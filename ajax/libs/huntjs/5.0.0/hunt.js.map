{"version":3,"file":"hunt.js","sources":["../src/noop.js","../src/throttle.js","../src/index.js"],"sourcesContent":["/**\n * Fallback function\n * @method noop\n * @returns {undefined}\n */\nexport default () => {}\n","const DEFAULT_THROTTLE_INTERVAL = 100\n\n/**\n * Throttles method execution to prevent some performance bottlenecks\n * @param {Function} fn method to throttle\n * @param {Number} interval milliseconds for the method to be delayed\n */\nfunction throttle(fn, interval = DEFAULT_THROTTLE_INTERVAL) {\n  let inThrottle\n  let lastFunc\n  let lastRan\n\n  return function() {\n    if (inThrottle === true) {\n      clearTimeout(lastFunc)\n      lastFunc = setTimeout(function() {\n        if (Date.now() - lastRan >= interval) {\n          fn.apply(this, arguments)\n          lastRan = Date.now()\n        }\n      }, interval - (Date.now() - lastRan))\n    } else {\n      fn.apply(this, arguments)\n      lastRan = Date.now()\n      inThrottle = true\n    }\n  }\n}\n\nexport default throttle\n","import noop from './noop'\nimport throttle from './throttle'\n\n/**\n * Constructor for element that should be hunted\n * @constructor Hunted\n * @param {Node} element\n * @param {Object} config\n */\nclass Hunted {\n  constructor(element, config) {\n    this.element = element\n\n    // instantiate element as not visible\n    this.visible = false\n\n    // extend properties from config or fallback to prototype values\n    for (var prop in config) {\n      if (Object.hasOwnProperty.call(config, prop)) {\n        this[prop] = config[prop]\n      }\n    }\n\n    // replace options with dataset if present\n    if (typeof element.dataset !== 'undefined') {\n      if (typeof element.dataset.huntPersist !== 'undefined') {\n        try {\n          this.persist = JSON.parse(element.dataset.huntPersist)\n        } catch (e) {}\n      }\n      if (typeof element.dataset.huntOffset !== 'undefined') {\n        try {\n          this.offset = JSON.parse(element.dataset.huntOffset)\n        } catch (e) {}\n      }\n    }\n  }\n}\n\n// protoype values\nHunted.prototype.offset = 0\nHunted.prototype.persist = false\nHunted.prototype.enter = noop\nHunted.prototype.leave = noop\n\n/**\n * Creates and initializes observer\n * @constructor Hunt\n * @param {Node|NodeList|Array} target\n * @param {Object} options\n */\nclass Hunt {\n  constructor(target, options) {\n    // sanity check for first argument\n    const isValidTarget =\n      (target && target.nodeType === 1) || typeof target.length === 'number'\n    if (!isValidTarget) {\n      throw new TypeError(\n        'hunt: observer first argument should be a node or a list of nodes'\n      )\n    }\n    // sanity check for second argument\n    if (typeof options !== 'object') {\n      throw new TypeError('hunt: observer second argument should be an object')\n    }\n\n    // turn target to array\n    if (target.nodeType === 1) {\n      this.__huntedElements__ = [new Hunted(target, options)]\n    } else {\n      const targetArray = [].slice.call(target)\n      this.__huntedElements__ = targetArray.map((t) => new Hunted(t, options))\n    }\n\n    // hoist viewport metrics\n    this.__viewportHeight__ = window.innerHeight\n\n    // connect observer and pass in throttle interval\n    this.__connect__(options.throttleInterval)\n  }\n\n  /**\n   * Assign throttled actions and add listeners\n   * @param {Number} throttleInterval\n   * @method __connect__\n   * @memberof Hunt\n   */\n  __connect__(throttleInterval) {\n    // throttle actions\n    this.__throttledHuntElements__ = throttle(\n      this.__huntElements__.bind(this),\n      throttleInterval\n    )\n    this.__throttledUpdateMetrics__ = throttle(\n      this.__updateMetrics__.bind(this),\n      throttleInterval\n    )\n\n    // add listeners\n    window.addEventListener('scroll', this.__throttledHuntElements__)\n    window.addEventListener('resize', this.__throttledUpdateMetrics__)\n\n    // run first check\n    this.__huntElements__()\n  }\n\n  /**\n   * Checks if hunted elements are visible and apply callbacks\n   * @method __huntElements__\n   * @memberof Hunt\n   */\n  __huntElements__() {\n    let position = this.__huntedElements__.length\n\n    while (position) {\n      --position\n      const hunted = this.__huntedElements__[position]\n      const rect = hunted.element.getBoundingClientRect()\n      const isOnViewport =\n        rect.top - hunted.offset < this.__viewportHeight__ &&\n        rect.top >= -(rect.height + hunted.offset)\n\n      /*\n       * trigger (enter) event if element comes from a non visible state and the scrolled\n       * viewport has reached the visible range of the element without exceeding it\n       */\n      if (hunted.visible === false && isOnViewport === true) {\n        hunted.enter.call(null, hunted.element)\n        hunted.visible = true\n        // when the leave callback method is not set and hunting should not persist remove element\n        if (hunted.leave === noop && hunted.persist !== true) {\n          this.__huntedElements__.splice(position, 1)\n\n          // end observer activity when there are no more elements\n          if (this.__huntedElements__.length === 0) {\n            this.disconnect()\n          }\n        }\n      }\n\n      /*\n       * trigger (leave) event if element comes from a visible state\n       * and it's out of the visible range its bottom or top limit\n       */\n      if (hunted.visible === true && isOnViewport === false) {\n        hunted.leave.call(null, hunted.element)\n        hunted.visible = false\n        // when hunting should not persist remove element\n        if (hunted.persist !== true) {\n          this.__huntedElements__.splice(position, 1)\n\n          // end observer activity when there are no more elements\n          if (this.__huntedElements__.length === 0) {\n            this.disconnect()\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Update viewport tracked height and runs a check\n   * @method __updateMetrics__\n   * @memberof Hunt\n   */\n  __updateMetrics__() {\n    this.__viewportHeight__ = window.innerHeight\n    this.__huntElements__()\n  }\n\n  /**\n   * Remove listeners and stops observing elements\n   * @method disconnect\n   * @memberof Hunt\n   */\n  disconnect() {\n    // remove listeners\n    window.removeEventListener('scroll', this.__throttledHuntElements__)\n    window.removeEventListener('resize', this.__throttledUpdateMetrics__)\n  }\n\n  /**\n   * __huntElements__ public alias\n   * @method trigger\n   * @memberof Hunt\n   */\n  trigger() {\n    this.__huntElements__()\n  }\n}\n\nexport default Hunt\n"],"names":["DEFAULT_THROTTLE_INTERVAL","throttle","fn","interval","inThrottle","lastFunc","lastRan","clearTimeout","setTimeout","Date","now","apply","this","arguments","Hunted","constructor","element","config","prop","visible","Object","hasOwnProperty","call","dataset","huntPersist","persist","JSON","parse","e","huntOffset","offset","prototype","enter","noop","leave","Hunt","target","options","nodeType","length","TypeError","__huntedElements__","targetArray","slice","map","t","__viewportHeight__","window","innerHeight","__connect__","throttleInterval","__throttledHuntElements__","__huntElements__","bind","__throttledUpdateMetrics__","__updateMetrics__","addEventListener","position","hunted","rect","getBoundingClientRect","isOnViewport","top","height","splice","disconnect","removeEventListener","trigger"],"mappings":"AAKA,mBCLMA,EAA4B,IAOlC,SAASC,EAASC,EAAIC,OAChBC,EACAC,EACAC,wBAH2BN,GAKxB,YACc,IAAfI,GACFG,aAAaF,GACbA,EAAWG,WAAW,WAChBC,KAAKC,MAAQJ,GAAWH,IAC1BD,EAAGS,MAAMC,KAAMC,WACfP,EAAUG,KAAKC,QAEhBP,GAAYM,KAAKC,MAAQJ,MAE5BJ,EAAGS,MAAMC,KAAMC,WACfP,EAAUG,KAAKC,MACfN,GAAa,ICfnB,IAAMU,EACJC,SAAYC,EAASC,OAOd,IAAIC,UANJF,QAAUA,OAGVG,SAAU,EAGEF,EACXG,OAAOC,eAAeC,KAAKL,EAAQC,UAChCA,GAAQD,EAAOC,YAKO,IAApBF,EAAQO,QAAyB,SACC,IAAhCP,EAAQO,QAAQC,qBAElBC,QAAUC,KAAKC,MAAMX,EAAQO,QAAQC,aAC1C,MAAOI,YAE+B,IAA/BZ,EAAQO,QAAQM,oBAElBC,OAASJ,KAAKC,MAAMX,EAAQO,QAAQM,YACzC,MAAOD,OAOjBd,EAAOiB,UAAUD,OAAS,EAC1BhB,EAAOiB,UAAUN,SAAU,EAC3BX,EAAOiB,UAAUC,MAAQC,EACzBnB,EAAOiB,UAAUG,MAAQD,EAQzB,IAAME,EACJpB,SAAYqB,EAAQC,QAGfD,GAA8B,IAApBA,EAAOE,UAA4C,iBAAlBF,EAAOG,cAE7C,IAAIC,UACR,wEAImB,iBAAZH,QACH,IAAIG,UAAU,yDAIE,IAApBJ,EAAOE,cACJG,mBAAqB,CAAC,IAAI3B,EAAOsB,EAAQC,QACzC,KACCK,EAAc,GAAGC,MAAMrB,KAAKc,QAC7BK,mBAAqBC,EAAYE,aAAKC,UAAM,IAAI/B,EAAO+B,EAAGR,UAI5DS,mBAAqBC,OAAOC,iBAG5BC,YAAYZ,EAAQa,mBAS3BD,YAAAA,qBAAYC,QAELC,0BAA4BlD,EAC/BW,KAAKwC,iBAAiBC,KAAKzC,MAC3BsC,QAEGI,2BAA6BrD,EAChCW,KAAK2C,kBAAkBF,KAAKzC,MAC5BsC,UAIKM,iBAAiB,SAAU5C,KAAKuC,kCAChCK,iBAAiB,SAAU5C,KAAK0C,iCAGlCF,oBAQPA,YAAAA,oCACMK,EAAW7C,KAAK6B,mBAAmBF,OAEhCkB,GAAU,KAETC,EAAS9C,KAAK6B,qBADlBgB,GAEIE,EAAOD,EAAO1C,QAAQ4C,wBACtBC,EACJF,EAAKG,IAAMJ,EAAO5B,OAASlB,KAAKkC,oBAChCa,EAAKG,OAASH,EAAKI,OAASL,EAAO5B,SAMd,IAAnB4B,EAAOvC,UAAsC,IAAjB0C,IAC9BH,EAAO1B,MAAMV,KAAK,KAAMoC,EAAO1C,SAC/B0C,EAAOvC,SAAU,EAEbuC,EAAOxB,QAAUD,IAA2B,IAAnByB,EAAOjC,eAC7BgB,mBAAmBuB,OAAOP,EAAU,GAGF,IAAnC7C,KAAK6B,mBAAmBF,aACrB0B,gBASY,IAAnBP,EAAOvC,UAAqC,IAAjB0C,IAC7BH,EAAOxB,MAAMZ,KAAK,KAAMoC,EAAO1C,SAC/B0C,EAAOvC,SAAU,GAEM,IAAnBuC,EAAOjC,eACJgB,mBAAmBuB,OAAOP,EAAU,GAGF,IAAnC7C,KAAK6B,mBAAmBF,aACrB0B,iBAYfV,YAAAA,kCACOT,mBAAqBC,OAAOC,iBAC5BI,oBAQPa,YAAAA,6BAESC,oBAAoB,SAAUtD,KAAKuC,kCACnCe,oBAAoB,SAAUtD,KAAK0C,6BAQ5Ca,YAAAA,wBACOf"}