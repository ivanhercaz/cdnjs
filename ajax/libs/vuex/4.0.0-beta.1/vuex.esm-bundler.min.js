import{inject,watch,reactive,computed}from"vue";const storeKey="store";function useStore(e=null){return inject(null!==e?e:storeKey)}const target="undefined"!=typeof window?window:"undefined"!=typeof global?global:{},devtoolHook=target.__VUE_DEVTOOLS_GLOBAL_HOOK__;function devtoolPlugin(e){devtoolHook&&(e._devtoolHook=devtoolHook,devtoolHook.emit("vuex:init",e),devtoolHook.on("vuex:travel-to-state",t=>{e.replaceState(t)}),e.subscribe((e,t)=>{devtoolHook.emit("vuex:mutation",e,t)},{prepend:!0}),e.subscribeAction((e,t)=>{devtoolHook.emit("vuex:action",e,t)},{prepend:!0}))}function forEachValue(e,t){Object.keys(e).forEach(o=>t(e[o],o))}function isObject(e){return null!==e&&"object"==typeof e}function isPromise(e){return e&&"function"==typeof e.then}function assert(e,t){if(!e)throw new Error(`[vuex] ${t}`)}function partial(e,t){return function(){return e(t)}}class Module{constructor(e,t){this.runtime=t,this._children=Object.create(null),this._rawModule=e;const o=e.state;this.state=("function"==typeof o?o():o)||{}}get namespaced(){return!!this._rawModule.namespaced}addChild(e,t){this._children[e]=t}removeChild(e){delete this._children[e]}getChild(e){return this._children[e]}hasChild(e){return e in this._children}update(e){this._rawModule.namespaced=e.namespaced,e.actions&&(this._rawModule.actions=e.actions),e.mutations&&(this._rawModule.mutations=e.mutations),e.getters&&(this._rawModule.getters=e.getters)}forEachChild(e){forEachValue(this._children,e)}forEachGetter(e){this._rawModule.getters&&forEachValue(this._rawModule.getters,e)}forEachAction(e){this._rawModule.actions&&forEachValue(this._rawModule.actions,e)}forEachMutation(e){this._rawModule.mutations&&forEachValue(this._rawModule.mutations,e)}}class ModuleCollection{constructor(e){this.register([],e,!1)}get(e){return e.reduce((e,t)=>e.getChild(t),this.root)}getNamespace(e){let t=this.root;return e.reduce((e,o)=>e+((t=t.getChild(o)).namespaced?o+"/":""),"")}update(e){update([],this.root,e)}register(e,t,o=!0){"production"!==process.env.NODE_ENV&&assertRawModule(e,t);const s=new Module(t,o);if(0===e.length)this.root=s;else{this.get(e.slice(0,-1)).addChild(e[e.length-1],s)}t.modules&&forEachValue(t.modules,(t,s)=>{this.register(e.concat(s),t,o)})}unregister(e){const t=this.get(e.slice(0,-1)),o=e[e.length-1];t.getChild(o).runtime&&t.removeChild(o)}isRegistered(e){const t=this.get(e.slice(0,-1)),o=e[e.length-1];return t.hasChild(o)}}function update(e,t,o){if("production"!==process.env.NODE_ENV&&assertRawModule(e,o),t.update(o),o.modules)for(const s in o.modules){if(!t.getChild(s))return void("production"!==process.env.NODE_ENV&&console.warn(`[vuex] trying to add a new module '${s}' on hot reloading, `+"manual reload is needed"));update(e.concat(s),t.getChild(s),o.modules[s])}}const functionAssert={assert:e=>"function"==typeof e,expected:"function"},objectAssert={assert:e=>"function"==typeof e||"object"==typeof e&&"function"==typeof e.handler,expected:'function or object with "handler" function'},assertTypes={getters:functionAssert,mutations:functionAssert,actions:objectAssert};function assertRawModule(e,t){Object.keys(assertTypes).forEach(o=>{if(!t[o])return;const s=assertTypes[o];forEachValue(t[o],(t,r)=>{assert(s.assert(t),makeAssertionMessage(e,o,r,t,s.expected))})})}function makeAssertionMessage(e,t,o,s,r){let n=`${t} should be ${r} but "${t}.${o}"`;return e.length>0&&(n+=` in module "${e.join(".")}"`),n+=` is ${JSON.stringify(s)}.`}function createStore(e){return new Store(e)}class Store{constructor(e={}){"production"!==process.env.NODE_ENV&&(assert("undefined"!=typeof Promise,"vuex requires a Promise polyfill in this browser."),assert(this instanceof Store,"store must be called with the new operator."));const{plugins:t=[],strict:o=!1}=e;this._committing=!1,this._actions=Object.create(null),this._actionSubscribers=[],this._mutations=Object.create(null),this._wrappedGetters=Object.create(null),this._modules=new ModuleCollection(e),this._modulesNamespaceMap=Object.create(null),this._subscribers=[],this._makeLocalGettersCache=Object.create(null);const s=this,{dispatch:r,commit:n}=this;this.dispatch=function(e,t){return r.call(s,e,t)},this.commit=function(e,t,o){return n.call(s,e,t,o)},this.strict=o;const a=this._modules.root.state;installModule(this,a,[],this._modules.root),resetStoreState(this,a),t.forEach(e=>e(this)),(void 0===e.devtools||e.devtools)&&devtoolPlugin(this)}install(e,t){e.provide(t||storeKey,this),e.config.globalProperties.$store=this}get state(){return this._state.data}set state(e){"production"!==process.env.NODE_ENV&&assert(!1,"use store.replaceState() to explicit replace store state.")}commit(e,t,o){const{type:s,payload:r,options:n}=unifyObjectStyle(e,t,o),a={type:s,payload:r},i=this._mutations[s];i?(this._withCommit(()=>{i.forEach(function(e){e(r)})}),this._subscribers.slice().forEach(e=>e(a,this.state)),"production"!==process.env.NODE_ENV&&n&&n.silent&&console.warn(`[vuex] mutation type: ${s}. Silent option has been removed. `+"Use the filter functionality in the vue-devtools")):"production"!==process.env.NODE_ENV&&console.error(`[vuex] unknown mutation type: ${s}`)}dispatch(e,t){const{type:o,payload:s}=unifyObjectStyle(e,t),r={type:o,payload:s},n=this._actions[o];if(n){try{this._actionSubscribers.slice().filter(e=>e.before).forEach(e=>e.before(r,this.state))}catch(e){"production"!==process.env.NODE_ENV&&(console.warn("[vuex] error in before action subscribers: "),console.error(e))}return(n.length>1?Promise.all(n.map(e=>e(s))):n[0](s)).then(e=>{try{this._actionSubscribers.filter(e=>e.after).forEach(e=>e.after(r,this.state))}catch(e){"production"!==process.env.NODE_ENV&&(console.warn("[vuex] error in after action subscribers: "),console.error(e))}return e})}"production"!==process.env.NODE_ENV&&console.error(`[vuex] unknown action type: ${o}`)}subscribe(e,t){return genericSubscribe(e,this._subscribers,t)}subscribeAction(e,t){return genericSubscribe("function"==typeof e?{before:e}:e,this._actionSubscribers,t)}watch(e,t,o){return"production"!==process.env.NODE_ENV&&assert("function"==typeof e,"store.watch only accepts a function."),watch(()=>e(this.state,this.getters),t,Object.assign({},o))}replaceState(e){this._withCommit(()=>{this._state.data=e})}registerModule(e,t,o={}){"string"==typeof e&&(e=[e]),"production"!==process.env.NODE_ENV&&(assert(Array.isArray(e),"module path must be a string or an Array."),assert(e.length>0,"cannot register the root module by using registerModule.")),this._modules.register(e,t),installModule(this,this.state,e,this._modules.get(e),o.preserveState),resetStoreState(this,this.state)}unregisterModule(e){"string"==typeof e&&(e=[e]),"production"!==process.env.NODE_ENV&&assert(Array.isArray(e),"module path must be a string or an Array."),this._modules.unregister(e),this._withCommit(()=>{delete getNestedState(this.state,e.slice(0,-1))[e[e.length-1]]}),resetStore(this)}hasModule(e){return"string"==typeof e&&(e=[e]),"production"!==process.env.NODE_ENV&&assert(Array.isArray(e),"module path must be a string or an Array."),this._modules.isRegistered(e)}hotUpdate(e){this._modules.update(e),resetStore(this,!0)}_withCommit(e){const t=this._committing;this._committing=!0,e(),this._committing=t}}function genericSubscribe(e,t,o){return t.indexOf(e)<0&&(o&&o.prepend?t.unshift(e):t.push(e)),()=>{const o=t.indexOf(e);o>-1&&t.splice(o,1)}}function resetStore(e,t){e._actions=Object.create(null),e._mutations=Object.create(null),e._wrappedGetters=Object.create(null),e._modulesNamespaceMap=Object.create(null);const o=e.state;installModule(e,o,[],e._modules.root,!0),resetStoreState(e,o,t)}function resetStoreState(e,t,o){const s=e._state;e.getters={},e._makeLocalGettersCache=Object.create(null);const r=e._wrappedGetters,n={};forEachValue(r,(t,o)=>{n[o]=partial(t,e),Object.defineProperty(e.getters,o,{get:()=>computed(()=>n[o]()).value,enumerable:!0})}),e._state=reactive({data:t}),e.strict&&enableStrictMode(e),s&&o&&e._withCommit(()=>{s.data=null})}function installModule(e,t,o,s,r){const n=!o.length,a=e._modules.getNamespace(o);if(s.namespaced&&(e._modulesNamespaceMap[a]&&"production"!==process.env.NODE_ENV&&console.error(`[vuex] duplicate namespace ${a} for the namespaced module ${o.join("/")}`),e._modulesNamespaceMap[a]=s),!n&&!r){const r=getNestedState(t,o.slice(0,-1)),n=o[o.length-1];e._withCommit(()=>{"production"!==process.env.NODE_ENV&&n in r&&console.warn(`[vuex] state field "${n}" was overridden by a module with the same name at "${o.join(".")}"`),r[n]=s.state})}const i=s.context=makeLocalContext(e,a,o);s.forEachMutation((t,o)=>{registerMutation(e,a+o,t,i)}),s.forEachAction((t,o)=>{const s=t.root?o:a+o,r=t.handler||t;registerAction(e,s,r,i)}),s.forEachGetter((t,o)=>{registerGetter(e,a+o,t,i)}),s.forEachChild((s,n)=>{installModule(e,t,o.concat(n),s,r)})}function makeLocalContext(e,t,o){const s=""===t,r={dispatch:s?e.dispatch:(o,s,r)=>{const n=unifyObjectStyle(o,s,r),{payload:a,options:i}=n;let{type:c}=n;if(i&&i.root||(c=t+c,"production"===process.env.NODE_ENV||e._actions[c]))return e.dispatch(c,a);console.error(`[vuex] unknown local action type: ${n.type}, global type: ${c}`)},commit:s?e.commit:(o,s,r)=>{const n=unifyObjectStyle(o,s,r),{payload:a,options:i}=n;let{type:c}=n;i&&i.root||(c=t+c,"production"===process.env.NODE_ENV||e._mutations[c])?e.commit(c,a,i):console.error(`[vuex] unknown local mutation type: ${n.type}, global type: ${c}`)}};return Object.defineProperties(r,{getters:{get:s?()=>e.getters:()=>makeLocalGetters(e,t)},state:{get:()=>getNestedState(e.state,o)}}),r}function makeLocalGetters(e,t){if(!e._makeLocalGettersCache[t]){const o={},s=t.length;Object.keys(e.getters).forEach(r=>{if(r.slice(0,s)!==t)return;const n=r.slice(s);Object.defineProperty(o,n,{get:()=>e.getters[r],enumerable:!0})}),e._makeLocalGettersCache[t]=o}return e._makeLocalGettersCache[t]}function registerMutation(e,t,o,s){(e._mutations[t]||(e._mutations[t]=[])).push(function(t){o.call(e,s.state,t)})}function registerAction(e,t,o,s){(e._actions[t]||(e._actions[t]=[])).push(function(t){let r=o.call(e,{dispatch:s.dispatch,commit:s.commit,getters:s.getters,state:s.state,rootGetters:e.getters,rootState:e.state},t);return isPromise(r)||(r=Promise.resolve(r)),e._devtoolHook?r.catch(t=>{throw e._devtoolHook.emit("vuex:error",t),t}):r})}function registerGetter(e,t,o,s){e._wrappedGetters[t]?"production"!==process.env.NODE_ENV&&console.error(`[vuex] duplicate getter key: ${t}`):e._wrappedGetters[t]=function(e){return o(s.state,s.getters,e.state,e.getters)}}function enableStrictMode(e){watch(()=>e._state.data,()=>{"production"!==process.env.NODE_ENV&&assert(e._committing,"do not mutate vuex store state outside mutation handlers.")},{deep:!0,flush:"sync"})}function getNestedState(e,t){return t.reduce((e,t)=>e[t],e)}function unifyObjectStyle(e,t,o){return isObject(e)&&e.type&&(o=t,t=e,e=e.type),"production"!==process.env.NODE_ENV&&assert("string"==typeof e,`expects string as the type, but found ${typeof e}.`),{type:e,payload:t,options:o}}const mapState=normalizeNamespace((e,t)=>{const o={};return"production"===process.env.NODE_ENV||isValidMap(t)||console.error("[vuex] mapState: mapper parameter must be either an Array or an Object"),normalizeMap(t).forEach(({key:t,val:s})=>{o[t]=function(){let t=this.$store.state,o=this.$store.getters;if(e){const s=getModuleByNamespace(this.$store,"mapState",e);if(!s)return;t=s.context.state,o=s.context.getters}return"function"==typeof s?s.call(this,t,o):t[s]},o[t].vuex=!0}),o}),mapMutations=normalizeNamespace((e,t)=>{const o={};return"production"===process.env.NODE_ENV||isValidMap(t)||console.error("[vuex] mapMutations: mapper parameter must be either an Array or an Object"),normalizeMap(t).forEach(({key:t,val:s})=>{o[t]=function(...t){let o=this.$store.commit;if(e){const t=getModuleByNamespace(this.$store,"mapMutations",e);if(!t)return;o=t.context.commit}return"function"==typeof s?s.apply(this,[o].concat(t)):o.apply(this.$store,[s].concat(t))}}),o}),mapGetters=normalizeNamespace((e,t)=>{const o={};return"production"===process.env.NODE_ENV||isValidMap(t)||console.error("[vuex] mapGetters: mapper parameter must be either an Array or an Object"),normalizeMap(t).forEach(({key:t,val:s})=>{s=e+s,o[t]=function(){if(!e||getModuleByNamespace(this.$store,"mapGetters",e)){if("production"===process.env.NODE_ENV||s in this.$store.getters)return this.$store.getters[s];console.error(`[vuex] unknown getter: ${s}`)}},o[t].vuex=!0}),o}),mapActions=normalizeNamespace((e,t)=>{const o={};return"production"===process.env.NODE_ENV||isValidMap(t)||console.error("[vuex] mapActions: mapper parameter must be either an Array or an Object"),normalizeMap(t).forEach(({key:t,val:s})=>{o[t]=function(...t){let o=this.$store.dispatch;if(e){const t=getModuleByNamespace(this.$store,"mapActions",e);if(!t)return;o=t.context.dispatch}return"function"==typeof s?s.apply(this,[o].concat(t)):o.apply(this.$store,[s].concat(t))}}),o}),createNamespacedHelpers=e=>({mapState:mapState.bind(null,e),mapGetters:mapGetters.bind(null,e),mapMutations:mapMutations.bind(null,e),mapActions:mapActions.bind(null,e)});function normalizeMap(e){return isValidMap(e)?Array.isArray(e)?e.map(e=>({key:e,val:e})):Object.keys(e).map(t=>({key:t,val:e[t]})):[]}function isValidMap(e){return Array.isArray(e)||isObject(e)}function normalizeNamespace(e){return(t,o)=>("string"!=typeof t?(o=t,t=""):"/"!==t.charAt(t.length-1)&&(t+="/"),e(t,o))}function getModuleByNamespace(e,t,o){const s=e._modulesNamespaceMap[o];return"production"===process.env.NODE_ENV||s||console.error(`[vuex] module namespace not found in ${t}(): ${o}`),s}var index={version:"__VERSION__",createStore:createStore,Store:Store,useStore:useStore,mapState:mapState,mapMutations:mapMutations,mapGetters:mapGetters,mapActions:mapActions,createNamespacedHelpers:createNamespacedHelpers};export default index;export{Store,createNamespacedHelpers,createStore,mapActions,mapGetters,mapMutations,mapState,useStore};