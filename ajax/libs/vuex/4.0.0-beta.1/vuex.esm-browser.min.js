import{inject,watch,reactive,computed}from"vue";const storeKey="store";function useStore(t=null){return inject(null!==t?t:storeKey)}const target="undefined"!=typeof window?window:"undefined"!=typeof global?global:{},devtoolHook=target.__VUE_DEVTOOLS_GLOBAL_HOOK__;function devtoolPlugin(t){devtoolHook&&(t._devtoolHook=devtoolHook,devtoolHook.emit("vuex:init",t),devtoolHook.on("vuex:travel-to-state",e=>{t.replaceState(e)}),t.subscribe((t,e)=>{devtoolHook.emit("vuex:mutation",t,e)},{prepend:!0}),t.subscribeAction((t,e)=>{devtoolHook.emit("vuex:action",t,e)},{prepend:!0}))}function forEachValue(t,e){Object.keys(t).forEach(o=>e(t[o],o))}function isObject(t){return null!==t&&"object"==typeof t}function isPromise(t){return t&&"function"==typeof t.then}function assert(t,e){if(!t)throw new Error(`[vuex] ${e}`)}function partial(t,e){return function(){return t(e)}}class Module{constructor(t,e){this.runtime=e,this._children=Object.create(null),this._rawModule=t;const o=t.state;this.state=("function"==typeof o?o():o)||{}}get namespaced(){return!!this._rawModule.namespaced}addChild(t,e){this._children[t]=e}removeChild(t){delete this._children[t]}getChild(t){return this._children[t]}hasChild(t){return t in this._children}update(t){this._rawModule.namespaced=t.namespaced,t.actions&&(this._rawModule.actions=t.actions),t.mutations&&(this._rawModule.mutations=t.mutations),t.getters&&(this._rawModule.getters=t.getters)}forEachChild(t){forEachValue(this._children,t)}forEachGetter(t){this._rawModule.getters&&forEachValue(this._rawModule.getters,t)}forEachAction(t){this._rawModule.actions&&forEachValue(this._rawModule.actions,t)}forEachMutation(t){this._rawModule.mutations&&forEachValue(this._rawModule.mutations,t)}}class ModuleCollection{constructor(t){this.register([],t,!1)}get(t){return t.reduce((t,e)=>t.getChild(e),this.root)}getNamespace(t){let e=this.root;return t.reduce((t,o)=>t+((e=e.getChild(o)).namespaced?o+"/":""),"")}update(t){update([],this.root,t)}register(t,e,o=!0){assertRawModule(t,e);const s=new Module(e,o);if(0===t.length)this.root=s;else{this.get(t.slice(0,-1)).addChild(t[t.length-1],s)}e.modules&&forEachValue(e.modules,(e,s)=>{this.register(t.concat(s),e,o)})}unregister(t){const e=this.get(t.slice(0,-1)),o=t[t.length-1];e.getChild(o).runtime&&e.removeChild(o)}isRegistered(t){const e=this.get(t.slice(0,-1)),o=t[t.length-1];return e.hasChild(o)}}function update(t,e,o){if(assertRawModule(t,o),e.update(o),o.modules)for(const s in o.modules){if(!e.getChild(s))return void console.warn(`[vuex] trying to add a new module '${s}' on hot reloading, `+"manual reload is needed");update(t.concat(s),e.getChild(s),o.modules[s])}}const functionAssert={assert:t=>"function"==typeof t,expected:"function"},objectAssert={assert:t=>"function"==typeof t||"object"==typeof t&&"function"==typeof t.handler,expected:'function or object with "handler" function'},assertTypes={getters:functionAssert,mutations:functionAssert,actions:objectAssert};function assertRawModule(t,e){Object.keys(assertTypes).forEach(o=>{if(!e[o])return;const s=assertTypes[o];forEachValue(e[o],(e,r)=>{assert(s.assert(e),makeAssertionMessage(t,o,r,e,s.expected))})})}function makeAssertionMessage(t,e,o,s,r){let a=`${e} should be ${r} but "${e}.${o}"`;return t.length>0&&(a+=` in module "${t.join(".")}"`),a+=` is ${JSON.stringify(s)}.`}function createStore(t){return new Store(t)}class Store{constructor(t={}){"production"!==process.env.NODE_ENV&&(assert("undefined"!=typeof Promise,"vuex requires a Promise polyfill in this browser."),assert(this instanceof Store,"store must be called with the new operator."));const{plugins:e=[],strict:o=!1}=t;this._committing=!1,this._actions=Object.create(null),this._actionSubscribers=[],this._mutations=Object.create(null),this._wrappedGetters=Object.create(null),this._modules=new ModuleCollection(t),this._modulesNamespaceMap=Object.create(null),this._subscribers=[],this._makeLocalGettersCache=Object.create(null);const s=this,{dispatch:r,commit:a}=this;this.dispatch=function(t,e){return r.call(s,t,e)},this.commit=function(t,e,o){return a.call(s,t,e,o)},this.strict=o;const n=this._modules.root.state;installModule(this,n,[],this._modules.root),resetStoreState(this,n),e.forEach(t=>t(this)),(void 0===t.devtools||t.devtools)&&devtoolPlugin(this)}install(t,e){t.provide(e||storeKey,this),t.config.globalProperties.$store=this}get state(){return this._state.data}set state(t){assert(!1,"use store.replaceState() to explicit replace store state.")}commit(t,e,o){const{type:s,payload:r,options:a}=unifyObjectStyle(t,e,o),n={type:s,payload:r},i=this._mutations[s];i?(this._withCommit(()=>{i.forEach(function(t){t(r)})}),this._subscribers.slice().forEach(t=>t(n,this.state)),a&&a.silent&&console.warn(`[vuex] mutation type: ${s}. Silent option has been removed. `+"Use the filter functionality in the vue-devtools")):console.error(`[vuex] unknown mutation type: ${s}`)}dispatch(t,e){const{type:o,payload:s}=unifyObjectStyle(t,e),r={type:o,payload:s},a=this._actions[o];if(a){try{this._actionSubscribers.slice().filter(t=>t.before).forEach(t=>t.before(r,this.state))}catch(t){console.warn("[vuex] error in before action subscribers: "),console.error(t)}return(a.length>1?Promise.all(a.map(t=>t(s))):a[0](s)).then(t=>{try{this._actionSubscribers.filter(t=>t.after).forEach(t=>t.after(r,this.state))}catch(t){console.warn("[vuex] error in after action subscribers: "),console.error(t)}return t})}console.error(`[vuex] unknown action type: ${o}`)}subscribe(t,e){return genericSubscribe(t,this._subscribers,e)}subscribeAction(t,e){return genericSubscribe("function"==typeof t?{before:t}:t,this._actionSubscribers,e)}watch(t,e,o){return assert("function"==typeof t,"store.watch only accepts a function."),watch(()=>t(this.state,this.getters),e,Object.assign({},o))}replaceState(t){this._withCommit(()=>{this._state.data=t})}registerModule(t,e,o={}){"string"==typeof t&&(t=[t]),assert(Array.isArray(t),"module path must be a string or an Array."),assert(t.length>0,"cannot register the root module by using registerModule."),this._modules.register(t,e),installModule(this,this.state,t,this._modules.get(t),o.preserveState),resetStoreState(this,this.state)}unregisterModule(t){"string"==typeof t&&(t=[t]),assert(Array.isArray(t),"module path must be a string or an Array."),this._modules.unregister(t),this._withCommit(()=>{delete getNestedState(this.state,t.slice(0,-1))[t[t.length-1]]}),resetStore(this)}hasModule(t){return"string"==typeof t&&(t=[t]),"production"!==process.env.NODE_ENV&&assert(Array.isArray(t),"module path must be a string or an Array."),this._modules.isRegistered(t)}hotUpdate(t){this._modules.update(t),resetStore(this,!0)}_withCommit(t){const e=this._committing;this._committing=!0,t(),this._committing=e}}function genericSubscribe(t,e,o){return e.indexOf(t)<0&&(o&&o.prepend?e.unshift(t):e.push(t)),()=>{const o=e.indexOf(t);o>-1&&e.splice(o,1)}}function resetStore(t,e){t._actions=Object.create(null),t._mutations=Object.create(null),t._wrappedGetters=Object.create(null),t._modulesNamespaceMap=Object.create(null);const o=t.state;installModule(t,o,[],t._modules.root,!0),resetStoreState(t,o,e)}function resetStoreState(t,e,o){const s=t._state;t.getters={},t._makeLocalGettersCache=Object.create(null);const r=t._wrappedGetters,a={};forEachValue(r,(e,o)=>{a[o]=partial(e,t),Object.defineProperty(t.getters,o,{get:()=>computed(()=>a[o]()).value,enumerable:!0})}),t._state=reactive({data:e}),t.strict&&enableStrictMode(t),s&&o&&t._withCommit(()=>{s.data=null})}function installModule(t,e,o,s,r){const a=!o.length,n=t._modules.getNamespace(o);if(s.namespaced&&(t._modulesNamespaceMap[n]&&console.error(`[vuex] duplicate namespace ${n} for the namespaced module ${o.join("/")}`),t._modulesNamespaceMap[n]=s),!a&&!r){const r=getNestedState(e,o.slice(0,-1)),a=o[o.length-1];t._withCommit(()=>{a in r&&console.warn(`[vuex] state field "${a}" was overridden by a module with the same name at "${o.join(".")}"`),r[a]=s.state})}const i=s.context=makeLocalContext(t,n,o);s.forEachMutation((e,o)=>{registerMutation(t,n+o,e,i)}),s.forEachAction((e,o)=>{const s=e.root?o:n+o,r=e.handler||e;registerAction(t,s,r,i)}),s.forEachGetter((e,o)=>{registerGetter(t,n+o,e,i)}),s.forEachChild((s,a)=>{installModule(t,e,o.concat(a),s,r)})}function makeLocalContext(t,e,o){const s=""===e,r={dispatch:s?t.dispatch:(o,s,r)=>{const a=unifyObjectStyle(o,s,r),{payload:n,options:i}=a;let{type:c}=a;if(i&&i.root||(c=e+c,t._actions[c]))return t.dispatch(c,n);console.error(`[vuex] unknown local action type: ${a.type}, global type: ${c}`)},commit:s?t.commit:(o,s,r)=>{const a=unifyObjectStyle(o,s,r),{payload:n,options:i}=a;let{type:c}=a;i&&i.root||(c=e+c,t._mutations[c])?t.commit(c,n,i):console.error(`[vuex] unknown local mutation type: ${a.type}, global type: ${c}`)}};return Object.defineProperties(r,{getters:{get:s?()=>t.getters:()=>makeLocalGetters(t,e)},state:{get:()=>getNestedState(t.state,o)}}),r}function makeLocalGetters(t,e){if(!t._makeLocalGettersCache[e]){const o={},s=e.length;Object.keys(t.getters).forEach(r=>{if(r.slice(0,s)!==e)return;const a=r.slice(s);Object.defineProperty(o,a,{get:()=>t.getters[r],enumerable:!0})}),t._makeLocalGettersCache[e]=o}return t._makeLocalGettersCache[e]}function registerMutation(t,e,o,s){(t._mutations[e]||(t._mutations[e]=[])).push(function(e){o.call(t,s.state,e)})}function registerAction(t,e,o,s){(t._actions[e]||(t._actions[e]=[])).push(function(e){let r=o.call(t,{dispatch:s.dispatch,commit:s.commit,getters:s.getters,state:s.state,rootGetters:t.getters,rootState:t.state},e);return isPromise(r)||(r=Promise.resolve(r)),t._devtoolHook?r.catch(e=>{throw t._devtoolHook.emit("vuex:error",e),e}):r})}function registerGetter(t,e,o,s){t._wrappedGetters[e]?console.error(`[vuex] duplicate getter key: ${e}`):t._wrappedGetters[e]=function(t){return o(s.state,s.getters,t.state,t.getters)}}function enableStrictMode(t){watch(()=>t._state.data,()=>{assert(t._committing,"do not mutate vuex store state outside mutation handlers.")},{deep:!0,flush:"sync"})}function getNestedState(t,e){return e.reduce((t,e)=>t[e],t)}function unifyObjectStyle(t,e,o){return isObject(t)&&t.type&&(o=e,e=t,t=t.type),assert("string"==typeof t,`expects string as the type, but found ${typeof t}.`),{type:t,payload:e,options:o}}const mapState=normalizeNamespace((t,e)=>{const o={};return isValidMap(e)||console.error("[vuex] mapState: mapper parameter must be either an Array or an Object"),normalizeMap(e).forEach(({key:e,val:s})=>{o[e]=function(){let e=this.$store.state,o=this.$store.getters;if(t){const s=getModuleByNamespace(this.$store,"mapState",t);if(!s)return;e=s.context.state,o=s.context.getters}return"function"==typeof s?s.call(this,e,o):e[s]},o[e].vuex=!0}),o}),mapMutations=normalizeNamespace((t,e)=>{const o={};return isValidMap(e)||console.error("[vuex] mapMutations: mapper parameter must be either an Array or an Object"),normalizeMap(e).forEach(({key:e,val:s})=>{o[e]=function(...e){let o=this.$store.commit;if(t){const e=getModuleByNamespace(this.$store,"mapMutations",t);if(!e)return;o=e.context.commit}return"function"==typeof s?s.apply(this,[o].concat(e)):o.apply(this.$store,[s].concat(e))}}),o}),mapGetters=normalizeNamespace((t,e)=>{const o={};return isValidMap(e)||console.error("[vuex] mapGetters: mapper parameter must be either an Array or an Object"),normalizeMap(e).forEach(({key:e,val:s})=>{s=t+s,o[e]=function(){if(!t||getModuleByNamespace(this.$store,"mapGetters",t)){if(s in this.$store.getters)return this.$store.getters[s];console.error(`[vuex] unknown getter: ${s}`)}},o[e].vuex=!0}),o}),mapActions=normalizeNamespace((t,e)=>{const o={};return isValidMap(e)||console.error("[vuex] mapActions: mapper parameter must be either an Array or an Object"),normalizeMap(e).forEach(({key:e,val:s})=>{o[e]=function(...e){let o=this.$store.dispatch;if(t){const e=getModuleByNamespace(this.$store,"mapActions",t);if(!e)return;o=e.context.dispatch}return"function"==typeof s?s.apply(this,[o].concat(e)):o.apply(this.$store,[s].concat(e))}}),o}),createNamespacedHelpers=t=>({mapState:mapState.bind(null,t),mapGetters:mapGetters.bind(null,t),mapMutations:mapMutations.bind(null,t),mapActions:mapActions.bind(null,t)});function normalizeMap(t){return isValidMap(t)?Array.isArray(t)?t.map(t=>({key:t,val:t})):Object.keys(t).map(e=>({key:e,val:t[e]})):[]}function isValidMap(t){return Array.isArray(t)||isObject(t)}function normalizeNamespace(t){return(e,o)=>("string"!=typeof e?(o=e,e=""):"/"!==e.charAt(e.length-1)&&(e+="/"),t(e,o))}function getModuleByNamespace(t,e,o){const s=t._modulesNamespaceMap[o];return s||console.error(`[vuex] module namespace not found in ${e}(): ${o}`),s}var index={version:"__VERSION__",createStore:createStore,Store:Store,useStore:useStore,mapState:mapState,mapMutations:mapMutations,mapGetters:mapGetters,mapActions:mapActions,createNamespacedHelpers:createNamespacedHelpers};export default index;export{Store,createNamespacedHelpers,createStore,mapActions,mapGetters,mapMutations,mapState,useStore};