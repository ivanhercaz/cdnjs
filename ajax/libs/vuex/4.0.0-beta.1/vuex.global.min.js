var Vuex=function(t){"use strict";const e="store";const o=("undefined"!=typeof window?window:"undefined"!=typeof global?global:{}).__VUE_DEVTOOLS_GLOBAL_HOOK__;function r(t,e){Object.keys(t).forEach(o=>e(t[o],o))}function s(t){return null!==t&&"object"==typeof t}function n(t,e){if(!t)throw new Error(`[vuex] ${e}`)}class i{constructor(t,e){this.runtime=e,this._children=Object.create(null),this._rawModule=t;const o=t.state;this.state=("function"==typeof o?o():o)||{}}get namespaced(){return!!this._rawModule.namespaced}addChild(t,e){this._children[t]=e}removeChild(t){delete this._children[t]}getChild(t){return this._children[t]}hasChild(t){return t in this._children}update(t){this._rawModule.namespaced=t.namespaced,t.actions&&(this._rawModule.actions=t.actions),t.mutations&&(this._rawModule.mutations=t.mutations),t.getters&&(this._rawModule.getters=t.getters)}forEachChild(t){r(this._children,t)}forEachGetter(t){this._rawModule.getters&&r(this._rawModule.getters,t)}forEachAction(t){this._rawModule.actions&&r(this._rawModule.actions,t)}forEachMutation(t){this._rawModule.mutations&&r(this._rawModule.mutations,t)}}class a{constructor(t){this.register([],t,!1)}get(t){return t.reduce((t,e)=>t.getChild(e),this.root)}getNamespace(t){let e=this.root;return t.reduce((t,o)=>t+((e=e.getChild(o)).namespaced?o+"/":""),"")}update(t){!function t(e,o,r){l(e,r);o.update(r);if(r.modules)for(const s in r.modules){if(!o.getChild(s))return void console.warn(`[vuex] trying to add a new module '${s}' on hot reloading, `+"manual reload is needed");t(e.concat(s),o.getChild(s),r.modules[s])}}([],this.root,t)}register(t,e,o=!0){l(t,e);const s=new i(e,o);if(0===t.length)this.root=s;else{this.get(t.slice(0,-1)).addChild(t[t.length-1],s)}e.modules&&r(e.modules,(e,r)=>{this.register(t.concat(r),e,o)})}unregister(t){const e=this.get(t.slice(0,-1)),o=t[t.length-1];e.getChild(o).runtime&&e.removeChild(o)}isRegistered(t){const e=this.get(t.slice(0,-1)),o=t[t.length-1];return e.hasChild(o)}}const c={assert:t=>"function"==typeof t,expected:"function"},u={getters:c,mutations:c,actions:{assert:t=>"function"==typeof t||"object"==typeof t&&"function"==typeof t.handler,expected:'function or object with "handler" function'}};function l(t,e){Object.keys(u).forEach(o=>{if(!e[o])return;const s=u[o];r(e[o],(e,r)=>{n(s.assert(e),function(t,e,o,r,s){let n=`${e} should be ${s} but "${e}.${o}"`;t.length>0&&(n+=` in module "${t.join(".")}"`);return n+=` is ${JSON.stringify(r)}.`}(t,o,r,e,s.expected))})})}class h{constructor(t={}){"production"!==process.env.NODE_ENV&&(n("undefined"!=typeof Promise,"vuex requires a Promise polyfill in this browser."),n(this instanceof h,"store must be called with the new operator."));const{plugins:e=[],strict:r=!1}=t;this._committing=!1,this._actions=Object.create(null),this._actionSubscribers=[],this._mutations=Object.create(null),this._wrappedGetters=Object.create(null),this._modules=new a(t),this._modulesNamespaceMap=Object.create(null),this._subscribers=[],this._makeLocalGettersCache=Object.create(null);const s=this,{dispatch:i,commit:c}=this;this.dispatch=function(t,e){return i.call(s,t,e)},this.commit=function(t,e,o){return c.call(s,t,e,o)},this.strict=r;const u=this._modules.root.state;f(this,u,[],this._modules.root),m(this,u),e.forEach(t=>t(this)),(void 0===t.devtools||t.devtools)&&function(t){o&&(t._devtoolHook=o,o.emit("vuex:init",t),o.on("vuex:travel-to-state",e=>{t.replaceState(e)}),t.subscribe((t,e)=>{o.emit("vuex:mutation",t,e)},{prepend:!0}),t.subscribeAction((t,e)=>{o.emit("vuex:action",t,e)},{prepend:!0}))}(this)}install(t,o){t.provide(o||e,this),t.config.globalProperties.$store=this}get state(){return this._state.data}set state(t){n(!1,"use store.replaceState() to explicit replace store state.")}commit(t,e,o){const{type:r,payload:s,options:n}=g(t,e,o),i={type:r,payload:s},a=this._mutations[r];a?(this._withCommit(()=>{a.forEach(function(t){t(s)})}),this._subscribers.slice().forEach(t=>t(i,this.state)),n&&n.silent&&console.warn(`[vuex] mutation type: ${r}. Silent option has been removed. `+"Use the filter functionality in the vue-devtools")):console.error(`[vuex] unknown mutation type: ${r}`)}dispatch(t,e){const{type:o,payload:r}=g(t,e),s={type:o,payload:r},n=this._actions[o];if(n){try{this._actionSubscribers.slice().filter(t=>t.before).forEach(t=>t.before(s,this.state))}catch(t){console.warn("[vuex] error in before action subscribers: "),console.error(t)}return(n.length>1?Promise.all(n.map(t=>t(r))):n[0](r)).then(t=>{try{this._actionSubscribers.filter(t=>t.after).forEach(t=>t.after(s,this.state))}catch(t){console.warn("[vuex] error in after action subscribers: "),console.error(t)}return t})}console.error(`[vuex] unknown action type: ${o}`)}subscribe(t,e){return p(t,this._subscribers,e)}subscribeAction(t,e){return p("function"==typeof t?{before:t}:t,this._actionSubscribers,e)}watch(e,o,r){return n("function"==typeof e,"store.watch only accepts a function."),t.watch(()=>e(this.state,this.getters),o,Object.assign({},r))}replaceState(t){this._withCommit(()=>{this._state.data=t})}registerModule(t,e,o={}){"string"==typeof t&&(t=[t]),n(Array.isArray(t),"module path must be a string or an Array."),n(t.length>0,"cannot register the root module by using registerModule."),this._modules.register(t,e),f(this,this.state,t,this._modules.get(t),o.preserveState),m(this,this.state)}unregisterModule(t){"string"==typeof t&&(t=[t]),n(Array.isArray(t),"module path must be a string or an Array."),this._modules.unregister(t),this._withCommit(()=>{delete _(this.state,t.slice(0,-1))[t[t.length-1]]}),d(this)}hasModule(t){return"string"==typeof t&&(t=[t]),"production"!==process.env.NODE_ENV&&n(Array.isArray(t),"module path must be a string or an Array."),this._modules.isRegistered(t)}hotUpdate(t){this._modules.update(t),d(this,!0)}_withCommit(t){const e=this._committing;this._committing=!0,t(),this._committing=e}}function p(t,e,o){return e.indexOf(t)<0&&(o&&o.prepend?e.unshift(t):e.push(t)),()=>{const o=e.indexOf(t);o>-1&&e.splice(o,1)}}function d(t,e){t._actions=Object.create(null),t._mutations=Object.create(null),t._wrappedGetters=Object.create(null),t._modulesNamespaceMap=Object.create(null);const o=t.state;f(t,o,[],t._modules.root,!0),m(t,o,e)}function m(e,o,s){const i=e._state;e.getters={},e._makeLocalGettersCache=Object.create(null);const a=e._wrappedGetters,c={};r(a,(o,r)=>{c[r]=function(t,e){return function(){return t(e)}}(o,e),Object.defineProperty(e.getters,r,{get:()=>t.computed(()=>c[r]()).value,enumerable:!0})}),e._state=t.reactive({data:o}),e.strict&&function(e){t.watch(()=>e._state.data,()=>{n(e._committing,"do not mutate vuex store state outside mutation handlers.")},{deep:!0,flush:"sync"})}(e),i&&s&&e._withCommit(()=>{i.data=null})}function f(t,e,o,r,s){const n=!o.length,i=t._modules.getNamespace(o);if(r.namespaced&&(t._modulesNamespaceMap[i]&&console.error(`[vuex] duplicate namespace ${i} for the namespaced module ${o.join("/")}`),t._modulesNamespaceMap[i]=r),!n&&!s){const s=_(e,o.slice(0,-1)),n=o[o.length-1];t._withCommit(()=>{n in s&&console.warn(`[vuex] state field "${n}" was overridden by a module with the same name at "${o.join(".")}"`),s[n]=r.state})}const a=r.context=function(t,e,o){const r=""===e,s={dispatch:r?t.dispatch:(o,r,s)=>{const n=g(o,r,s),{payload:i,options:a}=n;let{type:c}=n;if(a&&a.root||(c=e+c,t._actions[c]))return t.dispatch(c,i);console.error(`[vuex] unknown local action type: ${n.type}, global type: ${c}`)},commit:r?t.commit:(o,r,s)=>{const n=g(o,r,s),{payload:i,options:a}=n;let{type:c}=n;a&&a.root||(c=e+c,t._mutations[c])?t.commit(c,i,a):console.error(`[vuex] unknown local mutation type: ${n.type}, global type: ${c}`)}};return Object.defineProperties(s,{getters:{get:r?()=>t.getters:()=>(function(t,e){if(!t._makeLocalGettersCache[e]){const o={},r=e.length;Object.keys(t.getters).forEach(s=>{if(s.slice(0,r)!==e)return;const n=s.slice(r);Object.defineProperty(o,n,{get:()=>t.getters[s],enumerable:!0})}),t._makeLocalGettersCache[e]=o}return t._makeLocalGettersCache[e]})(t,e)},state:{get:()=>_(t.state,o)}}),s}(t,i,o);r.forEachMutation((e,o)=>{!function(t,e,o,r){(t._mutations[e]||(t._mutations[e]=[])).push(function(e){o.call(t,r.state,e)})}(t,i+o,e,a)}),r.forEachAction((e,o)=>{const r=e.root?o:i+o,s=e.handler||e;!function(t,e,o,r){(t._actions[e]||(t._actions[e]=[])).push(function(e){let s=o.call(t,{dispatch:r.dispatch,commit:r.commit,getters:r.getters,state:r.state,rootGetters:t.getters,rootState:t.state},e);var n;return(n=s)&&"function"==typeof n.then||(s=Promise.resolve(s)),t._devtoolHook?s.catch(e=>{throw t._devtoolHook.emit("vuex:error",e),e}):s})}(t,r,s,a)}),r.forEachGetter((e,o)=>{!function(t,e,o,r){if(t._wrappedGetters[e])return void console.error(`[vuex] duplicate getter key: ${e}`);t._wrappedGetters[e]=function(t){return o(r.state,r.getters,t.state,t.getters)}}(t,i+o,e,a)}),r.forEachChild((r,n)=>{f(t,e,o.concat(n),r,s)})}function _(t,e){return e.reduce((t,e)=>t[e],t)}function g(t,e,o){return s(t)&&t.type&&(o=e,e=t,t=t.type),n("string"==typeof t,`expects string as the type, but found ${typeof t}.`),{type:t,payload:e,options:o}}const y=O((t,e)=>{const o={};return $(e)||console.error("[vuex] mapState: mapper parameter must be either an Array or an Object"),x(e).forEach(({key:e,val:r})=>{o[e]=function(){let e=this.$store.state,o=this.$store.getters;if(t){const r=j(this.$store,"mapState",t);if(!r)return;e=r.context.state,o=r.context.getters}return"function"==typeof r?r.call(this,e,o):e[r]},o[e].vuex=!0}),o}),b=O((t,e)=>{const o={};return $(e)||console.error("[vuex] mapMutations: mapper parameter must be either an Array or an Object"),x(e).forEach(({key:e,val:r})=>{o[e]=function(...e){let o=this.$store.commit;if(t){const e=j(this.$store,"mapMutations",t);if(!e)return;o=e.context.commit}return"function"==typeof r?r.apply(this,[o].concat(e)):o.apply(this.$store,[r].concat(e))}}),o}),v=O((t,e)=>{const o={};return $(e)||console.error("[vuex] mapGetters: mapper parameter must be either an Array or an Object"),x(e).forEach(({key:e,val:r})=>{r=t+r,o[e]=function(){if(!t||j(this.$store,"mapGetters",t)){if(r in this.$store.getters)return this.$store.getters[r];console.error(`[vuex] unknown getter: ${r}`)}},o[e].vuex=!0}),o}),w=O((t,e)=>{const o={};return $(e)||console.error("[vuex] mapActions: mapper parameter must be either an Array or an Object"),x(e).forEach(({key:e,val:r})=>{o[e]=function(...e){let o=this.$store.dispatch;if(t){const e=j(this.$store,"mapActions",t);if(!e)return;o=e.context.dispatch}return"function"==typeof r?r.apply(this,[o].concat(e)):o.apply(this.$store,[r].concat(e))}}),o});function x(t){return $(t)?Array.isArray(t)?t.map(t=>({key:t,val:t})):Object.keys(t).map(e=>({key:e,val:t[e]})):[]}function $(t){return Array.isArray(t)||s(t)}function O(t){return(e,o)=>("string"!=typeof e?(o=e,e=""):"/"!==e.charAt(e.length-1)&&(e+="/"),t(e,o))}function j(t,e,o){const r=t._modulesNamespaceMap[o];return r||console.error(`[vuex] module namespace not found in ${e}(): ${o}`),r}return{version:"__VERSION__",createStore:function(t){return new h(t)},Store:h,useStore:function(o=null){return t.inject(null!==o?o:e)},mapState:y,mapMutations:b,mapGetters:v,mapActions:w,createNamespacedHelpers:t=>({mapState:y.bind(null,t),mapGetters:v.bind(null,t),mapMutations:b.bind(null,t),mapActions:w.bind(null,t)})}}(Vue);