"use strict";exports.__esModule=!0,exports.RECEIVE_MESSAGE_TYPES=void 0;var _src=require("zalgo-promise/src"),_src2=require("cross-domain-utils/src"),_src3=require("belter/src"),_conf=require("../../conf"),_send=require("../send"),_listeners=require("../listeners");function _extends(){return(_extends=Object.assign||function(e){for(var o=1;o<arguments.length;o++){var r=arguments[o];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e}).apply(this,arguments)}const RECEIVE_MESSAGE_TYPES={[_conf.MESSAGE_TYPE.REQUEST](e,o,r,{on:n,send:s}){const t=(0,_listeners.getRequestListener)({name:r.name,win:e,domain:o}),a=r.name===_conf.MESSAGE_NAME.METHOD&&r.data&&"string"==typeof r.data.name?`${r.data.name}()`:r.name;function i(t,i,E={}){if(!r.fireAndForget&&!(0,_src2.isWindowClosed)(e)){__DEBUG__&&t!==_conf.MESSAGE_TYPE.ACK&&(i===_conf.MESSAGE_ACK.SUCCESS?console.info("respond::res",a,o,"\n\n",E.data):i===_conf.MESSAGE_ACK.ERROR&&console.error("respond::err",a,o,"\n\n",E.error));try{(0,_send.sendMessage)(e,o,_extends({type:t,ack:i,hash:r.hash,name:r.name},E),{on:n,send:s})}catch(e){throw new Error(`Send response message failed for ${a} in ${(0,_src2.getDomain)()}\n\n${(0,_src3.stringifyError)(e)}`)}}}return __DEBUG__&&console.info("receive::req",a,o,"\n\n",r.data),_src.ZalgoPromise.all([i(_conf.MESSAGE_TYPE.ACK),_src.ZalgoPromise.try(()=>{if(!t)throw new Error(`No handler found for post message: ${r.name} from ${o} in ${window.location.protocol}//${window.location.host}${window.location.pathname}`);if(!(0,_src2.matchDomain)(t.domain,o))throw new Error(`Request origin ${o} does not match domain ${t.domain.toString()}`);const n=r.data;return t.handler({source:e,origin:o,data:n})}).then(e=>i(_conf.MESSAGE_TYPE.RESPONSE,_conf.MESSAGE_ACK.SUCCESS,{data:e}),e=>i(_conf.MESSAGE_TYPE.RESPONSE,_conf.MESSAGE_ACK.ERROR,{error:e}))]).then(_src3.noop).catch(e=>{if(t&&t.handleError)return t.handleError(e);throw e})},[_conf.MESSAGE_TYPE.ACK](e,o,r){if((0,_listeners.isResponseListenerErrored)(r.hash))return;const n=(0,_listeners.getResponseListener)(r.hash);if(!n)throw new Error(`No handler found for post message ack for message: ${r.name} from ${o} in ${window.location.protocol}//${window.location.host}${window.location.pathname}`);try{if(!(0,_src2.matchDomain)(n.domain,o))throw new Error(`Ack origin ${o} does not match domain ${n.domain.toString()}`);if(e!==n.win)throw new Error("Ack source does not match registered window")}catch(e){n.promise.reject(e)}n.ack=!0},[_conf.MESSAGE_TYPE.RESPONSE](e,o,r){if((0,_listeners.isResponseListenerErrored)(r.hash))return;const n=(0,_listeners.getResponseListener)(r.hash);if(!n)throw new Error(`No handler found for post message response for message: ${r.name} from ${o} in ${window.location.protocol}//${window.location.host}${window.location.pathname}`);if(!(0,_src2.matchDomain)(n.domain,o))throw new Error(`Response origin ${o} does not match domain ${(0,_src2.stringifyDomainPattern)(n.domain)}`);if(e!==n.win)throw new Error("Response source does not match registered window");(0,_listeners.deleteResponseListener)(r.hash);const s=r.name===_conf.MESSAGE_NAME.METHOD&&r.data&&"string"==typeof r.data.name?`${r.data.name}()`:r.name;r.ack===_conf.MESSAGE_ACK.ERROR?(__DEBUG__&&console.error("receive::err",s,o,"\n\n",r.error),n.promise.reject(r.error)):r.ack===_conf.MESSAGE_ACK.SUCCESS&&(__DEBUG__&&console.info("receive::res",s,o,"\n\n",r.data),n.promise.resolve({source:e,origin:o,data:r.data}))}};exports.RECEIVE_MESSAGE_TYPES=RECEIVE_MESSAGE_TYPES;