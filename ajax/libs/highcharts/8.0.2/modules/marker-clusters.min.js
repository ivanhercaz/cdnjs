!function(e){"object"==typeof module&&module.exports?module.exports=e.default=e:"function"==typeof define&&define.amd?define("highcharts/modules/marker-clusters",["highcharts"],function(t){return e(t),e.Highcharts=t,e}):e("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(t){function e(t,e,a,i){t.hasOwnProperty(e)||(t[e]=i.apply(null,a))}e(t=t?t._modules:{},"modules/marker-clusters.src.js",[t["parts/Globals.js"],t["parts/Point.js"],t["parts/Utilities.js"]],function(t,e,a){function P(t){var e,a=t.length,i=0,r=0;for(e=0;e<a;e++)i+=t[e].x,r+=t[e].y;return{x:i/a,y:r/a}}function s(t,e){var a=[];return a.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){a[t.dataIndex]=t})}),t.noise.forEach(function(t){a[t.data[0].dataIndex]=t.data[0]}),a}function x(t,e,a,i,r){t.point&&(i&&t.point.graphic&&(t.point.graphic.show(),t.point.graphic.attr({opacity:e}).animate({opacity:1},a)),r&&t.point.dataLabel&&(t.point.dataLabel.show(),t.point.dataLabel.attr({opacity:e}).animate({opacity:1},a)))}function g(t,e,a){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),a&&t.point.dataLabel&&t.point.dataLabel.hide())}function y(t,e,a,i){x(t,i,a,!0,!0),e.forEach(function(t){t.point&&t.point.destroy&&t.point.destroy()})}var X=this&&this.__read||function(t,e){var a="function"==typeof Symbol&&t[Symbol.iterator];if(!a)return t;t=a.call(t);var i,r=[];try{for(;(void 0===e||0<e--)&&!(i=t.next()).done;)r.push(i.value)}catch(t){var o={error:t}}finally{try{i&&!i.done&&(a=t.return)&&a.call(t)}finally{if(o)throw o.error}}return r},C=a.addEvent,I=a.animObject,Y=a.defined,k=a.error,b=a.isArray,v=a.isFunction,S=a.isObject,A=a.isNumber,M=a.merge,D=a.objectEach,L=a.relativeLength,z=a.syncTimeout;a=t.Series;var i=t.seriesTypes.scatter,r=t.SVGRenderer,E=a.prototype.generatePoints,O=0,n=[],T={enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}};(t.defaultOptions.plotOptions||{}).series=M((t.defaultOptions.plotOptions||{}).series,{cluster:T,tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}}),r.prototype.symbols.cluster=function(t,e,a,i){a/=2,i/=2;var r=this.arc(t+a,e+i,a-4,i-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),o=this.arc(t+a,e+i,a-3,i-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a-2,open:!1});return this.arc(t+a,e+i,a-1,i-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a,open:!1}).concat(o,r)},i.prototype.animateClusterPoint=function(t){var e=this.xAxis,a=this.yAxis,i=this.chart,r=I((this.options.cluster||{}).animation),o=r.duration||500,s=(this.markerClusterInfo||{}).pointsState,n=(s||{}).newState,l=(s||{}).oldState,p=[],u=s=0,d=0,h=!1,c=!1;if(l&&n){var f=n[t.stateId];if(u=e.toPixels(f.x)-i.plotLeft,d=a.toPixels(f.y)-i.plotTop,1===f.parentsId.length){t=(n||{})[t.stateId].parentsId[0];var m=l[t];f.point&&f.point.graphic&&m&&m.point&&m.point.plotX&&m.point.plotY&&m.point.plotX!==f.point.plotX&&m.point.plotY!==f.point.plotY&&(s=(t=f.point.graphic.getBBox()).width/2,f.point.graphic.attr({x:m.point.plotX-s,y:m.point.plotY-s}),f.point.graphic.animate({x:u-f.point.graphic.radius,y:d-f.point.graphic.radius},r,function(){c=!0,m.point&&m.point.destroy&&m.point.destroy()}),f.point.dataLabel&&f.point.dataLabel.alignAttr&&m.point.dataLabel&&m.point.dataLabel.alignAttr&&(f.point.dataLabel.attr({x:m.point.dataLabel.alignAttr.x,y:m.point.dataLabel.alignAttr.y}),f.point.dataLabel.animate({x:f.point.dataLabel.alignAttr.x,y:f.point.dataLabel.alignAttr.y},r)))}else 0===f.parentsId.length?(g(f,!0,!0),z(function(){x(f,.1,r,!0,!0)},o/2)):(g(f,!0,!0),f.parentsId.forEach(function(t){l&&l[t]&&(m=l[t],p.push(m),m.point&&m.point.graphic&&(h=!0,m.point.graphic.show(),m.point.graphic.animate({x:u-m.point.graphic.radius,y:d-m.point.graphic.radius,opacity:.4},r,function(){c=!0,y(f,p,r,.7)}),m.point.dataLabel&&-9999!==m.point.dataLabel.y&&f.point&&f.point.dataLabel&&f.point.dataLabel.alignAttr&&(m.point.dataLabel.show(),m.point.dataLabel.animate({x:f.point.dataLabel.alignAttr.x,y:f.point.dataLabel.alignAttr.y,opacity:.4},r))))}),z(function(){c||y(f,p,r,.85)},o),h||z(function(){y(f,p,r,.1)},o/2))}},i.prototype.getGridOffset=function(){var t=this.chart,e=this.xAxis,a=this.yAxis;return{plotLeft:e=this.dataMinX&&this.dataMaxX?e.reversed?e.toPixels(this.dataMaxX):e.toPixels(this.dataMinX):t.plotLeft,plotTop:t=this.dataMinY&&this.dataMaxY?a.reversed?a.toPixels(this.dataMinY):a.toPixels(this.dataMaxY):t.plotTop}},i.prototype.getScaledGridSize=function(t){var e=this.xAxis,a=!0,i=1,r=1;for(t=t.processedGridSize||T.layoutAlgorithm.gridSize,this.gridValueSize||(this.gridValueSize=Math.abs(e.toValue(t)-e.toValue(0))),e=+(t/(e=e.toPixels(this.gridValueSize)-e.toPixels(0))).toFixed(14);a&&1!==e;){var o=Math.pow(2,i);.75<e&&e<1.25?a=!1:1/o<=e&&e<1/o*2?(a=!1,r=o):e<=o&&o/2<e&&(a=!1,r=1/o),i++}return t/r/e},i.prototype.getRealExtremes=function(){var t=this.chart,e=this.xAxis,a=this.yAxis,i=e?e.toValue(t.plotLeft):0;e=e?e.toValue(t.plotLeft+t.plotWidth):0;var r=a?a.toValue(t.plotTop):0;return t=a?a.toValue(t.plotTop+t.plotHeight):0,e<i&&(e=(i=X([i,e],2))[0],i=i[1]),t<r&&(t=(r=X([r,t],2))[0],r=r[1]),{minX:i,maxX:e,minY:r,maxY:t}},i.prototype.onDrillToCluster=function(t){(t.point||t.target).firePointEvent("drillToCluster",t,function(t){var e=t.point||t.target,a=e.series.xAxis,i=e.series.yAxis,r=e.series.chart;if((e.series.options.cluster||{}).drillToCluster&&e.clusteredData){var o=e.clusteredData.map(function(t){return t.x}).sort(function(t,e){return t-e}),s=e.clusteredData.map(function(t){return t.y}).sort(function(t,e){return t-e});e=o[0];var n=o[o.length-1];o=s[0];var l=s[s.length-1];s=Math.abs(.1*(n-e));var p=Math.abs(.1*(l-o));r.pointer.zoomX=!0,r.pointer.zoomY=!0,n<e&&(e=(n=X([n,e],2))[0],n=n[1]),l<o&&(o=(l=X([l,o],2))[0],l=l[1]),r.zoom({originalEvent:t,xAxis:[{axis:a,min:e-s,max:n+s}],yAxis:[{axis:i,min:o-p,max:l+p}]})}})},i.prototype.getClusterDistancesFromPoint=function(t,e,a){var i,r=this.xAxis,o=this.yAxis,s=[];for(i=0;i<t.length;i++){var n=Math.sqrt(Math.pow(r.toPixels(e)-r.toPixels(t[i].posX),2)+Math.pow(o.toPixels(a)-o.toPixels(t[i].posY),2));s.push({clusterIndex:i,distance:n})}return s.sort(function(t,e){return t.distance-e.distance})},i.prototype.getPointsState=function(t,e,a){e=e?s(e,a):[],a=s(t,a);var i,r={};for(n=[],t.clusters.forEach(function(t){r[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){r[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),i=0;i<a.length;i++){t=a[i];var o=e[i];t&&o&&t.parentStateId&&o.parentStateId&&r[t.parentStateId]&&-1===r[t.parentStateId].parentsId.indexOf(o.parentStateId)&&(r[t.parentStateId].parentsId.push(o.parentStateId),-1===n.indexOf(o.parentStateId)&&n.push(o.parentStateId))}return r},i.prototype.markerClusterAlgorithms={grid:function(t,e,a,i){var r,o=this.xAxis,s=this.yAxis,n={},l=this.getGridOffset();for(i=this.getScaledGridSize(i),r=0;r<t.length;r++){var p=o.toPixels(t[r])-l.plotLeft,u=s.toPixels(e[r])-l.plotTop;p=Math.floor(p/i),n[u=(u=Math.floor(u/i))+"-"+p]||(n[u]=[]),n[u].push({dataIndex:a[r],x:t[r],y:e[r]})}return n},kmeans:function(t,e,a,i){var r,o=[],s=[],n={},l=i.processedDistance||T.layoutAlgorithm.distance,p=i.iterations,u=0,d=!0,h=0,c=0,f=[];for(r in i.processedGridSize=i.processedDistance,h=this.markerClusterAlgorithms?this.markerClusterAlgorithms.grid.call(this,t,e,a,i):{})1<h[r].length&&(f=P(h[r]),o.push({posX:f.x,posY:f.y,oldX:0,oldY:0,startPointsLen:h[r].length,points:[]}));for(;d;){for(o.map(function(t){return t.points.length=0,t}),d=s.length=0;d<t.length;d++)h=t[d],c=e[d],(f=this.getClusterDistancesFromPoint(o,h,c)).length&&f[0].distance<l?o[f[0].clusterIndex].points.push({x:h,y:c,dataIndex:a[d]}):s.push({x:h,y:c,dataIndex:a[d]});for(r=0;r<o.length;r++)1===o[r].points.length&&((f=this.getClusterDistancesFromPoint(o,o[r].points[0].x,o[r].points[0].y))[1].distance<l&&(o[f[1].clusterIndex].points.push(o[r].points[0]),o[f[0].clusterIndex].points.length=0));for(d=!1,r=0;r<o.length;r++)f=P(o[r].points),o[r].oldX=o[r].posX,o[r].oldY=o[r].posY,o[r].posX=f.x,o[r].posY=f.y,(o[r].posX>o[r].oldX+1||o[r].posX<o[r].oldX-1||o[r].posY>o[r].oldY+1||o[r].posY<o[r].oldY-1)&&(d=!0);p&&(d=u<p-1),u++}return o.forEach(function(t,e){n["cluster"+e]=t.points}),s.forEach(function(t,e){n["noise"+e]=[t]}),n},optimizedKmeans:function(t,e,a,i){var r,o,s=this.xAxis,n=this.yAxis,l=i.processedDistance||T.layoutAlgorithm.gridSize,p={},u=this.getRealExtremes(),d=(this.options.cluster||{}).marker;return!this.markerClusterInfo||this.initMaxX&&this.initMaxX<u.maxX||this.initMinX&&this.initMinX>u.minX||this.initMaxY&&this.initMaxY<u.maxY||this.initMinY&&this.initMinY>u.minY?(this.initMaxX=u.maxX,this.initMinX=u.minX,this.initMaxY=u.maxY,this.initMinY=u.minY,p=this.markerClusterAlgorithms?this.markerClusterAlgorithms.kmeans.call(this,t,e,a,i):{},this.baseClusters=null):(this.baseClusters||(this.baseClusters={clusters:this.markerClusterInfo.clusters,noise:this.markerClusterInfo.noise}),this.baseClusters.clusters.forEach(function(a){a.pointsOutside=[],a.pointsInside=[],a.data.forEach(function(t){r=Math.sqrt(Math.pow(s.toPixels(t.x)-s.toPixels(a.x),2)+Math.pow(n.toPixels(t.y)-n.toPixels(a.y),2)),(o=a.clusterZone&&a.clusterZone.marker&&a.clusterZone.marker.radius?a.clusterZone.marker.radius:d&&d.radius?d.radius:T.marker.radius)+(0<=l-o?l-o:o)<r&&Y(a.pointsOutside)?a.pointsOutside.push(t):Y(a.pointsInside)&&a.pointsInside.push(t)}),a.pointsInside.length&&(p[a.id]=a.pointsInside),a.pointsOutside.forEach(function(t,e){p[a.id+"_noise"+e]=[t]})}),this.baseClusters.noise.forEach(function(t){p[t.id]=t.data})),p}},i.prototype.preventClusterCollisions=function(t){var a=this.xAxis,i=this.yAxis,e=X(t.key.split("-").map(parseFloat),2),r=e[0],o=e[1],s=t.gridSize,n=t.groupedData,l=t.defaultRadius,p=t.clusterRadius,u=o*s,d=r*s,h=a.toPixels(t.x),c=i.toPixels(t.y);e=[];var f,m,x,g,y,C,I,k=0,b=0,v=(this.options.cluster||{}).marker,S=(this.options.cluster||{}).zones,A=this.getGridOffset();for(h-=A.plotLeft,c-=A.plotTop,x=1;x<5;x++){var M=x%2?-1:1,D=x<3?-1:1;for(M=Math.floor((h+M*p)/s),M=[(D=Math.floor((c+D*p)/s))+"-"+M,D+"-"+o,r+"-"+M],D=0;D<M.length;D++)-1===e.indexOf(M[D])&&M[D]!==t.key&&e.push(M[D])}return e.forEach(function(t){if(n[t]){n[t].posX||(C=P(n[t]),n[t].posX=C.x,n[t].posY=C.y),f=a.toPixels(n[t].posX||0)-A.plotLeft,m=i.toPixels(n[t].posY||0)-A.plotTop;var e=X(t.split("-").map(parseFloat),2);if(y=e[0],g=e[1],S)for(k=n[t].length,x=0;x<S.length;x++)k>=S[x].from&&k<=S[x].to&&(b=Y((S[x].marker||{}).radius)?S[x].marker.radius||0:v&&v.radius?v.radius:T.marker.radius);1<n[t].length&&0===b&&v&&v.radius?b=v.radius:1===n[t].length&&(b=l),I=p+b,b=0,g!==o&&Math.abs(h-f)<I&&(h=g-o<0?u+p:u+s-p),y!==r&&Math.abs(c-m)<I&&(c=y-r<0?d+p:d+s-p)}}),e=a.toValue(h+A.plotLeft),D=i.toValue(c+A.plotTop),{x:n[t.key].posX=e,y:n[t.key].posY=D}},i.prototype.isValidGroupedDataObject=function(t){var e,a=!1;return!!S(t)&&(D(t,function(t){if(a=!0,b(t)&&t.length){for(e=0;e<t.length;e++)if(!S(t[e])||!t[e].x||!t[e].y){a=!1;break}}else a=!1}),a)},i.prototype.getClusteredData=function(t,e){var a,i,r=[],o=[],s=[],n=[],l=[],p=0,u=Math.max(2,e.minimumClusterSize||2);if(v(e.layoutAlgorithm.type)&&!this.isValidGroupedDataObject(t))return k("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,this.chart),!1;for(i in t)if(t[i].length>=u){var d=t[i],h=Math.random().toString(36).substring(2,7)+"-"+O++,c=d.length;if(e.zones)for(a=0;a<e.zones.length;a++)if(c>=e.zones[a].from&&c<=e.zones[a].to){var f=e.zones[a];f.zoneIndex=a;var m=e.zones[a].marker,x=e.zones[a].className}var g=P(d);for(g="grid"!==e.layoutAlgorithm.type||e.allowOverlap?{x:g.x,y:g.y}:(a=this.options.marker||{},this.preventClusterCollisions({x:g.x,y:g.y,key:i,groupedData:t,gridSize:this.getScaledGridSize(e.layoutAlgorithm),defaultRadius:a.radius||3+(a.lineWidth||0),clusterRadius:m&&m.radius?m.radius:(e.marker||{}).radius||T.marker.radius})),a=0;a<c;a++)d[a].parentStateId=h;if(s.push({x:g.x,y:g.y,id:i,stateId:h,index:p,data:d,clusterZone:f,clusterZoneClassName:x}),r.push(g.x),o.push(g.y),l.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:M(e.marker,{states:e.states},m||{})}}),this.options.data&&this.options.data.length)for(a=0;a<c;a++)S(this.options.data[d[a].dataIndex])&&(d[a].options=this.options.data[d[a].dataIndex]);p++,m=null}else for(a=0;a<t[i].length;a++)d=t[i][a],h=Math.random().toString(36).substring(2,7)+"-"+O++,c=((this.options||{}).data||[])[d.dataIndex],r.push(d.x),o.push(d.y),d.parentStateId=h,n.push({x:d.x,y:d.y,id:i,stateId:h,index:p,data:t[i]}),h=c&&"object"==typeof c&&!b(c)?M(c,{x:d.x,y:d.y}):{userOptions:c,x:d.x,y:d.y},l.push({options:h}),p++;return{clusters:s,noise:n,groupedXData:r,groupedYData:o,groupMap:l}},i.prototype.destroyClusteredData=function(){(this.markerClusterSeriesData||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null},i.prototype.hideClusteredData=function(){var t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},a=n.map(function(t){return(e[t].point||{}).id||""});(t||[]).forEach(function(t){t&&-1!==a.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})},i.prototype.generatePoints=function(){var t,e,a,i,r,o=this,s=o.chart,n=o.xAxis,l=o.yAxis,p=o.options.cluster,u=o.getRealExtremes(),d=[],h=[],c=[];if(p&&p.enabled&&o.xData&&o.yData&&!s.polar){var f=p.layoutAlgorithm.type,m=p.layoutAlgorithm;for(m.processedGridSize=L(m.gridSize||T.layoutAlgorithm.gridSize,s.plotWidth),m.processedDistance=L(m.distance||T.layoutAlgorithm.distance,s.plotWidth),s=m.kmeansThreshold||T.layoutAlgorithm.kmeansThreshold,n=Math.abs(n.toValue(m.processedGridSize/2)-n.toValue(0)),l=Math.abs(l.toValue(m.processedGridSize/2)-l.toValue(0)),i=0;i<o.xData.length;i++){if(!o.dataMaxX)if(Y(x)&&Y(t)&&Y(g)&&Y(e))A(o.yData[i])&&A(g)&&A(e)&&(x=Math.max(o.xData[i],x),t=Math.min(o.xData[i],t),g=Math.max(o.yData[i]||g,g),e=Math.min(o.yData[i]||e,e));else var x=t=o.xData[i],g=e=o.yData[i];o.xData[i]>=u.minX-n&&o.xData[i]<=u.maxX+n&&(o.yData[i]||u.minY)>=u.minY-l&&(o.yData[i]||u.maxY)<=u.maxY+l&&(d.push(o.xData[i]),h.push(o.yData[i]),c.push(i))}Y(x)&&Y(t)&&A(g)&&A(e)&&(o.dataMaxX=x,o.dataMinX=t,o.dataMaxY=g,o.dataMinY=e),m=(d=(u=v(f)?f:o.markerClusterAlgorithms?f&&o.markerClusterAlgorithms[f]?o.markerClusterAlgorithms[f]:d.length<s?o.markerClusterAlgorithms.kmeans:o.markerClusterAlgorithms.grid:function(){return!1}).call(this,d,h,c,m))?o.getClusteredData(d,p):d,d=p.animation&&o.markerClusterInfo&&o.markerClusterInfo.pointsState&&o.markerClusterInfo.pointsState.oldState?((r=o.markerClusterInfo.pointsState.oldState)&&D(r,function(t){t.point&&t.point.destroy&&t.point.destroy()}),o.markerClusterInfo.pointsState.newState):{},h=o.xData.length,c=o.markerClusterInfo,m&&(o.processedXData=m.groupedXData,o.processedYData=m.groupedYData,o.hasGroupedData=!0,o.markerClusterInfo=m,o.groupMap=m.groupMap),E.apply(this),m&&o.markerClusterInfo&&((o.markerClusterInfo.clusters||[]).forEach(function(t){(a=o.points[t.index]).isCluster=!0,a.clusteredData=t.data,a.clusterPointsAmount=t.data.length,t.point=a,C(a,"click",o.onDrillToCluster)}),(o.markerClusterInfo.noise||[]).forEach(function(t){t.point=o.points[t.index]}),p.animation&&o.markerClusterInfo&&(o.markerClusterInfo.pointsState={oldState:d,newState:o.getPointsState(m,c,h)}),p.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else E.apply(this)},C(t.Chart,"render",function(){(this.series||[]).forEach(function(e){if(e.markerClusterInfo){var t=((e.markerClusterInfo||{}).pointsState||{}).oldState;(e.options.cluster||{}).animation&&e.markerClusterInfo&&0===e.chart.pointer.pinchDown.length&&"pan"!==(e.xAxis.eventArgs||{}).trigger&&t&&Object.keys(t).length&&(e.markerClusterInfo.clusters.forEach(function(t){e.animateClusterPoint(t)}),e.markerClusterInfo.noise.forEach(function(t){e.animateClusterPoint(t)}))}})}),C(e,"update",function(){if(this.dataGroup)return k("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}),C(a,"destroy",i.prototype.destroyClusteredData),C(a,"afterRender",function(){var e=(this.options.cluster||{}).drillToCluster;this.markerClusterInfo&&this.markerClusterInfo.clusters&&this.markerClusterInfo.clusters.forEach(function(t){t.point&&t.point.graphic&&(t.point.graphic.addClass("highcharts-cluster-point"),e&&t.point&&(t.point.graphic.css({cursor:"pointer"}),t.point.dataLabel&&t.point.dataLabel.css({cursor:"pointer"})),Y(t.clusterZone)&&t.point.graphic.addClass(t.clusterZoneClassName||"highcharts-cluster-zone-"+t.clusterZone.zoneIndex))})}),C(e,"drillToCluster",function(t){var e=(((t.point||t.target).series.options.cluster||{}).events||{}).drillToCluster;v(e)&&e.call(this,t)}),C(t.Axis,"setExtremes",function(){var e,t=this.chart,a=0;t.series.forEach(function(t){t.markerClusterInfo&&(e=I((t.options.cluster||{}).animation),a=e.duration||0)}),z(function(){t.tooltip&&t.tooltip.destroy()},a)})}),e(t,"masters/modules/marker-clusters.src.js",[],function(){})});