!function(e){"object"==typeof module&&module.exports?module.exports=e.default=e:"function"==typeof define&&define.amd?define("highcharts/modules/marker-clusters",["highcharts"],function(t){return e(t),e.Highcharts=t,e}):e("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(t){function e(t,e,a,i){t.hasOwnProperty(e)||(t[e]=i.apply(null,a))}e(t=t?t._modules:{},"modules/marker-clusters.src.js",[t["parts/Globals.js"],t["parts/Point.js"],t["parts/Utilities.js"]],function(t,e,a){function P(t){for(var e=t.length,a=0,i=0,r=0;r<e;r++)a+=t[r].x,i+=t[r].y;return{x:a/e,y:i/e}}function s(t,e){var a=[];return a.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){a[t.dataIndex]=t})}),t.noise.forEach(function(t){a[t.data[0].dataIndex]=t.data[0]}),a}function x(t,e,a,i,r){t.point&&(i&&t.point.graphic&&(t.point.graphic.show(),t.point.graphic.attr({opacity:e}).animate({opacity:1},a)),r&&t.point.dataLabel&&(t.point.dataLabel.show(),t.point.dataLabel.attr({opacity:e}).animate({opacity:1},a)))}function g(t,e,a){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),a&&t.point.dataLabel&&t.point.dataLabel.hide())}function y(t,e,a,i){x(t,i,a,!0,!0),e.forEach(function(t){t.point&&t.point.destroy&&t.point.destroy()})}var X=this&&this.__read||function(t,e){var a="function"==typeof Symbol&&t[Symbol.iterator];if(!a)return t;t=a.call(t);var i,r=[];try{for(;(void 0===e||0<e--)&&!(i=t.next()).done;)r.push(i.value)}catch(t){var o={error:t}}finally{try{i&&!i.done&&(a=t.return)&&a.call(t)}finally{if(o)throw o.error}}return r},C=a.addEvent,I=a.animObject,Y=a.defined,k=a.error,b=a.isArray,S=a.isFunction,A=a.isObject,M=a.isNumber,D=a.merge,v=a.objectEach,L=a.relativeLength,z=a.syncTimeout;a=t.Series;var i=t.seriesTypes.scatter,r=t.SVGRenderer,E=a.prototype.generatePoints,O=0,n=[],T={enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}};(t.defaultOptions.plotOptions||{}).series=D((t.defaultOptions.plotOptions||{}).series,{cluster:T,tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}}),r.prototype.symbols.cluster=function(t,e,a,i){a/=2,i/=2;var r=this.arc(t+a,e+i,a-4,i-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),o=this.arc(t+a,e+i,a-3,i-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a-2,open:!1});return this.arc(t+a,e+i,a-1,i-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a,open:!1}).concat(o,r)},i.prototype.animateClusterPoint=function(t){var e,a,i=this.xAxis,r=this.yAxis,o=this.chart,s=I((this.options.cluster||{}).animation),n=s.duration||500,l=(this.markerClusterInfo||{}).pointsState,p=(l||{}).newState,u=(l||{}).oldState,d=[],h=l=0,c=0,f=!1,m=!1;u&&p&&(e=p[t.stateId],h=i.toPixels(e.x)-o.plotLeft,c=r.toPixels(e.y)-o.plotTop,1===e.parentsId.length?(t=(p||{})[t.stateId].parentsId[0],a=u[t],e.point&&e.point.graphic&&a&&a.point&&a.point.plotX&&a.point.plotY&&a.point.plotX!==e.point.plotX&&a.point.plotY!==e.point.plotY&&(l=(t=e.point.graphic.getBBox()).width/2,e.point.graphic.attr({x:a.point.plotX-l,y:a.point.plotY-l}),e.point.graphic.animate({x:h-e.point.graphic.radius,y:c-e.point.graphic.radius},s,function(){m=!0,a.point&&a.point.destroy&&a.point.destroy()}),e.point.dataLabel&&e.point.dataLabel.alignAttr&&a.point.dataLabel&&a.point.dataLabel.alignAttr&&(e.point.dataLabel.attr({x:a.point.dataLabel.alignAttr.x,y:a.point.dataLabel.alignAttr.y}),e.point.dataLabel.animate({x:e.point.dataLabel.alignAttr.x,y:e.point.dataLabel.alignAttr.y},s)))):0===e.parentsId.length?(g(e,!0,!0),z(function(){x(e,.1,s,!0,!0)},n/2)):(g(e,!0,!0),e.parentsId.forEach(function(t){u&&u[t]&&(a=u[t],d.push(a),a.point&&a.point.graphic&&(f=!0,a.point.graphic.show(),a.point.graphic.animate({x:h-a.point.graphic.radius,y:c-a.point.graphic.radius,opacity:.4},s,function(){m=!0,y(e,d,s,.7)}),a.point.dataLabel&&-9999!==a.point.dataLabel.y&&e.point&&e.point.dataLabel&&e.point.dataLabel.alignAttr&&(a.point.dataLabel.show(),a.point.dataLabel.animate({x:e.point.dataLabel.alignAttr.x,y:e.point.dataLabel.alignAttr.y,opacity:.4},s))))}),z(function(){m||y(e,d,s,.85)},n),f||z(function(){y(e,d,s,.1)},n/2)))},i.prototype.getGridOffset=function(){var t=this.chart,e=this.xAxis,a=this.yAxis;return{plotLeft:e=this.dataMinX&&this.dataMaxX?e.reversed?e.toPixels(this.dataMaxX):e.toPixels(this.dataMinX):t.plotLeft,plotTop:t=this.dataMinY&&this.dataMaxY?a.reversed?a.toPixels(this.dataMinY):a.toPixels(this.dataMaxY):t.plotTop}},i.prototype.getScaledGridSize=function(t){var e=this.xAxis,a=!0,i=1,r=1;for(t=t.processedGridSize||T.layoutAlgorithm.gridSize,this.gridValueSize||(this.gridValueSize=Math.abs(e.toValue(t)-e.toValue(0))),e=+(t/(e=e.toPixels(this.gridValueSize)-e.toPixels(0))).toFixed(14);a&&1!==e;){var o=Math.pow(2,i);.75<e&&e<1.25?a=!1:1/o<=e&&e<1/o*2?(a=!1,r=o):e<=o&&o/2<e&&(a=!1,r=1/o),i++}return t/r/e},i.prototype.getRealExtremes=function(){var t=this.chart,e=this.xAxis,a=this.yAxis,i=e?e.toValue(t.plotLeft):0,e=e?e.toValue(t.plotLeft+t.plotWidth):0,r=a?a.toValue(t.plotTop):0,t=a?a.toValue(t.plotTop+t.plotHeight):0;return e<i&&(e=(i=X([i,e],2))[0],i=i[1]),t<r&&(t=(r=X([r,t],2))[0],r=r[1]),{minX:i,maxX:e,minY:r,maxY:t}},i.prototype.onDrillToCluster=function(t){(t.point||t.target).firePointEvent("drillToCluster",t,function(t){var e,a,i,r,o,s=t.point||t.target,n=s.series.xAxis,l=s.series.yAxis,p=s.series.chart;(s.series.options.cluster||{}).drillToCluster&&s.clusteredData&&(a=s.clusteredData.map(function(t){return t.x}).sort(function(t,e){return t-e}),r=s.clusteredData.map(function(t){return t.y}).sort(function(t,e){return t-e}),s=a[0],e=a[a.length-1],a=r[0],i=r[r.length-1],r=Math.abs(.1*(e-s)),o=Math.abs(.1*(i-a)),p.pointer.zoomX=!0,p.pointer.zoomY=!0,e<s&&(s=(e=X([e,s],2))[0],e=e[1]),i<a&&(a=(i=X([i,a],2))[0],i=i[1]),p.zoom({originalEvent:t,xAxis:[{axis:n,min:s-r,max:e+r}],yAxis:[{axis:l,min:a-o,max:i+o}]}))})},i.prototype.getClusterDistancesFromPoint=function(t,e,a){for(var i=this.xAxis,r=this.yAxis,o=[],s=0;s<t.length;s++){var n=Math.sqrt(Math.pow(i.toPixels(e)-i.toPixels(t[s].posX),2)+Math.pow(r.toPixels(a)-r.toPixels(t[s].posY),2));o.push({clusterIndex:s,distance:n})}return o.sort(function(t,e){return t.distance-e.distance})},i.prototype.getPointsState=function(t,e,a){e=e?s(e,a):[],a=s(t,a);var i,r={};for(n=[],t.clusters.forEach(function(t){r[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){r[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),i=0;i<a.length;i++){t=a[i];var o=e[i];t&&o&&t.parentStateId&&o.parentStateId&&r[t.parentStateId]&&-1===r[t.parentStateId].parentsId.indexOf(o.parentStateId)&&(r[t.parentStateId].parentsId.push(o.parentStateId),-1===n.indexOf(o.parentStateId)&&n.push(o.parentStateId))}return r},i.prototype.markerClusterAlgorithms={grid:function(t,e,a,i){var r,o=this.xAxis,s=this.yAxis,n={},l=this.getGridOffset();for(i=this.getScaledGridSize(i),r=0;r<t.length;r++){var p=o.toPixels(t[r])-l.plotLeft,u=s.toPixels(e[r])-l.plotTop,p=Math.floor(p/i);n[u=(u=Math.floor(u/i))+"-"+p]||(n[u]=[]),n[u].push({dataIndex:a[r],x:t[r],y:e[r]})}return n},kmeans:function(t,e,a,i){var r,o=[],s=[],n={},l=i.processedDistance||T.layoutAlgorithm.distance,p=i.iterations,u=0,d=!0,h=0,c=0,f=[];for(r in i.processedGridSize=i.processedDistance,h=this.markerClusterAlgorithms?this.markerClusterAlgorithms.grid.call(this,t,e,a,i):{})1<h[r].length&&(f=P(h[r]),o.push({posX:f.x,posY:f.y,oldX:0,oldY:0,startPointsLen:h[r].length,points:[]}));for(;d;){for(o.map(function(t){return t.points.length=0,t}),d=s.length=0;d<t.length;d++)h=t[d],c=e[d],(f=this.getClusterDistancesFromPoint(o,h,c)).length&&f[0].distance<l?o[f[0].clusterIndex].points.push({x:h,y:c,dataIndex:a[d]}):s.push({x:h,y:c,dataIndex:a[d]});for(r=0;r<o.length;r++)1===o[r].points.length&&((f=this.getClusterDistancesFromPoint(o,o[r].points[0].x,o[r].points[0].y))[1].distance<l&&(o[f[1].clusterIndex].points.push(o[r].points[0]),o[f[0].clusterIndex].points.length=0));for(d=!1,r=0;r<o.length;r++)f=P(o[r].points),o[r].oldX=o[r].posX,o[r].oldY=o[r].posY,o[r].posX=f.x,o[r].posY=f.y,(o[r].posX>o[r].oldX+1||o[r].posX<o[r].oldX-1||o[r].posY>o[r].oldY+1||o[r].posY<o[r].oldY-1)&&(d=!0);p&&(d=u<p-1),u++}return o.forEach(function(t,e){n["cluster"+e]=t.points}),s.forEach(function(t,e){n["noise"+e]=[t]}),n},optimizedKmeans:function(t,e,a,i){var r,o,s=this.xAxis,n=this.yAxis,l=i.processedDistance||T.layoutAlgorithm.gridSize,p={},u=this.getRealExtremes(),d=(this.options.cluster||{}).marker;return!this.markerClusterInfo||this.initMaxX&&this.initMaxX<u.maxX||this.initMinX&&this.initMinX>u.minX||this.initMaxY&&this.initMaxY<u.maxY||this.initMinY&&this.initMinY>u.minY?(this.initMaxX=u.maxX,this.initMinX=u.minX,this.initMaxY=u.maxY,this.initMinY=u.minY,p=this.markerClusterAlgorithms?this.markerClusterAlgorithms.kmeans.call(this,t,e,a,i):{},this.baseClusters=null):(this.baseClusters||(this.baseClusters={clusters:this.markerClusterInfo.clusters,noise:this.markerClusterInfo.noise}),this.baseClusters.clusters.forEach(function(a){a.pointsOutside=[],a.pointsInside=[],a.data.forEach(function(t){r=Math.sqrt(Math.pow(s.toPixels(t.x)-s.toPixels(a.x),2)+Math.pow(n.toPixels(t.y)-n.toPixels(a.y),2)),(o=a.clusterZone&&a.clusterZone.marker&&a.clusterZone.marker.radius?a.clusterZone.marker.radius:d&&d.radius?d.radius:T.marker.radius)+(0<=l-o?l-o:o)<r&&Y(a.pointsOutside)?a.pointsOutside.push(t):Y(a.pointsInside)&&a.pointsInside.push(t)}),a.pointsInside.length&&(p[a.id]=a.pointsInside),a.pointsOutside.forEach(function(t,e){p[a.id+"_noise"+e]=[t]})}),this.baseClusters.noise.forEach(function(t){p[t.id]=t.data})),p}},i.prototype.preventClusterCollisions=function(t){var a,i,r,o,s,n,l,p=this.xAxis,u=this.yAxis,d=(e=X(t.key.split("-").map(parseFloat),2))[0],h=e[1],c=t.gridSize,f=t.groupedData,m=t.defaultRadius,x=t.clusterRadius,g=h*c,y=d*c,C=p.toPixels(t.x),I=u.toPixels(t.y),e=[],k=0,b=0,S=(this.options.cluster||{}).marker,A=(this.options.cluster||{}).zones,M=this.getGridOffset();for(C-=M.plotLeft,I-=M.plotTop,r=1;r<5;r++){var D=r%2?-1:1,v=r<3?-1:1,D=Math.floor((C+D*x)/c);for(D=[(v=Math.floor((I+v*x)/c))+"-"+D,v+"-"+h,d+"-"+D],v=0;v<D.length;v++)-1===e.indexOf(D[v])&&D[v]!==t.key&&e.push(D[v])}return e.forEach(function(t){if(f[t]){f[t].posX||(n=P(f[t]),f[t].posX=n.x,f[t].posY=n.y),a=p.toPixels(f[t].posX||0)-M.plotLeft,i=u.toPixels(f[t].posY||0)-M.plotTop;var e=X(t.split("-").map(parseFloat),2);if(s=e[0],o=e[1],A)for(k=f[t].length,r=0;r<A.length;r++)k>=A[r].from&&k<=A[r].to&&(b=Y((A[r].marker||{}).radius)?A[r].marker.radius||0:S&&S.radius?S.radius:T.marker.radius);1<f[t].length&&0===b&&S&&S.radius?b=S.radius:1===f[t].length&&(b=m),l=x+b,b=0,o!==h&&Math.abs(C-a)<l&&(C=o-h<0?g+x:g+c-x),s!==d&&Math.abs(I-i)<l&&(I=s-d<0?y+x:y+c-x)}}),e=p.toValue(C+M.plotLeft),v=u.toValue(I+M.plotTop),{x:f[t.key].posX=e,y:f[t.key].posY=v}},i.prototype.isValidGroupedDataObject=function(t){var e,a=!1;return!!A(t)&&(v(t,function(t){if(a=!0,b(t)&&t.length){for(e=0;e<t.length;e++)if(!A(t[e])||!t[e].x||!t[e].y){a=!1;break}}else a=!1}),a)},i.prototype.getClusteredData=function(t,e){var a,i=[],r=[],o=[],s=[],n=[],l=0,p=Math.max(2,e.minimumClusterSize||2);if(S(e.layoutAlgorithm.type)&&!this.isValidGroupedDataObject(t))return k("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,this.chart),!1;for(a in t)if(t[a].length>=p){var u,d,h,c=t[a],f=Math.random().toString(36).substring(2,7)+"-"+O++,m=c.length;if(e.zones)for(g=0;g<e.zones.length;g++){m>=e.zones[g].from&&m<=e.zones[g].to&&((u=e.zones[g]).zoneIndex=g,d=e.zones[g].marker,h=e.zones[g].className)}for(var x=P(c),x="grid"!==e.layoutAlgorithm.type||e.allowOverlap?{x:x.x,y:x.y}:(g=this.options.marker||{},this.preventClusterCollisions({x:x.x,y:x.y,key:a,groupedData:t,gridSize:this.getScaledGridSize(e.layoutAlgorithm),defaultRadius:g.radius||3+(g.lineWidth||0),clusterRadius:d&&d.radius?d.radius:(e.marker||{}).radius||T.marker.radius})),g=0;g<m;g++)c[g].parentStateId=f;if(o.push({x:x.x,y:x.y,id:a,stateId:f,index:l,data:c,clusterZone:u,clusterZoneClassName:h}),i.push(x.x),r.push(x.y),n.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:D(e.marker,{states:e.states},d||{})}}),this.options.data&&this.options.data.length)for(g=0;g<m;g++)A(this.options.data[c[g].dataIndex])&&(c[g].options=this.options.data[c[g].dataIndex]);l++,d=null}else for(g=0;g<t[a].length;g++)c=t[a][g],f=Math.random().toString(36).substring(2,7)+"-"+O++,m=((this.options||{}).data||[])[c.dataIndex],i.push(c.x),r.push(c.y),c.parentStateId=f,s.push({x:c.x,y:c.y,id:a,stateId:f,index:l,data:t[a]}),f=m&&"object"==typeof m&&!b(m)?D(m,{x:c.x,y:c.y}):{userOptions:m,x:c.x,y:c.y},n.push({options:f}),l++;return{clusters:o,noise:s,groupedXData:i,groupedYData:r,groupMap:n}},i.prototype.destroyClusteredData=function(){(this.markerClusterSeriesData||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null},i.prototype.hideClusteredData=function(){var t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},a=n.map(function(t){return(e[t].point||{}).id||""});(t||[]).forEach(function(t){t&&-1!==a.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})},i.prototype.generatePoints=function(){var t,e,a,i,r,o=this,s=o.chart,n=o.xAxis,l=o.yAxis,p=o.options.cluster,u=o.getRealExtremes(),d=[],h=[],c=[];if(p&&p.enabled&&o.xData&&o.yData&&!s.polar){var f,m,x=p.layoutAlgorithm.type,g=p.layoutAlgorithm;for(g.processedGridSize=L(g.gridSize||T.layoutAlgorithm.gridSize,s.plotWidth),g.processedDistance=L(g.distance||T.layoutAlgorithm.distance,s.plotWidth),s=g.kmeansThreshold||T.layoutAlgorithm.kmeansThreshold,n=Math.abs(n.toValue(g.processedGridSize/2)-n.toValue(0)),l=Math.abs(l.toValue(g.processedGridSize/2)-l.toValue(0)),i=0;i<o.xData.length;i++){o.dataMaxX||(Y(f)&&Y(t)&&Y(m)&&Y(e)?M(o.yData[i])&&M(m)&&M(e)&&(f=Math.max(o.xData[i],f),t=Math.min(o.xData[i],t),m=Math.max(o.yData[i]||m,m),e=Math.min(o.yData[i]||e,e)):(f=t=o.xData[i],m=e=o.yData[i])),o.xData[i]>=u.minX-n&&o.xData[i]<=u.maxX+n&&(o.yData[i]||u.minY)>=u.minY-l&&(o.yData[i]||u.maxY)<=u.maxY+l&&(d.push(o.xData[i]),h.push(o.yData[i]),c.push(i))}Y(f)&&Y(t)&&M(m)&&M(e)&&(o.dataMaxX=f,o.dataMinX=t,o.dataMaxY=m,o.dataMinY=e),g=(d=(u=S(x)?x:o.markerClusterAlgorithms?x&&o.markerClusterAlgorithms[x]?o.markerClusterAlgorithms[x]:d.length<s?o.markerClusterAlgorithms.kmeans:o.markerClusterAlgorithms.grid:function(){return!1}).call(this,d,h,c,g))?o.getClusteredData(d,p):d,d=p.animation&&o.markerClusterInfo&&o.markerClusterInfo.pointsState&&o.markerClusterInfo.pointsState.oldState?((r=o.markerClusterInfo.pointsState.oldState)&&v(r,function(t){t.point&&t.point.destroy&&t.point.destroy()}),o.markerClusterInfo.pointsState.newState):{},h=o.xData.length,c=o.markerClusterInfo,g&&(o.processedXData=g.groupedXData,o.processedYData=g.groupedYData,o.hasGroupedData=!0,o.markerClusterInfo=g,o.groupMap=g.groupMap),E.apply(this),g&&o.markerClusterInfo&&((o.markerClusterInfo.clusters||[]).forEach(function(t){(a=o.points[t.index]).isCluster=!0,a.clusteredData=t.data,a.clusterPointsAmount=t.data.length,t.point=a,C(a,"click",o.onDrillToCluster)}),(o.markerClusterInfo.noise||[]).forEach(function(t){t.point=o.points[t.index]}),p.animation&&o.markerClusterInfo&&(o.markerClusterInfo.pointsState={oldState:d,newState:o.getPointsState(g,c,h)}),p.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else E.apply(this)},C(t.Chart,"render",function(){(this.series||[]).forEach(function(e){var t;e.markerClusterInfo&&(t=((e.markerClusterInfo||{}).pointsState||{}).oldState,(e.options.cluster||{}).animation&&e.markerClusterInfo&&0===e.chart.pointer.pinchDown.length&&"pan"!==(e.xAxis.eventArgs||{}).trigger&&t&&Object.keys(t).length&&(e.markerClusterInfo.clusters.forEach(function(t){e.animateClusterPoint(t)}),e.markerClusterInfo.noise.forEach(function(t){e.animateClusterPoint(t)})))})}),C(e,"update",function(){if(this.dataGroup)return k("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}),C(a,"destroy",i.prototype.destroyClusteredData),C(a,"afterRender",function(){var e=(this.options.cluster||{}).drillToCluster;this.markerClusterInfo&&this.markerClusterInfo.clusters&&this.markerClusterInfo.clusters.forEach(function(t){t.point&&t.point.graphic&&(t.point.graphic.addClass("highcharts-cluster-point"),e&&t.point&&(t.point.graphic.css({cursor:"pointer"}),t.point.dataLabel&&t.point.dataLabel.css({cursor:"pointer"})),Y(t.clusterZone)&&t.point.graphic.addClass(t.clusterZoneClassName||"highcharts-cluster-zone-"+t.clusterZone.zoneIndex))})}),C(e,"drillToCluster",function(t){var e=(((t.point||t.target).series.options.cluster||{}).events||{}).drillToCluster;S(e)&&e.call(this,t)}),C(t.Axis,"setExtremes",function(){var e,t=this.chart,a=0;t.series.forEach(function(t){t.markerClusterInfo&&(e=I((t.options.cluster||{}).animation),a=e.duration||0)}),z(function(){t.tooltip&&t.tooltip.destroy()},a)})}),e(t,"masters/modules/marker-clusters.src.js",[],function(){})});