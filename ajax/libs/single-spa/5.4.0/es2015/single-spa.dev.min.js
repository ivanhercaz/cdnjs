var singleSpa=Object.freeze({__proto__:null,get start(){return start},get ensureJQuerySupport(){return ensureJQuerySupport},get setBootstrapMaxTime(){return setBootstrapMaxTime},get setMountMaxTime(){return setMountMaxTime},get setUnmountMaxTime(){return setUnmountMaxTime},get setUnloadMaxTime(){return setUnloadMaxTime},get registerApplication(){return registerApplication},get getMountedApps(){return getMountedApps},get getAppStatus(){return getAppStatus},get unloadApplication(){return unloadApplication},get checkActivityFunctions(){return checkActivityFunctions},get getAppNames(){return getAppNames},get pathToActiveWhen(){return pathToActiveWhen},get navigateToUrl(){return navigateToUrl},get triggerAppChange(){return triggerAppChange},get addErrorHandler(){return addErrorHandler},get removeErrorHandler(){return removeErrorHandler},get mountRootParcel(){return mountRootParcel},get NOT_LOADED(){return NOT_LOADED},get LOADING_SOURCE_CODE(){return LOADING_SOURCE_CODE},get NOT_BOOTSTRAPPED(){return NOT_BOOTSTRAPPED},get BOOTSTRAPPING(){return BOOTSTRAPPING},get NOT_MOUNTED(){return NOT_MOUNTED},get MOUNTING(){return MOUNTING},get UPDATING(){return UPDATING},get LOAD_ERROR(){return LOAD_ERROR},get MOUNTED(){return MOUNTED},get UNMOUNTING(){return UNMOUNTING},get SKIP_BECAUSE_BROKEN(){return SKIP_BECAUSE_BROKEN}}),commonjsGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},NativeCustomEvent=commonjsGlobal.CustomEvent;function useNative(){try{var t=new NativeCustomEvent("cat",{detail:{foo:"bar"}});return"cat"===t.type&&"bar"===t.detail.foo}catch(t){}return!1}var customEvent=useNative()?NativeCustomEvent:"undefined"!=typeof document&&"function"==typeof document.createEvent?function(t,e){var n=document.createEvent("CustomEvent");return e?n.initCustomEvent(t,e.bubbles,e.cancelable,e.detail):n.initCustomEvent(t,!1,!1,void 0),n}:function(t,e){var n=document.createEventObject();return n.type=t,e?(n.bubbles=Boolean(e.bubbles),n.cancelable=Boolean(e.cancelable),n.detail=e.detail):(n.bubbles=!1,n.cancelable=!1,n.detail=void 0),n};let errorHandlers=[];function handleAppError(t,e,n){const r=transformErr(t,e,n);errorHandlers.length?errorHandlers.forEach(t=>t(r)):setTimeout(()=>{throw r})}function addErrorHandler(t){if("function"!=typeof t)throw Error(formatErrorMessage(28,"a single-spa error handler must be a function"));errorHandlers.push(t)}function removeErrorHandler(t){if("function"!=typeof t)throw Error(formatErrorMessage(29,"a single-spa error handler must be a function"));let e=!1;return errorHandlers=errorHandlers.filter(n=>{const r=n===t;return e=e||r,!r}),e}function formatErrorMessage(t,e,...n){return`single-spa minified message #${t}: ${e?e+" ":""}See https://single-spa.js.org/error/?code=${t}${n.length?`&arg=${n.join("&arg=")}`:""}`}function transformErr(t,e,n){const r=`${objectType(e)} '${toName(e)}' died in status ${e.status}: `;let o;if(t instanceof Error){try{t.message=r+t.message}catch(t){}o=t}else{console.warn(formatErrorMessage(30,`While ${e.status}, '${toName(e)}' rejected its lifecycle function promise with a non-Error. This will cause stack traces to not be accurate.`,e.status,toName(e)));try{o=Error(r+JSON.stringify(t))}catch(e){o=t}}return o.appOrParcelName=toName(e),e.status=n,o}const NOT_LOADED="NOT_LOADED",LOADING_SOURCE_CODE="LOADING_SOURCE_CODE",NOT_BOOTSTRAPPED="NOT_BOOTSTRAPPED",BOOTSTRAPPING="BOOTSTRAPPING",NOT_MOUNTED="NOT_MOUNTED",MOUNTING="MOUNTING",MOUNTED="MOUNTED",UPDATING="UPDATING",UNMOUNTING="UNMOUNTING",UNLOADING="UNLOADING",LOAD_ERROR="LOAD_ERROR",SKIP_BECAUSE_BROKEN="SKIP_BECAUSE_BROKEN";function isActive(t){return t.status===MOUNTED}function isntActive(t){return!isActive(t)}function isLoaded(t){return t.status!==NOT_LOADED&&t.status!==LOADING_SOURCE_CODE&&t.status!==LOAD_ERROR}function isntLoaded(t){return!isLoaded(t)}function shouldBeActive(t){try{return t.activeWhen(window.location)}catch(e){return handleAppError(e,t,SKIP_BECAUSE_BROKEN),!1}}function shouldntBeActive(t){return!shouldBeActive(t)}function notSkipped(t){return t!==SKIP_BECAUSE_BROKEN&&(!t||t.status!==SKIP_BECAUSE_BROKEN)}function withoutLoadErrors(t){return t.status!==LOAD_ERROR||(new Date).getTime()-t.loadErrorTime>=200}function toName(t){return t.name}function isParcel(t){return Boolean(t.unmountThisParcel)}function objectType(t){return isParcel(t)?"parcel":"application"}function assign(){for(let t=arguments.length-1;t>0;t--)for(let e in arguments[t])"__proto__"!==e&&(arguments[t-1][e]=arguments[t][e]);return arguments[0]}function find(t,e){for(let n=0;n<t.length;n++)if(e(t[n]))return t[n];return null}function validLifecycleFn(t){return t&&("function"==typeof t||(e=t,Array.isArray(e)&&!find(e,t=>"function"!=typeof t)));var e}function flattenFnArray(t,e){let n=t[e]||[];0===(n=Array.isArray(n)?n:[n]).length&&(n=[()=>Promise.resolve()]);const r=objectType(t),o=toName(t);return function(t){return n.reduce((n,a,i)=>n.then(()=>{const n=a(t);return smellsLikeAPromise(n)?n:Promise.reject(formatErrorMessage(15,`Within ${r} ${o}, the lifecycle function ${e} at array index ${i} did not return a promise`,r,o,e,i))}),Promise.resolve())}}function smellsLikeAPromise(t){return t&&"function"==typeof t.then&&"function"==typeof t.catch}function toBootstrapPromise(t,e){return Promise.resolve().then(()=>t.status!==NOT_BOOTSTRAPPED?t:(t.status=BOOTSTRAPPING,reasonableTime(t,"bootstrap").then(()=>(t.status=NOT_MOUNTED,t)).catch(n=>{if(e)throw transformErr(n,t,SKIP_BECAUSE_BROKEN);return handleAppError(n,t,SKIP_BECAUSE_BROKEN),t})))}function toUnmountPromise(t,e){return Promise.resolve().then(()=>{if(t.status!==MOUNTED)return t;t.status=UNMOUNTING;const n=Object.keys(t.parcels).map(e=>t.parcels[e].unmountThisParcel());return Promise.all(n).then(r,n=>r().then(()=>{const r=Error(n.message);if(e)throw transformErr(r,t,SKIP_BECAUSE_BROKEN);handleAppError(r,t,SKIP_BECAUSE_BROKEN)})).then(()=>t);function r(){return reasonableTime(t,"unmount").then(()=>{t.status=NOT_MOUNTED}).catch(n=>{if(e)throw transformErr(n,t,SKIP_BECAUSE_BROKEN);handleAppError(n,t,SKIP_BECAUSE_BROKEN)})}})}let beforeFirstMountFired=!1,firstMountFired=!1;function toMountPromise(t,e){return Promise.resolve().then(()=>t.status!==NOT_MOUNTED?t:(beforeFirstMountFired||(window.dispatchEvent(new customEvent("single-spa:before-first-mount")),beforeFirstMountFired=!0),reasonableTime(t,"mount").then(()=>(t.status=MOUNTED,firstMountFired||(window.dispatchEvent(new customEvent("single-spa:first-mount")),firstMountFired=!0),t)).catch(n=>{return t.status=MOUNTED,toUnmountPromise(t,!0).then(r,r);function r(){if(e)throw transformErr(n,t,SKIP_BECAUSE_BROKEN);return handleAppError(n,t,SKIP_BECAUSE_BROKEN),t}})))}function toUpdatePromise(t){return Promise.resolve().then(()=>{if(t.status!==MOUNTED)throw Error(formatErrorMessage(32,`Cannot update parcel '${toName(t)}' because it is not mounted`,toName(t)));return t.status=UPDATING,reasonableTime(t,"update").then(()=>(t.status=MOUNTED,t)).catch(e=>{throw transformErr(e,t,SKIP_BECAUSE_BROKEN)})})}let parcelCount=0;const rootParcels={parcels:{}};function mountRootParcel(){return mountParcel.apply(rootParcels,arguments)}function mountParcel(t,e){const n=this;if(!t||"object"!=typeof t&&"function"!=typeof t)throw Error(formatErrorMessage(2,"Cannot mount parcel without a config object or config loading function"));if(t.name&&"string"!=typeof t.name)throw Error(formatErrorMessage(3,`Parcel name must be a string, if provided. Was given ${typeof t.name}`,typeof t.name));if("object"!=typeof e)throw Error(formatErrorMessage(4,`Parcel ${name} has invalid customProps -- must be an object but was given ${typeof e}`,name,typeof e));if(!e.domElement)throw Error(formatErrorMessage(5,`Parcel ${name} cannot be mounted without a domElement provided as a prop`,name));const r=parcelCount++,o="function"==typeof t,a=o?t:()=>Promise.resolve(t),i={id:r,parcels:{},status:o?LOADING_SOURCE_CODE:NOT_BOOTSTRAPPED,customProps:e,parentName:toName(n),unmountThisParcel(){if(i.status!==MOUNTED)throw Error(formatErrorMessage(6,`Cannot unmount parcel '${name}' -- it is in a ${i.status} status`,name,i.status));return toUnmountPromise(i,!0).then(t=>(i.parentName&&delete n.parcels[i.id],t)).then(t=>(c(t),t)).catch(t=>{throw i.status=SKIP_BECAUSE_BROKEN,m(t),t})}};let s;n.parcels[r]=i;let u=a();if(!u||"function"!=typeof u.then)throw Error(formatErrorMessage(7,"When mounting a parcel, the config loading function must return a promise that resolves with the parcel config"));const l=(u=u.then(t=>{if(!t)throw Error(formatErrorMessage(8,"When mounting a parcel, the config loading function returned a promise that did not resolve with a parcel config"));const e=t.name||`parcel-${r}`;if(!validLifecycleFn(t.bootstrap))throw Error(formatErrorMessage(9,`Parcel ${e} must have a valid bootstrap function`,e));if(!validLifecycleFn(t.mount))throw Error(formatErrorMessage(10,`Parcel ${e} must have a valid mount function`,e));if(!validLifecycleFn(t.unmount))throw Error(formatErrorMessage(11,`Parcel ${e} must have a valid unmount function`,e));if(t.update&&!validLifecycleFn(t.update))throw Error(formatErrorMessage(12,`Parcel ${e} provided an invalid update function`,e));const n=flattenFnArray(t,"bootstrap"),o=flattenFnArray(t,"mount"),a=flattenFnArray(t,"unmount");i.status=NOT_BOOTSTRAPPED,i.name=e,i.bootstrap=n,i.mount=o,i.unmount=a,i.timeouts=ensureValidAppTimeouts(t.timeouts),t.update&&(i.update=flattenFnArray(t,"update"),s.update=function(t){return i.customProps=t,promiseWithoutReturnValue(toUpdatePromise(i))})})).then(()=>toBootstrapPromise(i,!0)),p=l.then(()=>toMountPromise(i,!0));let c,m;const f=new Promise((t,e)=>{c=t,m=e});return s={mount:()=>promiseWithoutReturnValue(Promise.resolve().then(()=>{if(i.status!==NOT_MOUNTED)throw Error(formatErrorMessage(13,`Cannot mount parcel '${name}' -- it is in a ${i.status} status`,name,i.status));return n.parcels[r]=i,toMountPromise(i)})),unmount:()=>promiseWithoutReturnValue(i.unmountThisParcel()),getStatus:()=>i.status,loadPromise:promiseWithoutReturnValue(u),bootstrapPromise:promiseWithoutReturnValue(l),mountPromise:promiseWithoutReturnValue(p),unmountPromise:promiseWithoutReturnValue(f)}}function promiseWithoutReturnValue(t){return t.then(()=>null)}function getProps(t){const e=toName(t);let n="function"==typeof t.customProps?t.customProps(e,window.location):t.customProps;("object"!=typeof n||null===n||Array.isArray(n))&&(n={},console.warn(formatErrorMessage(40,`single-spa: ${e}'s customProps function must return an object. Received ${n}`),e,n));const r=assign({},n,{name:e,mountParcel:mountParcel.bind(t),singleSpa:singleSpa});return isParcel(t)&&(r.unmountSelf=t.unmountThisParcel),r}const defaultWarningMillis=1e3,globalTimeoutConfig={bootstrap:{millis:4e3,dieOnTimeout:!1,warningMillis:defaultWarningMillis},mount:{millis:3e3,dieOnTimeout:!1,warningMillis:defaultWarningMillis},unmount:{millis:3e3,dieOnTimeout:!1,warningMillis:defaultWarningMillis},unload:{millis:3e3,dieOnTimeout:!1,warningMillis:defaultWarningMillis},update:{millis:3e3,dieOnTimeout:!1,warningMillis:defaultWarningMillis}};function setBootstrapMaxTime(t,e,n){if("number"!=typeof t||t<=0)throw Error(formatErrorMessage(16,"bootstrap max time must be a positive integer number of milliseconds"));globalTimeoutConfig.bootstrap={millis:t,dieOnTimeout:e,warningMillis:n||defaultWarningMillis}}function setMountMaxTime(t,e,n){if("number"!=typeof t||t<=0)throw Error(formatErrorMessage(17,"mount max time must be a positive integer number of milliseconds"));globalTimeoutConfig.mount={millis:t,dieOnTimeout:e,warningMillis:n||defaultWarningMillis}}function setUnmountMaxTime(t,e,n){if("number"!=typeof t||t<=0)throw Error(formatErrorMessage(18,"unmount max time must be a positive integer number of milliseconds"));globalTimeoutConfig.unmount={millis:t,dieOnTimeout:e,warningMillis:n||defaultWarningMillis}}function setUnloadMaxTime(t,e,n){if("number"!=typeof t||t<=0)throw Error(formatErrorMessage(19,"unload max time must be a positive integer number of milliseconds"));globalTimeoutConfig.unload={millis:t,dieOnTimeout:e,warningMillis:n||defaultWarningMillis}}function reasonableTime(t,e){const n=t.timeouts[e],r=n.warningMillis,o=objectType(t);return new Promise((a,i)=>{let s=!1,u=!1;t[e](getProps(t)).then(t=>{s=!0,a(t)}).catch(t=>{s=!0,i(t)}),setTimeout(()=>p(1),r),setTimeout(()=>p(!0),n.millis);const l=formatErrorMessage(31,`Lifecycle function ${e} for ${o} ${toName(t)} lifecycle did not resolve or reject for ${n.millis} ms.`,e,o,toName(t),n.millis);function p(t){if(!s)if(!0===t)u=!0,n.dieOnTimeout?i(Error(l)):console.error(l);else if(!u){const e=t,o=e*r;console.warn(l),o+r<n.millis&&setTimeout(()=>p(e+1),r)}}})}function ensureValidAppTimeouts(t){const e={};for(let n in globalTimeoutConfig)e[n]=assign({},globalTimeoutConfig[n],t&&t[n]||{});return e}function toLoadPromise(t){return Promise.resolve().then(()=>{if(t.loadPromise)return t.loadPromise;if(t.status!==NOT_LOADED&&t.status!==LOAD_ERROR)return t;let e,n;return t.status=LOADING_SOURCE_CODE,t.loadPromise=Promise.resolve().then(()=>{const r=t.loadApp(getProps(t));if(!smellsLikeAPromise(r))throw n=!0,Error(formatErrorMessage(33,`single-spa loading function did not return a promise. Check the second argument to registerApplication('${toName(t)}', loadingFunction, activityFunction)`,toName(t)));return r.then(n=>{let r,o;t.loadErrorTime=null,"object"!=typeof(e=n)&&(o=34,r="does not export anything"),validLifecycleFn(e.bootstrap)||(o=35,r="does not export a bootstrap function or array of functions"),validLifecycleFn(e.mount)||(o=36,r="does not export a bootstrap function or array of functions"),validLifecycleFn(e.unmount)||(o=37,r="does not export a bootstrap function or array of functions");const a=objectType(e);if(o){let n;try{n=JSON.stringify(e)}catch(t){}return console.error(formatErrorMessage(o,`The loading function for single-spa ${a} '${toName(t)}' resolved with the following, which does not have bootstrap, mount, and unmount functions`,a,toName(t),n),e),handleAppError(r,t,SKIP_BECAUSE_BROKEN),t}return e.devtools&&e.devtools.overlays&&(t.devtools.overlays=assign({},t.devtools.overlays,e.devtools.overlays)),t.status=NOT_BOOTSTRAPPED,t.bootstrap=flattenFnArray(e,"bootstrap"),t.mount=flattenFnArray(e,"mount"),t.unmount=flattenFnArray(e,"unmount"),t.unload=flattenFnArray(e,"unload"),t.timeouts=ensureValidAppTimeouts(e.timeouts),delete t.loadPromise,t})}).catch(e=>{let r;return delete t.loadPromise,n?r=SKIP_BECAUSE_BROKEN:(r=LOAD_ERROR,t.loadErrorTime=(new Date).getTime()),handleAppError(e,t,r),t})})}const isInBrowser="undefined"!=typeof window,capturedEventListeners={hashchange:[],popstate:[]},routingEventsListeningTo=["hashchange","popstate"];function navigateToUrl(t){let e;if("string"==typeof t)e=t;else if(this&&this.href)e=this.href;else{if(!(t&&t.currentTarget&&t.currentTarget.href&&t.preventDefault))throw Error(formatErrorMessage(14,"singleSpaNavigate/navigateToUrl must be either called with a string url, with an <a> tag as its context, or with an event whose currentTarget is an <a> tag"));e=t.currentTarget.href,t.preventDefault()}const n=parseUri(window.location.href),r=parseUri(e);0===e.indexOf("#")?window.location.hash=r.hash:n.host!==r.host&&r.host?window.location.href=e:r.pathname===n.pathname&&r.search===n.search?window.location.hash=r.hash:window.history.pushState(null,null,e)}function callCapturedEventListeners(t){if(t){const e=t[0].type;routingEventsListeningTo.indexOf(e)>=0&&capturedEventListeners[e].forEach(e=>{try{e.apply(this,t)}catch(t){setTimeout(()=>{throw t})}})}}let urlRerouteOnly;function setUrlRerouteOnly(t){urlRerouteOnly=t}function urlReroute(){reroute([],arguments)}function patchedUpdateState(t,e){return function(){const n=window.location.href,r=t.apply(this,arguments),o=window.location.href;return urlRerouteOnly&&n===o||urlReroute(createPopStateEvent(window.history.state,e)),r}}function createPopStateEvent(t,e){let n;try{n=new PopStateEvent("popstate",{state:t})}catch(e){(n=document.createEvent("PopStateEvent")).initPopStateEvent("popstate",!1,!1,t)}return n.singleSpa=!0,n.singleSpaTrigger=e,n}if(isInBrowser){window.addEventListener("hashchange",urlReroute),window.addEventListener("popstate",urlReroute);const t=window.addEventListener,e=window.removeEventListener;window.addEventListener=function(e,n){if(!("function"==typeof n&&routingEventsListeningTo.indexOf(e)>=0)||find(capturedEventListeners[e],t=>t===n))return t.apply(this,arguments);capturedEventListeners[e].push(n)},window.removeEventListener=function(t,n){if(!("function"==typeof n&&routingEventsListeningTo.indexOf(t)>=0))return e.apply(this,arguments);capturedEventListeners[t]=capturedEventListeners[t].filter(t=>t!==n)},window.history.pushState=patchedUpdateState(window.history.pushState,"pushState"),window.history.replaceState=patchedUpdateState(window.history.replaceState,"replaceState"),window.singleSpaNavigate=navigateToUrl}function parseUri(t){const e=document.createElement("a");return e.href=t,e}let hasInitialized=!1;function ensureJQuerySupport(t=window.jQuery){if(t||window.$&&window.$.fn&&window.$.fn.jquery&&(t=window.$),t&&!hasInitialized){const e=t.fn.on,n=t.fn.off;t.fn.on=function(t,n){return captureRoutingEvents.call(this,e,window.addEventListener,t,n,arguments)},t.fn.off=function(t,e){return captureRoutingEvents.call(this,n,window.removeEventListener,t,e,arguments)},hasInitialized=!0}}function captureRoutingEvents(t,e,n,r,o){if("string"!=typeof n)return t.apply(this,o);return n.split(/\s+/).forEach(t=>{routingEventsListeningTo.indexOf(t)>=0&&(e(t,r),n=n.replace(t,""))}),""===n.trim()?this:t.apply(this,o)}const appsToUnload={};function toUnloadPromise(t){return Promise.resolve().then(()=>{const e=appsToUnload[toName(t)];return e?t.status===NOT_LOADED?(finishUnloadingApp(t,e),t):t.status===UNLOADING?e.promise.then(()=>t):t.status!==NOT_MOUNTED?t:(t.status=UNLOADING,reasonableTime(t,"unload").then(()=>(finishUnloadingApp(t,e),t)).catch(n=>(errorUnloadingApp(t,e,n),t))):t})}function finishUnloadingApp(t,e){delete appsToUnload[toName(t)],delete t.bootstrap,delete t.mount,delete t.unmount,delete t.unload,t.status=NOT_LOADED,e.resolve()}function errorUnloadingApp(t,e,n){delete appsToUnload[toName(t)],delete t.bootstrap,delete t.mount,delete t.unmount,delete t.unload,handleAppError(n,t,SKIP_BECAUSE_BROKEN),e.reject(n)}function addAppToUnload(t,e,n,r){appsToUnload[toName(t)]={app:t,resolve:n,reject:r},Object.defineProperty(appsToUnload[toName(t)],"promise",{get:e})}function getAppUnloadInfo(t){return appsToUnload[t]}function getAppsToUnload(){return Object.keys(appsToUnload).map(t=>appsToUnload[t].app).filter(isntActive)}const apps=[];function getMountedApps(){return apps.filter(isActive).map(toName)}function getAppNames(){return apps.map(toName)}function getRawAppData(){return[...apps]}function getAppStatus(t){const e=find(apps,e=>toName(e)===t);return e?e.status:null}function registerApplication(t,e,n,r){const o=sanitizeArguments(t,e,n,r);if(-1!==getAppNames().indexOf(o.name))throw Error(formatErrorMessage(21,`There is already an app registered with name ${o.name}`,o.name));apps.push(assign({loadErrorTime:null,status:NOT_LOADED,parcels:{},devtools:{overlays:{options:{},selectors:[]}}},o)),isInBrowser&&(ensureJQuerySupport(),reroute())}function checkActivityFunctions(t){return apps.filter(e=>e.activeWhen(t)).map(toName)}function getAppsToLoad(){return apps.filter(notSkipped).filter(withoutLoadErrors).filter(isntLoaded).filter(shouldBeActive)}function getAppsToUnmount(){return apps.filter(notSkipped).filter(isActive).filter(shouldntBeActive)}function getAppsToMount(){return apps.filter(notSkipped).filter(isntActive).filter(isLoaded).filter(shouldBeActive)}function unregisterApplication(t){if(!apps.find(e=>toName(e)===t))throw Error(formatErrorMessage(25,`Cannot unregister application '${t}' because no such application has been registered`,t));return unloadApplication(t).then(()=>{const e=apps.findIndex(e=>toName(e)===t);apps.splice(e,1)})}function unloadApplication(t,e={waitForUnmount:!1}){if("string"!=typeof t)throw Error(formatErrorMessage(26,"unloadApplication requires a string 'appName'"));const n=find(apps,e=>toName(e)===t);if(!n)throw Error(formatErrorMessage(27,`Could not unload application '${t}' because no such application has been registered`,t));const r=getAppUnloadInfo(toName(n));if(e&&e.waitForUnmount){if(r)return r.promise;{const t=new Promise((e,r)=>{addAppToUnload(n,()=>t,e,r)});return t}}{let t;return r?(t=r.promise,immediatelyUnloadApp(n,r.resolve,r.reject)):t=new Promise((e,r)=>{addAppToUnload(n,()=>t,e,r),immediatelyUnloadApp(n,e,r)}),t}}function immediatelyUnloadApp(t,e,n){toUnmountPromise(t).then(toUnloadPromise).then(()=>{e(),setTimeout(()=>{reroute()})}).catch(n)}function validateRegisterWithArguments(t,e,n,r){if("string"!=typeof t||0===t.length)throw Error(formatErrorMessage(20,"The 1st argument to registerApplication must be a non-empty string 'appName'"));if(!e)throw Error(formatErrorMessage(23,"The 2nd argument to registerApplication must be an application or loading application function"));if("function"!=typeof n)throw Error(formatErrorMessage(24,"The 3rd argument to registerApplication must be an activeWhen function"));if(!validCustomProps(r))throw Error(formatErrorMessage(22,"The optional 4th argument is a customProps and must be an object"))}function validateRegisterWithConfig(t){if(Array.isArray(t)||null===t)throw Error(formatErrorMessage(39,"Configuration object can't be an Array or null!"));const e=["name","app","activeWhen","customProps"],n=Object.keys(t).reduce((t,n)=>e.includes(n)?t:t.concat(n),[]);if(0!==n.length)throw Error(formatErrorMessage(38,`The configuration object accepts only: ${e.join(", ")}. Invalid keys: ${n.join(", ")}.`,e.join(", "),n.join(", ")));if("string"!=typeof t.name||0===t.name.length)throw Error(formatErrorMessage(20,"The config.name on registerApplication must be a non-empty string"));if("object"!=typeof t.app&&"function"!=typeof t.app)throw Error(formatErrorMessage(20,"The config.app on registerApplication must be an application or a loading function"));const r=t=>"string"==typeof t||"function"==typeof t;if(!(r(t.activeWhen)||Array.isArray(t.activeWhen)&&t.activeWhen.every(r)))throw Error(formatErrorMessage(24,"The config.activeWhen on registerApplication must be a string, function or an array with both"));if(!validCustomProps(t.customProps))throw Error(formatErrorMessage(22,"The optional config.customProps must be an object"))}function validCustomProps(t){return!t||"function"==typeof t||"object"==typeof t&&null!==t&&!Array.isArray(t)}function sanitizeArguments(t,e,n,r){const o={name:null,loadApp:null,activeWhen:null,customProps:null};return"object"==typeof t?(validateRegisterWithConfig(t),o.name=t.name,o.loadApp=t.app,o.activeWhen=t.activeWhen,o.customProps=t.customProps):(validateRegisterWithArguments(t,e,n,r),o.name=t,o.loadApp=e,o.activeWhen=n,o.customProps=r),o.loadApp=sanitizeLoadApp(o.loadApp),o.customProps=sanitizeCustomProps(o.customProps),o.activeWhen=sanitizeActiveWhen(o.activeWhen),o}function sanitizeLoadApp(t){return"function"!=typeof t?()=>Promise.resolve(t):t}function sanitizeCustomProps(t){return t||{}}function sanitizeActiveWhen(t){let e=Array.isArray(t)?t:[t];return e=e.map(t=>"function"==typeof t?t:pathToActiveWhen(t)),t=>e.some(e=>e(t))}function pathToActiveWhen(t){const e=toDynamicPathValidatorRegex(t);return t=>{const n=t.href.replace(t.origin,"");return e.test(n)}}function toDynamicPathValidatorRegex(t){let e=0,n=!1,r="^";for(let e=0;e<t.length;e++){const r=t[e];(!n&&":"===r||n&&"/"===r)&&o(e)}return o(t.length),new RegExp(r,"i");function o(o){const a=t.slice(e,o).replace(/[|\\{}()[\]^$+*?.]/g,"\\$&");r+=n?"[^/]+/?":a,n=!n,e=o}}let appChangeUnderway=!1,peopleWaitingOnAppChange=[];function triggerAppChange(){return reroute()}function reroute(t=[],e){if(appChangeUnderway)return new Promise((t,n)=>{peopleWaitingOnAppChange.push({resolve:t,reject:n,eventArguments:e})});const n=[];return isStarted()?(appChangeUnderway=!0,Promise.resolve().then(()=>{window.dispatchEvent(new customEvent("single-spa:before-routing-event",i()));const e=r(getAppsToUnload()).map(toUnloadPromise),s=r(getAppsToUnmount()).map(toUnmountPromise).map(t=>t.then(toUnloadPromise)),u=s.concat(e),l=Promise.all(u);l.then(()=>{window.dispatchEvent(new customEvent("single-spa:before-mount-routing-event",i()))});const p=r(getAppsToLoad()),c=p.map(t=>toLoadPromise(t).then(t=>tryToBootstrapAndMount(t,l))),m=getAppsToMount().filter(t=>p.indexOf(t)<0).map(t=>(n.push(t),tryToBootstrapAndMount(t,l)));return l.catch(t=>{throw a(),t}).then(()=>(a(),Promise.all(c.concat(m)).catch(e=>{throw t.forEach(t=>t.reject(e)),e}).then(o)))})):Promise.resolve().then(()=>{const t=r(getAppsToLoad()).map(toLoadPromise);return Promise.all(t).then(a).then(()=>[]).catch(t=>{throw a(),t})});function r(t){return n.push(...t),t}function o(){const e=getMountedApps();t.forEach(t=>t.resolve(e));try{const t=0===n.length?"single-spa:no-app-change":"single-spa:app-change";window.dispatchEvent(new customEvent(t,i())),window.dispatchEvent(new customEvent("single-spa:routing-event",i()))}catch(t){setTimeout(()=>{throw t})}if(appChangeUnderway=!1,peopleWaitingOnAppChange.length>0){const t=peopleWaitingOnAppChange;peopleWaitingOnAppChange=[],reroute(t)}return e}function a(){t.forEach(t=>{callCapturedEventListeners(t.eventArguments)}),callCapturedEventListeners(e)}function i(){const t={},r={[MOUNTED]:[],[NOT_MOUNTED]:[],[NOT_LOADED]:[],[SKIP_BECAUSE_BROKEN]:[]};return n.forEach(e=>{const n=toName(e),o=getAppStatus(n);t[n]=o,(r[o]=r[o]||[]).push(n)}),{detail:{newAppStatuses:t,appsByNewStatus:r,totalAppChanges:n.length,originalEvent:null==e?void 0:e[0]}}}}function tryToBootstrapAndMount(t,e){return shouldBeActive(t)?toBootstrapPromise(t).then(t=>e.then(()=>shouldBeActive(t)?toMountPromise(t):t)):e.then(()=>t)}let started=!1;function start(t){started=!0,t&&t.urlRerouteOnly&&setUrlRerouteOnly(t.urlRerouteOnly),isInBrowser&&reroute()}function isStarted(){return started}isInBrowser&&setTimeout(()=>{started||console.warn(formatErrorMessage(1,"singleSpa.start() has not been called, 5000ms after single-spa was loaded. Before start() is called, apps can be declared and loaded, but not bootstrapped or mounted."))},5e3);var devtools={getRawAppData:getRawAppData,reroute:reroute,NOT_LOADED:NOT_LOADED,toLoadPromise:toLoadPromise,toBootstrapPromise:toBootstrapPromise,unregisterApplication:unregisterApplication};isInBrowser&&window.__SINGLE_SPA_DEVTOOLS__&&(window.__SINGLE_SPA_DEVTOOLS__.exposedMethods=devtools);export{BOOTSTRAPPING,LOADING_SOURCE_CODE,LOAD_ERROR,MOUNTED,MOUNTING,NOT_BOOTSTRAPPED,NOT_LOADED,NOT_MOUNTED,SKIP_BECAUSE_BROKEN,UNMOUNTING,UPDATING,addErrorHandler,checkActivityFunctions,ensureJQuerySupport,getAppNames,getAppStatus,getMountedApps,mountRootParcel,navigateToUrl,pathToActiveWhen,registerApplication,removeErrorHandler,setBootstrapMaxTime,setMountMaxTime,setUnloadMaxTime,setUnmountMaxTime,start,triggerAppChange,unloadApplication};