var singleSpa=Object.freeze({__proto__:null,get start(){return start},get ensureJQuerySupport(){return ensureJQuerySupport},get setBootstrapMaxTime(){return setBootstrapMaxTime},get setMountMaxTime(){return setMountMaxTime},get setUnmountMaxTime(){return setUnmountMaxTime},get setUnloadMaxTime(){return setUnloadMaxTime},get registerApplication(){return registerApplication},get getMountedApps(){return getMountedApps},get getAppStatus(){return getAppStatus},get unloadApplication(){return unloadApplication},get checkActivityFunctions(){return checkActivityFunctions},get getAppNames(){return getAppNames},get navigateToUrl(){return navigateToUrl},get triggerAppChange(){return triggerAppChange},get addErrorHandler(){return addErrorHandler},get removeErrorHandler(){return removeErrorHandler},get mountRootParcel(){return mountRootParcel},get NOT_LOADED(){return NOT_LOADED},get LOADING_SOURCE_CODE(){return LOADING_SOURCE_CODE},get NOT_BOOTSTRAPPED(){return NOT_BOOTSTRAPPED},get BOOTSTRAPPING(){return BOOTSTRAPPING},get NOT_MOUNTED(){return NOT_MOUNTED},get MOUNTING(){return MOUNTING},get UPDATING(){return UPDATING},get LOAD_ERROR(){return LOAD_ERROR},get MOUNTED(){return MOUNTED},get UNMOUNTING(){return UNMOUNTING},get SKIP_BECAUSE_BROKEN(){return SKIP_BECAUSE_BROKEN}}),commonjsGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},NativeCustomEvent=commonjsGlobal.CustomEvent;function useNative(){try{var t=new NativeCustomEvent("cat",{detail:{foo:"bar"}});return"cat"===t.type&&"bar"===t.detail.foo}catch(t){}return!1}var customEvent=useNative()?NativeCustomEvent:"undefined"!=typeof document&&"function"==typeof document.createEvent?function(t,e){var r=document.createEvent("CustomEvent");return e?r.initCustomEvent(t,e.bubbles,e.cancelable,e.detail):r.initCustomEvent(t,!1,!1,void 0),r}:function(t,e){var r=document.createEventObject();return r.type=t,e?(r.bubbles=Boolean(e.bubbles),r.cancelable=Boolean(e.cancelable),r.detail=e.detail):(r.bubbles=!1,r.cancelable=!1,r.detail=void 0),r};let errorHandlers=[];function handleAppError(t,e,r){const n=transformErr(t,e,r);errorHandlers.length?errorHandlers.forEach(t=>t(n)):setTimeout(()=>{throw n})}function addErrorHandler(t){if("function"!=typeof t)throw Error(formatErrorMessage(28,"a single-spa error handler must be a function"));errorHandlers.push(t)}function removeErrorHandler(t){if("function"!=typeof t)throw Error(formatErrorMessage(29,"a single-spa error handler must be a function"));let e=!1;return errorHandlers=errorHandlers.filter(r=>{const n=r===t;return e=e||n,!n}),e}function formatErrorMessage(t,e,...r){return`single-spa minified message #${t}: ${e?e+" ":""}See https://single-spa.js.org/error/?code=${t}${r.length?`&arg=${r.join("&arg=")}`:""}`}function transformErr(t,e,r){const n=`${objectType(e)} '${toName(e)}' died in status ${e.status}: `;let o;if(t instanceof Error){try{t.message=n+t.message}catch(t){}o=t}else{console.warn(formatErrorMessage(30,`While ${e.status}, '${toName(e)}' rejected its lifecycle function promise with a non-Error. This will cause stack traces to not be accurate.`,e.status,toName(e)));try{o=Error(n+JSON.stringify(t))}catch(e){o=t}}return o.appOrParcelName=toName(e),e.status=r,o}const NOT_LOADED="NOT_LOADED",LOADING_SOURCE_CODE="LOADING_SOURCE_CODE",NOT_BOOTSTRAPPED="NOT_BOOTSTRAPPED",BOOTSTRAPPING="BOOTSTRAPPING",NOT_MOUNTED="NOT_MOUNTED",MOUNTING="MOUNTING",MOUNTED="MOUNTED",UPDATING="UPDATING",UNMOUNTING="UNMOUNTING",UNLOADING="UNLOADING",LOAD_ERROR="LOAD_ERROR",SKIP_BECAUSE_BROKEN="SKIP_BECAUSE_BROKEN";function isActive(t){return t.status===MOUNTED}function isntActive(t){return!isActive(t)}function isLoaded(t){return t.status!==NOT_LOADED&&t.status!==LOADING_SOURCE_CODE&&t.status!==LOAD_ERROR}function isntLoaded(t){return!isLoaded(t)}function shouldBeActive(t){try{return t.activeWhen(window.location)}catch(e){handleAppError(e,t,SKIP_BECAUSE_BROKEN)}}function shouldntBeActive(t){try{return!shouldBeActive(t)}catch(e){handleAppError(e,t,SKIP_BECAUSE_BROKEN)}}function notSkipped(t){return t!==SKIP_BECAUSE_BROKEN&&(!t||t.status!==SKIP_BECAUSE_BROKEN)}function withoutLoadErrors(t){return t.status!==LOAD_ERROR||(new Date).getTime()-t.loadErrorTime>=200}function toName(t){return t.name}function isParcel(t){return Boolean(t.unmountThisParcel)}function objectType(t){return isParcel(t)?"parcel":"application"}function assign(){for(let t=arguments.length-1;t>0;t--)for(let e in arguments[t])"__proto__"!==e&&(arguments[t-1][e]=arguments[t][e]);return arguments[0]}function find(t,e){for(let r=0;r<t.length;r++)if(e(t[r]))return t[r];return null}function validLifecycleFn(t){return t&&("function"==typeof t||(e=t,Array.isArray(e)&&!find(e,t=>"function"!=typeof t)));var e}function flattenFnArray(t,e){let r=t[e]||[];0===(r=Array.isArray(r)?r:[r]).length&&(r=[()=>Promise.resolve()]);const n=objectType(t),o=toName(t);return function(t){return r.reduce((r,a,i)=>r.then(()=>{const r=a(t);return smellsLikeAPromise(r)?r:Promise.reject(formatErrorMessage(15,`Within ${n} ${o}, the lifecycle function ${e} at array index ${i} did not return a promise`,n,o,e,i))}),Promise.resolve())}}function smellsLikeAPromise(t){return t&&"function"==typeof t.then&&"function"==typeof t.catch}function toBootstrapPromise(t,e){return Promise.resolve().then(()=>t.status!==NOT_BOOTSTRAPPED?t:(t.status=BOOTSTRAPPING,reasonableTime(t,"bootstrap").then(()=>(t.status=NOT_MOUNTED,t)).catch(r=>{if(e)throw transformErr(r,t,SKIP_BECAUSE_BROKEN);return handleAppError(r,t,SKIP_BECAUSE_BROKEN),t})))}function toUnmountPromise(t,e){return Promise.resolve().then(()=>{if(t.status!==MOUNTED)return t;t.status=UNMOUNTING;const r=Object.keys(t.parcels).map(e=>t.parcels[e].unmountThisParcel());return Promise.all(r).then(n,r=>n().then(()=>{const n=Error(r.message);if(e)throw transformErr(n,t,SKIP_BECAUSE_BROKEN);handleAppError(n,t,SKIP_BECAUSE_BROKEN)})).then(()=>t);function n(){return reasonableTime(t,"unmount").then(()=>{t.status=NOT_MOUNTED}).catch(r=>{if(e)throw transformErr(r,t,SKIP_BECAUSE_BROKEN);handleAppError(r,t,SKIP_BECAUSE_BROKEN)})}})}let beforeFirstMountFired=!1,firstMountFired=!1;function toMountPromise(t,e){return Promise.resolve().then(()=>t.status!==NOT_MOUNTED?t:(beforeFirstMountFired||(window.dispatchEvent(new customEvent("single-spa:before-first-mount")),beforeFirstMountFired=!0),reasonableTime(t,"mount").then(()=>(t.status=MOUNTED,firstMountFired||(window.dispatchEvent(new customEvent("single-spa:first-mount")),firstMountFired=!0),t)).catch(r=>{return t.status=MOUNTED,toUnmountPromise(t,!0).then(n,n);function n(){if(e)throw transformErr(r,t,SKIP_BECAUSE_BROKEN);return handleAppError(r,t,SKIP_BECAUSE_BROKEN),t}})))}function toUpdatePromise(t){return Promise.resolve().then(()=>{if(t.status!==MOUNTED)throw Error(formatErrorMessage(32,`Cannot update parcel '${toName(t)}' because it is not mounted`,toName(t)));return t.status=UPDATING,reasonableTime(t,"update").then(()=>(t.status=MOUNTED,t)).catch(e=>{throw transformErr(e,t,SKIP_BECAUSE_BROKEN)})})}let parcelCount=0;const rootParcels={parcels:{}};function mountRootParcel(){return mountParcel.apply(rootParcels,arguments)}function mountParcel(t,e){const r=this;if(!t||"object"!=typeof t&&"function"!=typeof t)throw Error(formatErrorMessage(2,"Cannot mount parcel without a config object or config loading function"));if(t.name&&"string"!=typeof t.name)throw Error(formatErrorMessage(3,`Parcel name must be a string, if provided. Was given ${typeof t.name}`,typeof t.name));if("object"!=typeof e)throw Error(formatErrorMessage(4,`Parcel ${name} has invalid customProps -- must be an object but was given ${typeof e}`,name,typeof e));if(!e.domElement)throw Error(formatErrorMessage(5,`Parcel ${name} cannot be mounted without a domElement provided as a prop`,name));const n=parcelCount++,o="function"==typeof t,a=o?t:()=>Promise.resolve(t),i={id:n,parcels:{},status:o?LOADING_SOURCE_CODE:NOT_BOOTSTRAPPED,customProps:e,parentName:toName(r),unmountThisParcel(){if(i.status!==MOUNTED)throw Error(formatErrorMessage(6,`Cannot unmount parcel '${name}' -- it is in a ${i.status} status`,name,i.status));return toUnmountPromise(i,!0).then(t=>(i.parentName&&delete r.parcels[i.id],t)).then(t=>(c(t),t)).catch(t=>{throw i.status=SKIP_BECAUSE_BROKEN,m(t),t})}};let s;r.parcels[n]=i;let u=a();if(!u||"function"!=typeof u.then)throw Error(formatErrorMessage(7,"When mounting a parcel, the config loading function must return a promise that resolves with the parcel config"));const l=(u=u.then(t=>{if(!t)throw Error(formatErrorMessage(8,"When mounting a parcel, the config loading function returned a promise that did not resolve with a parcel config"));const e=t.name||`parcel-${n}`;if(!validLifecycleFn(t.bootstrap))throw Error(formatErrorMessage(9,`Parcel ${e} must have a valid bootstrap function`,e));if(!validLifecycleFn(t.mount))throw Error(formatErrorMessage(10,`Parcel ${e} must have a valid mount function`,e));if(!validLifecycleFn(t.unmount))throw Error(formatErrorMessage(11,`Parcel ${e} must have a valid unmount function`,e));if(t.update&&!validLifecycleFn(t.update))throw Error(formatErrorMessage(12,`Parcel ${e} provided an invalid update function`,e));const r=flattenFnArray(t,"bootstrap"),o=flattenFnArray(t,"mount"),a=flattenFnArray(t,"unmount");i.status=NOT_BOOTSTRAPPED,i.name=e,i.bootstrap=r,i.mount=o,i.unmount=a,i.timeouts=ensureValidAppTimeouts(t.timeouts),t.update&&(i.update=flattenFnArray(t,"update"),s.update=function(t){return i.customProps=t,promiseWithoutReturnValue(toUpdatePromise(i))})})).then(()=>toBootstrapPromise(i,!0)),p=l.then(()=>toMountPromise(i,!0));let c,m;const f=new Promise((t,e)=>{c=t,m=e});return s={mount:()=>promiseWithoutReturnValue(Promise.resolve().then(()=>{if(i.status!==NOT_MOUNTED)throw Error(formatErrorMessage(13,`Cannot mount parcel '${name}' -- it is in a ${i.status} status`,name,i.status));return r.parcels[n]=i,toMountPromise(i)})),unmount:()=>promiseWithoutReturnValue(i.unmountThisParcel()),getStatus:()=>i.status,loadPromise:promiseWithoutReturnValue(u),bootstrapPromise:promiseWithoutReturnValue(l),mountPromise:promiseWithoutReturnValue(p),unmountPromise:promiseWithoutReturnValue(f)}}function promiseWithoutReturnValue(t){return t.then(()=>null)}function getProps(t){const e=assign({},t.customProps,{name:toName(t),mountParcel:mountParcel.bind(t),singleSpa:singleSpa});return isParcel(t)&&(e.unmountSelf=t.unmountThisParcel),e}const defaultWarningMillis=1e3,globalTimeoutConfig={bootstrap:{millis:4e3,dieOnTimeout:!1,warningMillis:defaultWarningMillis},mount:{millis:3e3,dieOnTimeout:!1,warningMillis:defaultWarningMillis},unmount:{millis:3e3,dieOnTimeout:!1,warningMillis:defaultWarningMillis},unload:{millis:3e3,dieOnTimeout:!1,warningMillis:defaultWarningMillis},update:{millis:3e3,dieOnTimeout:!1,warningMillis:defaultWarningMillis}};function setBootstrapMaxTime(t,e,r){if("number"!=typeof t||t<=0)throw Error(formatErrorMessage(16,"bootstrap max time must be a positive integer number of milliseconds"));globalTimeoutConfig.bootstrap={millis:t,dieOnTimeout:e,warningMillis:r||defaultWarningMillis}}function setMountMaxTime(t,e,r){if("number"!=typeof t||t<=0)throw Error(formatErrorMessage(17,"mount max time must be a positive integer number of milliseconds"));globalTimeoutConfig.mount={millis:t,dieOnTimeout:e,warningMillis:r||defaultWarningMillis}}function setUnmountMaxTime(t,e,r){if("number"!=typeof t||t<=0)throw Error(formatErrorMessage(18,"unmount max time must be a positive integer number of milliseconds"));globalTimeoutConfig.unmount={millis:t,dieOnTimeout:e,warningMillis:r||defaultWarningMillis}}function setUnloadMaxTime(t,e,r){if("number"!=typeof t||t<=0)throw Error(formatErrorMessage(19,"unload max time must be a positive integer number of milliseconds"));globalTimeoutConfig.unload={millis:t,dieOnTimeout:e,warningMillis:r||defaultWarningMillis}}function reasonableTime(t,e){const r=t.timeouts[e],n=r.warningMillis,o=objectType(t);return new Promise((a,i)=>{let s=!1,u=!1;t[e](getProps(t)).then(t=>{s=!0,a(t)}).catch(t=>{s=!0,i(t)}),setTimeout(()=>p(1),n),setTimeout(()=>p(!0),r.millis);const l=formatErrorMessage(31,`Lifecycle function ${e} for ${o} ${toName(t)} lifecycle did not resolve or reject for ${r.millis} ms.`,e,o,toName(t),r.millis);function p(t){if(!s)if(!0===t)u=!0,r.dieOnTimeout?i(Error(l)):console.error(l);else if(!u){const e=t,o=e*n;console.warn(l),o+n<r.millis&&setTimeout(()=>p(e+1),n)}}})}function ensureValidAppTimeouts(t){const e={};for(let r in globalTimeoutConfig)e[r]=assign({},globalTimeoutConfig[r],t&&t[r]||{});return e}function toLoadPromise(t){return Promise.resolve().then(()=>{if(t.loadPromise)return t.loadPromise;if(t.status!==NOT_LOADED&&t.status!==LOAD_ERROR)return t;let e,r;return t.status=LOADING_SOURCE_CODE,t.loadPromise=Promise.resolve().then(()=>{const n=t.loadApp(getProps(t));if(!smellsLikeAPromise(n))throw r=!0,Error(formatErrorMessage(33,`single-spa loading function did not return a promise. Check the second argument to registerApplication('${toName(t)}', loadingFunction, activityFunction)`,toName(t)));return n.then(r=>{let n,o;t.loadErrorTime=null,"object"!=typeof(e=r)&&(o=34,n="does not export anything"),validLifecycleFn(e.bootstrap)||(o=35,n="does not export a bootstrap function or array of functions"),validLifecycleFn(e.mount)||(o=36,n="does not export a bootstrap function or array of functions"),validLifecycleFn(e.unmount)||(o=37,n="does not export a bootstrap function or array of functions");const a=objectType(e);if(o){let r;try{r=JSON.stringify(e)}catch(t){}return console.error(formatErrorMessage(o,`The loading function for single-spa ${a} '${toName(t)}' resolved with the following, which does not have bootstrap, mount, and unmount functions`,a,toName(t),r),e),handleAppError(n,t,SKIP_BECAUSE_BROKEN),t}return e.devtools&&e.devtools.overlays&&(t.devtools.overlays=assign({},t.devtools.overlays,e.devtools.overlays)),t.status=NOT_BOOTSTRAPPED,t.bootstrap=flattenFnArray(e,"bootstrap"),t.mount=flattenFnArray(e,"mount"),t.unmount=flattenFnArray(e,"unmount"),t.unload=flattenFnArray(e,"unload"),t.timeouts=ensureValidAppTimeouts(e.timeouts),delete t.loadPromise,t})}).catch(e=>{let n;return delete t.loadPromise,r?n=SKIP_BECAUSE_BROKEN:(n=LOAD_ERROR,t.loadErrorTime=(new Date).getTime()),handleAppError(e,t,n),t})})}const isInBrowser="undefined"!=typeof window,capturedEventListeners={hashchange:[],popstate:[]},routingEventsListeningTo=["hashchange","popstate"];function navigateToUrl(t){let e;if("string"==typeof t)e=t;else if(this&&this.href)e=this.href;else{if(!(t&&t.currentTarget&&t.currentTarget.href&&t.preventDefault))throw Error(formatErrorMessage(14,"singleSpaNavigate/navigateToUrl must be either called with a string url, with an <a> tag as its context, or with an event whose currentTarget is an <a> tag"));e=t.currentTarget.href,t.preventDefault()}const r=parseUri(window.location.href),n=parseUri(e);0===e.indexOf("#")?window.location.hash=n.hash:r.host!==n.host&&n.host?window.location.href=e:n.pathname===r.pathname&&n.search===r.pathname?window.location.hash=n.hash:window.history.pushState(null,null,e)}function callCapturedEventListeners(t){if(t){const e=t[0].type;routingEventsListeningTo.indexOf(e)>=0&&capturedEventListeners[e].forEach(e=>{try{e.apply(this,t)}catch(t){setTimeout(()=>{throw t})}})}}let urlRerouteOnly;function setUrlRerouteOnly(t){urlRerouteOnly=t}function urlReroute(){reroute([],arguments)}if(isInBrowser){window.addEventListener("hashchange",urlReroute),window.addEventListener("popstate",urlReroute);const t=window.addEventListener,e=window.removeEventListener;function patchedUpdateState(t){return function(){const e=window.location.href,r=t.apply(this,arguments),n=window.location.href;return urlRerouteOnly&&e===n||urlReroute(createPopStateEvent(window.history.state)),r}}function createPopStateEvent(t){try{return new PopStateEvent("popstate",{state:t})}catch(e){const r=document.createEvent("PopStateEvent");return r.initPopStateEvent("popstate",!1,!1,t),r}}window.addEventListener=function(e,r){if(!("function"==typeof r&&routingEventsListeningTo.indexOf(e)>=0)||find(capturedEventListeners[e],t=>t===r))return t.apply(this,arguments);capturedEventListeners[e].push(r)},window.removeEventListener=function(t,r){if(!("function"==typeof r&&routingEventsListeningTo.indexOf(t)>=0))return e.apply(this,arguments);capturedEventListeners[t]=capturedEventListeners[t].filter(t=>t!==r)},window.history.pushState=patchedUpdateState(window.history.pushState),window.history.replaceState=patchedUpdateState(window.history.replaceState),window.singleSpaNavigate=navigateToUrl}function parseUri(t){const e=document.createElement("a");return e.href=t,e}let hasInitialized=!1;function ensureJQuerySupport(t=window.jQuery){if(t||window.$&&window.$.fn&&window.$.fn.jquery&&(t=window.$),t&&!hasInitialized){const e=t.fn.on,r=t.fn.off;t.fn.on=function(t,r){return captureRoutingEvents.call(this,e,window.addEventListener,t,r,arguments)},t.fn.off=function(t,e){return captureRoutingEvents.call(this,r,window.removeEventListener,t,e,arguments)},hasInitialized=!0}}function captureRoutingEvents(t,e,r,n,o){if("string"!=typeof r)return t.apply(this,o);return r.split(/\s+/).forEach(t=>{routingEventsListeningTo.indexOf(t)>=0&&(e(t,n),r=r.replace(t,""))}),""===r.trim()?this:t.apply(this,o)}const appsToUnload={};function toUnloadPromise(t){return Promise.resolve().then(()=>{const e=appsToUnload[toName(t)];return e?t.status===NOT_LOADED?(finishUnloadingApp(t,e),t):t.status===UNLOADING?e.promise.then(()=>t):t.status!==NOT_MOUNTED?t:(t.status=UNLOADING,reasonableTime(t,"unload").then(()=>(finishUnloadingApp(t,e),t)).catch(r=>(errorUnloadingApp(t,e,r),t))):t})}function finishUnloadingApp(t,e){delete appsToUnload[toName(t)],delete t.bootstrap,delete t.mount,delete t.unmount,delete t.unload,t.status=NOT_LOADED,e.resolve()}function errorUnloadingApp(t,e,r){delete appsToUnload[toName(t)],delete t.bootstrap,delete t.mount,delete t.unmount,delete t.unload,handleAppError(r,t,SKIP_BECAUSE_BROKEN),e.reject(r)}function addAppToUnload(t,e,r,n){appsToUnload[toName(t)]={app:t,resolve:r,reject:n},Object.defineProperty(appsToUnload[toName(t)],"promise",{get:e})}function getAppUnloadInfo(t){return appsToUnload[t]}function getAppsToUnload(){return Object.keys(appsToUnload).map(t=>appsToUnload[t].app).filter(isntActive)}const apps=[];function getMountedApps(){return apps.filter(isActive).map(toName)}function getAppNames(){return apps.map(toName)}function getRawAppData(){return[...apps]}function getAppStatus(t){const e=find(apps,e=>toName(e)===t);return e?e.status:null}function registerApplication(t,e,r,n){const o=sanitizeArguments(t,e,r,n);if(-1!==getAppNames().indexOf(o.name))throw Error(formatErrorMessage(21,`There is already an app registered with name ${o.name}`,o.name));apps.push(assign({loadErrorTime:null,status:NOT_LOADED,parcels:{},devtools:{overlays:{options:{},selectors:[]}}},o)),isInBrowser&&(ensureJQuerySupport(),reroute())}function checkActivityFunctions(t){return apps.filter(e=>e.activeWhen(t)).map(toName)}function getAppsToLoad(){return apps.filter(notSkipped).filter(withoutLoadErrors).filter(isntLoaded).filter(shouldBeActive)}function getAppsToUnmount(){return apps.filter(notSkipped).filter(isActive).filter(shouldntBeActive)}function getAppsToMount(){return apps.filter(notSkipped).filter(isntActive).filter(isLoaded).filter(shouldBeActive)}function unregisterApplication(t){if(!apps.find(e=>toName(e)===t))throw Error(formatErrorMessage(25,`Cannot unregister application '${t}' because no such application has been registered`,t));return unloadApplication(t).then(()=>{const e=apps.findIndex(e=>toName(e)===t);apps.splice(e,1)})}function unloadApplication(t,e={waitForUnmount:!1}){if("string"!=typeof t)throw Error(formatErrorMessage(26,"unloadApplication requires a string 'appName'"));const r=find(apps,e=>toName(e)===t);if(!r)throw Error(formatErrorMessage(27,`Could not unload application '${t}' because no such application has been registered`,t));const n=getAppUnloadInfo(toName(r));if(e&&e.waitForUnmount){if(n)return n.promise;{const t=new Promise((e,n)=>{addAppToUnload(r,()=>t,e,n)});return t}}{let t;return n?(t=n.promise,immediatelyUnloadApp(r,n.resolve,n.reject)):t=new Promise((e,n)=>{addAppToUnload(r,()=>t,e,n),immediatelyUnloadApp(r,e,n)}),t}}function immediatelyUnloadApp(t,e,r){toUnmountPromise(t).then(toUnloadPromise).then(()=>{e(),setTimeout(()=>{reroute()})}).catch(r)}function validateRegisterWithArguments(t,e,r,n){if("string"!=typeof t||0===t.length)throw Error(formatErrorMessage(20,"The 1st argument to registerApplication must be a non-empty string 'appName'"));if(!e)throw Error(formatErrorMessage(23,"The 2nd argument to registerApplication must be an application or loading application function"));if("function"!=typeof r)throw Error(formatErrorMessage(24,"The 3rd argument to registerApplication must be an activeWhen function"));if(n&&("object"!=typeof n||Array.isArray(n)))throw Error(formatErrorMessage(22,"The optional 4th argument is a customProps and must be an object"))}function validateRegisterWithConfig(t){if(Array.isArray(t)||null===t)throw Error(formatErrorMessage(39,"Configuration object can't be an Array or null!"));const e=["name","app","activeWhen","customProps"],r=Object.keys(t).reduce((t,r)=>e.includes(r)?t:t.concat(r),[]);if(0!==r.length)throw Error(formatErrorMessage(38,`The configuration object accepts only: ${e.join(", ")}. Invalid keys: ${r.join(", ")}.`,e.join(", "),r.join(", ")));if("string"!=typeof t.name||0===t.name.length)throw Error(formatErrorMessage(20,"The config.name on registerApplication must be a non-empty string"));if("object"!=typeof t.app&&"function"!=typeof t.app)throw Error(formatErrorMessage(20,"The config.app on registerApplication must be an application or a loading function"));const n=t=>"string"==typeof t||"function"==typeof t;if(!(n(t.activeWhen)||Array.isArray(t.activeWhen)&&t.activeWhen.every(n)))throw Error(formatErrorMessage(24,"The config.activeWhen on registerApplication must be a string, function or an array with both"));if(t.customProps&&("object"!=typeof t.customProps||Array.isArray(t.customProps)))throw Error(formatErrorMessage(22,"The optional config.customProps must be an object"))}function sanitizeArguments(t,e,r,n){const o={name:null,loadApp:null,activeWhen:null,customProps:null};return"object"==typeof t?(validateRegisterWithConfig(t),o.name=t.name,o.loadApp=t.app,o.activeWhen=t.activeWhen,o.customProps=t.customProps):(validateRegisterWithArguments(t,e,r,n),o.name=t,o.loadApp=e,o.activeWhen=r,o.customProps=n),o.loadApp=sanitizeLoadApp(o.loadApp),o.customProps=sanitizeCustomProps(o.customProps),o.activeWhen=sanitizeActiveWhen(o.activeWhen),o}function sanitizeLoadApp(t){return"function"!=typeof t?()=>Promise.resolve(t):t}function sanitizeCustomProps(t){return t||{}}function sanitizeActiveWhen(t){let e=Array.isArray(t)?t:[t];return e=e.map(t=>"function"==typeof t?t:pathToActiveWhen(t)),t=>e.some(e=>e(t))}function pathToActiveWhen(t){const e=toDynamicPathValidatorRegex(t);return t=>{const r=t.href.replace(t.origin,"");return e.test(r)}}function toDynamicPathValidatorRegex(t){let e=0,r=!1,n="^";for(let e=0;e<t.length;e++){const n=t[e];(!r&&":"===n||r&&"/"===n)&&o(e)}return o(t.length),new RegExp(n,"i");function o(o){const a=t.slice(e,o).replace(/[|\\{}()[\]^$+*?.]/g,"\\$&");n+=r?"[^/]+/?":a,r=!r,e=o}}let appChangeUnderway=!1,peopleWaitingOnAppChange=[];function triggerAppChange(){return reroute()}function reroute(t=[],e){if(appChangeUnderway)return new Promise((t,r)=>{peopleWaitingOnAppChange.push({resolve:t,reject:r,eventArguments:e})});const r=[];return isStarted()?(appChangeUnderway=!0,Promise.resolve().then(()=>{window.dispatchEvent(new customEvent("single-spa:before-routing-event",i()));const e=n(getAppsToUnload()).map(toUnloadPromise),s=n(getAppsToUnmount()).map(toUnmountPromise).map(t=>t.then(toUnloadPromise)),u=s.concat(e),l=Promise.all(u),p=n(getAppsToLoad()),c=p.map(t=>toLoadPromise(t).then(toBootstrapPromise).then(t=>l.then(()=>toMountPromise(t)))),m=getAppsToMount().filter(t=>p.indexOf(t)<0).map(t=>(r.push(t),toBootstrapPromise(t).then(()=>l).then(()=>toMountPromise(t))));return l.catch(t=>{throw a(),t}).then(()=>(a(),Promise.all(c.concat(m)).catch(e=>{throw t.forEach(t=>t.reject(e)),e}).then(o)))})):Promise.resolve().then(()=>{const t=n(getAppsToLoad()).map(toLoadPromise);return Promise.all(t).then(a).then(()=>[]).catch(t=>{throw a(),t})});function n(t){return r.push(...t),t}function o(){const e=getMountedApps();t.forEach(t=>t.resolve(e));try{const t=0===r.length?"single-spa:no-app-change":"single-spa:app-change";window.dispatchEvent(new customEvent(t,i())),window.dispatchEvent(new customEvent("single-spa:routing-event",i()))}catch(t){setTimeout(()=>{throw t})}if(appChangeUnderway=!1,peopleWaitingOnAppChange.length>0){const t=peopleWaitingOnAppChange;peopleWaitingOnAppChange=[],reroute(t)}return e}function a(){t.forEach(t=>{callCapturedEventListeners(t.eventArguments)}),callCapturedEventListeners(e)}function i(){const t={},n={[MOUNTED]:[],[NOT_MOUNTED]:[],[NOT_LOADED]:[],[SKIP_BECAUSE_BROKEN]:[]};return r.forEach(e=>{const r=toName(e),o=getAppStatus(r);t[r]=o,(n[o]=n[o]||[]).push(r)}),{detail:{newAppStatuses:t,appsByNewStatus:n,totalAppChanges:r.length,originalEvent:null==e?void 0:e[0]}}}}let started=!1;function start(t){started=!0,t&&t.urlRerouteOnly&&setUrlRerouteOnly(t.urlRerouteOnly),isInBrowser&&reroute()}function isStarted(){return started}isInBrowser&&setTimeout(()=>{started||console.warn(formatErrorMessage(1,"singleSpa.start() has not been called, 5000ms after single-spa was loaded. Before start() is called, apps can be declared and loaded, but not bootstrapped or mounted."))},5e3);var devtools={getRawAppData:getRawAppData,reroute:reroute,NOT_LOADED:NOT_LOADED,toLoadPromise:toLoadPromise,toBootstrapPromise:toBootstrapPromise,unregisterApplication:unregisterApplication};isInBrowser&&window.__SINGLE_SPA_DEVTOOLS__&&(window.__SINGLE_SPA_DEVTOOLS__.exposedMethods=devtools);export{BOOTSTRAPPING,LOADING_SOURCE_CODE,LOAD_ERROR,MOUNTED,MOUNTING,NOT_BOOTSTRAPPED,NOT_LOADED,NOT_MOUNTED,SKIP_BECAUSE_BROKEN,UNMOUNTING,UPDATING,addErrorHandler,checkActivityFunctions,ensureJQuerySupport,getAppNames,getAppStatus,getMountedApps,mountRootParcel,navigateToUrl,registerApplication,removeErrorHandler,setBootstrapMaxTime,setMountMaxTime,setUnloadMaxTime,setUnmountMaxTime,start,triggerAppChange,unloadApplication};