import{OutMode}from"../../Enums/OutMode";import{Utils}from"../Utils/Utils";import{PolygonMaskType}from"../../Enums/PolygonMaskType";import{Mover}from"./Mover";import{RotateDirection}from"../../Enums/RotateDirection";export class Updater{constructor(t,o){this.container=t,this.particle=o,this.mover=new Mover(t,o)}static checkBounds(t,o,i,e){(t+o>i||t-o<0)&&e()}update(t){this.mover.move(t),this.updateOpacity(),this.updateSize(),this.updateAngle(),this.fixOutOfCanvasPosition(),this.updateOutMode()}updateOpacity(){const t=this.container.options,o=this.particle;t.particles.opacity.animation.enable&&(o.opacity.status?(o.opacity.value>=t.particles.opacity.value&&(o.opacity.status=!1),o.opacity.value+=o.opacity.velocity||0):(o.opacity.value<=t.particles.opacity.animation.minimumValue&&(o.opacity.status=!0),o.opacity.value-=o.opacity.velocity||0),o.opacity.value<0&&(o.opacity.value=0))}updateSize(){const t=this.container,o=t.options,i=this.particle;o.particles.size.animation.enable&&(i.size.status?(i.radius>=t.retina.sizeValue&&(i.size.status=!1),i.radius+=i.size.velocity||0):(i.radius<=o.particles.size.animation.minimumValue&&(i.size.status=!0),i.radius-=i.size.velocity||0),i.radius<0&&(i.radius=0))}updateAngle(){const t=this.container.options,o=this.particle;if(t.particles.rotate.animation.enable)switch(o.rotateDirection){case RotateDirection.clockwise:o.angle+=t.particles.rotate.animation.speed*Math.PI/18,o.angle>360&&(o.angle-=360);break;case RotateDirection.counterClockwise:default:o.angle-=t.particles.rotate.animation.speed*Math.PI/18,o.angle<0&&(o.angle+=360)}}fixOutOfCanvasPosition(){const t=this.container,o=t.options,i=this.particle,e=o.particles.move.outMode,a=t.canvas.dimension;let s;if(s=e===OutMode.bounce?{bottom:a.height,left:i.radius,right:a.width,top:i.radius}:e===OutMode.bounceHorizontal?{bottom:a.height+i.radius-i.offset.y,left:i.radius,right:a.width,top:-i.radius-i.offset.y}:e===OutMode.bounceVertical?{bottom:a.height,left:-i.radius-i.offset.x,right:a.width+i.radius+i.offset.x,top:i.radius}:{bottom:a.height+i.radius-i.offset.y,left:-i.radius-i.offset.x,right:a.width+i.radius+i.offset.x,top:-i.radius-i.offset.y},e===OutMode.destroy)t.canvas.isPointInside(i.position,i.radius)&&t.particles.remove(i);else{const o=t.canvas.calculateBounds(i.position,i.radius);o.left>a.width-i.offset.x?(i.position.x=s.left,i.position.y=Math.random()*a.height):o.right<-i.offset.x&&(i.position.x=s.right,i.position.y=Math.random()*a.height),o.top>a.height-i.offset.y?(i.position.y=s.top,i.position.x=Math.random()*a.width):o.bottom<-i.offset.y&&(i.position.y=s.bottom,i.position.x=Math.random()*a.width)}}updateOutMode(){switch(this.container.options.particles.move.outMode){case OutMode.bounce:case OutMode.bounceVertical:case OutMode.bounceHorizontal:this.updateBounce()}}updateBounce(){const t=this.container,o=t.options,i=this.particle;if(o.polygon.enable&&o.polygon.type!==PolygonMaskType.none&&o.polygon.type!==PolygonMaskType.inline)t.polygon.checkInsidePolygon(i.position)||this.polygonBounce();else if(o.polygon.enable&&o.polygon.type===PolygonMaskType.inline){if(i.initialPosition){Utils.getDistanceBetweenCoordinates(i.initialPosition,i.position)>t.retina.polygonMaskMoveRadius&&this.polygonBounce()}}else{const e=o.particles.move.outMode,a=i.position.x+i.offset.x,s=i.position.y+i.offset.y;e!==OutMode.bounce&&e!==OutMode.bounceHorizontal||Updater.checkBounds(a,i.radius,t.canvas.dimension.width,()=>{i.velocity.horizontal=-i.velocity.horizontal}),e!==OutMode.bounce&&e!==OutMode.bounceVertical||Updater.checkBounds(s,i.radius,t.canvas.dimension.height,()=>{i.velocity.vertical=-i.velocity.vertical})}}polygonBounce(){const t=this.particle;t.velocity.horizontal=-t.velocity.horizontal+t.velocity.vertical/2,t.velocity.vertical=-t.velocity.vertical+t.velocity.horizontal/2}};