import{Bubbler}from"./Particle/Bubbler";import{Drawer}from"./Particle/Drawer";import{Grabber}from"./Particle/Grabber";import{Repulser}from"./Particle/Repulser";import{ShapeType}from"../Enums/ShapeType";import{Updater}from"./Particle/Updater";import{Utils}from"./Utils/Utils";import{PolygonMaskType}from"../Enums/PolygonMaskType";import{Connecter}from"./Particle/Connecter";import{InteractionManager}from"./Particle/InteractionManager";import{HoverMode}from"../Enums/Modes/HoverMode";import{ClickMode}from"../Enums/Modes/ClickMode";import{RotateDirection}from"../Enums/RotateDirection";import{ColorUtils}from"./Utils/ColorUtils";export class Particle{constructor(i,t){var e,o,r,s,a,l,n,c;this.container=i;const h=i.options,p=h.particles.color;if(this.size={},this.angle=h.particles.rotate.random?360*Math.random():h.particles.rotate.value,h.particles.rotate.direction==RotateDirection.random){const i=Math.floor(2*Math.random());this.rotateDirection=i>0?RotateDirection.counterClockwise:RotateDirection.clockwise}else this.rotateDirection=h.particles.rotate.direction;const m=h.particles.size.random,y=i.retina.sizeValue;this.radius=m.enable?Utils.randomInRange(m.minimumValue,y):y,h.particles.size.animation.enable&&(this.size.status=!1,this.size.velocity=i.retina.sizeAnimationSpeed/100,h.particles.size.animation.sync||(this.size.velocity=this.size.velocity*Math.random())),h.particles.rotate.animation.enable&&(h.particles.rotate.animation.sync||(this.angle=360*Math.random())),this.position=this.calcPosition(this.container,t),h.polygon.enable&&h.polygon.type===PolygonMaskType.inline&&(this.initialPosition={x:this.position.x,y:this.position.y}),this.offset={x:0,y:0},h.particles.move.collisions&&this.checkOverlap(t),p instanceof Array?this.color=ColorUtils.colorToRgb(Utils.itemFromArray(p)):this.color=ColorUtils.colorToRgb(p);const d=h.particles.opacity.random,u=h.particles.opacity.value;this.opacity={value:d.enable?Utils.randomInRange(d.minimumValue,u):u},h.particles.opacity.animation.enable&&(this.opacity.status=!1,this.opacity.velocity=h.particles.opacity.animation.speed/100,h.particles.opacity.animation.sync||(this.opacity.velocity*=Math.random())),this.initialVelocity=Particle.calculateVelocity(h),this.velocity={horizontal:this.initialVelocity.horizontal,vertical:this.initialVelocity.vertical},this.fill=!0,this.close=!0;const v=h.particles.shape.type;if(v instanceof Array?this.shape=Utils.itemFromArray(v):this.shape=v,this.shape===ShapeType.image){const t=h.particles.shape,r=Utils.arrayRandomIndex(i.images),s=i.images[r],a=t.image instanceof Array?t.image[r]:t.image;this.image={data:s,ratio:a.width/a.height,replaceColor:a.replaceColor,src:a.src},this.image.ratio||(this.image.ratio=1),this.fill=null!==(e=a.fill)&&void 0!==e?e:this.fill,this.close=null!==(o=a.close)&&void 0!==o?o:this.close}if(this.shape===ShapeType.polygon&&(h.particles.shape.polygon instanceof Array?this.polygon=Utils.itemFromArray(h.particles.shape.polygon):this.polygon=h.particles.shape.polygon,this.fill=null!==(r=this.polygon.fill)&&void 0!==r?r:this.fill,this.close=null!==(s=this.polygon.close)&&void 0!==s?s:this.close),h.particles.stroke instanceof Array?this.stroke=Utils.itemFromArray(h.particles.stroke):this.stroke=h.particles.stroke,this.strokeColor="string"==typeof this.stroke.color?ColorUtils.stringToRgb(this.stroke.color):ColorUtils.colorToRgb(this.stroke.color),this.shadowColor="string"==typeof h.particles.shadow.color?ColorUtils.stringToRgb(h.particles.shadow.color):ColorUtils.colorToRgb(h.particles.shadow.color),this.shape===ShapeType.char||this.shape===ShapeType.character){h.particles.shape.character instanceof Array?this.character=Utils.itemFromArray(h.particles.shape.character):this.character=h.particles.shape.character;const i=this.character.value;this.text=i instanceof Array?Utils.itemFromArray(i):i,this.fill=null!==(a=this.character.fill)&&void 0!==a?a:this.fill,this.close=null!==(l=this.character.close)&&void 0!==l?l:this.close}const g=h.particles.shape.custom[this.shape];g&&(this.shapeData=g instanceof Array?Utils.itemFromArray(g):g,this.fill=null!==(n=this.shapeData.fill)&&void 0!==n?n:this.fill,this.close=null!==(c=this.shapeData.close)&&void 0!==c?c:this.close),this.updater=new Updater(this.container,this),this.bubbler=new Bubbler(this.container,this),this.repulser=new Repulser(this.container,this),this.drawer=new Drawer(this.container,this),this.grabber=new Grabber(this.container,this),this.connecter=new Connecter(this.container,this),this.interactionManager=new InteractionManager(this.container,this)}static calculateVelocity(i){const t=Utils.getParticleBaseVelocity(i),e={horizontal:0,vertical:0};return i.particles.move.straight?(e.horizontal=t.x,e.vertical=t.y,i.particles.move.random&&(e.horizontal*=Math.random(),e.vertical*=Math.random())):(e.horizontal=t.x+Math.random()-.5,e.vertical=t.y+Math.random()-.5),e}resetVelocity(){const i=this.container.options,t=Particle.calculateVelocity(i);this.velocity.horizontal=t.horizontal,this.velocity.vertical=t.vertical}update(i,t){const e=this.container,o=e.options;this.updater.update(t);const r=o.interactivity.events.onHover.mode,s=o.interactivity.events.onClick.mode;if(Utils.isInArray(HoverMode.grab,r)&&this.grabber.grab(),Utils.isInArray(HoverMode.connect,o.interactivity.events.onHover.mode))for(let t=i+1;t<e.particles.count;t++){const i=e.particles.array[t];this.connecter.connect(i)}(Utils.isInArray(HoverMode.bubble,r)||Utils.isInArray(ClickMode.bubble,s))&&this.bubbler.bubble(),(Utils.isInArray(HoverMode.repulse,r)||Utils.isInArray(ClickMode.repulse,s))&&this.repulser.repulse()}interact(i){this.interactionManager.interact(i)}draw(){this.drawer.draw()}isOverlapping(){const i=this.container,t=this;let e=!1,o=0;for(const r of i.particles.array.filter(i=>i!=t)){if(o++,Utils.getDistanceBetweenCoordinates(t.position,r.position)<=t.radius+r.radius){e=!0;break}}return{collisionFound:e,iterations:o}}checkOverlap(i){const t=this.container,e=this,o=e.isOverlapping();o.iterations>=t.particles.count?t.particles.remove(this):o.collisionFound&&(e.position.x=i?i.x:Math.random()*t.canvas.dimension.width,e.position.y=i?i.y:Math.random()*t.canvas.dimension.height,e.checkOverlap())}calcPosition(i,t){var e,o;const r={x:0,y:0};if(i.options.polygon.enable&&(null!==(o=null===(e=i.polygon.raw)||void 0===e?void 0:e.length)&&void 0!==o?o:0)>0)if(t)r.x=t.x,r.y=t.y;else{const t=i.polygon.randomPointInPolygon();r.x=t.x,r.y=t.y}else r.x=t?t.x:Math.random()*i.canvas.dimension.width,r.y=t?t.y:Math.random()*i.canvas.dimension.height,r.x>i.canvas.dimension.width-2*this.radius?r.x-=this.radius:r.x<2*this.radius&&(r.x+=this.radius),r.y>i.canvas.dimension.height-2*this.radius?r.y-=this.radius:r.y<2*this.radius&&(r.y+=this.radius);return r}};