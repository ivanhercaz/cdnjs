import{Particle}from"./Particle";import{PolygonMaskType}from"../Enums/PolygonMaskType";import{PolygonMaskInlineArrangement}from"../Enums/PolygonMaskInlineArrangement";export class Particles{constructor(t){this.container=t,this.array=[],this.interactionsEnabled=!1}get count(){return this.array.length}init(){const t=this.container,e=t.options;if(e.polygon.enable&&e.polygon.type===PolygonMaskType.inline&&e.polygon.inline.arrangement===PolygonMaskInlineArrangement.onePerPoint)t.polygon.drawPointsOnPolygonPath();else for(let n=this.array.length;n<e.particles.number.value;n++)this.addParticle(new Particle(t));this.interactionsEnabled=e.particles.lineLinked.enable||e.particles.move.attract.enable||e.particles.move.collisions}removeAt(t,e){t>=0&&t<=this.count&&this.array.splice(t,null!=e?e:1)}remove(t){this.removeAt(this.array.indexOf(t))}update(t){for(let e=0;e<this.array.length;e++){const n=this.array[e];if(n.update(e,t),this.interactionsEnabled)for(let t=e+1;t<this.array.length;t++){const e=this.array[t];n.interact(e)}}}draw(t){const e=this.container,n=e.options;e.canvas.clear(),this.update(t),n.polygon.enable&&n.polygon.draw.enable&&e.polygon.drawPolygon();for(const t of this.array)t.draw()}clear(){this.array=[]}push(t,e){const n=this.container,i=n.options;let a;this.pushing=!0,i.particles.number.limit>0&&this.array.length+t>i.particles.number.limit&&this.removeQuantity(this.array.length+t-i.particles.number.limit),e&&(a=e.position||{x:0,y:0});for(let e=0;e<t;e++)this.addParticle(new Particle(n,a));i.particles.move.enable||this.container.play(),this.pushing=!1}addParticle(t){this.array.push(t)}removeQuantity(t){const e=this.container.options;this.removeAt(0,t),e.particles.move.enable||this.container.play()}};