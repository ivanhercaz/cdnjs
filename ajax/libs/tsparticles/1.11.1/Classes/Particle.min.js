import{Bubbler}from"./Particle/Bubbler";import{Drawer}from"./Particle/Drawer";import{Grabber}from"./Particle/Grabber";import{Repulser}from"./Particle/Repulser";import{ShapeType}from"../Enums/ShapeType";import{Updater}from"./Particle/Updater";import{Utils}from"./Utils/Utils";import{PolygonMaskType}from"../Enums/PolygonMaskType";import{Connecter}from"./Particle/Connecter";import{InteractionManager}from"./Particle/InteractionManager";import{HoverMode}from"../Enums/Modes/HoverMode";import{ClickMode}from"../Enums/Modes/ClickMode";import{RotateDirection}from"../Enums/RotateDirection";import{ColorUtils}from"./Utils/ColorUtils";export class Particle{constructor(t,i){this.container=t;const e=t.options,o=e.particles.color;if(this.size={},this.angle=e.particles.rotate.random?360*Math.random():e.particles.rotate.value,e.particles.rotate.direction==RotateDirection.random){const t=Math.floor(2*Math.random());this.rotateDirection=t>0?RotateDirection.counterClockwise:RotateDirection.clockwise}else this.rotateDirection=e.particles.rotate.direction;const r=e.particles.size.random,a=t.retina.sizeValue;this.radius=r.enable?Utils.randomInRange(r.minimumValue,a):a,e.particles.size.animation.enable&&(this.size.status=!1,this.size.velocity=t.retina.sizeAnimationSpeed/100,e.particles.size.animation.sync||(this.size.velocity=this.size.velocity*Math.random())),e.particles.rotate.animation.enable&&(e.particles.rotate.animation.sync||(this.angle=360*Math.random())),this.position=this.calcPosition(this.container,i),e.polygon.enable&&e.polygon.type===PolygonMaskType.inline&&(this.initialPosition={x:this.position.x,y:this.position.y}),this.offset={x:0,y:0},e.particles.move.collisions&&this.checkOverlap(i),this.color=ColorUtils.colorToRgb(o);const s=e.particles.opacity.random,n=e.particles.opacity.value;this.opacity={value:s.enable?Utils.randomInRange(s.minimumValue,n):n},e.particles.opacity.animation.enable&&(this.opacity.status=!1,this.opacity.velocity=e.particles.opacity.animation.speed/100,e.particles.opacity.animation.sync||(this.opacity.velocity*=Math.random())),this.initialVelocity=Particle.calculateVelocity(e),this.velocity={horizontal:this.initialVelocity.horizontal,vertical:this.initialVelocity.vertical};const c=e.particles.shape.type;if(c instanceof Array?this.shape=Utils.itemFromArray(c):this.shape=c,this.shape===ShapeType.image){const i=e.particles.shape,o=Utils.arrayRandomIndex(t.images),r=t.images[o],a=i.image instanceof Array?i.image[o]:i.image;this.image={data:r,ratio:a.width/a.height,replaceColor:a.replaceColor,src:a.src},this.image.ratio||(this.image.ratio=1)}if(this.shape===ShapeType.polygon&&(e.particles.shape.polygon instanceof Array?this.polygon=Utils.itemFromArray(e.particles.shape.polygon):this.polygon=e.particles.shape.polygon),e.particles.shape.stroke instanceof Array?this.stroke=Utils.itemFromArray(e.particles.shape.stroke):this.stroke=e.particles.shape.stroke,this.strokeColor="string"==typeof this.stroke.color?ColorUtils.stringToRgb(this.stroke.color):ColorUtils.colorToRgb(this.stroke.color),this.shadowColor="string"==typeof e.particles.shadow.color?ColorUtils.stringToRgb(e.particles.shadow.color):ColorUtils.colorToRgb(e.particles.shadow.color),this.shape===ShapeType.char||this.shape===ShapeType.character){e.particles.shape.character instanceof Array?this.character=Utils.itemFromArray(e.particles.shape.character):this.character=e.particles.shape.character;const t=this.character.value;this.text=t instanceof Array?Utils.itemFromArray(t):t}this.updater=new Updater(this.container,this),this.bubbler=new Bubbler(this.container,this),this.repulser=new Repulser(this.container,this),this.drawer=new Drawer(this.container,this),this.grabber=new Grabber(this.container,this),this.connecter=new Connecter(this.container,this),this.interactionManager=new InteractionManager(this.container,this)}static calculateVelocity(t){const i=Utils.getParticleBaseVelocity(t),e={horizontal:0,vertical:0};return t.particles.move.straight?(e.horizontal=i.x,e.vertical=i.y,t.particles.move.random&&(e.horizontal*=Math.random(),e.vertical*=Math.random())):(e.horizontal=i.x+Math.random()-.5,e.vertical=i.y+Math.random()-.5),e}resetVelocity(){const t=this.container.options,i=Particle.calculateVelocity(t);this.velocity.horizontal=i.horizontal,this.velocity.vertical=i.vertical}update(t,i){const e=this.container,o=e.options;this.updater.update(i);const r=o.interactivity.events.onHover.mode,a=o.interactivity.events.onClick.mode;if(Utils.isInArray(HoverMode.grab,r)&&this.grabber.grab(),Utils.isInArray(HoverMode.connect,o.interactivity.events.onHover.mode))for(let i=t+1;i<e.particles.count;i++){const t=e.particles.array[i];this.connecter.connect(t)}(Utils.isInArray(HoverMode.bubble,r)||Utils.isInArray(ClickMode.bubble,a))&&this.bubbler.bubble(),(Utils.isInArray(HoverMode.repulse,r)||Utils.isInArray(ClickMode.repulse,a))&&this.repulser.repulse()}interact(t){this.interactionManager.interact(t)}draw(){this.drawer.draw()}isOverlapping(){const t=this.container,i=this;let e=!1,o=0;for(const r of t.particles.array.filter(t=>t!=i)){if(o++,Utils.getDistanceBetweenCoordinates(i.position,r.position)<=i.radius+r.radius){e=!0;break}}return{collisionFound:e,iterations:o}}checkOverlap(t){const i=this.container,e=this,o=e.isOverlapping();o.iterations>=i.particles.count?i.particles.remove(this):o.collisionFound&&(e.position.x=t?t.x:Math.random()*i.canvas.dimension.width,e.position.y=t?t.y:Math.random()*i.canvas.dimension.height,e.checkOverlap())}calcPosition(t,i){const e={x:0,y:0};if(t.polygon.raw&&t.polygon.raw.length>0)if(i)e.x=i.x,e.y=i.y;else{const i=t.polygon.randomPointInPolygon();e.x=i.x,e.y=i.y}else e.x=i?i.x:Math.random()*t.canvas.dimension.width,e.y=i?i.y:Math.random()*t.canvas.dimension.height,e.x>t.canvas.dimension.width-2*this.radius?e.x-=this.radius:e.x<2*this.radius&&(e.x+=this.radius),e.y>t.canvas.dimension.height-2*this.radius?e.y-=this.radius:e.y<2*this.radius&&(e.y+=this.radius);return e}};