import{Constants}from"./Utils/Constants";import{Utils}from"./Utils/Utils";import{CanvasUtils}from"./Utils/CanvasUtils";import{ColorUtils}from"./Utils/ColorUtils";export class Canvas{constructor(t){this.container=t,this.dimension={height:0,width:0},this.context=null,this.generatedCanvas=!1}init(){this.size();const t=this.container.options,o=t.backgroundMask.cover,i=t.particles.move.trail;this.coverColor=ColorUtils.colorToRgb(void 0!==o.color?o.color:t.backgroundMask.cover),this.trailFillColor="string"==typeof i.fillColor?ColorUtils.stringToRgb(i.fillColor):ColorUtils.colorToRgb(i.fillColor),this.paint()}loadCanvas(t,o){var i;t.className||(t.className=Constants.canvasClass),this.generatedCanvas&&(null===(i=this.element)||void 0===i||i.remove()),this.generatedCanvas=null!=o&&o,this.element=t,this.dimension.height=t.offsetHeight,this.dimension.width=t.offsetWidth,this.context=this.element.getContext("2d"),this.container.retina.init(),this.initBackground()}destroy(){var t;this.generatedCanvas&&(null===(t=this.element)||void 0===t||t.remove()),this.context&&CanvasUtils.clear(this.context,this.dimension)}size(){this.element&&(this.element.width=this.dimension.width,this.element.height=this.dimension.height)}paint(){const t=this.container.options;this.context&&(t.backgroundMask.enable&&t.backgroundMask.cover&&this.coverColor?this.paintBase(ColorUtils.getStyleFromColor(this.coverColor)):this.paintBase())}clear(){const t=this.container.options,o=t.particles.move.trail;t.backgroundMask.enable?this.paint():o.enable&&o.length>0&&this.trailFillColor?this.paintBase(ColorUtils.getStyleFromColor(this.trailFillColor,1/o.length)):this.context&&CanvasUtils.clear(this.context,this.dimension)}isPointInPath(t,o){var i,s;return null!==(s=null===(i=this.context)||void 0===i?void 0:i.isPointInPath(t,o.x,o.y))&&void 0!==s&&s}drawPolygonMask(){const t=this.container,o=t.options,i=this.context,s=o.polygon.draw,n=t.polygon,e=n.raw,r=n.polygonPath,l=n.path2DSupported;i&&(l&&r&&n.offset?CanvasUtils.drawPolygonMaskPath(i,r,s.stroke,n.offset):e&&CanvasUtils.drawPolygonMask(i,e,s.stroke))}drawLinkedLine(t,o,i,s,n){const e=this.container,r=e.options,l=this.context;if(!l)return;let a;if(e.particles.lineLinkedColor===Constants.randomColorValue)a=ColorUtils.getRandomRgbColor();else if("mid"==e.particles.lineLinkedColor&&t.color&&o.color){const i=t.color,s=o.color;a={b:Math.floor(Utils.mix(i.b,s.b,t.radius,o.radius)),g:Math.floor(Utils.mix(i.g,s.g,t.radius,o.radius)),r:Math.floor(Utils.mix(i.r,s.r,t.radius,o.radius))}}else a=e.particles.lineLinkedColor;const c=e.retina.lineLinkedWidth;CanvasUtils.drawLineLinked(l,c,i,s,r.backgroundMask.enable,a,n,r.particles.lineLinked.shadow)}drawConnectLine(t,o){const i=this.lineStyle(t,o);if(!i)return;const s=this.context;s&&CanvasUtils.drawConnectLine(s,this.container.retina.lineLinkedWidth,i,t.position,o.position)}drawGrabLine(t,o,i){const s=this.container,n=s.options.particles.lineLinked.color;let e=s.particles.lineLinkedColor||("string"==typeof n?ColorUtils.stringToRgb(n):ColorUtils.colorToRgb(n));e==Constants.randomColorValue&&(e=ColorUtils.getRandomRgbColor()),s.particles.lineLinkedColor=e;let r={r:127,g:127,b:127};const l=s.canvas.context;if(!l)return;r=s.particles.lineLinkedColor==Constants.randomColorValue?ColorUtils.getRandomRgbColor()||r:s.particles.lineLinkedColor||r;const a={x:t.position.x+t.offset.x,y:t.position.y+t.offset.y};CanvasUtils.drawGrabLine(l,s.retina.lineLinkedWidth,a,i,r,o)}drawParticle(t){const o=this.container.options;let i;const s=void 0!==t.bubbler.radius?t.bubbler.radius:t.radius,n=void 0!==t.bubbler.opacity?t.bubbler.opacity:t.opacity.value;t.color&&(i=ColorUtils.getStyleFromColor(t.color,n)),this.context&&i&&CanvasUtils.drawParticle(this.context,t,i,o.backgroundMask.enable,s,n)}paintBase(t){this.context&&CanvasUtils.paintBase(this.context,this.dimension,t)}lineStyle(t,o){if(t.color&&o.color){const i=t.color,s=o.color,n={b:Utils.mix(i.b,s.b,t.radius,o.radius),g:Utils.mix(i.g,s.g,t.radius,o.radius),r:Utils.mix(i.r,s.r,t.radius,o.radius)},e=ColorUtils.getStyleFromColor(n);if(this.context)return CanvasUtils.gradient(this.context,t,o,e)}}initBackground(){const t=this.container.options.background,o=this.element;if(!o)return;const i=o.style;if(t.color){const o="string"==typeof t.color?ColorUtils.stringToRgb(t.color):ColorUtils.colorToRgb(t.color);o&&(i.backgroundColor=ColorUtils.getStyleFromColor(o,t.opacity))}t.image&&(i.backgroundImage=t.image),t.position&&(i.backgroundPosition=t.position),t.repeat&&(i.backgroundRepeat=t.repeat),t.size&&(i.backgroundSize=t.size)}};