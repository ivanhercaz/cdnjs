import{ShapeUtils}from"./ShapeUtils";import{ColorUtils}from"./ColorUtils";export class CanvasUtils{static paintBase(o,t,e){o.save(),o.fillStyle=null!=e?e:"rgba(0,0,0,0)",o.fillRect(0,0,t.width,t.height),o.restore()}static clear(o,t){o.clearRect(0,0,t.width,t.height)}static drawPolygonMask(o,t,e){const l="string"==typeof e.color?ColorUtils.stringToRgb(e.color):ColorUtils.colorToRgb(e.color);if(l){o.save(),o.beginPath(),o.moveTo(t[0].x,t[0].y);for(let e=1;e<t.length;e++)o.lineTo(t[e].x,t[e].y);o.closePath(),o.strokeStyle=ColorUtils.getStyleFromColor(l),o.lineWidth=e.width,o.stroke(),o.restore()}}static drawPolygonMaskPath(o,t,e,l){o.save(),o.translate(l.x,l.y);const r="string"==typeof e.color?ColorUtils.stringToRgb(e.color):ColorUtils.colorToRgb(e.color);r&&(o.strokeStyle=ColorUtils.getStyleFromColor(r,e.opacity),o.lineWidth=e.width,o.stroke(t)),o.restore()}static drawLineLinked(o,t,e,l,r,s,i,a){o.save(),r&&(o.globalCompositeOperation="destination-out"),s&&(o.strokeStyle=ColorUtils.getStyleFromColor(s,i)),o.lineWidth=t,o.beginPath();const n="string"==typeof a.color?ColorUtils.stringToRgb(a.color):ColorUtils.colorToRgb(a.color);a.enable&&n&&(o.shadowBlur=a.blur,o.shadowColor=ColorUtils.getStyleFromColor(n)),o.moveTo(e.x,e.y),o.lineTo(l.x,l.y),o.stroke(),o.closePath(),o.restore()}static drawConnectLine(o,t,e,l,r){o.save(),o.beginPath(),o.lineWidth=t,o.strokeStyle=e,o.moveTo(l.x,l.y),o.lineTo(r.x,r.y),o.stroke(),o.closePath(),o.restore()}static gradient(o,t,e,l){const r=Math.floor(e.radius/t.radius);if(!t.color||!e.color)return;const s=t.position,i=e.position,a=o.createLinearGradient(s.x,s.y,i.x,i.y);return a.addColorStop(0,ColorUtils.getStyleFromColor(t.color)),a.addColorStop(r>1?1:r,l),a.addColorStop(1,ColorUtils.getStyleFromColor(e.color)),a}static drawGrabLine(o,t,e,l,r,s){o.save(),o.strokeStyle=ColorUtils.getStyleFromColor(r,s),o.lineWidth=t,o.beginPath(),o.moveTo(e.x,e.y),o.lineTo(l.x,l.y),o.stroke(),o.closePath(),o.restore()}static drawParticle(o,t,e,l,r,s){o.save();const i=t.container.options.particles.shadow,a=t.shadowColor;i.enable&&a&&(o.shadowBlur=i.blur,o.shadowColor=ColorUtils.getStyleFromColor(a),o.shadowOffsetX=i.offset.x,o.shadowOffsetY=i.offset.y),o.fillStyle=e;const n={x:t.position.x+t.offset.x,y:t.position.y+t.offset.y};o.translate(n.x,n.y),o.beginPath(),0!==t.angle&&o.rotate(t.angle*Math.PI/180),l&&(o.globalCompositeOperation="destination-out");const c=t.stroke;c.width>0&&t.strokeColor&&(o.strokeStyle=ColorUtils.getStyleFromColor(t.strokeColor,t.stroke.opacity),o.lineWidth=c.width),ShapeUtils.drawShape(o,t,r,s),t.close&&o.closePath(),c.width>0&&t.strokeColor&&o.stroke(),t.fill&&o.fill(),o.restore()}};