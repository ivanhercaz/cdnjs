import{Particle}from"./Particle";import{PolygonMaskType}from"../Enums/PolygonMaskType";import{PolygonMaskInlineArrangement}from"../Enums/PolygonMaskInlineArrangement";export class Particles{constructor(t){this.container=t,this.array=[],this.interactionsEnabled=!1}get count(){return this.array.length}init(){const t=this.container,e=t.options;if(e.polygon.enable&&e.polygon.type===PolygonMaskType.inline&&e.polygon.inline.arrangement===PolygonMaskInlineArrangement.onePerPoint)t.polygon.drawPointsOnPolygonPath();else for(let n=this.array.length;n<e.particles.number.value;n++)this.addParticle(new Particle(t));this.interactionsEnabled=e.particles.lineLinked.enable||e.particles.move.attract.enable||e.particles.move.collisions}redraw(){this.clear(),this.init(),this.draw(0)}removeAt(t,e){t>=0&&t<=this.count&&this.array.splice(t,null!=e?e:1)}remove(t){this.removeAt(this.array.indexOf(t))}update(t){for(let e=0;e<this.array.length;e++){const n=this.array[e];if(n.update(e,t),this.interactionsEnabled)for(let t=e+1;t<this.array.length;t++){const e=this.array[t];n.interact(e)}}}draw(t){const e=this.container,n=e.options;e.canvas.clear(),this.update(t),n.polygon.enable&&n.polygon.draw.enable&&e.polygon.drawPolygon();for(const t of this.array)t.draw()}clear(){this.array=[]}push(t,e){var n;const i=this.container,a=i.options;let r;this.pushing=!0,a.particles.number.limit>0&&this.array.length+t>a.particles.number.limit&&this.removeQuantity(this.array.length+t-a.particles.number.limit),e&&(r=null!==(n=e.position)&&void 0!==n?n:{x:0,y:0});for(let e=0;e<t;e++)this.addParticle(new Particle(i,r));a.particles.move.enable||this.container.play(),this.pushing=!1}addParticle(t){this.array.push(t)}removeQuantity(t){const e=this.container.options;this.removeAt(0,t),e.particles.move.enable||this.container.play()}};