import{OutMode}from"../../Enums/OutMode";import{Utils}from"../Utils/Utils";import{PolygonMaskType}from"../../Enums/PolygonMaskType";import{Mover}from"./Mover";import{RotateDirection}from"../../Enums/RotateDirection";import{SizeAnimationStatus}from"../../Enums/SizeAnimationStatus";import{OpacityAnimationStatus}from"../../Enums/OpacityAnimationStatus";export class Updater{constructor(t,i){this.container=t,this.particle=i,this.mover=new Mover(t,i)}static checkBounds(t,i,e,o){(t+i>e||t-i<0)&&o()}update(t){this.mover.move(t),this.updateOpacity(),this.updateSize(),this.updateAngle(),this.fixOutOfCanvasPosition(),this.updateOutMode()}updateOpacity(){const t=this.particle;if(t.particlesOptions.opacity.animation.enable){switch(t.opacity.status){case OpacityAnimationStatus.increasing:t.opacity.value>=t.particlesOptions.opacity.value?t.opacity.status=OpacityAnimationStatus.decreasing:t.opacity.value+=t.opacity.velocity||0;break;case OpacityAnimationStatus.decreasing:t.opacity.value<=t.particlesOptions.opacity.animation.minimumValue?t.opacity.status=OpacityAnimationStatus.increasing:t.opacity.value-=t.opacity.velocity||0}t.opacity.value<0&&(t.opacity.value=0)}}updateSize(){var t;const i=this.container,e=this.particle;if(e.particlesOptions.size.animation.enable){switch(e.size.status){case SizeAnimationStatus.increasing:e.size.value>=(null!==(t=e.sizeValue)&&void 0!==t?t:i.retina.sizeValue)?e.size.status=SizeAnimationStatus.decreasing:e.size.value+=e.size.velocity||0;break;case SizeAnimationStatus.decreasing:e.size.value<=e.particlesOptions.size.animation.minimumValue?e.size.status=SizeAnimationStatus.increasing:e.size.value-=e.size.velocity||0}e.size.value<0&&(e.size.value=0)}}updateAngle(){const t=this.particle;if(t.particlesOptions.rotate.animation.enable)switch(t.rotateDirection){case RotateDirection.clockwise:t.angle+=t.particlesOptions.rotate.animation.speed*Math.PI/18,t.angle>360&&(t.angle-=360);break;case RotateDirection.counterClockwise:default:t.angle-=t.particlesOptions.rotate.animation.speed*Math.PI/18,t.angle<0&&(t.angle+=360)}}fixOutOfCanvasPosition(){var t,i;const e=this.container,o=this.particle,a=o.particlesOptions.move.outMode,s=e.canvas.dimension;let n;if(n=a===OutMode.bounce?{bottom:s.height,left:o.size.value,right:s.width,top:o.size.value}:a===OutMode.bounceHorizontal?{bottom:s.height+o.size.value-o.offset.y,left:o.size.value,right:s.width,top:-o.size.value-o.offset.y}:a===OutMode.bounceVertical?{bottom:s.height,left:-o.size.value-o.offset.x,right:s.width+o.size.value+o.offset.x,top:o.size.value}:{bottom:s.height+o.size.value-o.offset.y,left:-o.size.value-o.offset.x,right:s.width+o.size.value+o.offset.x,top:-o.size.value-o.offset.y},a===OutMode.destroy){const i=null!==(t=o.sizeValue)&&void 0!==t?t:e.retina.sizeValue;Utils.isPointInside(o.position,e.canvas.dimension,i)||e.particles.remove(o)}else{const t=null!==(i=o.sizeValue)&&void 0!==i?i:e.retina.sizeValue,a=Utils.calculateBounds(o.position,t);a.left>s.width-o.offset.x?(o.position.x=n.left,o.position.y=Math.random()*s.height):a.right<-o.offset.x&&(o.position.x=n.right,o.position.y=Math.random()*s.height),a.top>s.height-o.offset.y?(o.position.y=n.top,o.position.x=Math.random()*s.width):a.bottom<-o.offset.y&&(o.position.y=n.bottom,o.position.x=Math.random()*s.width)}}updateOutMode(){switch(this.particle.particlesOptions.move.outMode){case OutMode.bounce:case OutMode.bounceVertical:case OutMode.bounceHorizontal:this.updateBounce()}}updateBounce(){const t=this.container,i=t.options,e=this.particle;if(i.polygon.enable&&i.polygon.type!==PolygonMaskType.none&&i.polygon.type!==PolygonMaskType.inline)t.polygon.checkInsidePolygon(e.position)||this.polygonBounce();else if(i.polygon.enable&&i.polygon.type===PolygonMaskType.inline){if(e.initialPosition){Utils.getDistanceBetweenCoordinates(e.initialPosition,e.position)>t.retina.polygonMaskMoveRadius&&this.polygonBounce()}}else{const i=e.particlesOptions.move.outMode,o=e.position.x+e.offset.x,a=e.position.y+e.offset.y;i!==OutMode.bounce&&i!==OutMode.bounceHorizontal||Updater.checkBounds(o,e.size.value,t.canvas.dimension.width,()=>{e.velocity.horizontal=-e.velocity.horizontal}),i!==OutMode.bounce&&i!==OutMode.bounceVertical||Updater.checkBounds(a,e.size.value,t.canvas.dimension.height,()=>{e.velocity.vertical=-e.velocity.vertical})}}polygonBounce(){const t=this.particle;t.velocity.horizontal=-t.velocity.horizontal+t.velocity.vertical/2,t.velocity.vertical=-t.velocity.vertical+t.velocity.horizontal/2}};