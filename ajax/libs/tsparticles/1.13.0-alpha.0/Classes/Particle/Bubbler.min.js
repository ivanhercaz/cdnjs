import{ProcessBubbleType}from"../../Enums/ProcessBubbleType";import{Utils}from"../Utils/Utils";import{HoverMode}from"../../Enums/Modes/HoverMode";import{ClickMode}from"../../Enums/Modes/ClickMode";import{Constants}from"../Utils/Constants";export class Bubbler{constructor(e,i){this.container=e,this.particle=i}static reset(e){delete e.bubble.opacity,delete e.bubble.radius}bubble(){const e=this.container.options,i=e.interactivity.events.onHover.enable,t=e.interactivity.events.onHover.mode,b=e.interactivity.events.onClick.enable,s=e.interactivity.events.onClick.mode;i&&Utils.isInArray(HoverMode.bubble,t)?this.hoverBubble():b&&Utils.isInArray(ClickMode.bubble,s)&&this.clickBubble()}process(e,i,t){const b=this.container,s=this.particle,o=b.options.interactivity.modes.bubble.duration,l=t.bubbleObj.optValue,a=b.retina.bubbleModeDistance,n=t.particlesObj.optValue,u=t.bubbleObj.value,r=t.particlesObj.value||0,c=t.type;if(l!==n)if(b.bubble.durationEnd){if(u){const e=2*l-r-i*(r-l)/o;c===ProcessBubbleType.size&&(s.bubble.radius=e),c===ProcessBubbleType.opacity&&(s.bubble.opacity=e)}}else if(e<=a){if((null!=u?u:r)!==l){const e=r-i*(r-l)/o;c===ProcessBubbleType.size&&(s.bubble.radius=e),c===ProcessBubbleType.opacity&&(s.bubble.opacity=e)}}else c===ProcessBubbleType.size&&(s.bubble.radius=void 0),c===ProcessBubbleType.opacity&&(s.bubble.opacity=void 0)}clickBubble(){var e;const i=this.container,t=i.options,b=this.particle,s=i.interactivity.mouse.clickPosition||{x:0,y:0},o=Utils.getDistanceBetweenCoordinates(b.position,s),l=((new Date).getTime()-(i.interactivity.mouse.clickTime||0))/1e3;if(i.bubble.clicking){l>t.interactivity.modes.bubble.duration&&(i.bubble.durationEnd=!0),l>2*t.interactivity.modes.bubble.duration&&(i.bubble.clicking=!1,i.bubble.durationEnd=!1);const s={bubbleObj:{optValue:i.retina.bubbleModeSize,value:b.bubble.radius},particlesObj:{optValue:null!==(e=b.sizeValue)&&void 0!==e?e:i.retina.sizeValue,value:b.size.value},type:ProcessBubbleType.size};this.process(o,l,s);const a={bubbleObj:{optValue:t.interactivity.modes.bubble.opacity,value:b.bubble.opacity},particlesObj:{optValue:b.particlesOptions.opacity.value,value:b.opacity.value},type:ProcessBubbleType.opacity};this.process(o,l,a)}}hoverBubble(){const e=this.container,i=this.particle,t=e.interactivity.mouse.position||{x:0,y:0},b=Utils.getDistanceBetweenCoordinates(i.position,t),s=1-b/e.retina.bubbleModeDistance;b<=e.retina.bubbleModeDistance?s>=0&&e.interactivity.status===Constants.mouseMoveEvent&&(this.hoverBubbleSize(s),this.hoverBubbleOpacity(s)):Bubbler.reset(i),e.interactivity.status===Constants.mouseLeaveEvent&&Bubbler.reset(i)}hoverBubbleSize(e){var i,t;const b=this.container,s=b.options,o=this.particle,l=s.interactivity.modes.bubble.size,a=o.particlesOptions.size.value,n=o.size.value;if(b.retina.bubbleModeSize>(null!==(i=o.sizeValue)&&void 0!==i?i:b.retina.sizeValue)){const i=n+l*e;i>n&&i<=l&&(o.bubble.radius=i)}else if(b.retina.bubbleModeSize<(null!==(t=o.sizeValue)&&void 0!==t?t:b.retina.sizeValue)){const i=n-(a-l)*e;i<n&&i>=l&&(o.bubble.radius=i)}}hoverBubbleOpacity(e){const i=this.container.options,t=this.particle,b=i.interactivity.modes.bubble.opacity,s=t.particlesOptions.opacity.value,o=t.opacity.value;if(b>s){const i=o+b*e;i>o&&i<=b&&(t.bubble.opacity=i)}else if(b<s){const i=o-(s-b)*e;i<o&&i>=b&&(t.bubble.opacity=i)}}};