import{Bubbler}from"./Particle/Bubbler";import{Drawer}from"./Particle/Drawer";import{Grabber}from"./Particle/Grabber";import{Repulser}from"./Particle/Repulser";import{ShapeType}from"../Enums/ShapeType";import{Updater}from"./Particle/Updater";import{Utils}from"./Utils/Utils";import{PolygonMaskType}from"../Enums/PolygonMaskType";import{Connecter}from"./Particle/Connecter";import{HoverMode}from"../Enums/Modes/HoverMode";import{ClickMode}from"../Enums/Modes/ClickMode";import{RotateDirection}from"../Enums/RotateDirection";import{ColorUtils}from"./Utils/ColorUtils";import{Particles}from"./Options/Particles/Particles";import{SizeAnimationStatus}from"../Enums/SizeAnimationStatus";import{OpacityAnimationStatus}from"../Enums/OpacityAnimationStatus";export class Particle{constructor(i,t,s){var o,e,a,r,n,l,c,h,p,m;this.container=i,this.emitter=s,this.fill=!0,this.close=!0,this.links=[];const d=i.options,y=new Particles;if(y.load(d.particles),void 0!==(null==s?void 0:s.emitterOptions.particles)){const i=s.emitterOptions.particles.shape.type;this.shape=i instanceof Array?Utils.itemFromArray(i):i;const t=s.emitterOptions.particles.shape.options[this.shape];t&&(this.shapeData=t instanceof Array?Utils.itemFromArray(t):t,this.fill=null!==(o=this.shapeData.fill)&&void 0!==o?o:this.fill,this.close=null!==(e=this.shapeData.close)&&void 0!==e?e:this.close),y.load(null===(a=this.shapeData)||void 0===a?void 0:a.particles),y.load(s.emitterOptions.particles)}else{const i=d.particles.shape.type;this.shape=i instanceof Array?Utils.itemFromArray(i):i;const t=d.particles.shape.options[this.shape];t&&(this.shapeData=t instanceof Array?Utils.itemFromArray(t):t,this.fill=null!==(r=this.shapeData.fill)&&void 0!==r?r:this.fill,this.close=null!==(n=this.shapeData.close)&&void 0!==n?n:this.close),y.load(null===(l=this.shapeData)||void 0===l?void 0:l.particles)}this.particlesOptions=y,i.retina.initParticle(this);const u=this.particlesOptions.color,v=null!==(c=this.sizeValue)&&void 0!==c?c:i.retina.sizeValue,f="boolean"==typeof this.particlesOptions.size.random?this.particlesOptions.size.random:this.particlesOptions.size.random.enable;if(this.size={value:f&&void 0!==this.randomMinimumSize?Utils.randomInRange(this.randomMinimumSize,v)*this.container.retina.pixelRatio:v},this.direction=s?s.emitterOptions.direction:this.particlesOptions.move.direction,this.bubble={},this.angle=this.particlesOptions.rotate.random?360*Math.random():this.particlesOptions.rotate.value,this.particlesOptions.rotate.direction==RotateDirection.random){const i=Math.floor(2*Math.random());this.rotateDirection=i>0?RotateDirection.counterClockwise:RotateDirection.clockwise}else this.rotateDirection=this.particlesOptions.rotate.direction;this.particlesOptions.size.animation.enable&&(this.size.status=SizeAnimationStatus.increasing,this.size.velocity=(null!==(h=this.sizeAnimationSpeed)&&void 0!==h?h:i.retina.sizeAnimationSpeed)/100,this.particlesOptions.size.animation.sync||(this.size.velocity=this.size.velocity*Math.random())),this.particlesOptions.rotate.animation.enable&&(this.particlesOptions.rotate.animation.sync||(this.angle=360*Math.random())),this.position=this.calcPosition(this.container,t),d.polygon.enable&&d.polygon.type===PolygonMaskType.inline&&(this.initialPosition={x:this.position.x,y:this.position.y}),this.offset={x:0,y:0},this.particlesOptions.move.collisions&&this.checkOverlap(t),u instanceof Array?this.color=ColorUtils.colorToRgb(Utils.itemFromArray(u)):this.color=ColorUtils.colorToRgb(u);const b=this.particlesOptions.opacity.random,g=this.particlesOptions.opacity.value;if(this.opacity={value:b.enable?Utils.randomInRange(b.minimumValue,g):g},this.particlesOptions.opacity.animation.enable&&(this.opacity.status=OpacityAnimationStatus.increasing,this.opacity.velocity=this.particlesOptions.opacity.animation.speed/100,this.particlesOptions.opacity.animation.sync||(this.opacity.velocity*=Math.random())),this.initialVelocity=this.calculateVelocity(),this.velocity={horizontal:this.initialVelocity.horizontal,vertical:this.initialVelocity.vertical},this.shape===ShapeType.image){const t=this.particlesOptions.shape,s=Utils.arrayRandomIndex(i.images),o=i.images[s],e=t.image instanceof Array?t.image[s]:t.image;this.image={data:o,ratio:e.width/e.height,replaceColor:e.replaceColor,src:e.src},this.image.ratio||(this.image.ratio=1),this.fill=null!==(p=e.fill)&&void 0!==p?p:this.fill,this.close=null!==(m=e.close)&&void 0!==m?m:this.close}this.stroke=this.particlesOptions.stroke instanceof Array?Utils.itemFromArray(this.particlesOptions.stroke):this.particlesOptions.stroke,this.strokeColor="string"==typeof this.stroke.color?ColorUtils.stringToRgb(this.stroke.color):ColorUtils.colorToRgb(this.stroke.color),this.shadowColor="string"==typeof this.particlesOptions.shadow.color?ColorUtils.stringToRgb(this.particlesOptions.shadow.color):ColorUtils.colorToRgb(this.particlesOptions.shadow.color),this.updater=new Updater(this.container,this),this.bubbler=new Bubbler(this.container,this),this.repulser=new Repulser(this.container,this)}resetVelocity(){const i=this.calculateVelocity();this.velocity.horizontal=i.horizontal,this.velocity.vertical=i.vertical}update(i,t){const s=this.container,o=s.options;this.links=[],this.updater.update(t);const e=o.interactivity.events.onHover.mode,a=o.interactivity.events.onClick.mode;if(Utils.isInArray(HoverMode.grab,e)&&Grabber.grab(this,s),Utils.isInArray(HoverMode.connect,o.interactivity.events.onHover.mode))for(let t=i+1;t<s.particles.count;t++){const i=s.particles.array[t];Connecter.connect(this,i,s)}(Utils.isInArray(HoverMode.bubble,e)||Utils.isInArray(ClickMode.bubble,a))&&this.bubbler.bubble(),(Utils.isInArray(HoverMode.repulse,e)||Utils.isInArray(ClickMode.repulse,a))&&this.repulser.repulse()}draw(){Drawer.draw(this,this.container)}isOverlapping(){const i=this.container,t=this;let s=!1,o=0;for(const e of i.particles.array.filter(i=>i!=t)){if(o++,Utils.getDistanceBetweenCoordinates(t.position,e.position)<=t.size.value+e.size.value){s=!0;break}}return{collisionFound:s,iterations:o}}checkOverlap(i){const t=this.container,s=this,o=s.isOverlapping();o.iterations>=t.particles.count?t.particles.remove(this):o.collisionFound&&(s.position.x=i?i.x:Math.random()*t.canvas.dimension.width,s.position.y=i?i.y:Math.random()*t.canvas.dimension.height,s.checkOverlap())}destroy(){}calcPosition(i,t){var s,o;const e={x:0,y:0};if(i.options.polygon.enable&&(null!==(o=null===(s=i.polygon.raw)||void 0===s?void 0:s.length)&&void 0!==o?o:0)>0)if(t)e.x=t.x,e.y=t.y;else{const t=i.polygon.randomPointInPolygon();e.x=t.x,e.y=t.y}else e.x=t?t.x:Math.random()*i.canvas.dimension.width,e.y=t?t.y:Math.random()*i.canvas.dimension.height,e.x>i.canvas.dimension.width-2*this.size.value?e.x-=this.size.value:e.x<2*this.size.value&&(e.x+=this.size.value),e.y>i.canvas.dimension.height-2*this.size.value?e.y-=this.size.value:e.y<2*this.size.value&&(e.y+=this.size.value);return e}calculateVelocity(){const i=Utils.getParticleBaseVelocity(this),t={horizontal:0,vertical:0};return this.particlesOptions.move.straight?(t.horizontal=i.x,t.vertical=i.y,this.particlesOptions.move.random&&(t.horizontal*=Math.random(),t.vertical*=Math.random())):(t.horizontal=i.x+Math.random()-.5,t.vertical=i.y+Math.random()-.5),t}};