import{ColorUtils}from"./ColorUtils";export class CanvasUtils{static paintBase(o,t,e){o.save(),o.fillStyle=null!=e?e:"rgba(0,0,0,0)",o.fillRect(0,0,t.width,t.height),o.restore()}static clear(o,t){o.clearRect(0,0,t.width,t.height)}static drawPolygonMask(o,t,e){const r="string"==typeof e.color?ColorUtils.stringToRgb(e.color):ColorUtils.colorToRgb(e.color);if(r){o.save(),o.beginPath(),o.moveTo(t[0].x,t[0].y);for(let e=1;e<t.length;e++)o.lineTo(t[e].x,t[e].y);o.closePath(),o.strokeStyle=ColorUtils.getStyleFromColor(r),o.lineWidth=e.width,o.stroke(),o.restore()}}static drawPolygonMaskPath(o,t,e,r){o.save(),o.translate(r.x,r.y);const l="string"==typeof e.color?ColorUtils.stringToRgb(e.color):ColorUtils.colorToRgb(e.color);l&&(o.strokeStyle=ColorUtils.getStyleFromColor(l,e.opacity),o.lineWidth=e.width,o.stroke(t)),o.restore()}static drawLineLinked(o,t,e,r,l,s,i,a){o.save(),l&&(o.globalCompositeOperation="destination-out"),s&&(o.strokeStyle=ColorUtils.getStyleFromColor(s,i)),o.lineWidth=t,o.beginPath();const n="string"==typeof a.color?ColorUtils.stringToRgb(a.color):ColorUtils.colorToRgb(a.color);a.enable&&n&&(o.shadowBlur=a.blur,o.shadowColor=ColorUtils.getStyleFromColor(n)),o.moveTo(e.x,e.y),o.lineTo(r.x,r.y),o.stroke(),o.closePath(),o.restore()}static drawConnectLine(o,t,e,r,l){o.save(),o.beginPath(),o.lineWidth=t,o.strokeStyle=e,o.moveTo(r.x,r.y),o.lineTo(l.x,l.y),o.stroke(),o.closePath(),o.restore()}static gradient(o,t,e,r,l){const s=Math.floor(e.size.value/t.size.value);if(!t.color||!e.color)return;const i=t.position,a=e.position,n=o.createLinearGradient(i.x,i.y,a.x,a.y);return n.addColorStop(0,ColorUtils.getStyleFromColor(t.color,l)),n.addColorStop(s>1?1:s,ColorUtils.getStyleFromColor(r,l)),n.addColorStop(1,ColorUtils.getStyleFromColor(e.color,l)),n}static drawGrabLine(o,t,e,r,l,s){o.save(),o.strokeStyle=ColorUtils.getStyleFromColor(l,s),o.lineWidth=t,o.beginPath(),o.moveTo(e.x,e.y),o.lineTo(r.x,r.y),o.stroke(),o.closePath(),o.restore()}static drawParticle(o,t,e,r,l,s,i){o.save();const a=t.shadowColor;i.enable&&a&&(o.shadowBlur=i.blur,o.shadowColor=ColorUtils.getStyleFromColor(a),o.shadowOffsetX=i.offset.x,o.shadowOffsetY=i.offset.y),o.fillStyle=e;const n={x:t.position.x+t.offset.x,y:t.position.y+t.offset.y};o.translate(n.x,n.y),o.beginPath(),0!==t.angle&&o.rotate(t.angle*Math.PI/180),r&&(o.globalCompositeOperation="destination-out");const c=t.stroke;c.width>0&&t.strokeColor&&(o.strokeStyle=ColorUtils.getStyleFromColor(t.strokeColor,t.stroke.opacity),o.lineWidth=c.width),this.drawShape(o,t,l,s),t.close&&o.closePath(),c.width>0&&t.strokeColor&&o.stroke(),t.fill&&o.fill(),o.restore()}static addShapeDrawer(o,t){this.drawers[o]||(this.drawers[o]=t)}static drawShape(o,t,e,r){if(!t.shape)return;const l=this.drawers[t.shape];l&&l.draw(o,t,e,r)}};CanvasUtils.drawers={};