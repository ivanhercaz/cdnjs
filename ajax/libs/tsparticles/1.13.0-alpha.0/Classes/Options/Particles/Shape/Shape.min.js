import{ShapeType}from"../../../../Enums/ShapeType";import{ImageShape}from"./ImageShape";import{PolygonShape}from"./PolygonShape";import{CharacterShape}from"./CharacterShape";export class Shape{constructor(){this.options={},this.character=new CharacterShape,this.image=new ImageShape,this.polygon=new PolygonShape,this.type=ShapeType.circle}get custom(){return this.options}set custom(e){this.options=e}get images(){return this.image instanceof Array?this.image:[this.image]}set images(e){this.image=e}get stroke(){return[]}set stroke(e){}get character(){var e;return null!==(e=this.options[ShapeType.character])&&void 0!==e?e:this.options[ShapeType.char]}set character(e){this.options[ShapeType.character]=e,this.options[ShapeType.char]=e}get polygon(){var e;return null!==(e=this.options[ShapeType.polygon])&&void 0!==e?e:this.options[ShapeType.star]}set polygon(e){this.options[ShapeType.polygon]=e,this.options[ShapeType.star]=e}load(e){var t;if(void 0!==e){const o=null!==(t=e.options)&&void 0!==t?t:e.custom;if(void 0!==o)for(const e in o){const t=o[e];void 0!==t&&(t instanceof Array?this.options[e]=t.filter(e=>void 0!==e).map(e=>e):this.options[e]=t)}if(void 0!==e.character){const t=e.character;void 0!==t&&(t instanceof Array?(this.options[ShapeType.character]=t.filter(e=>void 0!==e).map(e=>e),this.options[ShapeType.char]=t.filter(e=>void 0!==e).map(e=>e)):(this.options[ShapeType.character]=t,this.options[ShapeType.char]=t))}if(void 0!==e.polygon){const t=e.polygon;void 0!==t&&(t instanceof Array?(this.options[ShapeType.polygon]=t.filter(e=>void 0!==e).map(e=>e),this.options[ShapeType.star]=t.filter(e=>void 0!==e).map(e=>e)):(this.options[ShapeType.polygon]=t,this.options[ShapeType.star]=t))}void 0!==e.image&&(e.image instanceof Array?this.image=e.image.map(e=>{const t=new ImageShape;return t.load(e),t}):(this.image instanceof Array&&(this.image=new ImageShape),this.image.load(e.image))),void 0!==e.type&&(this.type=e.type)}}};