import{ShapeUtils}from"./ShapeUtils";import{ColorUtils}from"./ColorUtils";export class CanvasUtils{static paintBase(o,t,l){o.save(),o.fillStyle=null!=l?l:"rgba(0,0,0,0)",o.fillRect(0,0,t.width,t.height),o.restore()}static clear(o,t){o.clearRect(0,0,t.width,t.height)}static drawPolygonMask(o,t,l){const e="string"==typeof l.color?ColorUtils.stringToRgb(l.color):ColorUtils.colorToRgb(l.color);if(e){o.save(),o.beginPath(),o.moveTo(t[0].x,t[0].y);for(let l=1;l<t.length;l++)o.lineTo(t[l].x,t[l].y);o.closePath(),o.strokeStyle=ColorUtils.getStyleFromColor(e),o.lineWidth=l.width,o.stroke(),o.restore()}}static drawPolygonMaskPath(o,t,l,e){o.save(),o.translate(e.x,e.y);const r="string"==typeof l.color?ColorUtils.stringToRgb(l.color):ColorUtils.colorToRgb(l.color);r&&(o.strokeStyle=ColorUtils.getStyleFromColor(r,l.opacity),o.lineWidth=l.width,o.stroke(t)),o.restore()}static drawLineLinked(o,t,l,e,r,s,i,a){o.save(),r&&(o.globalCompositeOperation="destination-out"),s&&(o.strokeStyle=ColorUtils.getStyleFromColor(s,i)),o.lineWidth=t,o.beginPath();const n="string"==typeof a.color?ColorUtils.stringToRgb(a.color):ColorUtils.colorToRgb(a.color);a.enable&&n&&(o.shadowBlur=a.blur,o.shadowColor=ColorUtils.getStyleFromColor(n)),o.moveTo(l.x,l.y),o.lineTo(e.x,e.y),o.stroke(),o.closePath(),o.restore()}static drawConnectLine(o,t,l,e,r){o.save(),o.beginPath(),o.lineWidth=t,o.strokeStyle=l,o.moveTo(e.x,e.y),o.lineTo(r.x,r.y),o.stroke(),o.closePath(),o.restore()}static gradient(o,t,l,e,r){const s=Math.floor(l.radius/t.radius);if(!t.color||!l.color)return;const i=t.position,a=l.position,n=o.createLinearGradient(i.x,i.y,a.x,a.y);return n.addColorStop(0,ColorUtils.getStyleFromColor(t.color,r)),n.addColorStop(s>1?1:s,ColorUtils.getStyleFromColor(e,r)),n.addColorStop(1,ColorUtils.getStyleFromColor(l.color,r)),n}static drawGrabLine(o,t,l,e,r,s){o.save(),o.strokeStyle=ColorUtils.getStyleFromColor(r,s),o.lineWidth=t,o.beginPath(),o.moveTo(l.x,l.y),o.lineTo(e.x,e.y),o.stroke(),o.closePath(),o.restore()}static drawParticle(o,t,l,e,r,s){o.save();const i=t.container.options.particles.shadow,a=t.shadowColor;i.enable&&a&&(o.shadowBlur=i.blur,o.shadowColor=ColorUtils.getStyleFromColor(a),o.shadowOffsetX=i.offset.x,o.shadowOffsetY=i.offset.y),o.fillStyle=l;const n={x:t.position.x+t.offset.x,y:t.position.y+t.offset.y};o.translate(n.x,n.y),o.beginPath(),0!==t.angle&&o.rotate(t.angle*Math.PI/180),e&&(o.globalCompositeOperation="destination-out");const c=t.stroke;c.width>0&&t.strokeColor&&(o.strokeStyle=ColorUtils.getStyleFromColor(t.strokeColor,t.stroke.opacity),o.lineWidth=c.width),ShapeUtils.drawShape(o,t,r,s),t.close&&o.closePath(),c.width>0&&t.strokeColor&&o.stroke(),t.fill&&o.fill(),o.restore()}};