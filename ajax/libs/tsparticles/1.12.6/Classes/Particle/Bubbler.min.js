import{ProcessBubbleType}from"../../Enums/ProcessBubbleType";import{Utils}from"../Utils/Utils";import{HoverMode}from"../../Enums/Modes/HoverMode";import{ClickMode}from"../../Enums/Modes/ClickMode";import{Constants}from"../Utils/Constants";export class Bubbler{constructor(e,i){this.container=e,this.particle=i}bubble(){const e=this.container.options,i=e.interactivity.events.onHover.enable,t=e.interactivity.events.onHover.mode,s=e.interactivity.events.onClick.enable,o=e.interactivity.events.onClick.mode;i&&Utils.isInArray(HoverMode.bubble,t)?this.hoverBubble():s&&Utils.isInArray(ClickMode.bubble,o)&&this.clickBubble()}init(){const e=this.particle;this.opacity=e.opacity.value,this.radius=e.radius}process(e,i,t){const s=this.container,o=s.options.interactivity.modes.bubble.duration,a=t.bubbleObj.optValue,b=s.retina.bubbleModeDistance,n=t.particlesObj.optValue,c=t.bubbleObj.value,l=t.particlesObj.value||0,r=t.type;if(a!==n)if(s.bubble.durationEnd){if(c){const e=2*a-l-i*(l-a)/o;r===ProcessBubbleType.size&&(this.radius=e),r===ProcessBubbleType.opacity&&(this.opacity=e)}}else if(e<=b){if((null!=c?c:l)!==a){const e=l-i*(l-a)/o;r===ProcessBubbleType.size&&(this.radius=e),r===ProcessBubbleType.opacity&&(this.opacity=e)}}else r===ProcessBubbleType.size&&(this.radius=void 0),r===ProcessBubbleType.opacity&&(this.opacity=void 0)}clickBubble(){const e=this.container,i=e.options,t=this.particle,s=e.interactivity.mouse.clickPosition||{x:0,y:0},o=Utils.getDistanceBetweenCoordinates(t.position,s),a=((new Date).getTime()-(e.interactivity.mouse.clickTime||0))/1e3;if(e.bubble.clicking){a>i.interactivity.modes.bubble.duration&&(e.bubble.durationEnd=!0),a>2*i.interactivity.modes.bubble.duration&&(e.bubble.clicking=!1,e.bubble.durationEnd=!1);const t={bubbleObj:{optValue:e.retina.bubbleModeSize,value:this.radius},particlesObj:{optValue:e.retina.sizeValue,value:this.particle.radius},type:ProcessBubbleType.size};this.process(o,a,t);const s={bubbleObj:{optValue:i.interactivity.modes.bubble.opacity,value:this.opacity},particlesObj:{optValue:i.particles.opacity.value,value:this.particle.opacity.value},type:ProcessBubbleType.opacity};this.process(o,a,s)}}hoverBubble(){const e=this.container,i=this.particle,t=e.interactivity.mouse.position||{x:0,y:0},s=Utils.getDistanceBetweenCoordinates(i.position,t),o=1-s/e.retina.bubbleModeDistance;s<=e.retina.bubbleModeDistance?o>=0&&e.interactivity.status===Constants.mouseMoveEvent&&(this.hoverBubbleSize(o),this.hoverBubbleOpacity(o)):this.init(),e.interactivity.status===Constants.mouseLeaveEvent&&this.init()}hoverBubbleSize(e){const i=this.container,t=i.options,s=this.particle,o=t.interactivity.modes.bubble.size,a=t.particles.size.value,b=s.radius;if(i.retina.bubbleModeSize>i.retina.sizeValue){const i=b+o*e;i>b&&i<=o&&(this.radius=i)}else if(i.retina.bubbleModeSize<i.retina.sizeValue){const i=b-(a-o)*e;i<b&&i>=o&&(this.radius=i)}}hoverBubbleOpacity(e){const i=this.container.options,t=this.particle,s=i.interactivity.modes.bubble.opacity,o=i.particles.opacity.value,a=t.opacity.value;if(s>o){const i=a+s*e;i>a&&i<=s&&(this.opacity=i)}else if(s<o){const i=a-(o-s)*e;i<a&&i>=s&&(this.opacity=i)}}};