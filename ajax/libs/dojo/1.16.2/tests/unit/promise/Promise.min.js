define(["intern!object","intern/chai!assert","../../../Deferred"],function(e,c,u){e({name:"dojo/promise/Promise",".always will be invoked for resolution and rejection":function(){var n,r,t,e=new u,i={},o=new u,l={},a=this.async();e.promise.then(function(e){n=e}),e.promise.always(function(e){r=e,o.promise.then(null,function(e){t=e}),o.promise.always(a.callback(function(e){c.strictEqual(n,i),c.strictEqual(r,n),c.strictEqual(t,l),c.strictEqual(e,t)})),o.reject(l)}),e.resolve(i)},".otherwise() is equivalent to .then(null, ...)":function(){var n,e=new u,r={};e.promise.then(null,function(e){n=e}),e.promise.otherwise(this.async().callback(function(e){c.strictEqual(n,r),c.strictEqual(e,n)})),e.reject(r)},".trace() returns the same promise":function(){var e=(new u).promise;c.strictEqual(e.trace(),e)},".traceRejected() returns the same promise":function(){var e=(new u).promise;c.strictEqual(e.traceRejected(),e)},"finally() called when deferred already resolved":function(){var e=new u,n={};return e.resolve(n),e.promise.finally(function(e){return c.equal(e,void 0),"blah"}).then(function(e){c.equal(e,n)}).catch(function(){c.fail("Promise should not have rejected.")})},"finally() called when deferred is resolved later":function(){var e=new u,n={};return setTimeout(function(){e.resolve(n)},0),e.promise.finally(function(e){return c.equal(e,void 0),"blahblah"}).then(function(e){c.equal(e,n)}).catch(function(){c.fail("Promise should not have rejected.")})},"finally() called when deferred already rejected":function(){var e=new u,n=new Error;return e.reject(n),e.promise.finally(function(e){c.equal(e,void 0)}).then(function(){c.fail("Promise should not have resolved.")}).catch(function(e){c.equal(e,n)})},"finally() called when deferred is rejected later":function(){var e=new u,n=new Error;return setTimeout(function(){e.reject(n)},0),e.promise.finally(function(e){c.equal(e,void 0)}).then(function(){c.fail("Promise should not have resolved.")}).catch(function(e){c.equal(e,n)})},"finally() holds up call chain when chaining from a resolved promise and returning a promise that will resolve":function(){var e=new u,n=0,r={};e.resolve(r);var t=e.promise.finally(function(){var e=new u;return setTimeout(function(){n=1,e.resolve({})},0),e.promise});return c.equal(t.isResolved(),!1),c.equal(t.isFulfilled(),!1),t.then(function(e){c.equal(n,1),c.equal(e,r)},function(){c.fail("Promise should not have rejected")})},"finally() holds up call chain correctly when chaining from a rejected promise and returning a promise that will reject":function(){var e=new u,n=new Error;e.reject();var r=e.promise.finally(function(){var e=new u;return setTimeout(function(){e.reject(n)},0),e.promise});return c.equal(r.isRejected(),!1),c.equal(r.isFulfilled(),!1),r.then(function(){c.fail("Promise should not have resolved.")},function(e){c.equal(e,n)})},"finally() returns rejected promise if callback throws exception":function(){var e=new u,n=new Error;return e.resolve(),e.promise.finally(function(){throw n}).then(function(){c.fail("Promise should not have resolved.")}).catch(function(e){c.equal(e,n)})},"finally() returns rejected promise if chained off resolved promise and callback returns rejected promise":function(){var e=new u,n=new Error;return e.resolve(),e.promise.finally(function(){return(new u).reject(n)}).then(function(){c.fail("Promise should not have resolved")}).catch(function(e){c.equal(e,n)})},"finally() returns rejected promise if chained off rejected promise and callback returns rejected promise":function(){var e=new u,n=new Error;return e.reject(new Error),e.promise.finally(function(){return(new u).reject(n)}).then(function(){c.fail("Promise should not have resolved")}).catch(function(e){c.equal(e,n)})}})});