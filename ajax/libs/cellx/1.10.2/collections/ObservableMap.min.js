import{EventEmitter}from"../EventEmitter";const hasOwn=Object.prototype.hasOwnProperty;export class ObservableMap extends EventEmitter{constructor(e){if(super(),this._entries=new Map,e){let t=this._entries;if(e instanceof Map||e instanceof ObservableMap)for(let[r,s]of e instanceof Map?e:e._entries)t.set(r,s);else if(Array.isArray(e))for(let r=0,s=e.length;r<s;r++)t.set(e[r][0],e[r][1]);else for(let r in e)hasOwn.call(e,r)&&t.set(r,e[r])}}get size(){return this._entries.size}onChange(e,t){return this.on(ObservableMap.EVENT_CHANGE,e,t)}offChange(e,t){return this.off(ObservableMap.EVENT_CHANGE,e,t)}has(e){return this._entries.has(e)}get(e){return this._entries.get(e)}set(e,t){let r,s=this._entries,i=s.has(e);return i&&(r=s.get(e),Object.is(t,r))?this:(s.set(e,t),this.emit(ObservableMap.EVENT_CHANGE,{subtype:i?"update":"add",key:e,prevValue:r,value:t}),this)}delete(e){let t=this._entries;if(t.has(e)){let r=t.get(e);return t.delete(e),this.emit(ObservableMap.EVENT_CHANGE,{subtype:"delete",key:e,value:r}),!0}return!1}clear(){return this._entries.size&&(this._entries.clear(),this.emit(ObservableMap.EVENT_CHANGE,{subtype:"clear"})),this}equals(e){if(!(e instanceof ObservableMap))return!1;if(this.size!=e.size)return!1;for(let t of this)if(t[1]!==e.get(t[0]))return!1;return!0}forEach(e,t){for(let[r,s]of this._entries)e.call(t,s,r,this)}keys(){return this._entries.keys()}values(){return this._entries.values()}entries(){return this._entries.entries()}clone(e){let t;if(e){t=[];for(let[e,r]of this._entries)t.push([e,r&&"object"==typeof r&&r.clone?r.clone.length?r.clone(!0):r.clone():r])}return new this.constructor(t||this)}absorbFrom(e){if(!(e instanceof ObservableMap))throw TypeError('"that" must be instance of ObservableMap');let t=this._entries,r=!1;for(let[s,i]of t)if(e.has(s)){let a=e.get(s);i!==a&&(i&&a&&"object"==typeof i&&"object"==typeof a&&i.absorbFrom&&i.absorbFrom===a.absorbFrom?i.absorbFrom(a)&&(r=!0):(t.set(s,a),r=!0))}else t.delete(s),r=!0;for(let[s,i]of e)t.has(s)||(t.set(s,i),r=!0);return r&&this.emit(ObservableMap.EVENT_CHANGE,{subtype:"absorbFrom"}),r}toData(){let e={};for(let[t,r]of this._entries)e[t]=r&&"object"==typeof r&&r.toData?r.toData():r;return e}};ObservableMap.EVENT_CHANGE="change",ObservableMap.prototype[Symbol.iterator]=ObservableMap.prototype.entries;