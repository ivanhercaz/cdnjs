"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const utils_1=require("./utils"),hasOwn=Object.prototype.hasOwnProperty;let currentlySubscribing=!1,transactionLevel=0,transactionEvents=[],silently=0;class EventEmitter{static get currentlySubscribing(){return currentlySubscribing}static transact(t){transactionLevel++;try{t()}catch(t){utils_1.logError(t)}if(--transactionLevel)return;let e=transactionEvents;transactionEvents=[];for(let t of e)t.target.handleEvent(t)}static silently(t){silently++;try{t()}catch(t){utils_1.logError(t)}silently--}constructor(){this._events=new Map}getEvents(t){if(t){let e=this._events.get(t);return e?Array.isArray(e)?e:[e]:[]}let e=new Map;for(let[t,r]of this._events)e.set(t,Array.isArray(r)?r:[r]);return e}on(t,e,r){if("object"==typeof t){r=void 0!==e?e:this;let s=t;for(t in s)hasOwn.call(s,t)&&this._on(t,s[t],r);for(let t of Object.getOwnPropertySymbols(s))this._on(t,s[t],r)}else this._on(t,e,void 0!==r?r:this);return this}off(t,e,r){if(t)if("object"==typeof t){r=void 0!==e?e:this;let s=t;for(t in s)hasOwn.call(s,t)&&this._off(t,s[t],r);for(let t of Object.getOwnPropertySymbols(s))this._off(t,s[t],r)}else this._off(t,e,void 0!==r?r:this);else this._events.clear();return this}_on(t,e,r){let s;if("string"==typeof t&&-1!=(s=t.indexOf(":"))){let i=t.slice(s+1);currentlySubscribing=!0,(this[i+"Cell"]||(this[i],this[i+"Cell"])).on(t.slice(0,s),e,r),currentlySubscribing=!1}else{let s=this._events.get(t),i={listener:e,context:r};s?Array.isArray(s)?s.push(i):this._events.set(t,[s,i]):this._events.set(t,i)}}_off(t,e,r){let s;if("string"==typeof t&&-1!=(s=t.indexOf(":"))){let i=t.slice(s+1);(this[i+"Cell"]||(this[i],this[i+"Cell"])).off(t.slice(0,s),e,r)}else{let s,i=this._events.get(t);if(!i)return;if(Array.isArray(i)){if(1!=i.length){for(let t=i.length;t;)if((s=i[--t]).listener==e&&s.context===r){i.splice(t,1);break}return}s=i[0]}else s=i;s.listener==e&&s.context===r&&this._events.delete(t)}}once(t,e,r){function s(i){return this._off(t,s,r),e.call(this,i)}return void 0===r&&(r=this),this._on(t,s,r),s}emit(t,e){if("object"==typeof t)if(t.target){if(t.target!=this)throw new TypeError("Event cannot be emitted on this target")}else t.target=this;else t={target:this,type:t};if(e&&(t.data=e),!silently)if(transactionLevel)for(let e=transactionEvents.length;;){if(!e){(t.data||(t.data={})).prevEvent=null,transactionEvents.push(t);break}let r=transactionEvents[--e];if(r.target==this&&r.type===t.type){(t.data||(t.data={})).prevEvent=r,transactionEvents[e]=t;break}}else this.handleEvent(t);return t}handleEvent(t){let e=this._events.get(t.type);if(e)if(Array.isArray(e))if(1==e.length)!1===this._tryEventListener(e[0],t)&&(t.propagationStopped=!0);else{e=e.slice();for(let r=0;r<e.length;r++)!1===this._tryEventListener(e[r],t)&&(t.propagationStopped=!0)}else!1===this._tryEventListener(e,t)&&(t.propagationStopped=!0)}_tryEventListener(t,e){try{return t.listener.call(t.context,e)}catch(t){utils_1.logError(t)}}}exports.EventEmitter=EventEmitter;