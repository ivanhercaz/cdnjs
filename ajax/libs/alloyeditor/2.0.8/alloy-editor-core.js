window["AlloyEditor"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/adapter/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.8.5
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;

var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' ||
  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
}

/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var lowPriorityWarning = function () {};

{
  var printWarning = function (format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.warn(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  lowPriorityWarning = function (condition, format) {
    if (format === undefined) {
      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
    }
    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

var lowPriorityWarning$1 = lowPriorityWarning;

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;
    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;
          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;
              default:
                return $$typeof;
            }
        }
      case REACT_LAZY_TYPE:
      case REACT_MEMO_TYPE:
      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
}

// AsyncMode is deprecated along with isAsyncMode
var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;

var hasWarnedAboutDeprecatedIsAsyncMode = false;

// AsyncMode should be deprecated
function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true;
      lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }
  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.typeOf = typeOf;
exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isValidElementType = isValidElementType;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./src/adapter/core.js":
/*!*****************************!*\
  !*** ./src/adapter/core.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

__webpack_require__(/*! ../core */ "./src/core/index.js");

__webpack_require__(/*! ../plugins */ "./src/plugins/index.js");

__webpack_require__(/*! ../components/uibridge */ "./src/components/uibridge/index.js");

var _editorContext = __webpack_require__(/*! ./editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _oop = __webpack_require__(/*! ../oop/oop */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

var _lang = __webpack_require__(/*! ../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _base = __webpack_require__(/*! ../oop/base */ "./src/oop/base.js");

var _base2 = _interopRequireDefault(_base);

var _selections = __webpack_require__(/*! ../selections/selections */ "./src/selections/selections.js");

var _selections2 = _interopRequireDefault(_selections);

var _main = __webpack_require__(/*! ../components/main.jsx */ "./src/components/main.jsx");

var _main2 = _interopRequireDefault(_main);

var _commands = __webpack_require__(/*! ../commands */ "./src/commands/index.js");

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EMBED_VIDEO_WIDTH = 560;
var EMBED_VIDEO_HEIGHT = 315;

/**
 * AlloyEditor main class. Creates instance of the editor and provides the user configuration
 * to the UI.
 *
 * @class Core
 * @constructor
 * @param {Object} config The configuration to be used.
 */
function Core(config) {
	Core.superclass.constructor.call(this, config);
}

(0, _oop2.default)(Core, _base2.default, {
	/**
  * Initializer lifecycle implementation for the AlloyEditor class. Creates a CKEditor
  * instance, passing it the provided configuration attributes.
  *
  * @memberof Core
  * @instance
  * @protected
  * @method initializer
  * @param {Object} config Configuration object literal for the editor.
  */
	initializer: function initializer(config) {
		var node = this.get('srcNode');

		if (this.get('enableContentEditable')) {
			node.setAttribute('contenteditable', 'true');
		}

		var editor = CKEDITOR.inline(node);

		editor.config.allowedContent = this.get('allowedContent');

		editor.config.toolbars = this.get('toolbars');

		editor.config.removePlugins = this.get('removePlugins');

		editor.config.extraPlugins = this.get('extraPlugins');

		editor.config.embedProviders = this.get('embedProviders');

		editor.config.placeholderClass = this.get('placeholderClass');

		editor.config.pasteFromWordRemoveStyles = false;
		editor.config.pasteFromWordRemoveFontStyles = false;

		editor.config.selectionKeystrokes = this.get('selectionKeystrokes');

		editor.config.spritemap = this.get('spritemap');

		_lang2.default.mix(editor.config, config);

		if (CKEDITOR.env.ie && !CKEDITOR.env.edge) {
			var plugin = CKEDITOR.env.version === 11 ? 'ae_dragresize_ie11' : 'ae_dragresize_ie';

			editor.config.extraPlugins = editor.config.extraPlugins.replace('ae_dragresize', plugin);
			editor.config.removePlugins = editor.config.removePlugins.replace('ae_dragresize', plugin);
		}

		editor.once('contentDom', function () {
			this._addReadOnlyLinkClickListener(editor);

			var editable = editor.editable();

			var extraCommands = this.get('extraCommands');

			var extraCommandKeys = Object.keys(extraCommands);
			for (var i = 0; i < extraCommandKeys.length; i++) {
				var commandName = extraCommandKeys[i];

				if (editor.commands[commandName]) {
					continue;
				}

				editor.addCommand(commandName, extraCommands[commandName]);
			}

			editable.addClass('ae-editable');
		}.bind(this));

		this._editor = editor;

		AlloyEditor.loadLanguageResources(this._renderUI.bind(this));
	},


	/**
  * Destructor lifecycle implementation for the AlloyEdtor class. Destroys the CKEditor
  * instance and destroys all created toolbars.
  *
  * @memberof Core
  * @instance
  * @protected
  * @method destructor
  */
	destructor: function destructor() {
		this._destroyed = true;

		if (this._editorUIElement) {
			_reactDom2.default.unmountComponentAtNode(this._editorUIElement);
			this._editorUIElement.parentNode.removeChild(this._editorUIElement);
		}

		var nativeEditor = this.get('nativeEditor');

		if (nativeEditor) {
			var editable = nativeEditor.editable();

			if (editable) {
				editable.removeClass('ae-editable');

				if (this.get('enableContentEditable')) {
					this.get('srcNode').setAttribute('contenteditable', 'false');
				}
			}

			this._clearSelections();

			nativeEditor.destroy();
		}
	},


	/**
  * Clear selections from window object
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _clearSelections
  */
	_clearSelections: function _clearSelections() {
		var nativeEditor = this.get('nativeEditor');
		var isMSSelection = typeof window.getSelection != 'function';

		if (isMSSelection) {
			nativeEditor.document.$.selection.empty();
		} else {
			nativeEditor.document.getWindow().$.getSelection().removeAllRanges();
		}
	},


	/**
  * Method to set default link behavior
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _addReadOnlyLinkClickListener
  * @param {Object} editor
  */
	_addReadOnlyLinkClickListener: function _addReadOnlyLinkClickListener(editor) {
		editor.editable().on('click', this._defaultReadOnlyClickFn, this, {
			editor: editor
		});
	},


	/**
  * Called on `click` event when the editor is in read only mode. Navigates to link's URL or opens
  * the link in a new window.
  *
  * @memberof Core
  * @instance
  * @event readOnlyClick
  * @protected
  * @method _defaultReadOnlyClickFn
  * @param {Object} event The fired `click` event payload
  */
	_defaultReadOnlyClickFn: function _defaultReadOnlyClickFn(event) {
		var mouseEvent = event.data.$;
		var hasCtrlKey = mouseEvent.ctrlKey || mouseEvent.metaKey;
		var shouldOpen = this._editor.config.readOnly || hasCtrlKey;

		mouseEvent.preventDefault();

		if (!shouldOpen) {
			return;
		}

		if (event.listenerData.editor.editable().editor.fire('readOnlyClick', event.data) !== false) {
			var ckElement = new CKEDITOR.dom.elementPath(event.data.getTarget(), this);
			var link = ckElement.lastElement;

			if (link) {
				var href = link.$.attributes.href ? link.$.attributes.href.value : null;
				var target = hasCtrlKey ? '_blank' : link.$.attributes.target ? link.$.attributes.target.value : null;
				this._redirectLink(href, target);
			}
		}
	},


	/**
  * Retrieves the native CKEditor instance. Having this, the developer may use the API of CKEditor OOTB.
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _getNativeEditor
  * @return {Object} The current instance of CKEditor.
  */
	_getNativeEditor: function _getNativeEditor() {
		return this._editor;
	},


	/**
  * Redirects the browser to a given link
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _redirectLink
  * @param {string} href The href to take the browser to
  * @param {string=} target Specifies where to display the link
  */
	_redirectLink: function _redirectLink(href, target) {
		if (target && href) {
			window.open(href, target);
		} else if (href) {
			window.location.href = href;
		}
	},


	/**
  * Renders the specified from the user toolbars.
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _renderUI
  */
	_renderUI: function _renderUI() {
		var _this = this;

		if (!this._destroyed) {
			var editorUIElement = document.createElement('div');
			editorUIElement.className = 'ae-ui';

			var uiNode = this.get('uiNode') || document.body;

			uiNode.appendChild(editorUIElement);

			var callbackRef = function callbackRef(element) {
				if (!_this._mainUI && element) {
					_this._mainUI = element;
					_this.get('nativeEditor').fire('uiReady');
				}
			};

			_reactDom2.default.render(_react2.default.createElement(
				_editorContext2.default.Provider,
				{ value: { editor: this } },
				_react2.default.createElement(_main2.default, {
					eventsDelay: this.get('eventsDelay'),
					ref: callbackRef,
					toolbars: this.get('toolbars')
				})
			), editorUIElement);

			this._editorUIElement = editorUIElement;
		}
	},


	/**
  * The function returns an HTML element from the passed value. If the passed value is a string, it should be
  * the Id of the element which have to be retrieved from the DOM.
  * If an HTML Element is passed, the element itself will be returned.
  *
  * @memberof Core
  * @instance
  * @method _toElement
  * @protected
  * @param {!(String|HTMLElement)} value String, which have to correspond to an HTML element from the DOM,
  * or the HTML element itself. If Id is passed, the HTML element will be retrieved from the DOM.
  * @return {HTMLElement} An HTML element.
  */
	_toElement: function _toElement(value) {
		if (_lang2.default.isString(value)) {
			value = document.getElementById(value);
		}

		return value;
	},


	/**
  * Validates the allowed content attribute. Look
  * [here](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-allowedContent) for more information about the
  * supported values.
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _validateAllowedContent
  * @param {Any} value The value to be checked
  * @return {Boolean} True if the current value is valid configuration, false otherwise
  */
	_validateAllowedContent: function _validateAllowedContent(value) {
		return _lang2.default.isString(value) || _lang2.default.isObject(value) || _lang2.default.isBoolean(value);
	},


	/**
  * Validates the value of toolbars attribute
  *
  * @memberof Core
  * @instance
  * @protected
  * @method _validateToolbars
  * @param {Any} value The value to be checked
  * @return {Boolean} True if the current value is valid toolbars configuration, false otherwise
  */
	_validateToolbars: function _validateToolbars(value) {
		return _lang2.default.isObject(value) || _lang2.default.isNull(value);
	}
}, {
	ATTRS: {
		/**
   * Configures the allowed content for the current instance of AlloyEditor.
   * Look on the [official CKEditor API](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-allowedContent)
   * for more information about the valid values.
   *
   * @memberof Core
   * @instance
   * @property allowedContent
   * @default true
   * @writeOnce
   * @type {Boolean, String, Object}
   */
		allowedContent: {
			validator: '_validateAllowedContent',
			value: true,
			writeOnce: true
		},

		/**
   * Callback to be invoked when clicking on the
   * <code>src/components/buttons/button-link-edit-browse.jsx</code>
   * component.
   *
   * @memberof Core
   * @instance
   * @propety documentBrowseLinkCallback
   * @default undefined
   * @type {Function|undefined}
   */
		documentBrowseLinkCallback: {
			validator: _lang2.default.isFunction,
			value: undefined
		},

		/**
   * Configuration for the
   * <code>src/components/buttons/button-link-edit-browse.jsx</code>
   * component.
   *
   * @memberof Core
   * @instance
   * @propety documentBrowseLinkUrl
   * @default undefined
   * @type {String|undefined}
   */
		documentBrowseLinkUrl: {
			validator: _lang2.default.isString,
			value: undefined
		},

		/**
   * List of embed providers for videos
   *
   * @memberof Core
   * @instance
   * @property embedProviders
   * @default []
   * @type Array}
   */
		embedProviders: {
			validator: _lang2.default.isArray,
			value: [{
				id: 'facebook',
				tpl: '<iframe allowFullScreen="true" allowTransparency="true"\n\t\t\t\t\t\t\t\t\t\t\t\t frameborder="0" height="' + EMBED_VIDEO_HEIGHT + '"\n\t\t\t\t\t\t\t\t\t\t\t\t src="https://www.facebook.com/plugins/video.php?href={embedId}\'\n\t\t\t\t\t\t\t\t\t\t\t\t &show_text=0&width=' + EMBED_VIDEO_WIDTH + '&height=' + EMBED_VIDEO_HEIGHT + '" scrolling="no"\n\t\t\t\t\t\t\t\t\t\t\t\t style="border:none;overflow:hidden" width="' + EMBED_VIDEO_WIDTH + '}"></iframe>',
				type: 'video',
				urlSchemes: ['(https?:\\/\\/(?:www\\.)?facebook.com\\/\\S*\\/videos\\/\\S*)']
			}, {
				id: 'twitch',
				tpl: '<iframe allowfullscreen="true" frameborder="0"\n\t\t\t\t\t\t\t\t\t\t\t\t height="' + EMBED_VIDEO_HEIGHT + '"\n\t\t\t\t\t\t\t\t\t\t\t\t src="https://player.twitch.tv/?autoplay=false&video={embedId}"\n\t\t\t\t\t\t\t\t\t\t\t\t scrolling="no" width="' + EMBED_VIDEO_WIDTH + '"></iframe>',
				type: 'video',
				urlSchemes: ['https?:\\/\\/(?:www\\.)?twitch.tv\\/videos\\/(\\S*)$']
			}, {
				id: 'vimeo',
				tpl: '<iframe allowfullscreen frameborder="0" height="' + EMBED_VIDEO_HEIGHT + '"\n\t\t\t\t\t\t\t\t\t\t\t\t mozallowfullscreen src="https://player.vimeo.com/video/{embedId}"\n\t\t\t\t\t\t\t\t\t\t\t\t webkitallowfullscreen width="' + EMBED_VIDEO_WIDTH + '"></iframe>',
				type: 'video',
				urlSchemes: ['https?:\\/\\/(?:www\\.)?vimeo\\.com\\/album\\/.*\\/video\\/(\\S*)', 'https?:\\/\\/(?:www\\.)?vimeo\\.com\\/channels\\/.*\\/(\\S*)', 'https?:\\/\\/(?:www\\.)?vimeo\\.com\\/groups\\/.*\\/videos\\/(\\S*)', 'https?:\\/\\/(?:www\\.)?vimeo\\.com\\/(\\S*)$']
			}, {
				id: 'youtube',
				tpl: '<iframe allow="autoplay; encrypted-media" allowfullscreen\n\t\t\t\t\t\t\t\t\t\t\t\t height="' + EMBED_VIDEO_HEIGHT + '" frameborder="0"\n\t\t\t\t\t\t\t\t\t\t\t\t src="https://www.youtube.com/embed/{embedId}?rel=0"\n\t\t\t\t\t\t\t\t\t\t\t\t width="' + EMBED_VIDEO_WIDTH + '"></iframe>',
				type: 'video',
				urlSchemes: ['https?:\\/\\/(?:www\\.)?youtube.com\\/watch\\?v=(\\S*)$']
			}]
		},

		/**
   * Specifies whether AlloyEditor set the contenteditable attribute
   * to "true" on its srcNode.
   *
   * @memberof Core
   * @instance
   * @property enableContentEditable
   * @type Boolean
   * @default true
   * @writeOnce
   */
		enableContentEditable: {
			validator: _lang2.default.isBoolean,
			value: true,
			writeOnce: true
		},

		/**
   * The delay (timeout), in ms, after which events such like key or mouse events will be processed.
   *
   * @memberof Core
   * @instance
   * @property eventsDelay
   * @type {Number}
   */
		eventsDelay: {
			validator: _lang2.default.isNumber,
			value: 100
		},

		/**
   * The list of extra commands to be added to the editor.
   *
   * @memberof Core
   * @instance
   * @property extraCommands
   * @type {Object}
   */
		extraCommands: {
			validator: _lang2.default.isObject,
			value: {
				removeImage: _commands.removeImageCommand
			},
			writeOnce: true
		},

		/**
   * Specifies the extra plugins which have to be loaded to the current CKEditor instance in order to
   * make AlloyEditor to work properly.
   *
   * @memberof Core
   * @instance
   * @property extraPlugins
   * @default 'uicore,selectionregion,dragresize,addimages,placeholder,tabletools,tableresize,autolink'
   * @writeOnce
   * @type {String}
   */
		extraPlugins: {
			validator: _lang2.default.isString,
			value: 'ae_uicore,ae_selectionregion,ae_selectionkeystrokes,ae_imagealignment,ae_addimages,ae_placeholder,' + 'ae_tabletools,ae_tableresize,ae_autolink,ae_embed,ae_autolist,ae_dragresize,' + 'ae_uibridge,ae_richcombobridge,ae_panelmenubuttonbridge,ae_menubridge,ae_menubuttonbridge,ae_buttonbridge,font,colorbutton',
			writeOnce: true
		},

		/**
   * Specifies the "mode" for alloy editor
   * @memberof Core
   * @instance
   * @property mode
   * @default 'simple'
   * @writeOnce
   * @type {String}
   */
		mode: {
			validator: _lang2.default.isString,
			value: 'simple'
		},

		/**
   * Retrieves the native CKEditor instance. Having this, the developer may use the full API of CKEditor.
   *
   * @memberof Core
   * @instance
   * @property nativeEditor
   * @readOnly
   * @type {Object}
   */
		nativeEditor: {
			getter: '_getNativeEditor',
			readOnly: true
		},

		/**
   * Specifies the class, which should be added by Placeholder plugin
   * {{#crossLink "CKEDITOR.plugins.ae_placeholder}}{{/crossLink}}
   * when editor is not focused.
   *
   * @memberof Core
   * @instance
   * @property placeholderClass
   * @default 'ae-placeholder'
   * @writeOnce
   * @type {String}
   */
		placeholderClass: {
			validator: _lang2.default.isString,
			value: 'ae-placeholder',
			writeOnce: true
		},

		/**
   * Specifies the plugins, which come by default with CKEditor, but which are not needed by AlloyEditor.
   * These plugins add the default UI for CKeditor, which is no more needed. Please note that AlloyEdtor
   * comes with its own highly optimized copy of CKEditor (just customized via their official download page).
   * This version does not come with the unneeded plugins, so the value of this property won't be needed.
   * However, if you decide to go with the OOTB version of CKEditor, you will have to remove some of the
   * plugins if you decide to use AlloyEditor. Keep in mind that removing these plugins doesn't remove them
   * entirely from CKEditor. It just removes them from its current instance, in which you will use different
   * UI - those of AlloyEditor. You will be fully able to use both OOTB CKEditor and AlloyEditor on the same
   * page!
   *
   * @memberof Core
   * @instance
   * @property removePlugins
   * @default 'contextmenu,toolbar,elementspath,resize,liststyle,link'
   * @writeOnce
   * @type {String}
   */
		removePlugins: {
			validator: _lang2.default.isString,
			value: 'contextmenu,toolbar,elementspath,resize,liststyle,link',
			writeOnce: true
		},

		/**
   * Array of manual selection triggers. They can be configured to manually show a specific selection toolbar
   * by forcing the selection type. A selectionKeystroke item consists of a keys property with a [CKEditor keystroke
   * definition](http://docs.ckeditor.com/#!/api/CKEDITOR.config-cfg-keystrokes) and a selection property with
   * the selection name to trigger.
   *
   * @memberof Core
   * @instance
   * @property selectionKeystrokes
   * @type {Array}
   */
		selectionKeystrokes: {
			validator: _lang2.default.isArray,
			value: [{
				keys: CKEDITOR.CTRL + 76 /* L*/
				, selection: 'link'
			}, {
				keys: CKEDITOR.CTRL + CKEDITOR.SHIFT + 76 /* L*/
				, selection: 'embed'
			}]
		},

		/**
   * The path to the spritemap SVG used for icons
   *
   * @memberof Core
   * @instance
   * @property spritemap
   * @type String
   * @writeOnce
   */
		spritemap: {
			validator: _lang2.default.isString,
			value: 'alloy-editor/assets/icons/icons.svg',
			writeOnce: true
		},

		/**
   * The Node ID or HTMl node, which AlloyEditor should use as an editable area.
   *
   * @memberof Core
   * @instance
   * @property srcNode
   * @type String | Node
   * @writeOnce
   */
		srcNode: {
			setter: '_toElement',
			writeOnce: true
		},

		/**
   * The toolbars configuration for this editor instance
   *
   * @memberof Core
   * @instance
   * @property {Object} toolbars
   */
		toolbars: {
			validator: '_validateToolbars',
			value: {
				add: {
					buttons: ['imageFromFile', 'embed', 'camera', 'hline', 'table'],
					tabIndex: 2
				},
				styles: {
					selections: _selections2.default,
					tabIndex: 1
				}
			}
		},

		/**
   * The Node ID or HTMl node, where AlloyEditor's UI should be rendered.
   *
   * @memberof Core
   * @instance
   * @property uiNode
   * @type String | Node
   * @writeOnce
   */
		uiNode: {
			setter: '_toElement',
			writeOnce: true
		}
	}
});

CKEDITOR.event.implementOn(Core);

exports.default = Core;

/***/ }),

/***/ "./src/adapter/editor-context.js":
/*!***************************************!*\
  !*** ./src/adapter/editor-context.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * React context to avoid explicitly passing the editor instance all
 * through the component hierarchy via props.
 */
var EditorContext = _react2.default.createContext({});

/**
 * Helper that passes the editor context in via a prop.
 *
 * Context can only be accessed in `render()` and in lifecycle methods
 * (`componentDidMount()` etc). If a component needs to access context
 * elsewhere, such as in a constructor, the context needs to be passed
 * in via a prop.
 */
EditorContext.toProps = function (Component) {
  var forwardingComponent = _react2.default.forwardRef(function (props, ref) {
    return _react2.default.createElement(
      EditorContext.Consumer,
      null,
      function (context) {
        return _react2.default.createElement(Component, _extends({}, props, { context: context, ref: ref }));
      }
    );
  });
  forwardingComponent.key = Component.key;
  return forwardingComponent;
};

exports.default = EditorContext;

/***/ }),

/***/ "./src/adapter/main.js":
/*!*****************************!*\
  !*** ./src/adapter/main.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.registerBridgeButton = exports.regexBasePath = exports.loadLanguageResources = exports.implementEventTarget = exports.getUrl = exports.getButtons = exports.getBasePath = exports.editable = exports.Toolbars = exports.Selections = exports.SelectionTest = exports.SelectionSetPosition = exports.SelectionGetArrowBoxClasses = exports.OOP = exports.Lang = exports.Core = exports.Buttons = exports.Attribute = undefined;

var _core = __webpack_require__(/*! ./core */ "./src/adapter/core.js");

var _core2 = _interopRequireDefault(_core);

var _lang = __webpack_require__(/*! ../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _buttons = __webpack_require__(/*! ../components/buttons */ "./src/components/buttons/index.js");

var _buttons2 = _interopRequireDefault(_buttons);

var _toolbars = __webpack_require__(/*! ../components/toolbars */ "./src/components/toolbars/index.js");

var _toolbars2 = _interopRequireDefault(_toolbars);

var _selectionArrowbox = __webpack_require__(/*! ../selections/selection-arrowbox */ "./src/selections/selection-arrowbox.js");

var _selectionArrowbox2 = _interopRequireDefault(_selectionArrowbox);

var _selections = __webpack_require__(/*! ../selections/selections */ "./src/selections/selections.js");

var _selections2 = _interopRequireDefault(_selections);

var _selectionPosition = __webpack_require__(/*! ../selections/selection-position */ "./src/selections/selection-position.js");

var _selectionPosition2 = _interopRequireDefault(_selectionPosition);

var _selectionTest = __webpack_require__(/*! ../selections/selection-test */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

var _attribute = __webpack_require__(/*! ../oop/attribute */ "./src/oop/attribute.js");

var _attribute2 = _interopRequireDefault(_attribute);

var _oop = __webpack_require__(/*! ../oop/oop */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

__webpack_require__(/*! ../plugins */ "./src/plugins/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// An object containing all currently registered plugins in AlloyEditor.
var BRIDGE_BUTTONS = {};

/**
 * Creates an instance of AlloyEditor.
 *
 * @memberof AlloyEditor
 * @method editable
 * @static
 * @param {String|Node} node The Node ID or HTMl node, which AlloyEditor should use as an editable area.
 * @param {Object} config Configuration attributes for the current instance of AlloyEditor.
 * @return {Object} An instance of {{#crossLink "Core"}}{{/crossLink}}
 */
var editable = function editable(node, config) {
	config = config || {};
	config.srcNode = node;

	AlloyEditor.implementEventTarget();

	return new _core2.default(config);
};

/**
 * The full URL for the AlloyEditor installation directory.
 * It is possible to manually provide the base path by setting a
 * global variable named `ALLOYEDITOR_BASEPATH`. This global variable
 * must be set **before** the editor script loading.
 *
 * @memberof AlloyEditor
 * @method getBasePath
 * @static
 * @return {String} The found base path
 */
var getBasePath = function getBasePath() {
	// Find out the editor directory path, based on its <script> tag.
	var path = window.ALLOYEDITOR_BASEPATH || '';

	if (!path) {
		var scripts = document.getElementsByTagName('script');

		for (var i = 0; i < scripts.length; i++) {
			var match = scripts[i].src.match(AlloyEditor.regexBasePath);

			if (match) {
				path = match[1];
				break;
			}
		}
	}

	// In IE (only) the script.src string is the raw value entered in the
	// HTML source. Other browsers return the full resolved URL instead.
	if (path.indexOf(':/') === -1 && path.slice(0, 2) !== '//') {
		// Absolute path.
		if (path.indexOf('/') === 0) {
			path = location.href.match(/^.*?:\/\/[^/]*/)[0] + path;
		}
		// Relative path.
		else {
				path = location.href.match(/^[^?]*\/(?:)/)[0] + path;
			}
	}

	if (!path) {
		throw new Error('The AlloyEditor installation path could not be automatically detected. Please set the global variable "ALLOYEDITOR_BASEPATH" before creating editor instances.');
	}

	return path;
};

/**
 * Detects and load the corresponding language file if AlloyEditor language strings are not already present.
 * The function fires a {{#crossLink "AlloyEditor/languageResourcesLoaded:event"}}{{/crossLink}} event
 *
 * @memberof AlloyEditor
 * @method loadLanguageResources
 * @static
 * @param {Function} callback Optional callback to be called when AlloyEditor loads the language resource.
 */
var loadLanguageResources = function loadLanguageResources(callback) {
	AlloyEditor.implementEventTarget();

	if (_lang2.default.isFunction(callback)) {
		if (AlloyEditor.Strings) {
			setTimeout(callback, 0);
		} else {
			AlloyEditor.once('languageResourcesLoaded', function () {
				setTimeout(callback, 0);
			});
		}
	}

	if (!AlloyEditor._langResourceRequested) {
		AlloyEditor._langResourceRequested = true;

		var languages = ['af', 'ar', 'bg', 'bn', 'bs', 'ca', 'cs', 'cy', 'da', 'de', 'el', 'en-au', 'en-ca', 'en-gb', 'en', 'eo', 'es', 'et', 'eu', 'fa', 'fi', 'fo', 'fr-ca', 'fr', 'gl', 'gu', 'he', 'hi', 'hr', 'hu', 'id', 'is', 'it', 'ja', 'ka', 'km', 'ko', 'ku', 'lt', 'lv', 'mk', 'mn', 'ms', 'nb', 'nl', 'no', 'pl', 'pt-br', 'pt', 'ro', 'ru', 'si', 'sk', 'sl', 'sq', 'sr-latn', 'sr', 'sv', 'th', 'tr', 'tt', 'ug', 'uk', 'vi', 'zh-cn', 'zh'];

		var userLanguage = navigator.language || navigator.userLanguage || 'en';

		var parts = userLanguage.toLowerCase().match(/([a-z]+)(?:-([a-z]+))?/);
		var lang = parts[1];
		var locale = parts[2];

		if (languages.indexOf(lang + '-' + locale) >= 0) {
			lang = lang + '-' + locale;
		} else if (languages.indexOf(lang) === -1) {
			lang = 'en';
		}

		CKEDITOR.scriptLoader.load(AlloyEditor.getUrl('lang/alloy-editor/' + lang + '.js'), function (loaded) {
			if (loaded) {
				AlloyEditor.fire('languageResourcesLoaded');
			}
		},
		/* eslint-disable babel/no-invalid-this */
		this // Always `AlloyEditor`.
		/* eslint-enable babel/no-invalid-this */
		);
	}
};

/**
 * Gets the full URL for AlloyEditor resources. By default, URLs
 * returned by this function contain a querystring parameter ("t")
 * set to the {@link CKEDITOR#timestamp} value.
 *
 * @memberof AlloyEditor
 * @method getUrl
 * @static
 * @param {String} resource The resource whose full URL we want to get.
 * It may be a full, absolute, or relative URL.
 * @return {String} The full URL.
 */
var getUrl = function getUrl(resource) {
	var basePath = AlloyEditor.getBasePath();

	// If this is not a full or absolute path.
	if (resource.indexOf(':/') === -1 && resource.indexOf('/') !== 0) {
		resource = basePath + resource;
	}

	// Add the timestamp, except for directories.
	if (CKEDITOR.timestamp && resource.charAt(resource.length - 1) !== '/' && !/[&?]t=/.test(resource)) {
		resource += (resource.indexOf('?') >= 0 ? '&' : '?') + 't=' + CKEDITOR.timestamp;
	}

	return resource;
};

/**
 * Implements event firing and subscribing via CKEDITOR.event.
 *
 * @memberof AlloyEditor
 * @method implementEventTarget
 * @static
 */
var implementEventTarget = function implementEventTarget() {
	if (!AlloyEditor.fire && !AlloyEditor.on) {
		CKEDITOR.event.implementOn(AlloyEditor);
	}
};

/**
 * Regular expression which should match the script which have been used to load AlloyEditor.
 *
 * @memberof AlloyEditor
 * @property regexBasePath
 * @type {RegExp}
 * @static
 */
var regexBasePath = /(^|.*[\\/])(?:alloy-editor[^/]+|alloy-editor)\.js(?:\?.*|;.*)?$/i;

/**
 * Fired when AlloyEditor detects the browser language and loads the corresponding language file. Once this event
 * is fired, AlloyEditor.Strings will be populated with data.
 *
 * @event languageResourcesLoaded
 */

/**
 * Returns the required plugin names needed for a given plugin
 * if it is already registered or an empty array.
 *
 * @memberof AlloyEditor
 * @method getButtons
 * @param {Array} buttons An array of buttons or plugin names.
 * @return {Function} A function that can be invoked to resolve the requested button names.
 * @static
 */
var getButtons = function getButtons(buttons) {
	return function () {
		return buttons.reduce(function (acc, val) {
			val = BRIDGE_BUTTONS[val] || [val];
			return acc.concat(val);
		}, []);
	};
};

/**
 * Register a button and try to get its required plugins.
 *
 * @memberof AlloyEditor
 * @method registerBridgeButton
 * @param {String} buttonName The name of the button.
 * @param {String} pluginName The name of the plugin that registers the button.
 * @static
 */
var registerBridgeButton = function registerBridgeButton(buttonName, pluginName) {
	if (!BRIDGE_BUTTONS[pluginName]) {
		BRIDGE_BUTTONS[pluginName] = [];
	}

	BRIDGE_BUTTONS[pluginName].push(buttonName);
};

/**
 * @method OOP
 * @memberof AlloyEditor
 */
var OOP = {
	extend: _oop2.default
};

exports.Attribute = _attribute2.default;
exports.Buttons = _buttons2.default;
exports.Core = _core2.default;
exports.Lang = _lang2.default;
exports.OOP = OOP;
exports.SelectionGetArrowBoxClasses = _selectionArrowbox2.default;
exports.SelectionSetPosition = _selectionPosition2.default;
exports.SelectionTest = _selectionTest2.default;
exports.Selections = _selections2.default;
exports.Toolbars = _toolbars2.default;
exports.editable = editable;
exports.getBasePath = getBasePath;
exports.getButtons = getButtons;
exports.getUrl = getUrl;
exports.implementEventTarget = implementEventTarget;
exports.loadLanguageResources = loadLanguageResources;
exports.regexBasePath = regexBasePath;
exports.registerBridgeButton = registerBridgeButton;

/***/ }),

/***/ "./src/commands/index.js":
/*!*******************************!*\
  !*** ./src/commands/index.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeImageCommand = undefined;

var _removeImage = __webpack_require__(/*! ./remove-image */ "./src/commands/remove-image.js");

var _removeImage2 = _interopRequireDefault(_removeImage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.removeImageCommand = _removeImage2.default;

/***/ }),

/***/ "./src/commands/remove-image.js":
/*!**************************************!*\
  !*** ./src/commands/remove-image.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var removeImageCommand = {
	exec: function exec(editor) {
		var selection = editor.getSelection();

		if (selection) {
			var ranges = selection.getRanges();
			var startContainer = ranges[0].startContainer;

			var nextRange = new CKEDITOR.dom.range(startContainer);
			nextRange.setStart(startContainer, 0);
			nextRange.setEnd(startContainer, 0);

			var selectedElement = selection.getSelectedElement();

			if (selectedElement && selectedElement.getName() === 'img') {
				var native = selection.getNative();
				if (native) {
					native.removeAllRanges();
				}

				selection.selectRanges([nextRange]);

				selectedElement.remove();
			}
		}
	}
};

exports.default = removeImageCommand;

/***/ }),

/***/ "./src/components/base/button-action-style.js":
/*!****************************************************!*\
  !*** ./src/components/base/button-action-style.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonActionStyle is a mixin that provides applying style implementation for a
 * button based on the `applyStyle` and `removeStyle` API of CKEDITOR.
 *
 * To execute properly, the component has to expose the following methods which can be obtained
 * out of the box using the {{#crossLink "ButtonStyle"}}{{/crossLink}} mixin:
 * - `Function` {{#crossLink "ButtonStyle/isActive"}}{{/crossLink}} to check the active state
 * - `Function` {{#crossLink "ButtonStyle/getStyle"}}{{/crossLink}} to return the style that should be applied
 *
 * @class ButtonActionStyle
 */
exports.default = function (WrappedComponent) {
	var _class, _temp2;

	return _temp2 = _class = function (_WrappedComponent) {
		_inherits(ButtonActionStyle, _WrappedComponent);

		function ButtonActionStyle() {
			var _ref;

			var _temp, _this, _ret;

			_classCallCheck(this, ButtonActionStyle);

			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonActionStyle.__proto__ || Object.getPrototypeOf(ButtonActionStyle)).call.apply(_ref, [this].concat(args))), _this), _this.applyStyle = function () {
				if (_lang2.default.isFunction(_this.isActive) && _lang2.default.isFunction(_this.getStyle)) {
					var editor = _this.context.editor.get('nativeEditor');

					editor.getSelection().lock();

					if (_this.isActive()) {
						editor.removeStyle(_this.getStyle());
					} else {
						editor.applyStyle(_this.getStyle());
					}

					editor.getSelection().unlock();

					editor.fire('actionPerformed', _this);
				}
			}, _temp), _possibleConstructorReturn(_this, _ret);
		}

		/**
   * Removes or applies the component style to the current selection.
   *
   * @instance
   * @memberof ButtonActionStyle
   * @method applyStyle
   */


		return ButtonActionStyle;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp2;
};

/***/ }),

/***/ "./src/components/base/button-command-active.js":
/*!******************************************************!*\
  !*** ./src/components/base/button-command-active.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonCommandActive is a mixin that provides an `isActive` method to determine if
 * a context-aware command is currently in an active state.
 *
 * @class ButtonCommandActive
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(ButtonCommandActive, _WrappedComponent);

		function ButtonCommandActive() {
			_classCallCheck(this, ButtonCommandActive);

			return _possibleConstructorReturn(this, (ButtonCommandActive.__proto__ || Object.getPrototypeOf(ButtonCommandActive)).apply(this, arguments));
		}

		_createClass(ButtonCommandActive, [{
			key: 'isActive',


			/**
    * Checks if the command is active in the current selection.
    *
    * @instance
    * @memberof ButtonCommandActive
    * @method isActive
    * @return {Boolean} True if the command is active, false otherwise.
    */
			value: function isActive() {
				var editor = this.context.editor.get('nativeEditor');

				var command = editor.getCommand(this.props.command);

				return command ? command.state === CKEDITOR.TRISTATE_ON : false;
			}
		}]);

		return ButtonCommandActive;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp;
};

/***/ }),

/***/ "./src/components/base/button-command.js":
/*!***********************************************!*\
  !*** ./src/components/base/button-command.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonCommand is a mixin that executes a command via CKEDITOR's API.
 *
 * @class ButtonCommand
 */
exports.default = function (WrappedComponent) {
	var _class, _temp2;

	return _temp2 = _class = function (_WrappedComponent) {
		_inherits(ButtonCommand, _WrappedComponent);

		function ButtonCommand() {
			var _ref;

			var _temp, _this, _ret;

			_classCallCheck(this, ButtonCommand);

			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonCommand.__proto__ || Object.getPrototypeOf(ButtonCommand)).call.apply(_ref, [this].concat(args))), _this), _this.execCommand = function (data) {
				var editor = _this.context.editor.get('nativeEditor');

				editor.execCommand(_this.props.command, data);

				if (_this.props.modifiesSelection) {
					editor.selectionChange(true);
				}

				editor.fire('actionPerformed', _this);
			}, _temp), _possibleConstructorReturn(_this, _ret);
		}

		/**
   * Executes a CKEditor command and fires `actionPerformed` event.
   *
   * @instance
   * @memberof ButtonCommand
   * @param {Object=} data Optional data to be passed to CKEDITOR's `execCommand` method.
   * @method execCommand
   */


		return ButtonCommand;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp2;
};

/***/ }),

/***/ "./src/components/base/button-keystroke.js":
/*!*************************************************!*\
  !*** ./src/components/base/button-keystroke.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonKeystroke is a mixin that provides a `keystroke` prop that allows configuring
 * a function of the instance to be invoked upon the keystroke activation.
 *
 * @class ButtonKeystroke
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(ButtonKeystroke, _WrappedComponent);

		function ButtonKeystroke() {
			_classCallCheck(this, ButtonKeystroke);

			return _possibleConstructorReturn(this, (ButtonKeystroke.__proto__ || Object.getPrototypeOf(ButtonKeystroke)).apply(this, arguments));
		}

		_createClass(ButtonKeystroke, [{
			key: 'componentWillMount',


			/**
    * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
    *
    * @instance
    * @memberof ButtonKeystroke
    * @method componentWillMount
    */
			value: function componentWillMount() {
				if (_lang2.default.isFunction(_get(ButtonKeystroke.prototype.__proto__ || Object.getPrototypeOf(ButtonKeystroke.prototype), 'componentWillMount', this))) {
					_get(ButtonKeystroke.prototype.__proto__ || Object.getPrototypeOf(ButtonKeystroke.prototype), 'componentWillMount', this).call(this);
				}

				var nativeEditor = this.context.editor.get('nativeEditor');
				var keystroke = this.props.keystroke;

				var commandName = keystroke.name || (Math.random() * 1e9 >>> 0).toString();

				var command = nativeEditor.getCommand(commandName);

				if (!command) {
					command = new CKEDITOR.command(nativeEditor, {
						exec: function (editor) {
							var keystrokeFn = keystroke.fn;

							if (_lang2.default.isString(keystrokeFn)) {
								this[keystrokeFn].call(this, editor);
							} else if (_lang2.default.isFunction(keystrokeFn)) {
								keystrokeFn.call(this, editor);
							}
						}.bind(this)
					});

					nativeEditor.addCommand(commandName, command);
				}

				this._defaultKeystrokeCommand = nativeEditor.keystrokeHandler.keystrokes[keystroke.keys];

				nativeEditor.setKeystroke(keystroke.keys, commandName);
			}

			/**
    * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
    *
    * @instance
    * @memberof ButtonKeystroke
    * @method componentWillUnmount
    */

		}, {
			key: 'componentWillUnmount',
			value: function componentWillUnmount() {
				if (_lang2.default.isFunction(_get(ButtonKeystroke.prototype.__proto__ || Object.getPrototypeOf(ButtonKeystroke.prototype), 'componentWillUnmount', this))) {
					_get(ButtonKeystroke.prototype.__proto__ || Object.getPrototypeOf(ButtonKeystroke.prototype), 'componentWillUnmount', this).call(this);
				}

				this.context.editor.get('nativeEditor').setKeystroke(this.props.keystroke.keys, this._defaultKeystrokeCommand);
			}
		}]);

		return ButtonKeystroke;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp;
};

/***/ }),

/***/ "./src/components/base/button-props.js":
/*!*********************************************!*\
  !*** ./src/components/base/button-props.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonCfgProps is a mixin that provides a style prop and some methods to apply the resulting
 * style and checking if it is present in a given path or selection.
 *
 * @class ButtonCfgProps
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(ButtonCfgProps, _WrappedComponent);

		function ButtonCfgProps() {
			_classCallCheck(this, ButtonCfgProps);

			return _possibleConstructorReturn(this, (ButtonCfgProps.__proto__ || Object.getPrototypeOf(ButtonCfgProps)).apply(this, arguments));
		}

		_createClass(ButtonCfgProps, [{
			key: 'mergeButtonCfgProps',


			/**
    * Merges the properties, passed to the current component with user's configuration
    * via `buttonCfg` property.
    *
    * @instance
    * @memberof ButtonCfgProps
    * @method mergeButtonCfgProps
    * @param {Object} props The properties to be merged with the provided configuration for this
    * button. If not passed, the user configuration will be merged with `this.props`
    * @return {Object} The merged properties
    */
			value: function mergeButtonCfgProps() {
				var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;

				var nativeEditor = this.context.editor.get('nativeEditor');
				var buttonCfg = nativeEditor.config.buttonCfg || {};
				return CKEDITOR.tools.merge(props, buttonCfg['linkEdit']);
			}
		}]);

		return ButtonCfgProps;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp;
};

/***/ }),

/***/ "./src/components/base/button-state-classes.js":
/*!*****************************************************!*\
  !*** ./src/components/base/button-state-classes.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonStateClasses is a mixin that decorates the domElement of a component
 * with different CSS classes based on the current state of the element.
 *
 * To check for state, the component can expose the following methods:
 * - `Function` **isActive** to check the active state
 * - `Function` **isDisabled** to check the disabled state
 *
 * @class ButtonStateClasses
 */
exports.default = function (WrappedComponent) {
	return function (_WrappedComponent) {
		_inherits(ButtonStateClasses, _WrappedComponent);

		function ButtonStateClasses() {
			_classCallCheck(this, ButtonStateClasses);

			return _possibleConstructorReturn(this, (ButtonStateClasses.__proto__ || Object.getPrototypeOf(ButtonStateClasses)).apply(this, arguments));
		}

		_createClass(ButtonStateClasses, [{
			key: 'getStateClasses',

			/**
    * Returns the list of state classes associated to the current element's state, according
    * to the results of the isActive and isDisabled methods.
    *
    * @instance
    * @memberof ButtonStateClasses
    * @method getStateClasses
    * @return {String} A string with the state CSS classes.
    */
			value: function getStateClasses() {
				var stateClasses = '';

				// Check for active state
				if (_lang2.default.isFunction(this.isActive) && this.isActive()) {
					stateClasses += 'ae-button-pressed';
				}

				// Check for disabled state
				if (_lang2.default.isFunction(this.isDisabled) && this.isDisabled()) {
					stateClasses += ' ae-button-disabled';
				}

				return stateClasses;
			}
		}]);

		return ButtonStateClasses;
	}(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/button-style.js":
/*!*********************************************!*\
  !*** ./src/components/base/button-style.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ButtonStyle is a mixin that provides a style prop and some methods to apply the resulting
 * style and checking if it is present in a given path or selection.
 *
 * @class ButtonStyle
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(ButtonStyle, _WrappedComponent);

		function ButtonStyle() {
			_classCallCheck(this, ButtonStyle);

			return _possibleConstructorReturn(this, (ButtonStyle.__proto__ || Object.getPrototypeOf(ButtonStyle)).apply(this, arguments));
		}

		_createClass(ButtonStyle, [{
			key: 'componentWillMount',


			/**
    * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
    *
    * @instance
    * @memberof ButtonStyle
    * @method componentWillMount
    */
			value: function componentWillMount() {
				if (_lang2.default.isFunction(_get(ButtonStyle.prototype.__proto__ || Object.getPrototypeOf(ButtonStyle.prototype), 'componentWillMount', this))) {
					_get(ButtonStyle.prototype.__proto__ || Object.getPrototypeOf(ButtonStyle.prototype), 'componentWillMount', this).call(this);
				}

				var style = this.props.style;

				if (_lang2.default.isString(style)) {
					var parts = style.split('.');
					var currentMember = this.context.editor.get('nativeEditor').config;
					var property = parts.shift();

					while (property && _lang2.default.isObject(currentMember) && _lang2.default.isObject(currentMember[property])) {
						currentMember = currentMember[property];
						property = parts.shift();
					}

					if (_lang2.default.isObject(currentMember)) {
						style = currentMember;
					}
				}

				this._style = new CKEDITOR.style(style);
			}

			/**
    * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
    *
    * @instance
    * @memberof ButtonStyle
    * @method componentWillUnmount
    */

		}, {
			key: 'componentWillUnmount',
			value: function componentWillUnmount() {
				if (_lang2.default.isFunction(_get(ButtonStyle.prototype.__proto__ || Object.getPrototypeOf(ButtonStyle.prototype), 'componentWillUnmount', this))) {
					_get(ButtonStyle.prototype.__proto__ || Object.getPrototypeOf(ButtonStyle.prototype), 'componentWillUnmount', this).call(this);
				}

				this._style = null;
			}

			/**
    * Returns instance of CKEDITOR.style which represents the current button style.
    *
    * @instance
    * @memberof ButtonStyle
    * @method getStyle
    * @return {CKEDITOR.style} The current style representation.
    */

		}, {
			key: 'getStyle',
			value: function getStyle() {
				return this._style;
			}

			/**
    * Checks if style is active in the current selection.
    *
    * @instance
    * @memberof ButtonStyle
    * @method isActive
    * @return {Boolean} True if style is active, false otherwise.
    */

		}, {
			key: 'isActive',
			value: function isActive() {
				var editor = this.context.editor.get('nativeEditor');
				var elementPath = editor.elementPath();
				return this.getStyle().checkActive(elementPath, editor);
			}
		}]);

		return ButtonStyle;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp;
};

/***/ }),

/***/ "./src/components/base/toolbar-buttons.js":
/*!************************************************!*\
  !*** ./src/components/base/toolbar-buttons.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * ToolbarButtons provides a list of buttons which have to be displayed
 * on the current toolbar depending on user preferences and given state.
 *
 * @class ToolbarButtons
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(ToolbarButtons, _WrappedComponent);

		function ToolbarButtons() {
			_classCallCheck(this, ToolbarButtons);

			return _possibleConstructorReturn(this, (ToolbarButtons.__proto__ || Object.getPrototypeOf(ToolbarButtons)).apply(this, arguments));
		}

		_createClass(ToolbarButtons, [{
			key: 'getToolbarButtonGroups',


			/**
    * Analyses the current selection and returns the buttons or button groups to be rendered.
    *
    * @instance
    * @method getToolbarButtonGroups
    * @param {Array} buttons The buttons could be shown, prior to the state filtering.
    * @param {Object} additionalProps Additional props that should be passed down to the buttons.
    * @return {Array} An Array which contains the buttons or button groups that should be rendered.
    */
			value: function getToolbarButtonGroups(buttons, additionalProps) {
				var _this2 = this;

				if (_lang2.default.isFunction(buttons)) {
					buttons = buttons.call(this) || [];
				}

				return buttons.reduce(function (list, button) {
					if (Array.isArray(button)) {
						list.push(_this2.getToolbarButtons(button, additionalProps));
						return list;
					} else {
						return _this2.getToolbarButtons(buttons, additionalProps);
					}
				}, []);
			}

			/**
    * Analyzes the current selection and the buttons exclusive mode value to figure out which
    * buttons should be present in a given state.
    *
    * @instance
    * @memberof ToolbarButtons
    * @method getToolbarButtons
    * @param {Array} buttons The buttons could be shown, prior to the state filtering.
    * @param {Object} additionalProps Additional props that should be passed down to the buttons.
    * @return {Array} An Array which contains the buttons that should be rendered.
    */

		}, {
			key: 'getToolbarButtons',
			value: function getToolbarButtons(buttons, additionalProps) {
				var buttonProps = {};

				var nativeEditor = this.context.editor.get('nativeEditor');
				var buttonCfg = nativeEditor.config.buttonCfg || {};

				if (_lang2.default.isFunction(buttons)) {
					buttons = buttons.call(this) || [];
				}

				var toolbarButtons = this.filterExclusive(buttons.filter(function (button) {
					return button && (AlloyEditor.Buttons[button] || AlloyEditor.Buttons[button.name]);
				}).map(function (button) {
					if (_lang2.default.isString(button)) {
						buttonProps[button] = buttonCfg[button];
						button = AlloyEditor.Buttons[button];
					} else if (_lang2.default.isString(button.name)) {
						buttonProps[AlloyEditor.Buttons[button.name].key] = CKEDITOR.tools.merge(buttonCfg[button], button.cfg);
						button = AlloyEditor.Buttons[button.name];
					}

					return button;
				})).map(function (button, index) {
					var props = this.mergeExclusiveProps({
						editor: this.context.editor,
						key: button.key !== 'separator' ? button.key : button.key + '-' + index,
						tabKey: button.key,
						tabIndex: this.props.trigger && this.props.trigger.props.tabKey === button.key ? 0 : -1,
						trigger: this.props.trigger
					}, button.key);

					props = this.mergeDropdownProps(props, button.key);

					if (additionalProps) {
						props = CKEDITOR.tools.merge(props, additionalProps);
					}

					props = CKEDITOR.tools.merge(props, buttonProps[button.key]);

					return _react2.default.createElement(button, props);
				}, this);

				return toolbarButtons;
			}
		}]);

		return ToolbarButtons;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _temp;
};

/***/ }),

/***/ "./src/components/base/widget-arrow-box.js":
/*!*************************************************!*\
  !*** ./src/components/base/widget-arrow-box.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides functionality for displaying Widget Arrow box on top or on bottom of the widget
 * depending on the point of user interaction with the editor.
 *
 * @class WidgetArrowBox
 */
exports.default = function (WrappedComponent) {
	return function (_WrappedComponent) {
		_inherits(WidgetArrowBox, _WrappedComponent);

		function WidgetArrowBox() {
			_classCallCheck(this, WidgetArrowBox);

			return _possibleConstructorReturn(this, (WidgetArrowBox.__proto__ || Object.getPrototypeOf(WidgetArrowBox)).apply(this, arguments));
		}

		_createClass(WidgetArrowBox, [{
			key: 'getArrowBoxClasses',

			/**
    * Returns the list of arrow box classes associated to the current element's state. It relies
    * on the getInteractionPoint method to calculate the selection direction.
    *
    * @instance
    * @memberof WidgetArrowBox
    * @method getArrowBoxClasses
    * @return {String} A string with the arrow box CSS classes.
    */
			value: function getArrowBoxClasses() {
				var arrowBoxClasses = 'ae-arrow-box';

				if (_lang2.default.isFunction(this.getInteractionPoint) && this.getInteractionPoint()) {
					if (this.getInteractionPoint().direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
						arrowBoxClasses += ' ae-arrow-box-top';
					} else {
						arrowBoxClasses += ' ae-arrow-box-bottom';
					}
				}

				return arrowBoxClasses;
			}
		}]);

		return WidgetArrowBox;
	}(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-dropdown.js":
/*!************************************************!*\
  !*** ./src/components/base/widget-dropdown.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides functionality for managing different dropdowns inside a widget.
 *
 * @class WidgetDropdown
 */
exports.default = function (WrappedComponent) {
	return function (_WrappedComponent) {
		_inherits(WidgetDropdown, _WrappedComponent);

		function WidgetDropdown(props) {
			_classCallCheck(this, WidgetDropdown);

			var _this = _possibleConstructorReturn(this, (WidgetDropdown.__proto__ || Object.getPrototypeOf(WidgetDropdown)).call(this, props));

			_this.mergeDropdownProps = function (obj, itemKey) {
				return CKEDITOR.tools.merge(obj, {
					expanded: _this.state.itemDropdown === itemKey ? true : false,
					tabIndex: _this.state.dropdownTrigger === itemKey ? 0 : -1,
					toggleDropdown: _this.toggleDropdown.bind(_this, itemKey)
				});
			};

			_this.toggleDropdown = function (itemDropdown, toggleDirection) {
				_this.setState({
					dropdownTrigger: itemDropdown,
					itemDropdown: itemDropdown !== _this.state.itemDropdown ? itemDropdown : null
				}, function () {
					if (!_this.state.itemDropdown) {
						if (_this.moveFocus) {
							_this.moveFocus(toggleDirection);
						} else {
							_reactDom2.default.findDOMNode(_this).focus();
						}
					}
				});
			};

			_this.state = _extends({}, _this.state, {
				dropdownTrigger: null,
				itemDropdown: null
			});
			return _this;
		}

		/**
   * Lifecycle. Invoked when a component is receiving new props.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof WidgetDropdown
   * @method componentWillReceiveProps
   */


		_createClass(WidgetDropdown, [{
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps) {
				if (_lang2.default.isFunction(_get(WidgetDropdown.prototype.__proto__ || Object.getPrototypeOf(WidgetDropdown.prototype), 'componentWillReceiveProps', this))) {
					_get(WidgetDropdown.prototype.__proto__ || Object.getPrototypeOf(WidgetDropdown.prototype), 'componentWillReceiveProps', this).call(this, nextProps);
				}

				this.setState({
					dropdownTrigger: null,
					itemDropdown: null
				});
			}

			/**
    * Merges the provided object with two more properties:
    * - expanded - boolean flag which indicates if an widget should be rendered exclusively.
    * - toggleDropdown - function, which can be used by an widget in order to obtain exclusive state.
    *
    * @instance
    * @memberof WidgetDropdown
    * @method mergeDropdownProps
    * @param {Object} obj The properties container which should be merged with the properties, related
    *    to dropdown state.
    * @param {Object} itemKey They key of an React Widget which contains the dropdown.
    * @return {Object} The merged object.
    */


			/**
    * Sets the active dropdown of the widget or discards the toggled item from the state.
    *
    * @instance
    * @memberof WidgetDropdown
    * @method toggleDropdown
    * @param {Object} itemDropdown The widget which requests to toggle its dropdown.
    * @param {Number} toggleDirection User movement direction when toggled via keyboard.
    */

		}]);

		return WidgetDropdown;
	}(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-exclusive.js":
/*!*************************************************!*\
  !*** ./src/components/base/widget-exclusive.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides functionality for managing exclusive state of an widget.
 * The exclusive state means that a button may request to be the only rendered
 * widget in its parent container. WidgetExclusive will manage this state by
 * filtering and suppressing the other sibling widgets from displaying.
 *
 * @class WidgetExclusive
 */
exports.default = function (WrappedComponent) {
	return function (_WrappedComponent) {
		_inherits(WidgetExclusive, _WrappedComponent);

		function WidgetExclusive() {
			var _ref;

			var _temp, _this, _ret;

			_classCallCheck(this, WidgetExclusive);

			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = WidgetExclusive.__proto__ || Object.getPrototypeOf(WidgetExclusive)).call.apply(_ref, [this].concat(args))), _this), _this.requestExclusive = function (itemExclusive) {
				_this.setState({
					itemExclusive: itemExclusive
				});
			}, _temp), _possibleConstructorReturn(_this, _ret);
		}

		_createClass(WidgetExclusive, [{
			key: 'cancelExclusive',

			/**
    * Cancels the exclusive state of an widget.
    *
    * @instance
    * @memberof WidgetExclusive
    * @method cancelExclusive
    * @param {Object} itemExclusive The widget which exclusive state should be canceled.
    */
			value: function cancelExclusive(itemExclusive) {
				if (this.state.itemExclusive === itemExclusive) {
					this.setState({
						itemExclusive: null
					});
				}
			}

			/**
    * Lifecycle. Invoked when a component is receiving new props.
    * This method is not called for the initial render.
    * Calling this.setState() within this function will not trigger an additional render.
    *
    * @instance
    * @memberof WidgetExclusive
    * @method componentWillReceiveProps
    * @param {Object} nextProps Object containing the current set of properties.
    */

		}, {
			key: 'componentWillReceiveProps',
			value: function componentWillReceiveProps(nextProps) {
				if (_lang2.default.isFunction(_get(WidgetExclusive.prototype.__proto__ || Object.getPrototypeOf(WidgetExclusive.prototype), 'componentWillReceiveProps', this))) {
					_get(WidgetExclusive.prototype.__proto__ || Object.getPrototypeOf(WidgetExclusive.prototype), 'componentWillReceiveProps', this).call(this, nextProps);
				}

				// Receiving properties means that the component is being re-rendered.
				// Re-rendering is triggered by editorInteraction, so we have to
				// reset the exclusive state and render the UI according to the new selection.
				this.setState({
					itemExclusive: null
				});
			}

			/**
    * Filters the items and returns only those with exclusive state.
    *
    * @instance
    * @memberof WidgetExclusive
    * @method filterExclusive
    * @param {Array} items The widgets to be filtered.
    * @return {Array|Object} The item with executive state.
    */

		}, {
			key: 'filterExclusive',
			value: function filterExclusive(items) {
				return items.filter(function (item) {
					if (this.state.itemExclusive) {
						if (this.state.itemExclusive === item.key) {
							return item;
						}
					} else {
						return item;
					}
				}.bind(this));
			}

			/**
    * Merges the provided object with three more properties:
    * - cancelExclusive - function, which can be used by a widget in order to cancel executive state.
    * - renderExclusive - boolean flag which indicates if an widget should be rendered exclusively.
    * - requestExclusive - function, which can be used by a widget in order to obtain exclusive state.
    *
    * @instance
    * @memberof WidgetExclusive
    * @method mergeExclusiveProps
    * @param {Object} obj The properties container which should be merged with the properties, related
    *    to exclusive state.
    * @param {Object} itemKey They key of an React Widget which should be rendered exclusively.
    * @return {Object} The merged object.
    */

		}, {
			key: 'mergeExclusiveProps',
			value: function mergeExclusiveProps(obj, itemKey) {
				return CKEDITOR.tools.merge(obj, {
					cancelExclusive: this.cancelExclusive.bind(this, itemKey),
					renderExclusive: this.state.itemExclusive === itemKey,
					requestExclusive: this.requestExclusive.bind(this, itemKey)
				});
			}

			/**
    * Requests and sets exclusive state of an widget.
    *
    * @instance
    * @memberof WidgetExclusive
    * @method requestExclusive
    * @param {Object} itemExclusive The widget which requests exclusive state.
    */

		}]);

		return WidgetExclusive;
	}(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-focus-manager.js":
/*!*****************************************************!*\
  !*** ./src/components/base/widget-focus-manager.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DIRECTION_NONE = 0;
var DIRECTION_NEXT = 1;
var DIRECTION_PREV = -1;

var ACTION_NONE = 0;
var ACTION_MOVE_FOCUS = 1;
var ACTION_DISMISS_FOCUS = 2;

/**
 * WidgetFocusManager is a mixin that provides keyboard navigation inside a widget. To do this,
 * it exposes the following props and methods:
 *
 * @class WidgetFocusManager
 */

exports.default = function (WrappedComponent) {
	return function (_WrappedComponent) {
		_inherits(WidgetFocusManager, _WrappedComponent);

		function WidgetFocusManager() {
			var _ref;

			var _temp, _this, _ret;

			_classCallCheck(this, WidgetFocusManager);

			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = WidgetFocusManager.__proto__ || Object.getPrototypeOf(WidgetFocusManager)).call.apply(_ref, [this].concat(args))), _this), _this.focus = function (event) {
				if (!event || _this._isValidTarget(event.target)) {
					if (_this._descendants && _this._descendants.length) {
						var activeDescendantEl = _this._descendants[_this._activeDescendant];
						// When user clicks with the mouse, the activeElement is already set and there
						// is no need to focus it. Focusing of the active descendant (usually some button) is required
						// in case of keyboard navigation, because the focused element might be not the first button,
						// but the div element, which contains the button.
						if (document.activeElement !== activeDescendantEl && !_this.props.focusFirstChild) {
							if (_this._descendants.indexOf(document.activeElement) === -1) {
								activeDescendantEl.focus();
							}
						}

						if (event) {
							event.stopPropagation();
							event.preventDefault();
						}
					}
				}
			}, _this.handleKey = function (event) {
				if (_this._isValidTarget(event.target) && _this._descendants) {
					var action = _this._getFocusAction(event);

					if (action.type) {
						event.stopPropagation();
						event.preventDefault();

						if (action.type === ACTION_MOVE_FOCUS) {
							_this._moveFocus(action.direction);
						}

						if (action.type === ACTION_DISMISS_FOCUS) {
							_this.props.onDismiss(action.direction);
						}
					}
				}
			}, _temp), _possibleConstructorReturn(_this, _ret);
		}

		_createClass(WidgetFocusManager, [{
			key: 'componentDidMount',

			/**
    * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method componentDidMount
    */
			value: function componentDidMount() {
				if (_lang2.default.isFunction(_get(WidgetFocusManager.prototype.__proto__ || Object.getPrototypeOf(WidgetFocusManager.prototype), 'componentDidMount', this))) {
					_get(WidgetFocusManager.prototype.__proto__ || Object.getPrototypeOf(WidgetFocusManager.prototype), 'componentDidMount', this).call(this);
				}

				this._refresh();
			}

			/**
    * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
    * Refreshes the descendants list.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method componentDidUpdate
    */

		}, {
			key: 'componentDidUpdate',
			value: function componentDidUpdate() {
				if (_lang2.default.isFunction(_get(WidgetFocusManager.prototype.__proto__ || Object.getPrototypeOf(WidgetFocusManager.prototype), 'componentDidUpdate', this))) {
					_get(WidgetFocusManager.prototype.__proto__ || Object.getPrototypeOf(WidgetFocusManager.prototype), 'componentDidUpdate', this).call(this);
				}

				this._refresh();
			}

			/**
    * Focuses the current active descendant.
    *
    * Several Widgets can be nested in a component hierarchy by attaching this focus method to
    * the widget DOM node, transferring the DOM focus control to the inner FocusManager.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method focus
    */


			/**
    * Handles the key events on a DOM node to execute the appropriate navigation when needed.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @param {Object} event The Keyboard event that was detected on the widget DOM node.
    * @method handleKey
    */

		}, {
			key: 'moveFocus',


			/**
    * Moves the focus among descendants in the especified direction.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method moveFocus
    * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
    */
			value: function moveFocus(direction) {
				direction = _lang2.default.isNumber(direction) ? direction : 0;

				this._moveFocus(direction);
			}

			/**
    * Returns the action, if any, that a keyboard event in the current focus manager state
    * should produce.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _getFocusAction
    * @param {object} event The Keyboard event.
    * @protected
    * @return {Object} An action object with type and direction properties.
    */

		}, {
			key: '_getFocusAction',
			value: function _getFocusAction(event) {
				var action = {
					type: ACTION_NONE
				};

				if (this.props.keys) {
					var direction = this._getFocusMoveDirection(event);

					if (direction) {
						action.direction = direction;
						action.type = ACTION_MOVE_FOCUS;
					}

					var dismissAction = this._getFocusDismissAction(event, direction);

					if (dismissAction.dismiss) {
						action.direction = dismissAction.direction;
						action.type = ACTION_DISMISS_FOCUS;
					}
				}

				return action;
			}

			/**
    * Returns the dismiss action, if any, the focus manager should execute to yield the focus. This
    * will happen in any of these scenarios if a dismiss callback has been specified:
    * - A dismiss key has been pressed
    * - In a non-circular focus manager, when:
    *     - The active descendant is the first one and a prev key has been pressed.
    *     - The active descendant is the last one and a next key has been pressed.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _getFocusDismissAction
    * @param {Number} focusMoveDirection The focus movement direction (if any).
    * @param {Object} event The Keyboard event.
    * @protected
    * @return {Object} A dismiss action with dismiss and direction properties.
    */

		}, {
			key: '_getFocusDismissAction',
			value: function _getFocusDismissAction(event, focusMoveDirection) {
				var dismissAction = {
					direction: focusMoveDirection,
					dismiss: false
				};

				if (this.props.onDismiss) {
					if (this._isValidKey(event.keyCode, this.props.keys.dismiss)) {
						dismissAction.dismiss = true;
					}
					if (this._isValidKey(event.keyCode, this.props.keys.dismissNext)) {
						dismissAction.dismiss = true;
						dismissAction.direction = DIRECTION_NEXT;
					}
					if (this._isValidKey(event.keyCode, this.props.keys.dismissPrev)) {
						dismissAction.dismiss = true;
						dismissAction.direction = DIRECTION_PREV;
					}

					if (!dismissAction.dismiss && !this.props.circular && focusMoveDirection) {
						dismissAction.dismiss = focusMoveDirection === DIRECTION_PREV && this._activeDescendant === 0 || focusMoveDirection === DIRECTION_NEXT && this._activeDescendant === this._descendants.length - 1;
					}
				}

				return dismissAction;
			}

			/**
    * Returns the direction, if any, in which the focus should be moved. In presence of the
    * shift key modifier, the direction of the movement is inverted.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _getFocusMoveDirection
    * @param {Object} event The Keyboard event.
    * @protected
    * @return {Number} The computed direction of the expected focus movement.
    */

		}, {
			key: '_getFocusMoveDirection',
			value: function _getFocusMoveDirection(event) {
				var direction = DIRECTION_NONE;

				if (this._isValidKey(event.keyCode, this.props.keys.next)) {
					direction = DIRECTION_NEXT;
				}
				if (this._isValidKey(event.keyCode, this.props.keys.prev)) {
					direction = DIRECTION_PREV;
				}

				if (event.shifKey) {
					direction *= -1;
				}

				return direction;
			}

			/**
    * Indicates if a given keyCode is valid for the given set of keys.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _isValidKey
    * @param {Array|Number} keys A key set. Can be a number an array of numbers representing the allowed keyCodes.
    * @param {Number} keyCode An event keyCode.
    * @protected
    * @return {Boolean} A boolean value indicating if the key is valid.
    */

		}, {
			key: '_isValidKey',
			value: function _isValidKey(keyCode, keys) {
				return _lang2.default.isArray(keys) ? keys.indexOf(keyCode) !== -1 : keyCode === keys;
			}

			/**
    * Indicates if a given element is valid for focus management. User input elements such as
    * input, select or textarea are excluded.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _isValidKey
    * @param {DOMNode} element A DOM element.
    * @protected
    * @return {Boolean} A boolean value indicating if the element is valid.
    */

		}, {
			key: '_isValidTarget',
			value: function _isValidTarget(element) {
				var tagName = element.tagName.toLowerCase();

				return tagName !== 'input' && tagName !== 'select' && tagName !== 'textarea';
			}

			/**
    * Moves the focus among descendants in the especified direction.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _moveFocus
    * @param {number} direction The direction (1 or -1) of the focus movement among descendants.
    * @protected
    */

		}, {
			key: '_moveFocus',
			value: function _moveFocus(direction) {
				var numDescendants = this._descendants.length;

				var descendant = this._descendants[this._activeDescendant];

				descendant.setAttribute('tabIndex', -1);

				this._activeDescendant += direction;

				if (this.props.circular) {
					// Calculate proper modulo result since remainder operator doesn't behave in the
					// same way for negative numbers
					this._activeDescendant = (this._activeDescendant % numDescendants + numDescendants) % numDescendants;
				} else {
					this._activeDescendant = Math.max(Math.min(this._activeDescendant, numDescendants - 1), 0);
				}

				descendant = this._descendants[this._activeDescendant];

				descendant.setAttribute('tabIndex', 0);
				descendant.focus();
			}

			/**
    * Refreshes the descendants list by executing the CSS selector again and resets the descendants tabIndex.
    *
    * @instance
    * @memberof WidgetFocusManager
    * @method _refresh
    * @protected
    */

		}, {
			key: '_refresh',
			value: function _refresh() {
				var domNode = _reactDom2.default.findDOMNode(this);

				if (domNode) {
					var descendants = domNode.querySelectorAll(this.props.descendants);

					var priorityDescendants = [];

					this._descendants = [];

					Array.prototype.slice.call(descendants).forEach(function (item) {
						var dataTabIndex = item.getAttribute('data-tabindex');

						if (dataTabIndex) {
							priorityDescendants.push(item);
						} else {
							this._descendants.push(item);
						}
					}.bind(this));

					priorityDescendants = priorityDescendants.sort(function (a, b) {
						return _lang2.default.toInt(a.getAttribute('data-tabindex')) > _lang2.default.toInt(b.getAttribute('data-tabindex'));
					});

					this._descendants = priorityDescendants.concat(this._descendants);

					this._activeDescendant = 0;

					this._descendants.some(function (item, index) {
						if (item.getAttribute('tabindex') === '0') {
							this._activeDescendant = index;
							this.focus();

							return true;
						}
					}.bind(this));
				}
			}
		}]);

		return WidgetFocusManager;
	}(WrappedComponent);
};

/***/ }),

/***/ "./src/components/base/widget-position.js":
/*!************************************************!*\
  !*** ./src/components/base/widget-position.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Calculates the position where an Widget should be displayed based on the point
 * where user interacted with the editor.
 *
 * @class WidgetPosition
 */
exports.default = function (WrappedComponent) {
	var _class, _temp;

	return _temp = _class = function (_WrappedComponent) {
		_inherits(WidgetPosition, _WrappedComponent);

		function WidgetPosition() {
			_classCallCheck(this, WidgetPosition);

			return _possibleConstructorReturn(this, (WidgetPosition.__proto__ || Object.getPrototypeOf(WidgetPosition)).apply(this, arguments));
		}

		_createClass(WidgetPosition, [{
			key: 'cancelAnimation',


			/**
    * Cancels an scheduled animation frame.
    *
    * @instance
    * @memberof WidgetPosition
    * @method cancelAnimation
    */
			value: function cancelAnimation() {
				if (this._animationFrameId) {
					window.cancelAnimationFrame(this._animationFrameId);
				}
			}

			/**
    * Returns an object which contains the position of the element in page coordinates,
    * restricted to fit to given viewport.
    *
    * @instance
    * @memberof WidgetPosition
    * @method getConstrainedPosition
    * @param {Object} attrs The following properties, provided as numbers:
    * - height
    * - left
    * - top
    * - width
    * @param {Object} viewPaneSize Optional. If not provided, the current viewport will be used. Should contain at least these properties:
    * - width
    * @return {Object} An object with `x` and `y` properties, which represent the constrained position of the
    * element.
    */


			/**
    * Lifecycle. Returns the default values of the properties used in the widget.
    *
    * @instance
    * @memberof WidgetPosition
    * @method getDefaultProps
    */

		}, {
			key: 'getConstrainedPosition',
			value: function getConstrainedPosition(attrs, viewPaneSize) {
				viewPaneSize = viewPaneSize || new CKEDITOR.dom.window(window).getViewPaneSize();

				var x = attrs.left;
				var y = attrs.top;

				if (attrs.left + attrs.width > viewPaneSize.width) {
					x -= attrs.left + attrs.width - viewPaneSize.width;
				}

				if (y < 0) {
					y = 0;
				}

				return {
					x: x,
					y: y
				};
			}

			/**
    * Returns the position, in page coordinates, according to which a widget should appear.
    * Depending on the direction of the selection, the wdiget may appear above of or on bottom of the selection.
    *
    * It depends on the props editorEvent to analyze the following user-interaction parameters:
    * - {Object} selectionData The data about the selection in the editor as returned from
    * {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
    * - {Number} pos Contains the coordinates of the position, considered as most appropriate.
    * This may be the point where the user released the mouse, or just the beginning or the end of
    * the selection.
    *
    * @instance
    * @memberof WidgetInteractionPoint
    * @method getInteractionPoint
    * @return {Object} An Object which contains the following properties:
    * direction, x, y, where x and y are in page coordinates and direction can be one of these:
    * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
    */

		}, {
			key: 'getInteractionPoint',
			value: function getInteractionPoint() {
				var eventPayload = this.props.editorEvent ? this.props.editorEvent.data : null;

				if (!eventPayload) {
					return;
				}

				var selectionData = eventPayload.selectionData;

				var nativeEvent = eventPayload.nativeEvent;

				var pos = {
					x: eventPayload.nativeEvent.pageX,
					y: selectionData.region.top
				};

				var direction = selectionData.region.direction;

				var endRect = selectionData.region.endRect;

				var startRect = selectionData.region.startRect;

				if (endRect && startRect && startRect.top === endRect.top) {
					direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
				}

				var x = void 0;
				var y = void 0;

				// If we have the point where user released the mouse, show Toolbar at this point
				// otherwise show it on the middle of the selection.

				if (pos.x && pos.y) {
					x = this._getXPoint(selectionData, pos.x);

					if (direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
						y = Math.min(pos.y, selectionData.region.top);
					} else {
						y = Math.max(pos.y, this._getYPoint(selectionData, nativeEvent));
					}
				} else {
					x = selectionData.region.left + selectionData.region.width / 2;

					if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
						y = this._getYPoint(selectionData, nativeEvent);
					} else {
						y = selectionData.region.top;
					}
				}

				return {
					direction: direction,
					x: x,
					y: y
				};
			}

			/**
    * Returns the position of the Widget.
    *
    * @instance
    * @memberof WidgetInteractionPoint
    * @method _getXPoint
    * @param {Object} eventX The X coordinate received from the native event (mouseup).
    * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
    * @protected
    * @return {Number} The calculated X point in page coordinates.
    */

		}, {
			key: '_getXPoint',
			value: function _getXPoint(selectionData, eventX) {
				var region = selectionData.region;

				var left = region.startRect ? region.startRect.left : region.left;
				var right = region.endRect ? region.endRect.right : region.right;

				var x = void 0;

				if (left < eventX && right > eventX) {
					x = eventX;
				} else {
					var leftDist = Math.abs(left - eventX);
					var rightDist = Math.abs(right - eventX);

					if (leftDist < rightDist) {
						// user raised the mouse on left on the selection
						x = left;
					} else {
						x = right;
					}
				}

				return x;
			}

			/**
    * Returns the position of the Widget.
    *
    * @instance
    * @memberof WidgetInteractionPoint
    * @method _getYPoint
    * @param {Object} nativeEvent The data about event is fired
    * @param {Object} selectionData The data about the selection in the editor as returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
    * @protected
    * @return {Number} The calculated Y point in page coordinates.
    */

		}, {
			key: '_getYPoint',
			value: function _getYPoint(selectionData, nativeEvent) {
				var y = 0;

				if (selectionData && nativeEvent) {
					var elementTarget = new CKEDITOR.dom.element(nativeEvent.target);

					if (elementTarget.$ && elementTarget.getStyle('overflow') === 'auto') {
						y = nativeEvent.target.offsetTop + nativeEvent.target.offsetHeight;
					} else {
						y = selectionData.region.bottom;
					}
				}

				return y;
			}

			/**
    * Returns the position of the Widget taking in consideration the
    * {{#crossLink "WidgetPosition/gutter:attribute"}}{{/crossLink}} attribute.
    *
    * @instance
    * @memberof WidgetPosition
    * @protected
    * @method  getWidgetXYPoint
    * @param {Number} left The left offset in page coordinates where Toolbar should be shown.
    * @param {Number} top The top offset in page coordinates where Toolbar should be shown.
    * @param {Number} direction The direction of the selection. May be one of the following:
    * CKEDITOR.SELECTION_BOTTOM_TO_TOP or CKEDITOR.SELECTION_TOP_TO_BOTTOM
    * @return {Array} An Array with left and top offsets in page coordinates.
    */

		}, {
			key: 'getWidgetXYPoint',
			value: function getWidgetXYPoint(left, top, direction) {
				var domNode = _reactDom2.default.findDOMNode(this);

				var gutter = this.props.gutter;

				if (direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM || direction === CKEDITOR.SELECTION_BOTTOM_TO_TOP) {
					left = left - gutter.left - domNode.offsetWidth / 2;

					top = direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM ? top + gutter.top : top - domNode.offsetHeight - gutter.top;
				} else if (direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT || direction === CKEDITOR.SELECTION_RIGHT_TO_LEFT) {
					left = direction === CKEDITOR.SELECTION_LEFT_TO_RIGHT ? left + gutter.left + domNode.offsetHeight / 2 : left - 3 * domNode.offsetHeight / 2 - gutter.left;

					top = top - gutter.top - domNode.offsetHeight / 2;
				}

				if (left < 0) {
					left = 0;
				}

				if (top < 0) {
					top = 0;
				}

				return [left, top];
			}

			/**
    * Returns true if the widget is visible, false otherwise
    *
    * @instance
    * @memberof WidgetPosition
    * @method isVisible
    * @return {Boolean} True if the widget is visible, false otherwise
    */

		}, {
			key: 'isVisible',
			value: function isVisible() {
				var domNode = _reactDom2.default.findDOMNode(this);

				if (domNode) {
					var domElement = new CKEDITOR.dom.element(domNode);

					return domElement.hasClass('alloy-editor-visible');
				}

				return false;
			}

			/**
    * Moves a widget from a starting point to a destination point.
    *
    * @instance
    * @memberof WidgetPosition
    * @method moveToPoint
    * @param  {Object} startPoint The starting point for the movement.
    * @param  {Object} endPoint The destination point for the movement.
    */

		}, {
			key: 'moveToPoint',
			value: function moveToPoint(startPoint, endPoint) {
				var domElement = new CKEDITOR.dom.element(_reactDom2.default.findDOMNode(this));

				domElement.setStyles({
					left: startPoint[0] + 'px',
					top: startPoint[1] + 'px',
					opacity: 0,
					pointerEvents: 'none'
				});

				domElement.removeClass('alloy-editor-invisible');

				this._animationFrameId = window.requestAnimationFrame(function () {
					domElement.addClass('ae-toolbar-transition');
					domElement.addClass('alloy-editor-visible');
					domElement.setStyles({
						left: endPoint[0] + 'px',
						top: endPoint[1] + 'px',
						opacity: 1
					});

					// 150ms to match transition-duration for .ae-toolbar-transition:
					setTimeout(function () {
						domElement.setStyles({
							pointerEvents: ''
						});
					}, 150);
				});
			}

			/**
    * Shows the widget with the default animation transition.
    *
    * @instance
    * @memberof WidgetPosition
    * @method show
    */

		}, {
			key: 'show',
			value: function show() {
				var domNode = _reactDom2.default.findDOMNode(this);
				var uiNode = this.context.editor.get('uiNode');

				var scrollTop = uiNode ? uiNode.scrollTop : 0;

				if (!this.isVisible() && domNode) {
					var interactionPoint = this.getInteractionPoint();

					if (interactionPoint) {
						var domElement = new CKEDITOR.dom.element(domNode);

						var finalX = void 0;
						var finalY = void 0;
						var initialX = void 0;
						var initialY = void 0;

						finalX = initialX = parseFloat(domElement.getStyle('left'));
						finalY = initialY = parseFloat(domElement.getStyle('top'));

						if (this.props.constrainToViewport) {
							var res = this.getConstrainedPosition({
								height: parseFloat(domNode.offsetHeight),
								left: finalX,
								top: finalY,
								width: parseFloat(domNode.offsetWidth)
							});

							finalX = res.x;
							finalY = res.y;
						}

						if (interactionPoint.direction === CKEDITOR.SELECTION_TOP_TO_BOTTOM) {
							initialY = this.props.selectionData.region.bottom + scrollTop;
						} else {
							initialY = this.props.selectionData.region.top + scrollTop;
						}

						this.moveToPoint([initialX, initialY], [finalX, finalY]);
					}
				}
			}

			/**
    * Updates the widget position based on the current interaction point.
    *
    * @instance
    * @memberof WidgetPosition
    * @method updatePosition
    */

		}, {
			key: 'updatePosition',
			value: function updatePosition() {
				var interactionPoint = this.getInteractionPoint();

				var domNode = _reactDom2.default.findDOMNode(this);

				if (interactionPoint && domNode) {
					var uiNode = this.context.editor.get('uiNode') || document.body;
					var uiNodeStyle = getComputedStyle(uiNode);
					var uiNodeMarginLeft = parseInt(uiNodeStyle.getPropertyValue('margin-left'), 10);
					var uiNodeMarginRight = parseInt(uiNodeStyle.getPropertyValue('margin-right'), 10);
					var totalWidth = uiNodeMarginLeft + uiNode.clientWidth + uiNodeMarginRight;

					var scrollTop = uiNode.tagName !== 'BODY' ? uiNode.scrollTop : 0;

					var xy = this.getWidgetXYPoint(interactionPoint.x, interactionPoint.y, interactionPoint.direction);
					xy[1] += scrollTop;

					if (xy[0] < 0) {
						xy[0] = 0;
					}
					if (xy[0] > totalWidth - domNode.offsetWidth) {
						xy[0] = totalWidth - domNode.offsetWidth;
					}

					new CKEDITOR.dom.element(domNode).setStyles({
						left: xy[0] + 'px',
						top: xy[1] + 'px'
					});
				}
			}
		}]);

		return WidgetPosition;
	}(WrappedComponent), _class.contextType = _editorContext2.default, _class.defaultProps = _extends({}, WrappedComponent.defaultProps, {
		gutter: {
			left: 0,
			top: 10
		},
		constrainToViewport: true
	}), _temp;
};

/***/ }),

/***/ "./src/components/buttons/button-accessibility-image-alt.jsx":
/*!*******************************************************************!*\
  !*** ./src/components/buttons/button-accessibility-image-alt.jsx ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonProps = __webpack_require__(/*! ../base/button-props */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonAccessibilityImageAlt class provides functionality for changing text color in a document.
 *
 * @class ButtonAccessibilityImageAlt
 * @uses ButtonProps
 * @uses ButtonStateClasses
 *
 */
var ButtonAccessibilityImageAlt = function (_React$Component) {
	_inherits(ButtonAccessibilityImageAlt, _React$Component);

	function ButtonAccessibilityImageAlt(props) {
		_classCallCheck(this, ButtonAccessibilityImageAlt);

		var _this = _possibleConstructorReturn(this, (ButtonAccessibilityImageAlt.__proto__ || Object.getPrototypeOf(ButtonAccessibilityImageAlt)).call(this, props));

		_initialiseProps.call(_this);

		var element = props.context.editor.get('nativeEditor').getSelection().getSelectedElement();

		var imageAlt = element && element.getAttribute('alt') || '';

		_this.state = {
			element: element,
			imageAlt: imageAlt
		};
		return _this;
	}

	/**
  * Lifecycle. Renders the UI of the button.
  *
  * @method render
  * @return {Object} The content which should be rendered.
  */


	_createClass(ButtonAccessibilityImageAlt, [{
		key: 'render',
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			if (this.props.renderExclusive) {
				return _react2.default.createElement(
					'div',
					{ className: 'ae-container-edit-link' },
					_react2.default.createElement(
						'div',
						{ className: 'ae-container-input xxl' },
						_react2.default.createElement('input', {
							'aria-label': 'alt',
							className: 'ae-input',
							onChange: this._handleAltChange,
							onKeyDown: this._handleKeyDown,
							placeholder: 'alt',
							ref: 'refAltInput',
							title: 'alt',
							type: 'text',
							value: this.state.imageAlt
						})
					),
					_react2.default.createElement(
						'button',
						{
							'aria-label': AlloyEditor.Strings.confirm,
							className: 'ae-button',
							onClick: this._updateImageAlt,
							title: AlloyEditor.Strings.confirm },
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'check' })
					)
				);
			} else {
				return _react2.default.createElement(
					'button',
					{
						className: cssClass,
						onClick: this._requestExclusive,
						tabIndex: this.props.tabIndex },
					_react2.default.createElement(
						'small',
						{ className: 'ae-icon small' },
						'Alt'
					)
				);
			}
		}

		/**
   * Focuses the user cursor on the widget's input.
   *
   * @protected
   * @method _focusAltInput
   */

	}, {
		key: '_focusAltInput',
		value: function _focusAltInput() {
			var instance = this;

			var focusAltEl = function focusAltEl() {
				_reactDom2.default.findDOMNode(instance.refs.refAltInput).focus();
			};

			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(focusAltEl);
			} else {
				setTimeout(focusAltEl, 0);
			}
		}

		/**
   * Event attached to alt input that fires when its value is changed
   *
   * @protected
   * @method  _handleAltChange
   * @param {MouseEvent} event
   */


		/**
   * Event attached to al tinput that fires when key is down
   * This method check that enter key is pushed to update the component´s state
   *
   * @protected
   * @method  _handleKeyDown
   * @param {MouseEvent} event
   */


		/**
   * Requests the link button to be rendered in exclusive mode to allow the creation of a link.
   *
   * @protected
   * @method _requestExclusive
   */


		/**
   * Method called by clicking ok button or pushing key enter to update imageAlt state and to update alt property from the image that is selected
   * This method calls cancelExclusive to show the previous toolbar before enter to edit alt property
   *
   * @protected
   * @method  _updateImageAlt
   */

	}]);

	return ButtonAccessibilityImageAlt;
}(_react2.default.Component);

ButtonAccessibilityImageAlt.contextType = _editorContext2.default;
ButtonAccessibilityImageAlt.key = 'imageAlt';

var _initialiseProps = function _initialiseProps() {
	var _this2 = this;

	this._handleAltChange = function (event) {
		_this2.setState({
			imageAlt: event.target.value
		});

		_this2._focusAltInput();
	};

	this._handleKeyDown = function (event) {
		if (event.keyCode === 13) {
			event.preventDefault();

			_this2._updateImageAlt();
		}
	};

	this._requestExclusive = function () {
		_this2.props.requestExclusive(ButtonAccessibilityImageAlt.key);
	};

	this._updateImageAlt = function () {
		var editor = _this2.context.editor.get('nativeEditor');

		var imageAlt = _this2.refs.refAltInput.value;

		_this2.setState({
			imageAlt: imageAlt
		});

		_this2.state.element.setAttribute('alt', imageAlt);

		editor.fire('actionPerformed', _this2);

		// We need to cancelExclusive with the bound parameters in case the button is used
		// inside another in exclusive mode (such is the case of the alt button)
		_this2.props.cancelExclusive();
	};
};

exports.default = _editorContext2.default.toProps((0, _buttonProps2.default)((0, _buttonStateClasses2.default)(ButtonAccessibilityImageAlt)));

/***/ }),

/***/ "./src/components/buttons/button-background-color.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-background-color.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonProps = __webpack_require__(/*! ../base/button-props */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ButtonBackgroundColor = function (_React$Component) {
	_inherits(ButtonBackgroundColor, _React$Component);

	function ButtonBackgroundColor() {
		_classCallCheck(this, ButtonBackgroundColor);

		return _possibleConstructorReturn(this, (ButtonBackgroundColor.__proto__ || Object.getPrototypeOf(ButtonBackgroundColor)).apply(this, arguments));
	}

	_createClass(ButtonBackgroundColor, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var _this2 = this;

			var activeColor = AlloyEditor.Strings.normal;

			var activeColorClass = '';

			var colors = this._getColors();

			var itemStyle = {
				element: 'span',
				attributes: {
					class: ''
				}
			};

			colors.forEach(function (item) {
				itemStyle.attributes.class = item.styleClass;

				if (_this2._checkActive(itemStyle)) {
					activeColor = item.name;

					activeColorClass = item.style.attributes.class;
				}
			});

			var _props = this.props,
			    expanded = _props.expanded,
			    tabIndex = _props.tabIndex,
			    toggleDropdown = _props.toggleDropdown;


			var buttonStylesProps = {
				activeStyle: activeColor,
				onDismiss: toggleDropdown,
				showRemoveStylesItem: false,
				styles: colors
			};

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': expanded,
						className: 'ae-toolbar-element',
						onClick: toggleDropdown,
						role: 'combobox',
						tabIndex: tabIndex },
					_react2.default.createElement(
						'span',
						{ className: activeColorClass },
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'textbox' })
					)
				),
				expanded && _react2.default.createElement(_buttonStylesList2.default, buttonStylesProps)
			);
		}
	}, {
		key: '_applyStyle',
		value: function _applyStyle(className) {
			var _this3 = this;

			var editor = this.context.editor.get('nativeEditor');

			var styleConfig = {
				element: 'span',
				attributes: {
					class: className
				}
			};

			editor.getSelection().lock();

			this._getColors().forEach(function (item) {
				styleConfig.attributes.class = item.styleClass;

				if (_this3._checkActive(styleConfig)) {
					editor.removeStyle(new CKEDITOR.style(styleConfig));
				}
			});

			styleConfig.attributes.class = className;

			var style = new CKEDITOR.style(styleConfig);

			editor.applyStyle(style);

			editor.getSelection().unlock();

			editor.fire('actionPerformed', this);
		}

		/**
   * Checks if the given color definition is applied to the current selection in the editor.
   *
   * @instance
   * @memberof ButtonBackgroundColor
   * @method _checkActive
   * @param {Object} styleConfig color definition as per http://docs.ckeditor.com/#!/api/CKEDITOR.style.
   * @protected
   * @return {Boolean} Returns true if the color is applied to the selection, false otherwise.
   */

	}, {
		key: '_checkActive',
		value: function _checkActive(styleConfig) {
			var nativeEditor = this.context.editor.get('nativeEditor');

			// Styles with wildcard element (*) won't be considered active by CKEditor. Defaulting
			// to a 'span' element works for most of those cases with no defined element.
			styleConfig = CKEDITOR.tools.merge({ element: 'span' }, styleConfig);

			var style = new CKEDITOR.style(styleConfig);

			return style.checkActive(nativeEditor.elementPath(), nativeEditor);
		}

		/**
   * Returns an array of colors. Each color consists of two properties:
   * - name - the style name, for example "default"
   * - style - an object with one property, called `element` which value
   * represents the style which have to be applied to the element.
   *
   * @instance
   * @memberof ButtonBackgroundColor
   * @method _getColor
   * @protected
   * @return {Array<object>} An array of objects containing the colors.
   */

	}, {
		key: '_getColors',
		value: function _getColors() {
			return this.props.styles || [{
				name: AlloyEditor.Strings.normal,
				style: {
					element: 'span',
					attributes: {
						class: 'text-body'
					}
				},
				styleClass: '',
				styleFn: this._applyStyle.bind(this, '')
			}, {
				name: AlloyEditor.Strings.primary,
				style: {
					element: 'span',
					attributes: {
						class: 'text-primary'
					}
				},
				styleClass: 'bg-primary',
				styleFn: this._applyStyle.bind(this, 'bg-primary')
			}, {
				name: AlloyEditor.Strings.disabled,
				style: {
					element: 'span',
					attributes: {
						class: 'text-secondary'
					}
				},
				styleClass: 'bg-secondary',
				styleFn: this._applyStyle.bind(this, 'bg-secondary')
			}, {
				name: AlloyEditor.Strings.success,
				style: {
					element: 'span',
					attributes: {
						class: 'text-success'
					}
				},
				styleClass: 'bg-success',
				styleFn: this._applyStyle.bind(this, 'bg-success')
			}, {
				name: AlloyEditor.Strings.danger,
				style: {
					element: 'span',
					attributes: {
						class: 'text-danger'
					}
				},
				styleClass: 'bg-danger',
				styleFn: this._applyStyle.bind(this, 'bg-danger')
			}, {
				name: AlloyEditor.Strings.warning,
				style: {
					element: 'span',
					attributes: {
						class: 'text-warning'
					}
				},
				styleClass: 'bg-warning',
				styleFn: this._applyStyle.bind(this, 'bg-warning')
			}, {
				name: AlloyEditor.Strings.info,
				style: {
					element: 'span',
					attributes: {
						class: 'text-info'
					}
				},
				styleClass: 'bg-info',
				styleFn: this._applyStyle.bind(this, 'bg-info')
			}];
		}
	}]);

	return ButtonBackgroundColor;
}(_react2.default.Component);

ButtonBackgroundColor.contextType = _editorContext2.default;
ButtonBackgroundColor.key = 'backgroundColor';
ButtonBackgroundColor.propTypes = {
	/**
  * Indicates whether the styles list is expanded or not.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {Boolean} expanded
  */
	expanded: _propTypes2.default.bool,

	/**
  * The label that should be used for accessibility purposes.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {String} label
  */
	label: _propTypes2.default.string,

	/**
  * Indicates whether the remove styles item should appear in the styles list.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {Boolean} showRemoveStylesItem
  */
	showRemoveStylesItem: _propTypes2.default.bool,

	/**
  * List of the styles the button is able to handle.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {Array} styles
  */
	styles: _propTypes2.default.arrayOf(_propTypes2.default.object),

	/**
  * The tabIndex of the button in its toolbar current state. A value other than -1
  * means that the button has focus and is the active element.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {Number} tabIndex
  */
	tabIndex: _propTypes2.default.number,

	/**
  * Callback provided by the button host to notify when the styles list has been expanded.
  *
  * @instance
  * @memberof ButtonBackgroundColor
  * @property {Function} toggleDropdown
  */
	toggleDropdown: _propTypes2.default.func
};
exports.default = (0, _buttonProps2.default)((0, _buttonStateClasses2.default)(ButtonBackgroundColor));

/***/ }),

/***/ "./src/components/buttons/button-bold.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-bold.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonBold class provides functionality for styling an selection with strong (bold) style.
 *
 * @class ButtonBold
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonBold = function (_React$Component) {
	_inherits(ButtonBold, _React$Component);

	function ButtonBold() {
		_classCallCheck(this, ButtonBold);

		return _possibleConstructorReturn(this, (ButtonBold.__proto__ || Object.getPrototypeOf(ButtonBold)).apply(this, arguments));
	}

	_createClass(ButtonBold, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonBold
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonBold
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button  ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.bold,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-bold',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.bold },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'bold' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default bold
   * @memberof ButtonBold
   * @property {String} key
   * @static
   */

	}]);

	return ButtonBold;
}(_react2.default.Component);

ButtonBold.defaultProps = {
	command: 'bold',
	keystroke: {
		fn: 'execCommand',
		keys: CKEDITOR.CTRL + 66 /* B*/
	},
	style: 'coreStyles_bold'
};
ButtonBold.key = 'bold';
exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonBold))));

/***/ }),

/***/ "./src/components/buttons/button-camera-image.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-camera-image.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCameraImage class takes photo from camera and inserts it to the content.
 *
 * @class ButtonCameraImage
 */
var ButtonCameraImage = function (_React$Component) {
	_inherits(ButtonCameraImage, _React$Component);

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonCameraImage
  */
	function ButtonCameraImage(props) {
		_classCallCheck(this, ButtonCameraImage);

		var _this = _possibleConstructorReturn(this, (ButtonCameraImage.__proto__ || Object.getPrototypeOf(ButtonCameraImage)).call(this, props));

		_this.takePhoto = function () {
			var videoEl = _this._videoContainerRef.current;
			var canvasEl = _this._canvasContainerRef.current;

			var context = canvasEl.getContext('2d');

			var height = _this._videoHeight;
			var width = _this.props.videoWidth;

			if (width && height) {
				canvasEl.width = width;
				canvasEl.height = height;

				context.drawImage(videoEl, 0, 0, width, height);

				var imgURL = canvasEl.toDataURL('image/png');

				var el = CKEDITOR.dom.element.createFromHtml('<img src="' + imgURL + '">');

				var editor = _this.context.editor.get('nativeEditor');

				editor.insertElement(el);

				_this.props.cancelExclusive();

				editor.fire('actionPerformed', _this);

				editor.fire('imageCameraAdd', el);
			}
		};

		_this._handleStreamError = function (error) {
			window.alert('An error occurred! ' + error);
		};

		_this._handleStreamSuccess = function (stream) {
			var videoEl = _this._videoContainerRef.current;
			var canvasEl = _this._canvasContainerRef.current;

			videoEl.addEventListener('canplay', function () {
				var height = videoEl.videoHeight / (videoEl.videoWidth / _this.props.videoWidth);

				if (isNaN(height)) {
					height = _this.props.videoWidth / (4 / 3);
				}

				videoEl.setAttribute('width', _this.props.videoWidth);
				videoEl.setAttribute('height', height);
				canvasEl.setAttribute('width', _this.props.videoWidth);
				canvasEl.setAttribute('height', height);

				_this._videoHeight = height;
			}, false);

			_this._stream = stream;

			if (navigator.mozGetUserMedia) {
				videoEl.mozSrcObject = stream;
			} else {
				videoEl.srcObject = stream;
			}

			videoEl.play();

			_this._buttonTakePhotoRef.current.disabled = false;
		};

		_this._buttonTakePhotoRef = _react2.default.createRef();
		_this._canvasContainerRef = _react2.default.createRef();
		_this._videoContainerRef = _react2.default.createRef();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses the take photo button.
  *
  * @instance
  * @memberof ButtonCameraImage
  * @method componentDidMount
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default cameraImage
  * @memberof ButtonCameraImage
  * @property {String} key
  * @static
  */


	_createClass(ButtonCameraImage, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this._buttonTakePhotoRef.current.focus();
		}

		/**
   * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
   *
   * @instance
   * @memberof ButtonCameraImage
   * @method componentWillUnmount
   */

	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			if (this._stream) {
				if (this._stream.stop) {
					this._stream.stop();
				} else if (this._stream.getVideoTracks) {
					this._stream.getVideoTracks().forEach(function (track) {
						track.stop();
					});
				}
				this._stream = null;
			}
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonCameraImage
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',


		/**
   * Fired when an image is being taken from the camera and added as an element to the editor.
   *
   * @event ButtonCameraImage#imageCameraAdd
   * @memberof ButtonCameraImage
   * @param {CKEDITOR.dom.element} el The created img element in editor.
   */
		value: function render() {
			var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

			getUserMedia.call(navigator, {
				video: true,
				audio: false
			}, this._handleStreamSuccess, this._handleStreamError);

			return _react2.default.createElement(
				'div',
				{ className: 'ae-camera' },
				_react2.default.createElement(
					'video',
					{ ref: this._videoContainerRef },
					'Video stream not available.'
				),
				_react2.default.createElement(
					'button',
					{
						className: 'ae-camera-shoot',
						onClick: this.takePhoto,
						ref: this._buttonTakePhotoRef },
					'Take photo'
				),
				_react2.default.createElement('canvas', {
					className: 'ae-camera-canvas',
					ref: this._canvasContainerRef
				})
			);
		}

		/**
   * Takes photo from the video stream and inserts in into editor's content.
   *
   * @fires ButtonCameraImage#imageCameraAdd
   * @instance
   * @memberof ButtonCameraImage
   * @method takePhoto
   */


		/**
   * Displays error message in case of video stream capturing failure.
   *
   * @instance
   * @memberof ButtonCameraImage
   * @method _handleStreamError
   * @param {Event} error The fired event in case of error.
   * @protected
   */


		/**
   * Starts streaming video in the video element and sets width/height to the video
   * and canvas elements.
   *
   * @instance
   * @memberof ButtonCameraImage
   * @method _handleStreamSuccess
   * @param {Object} stream The video stream
   * @protected
   */

	}]);

	return ButtonCameraImage;
}(_react2.default.Component);

ButtonCameraImage.contextType = _editorContext2.default;
ButtonCameraImage.defaultProps = {
	videoWidth: 320
};
ButtonCameraImage.key = 'cameraImage';
exports.default = ButtonCameraImage;

/***/ }),

/***/ "./src/components/buttons/button-camera.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-camera.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCameraImage = __webpack_require__(/*! ./button-camera-image.jsx */ "./src/components/buttons/button-camera-image.jsx");

var _buttonCameraImage2 = _interopRequireDefault(_buttonCameraImage);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCamera class renders in two different ways:
 *
 * - Normal: Just a button that allows to switch to the edition mode.
 * - Exclusive: Renders ButtonCameraImage in order to take photo from the camera.
 *
 * @class ButtonCamera
 */
var ButtonCamera = function (_React$Component) {
	_inherits(ButtonCamera, _React$Component);

	function ButtonCamera() {
		_classCallCheck(this, ButtonCamera);

		return _possibleConstructorReturn(this, (ButtonCamera.__proto__ || Object.getPrototypeOf(ButtonCamera)).apply(this, arguments));
	}

	_createClass(ButtonCamera, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonCamera
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.renderExclusive) {
				return _react2.default.createElement(_buttonCameraImage2.default, this.props);
			} else {
				var disabled = !(navigator.getUserMedia || navigator.webkitGetUserMedia && location.protocol === 'https' || navigator.mozGetUserMedia || navigator.msGetUserMedia);

				var label = disabled ? AlloyEditor.Strings.cameraDisabled : AlloyEditor.Strings.camera;

				return _react2.default.createElement(
					'button',
					{
						'aria-label': label,
						className: 'ae-button',
						'data-type': 'button-image-camera',
						disabled: disabled,
						onClick: this.props.requestExclusive.bind(ButtonCamera.key),
						tabIndex: this.props.tabIndex,
						title: label },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'camera' })
				);
			}
		}
		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default camera
   * @memberof ButtonCamera
   * @property {String} key
   * @static
   */

	}]);

	return ButtonCamera;
}(_react2.default.Component);

ButtonCamera.key = 'camera';
exports.default = ButtonCamera;

/***/ }),

/***/ "./src/components/buttons/button-code.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-code.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCode class provides wraps a selection in `pre` element.
 *
 * @class ButtonCode
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonCode = function (_React$Component) {
	_inherits(ButtonCode, _React$Component);

	function ButtonCode() {
		_classCallCheck(this, ButtonCode);

		return _possibleConstructorReturn(this, (ButtonCode.__proto__ || Object.getPrototypeOf(ButtonCode)).apply(this, arguments));
	}

	_createClass(ButtonCode, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonCode
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonCode
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.code,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-code',
					onClick: this.applyStyle,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.code },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'code' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default code
   * @memberof ButtonCode
   * @property {String} key
   * @static
   */

	}]);

	return ButtonCode;
}(_react2.default.Component);

ButtonCode.defaultProps = {
	style: {
		element: 'pre'
	}
};
ButtonCode.key = 'code';
exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonCode)));

/***/ }),

/***/ "./src/components/buttons/button-color.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-color.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonProps = __webpack_require__(/*! ../base/button-props */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonColor class provides functionality for changing text color in a document.
 *
 *
 * @class ButtonColor
 * @uses ButtonProps
 * @uses ButtonStateClasses
 */
var ButtonColor = function (_React$Component) {
	_inherits(ButtonColor, _React$Component);

	function ButtonColor() {
		_classCallCheck(this, ButtonColor);

		return _possibleConstructorReturn(this, (ButtonColor.__proto__ || Object.getPrototypeOf(ButtonColor)).apply(this, arguments));
	}

	_createClass(ButtonColor, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var _this2 = this;

			var activeColor = AlloyEditor.Strings.normal;

			var colors = this._getColors();

			colors.some(function (item) {
				if (_this2._checkActive(item.style)) {
					activeColor = item.name;
				}
			});

			var _props = this.props,
			    expanded = _props.expanded,
			    tabIndex = _props.tabIndex,
			    toggleDropdown = _props.toggleDropdown;


			var buttonStylesProps = {
				activeStyle: activeColor,
				onDismiss: toggleDropdown,
				showRemoveStylesItem: false,
				styles: colors
			};

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': expanded,
						className: 'ae-toolbar-element',
						onClick: toggleDropdown,
						role: 'combobox',
						tabIndex: tabIndex },
					_react2.default.createElement(
						'span',
						null,
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'color-picker' })
					)
				),
				expanded && _react2.default.createElement(_buttonStylesList2.default, buttonStylesProps)
			);
		}
	}, {
		key: '_applyStyle',
		value: function _applyStyle(className) {
			var _this3 = this;

			var editor = this.context.editor.get('nativeEditor');

			var styleConfig = {
				element: 'span',
				attributes: {
					class: className
				}
			};

			var style = new CKEDITOR.style(styleConfig);

			editor.getSelection().lock();

			this._getColors().forEach(function (item) {
				if (_this3._checkActive(item.style)) {
					editor.removeStyle(new CKEDITOR.style(item.style));
				}
			});

			editor.applyStyle(style);

			editor.getSelection().unlock();

			editor.fire('actionPerformed', this);
		}

		/**
   * Checks if the given color definition is applied to the current selection in the editor.
   *
   * @instance
   * @memberof ButtonColor
   * @method _checkActive
   * @param {Object} styleConfig Color definition as per http://docs.ckeditor.com/#!/api/CKEDITOR.style.
   * @protected
   * @return {Boolean} Returns true if the color is applied to the selection, false otherwise.
   */

	}, {
		key: '_checkActive',
		value: function _checkActive(styleConfig) {
			var nativeEditor = this.context.editor.get('nativeEditor');

			// Styles with wildcard element (*) won't be considered active by CKEditor. Defaulting
			// to a 'span' element works for most of those cases with no defined element.
			styleConfig = CKEDITOR.tools.merge({ element: 'span' }, styleConfig);

			var style = new CKEDITOR.style(styleConfig);

			return style.checkActive(nativeEditor.elementPath(), nativeEditor);
		}

		/**
   * Returns an array of colors. Each color consists of two properties:
   * - name - The style name, for example "default".
   * - style - An object with one property, called `element` which value
   *          represents the style which have to be applied to the element.
   * - styleFn - The function that is invoked to apply the style to the element.
   *
   * @instance
   * @memberof ButtonColor
   * @method _getColor
   * @protected
   * @return {Array<object>} An array of objects containing the colors.
   */

	}, {
		key: '_getColors',
		value: function _getColors() {
			return this.props.styles || [{
				name: AlloyEditor.Strings.primary,
				style: {
					element: 'span',
					attributes: {
						class: 'text-primary'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-primary')
			}, {
				name: AlloyEditor.Strings.success,
				style: {
					element: 'span',
					attributes: {
						class: 'text-success'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-success')
			}, {
				name: AlloyEditor.Strings.danger,
				style: {
					element: 'span',
					attributes: {
						class: 'text-danger'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-danger')
			}, {
				name: AlloyEditor.Strings.warning,
				style: {
					element: 'span',
					attributes: {
						class: 'text-warning'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-warning')
			}, {
				name: AlloyEditor.Strings.info,
				style: {
					element: 'span',
					attributes: {
						class: 'text-info'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-info')
			}, {
				name: AlloyEditor.Strings.dark,
				style: {
					element: 'span',
					attributes: {
						class: 'text-dark'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-dark')
			}, {
				name: AlloyEditor.Strings.darkGray,
				style: {
					element: 'span',
					attributes: {
						class: 'text-gray-dark'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-gray-dark')
			}, {
				name: AlloyEditor.Strings.secondary,
				style: {
					element: 'span',
					attributes: {
						class: 'text-secondary'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-secondary')
			}, {
				name: AlloyEditor.Strings.light,
				style: {
					element: 'span',
					attributes: {
						class: 'text-dark'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-light')
			}, {
				name: AlloyEditor.Strings.lighter,
				style: {
					element: 'span',
					attributes: {
						class: 'text-dark'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-lighter')
			}, {
				name: AlloyEditor.Strings.white,
				style: {
					element: 'span',
					attributes: {
						class: 'text-dark'
					}
				},
				styleFn: this._applyStyle.bind(this, 'text-white')
			}];
		}
	}]);

	return ButtonColor;
}(_react2.default.Component);

ButtonColor.contextType = _editorContext2.default;
ButtonColor.key = 'color';
ButtonColor.propTypes = {
	/**
  * Indicates whether the styles list is expanded or not.
  *
  * @instance
  * @memberof ButtonColor
  * @property {Boolean} expanded
  */
	expanded: _propTypes2.default.bool,

	/**
  * The label that should be used for accessibility purposes.
  *
  * @instance
  * @memberof ButtonColor
  * @property {String} label
  */
	label: _propTypes2.default.string,

	/**
  * Indicates whether the remove styles item should appear in the styles list.
  *
  * @instance
  * @memberof ButtonColor
  * @property {Boolean} showRemoveStylesItem
  */
	showRemoveStylesItem: _propTypes2.default.bool,

	/**
  * List of the styles the button is able to handle.
  *
  * @instance
  * @memberof ButtonColor
  * @property {Array} styles
  */
	styles: _propTypes2.default.arrayOf(_propTypes2.default.object),

	/**
  * The tabIndex of the button in its toolbar current state. A value other than -1
  * means that the button has focus and is the active element.
  *
  * @instance
  * @memberof ButtonColor
  * @property {Number} tabIndex
  */
	tabIndex: _propTypes2.default.number,

	/**
  * Callback provided by the button host to notify when the styles list has been expanded.
  *
  * @instance
  * @memberof ButtonColor
  * @property {Function} toggleDropdown
  */
	toggleDropdown: _propTypes2.default.func
};
exports.default = (0, _buttonProps2.default)((0, _buttonStateClasses2.default)(ButtonColor));

/***/ }),

/***/ "./src/components/buttons/button-command-list-item.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-command-list-item.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCommandListItem class is a UI class that renders a ButtonCommand that can be used inside
 * a list as an item, with a string representation of its behaviour.
 *
 * @class ButtonCommandListItem
 * @uses ButtonCommand
 */
var ButtonCommandListItem = function (_React$Component) {
	_inherits(ButtonCommandListItem, _React$Component);

	function ButtonCommandListItem() {
		_classCallCheck(this, ButtonCommandListItem);

		return _possibleConstructorReturn(this, (ButtonCommandListItem.__proto__ || Object.getPrototypeOf(ButtonCommandListItem)).apply(this, arguments));
	}

	_createClass(ButtonCommandListItem, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonCommandListItem
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': this.props.description,
					className: this._getClassName(),
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex },
				this.props.description
			);
		}

		/**
   * Returns the class name of Widget.
   *
   * @instance
   * @memberof ButtonCommandListItem
   * @method _getClassName
   * @protected
   * @return {String} The class name of the Widget.
   */

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default buttonCommandListItem
   * @memberof ButtonCommandListItem
   * @property {String} key
   * @static
   */

	}, {
		key: '_getClassName',
		value: function _getClassName() {
			var className = 'ae-container ae-toolbar-element';

			return className;
		}
	}]);

	return ButtonCommandListItem;
}(_react2.default.Component);

ButtonCommandListItem.key = 'buttonCommandListItem';
exports.default = (0, _buttonCommand2.default)(ButtonCommandListItem);

/***/ }),

/***/ "./src/components/buttons/button-commands-list.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-commands-list.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommandListItem = __webpack_require__(/*! ./button-command-list-item.jsx */ "./src/components/buttons/button-command-list-item.jsx");

var _buttonCommandListItem2 = _interopRequireDefault(_buttonCommandListItem);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonCommandsList class provides functionality for showing a list of commands that can be
 * executed to the current selection..
 *
 * @class ButtonCommandsList
 * @uses WidgetFocusManager
 */
var ButtonCommandsList = function (_React$Component) {
	_inherits(ButtonCommandsList, _React$Component);

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonCommandsList
  * @method getDefaultProps
  * @return {Object} The default properties.
  */
	function ButtonCommandsList(props) {
		_classCallCheck(this, ButtonCommandsList);

		var _this = _possibleConstructorReturn(this, (ButtonCommandsList.__proto__ || Object.getPrototypeOf(ButtonCommandsList)).call(this, props));

		_this._ref = _react2.default.createRef();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses on the list node to allow keyboard interaction.
  *
  * @instance
  * @memberof ButtonCommandsList
  * @method componentDidMount
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default buttonCommandsList
  * @memberof ButtonCommandsList
  * @property {String} key
  * @static
  */


	_createClass(ButtonCommandsList, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this._ref.current.focus();
		}

		/**
   * Lifecycle. Renders the UI of the list.
   *
   * @instance
   * @memberof ButtonCommandsList
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{
					className: 'ae-dropdown ae-arrow-box ae-arrow-box-top-left',
					onFocus: this.focus,
					onKeyDown: this.handleKey,
					ref: this._ref,
					tabIndex: '0' },
				_react2.default.createElement(
					'ul',
					{
						className: 'ae-listbox',
						id: this.props.listId,
						role: 'listbox' },
					this._renderActions(this.props.commands)
				)
			);
		}

		/**
   * Renders instances of ButtonCommandListItem with the description of the row action that will be executed.
   *
   * @instance
   * @memberof ButtonCommandsList
   * @method _renderActions
   * @protected
   * @return {Array} Rendered instances of ButtonCommandListItem class
   */

	}, {
		key: '_renderActions',
		value: function _renderActions(commands) {
			var items = void 0;

			if (commands && commands.length) {
				items = commands.map(function (item) {
					return _react2.default.createElement(
						'li',
						{ key: item.command, role: 'option' },
						_react2.default.createElement(_buttonCommandListItem2.default, {
							command: item.command,
							description: typeof item.label === 'string' ? item.label : item.label(),
							icon: item.icon
						})
					);
				});
			}

			return items;
		}
	}]);

	return ButtonCommandsList;
}(_react2.default.Component);

ButtonCommandsList.defaultProps = {
	circular: false,
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	}
};
ButtonCommandsList.key = 'buttonCommandsList';
exports.default = (0, _widgetFocusManager2.default)(ButtonCommandsList);

/***/ }),

/***/ "./src/components/buttons/button-dropdown.jsx":
/*!****************************************************!*\
  !*** ./src/components/buttons/button-dropdown.jsx ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonDropdown class provides markup and keyboard navigation behaviour to a dropdown
 * opened from a button.
 *
 * @class ButtonDropdown
 */
var ButtonDropdown = function (_React$Component) {
	_inherits(ButtonDropdown, _React$Component);

	function ButtonDropdown() {
		_classCallCheck(this, ButtonDropdown);

		return _possibleConstructorReturn(this, (ButtonDropdown.__proto__ || Object.getPrototypeOf(ButtonDropdown)).apply(this, arguments));
	}

	_createClass(ButtonDropdown, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonDropdown
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonDropdown
   * @method getDefaultProps
   */
		value: function render() {
			return _react2.default.createElement(
				'div',
				{
					className: 'ae-dropdown ae-arrow-box ae-arrow-box-top-left',
					onFocus: this.focus,
					onKeyDown: this.handleKey,
					tabIndex: '0' },
				_react2.default.createElement(
					'ul',
					{ className: 'ae-listbox', role: 'listbox' },
					this.props.children
				)
			);
		}

		/**
   * The name which will be used as an alias of the dropdown in the configuration.
   *
   * @default dropdown
   * @memberof ButtonDropdown
   * @property {String} key
   * @static
   */

	}]);

	return ButtonDropdown;
}(_react2.default.Component);

ButtonDropdown.defaultProps = {
	circular: false,
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	}
};
ButtonDropdown.key = 'dropdown';
exports.default = (0, _widgetFocusManager2.default)(ButtonDropdown);

/***/ }),

/***/ "./src/components/buttons/button-embed-edit.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-embed-edit.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KEY_ENTER = 13;
var KEY_ESC = 27;

/**
 * The ButtonEmbedEdit class provides functionality for creating and editing an embed link in a document.
 * Provides UI for creating and editing an embed link.
 *
 * @class ButtonEmbedEdit
 */

var ButtonEmbedEdit = function (_React$Component) {
	_inherits(ButtonEmbedEdit, _React$Component);

	function ButtonEmbedEdit(props) {
		_classCallCheck(this, ButtonEmbedEdit);

		var _this = _possibleConstructorReturn(this, (ButtonEmbedEdit.__proto__ || Object.getPrototypeOf(ButtonEmbedEdit)).call(this, props));

		_this._clearLink = function () {
			_this.setState({
				linkHref: ''
			});
		};

		_this._embedLink = function () {
			var nativeEditor = _this.context.editor.get('nativeEditor');

			nativeEditor.execCommand('embedUrl', {
				url: _this.state.linkHref
			});

			// We need to cancelExclusive with the bound parameters in case the button is used
			// inside another in exclusive mode (such is the case of the link button)
			_this.props.cancelExclusive();
		};

		_this._focusLinkInput = function () {
			_this.linkInput.current.focus();
		};

		_this._handleKeyDown = function (event) {
			if (event.keyCode === KEY_ENTER || event.keyCode === KEY_ESC) {
				event.preventDefault();
			}

			if (event.keyCode === KEY_ENTER) {
				_this._embedLink();
			} else if (event.keyCode === KEY_ESC) {
				var editor = _this.context.editor.get('nativeEditor');

				// We need to cancelExclusive with the bound parameters in case the button is used
				// inside another in exclusive mode (such is the case of the link button)
				_this.props.cancelExclusive();

				editor.fire('actionPerformed', _this);
			}
		};

		_this._handleLinkHrefChange = function (event) {
			_this.setState({
				linkHref: event.target.value
			});
		};

		_this._removeEmbed = function () {
			var editor = _this.context.editor.get('nativeEditor');

			var embedWrapper = _this.state.element.getAscendant(function (element) {
				return element.hasClass('cke_widget_wrapper');
			});

			embedWrapper.remove();

			editor.fire('actionPerformed', _this);
		};

		_this.linkInput = _react2.default.createRef();
		_this.state = _this.getInitialState();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses on the link input to immediately allow editing. This should only happen if the component
  * is rendered in exclusive mode to prevent aggressive focus stealing.
  *
  * @instance
  * @memberof ButtonEmbedEdit
  * @method componentDidMount
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default embedEdit
  * @memberof ButtonEmbedEdit
  * @property {String} key
  * @static
  */


	_createClass(ButtonEmbedEdit, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (this.props.renderExclusive || this.props.manualSelection) {
				// We need to wait for the next rendering cycle before focusing to avoid undesired
				// scrolls on the page
				if (window.requestAnimationFrame) {
					window.requestAnimationFrame(this._focusLinkInput);
				} else {
					setTimeout(this._focusLinkInput, 0);
				}
			}
		}

		/**
   * Lifecycle. Invoked when a component is receiving new props.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method componentWillReceiveProps
   */

	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps() {
			this.setState(this.getInitialState());
		}

		/**
   * Lifecycle. Invoked once before the component is mounted.
   * The return value will be used as the initial value of this.state.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method getInitialState
   */

	}, {
		key: 'getInitialState',
		value: function getInitialState() {
			// Can't access context from constructor, so get editor from props.
			var editor = this.props.context.editor.get('nativeEditor');
			var embed = void 0;

			var selection = editor.getSelection();

			if (selection) {
				var selectedElement = selection.getSelectedElement();

				if (selectedElement) {
					embed = selectedElement.findOne('[data-widget="ae_embed"]');
				}
			}

			var href = embed ? embed.getAttribute('data-ae-embed-url') : '';

			return {
				element: embed,
				initialLink: {
					href: href
				},
				linkHref: href
			};
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var clearLinkStyle = {
				opacity: this.state.linkHref ? 1 : 0
			};

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-edit-link' },
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.deleteEmbed,
						className: 'ae-button',
						'data-type': 'button-embed-remove',
						disabled: !this.state.element,
						onClick: this._removeEmbed,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.deleteEmbed },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'trash', className: 'ae-icon-svg-trash' })
				),
				_react2.default.createElement(
					'div',
					{ className: 'ae-container-input xxl' },
					_react2.default.createElement('input', {
						className: 'ae-input',
						onChange: this._handleLinkHrefChange,
						onKeyDown: this._handleKeyDown,
						placeholder: AlloyEditor.Strings.editLink,
						ref: this.linkInput,
						type: 'text',
						value: this.state.linkHref
					}),
					_react2.default.createElement(
						'button',
						{
							'aria-label': AlloyEditor.Strings.clearInput,
							className: 'ae-button ae-button-clear',
							onClick: this._clearLink,
							style: clearLinkStyle,
							title: AlloyEditor.Strings.clear },
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'times-clear' })
					)
				),
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.confirm,
						className: 'ae-button',
						disabled: !this._isValidState(),
						onClick: this._embedLink,
						title: AlloyEditor.Strings.confirm },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'check', className: 'ae-icon-svg-check' })
				)
			);
		}

		/**
   * Clears the link input. This only changes the component internal state, but does not
   * affect the link element of the editor. Only the _removeLink and _updateLink methods
   * are translated to the editor element.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _clearLink
   * @protected
   */


		/**
   * Triggers the embedUrl command to transform the link into an embed media object
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _embedLink
   * @protected
   */


		/**
   * Focuses the user cursor on the widget's input.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _focusLinkInput
   * @protected
   */


		/**
   * Monitors key interaction inside the input element to respond to the keys:
   * - Enter: Creates/updates the link.
   * - Escape: Discards the changes.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _handleKeyDown
   * @param {SyntheticEvent} event The keyboard event.
   * @protected
   */


		/**
   * Updates the component state when the link input changes on user interaction.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _handleLinkHrefChange
   * @param {SyntheticEvent} event The change event.
   * @protected
   */

	}, {
		key: '_isValidState',


		/**
   * Verifies that the current link state is valid so the user can save the link. A valid state
   * means that we have a non-empty href that's different from the original one.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _isValidState
   * @protected
   * @return {Boolean} True if the state is valid, false otherwise
   */
		value: function _isValidState() {
			var validState = this.state.linkHref && this.state.linkHref !== this.state.initialLink.href;

			return validState;
		}

		/**
   * Removes the embed in the editor element.
   *
   * @instance
   * @memberof ButtonEmbedEdit
   * @method _removeEmbed
   * @protected
   */

	}]);

	return ButtonEmbedEdit;
}(_react2.default.Component);

ButtonEmbedEdit.contextType = _editorContext2.default;
ButtonEmbedEdit.key = 'embedEdit';
exports.default = _editorContext2.default.toProps(ButtonEmbedEdit);

/***/ }),

/***/ "./src/components/buttons/button-embed-video-edit.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-embed-video-edit.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KEY_ENTER = 13;
var KEY_ESC = 27;

/**
 * The ButtonEmbedVideoEdit class provides functionality for changing text color in a document.
 *
 * @uses ButtonIcon
 *
 * @class ButtonEmbedVideoEdit
 */

var ButtonEmbedVideoEdit = function (_React$Component) {
	_inherits(ButtonEmbedVideoEdit, _React$Component);

	function ButtonEmbedVideoEdit(props) {
		_classCallCheck(this, ButtonEmbedVideoEdit);

		var _this = _possibleConstructorReturn(this, (ButtonEmbedVideoEdit.__proto__ || Object.getPrototypeOf(ButtonEmbedVideoEdit)).call(this, props));

		_this._embedVideoURL = function () {
			var nativeEditor = _this.context.editor.get('nativeEditor');

			nativeEditor.execCommand('embedUrl', {
				type: 'video',
				url: _this.state.videoURL
			});

			// We need to cancelExclusive with the bound parameters in case the button is used
			// inside another in exclusive mode (such is the case of the link button)
			_this.props.cancelExclusive();
		};

		_this._focusVideoUrlInput = function () {
			_reactDom2.default.findDOMNode(_this.refs.linkInput).focus();
		};

		_this._handleKeyDown = function (event) {
			if (event.keyCode === KEY_ENTER || event.keyCode === KEY_ESC) {
				event.preventDefault();
			}

			if (event.keyCode === KEY_ENTER) {
				_this._embedVideoURL();
			} else if (event.keyCode === KEY_ESC) {
				_this.props.cancelExclusive();
			}
		};

		_this._handleVideoURLChange = function (event) {
			_this.setState({
				videoURL: event.target.value
			});
		};

		_this.state = _this.getInitialState();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses on the link input to immediately allow editing. This should only happen if the component
  * is rendered in exclusive mode to prevent aggressive focus stealing.
  *
  * @instance
  * @memberof ButtonEmbedVideoEdit
  * @method componentDidMount
  */


	_createClass(ButtonEmbedVideoEdit, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (this.props.renderExclusive || this.props.manualSelection) {
				// We need to wait for the next rendering cycle before focusing to avoid undesired
				// scrolls on the page
				if (window.requestAnimationFrame) {
					window.requestAnimationFrame(this._focusVideoUrlInput);
				} else {
					setTimeout(this._focusVideoUrlInput, 0);
				}
			}
		}

		/**
   * Lifecycle. Invoked when a component is receiving new props.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method componentWillReceiveProps
   */

	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps() {
			var newState = this.getInitialState();

			this.setState({
				all: undefined,
				keys: undefined,
				new: newState,
				old: undefined
			});
		}

		/**
   * Lifecycle. Invoked once before the component is mounted.
   * The return value will be used as the initial value of this.state.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method getInitialState
   */

	}, {
		key: 'getInitialState',
		value: function getInitialState() {
			// Can't access context from constructor, so get editor from props.
			var editor = this.props.context.editor.get('nativeEditor');
			var element = void 0;

			var selection = editor.getSelection();

			if (selection) {
				var selectedElement = selection.getSelectedElement();

				if (selectedElement) {
					element = selectedElement.findOne('[data-widget="videoembed"]');
				}
			}

			var videoURL = element ? element.getAttribute('data-embed-video-url') : '';

			return {
				element: element,
				initialEmbed: {
					videoURL: videoURL
				},
				videoURL: videoURL
			};
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var inputPlaceholder = AlloyEditor.Strings.pasteVideoLink;

			var clearVideoURLStyle = {
				opacity: this.state.videoURL ? 1 : 0
			};

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-embed-video-edit' },
				_react2.default.createElement(
					'div',
					{ className: 'ae-container-input xxl' },
					_react2.default.createElement('input', {
						className: 'ae-input',
						onChange: this._handleVideoURLChange,
						onKeyDown: this._handleKeyDown,
						placeholder: inputPlaceholder,
						ref: 'linkInput',
						type: 'text',
						value: this.state.videoURL
					}),
					_react2.default.createElement('button', {
						'aria-label': AlloyEditor.Strings.clearInput,
						className: 'ae-button ae-icon-remove',
						onClick: this._clearLink,
						style: clearVideoURLStyle,
						title: AlloyEditor.Strings.clear
					})
				),
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.confirm,
						className: 'ae-button',
						disabled: !this._isValidState(),
						onClick: this._embedVideoURL,
						title: AlloyEditor.Strings.confirm },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'check' })
				)
			);
		}

		/**
   * Clears the link input. This only changes the component internal state, but does not
   * affect the link element of the editor. Only the _removeLink and _updateLink methods
   * are translated to the editor element.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method _clearLink
   * @protected
   */

	}, {
		key: '_clearLink',
		value: function _clearLink() {
			this.setState({
				videoURL: ''
			});
		}

		/**
   * Triggers the embedVideoUrl command to transform the link into an embed media object
   *
   * @instance
   * @memberof EmbedVideoEdit
   * @method _embedVideoURL
   * @protected
   */


		/**
   * Focuses the user cursor on the widget's input.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method _focusVideoUrlInput
   * @protected
   */


		/**
   * Monitors key interaction inside the input element to respond to the keys:
   * - Enter: Creates/updates the link.
   * - Escape: Discards the changes.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method _handleKeyDown
   * @param {SyntheticEvent} event The keyboard event.
   * @protected
   */


		/**
   * Updates the component state when the link input changes on user interaction.
   *
   * @instance
   * @memberof ButtonEmbedVideoEdit
   * @method _handleVideoURLChange
   * @param {SyntheticEvent} event The change event.
   * @protected
   */

	}, {
		key: '_isValidState',


		/**
   * Verifies that the current link state is valid so the user can save the link. A valid state
   * means that we have a non-empty videoURL that's different from the original one.
   *
   * @instance
   * @memberof EmbedVideoEdit
   * @method _isValidState
   * @protected
   * @return {Boolean} True if the state is valid, false otherwise
   */
		value: function _isValidState() {
			var validState = this.state.videoURL && this.state.videoURL !== this.state.initialEmbed.videoURL;

			return validState;
		}
	}]);

	return ButtonEmbedVideoEdit;
}(_react2.default.Component);

ButtonEmbedVideoEdit.contextType = _editorContext2.default;
ButtonEmbedVideoEdit.key = 'embedVideoEdit';
exports.default = _editorContext2.default.toProps(ButtonEmbedVideoEdit);

/***/ }),

/***/ "./src/components/buttons/button-embed-video.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-embed-video.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonEmbedVideoEdit = __webpack_require__(/*! ./button-embed-video-edit.jsx */ "./src/components/buttons/button-embed-video-edit.jsx");

var _buttonEmbedVideoEdit2 = _interopRequireDefault(_buttonEmbedVideoEdit);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonProps = __webpack_require__(/*! ../base/button-props */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonEmbedVideo class provides functionality for changing text color in a document.
 *
 * @class ButtonEmbedVideo
 * @uses ButtonProps
 */
var ButtonEmbedVideo = function (_React$Component) {
	_inherits(ButtonEmbedVideo, _React$Component);

	function ButtonEmbedVideo() {
		_classCallCheck(this, ButtonEmbedVideo);

		return _possibleConstructorReturn(this, (ButtonEmbedVideo.__proto__ || Object.getPrototypeOf(ButtonEmbedVideo)).apply(this, arguments));
	}

	_createClass(ButtonEmbedVideo, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.renderExclusive) {
				return _react2.default.createElement(_buttonEmbedVideoEdit2.default, this.props);
			} else {
				return _react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.video,
						className: 'ae-button',
						'data-type': 'button-embed-video',
						onClick: this.props.requestExclusive,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.video },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'video' })
				);
			}
		}
	}]);

	return ButtonEmbedVideo;
}(_react2.default.Component);

ButtonEmbedVideo.key = 'embedVideo';
ButtonEmbedVideo.propTypes = {
	/**
  * The label that should be used for accessibility purposes.
  *
  * @instance
  * @memberof ButtonEmbedVideo
  * @property {String} label
  */
	label: _propTypes2.default.string,

	/**
  * The tabIndex of the button in its toolbar current state. A value other than -1
  * means that the button has focus and is the active element.
  *
  * @instance
  * @memberof ButtonEmbedVideo
  * @property {Number} tabIndex
  */
	tabIndex: _propTypes2.default.number
};
exports.default = (0, _buttonProps2.default)(ButtonEmbedVideo);

/***/ }),

/***/ "./src/components/buttons/button-embed.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-embed.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonEmbedEdit = __webpack_require__(/*! ./button-embed-edit.jsx */ "./src/components/buttons/button-embed-edit.jsx");

var _buttonEmbedEdit2 = _interopRequireDefault(_buttonEmbedEdit);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonEmbed class provides functionality for creating and editing an embed link in a document.
 * ButtonEmbed renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonEmbedEdit UI with all the link edition controls.
 *
 * @class ButtonEmbed
 * @uses ButtonKeystroke
 */
var ButtonEmbed = function (_React$Component) {
	_inherits(ButtonEmbed, _React$Component);

	function ButtonEmbed() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonEmbed);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonEmbed.__proto__ || Object.getPrototypeOf(ButtonEmbed)).call.apply(_ref, [this].concat(args))), _this), _this._requestExclusive = function () {
			_this.props.requestExclusive(ButtonEmbed.key);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}
	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonEmbed
  * @method getDefaultProps
  * @return {Object} The default properties.
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default embed
  * @memberof ButtonEmbed
  * @property {String} key
  * @static
  */


	_createClass(ButtonEmbed, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonEmbed
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.renderExclusive) {
				return _react2.default.createElement(_buttonEmbedEdit2.default, this.props);
			} else {
				return _react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.link,
						className: 'ae-button',
						'data-type': 'button-embed',
						onClick: this._requestExclusive,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.link },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'plus' })
				);
			}
		}

		/**
   * Requests the link button to be rendered in exclusive mode to allow the embedding of a link.
   *
   * @instance
   * @memberof ButtonEmbed
   * @method _requestExclusive
   * @protected
   */

	}]);

	return ButtonEmbed;
}(_react2.default.Component);

ButtonEmbed.defaultProps = {
	keystroke: {
		fn: '_requestExclusive',
		keys: CKEDITOR.CTRL + CKEDITOR.SHIFT + 76 /* L*/
	}
};
ButtonEmbed.key = 'embed';
exports.default = (0, _buttonKeystroke2.default)(ButtonEmbed);

/***/ }),

/***/ "./src/components/buttons/button-h1.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-h1.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonH1 class provides wraps a selection in `h1` element.
 *
 * @class ButtonH1
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonH1 = function (_React$Component) {
	_inherits(ButtonH1, _React$Component);

	function ButtonH1() {
		_classCallCheck(this, ButtonH1);

		return _possibleConstructorReturn(this, (ButtonH1.__proto__ || Object.getPrototypeOf(ButtonH1)).apply(this, arguments));
	}

	_createClass(ButtonH1, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonH1
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonH1
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.h1,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-h1',
					onClick: this.applyStyle,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.h1 },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'h1' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default h1
   * @memberof ButtonH1
   * @property {String} key
   * @static
   */

	}]);

	return ButtonH1;
}(_react2.default.Component);

ButtonH1.defaultProps = {
	style: {
		element: 'h1'
	}
};
ButtonH1.key = 'h1';
exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonH1)));

/***/ }),

/***/ "./src/components/buttons/button-h2.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-h2.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonH2 class provides wraps a selection in `h2` element.
 *
 * @class ButtonH2
 * @uses ButtonActionStyle
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonH2 = function (_React$Component) {
	_inherits(ButtonH2, _React$Component);

	function ButtonH2() {
		_classCallCheck(this, ButtonH2);

		return _possibleConstructorReturn(this, (ButtonH2.__proto__ || Object.getPrototypeOf(ButtonH2)).apply(this, arguments));
	}

	_createClass(ButtonH2, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonH2
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonH2
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.h2,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-h2',
					onClick: this.applyStyle,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.h2 },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'h2' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default h2
   * @memberof ButtonH2
   * @property {String} key
   * @static
   */

	}]);

	return ButtonH2;
}(_react2.default.Component);

ButtonH2.defaultProps = {
	style: {
		element: 'h2'
	}
};
ButtonH2.key = 'h2';
exports.default = (0, _buttonActionStyle2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonH2)));

/***/ }),

/***/ "./src/components/buttons/button-hline.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-hline.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonHline class provides inserts horizontal line.
 *
 * @class ButtonHline
 * @uses ButtonCommand
 * @uses ButtonStyle
 */
var ButtonHline = function (_React$Component) {
	_inherits(ButtonHline, _React$Component);

	function ButtonHline() {
		_classCallCheck(this, ButtonHline);

		return _possibleConstructorReturn(this, (ButtonHline.__proto__ || Object.getPrototypeOf(ButtonHline)).apply(this, arguments));
	}

	_createClass(ButtonHline, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonHline
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonHline
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.horizontalrule,
					className: 'ae-button',
					'data-type': 'button-hline',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.horizontalrule },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'hr' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default hline
   * @memberof ButtonHline
   * @property {String} key
   * @static
   */

	}]);

	return ButtonHline;
}(_react2.default.Component);

ButtonHline.defaultProps = {
	command: 'horizontalrule',
	style: {
		element: 'hr'
	}
};
ButtonHline.key = 'hline';
exports.default = (0, _buttonCommand2.default)((0, _buttonStyle2.default)(ButtonHline));

/***/ }),

/***/ "./src/components/buttons/button-icon.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-icon.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = ButtonIcon;

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ButtonIcon(_ref) {
	var _ref$className = _ref.className,
	    className = _ref$className === undefined ? '' : _ref$className,
	    symbol = _ref.symbol;

	return _react2.default.createElement(
		_editorContext2.default.Consumer,
		null,
		function (_ref2) {
			var editor = _ref2.editor;

			var nativeEditor = editor.get('nativeEditor');
			var spritemap = nativeEditor.config.spritemap || '';
			var path = spritemap + '#' + symbol;
			var classNamePrefix = className ? ' ' + className : '';
			var combinedClassName = 'ae-svg-icon' + classNamePrefix;

			return _react2.default.createElement(
				'svg',
				{ className: combinedClassName, width: '18', height: '18' },
				_react2.default.createElement('use', { href: path })
			);
		}
	);
}

/***/ }),

/***/ "./src/components/buttons/button-image-align-center.jsx":
/*!**************************************************************!*\
  !*** ./src/components/buttons/button-image-align-center.jsx ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImageAlignCenter class provides functionality for aligning an image in the center.
 *
 * @class ButtonImageAlignCenter
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignCenter = function (_React$Component) {
	_inherits(ButtonImageAlignCenter, _React$Component);

	function ButtonImageAlignCenter() {
		_classCallCheck(this, ButtonImageAlignCenter);

		return _possibleConstructorReturn(this, (ButtonImageAlignCenter.__proto__ || Object.getPrototypeOf(ButtonImageAlignCenter)).apply(this, arguments));
	}

	_createClass(ButtonImageAlignCenter, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonImageAlignCenter
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonImageAlignCenter
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignCenter,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-image-align-center',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignCenter },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-image-center' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default imageCenter
   * @memberof ButtonImageAlignCenter
   * @property {String} key
   * @static
   */

	}]);

	return ButtonImageAlignCenter;
}(_react2.default.Component);

ButtonImageAlignCenter.defaultProps = {
	command: 'justifycenter'
};
ButtonImageAlignCenter.key = 'imageCenter';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignCenter)));

/***/ }),

/***/ "./src/components/buttons/button-image-align-left.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-image-align-left.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImageAlignLeft class provides functionality for aligning an image on left.
 *
 * @class ButtonImageAlignLeft
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignLeft = function (_React$Component) {
	_inherits(ButtonImageAlignLeft, _React$Component);

	function ButtonImageAlignLeft() {
		_classCallCheck(this, ButtonImageAlignLeft);

		return _possibleConstructorReturn(this, (ButtonImageAlignLeft.__proto__ || Object.getPrototypeOf(ButtonImageAlignLeft)).apply(this, arguments));
	}

	_createClass(ButtonImageAlignLeft, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonImageAlignLeft
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonImageAlignLeft
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignLeft,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-image-align-left',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignLeft },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-image-left' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default imageLeft
   * @memberof ButtonImageAlignLeft
   * @property {String} key
   * @static
   */

	}]);

	return ButtonImageAlignLeft;
}(_react2.default.Component);

ButtonImageAlignLeft.defaultProps = {
	command: 'justifyleft'
};
ButtonImageAlignLeft.key = 'imageLeft';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignLeft)));

/***/ }),

/***/ "./src/components/buttons/button-image-align-right.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-image-align-right.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImageAlignRight class provides functionality for aligning an image on right.
 *
 * @class ButtonImageAlignRight
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonImageAlignRight = function (_React$Component) {
	_inherits(ButtonImageAlignRight, _React$Component);

	function ButtonImageAlignRight() {
		_classCallCheck(this, ButtonImageAlignRight);

		return _possibleConstructorReturn(this, (ButtonImageAlignRight.__proto__ || Object.getPrototypeOf(ButtonImageAlignRight)).apply(this, arguments));
	}

	_createClass(ButtonImageAlignRight, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonImageAlignRight
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonImageAlignRight
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignRight,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-image-align-right',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignRight },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-image-right' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default imageRight
   * @memberof ButtonImageAlignRight
   * @property {String} key
   * @static
   */

	}]);

	return ButtonImageAlignRight;
}(_react2.default.Component);

ButtonImageAlignRight.defaultProps = {
	command: 'justifyright'
};
ButtonImageAlignRight.key = 'imageRight';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonImageAlignRight)));

/***/ }),

/***/ "./src/components/buttons/button-image.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-image.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonImage class inserts an image to the content.
 *
 * @class ButtonImage
 */
var ButtonImage = function (_React$Component) {
	_inherits(ButtonImage, _React$Component);

	function ButtonImage(props) {
		_classCallCheck(this, ButtonImage);

		var _this = _possibleConstructorReturn(this, (ButtonImage.__proto__ || Object.getPrototypeOf(ButtonImage)).call(this, props));

		_this.handleClick = function () {
			_this.fileInput.current.click();
		};

		_this._onInputChange = function () {
			var inputEl = _this.fileInput.current;

			// On IE11 the function might be called with an empty array of
			// files. In such a case, no actions will be taken.
			if (!inputEl.files.length) {
				return;
			}

			var reader = new FileReader();
			var file = inputEl.files[0];

			reader.onload = function (event) {
				var editor = _this.context.editor.get('nativeEditor');

				var result = editor.fire('beforeImageAdd', {
					imageFiles: file
				});

				if (result) {
					var el = CKEDITOR.dom.element.createFromHtml('<img src="' + event.target.result + '">');

					editor.insertElement(el);

					editor.fire('actionPerformed', _this);

					var imageData = {
						el: el,
						file: file
					};

					editor.fire('imageAdd', imageData);
				}
			};

			reader.readAsDataURL(file);

			inputEl.value = '';
		};

		_this.fileInput = _react2.default.createRef();
		return _this;
	}

	/**
  * Lifecycle. Renders the UI of the button.
  *
  * @instance
  * @memberof ButtonImage
  * @method render
  * @return {Object} The content which should be rendered.
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default image
  * @memberof ButtonImage
  * @property {String} key
  * @static
  */


	_createClass(ButtonImage, [{
		key: 'render',
		value: function render() {
			var inputSyle = { display: 'none' };

			return _react2.default.createElement(
				'div',
				null,
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.image,
						className: 'ae-button',
						'data-type': 'button-image',
						onClick: this.handleClick,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.image },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'document-image' })
				),
				_react2.default.createElement('input', {
					accept: 'image/*',
					onChange: this._onInputChange,
					ref: this.fileInput,
					style: inputSyle,
					type: 'file'
				})
			);
		}

		/**
   * Simulates click on the input element. This will open browser's native file open dialog.
   *
   * @instance
   * @memberof ButtonImage
   * @method handleClick
   * @param {SyntheticEvent} event The received click event on the button.
   */


		/**
   * On input change, reads the chosen file and fires an event `beforeImageAdd` with the image which will be added
   * to the content. The image file will be passed in the `imageFiles` property.
   * If any of the listeners returns `false` or cancels the event, the image won't be added to the content.
   * Otherwise, an event `imageAdd` will be fired with the inserted element into the editable area.
   * The passed params will be:
   * - `el` - the created img element
   * - `file` - the original image file from the input element
   *
   * @fires ButtonImage#beforeImageAdd
   * @fires ButtonImage#imageAdd
   * @instance
   * @memberof ButtonImage
   * @method _onInputChange
   * @protected
   */

	}]);

	return ButtonImage;
}(_react2.default.Component);

ButtonImage.contextType = _editorContext2.default;
ButtonImage.key = 'imageFromFile';
exports.default = ButtonImage;

/***/ }),

/***/ "./src/components/buttons/button-indent-block.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-indent-block.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonIndentBlock class provides functionality for indenting the selected blocks.
 *
 * @class ButtonIndentBlock
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonIndentBlock = function (_React$Component) {
	_inherits(ButtonIndentBlock, _React$Component);

	function ButtonIndentBlock() {
		_classCallCheck(this, ButtonIndentBlock);

		return _possibleConstructorReturn(this, (ButtonIndentBlock.__proto__ || Object.getPrototypeOf(ButtonIndentBlock)).apply(this, arguments));
	}

	_createClass(ButtonIndentBlock, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonIndentBlock
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonIndentBlock
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.indent,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-indent-block',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.indent },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'indent-less' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default indentBlock
   * @memberof ButtonIndentBlock
   * @property {String} key
   * @static
   */

	}]);

	return ButtonIndentBlock;
}(_react2.default.Component);

ButtonIndentBlock.defaultProps = {
	command: 'indent'
};
ButtonIndentBlock.key = 'indentBlock';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonIndentBlock)));

/***/ }),

/***/ "./src/components/buttons/button-italic.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-italic.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonItalic class provides functionality for styling an selection with italic (em) style.
 *
 * @class ButtonItalic
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonItalic = function (_React$Component) {
	_inherits(ButtonItalic, _React$Component);

	function ButtonItalic() {
		_classCallCheck(this, ButtonItalic);

		return _possibleConstructorReturn(this, (ButtonItalic.__proto__ || Object.getPrototypeOf(ButtonItalic)).apply(this, arguments));
	}

	_createClass(ButtonItalic, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonItalic
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonItalic
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.italic,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-italic',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.italic },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'italic' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default italic
   * @memberof ButtonItalic
   * @property {String} key
   * @static
   */

	}]);

	return ButtonItalic;
}(_react2.default.Component);

ButtonItalic.defaultProps = {
	command: 'italic',
	keystroke: {
		fn: 'execCommand',
		keys: CKEDITOR.CTRL + 73 /* I*/
	},
	style: 'coreStyles_italic'
};
ButtonItalic.key = 'italic';
exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonItalic))));

/***/ }),

/***/ "./src/components/buttons/button-item-selector-audio.jsx":
/*!***************************************************************!*\
  !*** ./src/components/buttons/button-item-selector-audio.jsx ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class ButtonItemSelectorAudio
 * @uses ButtonCommand
 */
var ButtonItemSelectorAudio = function (_React$Component) {
	_inherits(ButtonItemSelectorAudio, _React$Component);

	function ButtonItemSelectorAudio() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonItemSelectorAudio);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonItemSelectorAudio.__proto__ || Object.getPrototypeOf(ButtonItemSelectorAudio)).call.apply(_ref, [this].concat(args))), _this), _this._handleClick = function () {
			_this.execCommand(null);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(ButtonItemSelectorAudio, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.audio,
					className: 'ae-button',
					'data-type': 'button-audio',
					onClick: this._handleClick,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.audio },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'audio' })
			);
		}
	}]);

	return ButtonItemSelectorAudio;
}(_react2.default.Component);

ButtonItemSelectorAudio.defaultProps = {
	command: 'audioselector'
};
ButtonItemSelectorAudio.key = 'audio';
exports.default = (0, _buttonCommand2.default)(ButtonItemSelectorAudio);

/***/ }),

/***/ "./src/components/buttons/button-item-selector-image.jsx":
/*!***************************************************************!*\
  !*** ./src/components/buttons/button-item-selector-image.jsx ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class ButtonItemSelectorImage
 * @uses ButtonCommand
 */
var ButtonItemSelectorImage = function (_React$Component) {
	_inherits(ButtonItemSelectorImage, _React$Component);

	function ButtonItemSelectorImage() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonItemSelectorImage);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonItemSelectorImage.__proto__ || Object.getPrototypeOf(ButtonItemSelectorImage)).call.apply(_ref, [this].concat(args))), _this), _this._handleClick = function () {
			_this.execCommand(null);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(ButtonItemSelectorImage, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.image,
					className: 'ae-button',
					'data-type': 'button-image',
					onClick: this._handleClick,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.image },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'picture' })
			);
		}
	}]);

	return ButtonItemSelectorImage;
}(_react2.default.Component);

ButtonItemSelectorImage.defaultProps = {
	command: 'imageselector'
};
ButtonItemSelectorImage.key = 'image';
exports.default = (0, _buttonCommand2.default)(ButtonItemSelectorImage);

/***/ }),

/***/ "./src/components/buttons/button-item-selector-video.jsx":
/*!***************************************************************!*\
  !*** ./src/components/buttons/button-item-selector-video.jsx ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class ButtonItemSelectorVideo
 * @uses ButtonCommand
 */
var ButtonItemSelectorVideo = function (_React$Component) {
	_inherits(ButtonItemSelectorVideo, _React$Component);

	function ButtonItemSelectorVideo() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonItemSelectorVideo);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonItemSelectorVideo.__proto__ || Object.getPrototypeOf(ButtonItemSelectorVideo)).call.apply(_ref, [this].concat(args))), _this), _this._handleClick = function () {
			_this.execCommand(null);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(ButtonItemSelectorVideo, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.video,
					className: 'ae-button',
					'data-type': 'button-video',
					onClick: this._handleClick,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.video },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'video' })
			);
		}
	}]);

	return ButtonItemSelectorVideo;
}(_react2.default.Component);

ButtonItemSelectorVideo.defaultProps = {
	command: 'videoselector'
};
ButtonItemSelectorVideo.key = 'video';
exports.default = (0, _buttonCommand2.default)(ButtonItemSelectorVideo);

/***/ }),

/***/ "./src/components/buttons/button-link-autocomplete-list.jsx":
/*!******************************************************************!*\
  !*** ./src/components/buttons/button-link-autocomplete-list.jsx ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLinkAutocompleteList class provides functionality for showing a list of
 * items that can be selected for the link.
 *
 * @class ButtonLinkAutocompleteList
 * @uses WidgetFocusManager
 */
var ButtonLinkAutocompleteList = function (_React$Component) {
	_inherits(ButtonLinkAutocompleteList, _React$Component);

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonLinkAutocompleteList
  * @method getDefaultProps
  * @return {Object} The default properties.
  */
	function ButtonLinkAutocompleteList(props) {
		_classCallCheck(this, ButtonLinkAutocompleteList);

		var _this = _possibleConstructorReturn(this, (ButtonLinkAutocompleteList.__proto__ || Object.getPrototypeOf(ButtonLinkAutocompleteList)).call(this, props));

		_this.state = {
			items: []
		};
		return _this;
	}

	/**
  * Lifecycle. Invoked when a component is receiving new props.
  * This method is not called for the initial render.
  *
  * @instance
  * @memberof ButtonLinkAutocompleteList
  * @method componentWillReceiveProps
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default buttonLinkAutocompleteList
  * @memberof ButtonLinkAutocompleteList
  * @property {String} key
  * @static
  */


	_createClass(ButtonLinkAutocompleteList, [{
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps(nextProps) {
			if (!nextProps.term || nextProps.term !== this.props.term) {
				clearTimeout(this._timeout);

				if (nextProps.term) {
					this._timeout = setTimeout(this._updateItems, this.props.delay);
				} else {
					this.setState({
						items: []
					});
				}
			}

			if (nextProps.autocompleteSelected) {
				setTimeout(this.focus, 0);
				this.props.setAutocompleteState({
					selected: false
				});
			}
		}

		/**
   * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
   *
   * @instance
   * @memberof ButtonLinkAutocompleteList
   * @method componentWillUnmount
   */

	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			clearTimeout(this._timeout);
		}

		/**
   * Lifecycle. Renders the UI of the list.
   *
   * @instance
   * @memberof ButtonLinkAutocompleteList
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			if (!this.props.expanded || !this.state.items.length) {
				return null;
			}

			return _react2.default.createElement(
				_buttonDropdown2.default,
				null,
				this._renderAutocompleteItems(this.state.items)
			);
		}

		/**
   * Lifecycle. Invoked before rendering when new props or state are being received.
   * This method is not called for the initial render or when forceUpdate is used.
   *
   * @instance
   * @memberof ButtonLinkAutocompleteList
   * @method  shouldComponentUpdate
   * @return {Boolean} Returns false when the transition to the new props and state will not
   * require a component update.
   */

	}, {
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps, nextState) {
			return nextProps.expanded !== this.props.expanded || nextProps.term !== this.props.term || nextState.items !== this.state.items;
		}

		/**
   * Renders a set of list items for the provided items
   *
   * @instance
   * @memberof ButtonLinkAutocompleteList
   * @method _renderAutocompleteItems
   * @param {Array} items List of autocomplete items to render
   * @protected
   * @return {Array} Rendered list item instances
   */

	}, {
		key: '_renderAutocompleteItems',
		value: function _renderAutocompleteItems(items) {
			var _this2 = this;

			items = items || [];

			var handleLinkAutocompleteClick = this.props.handleLinkAutocompleteClick;

			return items.map(function (item) {
				var className = _this2.props.term === item.url ? 'ae-toolbar-element active' : 'ae-toolbar-element';

				return _react2.default.createElement(
					'li',
					{ key: item.url, role: 'option' },
					_react2.default.createElement(
						'button',
						{
							className: className,
							onClick: handleLinkAutocompleteClick,
							'data-value': item.url },
						item.title
					)
				);
			});
		}

		/**
   * Retrieves the data according to {this.props.term} and calls setState() with the returned data
   *
   * @instance
   * @memberof ButtonLinkAutocompleteList
   * @method _updateItems
   * @protected
   */

	}, {
		key: '_updateItems',
		value: function _updateItems() {
			var _this3 = this;

			if (!this.props.term) {
				return;
			}

			var promise = Promise.resolve(this.props.data(this.props.term));

			promise.then(function (items) {
				if (items.length && !_this3.props.expanded) {
					_this3.props.toggleDropdown();
				}

				_this3.setState({
					items: items
				});
			});
		}
	}]);

	return ButtonLinkAutocompleteList;
}(_react2.default.Component);

ButtonLinkAutocompleteList.defaultProps = {
	circular: false,
	data: [],
	delay: 100,
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	}
};
ButtonLinkAutocompleteList.key = 'buttonLinkAutocompleteList';
exports.default = (0, _widgetFocusManager2.default)(ButtonLinkAutocompleteList);

/***/ }),

/***/ "./src/components/buttons/button-link-browse.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-link-browse.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonLink = __webpack_require__(/*! ./button-link.jsx */ "./src/components/buttons/button-link.jsx");

var _buttonLink2 = _interopRequireDefault(_buttonLink);

var _buttonLinkEditBrowse = __webpack_require__(/*! ./button-link-edit-browse.jsx */ "./src/components/buttons/button-link-edit-browse.jsx");

var _buttonLinkEditBrowse2 = _interopRequireDefault(_buttonLinkEditBrowse);

var _buttonProps = __webpack_require__(/*! ../base/button-props */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLinkBrowse class provides functionality for changing text color in a document.
 *
 * @uses ButtonKeystroke
 * @uses ButtonProps
 * @uses ButtonStateClasses
 *
 * @class ButtonLinkBrowse
 */
var ButtonLinkBrowse = function (_React$Component) {
	_inherits(ButtonLinkBrowse, _React$Component);

	function ButtonLinkBrowse() {
		_classCallCheck(this, ButtonLinkBrowse);

		return _possibleConstructorReturn(this, (ButtonLinkBrowse.__proto__ || Object.getPrototypeOf(ButtonLinkBrowse)).apply(this, arguments));
	}

	_createClass(ButtonLinkBrowse, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.renderExclusive) {
				this.props = this.mergeButtonCfgProps();

				return _react2.default.createElement(_buttonLinkEditBrowse2.default, this.props);
			} else {
				return _react2.default.createElement(_buttonLink2.default, this.props);
			}
		}

		/**
   * Requests the link button to be rendered in exclusive mode to allow the creation of a link.
   *
   * @protected
   * @method _requestExclusive
   */

	}, {
		key: '_requestExclusive',
		value: function _requestExclusive() {
			this.props.requestExclusive(ButtonLinkBrowse.key);
		}
	}]);

	return ButtonLinkBrowse;
}(_react2.default.Component);

ButtonLinkBrowse.defaultProps = {
	keystroke: {
		fn: '_requestExclusive',
		keys: CKEDITOR.CTRL + 76 /* L*/
	}
};
ButtonLinkBrowse.key = 'linkBrowse';
ButtonLinkBrowse.propTypes = {
	/**
  * The label that should be used for accessibility purposes.
  *
  * @property {String} label
  */
	label: _propTypes2.default.string,

	/**
  * The tabIndex of the button in its toolbar current state. A value other than -1
  * means that the button has focus and is the active element.
  *
  * @property {Number} tabIndex
  */
	tabIndex: _propTypes2.default.number
};
exports.default = (0, _buttonProps2.default)((0, _buttonStateClasses2.default)((0, _buttonKeystroke2.default)(ButtonLinkBrowse)));

/***/ }),

/***/ "./src/components/buttons/button-link-edit-browse.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-link-edit-browse.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonLinkEdit = __webpack_require__(/*! ./button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The LinkEditBrowse class provides functionality for creating and editing a link in a document,
 * and also allows to link to an existing file in DM.
 * Provides UI for creating, editing and removing a link.
 *
 * @class ButtonLinkEditBrowse
 */
var ButtonLinkEditBrowse = function (_React$Component) {
	_inherits(ButtonLinkEditBrowse, _React$Component);

	/**
  *
  * @inheritDoc
  */
	function ButtonLinkEditBrowse(props) {
		_classCallCheck(this, ButtonLinkEditBrowse);

		var _this = _possibleConstructorReturn(this, (ButtonLinkEditBrowse.__proto__ || Object.getPrototypeOf(ButtonLinkEditBrowse)).call(this, props));

		_this._browseClick = function () {
			var editor = _this.context.editor.get('nativeEditor');
			var url = editor.config.documentBrowseLinkUrl;
			var browseLinkCallback = editor.config.documentBrowseLinkCallback;
			var linkTarget = _this.linkEditButtonRef.current ? _this.linkEditButtonRef.current.state.linkTarget : '';

			var changeLinkCallback = function changeLinkCallback(selectedItem) {
				_this._updateLink(selectedItem.value, linkTarget, selectedItem.href);
			};

			if (_lang2.default.isFunction(browseLinkCallback)) {
				browseLinkCallback.apply(null, [editor, url, changeLinkCallback]);
			}
		};

		_this._updateLink = function (linkHref, linkTarget, linkTitle) {
			var editor = _this.context.editor.get('nativeEditor');
			var linkUtils = new CKEDITOR.Link(editor, { appendProtocol: false });
			var linkAttrs = {
				target: linkTarget
			};
			var modifySelection = { advance: true };

			if (linkHref) {
				if (editor.plugins && editor.plugins.creole && !linkTitle) {
					linkHref = location.origin + linkHref;
				}

				if (_this.state.element) {
					linkAttrs.href = linkHref;

					linkUtils.update(linkAttrs, _this.state.element, modifySelection);
				} else {
					linkUtils.create(linkHref, linkAttrs, modifySelection);
				}

				editor.fire('actionPerformed', _this);
			}
		};

		var link = new CKEDITOR.Link(
		// Can't access context from constructor, so get editor from props.
		_this.props.context.editor.get('nativeEditor')).getFromSelection();

		var href = link ? link.getAttribute('href') : '';

		_this.linkEditButtonRef = _react2.default.createRef();

		_this.state = {
			element: link,
			linkHref: href
		};
		return _this;
	}

	/**
  * Lifecycle. Renders the UI of the button.
  *
  * @method render
  * @return {Object} The content which should be rendered.
  */


	_createClass(ButtonLinkEditBrowse, [{
		key: 'render',
		value: function render() {
			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-link-edit-browse' },
				_react2.default.createElement(_buttonLinkEdit2.default, _extends({ ref: this.linkEditButtonRef }, this.props)),
				_react2.default.createElement(
					'button',
					{
						'aria-label': 'Browse',
						className: 'ae-button',
						onClick: this._browseClick,
						title: 'browse' },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'folder' })
				)
			);
		}

		/**
   * Opens an item selector dialog.
   *
   * @protected
   * @method _browseClick
   */


		/**
   * Updates the link in the editor element. If the element didn't exist previously, it will
   * create a new <a> element with the href specified in the link input.
   *
   * @protected
   * @method _updateLink
   * @param {String} linkHref href value for the link
   * @param {String} linkTarget target value for the link
   * @param {String} linkTitle if the link is a title that points to a wiki page (only works for creole)
   */

	}]);

	return ButtonLinkEditBrowse;
}(_react2.default.Component);

ButtonLinkEditBrowse.contextType = _editorContext2.default;
ButtonLinkEditBrowse.key = 'linkEditBrowse';
exports.default = _editorContext2.default.toProps(ButtonLinkEditBrowse);

/***/ }),

/***/ "./src/components/buttons/button-link-edit.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-link-edit.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonProps = __webpack_require__(/*! ../base/button-props */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonLinkAutocompleteList = __webpack_require__(/*! ./button-link-autocomplete-list.jsx */ "./src/components/buttons/button-link-autocomplete-list.jsx");

var _buttonLinkAutocompleteList2 = _interopRequireDefault(_buttonLinkAutocompleteList);

var _buttonLinkTargetEdit = __webpack_require__(/*! ./button-link-target-edit.jsx */ "./src/components/buttons/button-link-target-edit.jsx");

var _buttonLinkTargetEdit2 = _interopRequireDefault(_buttonLinkTargetEdit);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLinkEdit class provides functionality for creating and editing a link in a document.
 * Provides UI for creating, editing and removing a link.
 *
 * @class ButtonLinkEdit
 * @uses ButtonCfgProps
 * @uses WidgetDropdown
 * @uses WidgetFocusManager
 */
var ButtonLinkEdit = function (_React$Component) {
	_inherits(ButtonLinkEdit, _React$Component);

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonLinkEdit
  * @method getDefaultProps
  * @return {Object} The default properties.
  */
	function ButtonLinkEdit(props) {
		_classCallCheck(this, ButtonLinkEdit);

		var _this = _possibleConstructorReturn(this, (ButtonLinkEdit.__proto__ || Object.getPrototypeOf(ButtonLinkEdit)).call(this, props));

		_this._clearLink = function () {
			_this.setState({
				linkHref: ''
			});

			_this._focusLinkInput();
		};

		_this._handleKeyDown = function (event) {
			if (event.keyCode === 13 || event.keyCode === 27) {
				event.preventDefault();
			}

			if (event.keyCode === 13) {
				_this._updateLink();
			} else if (event.keyCode === 40) {
				_this.setState({
					autocompleteSelected: true
				});
			} else if (event.keyCode === 27) {
				var editor = _this.context.editor.get('nativeEditor');

				new CKEDITOR.Link(editor).advanceSelection();

				_this.context.editor.get('nativeEditor').fire('actionPerformed', _this);
			}
		};

		_this._handleLinkHrefChange = function (event) {
			_this.setState({
				linkHref: event.target.value
			});

			_this._focusLinkInput();
		};

		_this._handleLinkTargetChange = function (event) {
			_this.setState({
				itemDropdown: null,
				linkTarget: event.target.getAttribute('data-value')
			});

			_this._focusLinkInput();
		};

		_this._removeLink = function () {
			var editor = _this.context.editor.get('nativeEditor');
			var linkUtils = new CKEDITOR.Link(editor);
			var selection = editor.getSelection();
			var bookmarks = selection.createBookmarks();

			linkUtils.remove(_this.state.element, { advance: true });

			selection.selectBookmarks(bookmarks);

			// We need to cancelExclusive with the bound parameters in case the button is used
			// inside another in exclusive mode (such is the case of the link button)
			_this.props.cancelExclusive();

			editor.fire('actionPerformed', _this);
		};

		_this._updateLink = function () {
			var editor = _this.context.editor.get('nativeEditor');
			var linkUtils = new CKEDITOR.Link(editor, {
				appendProtocol: _this.props.appendProtocol
			});
			var linkAttrs = {
				target: _this.state.linkTarget
			};
			var modifySelection = { advance: true };

			if (_this.state.linkHref) {
				if (_this.state.element) {
					linkAttrs.href = _this.state.linkHref;

					linkUtils.update(linkAttrs, _this.state.element, modifySelection);
				} else {
					linkUtils.create(_this.state.linkHref, linkAttrs, modifySelection);
				}

				editor.fire('actionPerformed', _this);
			}

			// We need to cancelExclusive with the bound parameters in case the button is used
			// inside another in exclusive mode (such is the case of the link button)
			_this.props.cancelExclusive();
		};

		_this.linkInput = _react2.default.createRef();
		_this.state = _this._getInitialState();
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * Focuses on the link input to immediately allow editing. This should only happen if the component
  * is rendered in exclusive mode to prevent aggressive focus stealing.
  *
  * @instance
  * @memberof ButtonLinkEdit
  * @method componentDidMount
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default linkEdit
  * @memberof ButtonLinkEdit
  * @property {String} key
  * @static
  */


	_createClass(ButtonLinkEdit, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			if (this.props.renderExclusive || this.props.manualSelection) {
				// We need to wait for the next rendering cycle before focusing to avoid undesired
				// scrolls on the page
				this._focusLinkInput();
			}
		}

		/**
   * Lifecycle. Invoked when a component is receiving new props.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method componentWillReceiveProps
   */

	}, {
		key: 'componentWillReceiveProps',
		value: function componentWillReceiveProps() {
			this.setState(this._getInitialState());
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var targetSelector = {
				allowedTargets: this.props.allowedTargets,
				editor: this.context.editor,
				handleLinkTargetChange: this._handleLinkTargetChange,
				selectedTarget: this.state.linkTarget || AlloyEditor.Strings.linkTargetDefault
			};

			targetSelector = this.mergeDropdownProps(targetSelector, _buttonLinkTargetEdit2.default.key);

			var autocompleteDropdown = void 0;

			if (this.props.data) {
				var dataFn = this.props.data;

				if (!_lang2.default.isFunction(dataFn)) {
					var items = this.props.data;

					dataFn = function dataFn() {
						return items;
					};
				}

				var autocompleteDropdownProps = {
					autocompleteSelected: this.state.autocompleteSelected,
					data: dataFn,
					editor: this.context.editor,
					handleLinkAutocompleteClick: this._handleLinkAutocompleteClick,
					onDismiss: this.props.toggleDropdown,
					setAutocompleteState: this._setAutocompleteState,
					term: this.state.linkHref
				};

				autocompleteDropdownProps = this.mergeDropdownProps(autocompleteDropdownProps, _buttonLinkAutocompleteList2.default.key);

				autocompleteDropdown = _react2.default.createElement(_buttonLinkAutocompleteList2.default, autocompleteDropdownProps);
			}

			var buttonClearLink = void 0;

			if (this.state.linkHref) {
				buttonClearLink = _react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.clearInput,
						className: 'ae-button ae-button-clear',
						onClick: this._clearLink,
						title: AlloyEditor.Strings.clear },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'times-circle' })
				);
			}

			var placeholderProp = {};

			if (!CKEDITOR.env.ie && AlloyEditor.Strings) {
				placeholderProp.placeholder = AlloyEditor.Strings.editLink;
			}

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-edit-link' },
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.removeLink,
						className: 'ae-button',
						disabled: !this.state.element,
						onClick: this._removeLink,
						title: AlloyEditor.Strings.remove },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'chain-broken' })
				),
				_react2.default.createElement(
					'div',
					{ className: 'ae-container-input xxl' },
					this.props.showTargetSelector && _react2.default.createElement(_buttonLinkTargetEdit2.default, targetSelector),
					_react2.default.createElement(
						'div',
						{ className: 'ae-container-input' },
						_react2.default.createElement('input', _extends({
							className: 'ae-input',
							onChange: this._handleLinkHrefChange,
							onKeyDown: this._handleKeyDown
						}, placeholderProp, {
							ref: this.linkInput,
							type: 'text',
							value: this.state.linkHref
						})),
						autocompleteDropdown
					),
					buttonClearLink
				),
				_react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.confirm,
						className: 'ae-button',
						disabled: !this._isValidState(),
						onClick: this._updateLink,
						title: AlloyEditor.Strings.confirm },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'check', className: 'ae-icon-svg-check' })
				)
			);
		}

		/**
   * The return value will be used as the initial value of this.state.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _getInitialState
   * @protected
   * @return {Object}
   */

	}, {
		key: '_getInitialState',
		value: function _getInitialState() {
			// Can't access context from contructor, so get editor from props.
			var editor = this.props.context.editor;
			var defaultLinkTarget = this.props.defaultLinkTarget;


			var link = new CKEDITOR.Link(editor.get('nativeEditor')).getFromSelection();
			var href = link && link.getAttribute('href') || '';
			var target = link && link.getAttribute('target') || defaultLinkTarget;

			return {
				autocompleteSelected: false,
				element: link,
				initialLink: {
					href: href,
					target: target
				},
				linkHref: href,
				linkTarget: target
			};
		}

		/**
   * Clears the link input. This only changes the component internal state, but does not
   * affect the link element of the editor. Only the _removeLink and _updateLink methods
   * are translated to the editor element.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _clearLink
   * @protected
   */

	}, {
		key: '_focusLinkInput',


		/**
   * Focuses the user cursor on the widget's input.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _focusLinkInput
   * @protected
   */
		value: function _focusLinkInput() {
			var instance = this;

			var focusLinkEl = function focusLinkEl() {
				instance.linkInput.current.focus();
			};

			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(focusLinkEl);
			} else {
				setTimeout(focusLinkEl, 0);
			}
		}

		/**
   * Monitors key interaction inside the input element to respond to the keys:
   * - Enter: Creates/updates the link.
   * - Escape: Discards the changes.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _handleKeyDown
   * @param {SyntheticEvent} event The keyboard event.
   * @protected
   */


		/**
   * Updates the component state when the link input changes on user interaction.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _handleLinkHrefChange
   * @param {SyntheticEvent} event The change event.
   * @protected
   */


		/**
   * Updates the component state when the link target changes on user interaction.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _handleLinkTargetChange
   * @param {SyntheticEvent} event The click event.
   * @protected
   */

	}, {
		key: '_handleLinkAutocompleteClick',


		/**
   * Updates the component state when an autocomplete link result is selected by user interaction.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _handleLinkAutocompleteClick
   * @param {SyntheticEvent} event The click event.
   * @protected
   */
		value: function _handleLinkAutocompleteClick(event) {
			this.setState({
				itemDropdown: null,
				linkHref: event.target.getAttribute('data-value')
			});

			this._focusLinkInput();
		}

		/**
   * Verifies that the current link state is valid so the user can save the link. A valid state
   * means that we have a non-empty href and that either that or the link target are different
   * from the original link.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _isValidState
   * @protected
   * @return {Boolean} [description]
   */

	}, {
		key: '_isValidState',
		value: function _isValidState() {
			var validState = this.state.linkHref && (this.state.linkHref !== this.state.initialLink.href || this.state.linkTarget !== this.state.initialLink.target);

			return validState;
		}

		/**
   * Removes the link in the editor element.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _removeLink
   * @protected
   */

	}, {
		key: '_setAutocompleteState',


		/**
   * Update autocompleteSelected state to focus and select autocomplete´s dropdown
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _setAutocompleteState
   * @protected
   */
		value: function _setAutocompleteState(state) {
			this.setState({
				autocompleteSelected: state.selected
			});
		}

		/**
   * Updates the link in the editor element. If the element didn't exist previously, it will
   * create a new <a> element with the href specified in the link input.
   *
   * @instance
   * @memberof ButtonLinkEdit
   * @method _updateLink
   * @protected
   */

	}]);

	return ButtonLinkEdit;
}(_react2.default.Component);

ButtonLinkEdit.contextType = _editorContext2.default;
ButtonLinkEdit.defaultProps = {
	appendProtocol: true,
	autocompleteUrl: '',
	circular: true,
	customIndexStart: true,
	defaultLinkTarget: '',
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	},
	showTargetSelector: true
};
ButtonLinkEdit.key = 'linkEdit';
exports.default = _editorContext2.default.toProps((0, _buttonProps2.default)((0, _widgetDropdown2.default)((0, _widgetFocusManager2.default)(ButtonLinkEdit))));

/***/ }),

/***/ "./src/components/buttons/button-link-target-edit.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-link-target-edit.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonTargetList = __webpack_require__(/*! ./button-target-list.jsx */ "./src/components/buttons/button-target-list.jsx");

var _buttonTargetList2 = _interopRequireDefault(_buttonTargetList);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLinkTargetEdit class provides functionality for changing the target of a link
 * in the document.
 *
 * @class ButtonLinkTargetEdit
 */
var ButtonLinkTargetEdit = function (_React$Component) {
	_inherits(ButtonLinkTargetEdit, _React$Component);

	function ButtonLinkTargetEdit() {
		_classCallCheck(this, ButtonLinkTargetEdit);

		return _possibleConstructorReturn(this, (ButtonLinkTargetEdit.__proto__ || Object.getPrototypeOf(ButtonLinkTargetEdit)).apply(this, arguments));
	}

	_createClass(ButtonLinkTargetEdit, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonLinkTargetEdit
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var handleLinkTargetChange = this.props.handleLinkTargetChange;
			var allowedLinkTargets = this.props.allowedTargets;

			return _react2.default.createElement(
				'div',
				{
					className: 'ae-container-edit-link-target ae-container-dropdown ae-container-dropdown-medium ae-has-dropdown',
					tabIndex: '0' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': this.props.selectedTarget,
						className: 'ae-toolbar-element',
						onClick: this.props.toggleDropdown,
						role: 'combobox',
						tabIndex: this.props.tabIndex,
						title: this.props.selectedTarget },
					_react2.default.createElement(
						'div',
						{ className: 'ae-container' },
						_react2.default.createElement(
							'span',
							{ className: 'ae-container-dropdown-selected-item' },
							this.props.selectedTarget
						),
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'caret-bottom' })
					)
				),
				this.props.expanded && _react2.default.createElement(_buttonTargetList2.default, {
					onDismiss: this.props.toggleDropdown,
					allowedLinkTargets: allowedLinkTargets,
					handleLinkTargetChange: handleLinkTargetChange,
					selectedTarget: this.props.selectedTarget
				})
			);
		}

		/**
   * Lifecycle. Invoked before rendering when new props or state are being received.
   * This method is not called for the initial render or when forceUpdate is used.
   *
   * @instance
   * @memberof ButtonLinkTargetEdit
   * @method  shouldComponentUpdate
   * @return {Boolean} Returns false when the transition to the new props and state will not
   * require a component update.
   */

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default linkTargetEdit
   * @memberof ButtonLinkTargetEdit
   * @property {String} key
   * @static
   */

	}, {
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps) {
			return nextProps.expanded !== this.props.expanded || nextProps.selectedTarget !== this.props.selectedTarget;
		}
	}]);

	return ButtonLinkTargetEdit;
}(_react2.default.Component);

ButtonLinkTargetEdit.key = 'linkTargetEdit';
exports.default = ButtonLinkTargetEdit;

/***/ }),

/***/ "./src/components/buttons/button-link.jsx":
/*!************************************************!*\
  !*** ./src/components/buttons/button-link.jsx ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonProps = __webpack_require__(/*! ../base/button-props */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonLinkEdit = __webpack_require__(/*! ./button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonLink class provides functionality for creating and editing a link in a document. ButtonLink
 * renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonLinkEdit UI with all the link edition controls.
 *
 * @class ButtonLink
 * @uses ButtonCfgProps
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 */
var ButtonLink = function (_React$Component) {
	_inherits(ButtonLink, _React$Component);

	function ButtonLink() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonLink);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonLink.__proto__ || Object.getPrototypeOf(ButtonLink)).call.apply(_ref, [this].concat(args))), _this), _this._requestExclusive = function () {
			_this.props.requestExclusive(ButtonLink.key);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonLink
  * @method getDefaultProps
  * @return {Object} The default properties.
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default link
  * @memberof ButtonLink
  * @property {String} key
  * @static
  */


	_createClass(ButtonLink, [{
		key: 'isActive',


		/**
   * Checks if the current selection is contained within a link.
   *
   * @instance
   * @memberof ButtonLink
   * @method isActive
   * @return {Boolean} True if the selection is inside a link, false otherwise.
   */
		value: function isActive() {
			return new CKEDITOR.Link(this.context.editor.get('nativeEditor')).getFromSelection() !== null;
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonLink
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			if (this.props.renderExclusive) {
				var props = this.mergeButtonCfgProps();

				return _react2.default.createElement(_buttonLinkEdit2.default, props);
			} else {
				return _react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.link,
						className: cssClass,
						'data-type': 'button-link',
						onClick: this._requestExclusive,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.link },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'link' })
				);
			}
		}

		/**
   * Requests the link button to be rendered in exclusive mode to allow the creation of a link.
   *
   * @instance
   * @memberof ButtonLink
   * @method _requestExclusive
   * @protected
   */

	}]);

	return ButtonLink;
}(_react2.default.Component);

ButtonLink.contextType = _editorContext2.default;
ButtonLink.defaultProps = {
	keystroke: {
		fn: '_requestExclusive',
		keys: CKEDITOR.CTRL + 76 /* L*/
	}
};
ButtonLink.key = 'link';
exports.default = (0, _buttonProps2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)(ButtonLink)));

/***/ }),

/***/ "./src/components/buttons/button-ol.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-ol.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonOrderedList class provides functionality for creating ordered lists in an editor.
 *
 * @class ButtonOrderedList
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonOrderedList = function (_React$Component) {
	_inherits(ButtonOrderedList, _React$Component);

	function ButtonOrderedList() {
		_classCallCheck(this, ButtonOrderedList);

		return _possibleConstructorReturn(this, (ButtonOrderedList.__proto__ || Object.getPrototypeOf(ButtonOrderedList)).apply(this, arguments));
	}

	_createClass(ButtonOrderedList, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonOrderedList
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonOrderedList
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.numberedlist,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-ol',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.numberedlist },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'list-ol' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default ol
   * @memberof ButtonOrderedList
   * @property {String} key
   * @static
   */

	}]);

	return ButtonOrderedList;
}(_react2.default.Component);

ButtonOrderedList.defaultProps = {
	command: 'numberedlist',
	style: {
		element: 'ol'
	}
};
ButtonOrderedList.key = 'ol';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonOrderedList)));

/***/ }),

/***/ "./src/components/buttons/button-outdent-block.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-outdent-block.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonOutdentBlock class provides functionality for outdenting blocks.
 *
 * @class ButtonOutdentBlock
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonOutdentBlock = function (_React$Component) {
	_inherits(ButtonOutdentBlock, _React$Component);

	function ButtonOutdentBlock() {
		_classCallCheck(this, ButtonOutdentBlock);

		return _possibleConstructorReturn(this, (ButtonOutdentBlock.__proto__ || Object.getPrototypeOf(ButtonOutdentBlock)).apply(this, arguments));
	}

	_createClass(ButtonOutdentBlock, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonOutdentBlock
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonOutdentBlock
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.outdent,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-outdent-block',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.outdent },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'indent-more' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default outdentBlock
   * @memberof ButtonOutdentBlock
   * @property {String} key
   * @static
   */

	}]);

	return ButtonOutdentBlock;
}(_react2.default.Component);

ButtonOutdentBlock.defaultProps = {
	command: 'outdent'
};
ButtonOutdentBlock.key = 'outdentBlock';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonOutdentBlock)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-align-left.jsx":
/*!****************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-align-left.jsx ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphAlignLeft class provides functionality for aligning a paragraph on left.
 *
 * @class ButtonParagraphAlignLeft
 *
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphAlignLeft = function (_React$Component) {
	_inherits(ButtonParagraphAlignLeft, _React$Component);

	function ButtonParagraphAlignLeft() {
		_classCallCheck(this, ButtonParagraphAlignLeft);

		return _possibleConstructorReturn(this, (ButtonParagraphAlignLeft.__proto__ || Object.getPrototypeOf(ButtonParagraphAlignLeft)).apply(this, arguments));
	}

	_createClass(ButtonParagraphAlignLeft, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonParagraphAlignLeft
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonParagraphAlignLeft
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignLeft,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-paragraph-align-left',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignLeft },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-left' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default paragraphLeft
   * @memberof ButtonParagraphAlignLeft
   * @property {String} key
   * @static
   */

	}]);

	return ButtonParagraphAlignLeft;
}(_react2.default.Component);

ButtonParagraphAlignLeft.defaultProps = {
	command: 'justifyleft'
};
ButtonParagraphAlignLeft.key = 'paragraphLeft';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphAlignLeft)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-align-right.jsx":
/*!*****************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-align-right.jsx ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphAlignRight class provides functionality for aligning a paragraph on right.
 *
 * @class ButtonParagraphAlignRight
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphAlignRight = function (_React$Component) {
	_inherits(ButtonParagraphAlignRight, _React$Component);

	function ButtonParagraphAlignRight() {
		_classCallCheck(this, ButtonParagraphAlignRight);

		return _possibleConstructorReturn(this, (ButtonParagraphAlignRight.__proto__ || Object.getPrototypeOf(ButtonParagraphAlignRight)).apply(this, arguments));
	}

	_createClass(ButtonParagraphAlignRight, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonParagraphAlignRight
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonParagraphAlignRight
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignRight,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-paragraph-align-right',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignRight },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-right' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default paragraphRight
   * @memberof ButtonParagraphAlignRight
   * @property {String} key
   * @static
   */

	}]);

	return ButtonParagraphAlignRight;
}(_react2.default.Component);

ButtonParagraphAlignRight.defaultProps = {
	command: 'justifyright'
};
ButtonParagraphAlignRight.key = 'paragraphRight';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphAlignRight)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-align.jsx":
/*!***********************************************************!*\
  !*** ./src/components/buttons/button-paragraph-align.jsx ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphAlign class provides functionality to work with table rows.
 *
 * @class ButtonParagraphAlign
 */
var ButtonParagraphAlign = function (_React$Component) {
	_inherits(ButtonParagraphAlign, _React$Component);

	function ButtonParagraphAlign() {
		_classCallCheck(this, ButtonParagraphAlign);

		return _possibleConstructorReturn(this, (ButtonParagraphAlign.__proto__ || Object.getPrototypeOf(ButtonParagraphAlign)).apply(this, arguments));
	}

	_createClass(ButtonParagraphAlign, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonParagraphAlign
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var buttonCommandsList = void 0;
			var buttonCommandsListId = void 0;

			if (this.props.expanded) {
				buttonCommandsListId = ButtonParagraphAlign.key + 'List';
				buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, {
					commands: this._getCommands(),
					listId: buttonCommandsListId,
					inlineIcons: false,
					onDismiss: this.props.toggleDropdown
				});
			}

			var editor = this.context.editor.get('nativeEditor');

			var activeCommand = this._getCommands().filter(function (alignment) {
				var command = editor.getCommand(alignment.command);

				return command ? command.state === CKEDITOR.TRISTATE_ON : false;
			}).pop();

			var iconClassName = activeCommand.icon;

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-dropdown ae-container-dropdown-xsmall ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': activeCommand.label,
						'aria-owns': buttonCommandsListId,
						className: 'ae-toolbar-element',
						onClick: this.props.toggleDropdown,
						role: 'combobox',
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.row },
					_react2.default.createElement(
						'div',
						{ className: 'ae-container' },
						_react2.default.createElement(_buttonIcon2.default, { symbol: iconClassName }),
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'caret-bottom' })
					)
				),
				buttonCommandsList
			);
		}

		/**
   * Returns a list of commands. If a list of commands was passed
   * as property `commands`, it will take a precedence over the default ones.
   *
   * @instance
   * @memberof ButtonParagraphAlign
   * @method _getCommands
   * @protected
   * @return {Array} The list of available commands.
   */

	}, {
		key: '_getCommands',
		value: function _getCommands() {
			return this.props.commands || [{
				command: 'justifyleft',
				icon: 'align-left',
				label: AlloyEditor.Strings.alignLeft
			}, {
				command: 'justifycenter',
				icon: 'align-center',
				label: AlloyEditor.Strings.alignCenter
			}, {
				command: 'justifyright',
				icon: 'align-right',
				label: AlloyEditor.Strings.alignRight
			}, {
				command: 'justifyblock',
				icon: 'align-justify',
				label: AlloyEditor.Strings.alignJustify
			}];
		}
	}]);

	return ButtonParagraphAlign;
}(_react2.default.Component);

ButtonParagraphAlign.contextType = _editorContext2.default;
ButtonParagraphAlign.key = 'paragraphAlign';
exports.default = ButtonParagraphAlign;

/***/ }),

/***/ "./src/components/buttons/button-paragraph-center.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-center.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphCenter class provides functionality for centering a paragraph.
 *
 * @class ButtonParagraphCenter
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphCenter = function (_React$Component) {
	_inherits(ButtonParagraphCenter, _React$Component);

	function ButtonParagraphCenter() {
		_classCallCheck(this, ButtonParagraphCenter);

		return _possibleConstructorReturn(this, (ButtonParagraphCenter.__proto__ || Object.getPrototypeOf(ButtonParagraphCenter)).apply(this, arguments));
	}

	_createClass(ButtonParagraphCenter, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonParagraphCenter
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonParagraphCenter
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignCenter,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-paragraph-center',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignCenter },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-center' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default paragraphCenter
   * @memberof ButtonParagraphCenter
   * @property {String} key
   * @static
   */

	}]);

	return ButtonParagraphCenter;
}(_react2.default.Component);

ButtonParagraphCenter.defaultProps = {
	command: 'justifycenter'
};
ButtonParagraphCenter.key = 'paragraphCenter';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphCenter)));

/***/ }),

/***/ "./src/components/buttons/button-paragraph-justify.jsx":
/*!*************************************************************!*\
  !*** ./src/components/buttons/button-paragraph-justify.jsx ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonCommandActive = __webpack_require__(/*! ../base/button-command-active */ "./src/components/base/button-command-active.js");

var _buttonCommandActive2 = _interopRequireDefault(_buttonCommandActive);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonParagraphJustify class provides functionality for justfying a paragraph.
 *
 * @class ButtonParagraphJustify
 * @uses ButtonCommand
 * @uses ButtonCommandActive
 * @uses ButtonStateClasses
 */
var ButtonParagraphJustify = function (_React$Component) {
	_inherits(ButtonParagraphJustify, _React$Component);

	function ButtonParagraphJustify() {
		_classCallCheck(this, ButtonParagraphJustify);

		return _possibleConstructorReturn(this, (ButtonParagraphJustify.__proto__ || Object.getPrototypeOf(ButtonParagraphJustify)).apply(this, arguments));
	}

	_createClass(ButtonParagraphJustify, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonParagraphJustify
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonParagraphJustify
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.alignJustify,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-paragraph-justify',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.alignJustify },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'align-justify' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default paragraphJustify
   * @memberof ButtonParagraphJustify
   * @property {String} key
   * @static
   */

	}]);

	return ButtonParagraphJustify;
}(_react2.default.Component);

ButtonParagraphJustify.defaultProps = {
	command: 'justifyblock'
};
ButtonParagraphJustify.key = 'paragraphJustify';
exports.default = (0, _buttonCommand2.default)((0, _buttonCommandActive2.default)((0, _buttonStateClasses2.default)(ButtonParagraphJustify)));

/***/ }),

/***/ "./src/components/buttons/button-quote.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-quote.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonQuote class wraps a selection in `blockquote` element.
 *
 * @class ButtonQuote
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonQuote = function (_React$Component) {
	_inherits(ButtonQuote, _React$Component);

	function ButtonQuote() {
		_classCallCheck(this, ButtonQuote);

		return _possibleConstructorReturn(this, (ButtonQuote.__proto__ || Object.getPrototypeOf(ButtonQuote)).apply(this, arguments));
	}

	_createClass(ButtonQuote, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonQuote
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonQuote
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.quote,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-quote',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.quote },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'quote-right' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default quote
   * @memberof ButtonQuote
   * @property {String} key
   * @static
   */

	}]);

	return ButtonQuote;
}(_react2.default.Component);

ButtonQuote.defaultProps = {
	command: 'blockquote',
	style: {
		element: 'blockquote'
	}
};
ButtonQuote.key = 'quote';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonQuote)));

/***/ }),

/***/ "./src/components/buttons/button-remove-format.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-remove-format.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonRemoveFormat class removes style formatting.
 *
 * @class ButtonRemoveFormat
 * @uses ButtonCommand
 */
var ButtonRemoveFormat = function (_React$Component) {
	_inherits(ButtonRemoveFormat, _React$Component);

	function ButtonRemoveFormat() {
		_classCallCheck(this, ButtonRemoveFormat);

		return _possibleConstructorReturn(this, (ButtonRemoveFormat.__proto__ || Object.getPrototypeOf(ButtonRemoveFormat)).apply(this, arguments));
	}

	_createClass(ButtonRemoveFormat, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonRemoveFormat
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonRemoveFormat
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.removeformat,
					className: 'ae-button',
					'data-type': 'button-removeformat',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.removeformat },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'remove-style' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default removeFormat
   * @memberof ButtonRemoveFormat
   * @property {String} key
   * @static
   */

	}]);

	return ButtonRemoveFormat;
}(_react2.default.Component);

ButtonRemoveFormat.defaultProps = {
	command: 'removeFormat'
};
ButtonRemoveFormat.key = 'removeFormat';
exports.default = (0, _buttonCommand2.default)(ButtonRemoveFormat);

/***/ }),

/***/ "./src/components/buttons/button-remove-image.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-remove-image.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command.js */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes.js */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonRemoveImage class removes an image using a CKEDITOR.command.
 *
 * @class ButtonRemoveImage
 * @uses ButtonCommand
 */
var ButtonRemoveImage = function (_React$Component) {
	_inherits(ButtonRemoveImage, _React$Component);

	function ButtonRemoveImage() {
		_classCallCheck(this, ButtonRemoveImage);

		return _possibleConstructorReturn(this, (ButtonRemoveImage.__proto__ || Object.getPrototypeOf(ButtonRemoveImage)).apply(this, arguments));
	}

	_createClass(ButtonRemoveImage, [{
		key: 'render',


		/**
   * @inheritDoc
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.removeImage,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					onClick: this.execCommand,
					title: AlloyEditor.Strings.removeImage },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'times-circle' })
			);
		}
	}]);

	return ButtonRemoveImage;
}(_react2.default.Component);

ButtonRemoveImage.defaultProps = {
	command: 'removeImage'
};
ButtonRemoveImage.key = 'removeImage';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)(ButtonRemoveImage));

/***/ }),

/***/ "./src/components/buttons/button-separator.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-separator.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The ButtonSeparator function renders a simple separator.
 */
function ButtonSeparator(_props) {
  return _react2.default.createElement('span', { className: 'ae-separator' });
}

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default separator
 * @memberof ButtonSeparator
 * @property {String} key
 * @static
 */
ButtonSeparator.key = 'separator';

exports.default = ButtonSeparator;

/***/ }),

/***/ "./src/components/buttons/button-spacing.jsx":
/*!***************************************************!*\
  !*** ./src/components/buttons/button-spacing.jsx ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonProps = __webpack_require__(/*! ../base/button-props */ "./src/components/base/button-props.js");

var _buttonProps2 = _interopRequireDefault(_buttonProps);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonSpacing class provides functionality for changing text color in a document.
 *
 * @uses ButtonProps
 * @uses ButtonStateClasses
 *
 * @class ButtonSpacing
 */
var ButtonSpacing = function (_React$Component) {
	_inherits(ButtonSpacing, _React$Component);

	function ButtonSpacing() {
		_classCallCheck(this, ButtonSpacing);

		return _possibleConstructorReturn(this, (ButtonSpacing.__proto__ || Object.getPrototypeOf(ButtonSpacing)).apply(this, arguments));
	}

	_createClass(ButtonSpacing, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var _this2 = this;

			var activeSpacing = '1.0x';

			var spacings = this._getSpacings();

			spacings.forEach(function (item) {
				if (_this2._checkActive(item.style)) {
					activeSpacing = item.name;
				}
			});

			var _props = this.props,
			    editor = _props.editor,
			    expanded = _props.expanded,
			    tabIndex = _props.tabIndex,
			    toggleDropdown = _props.toggleDropdown;


			var buttonStylesProps = {
				activeStyle: activeSpacing,
				editor: editor,
				onDismiss: toggleDropdown,
				showRemoveStylesItem: false,
				styles: spacings
			};

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-container-dropdown-small ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': expanded,
						className: 'ae-toolbar-element',
						onClick: toggleDropdown,
						role: 'combobox',
						tabIndex: tabIndex },
					_react2.default.createElement(
						'span',
						null,
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'separator' }),
						'\xA0',
						activeSpacing
					)
				),
				expanded && _react2.default.createElement(_buttonStylesList2.default, buttonStylesProps)
			);
		}
	}, {
		key: '_applyStyle',
		value: function _applyStyle(className) {
			var _this3 = this;

			var editor = this.context.editor.get('nativeEditor');

			var styleConfig = {
				element: 'div',
				attributes: {
					class: className
				}
			};

			var style = new CKEDITOR.style(styleConfig);

			editor.getSelection().lock();

			this._getSpacings().forEach(function (item) {
				if (_this3._checkActive(item.style)) {
					editor.removeStyle(new CKEDITOR.style(item.style));
				}
			});

			editor.applyStyle(style);

			editor.getSelection().unlock();

			editor.fire('actionPerformed', this);
		}

		/**
   * Checks if the given spacing definition is applied to the current selection in the editor.
   *
   * @instance
   * @memberof Spacing
   * @method _checkActive
   * @param {Object} styleConfig Spacing definition as per http://docs.ckeditor.com/#!/api/CKEDITOR.style.
   * @protected
   * @return {Boolean} Returns true if the spacing is applied to the selection, false otherwise.
   */

	}, {
		key: '_checkActive',
		value: function _checkActive(styleConfig) {
			var nativeEditor = this.context.editor.get('nativeEditor');

			var active = true;

			var elementPath = nativeEditor.elementPath();

			if (elementPath && elementPath.lastElement) {
				styleConfig.attributes.class.split(' ').forEach(function (className) {
					active = active && elementPath.lastElement.hasClass(className);
				});
			} else {
				active = false;
			}

			return active;
		}

		/**
   * Returns an array of spacings. Each spacing consists from three properties:
   * - name - the style name, for example "default"
   * - style - an object with one property, called `element` which value
   * represents the style which have to be applied to the element.
   * - styleFn - a function which applies selected style to the editor selection
   *
   * @instance
   * @memberof Spacing
   * @method _getSpacings
   * @protected
   * @return {Array<object>} An array of objects containing the spacings.
   */

	}, {
		key: '_getSpacings',
		value: function _getSpacings() {
			return this.props.styles || [{
				name: '1.0x',
				style: {
					element: 'div',
					attributes: {
						class: ''
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, '')
			}, {
				name: '1.5x',
				style: {
					element: 'div',
					attributes: {
						class: 'mt-1 mb-1'
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, 'mt-1 mb-1')
			}, {
				name: '2.0x',
				style: {
					element: 'div',
					attributes: {
						class: 'mt-2 mb-2'
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, 'mt-2 mb-2')
			}, {
				name: '3.0x',
				style: {
					element: 'div',
					attributes: {
						class: 'mt-3 mb-3'
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, 'mt-3 mb-3')
			}, {
				name: '4.0x',
				style: {
					element: 'div',
					attributes: {
						class: 'mt-4 mb-4'
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, 'mt-4 mb-4')
			}, {
				name: '5.0x',
				style: {
					element: 'div',
					attributes: {
						class: 'mt-5 mb-5'
					},
					type: 1
				},
				styleFn: this._applyStyle.bind(this, 'mt-5 mb-5')
			}];
		}
	}]);

	return ButtonSpacing;
}(_react2.default.Component);

ButtonSpacing.key = 'spacing';
ButtonSpacing.propTypes = {
	/**
  * Indicates whether the styles list is expanded or not.
  *
  * @instance
  * @memberof Spacing
  * @property {Boolean} expanded
  */
	expanded: _propTypes2.default.bool,

	/**
  * The label that should be used for accessibility purposes.
  *
  * @instance
  * @memberof Spacing
  * @property {String} label
  */
	label: _propTypes2.default.string,

	/**
  * Indicates whether the remove styles item should appear in the styles list.
  *
  * @instance
  * @memberof Spacing
  * @property {Boolean} showRemoveStylesItem
  */
	showRemoveStylesItem: _propTypes2.default.bool,

	/**
  * List of the styles the button is able to handle.
  *
  * @instance
  * @memberof Spacing
  * @property {Array} styles
  */
	styles: _propTypes2.default.arrayOf(_propTypes2.default.object),

	/**
  * The tabIndex of the button in its toolbar current state. A value other than -1
  * means that the button has focus and is the active element.
  *
  * @instance
  * @memberof Spacing
  * @property {Number} tabIndex
  */
	tabIndex: _propTypes2.default.number,

	/**
  * Callback provided by the button host to notify when the styles list has been expanded.
  *
  * @instance
  * @memberof Spacing
  * @property {Function} toggleDropdown
  */
	toggleDropdown: _propTypes2.default.func
};
exports.default = (0, _buttonProps2.default)((0, _buttonStateClasses2.default)(ButtonSpacing));

/***/ }),

/***/ "./src/components/buttons/button-strike.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-strike.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStrike class styles a selection with strike style.
 *
 * @class ButtonStrike
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonStrike = function (_React$Component) {
	_inherits(ButtonStrike, _React$Component);

	function ButtonStrike() {
		_classCallCheck(this, ButtonStrike);

		return _possibleConstructorReturn(this, (ButtonStrike.__proto__ || Object.getPrototypeOf(ButtonStrike)).apply(this, arguments));
	}

	_createClass(ButtonStrike, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   * @instance
   * @memberof ButtonStrike
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonStrike
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.strike,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-strike',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.strike },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'strikethrough' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default strike
   * @memberof ButtonStrike
   * @property {String} key
   * @static
   */

	}]);

	return ButtonStrike;
}(_react2.default.Component);

ButtonStrike.defaultProps = {
	command: 'strike',
	style: 'coreStyles_strike'
};
ButtonStrike.key = 'strike';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonStrike)));

/***/ }),

/***/ "./src/components/buttons/button-styles-list-header.jsx":
/*!**************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-header.jsx ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonsStylesListHeader class provides the header of an list of style items.
 *
 * @class ButtonsStylesListHeader
 */
var ButtonsStylesListHeader = function (_React$Component) {
	_inherits(ButtonsStylesListHeader, _React$Component);

	function ButtonsStylesListHeader() {
		_classCallCheck(this, ButtonsStylesListHeader);

		return _possibleConstructorReturn(this, (ButtonsStylesListHeader.__proto__ || Object.getPrototypeOf(ButtonsStylesListHeader)).apply(this, arguments));
	}

	_createClass(ButtonsStylesListHeader, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonsStylesListHeader
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.styles && this.props.styles.length) {
				return _react2.default.createElement(
					'span',
					{ className: 'ae-list-header' },
					this.props.name
				);
			} else {
				return null;
			}
		}
	}]);

	return ButtonsStylesListHeader;
}(_react2.default.Component);

ButtonsStylesListHeader.key = 'buttonStylesListHeader';
exports.default = ButtonsStylesListHeader;

/***/ }),

/***/ "./src/components/buttons/button-styles-list-item-remove.jsx":
/*!*******************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-item-remove.jsx ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStylesListItemRemove class provides functionality for previewing a style definition
 * inside a list and applying it to the current editor selection.
 *
 * @class ButtonStylesListItemRemove
 */
var ButtonStylesListItemRemove = function (_React$Component) {
	_inherits(ButtonStylesListItemRemove, _React$Component);

	function ButtonStylesListItemRemove() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonStylesListItemRemove);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonStylesListItemRemove.__proto__ || Object.getPrototypeOf(ButtonStylesListItemRemove)).call.apply(_ref, [this].concat(args))), _this), _this._removeStyles = function () {
			var editor = _this.context.editor.get('nativeEditor');

			editor.execCommand('removeFormat');

			_this.props.removeBlocks.forEach(function (blockItem) {
				var blockStyle = new CKEDITOR.style({ element: blockItem });

				editor.removeStyle(blockStyle);
			});

			editor.fire('actionPerformed', _this);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonStylesListItemRemove
  * @method getDefaultProps
  * @return {Object} The default properties.
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default buttonStylesListItemRemove
  * @memberof ButtonStylesListItemRemove
  * @property {String} key
  * @static
  */


	_createClass(ButtonStylesListItemRemove, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonStylesListItemRemove
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			return _react2.default.createElement(
				'li',
				{ role: 'option' },
				_react2.default.createElement(
					'button',
					{
						className: 'ae-toolbar-element',
						onClick: this._removeStyles,
						tabIndex: this.props.tabIndex },
					AlloyEditor.Strings.normal
				)
			);
		}

		/**
   * Removes all inline styles and configured block elements applied to the current selection.
   *
   * @instance
   * @memberof ButtonStylesListItemRemove
   * @method _removeStyles
   * @protected
   */

	}]);

	return ButtonStylesListItemRemove;
}(_react2.default.Component);

ButtonStylesListItemRemove.contextType = _editorContext2.default;
ButtonStylesListItemRemove.defaultProps = {
	removeBlocks: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'pre']
};
ButtonStylesListItemRemove.key = 'buttonStylesListItemRemove';
exports.default = ButtonStylesListItemRemove;

/***/ }),

/***/ "./src/components/buttons/button-styles-list-item.jsx":
/*!************************************************************!*\
  !*** ./src/components/buttons/button-styles-list-item.jsx ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonActionStyle = __webpack_require__(/*! ../base/button-action-style */ "./src/components/base/button-action-style.js");

var _buttonActionStyle2 = _interopRequireDefault(_buttonActionStyle);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStylesListItem class provides functionality for previewing a style definition
 * inside a list and applying it to the current editor selection.
 *
 * @class ButtonStylesListItem
 * @uses ButtonActionStyle
 * @uses ButtonStyle
 */
var ButtonStylesListItem = function (_React$Component) {
	_inherits(ButtonStylesListItem, _React$Component);

	function ButtonStylesListItem() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonStylesListItem);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonStylesListItem.__proto__ || Object.getPrototypeOf(ButtonStylesListItem)).call.apply(_ref, [this].concat(args))), _this), _this._onClick = function () {
			if (_this.props.styleFn) {
				_this.props.styleFn();
			} else {
				// Typically, we want the style to be the only one applied to the current selection, so
				// we execute the 'removeFormat' command first. Note that block styles won't be cleaned.
				// However, this is consistent with other editors implementations of this feature.
				_this.context.editor.get('nativeEditor').execCommand('removeFormat');

				_this.applyStyle();
			}
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default buttonStylesListItem
  * @memberof ButtonStylesListItem
  * @property {String} key
  * @static
  */


	_createClass(ButtonStylesListItem, [{
		key: 'componentWillMount',


		/**
   * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
   *
   * @instance
   * @memberof ButtonStylesListItem
   * @method componentWillMount
   */
		value: function componentWillMount() {
			// Styles with wildcard element (*) generate an empty tag in their preview < class="custom-class" />.
			// We default to element span and remove the margins to obtain a more consistent set of previews.
			var styleCfg = {
				element: 'span',
				styles: {
					margin: 0
				}
			};

			styleCfg = CKEDITOR.tools.merge(styleCfg, this.props.style);

			this._preview = new CKEDITOR.style(styleCfg).buildPreview(this.props.name);
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonStylesListItem
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			// We need to use dangerouselySetInnterHTML since we're not in control of the style
			// preview that is generated by CKEditor.
			var className = this.props.name === this.props.activeStyle ? 'ae-toolbar-element active' : 'ae-toolbar-element';

			return _react2.default.createElement('button', {
				className: className,
				dangerouslySetInnerHTML: { __html: this._preview },
				onClick: this._onClick,
				tabIndex: this.props.tabIndex
			});
		}

		/**
   * Applies the item style to the editor selection.
   *
   * @instance
   * @memberof ButtonStylesListItem
   * @method _onClick
   * @protected
   */

	}]);

	return ButtonStylesListItem;
}(_react2.default.Component);

ButtonStylesListItem.contextType = _editorContext2.default;
ButtonStylesListItem.key = 'buttonStylesListItem';
exports.default = (0, _buttonActionStyle2.default)((0, _buttonStyle2.default)(ButtonStylesListItem));

/***/ }),

/***/ "./src/components/buttons/button-styles-list.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-styles-list.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _buttonStylesListItem = __webpack_require__(/*! ./button-styles-list-item.jsx */ "./src/components/buttons/button-styles-list-item.jsx");

var _buttonStylesListItem2 = _interopRequireDefault(_buttonStylesListItem);

var _buttonStylesListItemRemove = __webpack_require__(/*! ./button-styles-list-item-remove.jsx */ "./src/components/buttons/button-styles-list-item-remove.jsx");

var _buttonStylesListItemRemove2 = _interopRequireDefault(_buttonStylesListItemRemove);

var _buttonStylesListHeader = __webpack_require__(/*! ./button-styles-list-header.jsx */ "./src/components/buttons/button-styles-list-header.jsx");

var _buttonStylesListHeader2 = _interopRequireDefault(_buttonStylesListHeader);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStylesList class provides functionality for showing a list of styles that can be
 * applied to the current selection..
 *
 * @class ButtonStylesList
 * @uses WidgetFocusManager
 */
var ButtonStylesList = function (_React$Component) {
	_inherits(ButtonStylesList, _React$Component);

	function ButtonStylesList() {
		_classCallCheck(this, ButtonStylesList);

		return _possibleConstructorReturn(this, (ButtonStylesList.__proto__ || Object.getPrototypeOf(ButtonStylesList)).apply(this, arguments));
	}

	_createClass(ButtonStylesList, [{
		key: 'componentDidMount',


		/**
   * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
   *
   * Focuses on the list node to allow keyboard interaction.
   *
   * @instance
   * @memberof ButtonStylesList
   * @method componentDidMount
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonStylesList
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function componentDidMount() {
			_reactDom2.default.findDOMNode(this).focus();
		}

		/**
   * Lifecycle. Invoked once, both on the client and server, immediately before the initial rendering occurs.
   *
   * @instance
   * @memberof ButtonStylesList
   * @method componentWillMount
   */


		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @memberof ButtonStylesList
   * @static
   * @property {String} key
   * @default buttonStylesList
   */

	}, {
		key: 'componentWillMount',
		value: function componentWillMount() {
			var blockStyles = [];
			var inlineStyles = [];
			var objectStyles = [];

			this.props.styles.forEach(function (item) {
				var style = new CKEDITOR.style(item.style);

				if (style.type === CKEDITOR.STYLE_BLOCK) {
					blockStyles.push(item);
				} else if (style.type === CKEDITOR.STYLE_INLINE) {
					inlineStyles.push(item);
				} else if (style.type === CKEDITOR.STYLE_OBJECT) {
					objectStyles.push(item);
				}
			});

			this._blockStyles = blockStyles;
			this._inlineStyles = inlineStyles;
			this._objectStyles = objectStyles;
		}

		/**
   * Lifecycle. Renders the UI of the list.
   *
   * @instance
   * @memberof ButtonStylesList
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var removeStylesItem = void 0;

			if (this.props.showRemoveStylesItem) {
				removeStylesItem = _react2.default.createElement(_buttonStylesListItemRemove2.default, {
					onDismiss: this.props.toggleDropdown
				});
			}

			return _react2.default.createElement(
				_buttonDropdown2.default,
				this.props,
				removeStylesItem,
				_react2.default.createElement(_buttonStylesListHeader2.default, {
					name: AlloyEditor.Strings.blockStyles,
					styles: this._blockStyles
				}),
				this._renderStylesItems(this._blockStyles),
				_react2.default.createElement(_buttonStylesListHeader2.default, {
					name: AlloyEditor.Strings.inlineStyles,
					styles: this._inlineStyles
				}),
				this._renderStylesItems(this._inlineStyles),
				_react2.default.createElement(_buttonStylesListHeader2.default, {
					name: AlloyEditor.Strings.objectStyles,
					styles: this._objectStyles
				}),
				this._renderStylesItems(this._objectStyles)
			);
		}

		/**
   * Renders instances of ButtonStylesListItem with the preview of the correspondent block, inline or object styles.
   *
   * @instance
   * @memberof ButtonStylesList
   * @method _renderStylesItems
   * @param {Array} styles List of styles for which preview should be rendered.
   * @protected
   * @return {Array} Rendered instances of ButtonStylesListItem class
   */

	}, {
		key: '_renderStylesItems',
		value: function _renderStylesItems(styles) {
			var _this2 = this;

			var items = void 0;

			if (styles && styles.length) {
				items = styles.map(function (item) {
					return _react2.default.createElement(
						'li',
						{ key: item.name, role: 'option' },
						_react2.default.createElement(_buttonStylesListItem2.default, {
							activeStyle: _this2.props.activeStyle,
							name: item.name,
							style: item.style,
							styleFn: item.styleFn
						})
					);
				});
			}

			return items;
		}
	}]);

	return ButtonStylesList;
}(_react2.default.Component);

ButtonStylesList.defaultProps = {
	circular: false,
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	},
	showRemoveStylesItem: true
};
ButtonStylesList.key = 'buttonStylesList';
exports.default = (0, _widgetFocusManager2.default)(ButtonStylesList);

/***/ }),

/***/ "./src/components/buttons/button-styles.jsx":
/*!**************************************************!*\
  !*** ./src/components/buttons/button-styles.jsx ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonStyles class provides functionality for styling a selection with a list of
 * configurable and customizable styles. The allowed styles follow CKEDITOR.Style configuration
 * (http://docs.ckeditor.com/#!/api/CKEDITOR.style)
 *
 * @class ButtonStyles
 */
var ButtonStyles = function (_React$Component) {
	_inherits(ButtonStyles, _React$Component);

	function ButtonStyles() {
		_classCallCheck(this, ButtonStyles);

		return _possibleConstructorReturn(this, (ButtonStyles.__proto__ || Object.getPrototypeOf(ButtonStyles)).apply(this, arguments));
	}

	_createClass(ButtonStyles, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonStyles
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var _this2 = this;

			var activeStyle = AlloyEditor.Strings.normal;

			var styles = this._getStyles();

			styles.forEach(function (item) {
				if (_this2._checkActive(item.style)) {
					activeStyle = item.name;
				}
			});

			var buttonStylesList = void 0;

			if (this.props.expanded) {
				buttonStylesList = _react2.default.createElement(_buttonStylesList2.default, {
					activeStyle: activeStyle,
					onDismiss: this.props.toggleDropdown,
					showRemoveStylesItem: this.props.showRemoveStylesItem,
					styles: styles
				});
			}

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-dropdown ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': AlloyEditor.Strings.styles + ' ' + activeStyle,
						className: 'ae-toolbar-element',
						onClick: this.props.toggleDropdown,
						role: 'combobox',
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.styles + ' ' + activeStyle },
					_react2.default.createElement(
						'div',
						{ className: 'ae-container' },
						_react2.default.createElement(
							'span',
							{ className: 'ae-container-dropdown-selected-item' },
							activeStyle
						),
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'caret-bottom' })
					)
				),
				buttonStylesList
			);
		}

		/**
   * Checks if the given style definition is applied to the current selection in the editor.
   *
   * @instance
   * @memberof ButtonStyles
   * @method _checkActive
   * @param {Object} styleConfig Style definition as per http://docs.ckeditor.com/#!/api/CKEDITOR.style.
   * @protected
   * @return {Boolean} Returns true if the style is applied to the selection, false otherwise.
   */


		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default styles
   * @memberof ButtonStyles
   * @property {String} key
   * @static
   */

	}, {
		key: '_checkActive',
		value: function _checkActive(styleConfig) {
			var nativeEditor = this.context.editor.get('nativeEditor');

			// Styles with wildcard element (*) won't be considered active by CKEditor. Defaulting
			// to a 'span' element works for most of those cases with no defined element.
			styleConfig = CKEDITOR.tools.merge({ element: 'span' }, styleConfig);

			var style = new CKEDITOR.style(styleConfig);

			return style.checkActive(nativeEditor.elementPath(), nativeEditor);
		}

		/**
   * Returns an array of styles. Each style consists from two properties:
   * - name - the style name, for example "h1"
   * - style - an object with one property, called `element` which value
   * represents the style which have to be applied to the element.
   *
   * @instance
   * @memberof ButtonStyles
   * @method _getStyles
   * @protected
   * @return {Array<object>} An array of objects containing the styles.
   */

	}, {
		key: '_getStyles',
		value: function _getStyles() {
			return this.props.styles || [{
				name: AlloyEditor.Strings.h1,
				style: {
					element: 'h1'
				}
			}, {
				name: AlloyEditor.Strings.h2,
				style: {
					element: 'h2'
				}
			}, {
				name: AlloyEditor.Strings.formatted,
				style: {
					element: 'pre'
				}
			}, {
				name: AlloyEditor.Strings.cite,
				style: {
					element: 'cite'
				}
			}, {
				name: AlloyEditor.Strings.code,
				style: {
					element: 'code'
				}
			}];
		}
	}]);

	return ButtonStyles;
}(_react2.default.Component);

ButtonStyles.contextType = _editorContext2.default;
ButtonStyles.key = 'styles';
exports.default = ButtonStyles;

/***/ }),

/***/ "./src/components/buttons/button-subscript.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-subscript.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonSubscript class provides functionality for applying subscript style to a text selection.
 *
 * @class ButtonSubscript
 *
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonSubscript = function (_React$Component) {
	_inherits(ButtonSubscript, _React$Component);

	function ButtonSubscript() {
		_classCallCheck(this, ButtonSubscript);

		return _possibleConstructorReturn(this, (ButtonSubscript.__proto__ || Object.getPrototypeOf(ButtonSubscript)).apply(this, arguments));
	}

	_createClass(ButtonSubscript, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonSubscript
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonSubscript
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.subscript,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-subscript',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.subscript },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'subscript' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default subscript
   * @memberof ButtonSubscript
   * @property {String} key
   * @static
   */

	}]);

	return ButtonSubscript;
}(_react2.default.Component);

ButtonSubscript.defaultProps = {
	command: 'subscript',
	style: 'coreStyles_subscript'
};
ButtonSubscript.key = 'subscript';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonSubscript)));

/***/ }),

/***/ "./src/components/buttons/button-superscript.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-superscript.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonSuperscript class provides functionality for applying superscript style to a text selection.
 *
 * @class ButtonSuperscript
 *
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonSuperscript = function (_React$Component) {
	_inherits(ButtonSuperscript, _React$Component);

	function ButtonSuperscript() {
		_classCallCheck(this, ButtonSuperscript);

		return _possibleConstructorReturn(this, (ButtonSuperscript.__proto__ || Object.getPrototypeOf(ButtonSuperscript)).apply(this, arguments));
	}

	_createClass(ButtonSuperscript, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonSuperscript
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonSuperscript
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.superscript,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-superscript',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.superscript },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'superscript' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default superscript
   * @memberof ButtonSuperscript
   * @property {String} key
   * @static
   */

	}]);

	return ButtonSuperscript;
}(_react2.default.Component);

ButtonSuperscript.defaultProps = {
	command: 'superscript',
	style: 'coreStyles_superscript'
};
ButtonSuperscript.key = 'superscript';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonSuperscript)));

/***/ }),

/***/ "./src/components/buttons/button-table-cell.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-table-cell.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableCell class provides functionality to work with table cells.
 *
 * @class ButtonTableCell
 */
var ButtonTableCell = function (_React$Component) {
	_inherits(ButtonTableCell, _React$Component);

	function ButtonTableCell() {
		_classCallCheck(this, ButtonTableCell);

		return _possibleConstructorReturn(this, (ButtonTableCell.__proto__ || Object.getPrototypeOf(ButtonTableCell)).apply(this, arguments));
	}

	_createClass(ButtonTableCell, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableCell
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var buttonCommandsList = void 0;
			var buttonCommandsListId = void 0;

			if (this.props.expanded) {
				buttonCommandsListId = ButtonTableCell.key + 'List';
				buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, {
					commands: this._getCommands(),
					listId: buttonCommandsListId,
					onDismiss: this.props.toggleDropdown
				});
			}

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': AlloyEditor.Strings.cell,
						'aria-owns': buttonCommandsListId,
						className: 'ae-button',
						onClick: this.props.toggleDropdown,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.cell },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'add-cell' })
				),
				buttonCommandsList
			);
		}

		/**
   * Returns a list of commands. If a list of commands was passed
   * as property `commands`, it will take a precedence over the default ones.
   *
   * @instance
   * @memberof ButtonTableCell
   * @method _getCommands
   * @protected
   * @return {Array} The list of available commands.
   */

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default tableCell
   * @memberof ButtonTableCell
   * @property {String} key
   * @static
   */

	}, {
		key: '_getCommands',
		value: function _getCommands() {
			return this.props.commands || [{
				command: 'cellInsertBefore',
				label: AlloyEditor.Strings.cellInsertBefore
			}, {
				command: 'cellInsertAfter',
				label: AlloyEditor.Strings.cellInsertAfter
			}, {
				command: 'cellDelete',
				label: AlloyEditor.Strings.cellDelete
			}, {
				command: 'cellMerge',
				label: AlloyEditor.Strings.cellMerge
			}, {
				command: 'cellMergeDown',
				label: AlloyEditor.Strings.cellMergeDown
			}, {
				command: 'cellMergeRight',
				label: AlloyEditor.Strings.cellMergeRight
			}, {
				command: 'cellHorizontalSplit',
				label: AlloyEditor.Strings.cellSplitHorizontal
			}, {
				command: 'cellVerticalSplit',
				label: AlloyEditor.Strings.cellSplitVertical
			}];
		}
	}]);

	return ButtonTableCell;
}(_react2.default.Component);

ButtonTableCell.key = 'tableCell';
exports.default = ButtonTableCell;

/***/ }),

/***/ "./src/components/buttons/button-table-column.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-table-column.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableColumn class provides functionality to work with table columns.
 *
 * @class ButtonTableColumn
 */
var ButtonTableColumn = function (_React$Component) {
	_inherits(ButtonTableColumn, _React$Component);

	function ButtonTableColumn() {
		_classCallCheck(this, ButtonTableColumn);

		return _possibleConstructorReturn(this, (ButtonTableColumn.__proto__ || Object.getPrototypeOf(ButtonTableColumn)).apply(this, arguments));
	}

	_createClass(ButtonTableColumn, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableColumn
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var buttonCommandsList = void 0;
			var buttonCommandsListId = void 0;

			if (this.props.expanded) {
				buttonCommandsListId = ButtonTableColumn.key + 'List';
				buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, {
					commands: this._getCommands(),
					listId: buttonCommandsListId,
					onDismiss: this.props.toggleDropdown
				});
			}

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': AlloyEditor.Strings.column,
						'aria-owns': buttonCommandsListId,
						className: 'ae-button',
						onClick: this.props.toggleDropdown,
						role: 'listbox',
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.column },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'add-column' })
				),
				buttonCommandsList
			);
		}

		/**
   * Returns a list of commands. If a list of commands was passed
   * as property `commands`, it will take a precedence over the default ones.
   *
   * @instance
   * @memberof ButtonTableColumn
   * @method _getCommands
   * @protected
   * @return {Array} The list of available commands.
   */

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default tableColumn
   * @memberof ButtonTableColumn
   * @property {String} key
   * @static
   */

	}, {
		key: '_getCommands',
		value: function _getCommands() {
			return this.props.commands || [{
				command: 'columnInsertBefore',
				label: AlloyEditor.Strings.columnInsertBefore
			}, {
				command: 'columnInsertAfter',
				label: AlloyEditor.Strings.columnInsertAfter
			}, {
				command: 'columnDelete',
				label: AlloyEditor.Strings.columnDelete
			}];
		}
	}]);

	return ButtonTableColumn;
}(_react2.default.Component);

ButtonTableColumn.key = 'tableColumn';
exports.default = ButtonTableColumn;

/***/ }),

/***/ "./src/components/buttons/button-table-edit.jsx":
/*!******************************************************!*\
  !*** ./src/components/buttons/button-table-edit.jsx ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KEY_ENTER = 13;
var KEY_ESC = 27;

/**
 * The ButtonTableEdit class provides functionality for creating and editing a table in a document.
 * Provides UI for creating a table.
 *
 * @class ButtonTableEdit
 */

var ButtonTableEdit = function (_React$Component) {
	_inherits(ButtonTableEdit, _React$Component);

	/**
  * Lifecycle. Invoked once before the component is mounted.
  *
  * @instance
  * @memberof ButtonTableEdit
  * @method getInitialState
  */


	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof ButtonTableEdit
  * @method getDefaultProps
  */
	function ButtonTableEdit(props) {
		_classCallCheck(this, ButtonTableEdit);

		var _this = _possibleConstructorReturn(this, (ButtonTableEdit.__proto__ || Object.getPrototypeOf(ButtonTableEdit)).call(this, props));

		_this._createTable = function () {
			var editor = _this.context.editor.get('nativeEditor');
			var tableUtils = new CKEDITOR.Table(editor);

			tableUtils.create({
				attrs: _this.props.tableAttributes,
				cols: _this.state.cols,
				rows: _this.state.rows
			});

			_this.props.cancelExclusive();

			editor.fire('actionPerformed', _this);
		};

		_this._handleChange = function (inputName, event) {
			var state = {};
			state[inputName] = event.target.value;

			_this.setState(state);
		};

		_this._handleKeyDown = function (event) {
			if (event.keyCode === KEY_ENTER || event.keyCode === KEY_ESC) {
				event.preventDefault();
			}

			if (event.keyCode === KEY_ENTER) {
				_this._createTable();
			} else if (event.keyCode === KEY_ESC) {
				_this.props.cancelExclusive();
			}
		};

		_this.rowsRef = _react2.default.createRef();
		_this.colsRef = _react2.default.createRef();
		_this.state = {
			cols: 3,
			rows: 3
		};
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client (not on the server),
  * immediately after the initial rendering occurs.
  *
  * Focuses on the link input to immediately allow editing.
  *
  * @instance
  * @memberof ButtonTableEdit
  * @method componentDidMount
  */


	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default tableEdit
  * @memberof ButtonTableEdit
  * @property {String} key
  * @static
  */


	_createClass(ButtonTableEdit, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this.rowsRef.current.focus();
		}

		/**
   * Creates a table.
   *
   * @instance
   * @memberof ButtonTableEdit
   * @method _createTable
   * @protected
   */


		/**
   * Handles a change in input value. Sets the provided value from the user back to the input.
   *
   * @instance
   * @memberof ButtonTableEdit
   * @method _handleChange
   * @param {String} inputName The name of the input which value should be updated.
   * @param {SyntheticEvent} event The provided event.
   * @protected
   */


		/**
   * Monitors key interaction inside the input element to respond to the keys:
   * - Enter: Creates the table.
   * - Escape: Discards the changes.
   *
   * @instance
   * @memberof ButtonTableEdit
   * @method _handleKeyDown
   * @param {SyntheticEvent} event The keyboard event.
   * @protected
   */

	}, {
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableEdit
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var time = Date.now();
			var rowsId = time + 'rows';
			var colsId = time + 'cols';

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-edit-table' },
				_react2.default.createElement(
					'label',
					{ htmlFor: rowsId },
					AlloyEditor.Strings.rows
				),
				_react2.default.createElement(
					'div',
					{ className: 'ae-container-input small' },
					_react2.default.createElement('input', {
						className: 'ae-input',
						id: rowsId,
						onChange: this._handleChange.bind(this, 'rows'),
						min: '1',
						onKeyDown: this._handleKeyDown,
						placeholder: 'Rows',
						ref: this.rowsRef,
						type: 'number',
						value: this.state.rows
					})
				),
				_react2.default.createElement(
					'label',
					{ htmlFor: colsId },
					AlloyEditor.Strings.columns
				),
				_react2.default.createElement(
					'div',
					{ className: 'ae-container-input small' },
					_react2.default.createElement('input', {
						className: 'ae-input',
						id: colsId,
						onChange: this._handleChange.bind(this, 'cols'),
						min: '1',
						onKeyDown: this._handleKeyDown,
						placeholder: 'Colums',
						ref: this.colsRef,
						type: 'number',
						value: this.state.cols
					})
				),
				_react2.default.createElement(
					'button',
					{
						'aria-label': 'Confirm',
						className: 'ae-button',
						onClick: this._createTable },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'check' })
				)
			);
		}
	}]);

	return ButtonTableEdit;
}(_react2.default.Component);

ButtonTableEdit.contextType = _editorContext2.default;
ButtonTableEdit.defaultProps = {
	tableAttributes: {
		border: 1,
		cellPadding: 0,
		cellSpacing: 0,
		style: 'width: 100%'
	}
};
ButtonTableEdit.key = 'tableEdit';
exports.default = ButtonTableEdit;

/***/ }),

/***/ "./src/components/buttons/button-table-heading.jsx":
/*!*********************************************************!*\
  !*** ./src/components/buttons/button-table-heading.jsx ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableHeading class provides functionality to work with table heading.
 *
 * @class ButtonTableHeading
 */
var ButtonTableHeading = function (_React$Component) {
	_inherits(ButtonTableHeading, _React$Component);

	function ButtonTableHeading() {
		_classCallCheck(this, ButtonTableHeading);

		return _possibleConstructorReturn(this, (ButtonTableHeading.__proto__ || Object.getPrototypeOf(ButtonTableHeading)).apply(this, arguments));
	}

	_createClass(ButtonTableHeading, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableHeading
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var buttonCommandsList = void 0;
			var buttonCommandsListId = void 0;

			if (this.props.expanded) {
				buttonCommandsListId = ButtonTableHeading.key + 'List';
				buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, {
					commands: this._getCommands(),
					listId: buttonCommandsListId,
					onDismiss: this.props.toggleDropdown
				});
			}

			var activeHeading = new CKEDITOR.Table(this.context.editor.get('nativeEditor')).getHeading();
			var activeHeadingIntro = AlloyEditor.Strings.headers + ':';
			var activeHeadingLabel = AlloyEditor.Strings['headers' + activeHeading];

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container-dropdown-xl ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': '',
						className: 'ae-toolbar-element',
						onClick: this.props.toggleDropdown,
						role: 'combobox',
						tabIndex: this.props.tabIndex,
						title: '' },
					_react2.default.createElement(
						'div',
						{ className: 'ae-container' },
						_react2.default.createElement(
							'span',
							{ className: 'ae-container-dropdown-selected-item' },
							activeHeadingIntro,
							' ',
							_react2.default.createElement(
								'strong',
								null,
								activeHeadingLabel
							)
						),
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'caret-bottom' })
					)
				),
				buttonCommandsList
			);
		}

		/**
   * Returns a list of commands. If a list of commands was passed
   * as property `commands`, it will take a precedence over the default ones.
   *
   * @instance
   * @memberof ButtonTableHeading
   * @method _getCommands
   * @protected
   * @return {Array} The list of available commands.
   */


		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default tableRow
   * @memberof ButtonTableHeading
   * @property {String} key
   * @static
   */

	}, {
		key: '_getCommands',
		value: function _getCommands() {
			return this.props.commands || [{
				command: 'tableHeadingNone',
				label: AlloyEditor.Strings.headersNone
			}, {
				command: 'tableHeadingRow',
				label: AlloyEditor.Strings.headersRow
			}, {
				command: 'tableHeadingColumn',
				label: AlloyEditor.Strings.headersColumn
			}, {
				command: 'tableHeadingBoth',
				label: AlloyEditor.Strings.headersBoth
			}];
		}
	}]);

	return ButtonTableHeading;
}(_react2.default.Component);

ButtonTableHeading.contextType = _editorContext2.default;
ButtonTableHeading.key = 'tableHeading';
exports.default = ButtonTableHeading;

/***/ }),

/***/ "./src/components/buttons/button-table-remove.jsx":
/*!********************************************************!*\
  !*** ./src/components/buttons/button-table-remove.jsx ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableRemove class provides functionality for removing a table
 *
 * @class ButtonTableRemove
 */
var ButtonTableRemove = function (_React$Component) {
	_inherits(ButtonTableRemove, _React$Component);

	function ButtonTableRemove() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonTableRemove);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonTableRemove.__proto__ || Object.getPrototypeOf(ButtonTableRemove)).call.apply(_ref, [this].concat(args))), _this), _this._removeTable = function () {
			var editor = _this.context.editor.get('nativeEditor');
			var tableUtils = new CKEDITOR.Table(editor);

			tableUtils.remove();

			editor.fire('actionPerformed', _this);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default tableRemove
  * @memberof ButtonTableRemove
  * @property {String} key
  * @static
  */


	_createClass(ButtonTableRemove, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableRemove
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.deleteTable,
					className: 'ae-button',
					'data-type': 'button-table-remove',
					onClick: this._removeTable,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.deleteTable },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'trash' })
			);
		}

		/**
   * Removes the table in the editor element.
   *
   * @instance
   * @memberof ButtonTableRemove
   * @method _removeTable
   * @protected
   */

	}]);

	return ButtonTableRemove;
}(_react2.default.Component);

ButtonTableRemove.contextType = _editorContext2.default;
ButtonTableRemove.key = 'tableRemove';
exports.default = ButtonTableRemove;

/***/ }),

/***/ "./src/components/buttons/button-table-row.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-table-row.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTableRow class provides functionality to work with table rows.
 *
 * @class ButtonTableRow
 */
var ButtonTableRow = function (_React$Component) {
	_inherits(ButtonTableRow, _React$Component);

	function ButtonTableRow() {
		_classCallCheck(this, ButtonTableRow);

		return _possibleConstructorReturn(this, (ButtonTableRow.__proto__ || Object.getPrototypeOf(ButtonTableRow)).apply(this, arguments));
	}

	_createClass(ButtonTableRow, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTableRow
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			var buttonCommandsList = void 0;
			var buttonCommandsListId = void 0;

			if (this.props.expanded) {
				buttonCommandsListId = ButtonTableRow.key + 'List';
				buttonCommandsList = _react2.default.createElement(_buttonCommandsList2.default, {
					commands: this._getCommands(),
					listId: buttonCommandsListId,
					onDismiss: this.props.toggleDropdown
				});
			}

			return _react2.default.createElement(
				'div',
				{ className: 'ae-container ae-has-dropdown' },
				_react2.default.createElement(
					'button',
					{
						'aria-expanded': this.props.expanded,
						'aria-label': AlloyEditor.Strings.row,
						'aria-owns': buttonCommandsListId,
						className: 'ae-button',
						onClick: this.props.toggleDropdown,
						role: 'combobox',
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.row },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'add-row' })
				),
				buttonCommandsList
			);
		}

		/**
   * Returns a list of commands. If a list of commands was passed
   * as property `commands`, it will take a precedence over the default ones.
   *
   * @instance
   * @memberof ButtonTableRow
   * @method _getCommands
   * @protected
   * @return {Array} The list of available commands.
   */

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default tableRow
   * @memberof ButtonTableRow
   * @property {String} key
   * @static
   */

	}, {
		key: '_getCommands',
		value: function _getCommands() {
			return this.props.commands || [{
				command: 'rowInsertBefore',
				label: AlloyEditor.Strings.rowInsertBefore
			}, {
				command: 'rowInsertAfter',
				label: AlloyEditor.Strings.rowInsertAfter
			}, {
				command: 'rowDelete',
				label: AlloyEditor.Strings.rowDelete
			}];
		}
	}]);

	return ButtonTableRow;
}(_react2.default.Component);

ButtonTableRow.key = 'tableRow';
exports.default = ButtonTableRow;

/***/ }),

/***/ "./src/components/buttons/button-table.jsx":
/*!*************************************************!*\
  !*** ./src/components/buttons/button-table.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonTableEdit = __webpack_require__(/*! ./button-table-edit.jsx */ "./src/components/buttons/button-table-edit.jsx");

var _buttonTableEdit2 = _interopRequireDefault(_buttonTableEdit);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTable class provides functionality for creating and editing a table in a document. ButtonTable
 * renders in two different modes:
 *
 * - Normal: Just a button that allows to switch to the edition mode
 * - Exclusive: The ButtonTableEdit UI with all the table edition controls.
 *
 * @class ButtonTable
 */
var ButtonTable = function (_React$Component) {
	_inherits(ButtonTable, _React$Component);

	function ButtonTable() {
		_classCallCheck(this, ButtonTable);

		return _possibleConstructorReturn(this, (ButtonTable.__proto__ || Object.getPrototypeOf(ButtonTable)).apply(this, arguments));
	}

	_createClass(ButtonTable, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTable
   * @method render
   * @return {Object} The content which should be rendered.
   */
		value: function render() {
			if (this.props.renderExclusive) {
				return _react2.default.createElement(_buttonTableEdit2.default, this.props);
			} else {
				return _react2.default.createElement(
					'button',
					{
						'aria-label': AlloyEditor.Strings.table,
						className: 'ae-button',
						'data-type': 'button-table',
						onClick: this.props.requestExclusive,
						tabIndex: this.props.tabIndex,
						title: AlloyEditor.Strings.table },
					_react2.default.createElement(_buttonIcon2.default, { symbol: 'table' })
				);
			}
		}
		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default table
   * @memberof ButtonTable
   * @property {String} key
   * @static
   */

	}]);

	return ButtonTable;
}(_react2.default.Component);

ButtonTable.key = 'table';
exports.default = ButtonTable;

/***/ }),

/***/ "./src/components/buttons/button-target-list.jsx":
/*!*******************************************************!*\
  !*** ./src/components/buttons/button-target-list.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonTargetList class provides functionality for changing the target of a link
 * in the document.
 *
 * @class ButtonTargetList
 * @uses WidgetFocusManager
 */
var ButtonTargetList = function (_React$Component) {
	_inherits(ButtonTargetList, _React$Component);

	function ButtonTargetList() {
		_classCallCheck(this, ButtonTargetList);

		return _possibleConstructorReturn(this, (ButtonTargetList.__proto__ || Object.getPrototypeOf(ButtonTargetList)).apply(this, arguments));
	}

	_createClass(ButtonTargetList, [{
		key: 'componentDidMount',


		/**
   * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
   *
   * @instance
   * @memberof ButtonTargetList
   * @method componentDidMount
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonTargetList
   * @method getDefaultProps
   */
		value: function componentDidMount() {
			_reactDom2.default.findDOMNode(this).focus();
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTargetList
   * @method render
   * @return {Object} The content which should be rendered.
   */


		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default linkTargetEdit
   * @memberof ButtonTargetList
   * @property {String} key
   * @static
   */

	}, {
		key: 'render',
		value: function render() {
			var listTargets = this._renderListTargets();

			return _react2.default.createElement(
				_buttonDropdown2.default,
				this.props,
				listTargets
			);
		}

		/**
   * Returns the the allowed link target items.
   *
   * @instance
   * @memberof ButtonTargetList
   * @method _getAllowedTargetItems
   * @protected
   * @return {Array} The allowed target items.
   */

	}, {
		key: '_getAllowedTargetItems',
		value: function _getAllowedTargetItems() {
			return this.props.allowedLinkTargets || [{
				label: AlloyEditor.Strings.linkTargetDefault,
				value: ''
			}, {
				label: AlloyEditor.Strings.linkTargetSelf,
				value: '_self'
			}, {
				label: AlloyEditor.Strings.linkTargetBlank,
				value: '_blank'
			}, {
				label: AlloyEditor.Strings.linkTargetParent,
				value: '_parent'
			}, {
				label: AlloyEditor.Strings.linkTargetTop,
				value: '_top'
			}];
		}

		/**
   * Renders the allowed link target items.
   *
   * @instance
   * @memberof ButtonTargetList
   * @method _renderListTargets
   * @protected
   * @return {Object} Returns the rendered link items
   */

	}, {
		key: '_renderListTargets',
		value: function _renderListTargets() {
			var _this2 = this;

			var targets = this._getAllowedTargetItems();

			var handleLinkTargetChange = this.props.handleLinkTargetChange;

			targets = targets.map(function (target) {
				var className = _this2.props.selectedTarget === target.value ? 'ae-toolbar-element active' : 'ae-toolbar-element';

				return _react2.default.createElement(
					'li',
					{ key: target.value, role: 'option' },
					_react2.default.createElement(
						'button',
						{
							className: className,
							'data-value': target.value,
							onClick: handleLinkTargetChange },
						target.label
					)
				);
			});

			return targets;
		}
	}]);

	return ButtonTargetList;
}(_react2.default.Component);

ButtonTargetList.defaultProps = {
	circular: true,
	descendants: '.ae-toolbar-element',
	keys: {
		dismiss: [27],
		dismissNext: [39],
		dismissPrev: [37],
		next: [40],
		prev: [38]
	}
};
ButtonTargetList.key = 'targetList';
exports.default = (0, _widgetFocusManager2.default)(ButtonTargetList);

/***/ }),

/***/ "./src/components/buttons/button-twitter.jsx":
/*!***************************************************!*\
  !*** ./src/components/buttons/button-twitter.jsx ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var MAX_TWEET_LENGTH = 280;

/**
 * The ButtonTwitter class provides functionality for creating a link which
 * allows people to tweet part of the content in the editor.
 *
 * @class ButtonTwitter
 * @uses ButtonStateClasses
 */

var ButtonTwitter = function (_React$Component) {
	_inherits(ButtonTwitter, _React$Component);

	function ButtonTwitter() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, ButtonTwitter);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonTwitter.__proto__ || Object.getPrototypeOf(ButtonTwitter)).call.apply(_ref, [this].concat(args))), _this), _this.handleClick = function () {
			var editor = _this.context.editor.get('nativeEditor');

			var linkUtils = new CKEDITOR.Link(editor);

			if (_this.isActive()) {
				linkUtils.remove(linkUtils.getFromSelection());
			} else {
				linkUtils.create(_this._getHref(), {
					class: 'ae-twitter-link',
					target: '_blank'
				});
			}

			editor.fire('actionPerformed', _this);
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	/**
  * The name which will be used as an alias of the button in the configuration.
  *
  * @default twitter
  * @memberof ButtonTwitter
  * @property {String} key
  * @static
  */


	/**
  * Creates or removes the twitter link on the selection.
  *
  * @instance
  * @memberof ButtonTwitter
  * @method handleClick
  */


	_createClass(ButtonTwitter, [{
		key: 'isActive',


		/**
   * Checks if the current selection is contained within a link that points to twitter.com/intent/tweet.
   *
   * @instance
   * @memberof ButtonTwitter
   * @method isActive
   * @return {Boolean} True if the selection is inside a twitter link, false otherwise.
   */
		value: function isActive() {
			var link = new CKEDITOR.Link(this.context.editor.get('nativeEditor')).getFromSelection();

			return link && link.getAttribute('href').indexOf('twitter.com/intent/tweet') !== -1;
		}

		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonTwitter
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.twitter,
					className: cssClass,
					'data-type': 'button-twitter',
					onClick: this.handleClick,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.twitter },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'twitter' })
			);
		}

		/**
   * Generates the appropriate twitter url based on the selected text and the configuration
   * options received via props.
   *
   * @instance
   * @memberof ButtonTwitter
   * @method _getHref
   * @protected
   * @return {String} A valid twitter url with the selected text and given configuration.
   */

	}, {
		key: '_getHref',
		value: function _getHref() {
			var nativeEditor = this.context.editor.get('nativeEditor');
			var selectedText = nativeEditor.getSelection().getSelectedText().substring(0, MAX_TWEET_LENGTH);
			var url = this.props.url;
			var via = this.props.via;
			var twitterHref = 'https://twitter.com/intent/tweet?text=' + selectedText;

			if (url) {
				twitterHref += '&url=' + url;
			}

			if (via) {
				twitterHref += '&via=' + via;
			}

			return twitterHref;
		}
	}]);

	return ButtonTwitter;
}(_react2.default.Component);

ButtonTwitter.contextType = _editorContext2.default;
ButtonTwitter.key = 'twitter';
exports.default = (0, _buttonStateClasses2.default)(ButtonTwitter);

/***/ }),

/***/ "./src/components/buttons/button-ul.jsx":
/*!**********************************************!*\
  !*** ./src/components/buttons/button-ul.jsx ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonUnorderedlist class provides functionality for creating unordered lists in an editor.
 *
 * @class ButtonUnorderedlist
 * @uses ButtonCommand
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonUnorderedlist = function (_React$Component) {
	_inherits(ButtonUnorderedlist, _React$Component);

	function ButtonUnorderedlist() {
		_classCallCheck(this, ButtonUnorderedlist);

		return _possibleConstructorReturn(this, (ButtonUnorderedlist.__proto__ || Object.getPrototypeOf(ButtonUnorderedlist)).apply(this, arguments));
	}

	_createClass(ButtonUnorderedlist, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonUnorderedlist
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonUnorderedlist
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.bulletedlist,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-ul',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.bulletedlist },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'list-ul' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default ul
   * @memberof ButtonUnorderedlist
   * @property {String} key
   * @static
   */

	}]);

	return ButtonUnorderedlist;
}(_react2.default.Component);

ButtonUnorderedlist.defaultProps = {
	command: 'bulletedlist',
	style: {
		element: 'ul'
	}
};
ButtonUnorderedlist.key = 'ul';
exports.default = (0, _buttonCommand2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonUnorderedlist)));

/***/ }),

/***/ "./src/components/buttons/button-underline.jsx":
/*!*****************************************************!*\
  !*** ./src/components/buttons/button-underline.jsx ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _buttonCommand = __webpack_require__(/*! ../base/button-command */ "./src/components/base/button-command.js");

var _buttonCommand2 = _interopRequireDefault(_buttonCommand);

var _buttonIcon = __webpack_require__(/*! ./button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _buttonKeystroke = __webpack_require__(/*! ../base/button-keystroke */ "./src/components/base/button-keystroke.js");

var _buttonKeystroke2 = _interopRequireDefault(_buttonKeystroke);

var _buttonStateClasses = __webpack_require__(/*! ../base/button-state-classes */ "./src/components/base/button-state-classes.js");

var _buttonStateClasses2 = _interopRequireDefault(_buttonStateClasses);

var _buttonStyle = __webpack_require__(/*! ../base/button-style */ "./src/components/base/button-style.js");

var _buttonStyle2 = _interopRequireDefault(_buttonStyle);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ButtonUnderline class provides functionality for underlying a text selection.
 *
 * @class ButtonUnderline
 * @uses ButtonCommand
 * @uses ButtonKeystroke
 * @uses ButtonStateClasses
 * @uses ButtonStyle
 */
var ButtonUnderline = function (_React$Component) {
	_inherits(ButtonUnderline, _React$Component);

	function ButtonUnderline() {
		_classCallCheck(this, ButtonUnderline);

		return _possibleConstructorReturn(this, (ButtonUnderline.__proto__ || Object.getPrototypeOf(ButtonUnderline)).apply(this, arguments));
	}

	_createClass(ButtonUnderline, [{
		key: 'render',


		/**
   * Lifecycle. Renders the UI of the button.
   *
   * @instance
   * @memberof ButtonUnderline
   * @method render
   * @return {Object} The content which should be rendered.
   */

		/**
   * Lifecycle. Returns the default values of the properties used in the widget.
   *
   * @instance
   * @memberof ButtonUnderline
   * @method getDefaultProps
   * @return {Object} The default properties.
   */
		value: function render() {
			var cssClass = 'ae-button ' + this.getStateClasses();

			return _react2.default.createElement(
				'button',
				{
					'aria-label': AlloyEditor.Strings.underline,
					'aria-pressed': cssClass.indexOf('pressed') !== -1,
					className: cssClass,
					'data-type': 'button-underline',
					onClick: this.execCommand,
					tabIndex: this.props.tabIndex,
					title: AlloyEditor.Strings.underline },
				_react2.default.createElement(_buttonIcon2.default, { symbol: 'underline' })
			);
		}

		/**
   * The name which will be used as an alias of the button in the configuration.
   *
   * @default underline
   * @memberof ButtonUnderline
   * @property {String} key
   * @static
   */

	}]);

	return ButtonUnderline;
}(_react2.default.Component);

ButtonUnderline.defaultProps = {
	command: 'underline',
	keystroke: {
		fn: 'execCommand',
		keys: CKEDITOR.CTRL + 85 /* U*/
	},
	style: 'coreStyles_underline'
};
ButtonUnderline.key = 'underline';
exports.default = (0, _buttonCommand2.default)((0, _buttonKeystroke2.default)((0, _buttonStateClasses2.default)((0, _buttonStyle2.default)(ButtonUnderline))));

/***/ }),

/***/ "./src/components/buttons/index.js":
/*!*****************************************!*\
  !*** ./src/components/buttons/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _ButtonAccessibilityI;

var _buttonAccessibilityImageAlt = __webpack_require__(/*! ./button-accessibility-image-alt.jsx */ "./src/components/buttons/button-accessibility-image-alt.jsx");

var _buttonAccessibilityImageAlt2 = _interopRequireDefault(_buttonAccessibilityImageAlt);

var _buttonBackgroundColor = __webpack_require__(/*! ./button-background-color.jsx */ "./src/components/buttons/button-background-color.jsx");

var _buttonBackgroundColor2 = _interopRequireDefault(_buttonBackgroundColor);

var _buttonBold = __webpack_require__(/*! ./button-bold.jsx */ "./src/components/buttons/button-bold.jsx");

var _buttonBold2 = _interopRequireDefault(_buttonBold);

var _buttonCameraImage = __webpack_require__(/*! ./button-camera-image.jsx */ "./src/components/buttons/button-camera-image.jsx");

var _buttonCameraImage2 = _interopRequireDefault(_buttonCameraImage);

var _buttonCamera = __webpack_require__(/*! ./button-camera.jsx */ "./src/components/buttons/button-camera.jsx");

var _buttonCamera2 = _interopRequireDefault(_buttonCamera);

var _buttonCode = __webpack_require__(/*! ./button-code.jsx */ "./src/components/buttons/button-code.jsx");

var _buttonCode2 = _interopRequireDefault(_buttonCode);

var _buttonColor = __webpack_require__(/*! ./button-color.jsx */ "./src/components/buttons/button-color.jsx");

var _buttonColor2 = _interopRequireDefault(_buttonColor);

var _buttonCommandListItem = __webpack_require__(/*! ./button-command-list-item.jsx */ "./src/components/buttons/button-command-list-item.jsx");

var _buttonCommandListItem2 = _interopRequireDefault(_buttonCommandListItem);

var _buttonCommandsList = __webpack_require__(/*! ./button-commands-list.jsx */ "./src/components/buttons/button-commands-list.jsx");

var _buttonCommandsList2 = _interopRequireDefault(_buttonCommandsList);

var _buttonDropdown = __webpack_require__(/*! ./button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _buttonEmbedEdit = __webpack_require__(/*! ./button-embed-edit.jsx */ "./src/components/buttons/button-embed-edit.jsx");

var _buttonEmbedEdit2 = _interopRequireDefault(_buttonEmbedEdit);

var _buttonEmbed = __webpack_require__(/*! ./button-embed.jsx */ "./src/components/buttons/button-embed.jsx");

var _buttonEmbed2 = _interopRequireDefault(_buttonEmbed);

var _buttonEmbedVideoEdit = __webpack_require__(/*! ./button-embed-video-edit.jsx */ "./src/components/buttons/button-embed-video-edit.jsx");

var _buttonEmbedVideoEdit2 = _interopRequireDefault(_buttonEmbedVideoEdit);

var _buttonEmbedVideo = __webpack_require__(/*! ./button-embed-video.jsx */ "./src/components/buttons/button-embed-video.jsx");

var _buttonEmbedVideo2 = _interopRequireDefault(_buttonEmbedVideo);

var _buttonH = __webpack_require__(/*! ./button-h1.jsx */ "./src/components/buttons/button-h1.jsx");

var _buttonH2 = _interopRequireDefault(_buttonH);

var _buttonH3 = __webpack_require__(/*! ./button-h2.jsx */ "./src/components/buttons/button-h2.jsx");

var _buttonH4 = _interopRequireDefault(_buttonH3);

var _buttonHline = __webpack_require__(/*! ./button-hline.jsx */ "./src/components/buttons/button-hline.jsx");

var _buttonHline2 = _interopRequireDefault(_buttonHline);

var _buttonImageAlignCenter = __webpack_require__(/*! ./button-image-align-center.jsx */ "./src/components/buttons/button-image-align-center.jsx");

var _buttonImageAlignCenter2 = _interopRequireDefault(_buttonImageAlignCenter);

var _buttonImageAlignLeft = __webpack_require__(/*! ./button-image-align-left.jsx */ "./src/components/buttons/button-image-align-left.jsx");

var _buttonImageAlignLeft2 = _interopRequireDefault(_buttonImageAlignLeft);

var _buttonImageAlignRight = __webpack_require__(/*! ./button-image-align-right.jsx */ "./src/components/buttons/button-image-align-right.jsx");

var _buttonImageAlignRight2 = _interopRequireDefault(_buttonImageAlignRight);

var _buttonImage = __webpack_require__(/*! ./button-image.jsx */ "./src/components/buttons/button-image.jsx");

var _buttonImage2 = _interopRequireDefault(_buttonImage);

var _buttonIndentBlock = __webpack_require__(/*! ./button-indent-block.jsx */ "./src/components/buttons/button-indent-block.jsx");

var _buttonIndentBlock2 = _interopRequireDefault(_buttonIndentBlock);

var _buttonItalic = __webpack_require__(/*! ./button-italic.jsx */ "./src/components/buttons/button-italic.jsx");

var _buttonItalic2 = _interopRequireDefault(_buttonItalic);

var _buttonItemSelectorAudio = __webpack_require__(/*! ./button-item-selector-audio.jsx */ "./src/components/buttons/button-item-selector-audio.jsx");

var _buttonItemSelectorAudio2 = _interopRequireDefault(_buttonItemSelectorAudio);

var _buttonItemSelectorImage = __webpack_require__(/*! ./button-item-selector-image.jsx */ "./src/components/buttons/button-item-selector-image.jsx");

var _buttonItemSelectorImage2 = _interopRequireDefault(_buttonItemSelectorImage);

var _buttonItemSelectorVideo = __webpack_require__(/*! ./button-item-selector-video.jsx */ "./src/components/buttons/button-item-selector-video.jsx");

var _buttonItemSelectorVideo2 = _interopRequireDefault(_buttonItemSelectorVideo);

var _buttonLinkAutocompleteList = __webpack_require__(/*! ./button-link-autocomplete-list.jsx */ "./src/components/buttons/button-link-autocomplete-list.jsx");

var _buttonLinkAutocompleteList2 = _interopRequireDefault(_buttonLinkAutocompleteList);

var _buttonLinkBrowse = __webpack_require__(/*! ./button-link-browse.jsx */ "./src/components/buttons/button-link-browse.jsx");

var _buttonLinkBrowse2 = _interopRequireDefault(_buttonLinkBrowse);

var _buttonLinkEditBrowse = __webpack_require__(/*! ./button-link-edit-browse.jsx */ "./src/components/buttons/button-link-edit-browse.jsx");

var _buttonLinkEditBrowse2 = _interopRequireDefault(_buttonLinkEditBrowse);

var _buttonLinkEdit = __webpack_require__(/*! ./button-link-edit.jsx */ "./src/components/buttons/button-link-edit.jsx");

var _buttonLinkEdit2 = _interopRequireDefault(_buttonLinkEdit);

var _buttonLinkTargetEdit = __webpack_require__(/*! ./button-link-target-edit.jsx */ "./src/components/buttons/button-link-target-edit.jsx");

var _buttonLinkTargetEdit2 = _interopRequireDefault(_buttonLinkTargetEdit);

var _buttonLink = __webpack_require__(/*! ./button-link.jsx */ "./src/components/buttons/button-link.jsx");

var _buttonLink2 = _interopRequireDefault(_buttonLink);

var _buttonOl = __webpack_require__(/*! ./button-ol.jsx */ "./src/components/buttons/button-ol.jsx");

var _buttonOl2 = _interopRequireDefault(_buttonOl);

var _buttonOutdentBlock = __webpack_require__(/*! ./button-outdent-block.jsx */ "./src/components/buttons/button-outdent-block.jsx");

var _buttonOutdentBlock2 = _interopRequireDefault(_buttonOutdentBlock);

var _buttonParagraphAlign = __webpack_require__(/*! ./button-paragraph-align.jsx */ "./src/components/buttons/button-paragraph-align.jsx");

var _buttonParagraphAlign2 = _interopRequireDefault(_buttonParagraphAlign);

var _buttonParagraphAlignLeft = __webpack_require__(/*! ./button-paragraph-align-left.jsx */ "./src/components/buttons/button-paragraph-align-left.jsx");

var _buttonParagraphAlignLeft2 = _interopRequireDefault(_buttonParagraphAlignLeft);

var _buttonParagraphAlignRight = __webpack_require__(/*! ./button-paragraph-align-right.jsx */ "./src/components/buttons/button-paragraph-align-right.jsx");

var _buttonParagraphAlignRight2 = _interopRequireDefault(_buttonParagraphAlignRight);

var _buttonParagraphCenter = __webpack_require__(/*! ./button-paragraph-center.jsx */ "./src/components/buttons/button-paragraph-center.jsx");

var _buttonParagraphCenter2 = _interopRequireDefault(_buttonParagraphCenter);

var _buttonParagraphJustify = __webpack_require__(/*! ./button-paragraph-justify.jsx */ "./src/components/buttons/button-paragraph-justify.jsx");

var _buttonParagraphJustify2 = _interopRequireDefault(_buttonParagraphJustify);

var _buttonQuote = __webpack_require__(/*! ./button-quote.jsx */ "./src/components/buttons/button-quote.jsx");

var _buttonQuote2 = _interopRequireDefault(_buttonQuote);

var _buttonRemoveFormat = __webpack_require__(/*! ./button-remove-format.jsx */ "./src/components/buttons/button-remove-format.jsx");

var _buttonRemoveFormat2 = _interopRequireDefault(_buttonRemoveFormat);

var _buttonRemoveImage = __webpack_require__(/*! ./button-remove-image.jsx */ "./src/components/buttons/button-remove-image.jsx");

var _buttonRemoveImage2 = _interopRequireDefault(_buttonRemoveImage);

var _buttonSeparator = __webpack_require__(/*! ./button-separator.jsx */ "./src/components/buttons/button-separator.jsx");

var _buttonSeparator2 = _interopRequireDefault(_buttonSeparator);

var _buttonSpacing = __webpack_require__(/*! ./button-spacing.jsx */ "./src/components/buttons/button-spacing.jsx");

var _buttonSpacing2 = _interopRequireDefault(_buttonSpacing);

var _buttonStrike = __webpack_require__(/*! ./button-strike.jsx */ "./src/components/buttons/button-strike.jsx");

var _buttonStrike2 = _interopRequireDefault(_buttonStrike);

var _buttonStylesListHeader = __webpack_require__(/*! ./button-styles-list-header.jsx */ "./src/components/buttons/button-styles-list-header.jsx");

var _buttonStylesListHeader2 = _interopRequireDefault(_buttonStylesListHeader);

var _buttonStylesListItemRemove = __webpack_require__(/*! ./button-styles-list-item-remove.jsx */ "./src/components/buttons/button-styles-list-item-remove.jsx");

var _buttonStylesListItemRemove2 = _interopRequireDefault(_buttonStylesListItemRemove);

var _buttonStylesListItem = __webpack_require__(/*! ./button-styles-list-item.jsx */ "./src/components/buttons/button-styles-list-item.jsx");

var _buttonStylesListItem2 = _interopRequireDefault(_buttonStylesListItem);

var _buttonStylesList = __webpack_require__(/*! ./button-styles-list.jsx */ "./src/components/buttons/button-styles-list.jsx");

var _buttonStylesList2 = _interopRequireDefault(_buttonStylesList);

var _buttonStyles = __webpack_require__(/*! ./button-styles.jsx */ "./src/components/buttons/button-styles.jsx");

var _buttonStyles2 = _interopRequireDefault(_buttonStyles);

var _buttonSubscript = __webpack_require__(/*! ./button-subscript.jsx */ "./src/components/buttons/button-subscript.jsx");

var _buttonSubscript2 = _interopRequireDefault(_buttonSubscript);

var _buttonSuperscript = __webpack_require__(/*! ./button-superscript.jsx */ "./src/components/buttons/button-superscript.jsx");

var _buttonSuperscript2 = _interopRequireDefault(_buttonSuperscript);

var _buttonTableCell = __webpack_require__(/*! ./button-table-cell.jsx */ "./src/components/buttons/button-table-cell.jsx");

var _buttonTableCell2 = _interopRequireDefault(_buttonTableCell);

var _buttonTableColumn = __webpack_require__(/*! ./button-table-column.jsx */ "./src/components/buttons/button-table-column.jsx");

var _buttonTableColumn2 = _interopRequireDefault(_buttonTableColumn);

var _buttonTableEdit = __webpack_require__(/*! ./button-table-edit.jsx */ "./src/components/buttons/button-table-edit.jsx");

var _buttonTableEdit2 = _interopRequireDefault(_buttonTableEdit);

var _buttonTableHeading = __webpack_require__(/*! ./button-table-heading.jsx */ "./src/components/buttons/button-table-heading.jsx");

var _buttonTableHeading2 = _interopRequireDefault(_buttonTableHeading);

var _buttonTableRemove = __webpack_require__(/*! ./button-table-remove.jsx */ "./src/components/buttons/button-table-remove.jsx");

var _buttonTableRemove2 = _interopRequireDefault(_buttonTableRemove);

var _buttonTableRow = __webpack_require__(/*! ./button-table-row.jsx */ "./src/components/buttons/button-table-row.jsx");

var _buttonTableRow2 = _interopRequireDefault(_buttonTableRow);

var _buttonTable = __webpack_require__(/*! ./button-table.jsx */ "./src/components/buttons/button-table.jsx");

var _buttonTable2 = _interopRequireDefault(_buttonTable);

var _buttonTargetList = __webpack_require__(/*! ./button-target-list.jsx */ "./src/components/buttons/button-target-list.jsx");

var _buttonTargetList2 = _interopRequireDefault(_buttonTargetList);

var _buttonTwitter = __webpack_require__(/*! ./button-twitter.jsx */ "./src/components/buttons/button-twitter.jsx");

var _buttonTwitter2 = _interopRequireDefault(_buttonTwitter);

var _buttonUl = __webpack_require__(/*! ./button-ul.jsx */ "./src/components/buttons/button-ul.jsx");

var _buttonUl2 = _interopRequireDefault(_buttonUl);

var _buttonUnderline = __webpack_require__(/*! ./button-underline.jsx */ "./src/components/buttons/button-underline.jsx");

var _buttonUnderline2 = _interopRequireDefault(_buttonUnderline);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.default = (_ButtonAccessibilityI = {}, _defineProperty(_ButtonAccessibilityI, _buttonAccessibilityImageAlt2.default.key, _buttonAccessibilityImageAlt2.default), _defineProperty(_ButtonAccessibilityI, _buttonBackgroundColor2.default.key, _buttonBackgroundColor2.default), _defineProperty(_ButtonAccessibilityI, _buttonBold2.default.key, _buttonBold2.default), _defineProperty(_ButtonAccessibilityI, _buttonCameraImage2.default.key, _buttonCameraImage2.default), _defineProperty(_ButtonAccessibilityI, _buttonCamera2.default.key, _buttonCamera2.default), _defineProperty(_ButtonAccessibilityI, _buttonCode2.default.key, _buttonCode2.default), _defineProperty(_ButtonAccessibilityI, _buttonColor2.default.key, _buttonColor2.default), _defineProperty(_ButtonAccessibilityI, _buttonCommandListItem2.default.key, _buttonCommandListItem2.default), _defineProperty(_ButtonAccessibilityI, _buttonCommandsList2.default.key, _buttonCommandsList2.default), _defineProperty(_ButtonAccessibilityI, _buttonDropdown2.default.key, _buttonDropdown2.default), _defineProperty(_ButtonAccessibilityI, _buttonEmbedEdit2.default.key, _buttonEmbedEdit2.default), _defineProperty(_ButtonAccessibilityI, _buttonEmbed2.default.key, _buttonEmbed2.default), _defineProperty(_ButtonAccessibilityI, _buttonEmbedVideoEdit2.default.key, _buttonEmbedVideoEdit2.default), _defineProperty(_ButtonAccessibilityI, _buttonEmbedVideo2.default.key, _buttonEmbedVideo2.default), _defineProperty(_ButtonAccessibilityI, _buttonH2.default.key, _buttonH2.default), _defineProperty(_ButtonAccessibilityI, _buttonH4.default.key, _buttonH4.default), _defineProperty(_ButtonAccessibilityI, _buttonHline2.default.key, _buttonHline2.default), _defineProperty(_ButtonAccessibilityI, _buttonImageAlignCenter2.default.key, _buttonImageAlignCenter2.default), _defineProperty(_ButtonAccessibilityI, _buttonImageAlignLeft2.default.key, _buttonImageAlignLeft2.default), _defineProperty(_ButtonAccessibilityI, _buttonImageAlignRight2.default.key, _buttonImageAlignRight2.default), _defineProperty(_ButtonAccessibilityI, _buttonImage2.default.key, _buttonImage2.default), _defineProperty(_ButtonAccessibilityI, _buttonIndentBlock2.default.key, _buttonIndentBlock2.default), _defineProperty(_ButtonAccessibilityI, _buttonItalic2.default.key, _buttonItalic2.default), _defineProperty(_ButtonAccessibilityI, _buttonItemSelectorAudio2.default.key, _buttonItemSelectorAudio2.default), _defineProperty(_ButtonAccessibilityI, _buttonItemSelectorImage2.default.key, _buttonItemSelectorImage2.default), _defineProperty(_ButtonAccessibilityI, _buttonItemSelectorVideo2.default.key, _buttonItemSelectorVideo2.default), _defineProperty(_ButtonAccessibilityI, _buttonLinkAutocompleteList2.default.key, _buttonLinkAutocompleteList2.default), _defineProperty(_ButtonAccessibilityI, _buttonLinkBrowse2.default.key, _buttonLinkBrowse2.default), _defineProperty(_ButtonAccessibilityI, _buttonLinkEditBrowse2.default.key, _buttonLinkEditBrowse2.default), _defineProperty(_ButtonAccessibilityI, _buttonLinkEdit2.default.key, _buttonLinkEdit2.default), _defineProperty(_ButtonAccessibilityI, _buttonLinkTargetEdit2.default.key, _buttonLinkTargetEdit2.default), _defineProperty(_ButtonAccessibilityI, _buttonLink2.default.key, _buttonLink2.default), _defineProperty(_ButtonAccessibilityI, _buttonOl2.default.key, _buttonOl2.default), _defineProperty(_ButtonAccessibilityI, _buttonOutdentBlock2.default.key, _buttonOutdentBlock2.default), _defineProperty(_ButtonAccessibilityI, _buttonParagraphAlign2.default.key, _buttonParagraphAlign2.default), _defineProperty(_ButtonAccessibilityI, _buttonParagraphAlignLeft2.default.key, _buttonParagraphAlignLeft2.default), _defineProperty(_ButtonAccessibilityI, _buttonParagraphAlignRight2.default.key, _buttonParagraphAlignRight2.default), _defineProperty(_ButtonAccessibilityI, _buttonParagraphCenter2.default.key, _buttonParagraphCenter2.default), _defineProperty(_ButtonAccessibilityI, _buttonParagraphJustify2.default.key, _buttonParagraphJustify2.default), _defineProperty(_ButtonAccessibilityI, _buttonQuote2.default.key, _buttonQuote2.default), _defineProperty(_ButtonAccessibilityI, _buttonRemoveFormat2.default.key, _buttonRemoveFormat2.default), _defineProperty(_ButtonAccessibilityI, _buttonRemoveImage2.default.key, _buttonRemoveImage2.default), _defineProperty(_ButtonAccessibilityI, _buttonSeparator2.default.key, _buttonSeparator2.default), _defineProperty(_ButtonAccessibilityI, _buttonSpacing2.default.key, _buttonSpacing2.default), _defineProperty(_ButtonAccessibilityI, _buttonStrike2.default.key, _buttonStrike2.default), _defineProperty(_ButtonAccessibilityI, _buttonStylesListHeader2.default.key, _buttonStylesListHeader2.default), _defineProperty(_ButtonAccessibilityI, _buttonStylesListItemRemove2.default.key, _buttonStylesListItemRemove2.default), _defineProperty(_ButtonAccessibilityI, _buttonStylesListItem2.default.key, _buttonStylesListItem2.default), _defineProperty(_ButtonAccessibilityI, _buttonStylesList2.default.key, _buttonStylesList2.default), _defineProperty(_ButtonAccessibilityI, _buttonStyles2.default.key, _buttonStyles2.default), _defineProperty(_ButtonAccessibilityI, _buttonSubscript2.default.key, _buttonSubscript2.default), _defineProperty(_ButtonAccessibilityI, _buttonSuperscript2.default.key, _buttonSuperscript2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableCell2.default.key, _buttonTableCell2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableColumn2.default.key, _buttonTableColumn2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableEdit2.default.key, _buttonTableEdit2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableHeading2.default.key, _buttonTableHeading2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableRemove2.default.key, _buttonTableRemove2.default), _defineProperty(_ButtonAccessibilityI, _buttonTableRow2.default.key, _buttonTableRow2.default), _defineProperty(_ButtonAccessibilityI, _buttonTable2.default.key, _buttonTable2.default), _defineProperty(_ButtonAccessibilityI, _buttonTargetList2.default.key, _buttonTargetList2.default), _defineProperty(_ButtonAccessibilityI, _buttonTwitter2.default.key, _buttonTwitter2.default), _defineProperty(_ButtonAccessibilityI, _buttonUl2.default.key, _buttonUl2.default), _defineProperty(_ButtonAccessibilityI, _buttonUnderline2.default.key, _buttonUnderline2.default), _ButtonAccessibilityI);

/***/ }),

/***/ "./src/components/main.jsx":
/*!*********************************!*\
  !*** ./src/components/main.jsx ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _propTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _widgetExclusive = __webpack_require__(/*! ./base/widget-exclusive */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ./base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _editorContext = __webpack_require__(/*! ../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The main editor UI class manages a hierarchy of widgets (toolbars and buttons).
 *
 * @class UI
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 */
var UI = function (_React$Component) {
	_inherits(UI, _React$Component);

	/**
  * Lifecycle. Returns the default values of the properties used in the widget.
  *
  * @instance
  * @memberof UI
  * @method getDefaultProps
  * @return {Object} The default properties.
  */
	function UI(props) {
		_classCallCheck(this, UI);

		var _this = _possibleConstructorReturn(this, (UI.__proto__ || Object.getPrototypeOf(UI)).call(this, props));

		_this._onDismissToolbarFocus = function () {
			var editor = _this.context.editor.get('nativeEditor');

			editor.focus();
		};

		_this.state = {
			hidden: false
		};
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client, immediately after the initial rendering occurs.
  *
  * @instance
  * @memberof UI
  * @method componentDidMount
  */


	_createClass(UI, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var _this2 = this;

			var editor = this.context.editor.get('nativeEditor');

			editor.on('editorInteraction', this._onEditorInteraction, this);
			editor.on('actionPerformed', this._onActionPerformed, this);
			editor.on('key', this._onEditorKey, this);

			// Set up events for hiding the UI when user stops interacting with the editor.
			// This may happen when he just clicks outside of the editor. However,
			// this does not include a situation when he clicks on some button, part of
			// editor's UI.

			// It is not easy to debounce _setUIHidden on mousedown, because if we
			// debounce it, when the handler is being invoked, the target might be no more part
			// of the editor's UI - onActionPerformed causes re-render.
			this._mousedownListener = function (event) {
				_this2._setUIHidden(event.target);
			};

			this._keyDownListener = CKEDITOR.tools.debounce(function (_event) {
				_this2._setUIHidden(document.activeElement);
			}, this.props.eventsDelay, this);

			document.addEventListener('mousedown', this._mousedownListener);
			document.addEventListener('keydown', this._keyDownListener);
		}

		/**
   * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
   * Fires `ariaUpdate` event passing ARIA related messages.
   * Fires `editorUpdate` event passing the previous and current properties and state.
   *
   * @instance
   * @memberof UI
   * @method componentDidUpdate
   */

	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps, prevState) {
			var domNode = _reactDom2.default.findDOMNode(this);

			var editor = this.context.editor.get('nativeEditor');

			if (domNode) {
				editor.fire('ariaUpdate', {
					message: this._getAvailableToolbarsMessage(domNode)
				});
			}

			editor.fire('editorUpdate', {
				prevProps: prevProps,
				prevState: prevState,
				props: this.props,
				state: this.state
			});
		}
	}, {
		key: '_getAriaUpdateTemplate',
		value: function _getAriaUpdateTemplate(ariaUpdate) {
			if (!this._ariaUpdateTemplates) {
				this._ariaUpdateTemplates = {};
			}

			if (!this._ariaUpdateTemplates[ariaUpdate]) {
				this._ariaUpdateTemplates[ariaUpdate] = new CKEDITOR.template(this._getAriaUpdates()[ariaUpdate]);
			}

			return this._ariaUpdateTemplates[ariaUpdate];
		}

		/**
   * Returns the templates for ARIA messages.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _getAriaUpdates
   * @return {Object} ARIA relates messages. Default:
   * {
   *      noToolbar: AlloyEditor.Strings.ariaUpdateNoToolbar,
   *      oneToolbar: AlloyEditor.Strings.ariaUpdateOneToolbar,
   *      manyToolbars: AlloyEditor.Strings.ariaUpdateManyToolbars
   *  }
   */

	}, {
		key: '_getAriaUpdates',
		value: function _getAriaUpdates() {
			return this.props.ariaUpdates || {
				noToolbar: AlloyEditor.Strings.ariaUpdateNoToolbar,
				oneToolbar: AlloyEditor.Strings.ariaUpdateOneToolbar,
				manyToolbars: AlloyEditor.Strings.ariaUpdateManyToolbars
			};
		}

		/**
   * Returns an ARIA message which represents the number of currently available toolbars.
   *
   * @instance
   * @memberof UI
   * @method _getAvailableToolbarsMessage
   * @protected
   * @param {CKEDITOR.dom.element} domNode The DOM node from which the available toolbars will be retrieved.
   * @return {String} The ARIA message for the number of available toolbars
   */

	}, {
		key: '_getAvailableToolbarsMessage',
		value: function _getAvailableToolbarsMessage(domNode) {
			var toolbarsNodeList = domNode.querySelectorAll('[role="toolbar"]');

			if (!toolbarsNodeList.length) {
				return this._getAriaUpdates().noToolbar;
			} else {
				var toolbarNames = Array.prototype.slice.call(toolbarsNodeList).map(function (toolbar) {
					return toolbar.getAttribute('aria-label');
				});

				var ariaUpdate = toolbarNames.length === 1 ? 'oneToolbar' : 'manyToolbars';

				return this._getAriaUpdateTemplate(ariaUpdate).output({
					toolbars: toolbarNames.join(',').replace(/,([^,]*)$/, ' and ' + '$1')
				});
			}
		}

		/**
   * Lifecycle. Invoked immediately before a component is unmounted from the DOM.
   *
   * @instance
   * @memberof UI
   * @method componentWillUnmount
   */

	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			if (this._mousedownListener) {
				document.removeEventListener('mousedown', this._mousedownListener);
			}

			if (this._keyDownListener) {
				this._keyDownListener.detach();
				document.removeEventListener('keydown', this._keyDownListener);
			}
		}

		/**
   * Lifecycle. Renders the UI of the editor. This may include several toolbars and buttons.
   * The editor's UI also takes care of rendering the items in exclusive mode.
   *
   * @instance
   * @memberof UI
   * @method render
   * @return {Object} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var _this3 = this;

			if (this.state.hidden) {
				return null;
			}

			var toolbars = Object.keys(this.props.toolbars).map(function (toolbar) {
				return AlloyEditor.Toolbars[toolbar] || window[toolbar];
			});

			toolbars = this.filterExclusive(toolbars).map(function (toolbar) {
				var props = _this3.mergeExclusiveProps({
					config: _this3.props.toolbars[toolbar.key],
					editor: _this3.context.editor,
					editorEvent: _this3.state.editorEvent,
					key: toolbar.key,
					onDismiss: _this3._onDismissToolbarFocus,
					selectionData: _this3.state.selectionData
				}, toolbar.key);

				return _react2.default.createElement(toolbar, props);
			});

			return _react2.default.createElement(
				'div',
				{ className: 'ae-toolbars', onKeyDown: this.handleKey },
				toolbars
			);
		}

		/**
   * Listener to the editor's `actionPerformed` event. Sets state and redraws the UI of the editor.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _onActionPerformed
   * @param {SynteticEvent} event The provided event
   */

	}, {
		key: '_onActionPerformed',
		value: function _onActionPerformed(_event) {
			var editor = this.context.editor.get('nativeEditor');

			editor.focus();

			this.setState({
				itemExclusive: null,
				selectionData: editor.getSelectionData()
			});
		}

		/**
   * Executed when a dismiss key is pressed over a toolbar to return the focus to the editor.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _onDismissToolbarFocus
   */

	}, {
		key: '_onEditorInteraction',


		/**
   * Listener to the editor's `userInteraction` event. Retrieves the data about the user selection and
   * provides it via component's state property.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _onEditorInteraction
   * @param {SynteticEvent} event The provided event
   */
		value: function _onEditorInteraction(event) {
			this.setState({
				editorEvent: event,
				hidden: false,
				itemExclusive: null,
				selectionData: event.data.selectionData
			});
		}

		/**
   * Focuses on the active toolbar when the combination ALT+F10 is pressed inside the editor.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _onEditorKey
   */

	}, {
		key: '_onEditorKey',
		value: function _onEditorKey(event) {
			var nativeEvent = event.data.domEvent.$;

			if (nativeEvent.altKey && nativeEvent.keyCode === 121) {
				this.focus();
			}
		}

		/**
   * Checks if the target with which the user interacted is part of editor's UI or it is
   * the editable area. If none of these, sets the state of editor's UI to be hidden.
   *
   * @instance
   * @memberof UI
   * @protected
   * @method _setUIHidden
   * @param {DOMElement} target The DOM element with which user interacted lastly.
   */

	}, {
		key: '_setUIHidden',
		value: function _setUIHidden(target) {
			var domNode = _reactDom2.default.findDOMNode(this);

			if (domNode) {
				var editable = this.context.editor.get('nativeEditor').editable();
				var parentNode = target.parentNode;
				var targetNode = new CKEDITOR.dom.node(target);

				if (!editable) {
					this.setState({
						hidden: true
					});
				} else {
					var res = editable.$ === target || editable.contains(targetNode) || new CKEDITOR.dom.element(domNode).contains(targetNode);

					if (parentNode) {
						res = res || parentNode.id === 'ckimgrsz';
					}

					if (!res) {
						this.setState({
							hidden: true
						});
					}
				}
			}
		}
	}]);

	return UI;
}(_react2.default.Component);

/**
 * Fired when component updates and when it is rendered in the DOM.
 * The payload consists from a `message` property containing the ARIA message.
 *
 * @event ariaUpdate
 */

/**
 * Fired when component updates. The payload consists from an object with the following
 * properties:
 * - prevProps - The previous properties of the component
 * - prevState - The previous state of the component
 * - props - The current properties of the component
 * - state - The current state of the component
 *
 * @event ariaUpdate
 */

UI.contextType = _editorContext2.default;
UI.defaultProps = {
	circular: true,
	descendants: '[class^=ae-toolbar-]',
	eventsDelay: 0,
	keys: {
		next: 9
	}
};
UI.propTypes = {
	/**
  * Localized messages for live aria updates. Should include the following messages:
  * - noToolbar: Notification for no available toolbar in the editor.
  * - oneToolbar: Notification for just one available toolbar in the editor.
  * - manyToolbars: Notification for more than one available toolbar in the editor.
  *
  * @instance
  * @memberof UI
  * @property {Object} ariaUpdates
  */
	ariaUpdates: _propTypes2.default.object,

	/**
  * The delay (ms), after which key or mouse events will be processed.
  *
  * @instance
  * @memberof UI
  * @property {Number} eventsDelay
  */
	eventsDelay: _propTypes2.default.number,

	/**
  * The toolbars configuration for this editor instance
  *
  * @instance
  * @memberof UI
  * @property {Object} toolbars
  */
	toolbars: _propTypes2.default.object.isRequired
};
exports.default = (0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)(UI));

/***/ }),

/***/ "./src/components/toolbars/index.js":
/*!******************************************!*\
  !*** ./src/components/toolbars/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _ToolbarAdd$key$Toolb;

var _toolbarAdd = __webpack_require__(/*! ./toolbar-add.jsx */ "./src/components/toolbars/toolbar-add.jsx");

var _toolbarAdd2 = _interopRequireDefault(_toolbarAdd);

var _toolbarStyles = __webpack_require__(/*! ./toolbar-styles.jsx */ "./src/components/toolbars/toolbar-styles.jsx");

var _toolbarStyles2 = _interopRequireDefault(_toolbarStyles);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

exports.default = (_ToolbarAdd$key$Toolb = {}, _defineProperty(_ToolbarAdd$key$Toolb, _toolbarAdd2.default.key, _toolbarAdd2.default), _defineProperty(_ToolbarAdd$key$Toolb, _toolbarStyles2.default.key, _toolbarStyles2.default), _ToolbarAdd$key$Toolb);

/***/ }),

/***/ "./src/components/toolbars/toolbar-add.jsx":
/*!*************************************************!*\
  !*** ./src/components/toolbars/toolbar-add.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _toolbarButtons = __webpack_require__(/*! ../base/toolbar-buttons */ "./src/components/base/toolbar-buttons.js");

var _toolbarButtons2 = _interopRequireDefault(_toolbarButtons);

var _widgetArrowBox = __webpack_require__(/*! ../base/widget-arrow-box */ "./src/components/base/widget-arrow-box.js");

var _widgetArrowBox2 = _interopRequireDefault(_widgetArrowBox);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetExclusive = __webpack_require__(/*! ../base/widget-exclusive */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _widgetPosition = __webpack_require__(/*! ../base/widget-position */ "./src/components/base/widget-position.js");

var _widgetPosition2 = _interopRequireDefault(_widgetPosition);

var _buttonIcon = __webpack_require__(/*! ../buttons/button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var POSITION_LEFT = 1;
var POSITION_RIGHT = 2;

/**
 * The ToolbarAdd class provides functionality for adding content to the editor.
 *
 * @class ToolbarAdd
 * @uses ToolbarButtons
 * @uses WidgetArrowBox
 * @uses WidgetDropdown
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 * @uses WidgetPosition
 */

var ToolbarAdd = function (_React$Component) {
	_inherits(ToolbarAdd, _React$Component);

	function ToolbarAdd(props) {
		_classCallCheck(this, ToolbarAdd);

		var _this = _possibleConstructorReturn(this, (ToolbarAdd.__proto__ || Object.getPrototypeOf(ToolbarAdd)).call(this, props));

		_this.state = {};
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client (not on the server),
  * immediately after the initial rendering occurs.
  *
  * @instance
  * @memberof ToolbarAdd
  * @method componentDidMount
  */


	_createClass(ToolbarAdd, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this._updatePosition();
		}

		/**
   * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ToolbarAdd
   * @method componentDidUpdate
   * @param {Object} prevProps The previous state of the component's properties.
   * @param {Object} prevState Component's previous state.
   */

	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(_prevProps, _prevState) {
			this._updatePosition();

			// In case of exclusive rendering, focus the first descendant (button)
			// so the user will be able to start interacting with the buttons immediately.
			if (this.props.renderExclusive) {
				this.focus();
			}
		}

		/**
   * Lifecycle. Renders the buttons for adding content or hides the toolbar
   * if user interacted with a non-editable element.
   *
   * @instance
   * @memberof ToolbarAdd
   * @method render
   * @return {Object|null} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			// Some operations such as `requestExclusive` may force editor to blur which will
			// invalidate the `props.editorEvent` stored value, without causing a `props` change.
			// For example, if the editor is empty, `ae_placeholder` plugin will remove
			// the target from the DOM and will prevent `add` toolbar from rendering.
			//
			// It should be safe to assume that if you have been able to render the toolbar
			// and request the exclusive mode, then rendering might be kept until the exclusive mode is left.
			if (!this.state.itemExclusive && this.props.editorEvent && this.props.editorEvent.data.nativeEvent.target && !this.props.editorEvent.data.nativeEvent.target.isContentEditable) {
				return null;
			}

			var buttons = this._getButtons();
			var className = this._getToolbarClassName();

			return _react2.default.createElement(
				'div',
				{
					'aria-label': AlloyEditor.Strings.add,
					className: className,
					'data-tabindex': this.props.config.tabIndex || 0,
					onFocus: this.focus.bind(this),
					onKeyDown: this.handleKey.bind(this),
					role: 'toolbar',
					tabIndex: '-1' },
				_react2.default.createElement(
					'div',
					{ className: 'ae-container' },
					buttons
				)
			);
		}

		/**
   * Returns a list of buttons that will eventually render to HTML.
   *
   * @instance
   * @memberof ToolbarAdd
   * @method _getButtons
   * @protected
   * @return {Object} The buttons which have to be rendered.
   */

	}, {
		key: '_getButtons',
		value: function _getButtons() {
			var buttons = void 0;

			if (this.props.renderExclusive) {
				buttons = this.getToolbarButtons(this.props.config.buttons);
			} else {
				if (this.props.selectionData && this.props.selectionData.region) {
					buttons = _react2.default.createElement(
						'button',
						{
							'aria-label': AlloyEditor.Strings.add,
							className: 'ae-button ae-button-add',
							onClick: this.props.requestExclusive.bind(this, ToolbarAdd.key),
							title: AlloyEditor.Strings.add },
						_react2.default.createElement(_buttonIcon2.default, { symbol: 'plus' })
					);
				}
			}

			return buttons;
		}

		/**
   * Returns the class name of the toolbar in case of both exclusive and normal mode.
   *
   * @instance
   * @memberof ToolbarAdd
   * @method _getToolbarClassName
   * @protected
   * @return {String} The class name which have to be applied to the DOM element.
   */

	}, {
		key: '_getToolbarClassName',
		value: function _getToolbarClassName() {
			var cssClass = 'ae-toolbar-add';

			if (this.props.renderExclusive) {
				cssClass = 'ae-toolbar ' + this.getArrowBoxClasses();
			}

			return cssClass;
		}

		/**
   * Calculates and sets the position of the toolbar in exclusive or normal mode.
   *
   * @instance
   * @memberof ToolbarAdd
   * @method _updatePosition
   * @protected
   */

	}, {
		key: '_updatePosition',
		value: function _updatePosition() {
			var region = void 0;

			// If component is not mounted, there is nothing to do
			if (!_reactDom2.default.findDOMNode(this)) {
				return;
			}

			if (this.props.renderExclusive) {
				this.updatePosition();
				this.show();
			} else {
				if (this.props.selectionData) {
					region = this.props.selectionData.region;
				}

				if (region) {
					var domNode = _reactDom2.default.findDOMNode(this);

					var domElement = new CKEDITOR.dom.element(domNode);

					var startRect = region.startRect || region;

					var nativeEditor = this.context.editor.get('nativeEditor');

					var clientRect = nativeEditor.editable().getClientRect();

					var offsetLeft = void 0;

					var position = this.props.config.position || this.props.position;

					if (position === POSITION_LEFT) {
						offsetLeft = clientRect.left - domNode.offsetWidth - this.props.gutterExclusive.left + 'px';
					} else {
						offsetLeft = clientRect.right + this.props.gutterExclusive.left + 'px';
					}

					domNode.style.left = offsetLeft;

					domNode.style.top = Math.floor((region.bottom + region.top) / 2) + 'px';

					var uiNode = this.context.editor.get('uiNode');

					var scrollTop = uiNode ? uiNode.scrollTop : 0;

					if (nativeEditor.element.getStyle('overflow') !== 'auto') {
						domNode.style.top = Math.floor(region.top - domNode.offsetHeight / 2 + startRect.height / 2 + scrollTop) + 'px';
					} else {
						domNode.style.top = Math.floor(nativeEditor.element.$.offsetTop + startRect.height / 2 - domNode.offsetHeight / 2) + 'px';
					}

					domNode.style.opacity = 1;

					domElement.removeClass('ae-arrow-box');

					this.cancelAnimation();
				}
			}
		}
	}]);

	return ToolbarAdd;
}(_react2.default.Component);

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default add
 * @memberof ToolbarAdd
 * @property {String} key
 * @static
 */


ToolbarAdd.contextType = _editorContext2.default;
ToolbarAdd.key = 'add';

/**
 * Defines the constant for positioning the Toolbar on left of the editable area.
 *
 * @default 1
 * @memberof ToolbarAdd
 * @property {String} left
 * @static
 */
ToolbarAdd.left = POSITION_LEFT;

/**
 * Defines the constant for positioning the Toolbar on right of the editable area.
 *
 * @default 2
 * @memberof ToolbarAdd
 * @property {String} right
 * @static
 */
ToolbarAdd.right = POSITION_RIGHT;

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ToolbarAdd
 * @method getDefaultProps
 * @return {Object} The default properties.
 */
ToolbarAdd.defaultProps = {
	circular: true,
	descendants: '.ae-button',
	gutterExclusive: {
		left: 10,
		top: 0
	},
	keys: {
		dismiss: [27],
		next: [39, 40],
		prev: [37, 38]
	},
	position: POSITION_LEFT
};

exports.default = (0, _widgetArrowBox2.default)((0, _widgetDropdown2.default)((0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)((0, _widgetPosition2.default)((0, _toolbarButtons2.default)(ToolbarAdd))))));

/***/ }),

/***/ "./src/components/toolbars/toolbar-styles.jsx":
/*!****************************************************!*\
  !*** ./src/components/toolbars/toolbar-styles.jsx ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

var _toolbarButtons = __webpack_require__(/*! ../base/toolbar-buttons */ "./src/components/base/toolbar-buttons.js");

var _toolbarButtons2 = _interopRequireDefault(_toolbarButtons);

var _widgetArrowBox = __webpack_require__(/*! ../base/widget-arrow-box */ "./src/components/base/widget-arrow-box.js");

var _widgetArrowBox2 = _interopRequireDefault(_widgetArrowBox);

var _widgetDropdown = __webpack_require__(/*! ../base/widget-dropdown */ "./src/components/base/widget-dropdown.js");

var _widgetDropdown2 = _interopRequireDefault(_widgetDropdown);

var _widgetExclusive = __webpack_require__(/*! ../base/widget-exclusive */ "./src/components/base/widget-exclusive.js");

var _widgetExclusive2 = _interopRequireDefault(_widgetExclusive);

var _widgetFocusManager = __webpack_require__(/*! ../base/widget-focus-manager */ "./src/components/base/widget-focus-manager.js");

var _widgetFocusManager2 = _interopRequireDefault(_widgetFocusManager);

var _widgetPosition = __webpack_require__(/*! ../base/widget-position */ "./src/components/base/widget-position.js");

var _widgetPosition2 = _interopRequireDefault(_widgetPosition);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

var _lang = __webpack_require__(/*! ../../oop/lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The ToolbarStyles class hosts the buttons for styling a text selection.
 *
 * @class ToolbarStyles
 * @uses ToolbarButtons
 * @uses WidgetArrowBox
 * @uses WidgetDropdown
 * @uses WidgetExclusive
 * @uses WidgetFocusManager
 * @uses WidgetPosition
 */
var ToolbarStyles = function (_React$Component) {
	_inherits(ToolbarStyles, _React$Component);

	function ToolbarStyles(props) {
		_classCallCheck(this, ToolbarStyles);

		var _this = _possibleConstructorReturn(this, (ToolbarStyles.__proto__ || Object.getPrototypeOf(ToolbarStyles)).call(this, props));

		_this.state = {};
		return _this;
	}

	/**
  * Lifecycle. Invoked once, only on the client (not on the server),
  * immediately after the initial rendering occurs.
  *
  * @instance
  * @memberof ToolbarStyles
  * @method componentDidMount
  */


	_createClass(ToolbarStyles, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this._updatePosition();
		}

		/**
   * Lifecycle. Invoked immediately after the component's updates are flushed to the DOM.
   * This method is not called for the initial render.
   *
   * @instance
   * @memberof ToolbarStyles
   * @method componentDidUpdate
   * @param {Object} prevProps The previous state of the component's properties.
   * @param {Object} prevState Component's previous state.
   */

	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(_prevProps, _prevState) {
			this._updatePosition();
		}

		/**
   * Lifecycle. Renders the buttons for adding content or hides the toolbar
   * if user interacted with a non-editable element.
   *
   * @instance
   * @memberof ToolbarStyles
   * @method render
   * @return {Object|null} The content which should be rendered.
   */

	}, {
		key: 'render',
		value: function render() {
			var currentSelection = this._getCurrentSelection();

			if (currentSelection) {
				var getArrowBoxClassesFn = this._getSelectionFunction(currentSelection.getArrowBoxClasses);
				var arrowBoxClasses = void 0;

				if (getArrowBoxClassesFn) {
					arrowBoxClasses = getArrowBoxClassesFn();
				} else {
					arrowBoxClasses = this.getArrowBoxClasses();
				}

				var cssClasses = 'ae-toolbar-styles ' + arrowBoxClasses;

				var buttons = currentSelection.buttons;

				if ((typeof buttons === 'undefined' ? 'undefined' : _typeof(buttons)) === 'object' && !Array.isArray(buttons)) {
					buttons = buttons[this.context.editor.get('mode')] || buttons['simple'];
				}

				var buttonsGroup = this.getToolbarButtonGroups(buttons, {
					manualSelection: this.props.editorEvent ? this.props.editorEvent.data.manualSelection : null,
					selectionType: currentSelection.name
				});

				var hasGroups = buttonsGroup.filter(function (button) {
					return Array.isArray(button);
				}).length > 0;

				var className = 'ae-container';

				if (hasGroups) {
					className += ' ae-container-column';
				}

				return _react2.default.createElement(
					'div',
					{
						'aria-label': AlloyEditor.Strings.styles,
						className: cssClasses,
						'data-tabindex': this.props.config.tabIndex || 0,
						onFocus: this.focus.bind(this),
						onKeyDown: this.handleKey.bind(this),
						role: 'toolbar',
						tabIndex: '-1' },
					_react2.default.createElement(
						'div',
						{ className: className },
						buttonsGroup.map(function (value, index) {
							if (Array.isArray(value)) {
								return _react2.default.createElement(
									'div',
									{ className: 'ae-row', key: index },
									value.map(function (button) {
										return button;
									})
								);
							} else {
								return value;
							}
						})
					)
				);
			}

			return null;
		}

		/**
   * Retrieve a function from String. It converts a fully qualified string into the mapped function.
   *
   * @instance
   * @memberof ToolbarStyles
   * @method _getSelectionFunction
   * @param {Function|String} selectionFn A function, or a fully qualified string pointing to the desired one (e.g. 'AlloyEditor.SelectionTest.image').
   * @protected
   * @return {Function} The mapped function.
   */

	}, {
		key: '_getSelectionFunction',
		value: function _getSelectionFunction(selectionFn) {
			var selectionFunction = void 0;

			if (_lang2.default.isFunction(selectionFn)) {
				selectionFunction = selectionFn;
			} else if (_lang2.default.isString(selectionFn)) {
				var parts = selectionFn.split('.');
				var currentMember = window;
				var property = parts.shift();

				while (property && _lang2.default.isObject(currentMember) && _lang2.default.isObject(currentMember[property])) {
					currentMember = currentMember[property];
					property = parts.shift();
				}

				if (_lang2.default.isFunction(currentMember)) {
					selectionFunction = currentMember;
				}
			}

			return selectionFunction;
		}

		/**
   * Analyzes the current editor selection and returns the selection configuration that matches.
   *
   * @instance
   * @memberof ToolbarStyles
   * @method _getCurrentSelection
   * @protected
   * @return {Object} The matched selection configuration.
   */

	}, {
		key: '_getCurrentSelection',
		value: function _getCurrentSelection() {
			var eventPayload = this.props.editorEvent ? this.props.editorEvent.data : null;
			var selection = void 0;

			if (eventPayload) {
				this.props.config.selections.some(function (item) {
					var testFn = this._getSelectionFunction(item.test);
					var result = void 0;

					if (testFn) {
						result = eventPayload.manualSelection === item.name || testFn({
							data: eventPayload,
							editor: this.context.editor
						});
					}

					if (result) {
						selection = item;
					}

					return result;
				}, this);
			}

			return selection;
		}

		/**
   * Calculates and sets the position of the toolbar.
   *
   * @instance
   * @memberof ToolbarStyles
   * @method _updatePosition
   * @protected
   */

	}, {
		key: '_updatePosition',
		value: function _updatePosition() {
			// If component is not mounted, there is nothing to do
			if (!_reactDom2.default.findDOMNode(this)) {
				return;
			}

			var currentSelection = this._getCurrentSelection();
			var result = void 0;

			// If current selection has a function called `setPosition`, call it
			// and check the returned value. If false, fallback to the default positioning logic.
			if (currentSelection) {
				var setPositionFn = this._getSelectionFunction(currentSelection.setPosition);

				if (setPositionFn) {
					result = setPositionFn.call(this, {
						editor: this.context.editor,
						editorEvent: this.props.editorEvent,
						selectionData: this.props.selectionData
					});
				}
			}

			if (!result) {
				this.updatePosition();
				this.show();
			}
		}
	}]);

	return ToolbarStyles;
}(_react2.default.Component);

/**
 * Lifecycle. Returns the default values of the properties used in the widget.
 *
 * @instance
 * @memberof ToolbarStyles
 * @method getDefaultProps
 * @return {Object} The default properties.
 */


ToolbarStyles.contextType = _editorContext2.default;
ToolbarStyles.defaultProps = {
	circular: true,
	descendants: '.ae-input, .ae-button:not([disabled]), .ae-toolbar-element',
	keys: {
		dismiss: [27],
		next: [39, 40],
		prev: [37, 38]
	}
};

/**
 * The name which will be used as an alias of the button in the configuration.
 *
 * @default styles
 * @memberof ToolbarStyles
 * @property {String} key
 * @static
 */
ToolbarStyles.key = 'styles';

exports.default = (0, _widgetArrowBox2.default)((0, _widgetDropdown2.default)((0, _widgetExclusive2.default)((0, _widgetFocusManager2.default)((0, _widgetPosition2.default)((0, _toolbarButtons2.default)(ToolbarStyles))))));

/***/ }),

/***/ "./src/components/uibridge/button.jsx":
/*!********************************************!*\
  !*** ./src/components/uibridge/button.jsx ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_buttonbridge')) {
	var BUTTON_DEFS = {};

	/**
  * Generates a ButtonBridge React class for a given button definition if it has not been
  * already created based on the button name and definition.
  *
  * @private
  * @method generateButtonBridge
  * @param {String} buttonName The button's name
  * @param {Object} buttonDefinition The button's definition
  * @return {Object} The generated or already existing React Button Class
  */

	function generateButtonBridge(buttonName, buttonDefinition, editor) {
		var ButtonBridge = AlloyEditor.Buttons[buttonName];

		BUTTON_DEFS[editor.name] = BUTTON_DEFS[editor.name] || {};
		BUTTON_DEFS[editor.name][buttonName] = BUTTON_DEFS[editor.name][buttonName] || buttonDefinition;

		if (!ButtonBridge) {
			var _class, _temp2;

			ButtonBridge = (_temp2 = _class = function (_React$Component) {
				_inherits(ButtonBridge, _React$Component);

				function ButtonBridge() {
					var _ref;

					var _temp, _this, _ret;

					_classCallCheck(this, ButtonBridge);

					for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
						args[_key] = arguments[_key];
					}

					return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ButtonBridge.__proto__ || Object.getPrototypeOf(ButtonBridge)).call.apply(_ref, [this].concat(args))), _this), _this._handleClick = function () {
						var editor = _this.context.editor.get('nativeEditor');

						var buttonCommand = BUTTON_DEFS[editor.name][buttonName].command;

						var buttonOnClick = BUTTON_DEFS[editor.name][buttonName].onClick;

						if (buttonOnClick) {
							buttonOnClick.call(_this);
						} else {
							editor.execCommand(buttonCommand);
						}

						editor.fire('actionPerformed', _this);
					}, _temp), _possibleConstructorReturn(_this, _ret);
				}

				_createClass(ButtonBridge, [{
					key: 'toFeature',


					// API not yet implemented inside the button
					// bridge. By mocking the unsupported method, we prevent
					// plugins from crashing if they make use of it.
					value: function toFeature() {}
				}, {
					key: 'render',
					value: function render() {
						var editor = this.context.editor.get('nativeEditor');

						var buttonClassName = 'ae-button ae-button-bridge';

						var buttonDisplayName = BUTTON_DEFS[editor.name][buttonName].name || BUTTON_DEFS[editor.name][buttonName].command || buttonName;

						var buttonLabel = BUTTON_DEFS[editor.name][buttonName].label;

						var buttonType = 'button-' + buttonDisplayName;

						var iconClassName = 'ae-icon-' + buttonDisplayName;

						var iconStyle = {};

						var cssStyle = CKEDITOR.skin.getIconStyle(buttonDisplayName);

						if (cssStyle) {
							var cssStyleParts = cssStyle.split(';');

							iconStyle.backgroundImage = cssStyleParts[0].substring(cssStyleParts[0].indexOf(':') + 1);
							iconStyle.backgroundPosition = cssStyleParts[1].substring(cssStyleParts[1].indexOf(':') + 1);
							iconStyle.backgroundSize = cssStyleParts[2].substring(cssStyleParts[2].indexOf(':') + 1);
						}

						return _react2.default.createElement(
							'button',
							{
								'aria-label': buttonLabel,
								className: buttonClassName,
								'data-type': buttonType,
								onClick: this._handleClick,
								tabIndex: this.props.tabIndex,
								title: buttonLabel },
							_react2.default.createElement('span', { className: iconClassName, style: iconStyle })
						);
					}
				}]);

				return ButtonBridge;
			}(_react2.default.Component), _class.contextType = _editorContext2.default, _class.displayName = buttonName, _class.key = buttonName, _temp2);

			AlloyEditor.Buttons[buttonName] = ButtonBridge;
		}

		return ButtonBridge;
	}

	/* istanbul ignore else */
	if (!CKEDITOR.plugins.get('button')) {
		CKEDITOR.UI_BUTTON = 'button';

		CKEDITOR.plugins.add('button', {});
	}

	/**
  * CKEditor plugin that bridges the support offered by CKEditor Button plugin. It takes over the
  * responsibility of registering and creating buttons via:
  * - editor.ui.addButton(name, definition)
  * - editor.ui.add(name, CKEDITOR.UI_BUTTON, definition)
  *
  * @class CKEDITOR.plugins.ae_buttonbridge
  * @requires CKEDITOR.plugins.ae_uibridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_buttonbridge', {
		requires: ['ae_uibridge'],

		/**
   * Set the add handler for UI_BUTTON to our own. We do this in the init phase to override
   * the one in the native plugin in case it's present.
   *
   * @method init
   * @param {Object} editor The CKEditor instance being initialized
   */
		beforeInit: function beforeInit(editor) {
			editor.ui.addButton = function (buttonName, buttonDefinition) {
				this.add(buttonName, CKEDITOR.UI_BUTTON, buttonDefinition);
			};

			editor.ui.addHandler(CKEDITOR.UI_BUTTON, {
				add: generateButtonBridge,
				create: function create(buttonDefinition) {
					var buttonName = 'buttonBridge' + (Math.random() * 1e9 >>> 0);
					var ButtonBridge = generateButtonBridge(buttonName, buttonDefinition);

					return new ButtonBridge();
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/components/uibridge/index.js":
/*!******************************************!*\
  !*** ./src/components/uibridge/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./button.jsx */ "./src/components/uibridge/button.jsx");

__webpack_require__(/*! ./menu-button.jsx */ "./src/components/uibridge/menu-button.jsx");

__webpack_require__(/*! ./menu.jsx */ "./src/components/uibridge/menu.jsx");

__webpack_require__(/*! ./panel-menu-button.jsx */ "./src/components/uibridge/panel-menu-button.jsx");

__webpack_require__(/*! ./richcombo.jsx */ "./src/components/uibridge/richcombo.jsx");

__webpack_require__(/*! ./uibridge */ "./src/components/uibridge/uibridge.js");

/***/ }),

/***/ "./src/components/uibridge/menu-button.jsx":
/*!*************************************************!*\
  !*** ./src/components/uibridge/menu-button.jsx ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonDropdown = __webpack_require__(/*! ../buttons/button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_menubuttonbridge')) {
	var MENUBUTTON_DEFS = {};

	/**
  * Generates a MenuButtonBridge React class for a given menuButton definition if it has not been
  * already created based on the button name and definition.
  *
  * @private
  * @method generateMenuButtonBridge
  * @param {String} menuButtonName The menuButton's name
  * @param {Object} menuButtonDefinition The menuButton's definition
  * @return {Object} The generated or already existing React MenuButton Class
  */
	function generateMenuButtonBridge(menuButtonName, menuButtonDefinition, editor) {
		var MenuButtonBridge = AlloyEditor.Buttons[menuButtonName];

		MENUBUTTON_DEFS[editor.name] = MENUBUTTON_DEFS[editor.name] || {};
		MENUBUTTON_DEFS[editor.name][menuButtonName] = MENUBUTTON_DEFS[editor.name][menuButtonName] || menuButtonDefinition;

		if (!MenuButtonBridge) {
			var _class, _temp;

			MenuButtonBridge = (_temp = _class = function (_React$Component) {
				_inherits(MenuButtonBridge, _React$Component);

				function MenuButtonBridge() {
					_classCallCheck(this, MenuButtonBridge);

					return _possibleConstructorReturn(this, (MenuButtonBridge.__proto__ || Object.getPrototypeOf(MenuButtonBridge)).apply(this, arguments));
				}

				_createClass(MenuButtonBridge, [{
					key: 'toFeature',


					// API not yet implemented inside the menubutton
					// bridge. By mocking the unsupported method, we prevent
					// plugins from crashing if they make use of it.
					value: function toFeature() {}
				}, {
					key: 'render',
					value: function render() {
						var editor = this.context.editor.get('nativeEditor');

						var panelMenuButtonDisplayName = MENUBUTTON_DEFS[editor.name][menuButtonName].name || MENUBUTTON_DEFS[editor.name][menuButtonName].command || menuButtonName;

						var buttonClassName = 'ae-button ae-button-bridge';

						var iconClassName = 'ae-icon-' + panelMenuButtonDisplayName;

						var iconStyle = {};

						var cssStyle = CKEDITOR.skin.getIconStyle(panelMenuButtonDisplayName);

						if (cssStyle) {
							var cssStyleParts = cssStyle.split(';');

							iconStyle.backgroundImage = cssStyleParts[0].substring(cssStyleParts[0].indexOf(':') + 1);
							iconStyle.backgroundPosition = cssStyleParts[1].substring(cssStyleParts[1].indexOf(':') + 1);
							iconStyle.backgroundSize = cssStyleParts[2].substring(cssStyleParts[2].indexOf(':') + 1);
						}

						return _react2.default.createElement(
							'div',
							{ className: 'ae-container ae-has-dropdown' },
							_react2.default.createElement(
								'button',
								{
									'aria-expanded': this.props.expanded,
									'aria-label': MENUBUTTON_DEFS[editor.name][menuButtonName].label,
									className: buttonClassName,
									onClick: this.props.toggleDropdown,
									role: 'combobox',
									tabIndex: this.props.tabIndex,
									title: MENUBUTTON_DEFS[editor.name][menuButtonName].label },
								_react2.default.createElement('span', {
									className: iconClassName,
									style: iconStyle
								})
							),
							this.props.expanded && _react2.default.createElement(
								_buttonDropdown2.default,
								{
									onDismiss: this.props.toggleDropdown },
								this._getMenuItems()
							)
						);
					}
				}, {
					key: '_getMenuItems',
					value: function _getMenuItems() {
						var editor = this.context.editor.get('nativeEditor');
						var items = menuButtonDefinition.onMenu();
						var menuItems = Object.keys(items).map(function (key) {
							var menuItem = editor.getMenuItem(key);

							if (!menuItem) {
								return null;
							}

							var menuItemDefinition = menuItem.definition || menuItem;
							var menuItemState = items[key];

							var className = 'ae-toolbar-element ' + (menuItemState === CKEDITOR.TRISTATE_ON ? 'active' : '');
							var disabled = menuItemState === CKEDITOR.TRISTATE_DISABLED;
							var onClick = function onClick() {
								if (menuItemDefinition.command) {
									editor.execCommand(menuItemDefinition.command);
								} else if (menuItemDefinition.onClick) {
									menuItemDefinition.onClick.apply(menuItemDefinition);
								}
							};

							return _react2.default.createElement(
								'li',
								{ key: menuItem.name, role: 'option' },
								_react2.default.createElement(
									'button',
									{
										className: className,
										disabled: disabled,
										onClick: onClick },
									menuItemDefinition.label
								)
							);
						});

						return menuItems;
					}
				}]);

				return MenuButtonBridge;
			}(_react2.default.Component), _class.contextType = _editorContext2.default, _class.displayName = menuButtonName, _class.key = menuButtonName, _temp);

			AlloyEditor.Buttons[menuButtonName] = MenuButtonBridge;
		}

		return MenuButtonBridge;
	}

	/* istanbul ignore else */
	if (!CKEDITOR.plugins.get('menubutton')) {
		CKEDITOR.UI_MENU_BUTTON = 'menubutton';

		CKEDITOR.plugins.add('menubutton', {});
	}

	/**
  * CKEditor plugin that bridges the support offered by CKEditor MenuButton plugin. It takes over the
  * responsibility of registering and creating menuButtons via:
  * - editor.ui.addMenuButton(name, definition)
  * - editor.ui.add(name, CKEDITOR.UI_MENUBUTTON, definition)
  *
  * @class CKEDITOR.plugins.ae_menubuttonbridge
  * @requires CKEDITOR.plugins.ae_uibridge
  * @requires CKEDITOR.plugins.ae_menubridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_menubuttonbridge', {
		requires: ['ae_uibridge', 'ae_menubridge'],

		/**
   * Set the add handler for UI_MENUBUTTON to our own. We do this in the init phase to override
   * the one in the native plugin in case it's present.
   *
   * @method init
   * @param {Object} editor The CKEditor instance being initialized
   */
		beforeInit: function beforeInit(editor) {
			editor.ui.addMenuButton = function (menuButtonName, menuButtonDefinition) {
				this.add(menuButtonName, CKEDITOR.UI_MENUBUTTON, menuButtonDefinition);
			};

			editor.ui.addHandler(CKEDITOR.UI_MENUBUTTON, {
				add: generateMenuButtonBridge,
				create: function create(menuButtonDefinition) {
					var menuButtonName = 'buttonBridge' + (Math.random() * 1e9 >>> 0);
					var MenuButtonBridge = generateMenuButtonBridge(menuButtonName, menuButtonDefinition);

					return new MenuButtonBridge();
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/components/uibridge/menu.jsx":
/*!******************************************!*\
  !*** ./src/components/uibridge/menu.jsx ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_menubridge')) {
	/**
  * CKEditor plugin that bridges the support offered by CKEditor Menu plugin. It takes over the
  * responsibility of adding, removing and retrieving menu groups and items
  * - editor.addMenuGroup(name, order)
  * - editor.addMenuItem(name, definition)
  * - editor.addMenuItems(definitions)
  * - editor.getMenuItem(name)
  * - editor.removeMenuItem(name)
  *
  * @class CKEDITOR.plugins.ae_menubridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_menubridge', {
		/**
   * Set the add handler for UI_BUTTON to our own. We do this in the init phase to override
   * the one in the native plugin in case it's present.
   *
   * @method init
   * @param {Object} editor The CKEditor instance being initialized
   */
		beforeInit: function beforeInit(editor) {
			// Do nothing if the real menu plugin is present
			if (CKEDITOR.plugins.get('menu')) {
				return;
			}

			var groups = [];
			var groupsOrder = editor._.menuGroups = {};
			var menuItems = editor._.menuItems = {};

			for (var i = 0; i < groups.length; i++) {
				groupsOrder[groups[i]] = i + 1;
			}

			/**
    * Registers an item group to the editor context menu in order to make it
    * possible to associate it with menu items later.
    *
    * @method addMenuGroup
    * @param {String} name Specify a group name.
    * @param {Number} [order=100] Define the display sequence of this group
    * inside the menu. A smaller value gets displayed first.
    */
			editor.addMenuGroup = function (name, order) {
				groupsOrder[name] = order || 100;
			};

			/**
    * Adds an item from the specified definition to the editor context menu.
    *
    * @method addMenuItem
    * @param {String} name The menu item name.
    * @param {Object} definition The menu item definition.
    */
			editor.addMenuItem = function (name, definition) {
				if (groupsOrder[definition.group]) {
					menuItems[name] = {
						name: name,
						definition: definition
					};
				}
			};

			/**
    * Adds one or more items from the specified definition object to the editor context menu.
    *
    * @method addMenuItems
    * @param {Object} definitions Object where keys are used as itemName and corresponding values as definition for a {@link #addMenuItem} call.
    */
			editor.addMenuItems = function (definitions) {
				for (var itemName in definitions) {
					if (definitions.hasOwnProperty(itemName)) {
						this.addMenuItem(itemName, definitions[itemName]);
					}
				}
			};

			/**
    * Retrieves a particular menu item definition from the editor context menu.
    *
    * @method getMenuItem
    * @param {String} name The name of the desired menu item.
    * @return {Object}
    */
			editor.getMenuItem = function (name) {
				return menuItems[name];
			};

			/**
    * Removes a particular menu item added before from the editor context menu.
    *
    * @method  removeMenuItem
    * @param {String} name The name of the desired menu item.
    */
			editor.removeMenuItem = function (name) {
				delete menuItems[name];
			};
		}
	});
}

/***/ }),

/***/ "./src/components/uibridge/panel-menu-button.jsx":
/*!*******************************************************!*\
  !*** ./src/components/uibridge/panel-menu-button.jsx ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonDropdown = __webpack_require__(/*! ../buttons/button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_panelmenubuttonbridge')) {
	var PANEL_MENU_DEFS = {};

	/**
  * Generates a PanelMenuButtonBridge React class for a given panelmenubutton definition if it has not been
  * already created based on the panelmenubutton name and definition.
  *
  * @private
  * @method generatePanelMenuButtonBridge
  * @param {String} panelMenuButtonName The panel button name
  * @param {Object} panelMenuButtonDefinition The panel button definition
  * @return {Object} The generated or already existing React PanelMenuButton Class
  */
	var generatePanelMenuButtonBridge = function generatePanelMenuButtonBridge(panelMenuButtonName, panelMenuButtonDefinition, editor) {
		var PanelMenuButtonBridge = AlloyEditor.Buttons[panelMenuButtonName];

		PANEL_MENU_DEFS[editor.name] = PANEL_MENU_DEFS[editor.name] || {};
		PANEL_MENU_DEFS[editor.name][panelMenuButtonName] = PANEL_MENU_DEFS[editor.name][panelMenuButtonName] || panelMenuButtonDefinition;

		if (!PanelMenuButtonBridge) {
			var _class, _temp;

			PanelMenuButtonBridge = (_temp = _class = function (_React$Component) {
				_inherits(PanelMenuButtonBridge, _React$Component);

				function PanelMenuButtonBridge() {
					_classCallCheck(this, PanelMenuButtonBridge);

					return _possibleConstructorReturn(this, (PanelMenuButtonBridge.__proto__ || Object.getPrototypeOf(PanelMenuButtonBridge)).apply(this, arguments));
				}

				_createClass(PanelMenuButtonBridge, [{
					key: 'createPanel',


					// API not yet implemented inside the panel menu button bridge. By mocking the unsupported methods, we
					// prevent plugins from crashing if they make use of them.
					value: function createPanel() {}
				}, {
					key: 'render',
					value: function render() {
						var editor = this.context.editor.get('nativeEditor');

						var panelMenuButtonDisplayName = PANEL_MENU_DEFS[editor.name][panelMenuButtonName].name || PANEL_MENU_DEFS[editor.name][panelMenuButtonName].command || panelMenuButtonName;

						var buttonClassName = 'ae-button ae-button-bridge';

						var iconClassName = 'ae-icon-' + panelMenuButtonDisplayName;

						var iconStyle = {};

						var cssStyle = CKEDITOR.skin.getIconStyle(panelMenuButtonDisplayName);

						if (cssStyle) {
							var cssStyleParts = cssStyle.split(';');

							iconStyle.backgroundImage = cssStyleParts[0].substring(cssStyleParts[0].indexOf(':') + 1);
							iconStyle.backgroundPosition = cssStyleParts[1].substring(cssStyleParts[1].indexOf(':') + 1);
							iconStyle.backgroundSize = cssStyleParts[2].substring(cssStyleParts[2].indexOf(':') + 1);
						}

						var panel = void 0;

						if (this.props.expanded) {
							panel = this._getPanel();
						}

						return _react2.default.createElement(
							'div',
							{ className: 'ae-container ae-has-dropdown' },
							_react2.default.createElement(
								'button',
								{
									'aria-expanded': this.props.expanded,
									'aria-label': PANEL_MENU_DEFS[editor.name][panelMenuButtonName].label,
									className: buttonClassName,
									onClick: this.props.toggleDropdown,
									role: 'combobox',
									tabIndex: this.props.tabIndex,
									title: PANEL_MENU_DEFS[editor.name][panelMenuButtonName].label },
								_react2.default.createElement('span', {
									className: iconClassName,
									style: iconStyle
								})
							),
							panel
						);
					}
				}, {
					key: '_getPanel',
					value: function _getPanel() {
						var editor = this.context.editor.get('nativeEditor');

						var panelMenuButtonOnBlock = PANEL_MENU_DEFS[editor.name][panelMenuButtonName].onBlock;

						var panel = {
							hide: this.props.toggleDropdown,
							show: this.props.toggleDropdown
						};

						var blockElement = new CKEDITOR.dom.element('div');

						var block = {
							element: blockElement,
							keys: {}
						};

						/* istanbul ignore else */
						if (panelMenuButtonOnBlock) {
							panelMenuButtonOnBlock.call(this, panel, block);
						}

						// TODO
						// Use block.keys to configure the panel keyboard navigation

						return _react2.default.createElement(
							_buttonDropdown2.default,
							{ onDismiss: this.props.toggleDropdown },
							_react2.default.createElement('div', {
								className: blockElement.getAttribute('class'),
								dangerouslySetInnerHTML: {
									__html: blockElement.getHtml()
								}
							})
						);
					}
				}]);

				return PanelMenuButtonBridge;
			}(_react2.default.Component), _class.contextType = _editorContext2.default, _class.displayName = panelMenuButtonName, _class.key = panelMenuButtonName, _temp);

			AlloyEditor.Buttons[panelMenuButtonName] = PanelMenuButtonBridge;
		}

		return PanelMenuButtonBridge;
	};

	/* istanbul ignore else */
	if (!CKEDITOR.plugins.get('panelmenubutton')) {
		CKEDITOR.UI_PANELBUTTON = 'panelmenubutton';

		CKEDITOR.plugins.add('panelmenubutton', {});
	}

	/* istanbul ignore else */
	if (!CKEDITOR.plugins.get('panelbutton')) {
		CKEDITOR.UI_PANELBUTTON = 'panelbutton';

		CKEDITOR.plugins.add('panelbutton', {});
	}

	/**
  * CKEditor plugin that bridges the support offered by CKEditor PanelButton plugin. It takes over the
  * responsibility of registering and creating buttons via:
  * - editor.ui.addPanelMenuButton(name, definition)
  * - editor.ui.add(name, CKEDITOR.UI_PANELBUTTON, definition)
  *
  * @class CKEDITOR.plugins.ae_panelmenubuttonbridge
  * @requires CKEDITOR.plugins.ae_uibridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_panelmenubuttonbridge', {
		requires: ['ae_uibridge'],

		/**
   * Set the add handler for UI_PANELBUTTON to our own. We do this in the init phase to override
   * the one in the native plugin in case it's present
   *
   * @method init
   * @param {Object} editor The CKEditor instance being initialized
   */
		beforeInit: function beforeInit(editor) {
			editor.ui.addPanelMenuButton = function (panelMenuButtonName, panelMenuButtonDefinition) {
				this.add(panelMenuButtonName, CKEDITOR.UI_PANELBUTTON, panelMenuButtonDefinition);
			};

			editor.ui.addHandler(CKEDITOR.UI_PANELBUTTON, {
				add: generatePanelMenuButtonBridge,
				create: function create(panelMenuButtonDefinition) {
					var panelMenuButtonName = 'panelMenuButtonBridge' + (Math.random() * 1e9 >>> 0);
					var PanelMenuButtonBridge = generatePanelMenuButtonBridge(panelMenuButtonName, panelMenuButtonDefinition);

					return new PanelMenuButtonBridge();
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/components/uibridge/richcombo.jsx":
/*!***********************************************!*\
  !*** ./src/components/uibridge/richcombo.jsx ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(/*! react */ "react");

var _react2 = _interopRequireDefault(_react);

var _buttonDropdown = __webpack_require__(/*! ../buttons/button-dropdown.jsx */ "./src/components/buttons/button-dropdown.jsx");

var _buttonDropdown2 = _interopRequireDefault(_buttonDropdown);

var _buttonIcon = __webpack_require__(/*! ../buttons/button-icon.jsx */ "./src/components/buttons/button-icon.jsx");

var _buttonIcon2 = _interopRequireDefault(_buttonIcon);

var _editorContext = __webpack_require__(/*! ../../adapter/editor-context */ "./src/adapter/editor-context.js");

var _editorContext2 = _interopRequireDefault(_editorContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_richcombobridge')) {
	var RICH_COMBO_DEFS = {};

	/**
  * Generates a RichComboBridge React class for a given richcombo definition if it has not been
  * already created based on the richcombo name and definition.
  *
  * @method generateRichComboBridge
  * @private
  * @param {String} richComboName The rich combo name
  * @param {Object} richComboDefinition The rich combo definition
  * @return {Object} The generated or already existing React RichCombo Class
  */
	var generateRichComboBridge = function generateRichComboBridge(richComboName, richComboDefinition, editor) {
		var RichComboBridge = AlloyEditor.Buttons[richComboName];

		RICH_COMBO_DEFS[editor.name] = RICH_COMBO_DEFS[editor.name] || {};
		RICH_COMBO_DEFS[editor.name][richComboName] = RICH_COMBO_DEFS[editor.name][richComboName] || richComboDefinition;
		RICH_COMBO_DEFS[editor.name][richComboName].currentValue = undefined;

		if (!RichComboBridge) {
			var _class, _temp;

			RichComboBridge = (_temp = _class = function (_React$Component) {
				_inherits(RichComboBridge, _React$Component);

				function RichComboBridge(props) {
					_classCallCheck(this, RichComboBridge);

					var _this = _possibleConstructorReturn(this, (RichComboBridge.__proto__ || Object.getPrototypeOf(RichComboBridge)).call(this, props));

					_this._onClick = function (event) {
						var editor = _this.context.editor.get('nativeEditor');

						var editorCombo = RICH_COMBO_DEFS[editor.name][richComboName];

						if (editorCombo.onClick) {
							var newValue = event.currentTarget.getAttribute('data-value');

							editorCombo.onClick.call(_this, newValue);

							RICH_COMBO_DEFS[editor.name][richComboName].currentValue = newValue;

							editor.fire('actionPerformed', _this);
						}
					};

					_this.state = {
						value: RICH_COMBO_DEFS[editor.name][richComboName].currentValue
					};
					return _this;
				}

				// API not yet implemented inside the richcombo bridge. By mocking the unsupported methods, we
				// prevent plugins from crashing if they make use of them.


				_createClass(RichComboBridge, [{
					key: 'commit',
					value: function commit() {}
				}, {
					key: 'createPanel',
					value: function createPanel() {}
				}, {
					key: 'disable',
					value: function disable() {}
				}, {
					key: 'enable',
					value: function enable() {}
				}, {
					key: 'getState',
					value: function getState() {}
				}, {
					key: 'hideGroup',
					value: function hideGroup() {}
				}, {
					key: 'hideItem',
					value: function hideItem() {}
				}, {
					key: 'mark',
					value: function mark() {}
				}, {
					key: 'showAll',
					value: function showAll() {}
				}, {
					key: 'startGroup',
					value: function startGroup() {}
				}, {
					key: 'unmarkAll',
					value: function unmarkAll() {}
				}, {
					key: 'add',
					value: function add(value, preview, title) {
						this._items.push({
							preview: preview,
							title: title,
							value: value
						});
					}
				}, {
					key: 'componentWillMount',
					value: function componentWillMount() {
						var editor = this.context.editor.get('nativeEditor');

						var editorCombo = RICH_COMBO_DEFS[editor.name][richComboName];

						this._items = [];

						this.setValue = this._setValue;

						if (editorCombo.init) {
							editorCombo.init.call(this);
						}

						if (editorCombo.onRender) {
							editorCombo.onRender.call(this);
						}
					}
				}, {
					key: 'componentWillUnmount',
					value: function componentWillUnmount() {
						this._cacheValue(this.state.value);

						this.setValue = this._cacheValue;
					}
				}, {
					key: 'getValue',
					value: function getValue() {
						return this.state.value;
					}
				}, {
					key: 'render',
					value: function render() {
						var editor = this.context.editor.get('nativeEditor');

						var richComboLabel = RICH_COMBO_DEFS[editor.name][richComboName].currentValue || richComboDefinition.label;

						return _react2.default.createElement(
							'div',
							{ className: 'ae-container-dropdown ae-has-dropdown' },
							_react2.default.createElement(
								'button',
								{
									'aria-expanded': this.props.expanded,
									'aria-label': richComboLabel,
									className: 'ae-toolbar-element',
									onClick: this.props.toggleDropdown,
									role: 'combobox',
									tabIndex: this.props.tabIndex,
									title: richComboLabel },
								_react2.default.createElement(
									'div',
									{ className: 'ae-container' },
									_react2.default.createElement(
										'span',
										{ className: 'ae-container-dropdown-selected-item' },
										richComboLabel
									),
									_react2.default.createElement(_buttonIcon2.default, { symbol: 'caret-bottom' })
								)
							),
							this.props.expanded && _react2.default.createElement(
								_buttonDropdown2.default,
								{
									onDismiss: this.props.toggleDropdown },
								this._getItems()
							)
						);
					}
				}, {
					key: '_cacheValue',
					value: function _cacheValue(value) {
						var editor = this.context.editor.get('nativeEditor');

						RICH_COMBO_DEFS[editor.name][richComboName].currentValue = value;
					}
				}, {
					key: '_getItems',
					value: function _getItems() {
						var richCombo = this;

						var items = this._items.map(function (item) {
							var className = 'ae-toolbar-element ' + (item.value === this.state.value ? 'active' : '');

							return _react2.default.createElement(
								'li',
								{ key: item.title, role: 'option' },
								_react2.default.createElement('button', {
									className: className,
									dangerouslySetInnerHTML: {
										__html: item.preview
									},
									'data-value': item.value,
									onClick: richCombo._onClick
								})
							);
						}.bind(this));

						return items;
					}
				}, {
					key: '_setValue',
					value: function _setValue(value) {
						this._cacheValue(value);

						this.setState({
							value: value
						});
					}
				}]);

				return RichComboBridge;
			}(_react2.default.Component), _class.contextType = _editorContext2.default, _class.displayName = richComboName, _class.key = richComboName, _temp);

			AlloyEditor.Buttons[richComboName] = RichComboBridge;
		}

		return RichComboBridge;
	};

	/* istanbul ignore else */
	if (!CKEDITOR.plugins.get('richcombo')) {
		CKEDITOR.UI_RICHCOMBO = 'richcombo';

		CKEDITOR.plugins.add('richcombo', {});
	}

	/**
  * CKEditor plugin that bridges the support offered by CKEditor RichCombo plugin. It takes over the
  * responsibility of registering and creating rich combo elements via:
  * - editor.ui.addRichCombo(name, definition)
  * - editor.ui.add(name, CKEDITOR.UI_RICHCOMBO, definition)
  *
  * @class CKEDITOR.plugins.ae_richcombobridge
  * @requires CKEDITOR.plugins.ae_uibridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_richcombobridge', {
		requires: ['ae_uibridge'],

		/**
   * Set the add handler for UI_RICHCOMBO to our own. We do this in the init phase to override
   * the one in the original plugin in case it's present
   *
   * @method init
   * @param {Object} editor The CKEditor instance being initialized
   */
		beforeInit: function beforeInit(editor) {
			editor.ui.addRichCombo = function (richComboName, richComboDefinition) {
				this.add(richComboName, CKEDITOR.UI_RICHCOMBO, richComboDefinition);
			};

			editor.ui.addHandler(CKEDITOR.UI_RICHCOMBO, {
				add: generateRichComboBridge,
				create: function create(richComboDefinition) {
					var richComboName = 'richComboBridge' + (Math.random() * 1e9 >>> 0);
					var RichComboBridge = generateRichComboBridge(richComboName, richComboDefinition);

					return new RichComboBridge();
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/components/uibridge/uibridge.js":
/*!*********************************************!*\
  !*** ./src/components/uibridge/uibridge.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_uibridge')) {
	/**
  * CKEditor plugin that extends CKEDITOR.ui.add function so an add handler can be specified
  * on top of the original ones. It bridges the calls to add components via:
  * - editor.ui.add(name, type, definition)
  *
  * @class CKEDITOR.plugins.ae_uibridge
  * @constructor
  */
	CKEDITOR.plugins.add('ae_uibridge', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   *
   * @method beforeInit
   * @param {Object} editor The current editor instance
   */
		beforeInit: function beforeInit(editor) {
			var originalUIAddFn = editor.ui.add;

			editor.ui.add = function (name, type, definition) {
				originalUIAddFn.call(this, name, type, definition);

				var typeHandler = this._.handlers[type];

				if (typeHandler && typeHandler.add) {
					typeHandler.add(name, definition, editor);
					AlloyEditor.registerBridgeButton(name, editor.__processingPlugin__.plugin.name);
				}
			};
		}
	});
}

/***/ }),

/***/ "./src/core/debounce.js":
/*!******************************!*\
  !*** ./src/core/debounce.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Debounce util function. If a function execution is expensive, it might be debounced. This means
 * that it will be executed after some amount of time after its last call. For example, if we attach a
 * a function on scroll event, it might be called hundreds times per second. In this case it may be
 * debounced with, let's say 100ms. The real execution of this function will happen 100ms after last
 * scroll event.
 *
 * @memberof CKEDITOR.tools
 * @method debounce
 * @param {Array} args An array of arguments which the callback will receive.
 * @param {Function} callback The callback which has to be called after given timeout.
 * @param {Number} timeout Timeout in milliseconds after which the callback will be called.
 * @param {Object} context The context in which the callback will be called. This argument is optional.
 * @static
 */
function debounce(callback, timeout, context) {
  var args = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

  var debounceHandle = void 0;

  var callFn = function callFn() {
    for (var _len = arguments.length, callArgs = Array(_len), _key = 0; _key < _len; _key++) {
      callArgs[_key] = arguments[_key];
    }

    /* eslint-disable babel/no-invalid-this */
    var callContext = context || this;
    /* eslint-enable babel/no-invalid-this */

    clearTimeout(debounceHandle);

    debounceHandle = setTimeout(function () {
      callback.apply(callContext, [].concat(callArgs, _toConsumableArray(args)));
    }, timeout);
  };

  callFn.detach = function () {
    clearTimeout(debounceHandle);
  };

  return callFn;
}

CKEDITOR.tools.debounce = CKEDITOR.tools.debounce || debounce;

exports.default = debounce;

/***/ }),

/***/ "./src/core/index.js":
/*!***************************!*\
  !*** ./src/core/index.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debounce = undefined;

var _debounce = __webpack_require__(/*! ./debounce */ "./src/core/debounce.js");

var _debounce2 = _interopRequireDefault(_debounce);

__webpack_require__(/*! ./link */ "./src/core/link.js");

__webpack_require__(/*! ./plugins */ "./src/core/plugins.js");

__webpack_require__(/*! ./selection-region */ "./src/core/selection-region.js");

__webpack_require__(/*! ./table */ "./src/core/table.js");

__webpack_require__(/*! ./tools */ "./src/core/tools.js");

__webpack_require__(/*! ./uicore */ "./src/core/uicore.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.debounce = _debounce2.default;

/***/ }),

/***/ "./src/core/link.js":
/*!**************************!*\
  !*** ./src/core/link.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var REGEX_BOOKMARK_SCHEME = /^#.*/i;
var REGEX_EMAIL_SCHEME = /^[a-z0-9\u0430-\u044F._-]+@/i;
var REGEX_URI_SCHEME = /^(?:[a-z][a-z0-9+\-.]*):|^\//i;

/**
 * Link class utility. Provides methods for create, delete and update links.
 *
 * @class CKEDITOR.Link
 * @constructor
 * @param {Object} editor The CKEditor instance.
 */
function Link(editor, config) {
	this._editor = editor;
	this.appendProtocol = config && config.appendProtocol === false ? false : true;
}

Link.prototype = {
	constructor: Link,

	/**
  * Advances the editor selection to the next available position after a
  * given link or the one in the current selection.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method advanceSelection
  * @param {CKEDITOR.dom.element} link The link element which link style should be removed.
  */
	advanceSelection: function advanceSelection(link) {
		link = link || this.getFromSelection();

		var range = this._editor.getSelection().getRanges()[0];

		if (link) {
			range.moveToElementEditEnd(link);

			var nextNode = range.getNextEditableNode();

			if (nextNode && !this._editor.element.equals(nextNode.getCommonAncestor(link))) {
				var whitespace = /\s/.exec(nextNode.getText());

				var offset = whitespace ? whitespace.index + 1 : 0;

				range.setStart(nextNode, offset);
				range.setEnd(nextNode, offset);
			}
		}

		this._editor.getSelection().selectRanges([range]);
	},


	/**
  * Create a link with given URI as href.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method create
  * @param {Object} attrs A config object with link attributes. These might be arbitrary DOM attributes.
  * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
  * @param {String} URI The URI of the link.
  */
	create: function create(URI, attrs, modifySelection) {
		var selection = this._editor.getSelection();

		var range = selection.getRanges()[0];

		if (range.collapsed) {
			var text = new CKEDITOR.dom.text(URI, this._editor.document);
			range.insertNode(text);
			range.selectNodeContents(text);
		}

		URI = this._getCompleteURI(URI);

		var linkAttrs = CKEDITOR.tools.merge({
			'data-cke-saved-href': URI,
			href: URI
		}, attrs);

		var style = new CKEDITOR.style({
			attributes: linkAttrs,
			element: 'a'
		});

		style.type = CKEDITOR.STYLE_INLINE;
		style.applyToRange(range, this._editor);

		if (modifySelection && modifySelection.advance) {
			this.advanceSelection();
		} else {
			range.select();
		}
	},


	/**
  * Retrieves a link from the current selection.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method getFromSelection
  * @return {CKEDITOR.dom.element} The retrieved link or null if not found.
  */
	getFromSelection: function getFromSelection() {
		var selection = this._editor.getSelection();

		var selectedElement = selection.getSelectedElement();

		if (selectedElement && selectedElement.is('a')) {
			return selectedElement;
		}

		if (selectedElement && CKEDITOR.env.ie) {
			var children = selectedElement.getChildren();

			var count = children.count();

			for (var i = 0; i < count; i++) {
				var node = children.getItem(i);

				if (node.is('a')) {
					return node;
				}
			}
		}

		var range = selection.getRanges()[0];

		if (range) {
			range.shrink(CKEDITOR.SHRINK_TEXT);

			return this._editor.elementPath(range.getCommonAncestor()).contains('a', 1);
		}

		return null;
	},


	/**
  * Removes a link from the editor.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method remove
  * @param {CKEDITOR.dom.element} link The link element which link style should be removed.
  * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
  */
	remove: function remove(link, modifySelection) {
		var editor = this._editor;

		if (link) {
			if (modifySelection && modifySelection.advance) {
				this.advanceSelection();
			}

			link.remove(editor);
		} else {
			var style = new CKEDITOR.style({
				alwaysRemoveElement: 1,
				element: 'a',
				type: CKEDITOR.STYLE_INLINE
			});

			// 'removeStyle()' removes the style from the editor's current selection.
			//  We need to force the selection to be the whole link element
			//  to remove it properly.

			var selection = editor.getSelection();
			selection.selectElement(selection.getStartElement());

			editor.removeStyle(style);
		}
	},


	/**
  * Updates the href of an already existing link.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method update
  * @param {CKEDITOR.dom.element} link The link element which href should be removed.
  * @param {Object|String} attrs The attributes to update or remove. Attributes with null values will be removed.
  * @param {Object} modifySelection A config object with an advance attribute to indicate if the selection should be moved after the link creation.
  */
	update: function update(attrs, link, modifySelection) {
		var instance = this;

		link = link || this.getFromSelection();

		if (typeof attrs === 'string') {
			var uri = instance._getCompleteURI(attrs);

			link.setAttributes({
				'data-cke-saved-href': uri,
				href: uri
			});
		} else if ((typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs)) === 'object') {
			var removeAttrs = [];

			var setAttrs = {};

			Object.keys(attrs).forEach(function (key) {
				if (attrs[key] === null) {
					if (key === 'href') {
						removeAttrs.push('data-cke-saved-href');
					}

					removeAttrs.push(key);
				} else {
					if (key === 'href') {
						var _uri = instance._getCompleteURI(attrs[key]);

						setAttrs['data-cke-saved-href'] = _uri;
						setAttrs[key] = _uri;
					} else {
						setAttrs[key] = attrs[key];
					}
				}
			});

			link.removeAttributes(removeAttrs);
			link.setAttributes(setAttrs);
		}

		if (modifySelection && modifySelection.advance) {
			this.advanceSelection(link);
		}
	},


	/**
  * Checks if the URI begins with a '#' symbol to determine if it's an on page bookmark.
  * If it doesn't, it then checks if the URI has an '@' symbol. If it does and the URI
  * looks like an email and doesn't have 'mailto:', 'mailto:' is added to the URI.
  * If it doesn't and the URI doesn't have a scheme, the default 'http' scheme with
  * hierarchical path '//' is added to the URI.
  *
  * @instance
  * @memberof CKEDITOR.Link
  * @method _getCompleteURI
  * @param {String} URI The URI of the link.
  * @protected
  * @return {String} The URI updated with the protocol.
  */
	_getCompleteURI: function _getCompleteURI(URI) {
		if (REGEX_BOOKMARK_SCHEME.test(URI)) {
			return URI;
		} else if (REGEX_EMAIL_SCHEME.test(URI)) {
			URI = 'mailto:' + URI;
		} else if (!REGEX_URI_SCHEME.test(URI)) {
			URI = this.appendProtocol ? 'http://' + URI : URI;
		}

		return URI;
	}
};

CKEDITOR.Link = CKEDITOR.Link || Link;

/***/ }),

/***/ "./src/core/plugins.js":
/*!*****************************!*\
  !*** ./src/core/plugins.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Wraps each of the plugin lifecycle methods in a closure that will
// set up the editor.__processingPlugin__ variable so it can be globally
// accessed exposing the plugin being processed and the lifecycle phase
// in which it is happening
//
// @param {Object} plugin The plugin to wrap lifecycle methods
var wrapPluginLifecycle = function wrapPluginLifecycle(plugin) {
	var methods = ['beforeInit', 'init', 'afterInit'];

	methods.forEach(function (methodName) {
		if (plugin[methodName]) {
			plugin[methodName] = CKEDITOR.tools.override(plugin[methodName], function (originalPluginMethod) {
				var payload = {
					phase: methodName,
					plugin: plugin
				};

				return function (editor) {
					editor.__processingPlugin__ = payload;

					// eslint-disable-next-line babel/no-invalid-this
					originalPluginMethod.call(this, editor);

					editor.__processingPlugin__ = null;
				};
			});
		}
	});
};

// Filters the requires object to remove unwanted dependencies. At this point
// only 'toolbar' has been identified, but more can appear. An unwanted plugin
// dependency is one that prevents a necessary plugin from being removed
//
// @param {string|Array<string>} requires The requires object
// @return {string} The filtered requires object
var filterUnwantedDependencies = function filterUnwantedDependencies(requires) {
	if (typeof requires === 'string') {
		requires = requires.split(',');
	}

	return requires.filter(function (require) {
		return require !== 'toolbar';
	});
};

/**
 * CKEDITOR.plugins class utility which adds additional methods to those of CKEditor.
 *
 * @class CKEDITOR.plugins
 */

/**
 * Overrides CKEDITOR.plugins.load method so we can extend the lifecycle methods of
 * the loaded plugins to add some metainformation about the plugin being processed
 *
 * @param {String/Array} names The name of the resource to load. It may be a
 * string with a single resource name, or an array with several names.
 * @param {Function} callback A function to be called when all resources
 * are loaded. The callback will receive an array containing all loaded names.
 * @param {Object} [scope] The scope object to be used for the callback call.
 * @memberof CKEDITOR.plugins
 * @method load
 * @static
 */
CKEDITOR.plugins.load = CKEDITOR.tools.override(CKEDITOR.plugins.load, function (pluginsLoad) {
	// Wrap original load function so we can transform the plugin input parameter
	// before passing it down to the original callback
	return function (names, callback, scope) {
		// eslint-disable-next-line babel/no-invalid-this
		pluginsLoad.call(this, names, function (plugins) {
			if (callback) {
				Object.keys(plugins).forEach(function (pluginName) {
					var plugin = plugins[pluginName];

					if (plugin.requires) {
						plugin.requires = filterUnwantedDependencies(plugin.requires);
					}

					wrapPluginLifecycle(plugin);
				});

				callback.call(scope, plugins);
			}
		});
	};
});

/***/ }),

/***/ "./src/core/selection-region.js":
/*!**************************************!*\
  !*** ./src/core/selection-region.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (!CKEDITOR.plugins.get('ae_selectionregion')) {
	CKEDITOR.SELECTION_TOP_TO_BOTTOM = 0;
	CKEDITOR.SELECTION_BOTTOM_TO_TOP = 1;
	CKEDITOR.SELECTION_LEFT_TO_RIGHT = 2;
	CKEDITOR.SELECTION_RIGHT_TO_LEFT = 3;

	/**
  * SelectionRegion utility class which provides metadata about the selection. The metadata may be the start and end
  * rectangles, caret region, etc. **This class is not intended to be used standalone. Its functions will
  * be merged into each editor instance, so the developer may use them directly via the editor, without making
  * an instance of this class**.
  *
  * @class SelectionRegion
  * @constructor
  */
	function SelectionRegion() {}

	SelectionRegion.prototype = {
		constructor: SelectionRegion,

		/**
   * Creates selection from two points in page coordinates.
   *
   * @instance
   * @memberof SelectionRegion
   * @method createSelectionFromPoint
   * @param {Number} x X point in page coordinates.
   * @param {Number} y Y point in page coordinates.
   */
		createSelectionFromPoint: function createSelectionFromPoint(x, y) {
			this.createSelectionFromRange(x, y, x, y);
		},


		/**
   * Creates selection from range. A range consists from two points in page coordinates.
   *
   * @instance
   * @memberof SelectionRegion
   * @method createSelectionFromRange
   * @param {Number} startX X coordinate of the first point.
   * @param {Number} startY Y coordinate of the first point.
   * @param {Number} endX X coordinate of the second point.
   * @param {Number} endY Y coordinate of the second point.
   */
		createSelectionFromRange: function createSelectionFromRange(startX, startY, endX, endY) {
			var end = void 0;
			var endContainer = void 0;
			var endOffset = void 0;
			var range = void 0;
			var start = void 0;
			var startContainer = void 0;
			var startOffset = void 0;

			if (typeof document.caretPositionFromPoint === 'function') {
				start = document.caretPositionFromPoint(startX, startY);
				end = document.caretPositionFromPoint(endX, endY);

				startContainer = start.offsetNode;
				endContainer = end.offsetNode;

				startOffset = start.offset;
				endOffset = end.offset;

				range = this.createRange();
			} else if (typeof document.caretRangeFromPoint === 'function') {
				start = document.caretRangeFromPoint(startX, startY);
				end = document.caretRangeFromPoint(endX, endY);

				startContainer = start.startContainer;
				endContainer = end.startContainer;

				startOffset = start.startOffset;
				endOffset = end.startOffset;

				range = this.createRange();
			}

			if (range && document.getSelection) {
				range.setStart(new CKEDITOR.dom.node(startContainer), startOffset);
				range.setEnd(new CKEDITOR.dom.node(endContainer), endOffset);

				this.getSelection().selectRanges([range]);
			} else if (typeof document.body.createTextRange === 'function') {
				var selection = this.getSelection();

				selection.unlock();

				range = document.body.createTextRange();
				range.moveToPoint(startX, startY);

				var endRange = range.duplicate();
				endRange.moveToPoint(endX, endY);

				range.setEndPoint('EndToEnd', endRange);
				range.select();

				this.getSelection().lock();
			}
		},


		/**
   * Returns the region of the current position of the caret. The points are in page coordinates.
   *
   * @instance
   * @memberof SelectionRegion
   * @method getCaretRegion
   * @return {Object} Returns object with the following properties:
   * - bottom
   * - left
   * - right
   * - top
   */
		getCaretRegion: function getCaretRegion() {
			var selection = this.getSelection();

			var region = {
				bottom: 0,
				left: 0,
				right: 0,
				top: 0
			};

			var bookmarks = selection.createBookmarks();

			if (!bookmarks.length) {
				return region;
			}

			var bookmarkNodeEl = bookmarks[0].startNode.$;

			bookmarkNodeEl.style.display = 'inline-block';

			region = new CKEDITOR.dom.element(bookmarkNodeEl).getClientRect();

			bookmarkNodeEl.parentNode.removeChild(bookmarkNodeEl);

			var scrollPos = new CKEDITOR.dom.window(window).getScrollPosition();

			region.bottom = scrollPos.y + region.bottom;
			region.left = scrollPos.x + region.left;
			region.right = scrollPos.x + region.right;
			region.top = scrollPos.y + region.top;

			return region;
		},


		/**
   * Returns data for the current selection.
   *
   * @instance
   * @memberof SelectionRegion
   * @method getSelectionData
   * @return {Object|null} Returns an object with the following data:
   * - element - The currently selected element, if any
   * - text - The selected text
   * - region - The data, returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionRegion:method"}}{{/crossLink}}
   */
		getSelectionData: function getSelectionData() {
			var selection = this.getSelection();

			if (!selection.getNative()) {
				return null;
			}

			var result = {
				element: selection.getSelectedElement(),
				text: selection.getSelectedText()
			};

			result.region = this.getSelectionRegion(selection);

			return result;
		},


		/**
   * Returns the region of the current selection.
   *
   * @instance
   * @memberof SelectionRegion
   * @method getSelectionRegion
   * @return {Object} Returns object which is being returned from
   * {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getClientRectsRegion:method"}}{{/crossLink}} with three more properties:
   * - direction - the direction of the selection. Can be one of these:
   *   1. CKEDITOR.SELECTION_TOP_TO_BOTTOM
   *   2. CKEDITOR.SELECTION_BOTTOM_TO_TOP
   * - height - The height of the selection region
   * - width - The width of the selection region
   */
		getSelectionRegion: function getSelectionRegion() {
			var region = this.getClientRectsRegion();

			region.direction = this.getSelectionDirection();

			region.height = region.bottom - region.top;
			region.width = region.right - region.left;

			return region;
		},


		/**
   * Returns true if the current selection is empty, false otherwise.
   *
   * @instance
   * @memberof SelectionRegion
   * @method isSelectionEmpty
   * @return {Boolean} Returns true if the current selection is empty, false otherwise.
   */
		isSelectionEmpty: function isSelectionEmpty() {
			var selection = this.getSelection();

			if (selection.getType() === CKEDITOR.SELECTION_NONE) {
				return true;
			}

			var ranges = selection.getRanges();
			return ranges && ranges.length === 1 && ranges[0].collapsed;
		},


		/**
   * Returns object with data about the [client rectangles](https://developer.mozilla.org/en-US/docs/Web/API/Element.getClientRects) of the selection,
   * normalized across browses. All offsets below are in page coordinates.
   *
   * @instance
   * @memberof SelectionRegion
   * @method getClientRectsRegion
   * @return {Object} Returns object with the following data:
   * - bottom - bottom offset of all client rectangles
   * - left - left offset of all client rectangles
   * - right - right offset of all client rectangles
   * - top - top offset of all client rectangles
   * - startRect - An Object, which contains the following information:
   *     + bottom - bottom offset
   *     + height - the height of the rectangle
   *     + left - left offset of the selection
   *     + right - right offset of the selection
   *     + top - top offset of the selection
   *     + width - the width of the rectangle
   * - endRect - An Object, which contains the following information:
   *     + bottom - bottom offset
   *     + height - the height of the rectangle
   *     + left - left offset of the selection
   *     + right - right offset of the selection
   *     + top - top offset of the selection
   *     + width - the width of the rectangle
   *
   * If there is no native selection, the objects will be filled with 0.
   */
		getClientRectsRegion: function getClientRectsRegion() {
			var selection = this.getSelection();
			var nativeSelection = selection.getNative();

			var defaultRect = {
				bottom: 0,
				height: 0,
				left: 0,
				right: 0,
				top: 0,
				width: 0
			};

			var region = {
				bottom: 0,
				endRect: defaultRect,
				left: 0,
				right: 0,
				top: 0,
				startRect: defaultRect
			};

			if (!nativeSelection) {
				return region;
			}

			var bottom = 0;
			var clientRects = void 0;
			var left = Infinity;
			var right = -Infinity;
			var top = Infinity;

			if (nativeSelection.createRange) {
				clientRects = nativeSelection.createRange().getClientRects();
			} else {
				clientRects = nativeSelection.rangeCount > 0 ? nativeSelection.getRangeAt(0).getClientRects() : [];
			}

			if (clientRects.length === 0) {
				region = this.getCaretRegion();
			} else {
				for (var i = 0, length = clientRects.length; i < length; i++) {
					var item = clientRects[i];

					if (item.left < left) {
						left = item.left;
					}

					if (item.right > right) {
						right = item.right;
					}

					if (item.top < top) {
						top = item.top;
					}

					if (item.bottom > bottom) {
						bottom = item.bottom;
					}
				}

				var scrollPos = new CKEDITOR.dom.window(window).getScrollPosition();

				region.bottom = scrollPos.y + bottom;
				region.left = scrollPos.x + left;
				region.right = scrollPos.x + right;
				region.top = scrollPos.y + top;

				if (clientRects.length) {
					var endRect = clientRects[clientRects.length - 1];
					var startRect = clientRects[0];

					region.endRect = {
						bottom: scrollPos.y + endRect.bottom,
						height: endRect.height,
						left: scrollPos.x + endRect.left,
						right: scrollPos.x + endRect.right,
						top: scrollPos.y + endRect.top,
						width: endRect.width
					};

					region.startRect = {
						bottom: scrollPos.y + startRect.bottom,
						height: startRect.height,
						left: scrollPos.x + startRect.left,
						right: scrollPos.x + startRect.right,
						top: scrollPos.y + startRect.top,
						width: startRect.width
					};
				}
			}

			return region;
		},


		/**
   * Retrieves the direction of the selection. The direction is from top to bottom or from bottom to top.
   * For IE < 9 it is not possible, so the direction for these browsers will be always CKEDITOR.SELECTION_TOP_TO_BOTTOM.
   *
   * @instance
   * @memberof SelectionRegion
   * @method getSelectionDirection
   * @return {Number} Returns a number which represents selection direction. It might be one of these:
   * - CKEDITOR.SELECTION_TOP_TO_BOTTOM;
   * - CKEDITOR.SELECTION_BOTTOM_TO_TOP;
   */
		getSelectionDirection: function getSelectionDirection() {
			var direction = CKEDITOR.SELECTION_TOP_TO_BOTTOM;
			var selection = this.getSelection();
			var nativeSelection = selection.getNative();

			if (!nativeSelection) {
				return direction;
			}

			var anchorNode = void 0;

			if ((anchorNode = nativeSelection.anchorNode) && anchorNode.compareDocumentPosition) {
				var position = anchorNode.compareDocumentPosition(nativeSelection.focusNode);

				if (!position && nativeSelection.anchorOffset > nativeSelection.focusOffset || position === Node.DOCUMENT_POSITION_PRECEDING) {
					direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
				}
			}

			return direction;
		}
	};

	CKEDITOR.plugins.add('ae_selectionregion', {
		init: function init(editor) {
			var attr = void 0;
			var hasOwnProperty = Object.prototype.hasOwnProperty;

			for (attr in SelectionRegion.prototype) {
				if (hasOwnProperty.call(SelectionRegion.prototype, attr) && typeof editor[attr] === 'undefined') {
					editor[attr] = SelectionRegion.prototype[attr];
				}
			}
		}
	});
}

/***/ }),

/***/ "./src/core/table.js":
/*!***************************!*\
  !*** ./src/core/table.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var IE_NON_DIRECTLY_EDITABLE_ELEMENT = {
	table: 1,
	col: 1,
	colgroup: 1,
	tbody: 1,
	td: 1,
	tfoot: 1,
	th: 1,
	thead: 1,
	tr: 1
};

/**
 * Table class utility. Provides methods for create, delete and update tables.
 *
 * @class CKEDITOR.Table
 * @constructor
 * @param {Object} editor The CKEditor instance.
 */

function Table(editor) {
	this._editor = editor;
}

Table.HEADING_BOTH = 'Both';
Table.HEADING_COL = 'Column';
Table.HEADING_NONE = 'None';
Table.HEADING_ROW = 'Row';

Table.prototype = {
	constructor: Table,

	/**
  * Creates a table.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method create
  * @param {Object} config Table configuration object
  * @return {Object} The created table
  */
	create: function create(config) {
		var editor = this._editor;
		var table = this._createElement('table');

		config = config || {};

		// Generate the rows and cols.
		var tbody = table.append(this._createElement('tbody'));
		var rows = config.rows || 1;
		var cols = config.cols || 1;

		for (var i = 0; i < rows; i++) {
			var row = tbody.append(this._createElement('tr'));
			for (var j = 0; j < cols; j++) {
				var cell = row.append(this._createElement('td'));

				cell.appendBogus();
			}
		}

		this.setAttributes(table, config.attrs);
		this.setHeading(table, config.heading);

		// Insert the table element if we're creating one.
		editor.insertElement(table);

		var firstCell = new CKEDITOR.dom.element(table.$.rows[0].cells[0]);
		var range = editor.createRange();
		range.moveToPosition(firstCell, CKEDITOR.POSITION_AFTER_START);
		range.select();

		return table;
	},


	/**
  * Retrieves a table from the current selection.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method getFromSelection
  * @return {CKEDITOR.dom.element} The retrieved table or null if not found.
  */
	getFromSelection: function getFromSelection() {
		var table = void 0;
		var selection = this._editor.getSelection();
		var selected = selection.getSelectedElement();

		if (selected && selected.is('table')) {
			table = selected;
		} else {
			var ranges = selection.getRanges();

			if (ranges.length > 0) {
				// Webkit could report the following range on cell selection (#4948):
				// <table><tr><td>[&nbsp;</td></tr></table>]

				/* istanbul ignore else */
				if (CKEDITOR.env.webkit) {
					ranges[0].shrink(CKEDITOR.NODE_ELEMENT);
				}

				table = this._editor.elementPath(ranges[0].getCommonAncestor(true)).contains('table', 1);
			}
		}

		return table;
	},


	/**
  * Checks if a given table can be considered as editable. This method
  * workarounds a limitation of IE where for some elements (like table),
  * `isContentEditable` returns always false. This is because IE does not support
  * `contenteditable` on such elements. However, despite such elements
  * cannot be set as content editable directly, a content editable SPAN,
  * or DIV element can be placed inside the individual table cells.
  * See https://msdn.microsoft.com/en-us/library/ms537837%28v=VS.85%29.aspx
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method isEditable
  * @param {CKEDITOR.dom.element} el The table element to test if editable
  * @return {Boolean}
  */
	isEditable: function isEditable(el) {
		if (!CKEDITOR.env.ie || !el.is(IE_NON_DIRECTLY_EDITABLE_ELEMENT)) {
			return !el.isReadOnly();
		}

		if (el.hasAttribute('contenteditable')) {
			return el.getAttribute('contenteditable') !== 'false';
		}

		return this.isEditable(el.getParent());
	},


	/**
  * Returns which heading style is set for the given table.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method getHeading
  * @param {CKEDITOR.dom.element} table The table to gather the heading from. If null, it will be retrieved from the current selection.
  * @return {String} The heading of the table. Expected values are `CKEDITOR.Table.NONE`, `CKEDITOR.Table.ROW`, `CKEDITOR.Table.COL` and `CKEDITOR.Table.BOTH`.
  */
	getHeading: function getHeading(table) {
		table = table || this.getFromSelection();

		if (!table) {
			return null;
		}

		var rowHeadingSettings = table.$.tHead !== null;

		var colHeadingSettings = true;

		// Check if all of the first cells in every row are TH
		for (var row = 0; row < table.$.rows.length; row++) {
			// If just one cell isn't a TH then it isn't a header column
			var cell = table.$.rows[row].cells[0];

			if (cell && cell.nodeName.toLowerCase() !== 'th') {
				colHeadingSettings = false;
				break;
			}
		}

		var headingSettings = Table.HEADING_NONE;

		if (rowHeadingSettings) {
			headingSettings = Table.HEADING_ROW;
		}

		if (colHeadingSettings) {
			headingSettings = headingSettings === Table.HEADING_ROW ? Table.HEADING_BOTH : Table.HEADING_COL;
		}

		return headingSettings;
	},


	/**
  * Removes a table from the editor.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method remove
  * @param {CKEDITOR.dom.element} table The table element which table style should be removed.
  */
	remove: function remove(table) {
		var editor = this._editor;

		if (table) {
			table.remove();
		} else {
			table = editor.elementPath().contains('table', 1);

			if (table) {
				// If the table's parent has only one child remove it as well (unless it's a table cell, or the editable element) (#5416, #6289, #12110)
				var parent = table.getParent();
				var editable = editor.editable();

				if (parent.getChildCount() === 1 && !parent.is('td', 'th') && !parent.equals(editable)) {
					table = parent;
				}

				var range = editor.createRange();
				range.moveToPosition(table, CKEDITOR.POSITION_BEFORE_START);
				table.remove();
			}
		}
	},


	/**
  * Assigns provided attributes to a table.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method setAttributes
  * @param {Object} table The table to which the attributes should be assigned
  * @param {Object} attrs The attributes which have to be assigned to the table
  */
	setAttributes: function setAttributes(table, attrs) {
		if (attrs) {
			Object.keys(attrs).forEach(function (attr) {
				table.setAttribute(attr, attrs[attr]);
			});
		}
	},


	/**
  * Sets the appropriate table heading style to a table.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @method setHeading
  * @param {CKEDITOR.dom.element} table The table element to which the heading should be set. If null, it will be retrieved from the current selection.
  * @param {String} heading The table heading to be set. Accepted values are: `CKEDITOR.Table.NONE`, `CKEDITOR.Table.ROW`, `CKEDITOR.Table.COL` and `CKEDITOR.Table.BOTH`.
  */
	setHeading: function setHeading(table, heading) {
		table = table || this.getFromSelection();

		var i = void 0;
		var newCell = void 0;
		var tableHead = void 0;
		var tableBody = table.getElementsByTag('tbody').getItem(0);

		var tableHeading = this.getHeading(table);
		var hadColHeading = tableHeading === Table.HEADING_COL || tableHeading === Table.HEADING_BOTH;

		var needColHeading = heading === Table.HEADING_COL || heading === Table.HEADING_BOTH;
		var needRowHeading = heading === Table.HEADING_ROW || heading === Table.HEADING_BOTH;

		// If we need row heading and don't have a <thead> element yet, move the
		// first row of the table to the head and convert the nodes to <th> ones.
		if (!table.$.tHead && needRowHeading) {
			var tableFirstRow = tableBody.getElementsByTag('tr').getItem(0);
			var tableFirstRowChildCount = tableFirstRow.getChildCount();

			// Change TD to TH:
			for (i = 0; i < tableFirstRowChildCount; i++) {
				var cell = tableFirstRow.getChild(i);

				// Skip bookmark nodes. (#6155)
				if (cell.type === CKEDITOR.NODE_ELEMENT && !cell.data('cke-bookmark')) {
					cell.renameNode('th');
					cell.setAttribute('scope', 'col');
				}
			}

			tableHead = this._createElement(table.$.createTHead());
			tableHead.append(tableFirstRow.remove());
		}

		// If we don't need row heading and we have a <thead> element, move the
		// row out of there and into the <tbody> element.
		if (table.$.tHead !== null && !needRowHeading) {
			// Move the row out of the THead and put it in the TBody:
			tableHead = this._createElement(table.$.tHead);

			var previousFirstRow = tableBody.getFirst();

			while (tableHead.getChildCount() > 0) {
				var newFirstRow = tableHead.getFirst();
				var newFirstRowChildCount = newFirstRow.getChildCount();

				for (i = 0; i < newFirstRowChildCount; i++) {
					newCell = newFirstRow.getChild(i);

					if (newCell.type === CKEDITOR.NODE_ELEMENT) {
						newCell.renameNode('td');
						newCell.removeAttribute('scope');
					}
				}

				newFirstRow.insertBefore(previousFirstRow);
			}

			tableHead.remove();
		}

		tableHeading = this.getHeading(table);
		var hasColHeading = tableHeading === Table.HEADING_COL || tableHeading === Table.HEADING_BOTH;

		// If we need column heading and the table doesn't have it, convert every first cell in
		// every row into a `<th scope="row">` element.
		if (!hasColHeading && needColHeading) {
			for (i = 0; i < table.$.rows.length; i++) {
				if (table.$.rows[i].cells[0].nodeName.toLowerCase() !== 'th') {
					newCell = new CKEDITOR.dom.element(table.$.rows[i].cells[0]);
					newCell.renameNode('th');
					newCell.setAttribute('scope', 'row');
				}
			}
		}

		// If we don't need column heading but the table has it, convert every first cell in every
		// row back into a `<td>` element.
		if (hadColHeading && !needColHeading) {
			for (i = 0; i < table.$.rows.length; i++) {
				var row = new CKEDITOR.dom.element(table.$.rows[i]);

				if (row.getParent().getName() === 'tbody') {
					newCell = new CKEDITOR.dom.element(row.$.cells[0]);
					newCell.renameNode('td');
					newCell.removeAttribute('scope');
				}
			}
		}
	},


	/**
  * Creates a new CKEDITOR.dom.element using the passed tag name.
  *
  * @instance
  * @memberof CKEDITOR.Table
  * @protected
  * @method _createElement
  * @param {String} name The tag name from which an element should be created
  * @return {CKEDITOR.dom.element} Instance of CKEDITOR DOM element class
  */
	_createElement: function _createElement(name) {
		return new CKEDITOR.dom.element(name, this._editor.document);
	}
};

CKEDITOR.on('instanceReady', function (event) {
	var headingCommands = [Table.HEADING_NONE, Table.HEADING_ROW, Table.HEADING_COL, Table.HEADING_BOTH];

	var tableUtils = new Table(event.editor);

	headingCommands.forEach(function (heading) {
		event.editor.addCommand('tableHeading' + heading, {
			exec: function exec(_editor) {
				tableUtils.setHeading(null, heading);
			}
		});
	});
});

CKEDITOR.Table = CKEDITOR.Table || Table;

/***/ }),

/***/ "./src/core/tools.js":
/*!***************************!*\
  !*** ./src/core/tools.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * CKEDITOR.tools class utility which adds additional methods to those of CKEditor.
 *
 * @class CKEDITOR.tools
 */

/**
 * Sends a request using the JSONP technique.
 *
 * @memberof CKEDITOR.tools
 * @method jsonp
 * @param {CKEDITOR.template} urlTemplate The template of the URL to be requested. All properties passed in `urlParams` can be used, plus a `{callback}`, which represent a JSONP callback, must be defined.
 * @param {Function} callback A function to be called in case of success.
 * @param {Function} errorCallback A function to be called in case of failure.
 * @param {Object} urlParams Parameters to be passed to the `urlTemplate`.
 * @return {Object} An object with the following properties:
 *  - id: the transaction ID
 *  - a `cancel()` method
 * @static
 */
CKEDITOR.tools.jsonp = function (urlTemplate, urlParams, callback, errorCallback) {
	var callbackKey = CKEDITOR.tools.getNextNumber();

	urlParams = urlParams || {};
	urlParams.callback = 'CKEDITOR._.jsonpCallbacks[' + callbackKey + ']';

	if (!CKEDITOR._.jsonpCallbacks) {
		CKEDITOR._.jsonpCallbacks = {};
	}

	CKEDITOR._.jsonpCallbacks[callbackKey] = function (response) {
		setTimeout(function () {
			cleanUp();

			callback(response);
		});
	};

	var scriptElement = new CKEDITOR.dom.element('script');
	scriptElement.setAttribute('src', urlTemplate.output(urlParams));
	scriptElement.on('error', function () {
		cleanUp();

		if (errorCallback) {
			errorCallback();
		}
	});

	function cleanUp() {
		if (scriptElement) {
			scriptElement.remove();
			delete CKEDITOR._.jsonpCallbacks[callbackKey];
			scriptElement = null;
		}
	}

	CKEDITOR.document.getBody().append(scriptElement);

	return {
		cancel: cleanUp,
		id: callbackKey
	};
};

/**
 * Returns a new object containing all of the properties of all the supplied
 * objects. The properties from later objects will overwrite those in earlier
 * objects.
 *
 * Passing in a single object will create a shallow copy of it.
 *
 * @memberof CKEDITOR.tools
 * @method merge
 * @param {Object} objects* One or more objects to merge.
 * @return {Object} A new merged object.
 * @static
 */
CKEDITOR.tools.merge = CKEDITOR.tools.merge || function () {
	var result = {};

	for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
		args[_key] = arguments[_key];
	}

	for (var i = 0; i < args.length; ++i) {
		var obj = args[i];

		for (var key in obj) {
			if (Object.prototype.hasOwnProperty.call(obj, key)) {
				result[key] = obj[key];
			}
		}
	}

	return result;
};

/**
 * Simulates event on a DOM element.
 *
 * @memberof CKEDITOR.tools
 * @method simulate
 * @param {DOMElement} element The element on which the event shoud be simualted.
 * @param {String} event The name of the event which have to be simulated.
 * @static
 */
CKEDITOR.tools.simulate = function (element, event) {
	var eventInstance = document.createEvent('Events');
	eventInstance.initEvent(event, true, false);
	element.dispatchEvent(eventInstance);
};

/***/ }),

/***/ "./src/core/uicore.js":
/*!****************************!*\
  !*** ./src/core/uicore.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (!CKEDITOR.plugins.get('ae_uicore')) {
	/**
  * UICore class which will handle user interactions with the editor. These interactions
  * might be triggered via mouse, keyboard or touch devices. The class fill fire an event via
  * CKEditor's event system - "editorInteraction". The UI may listen to this event and
  * execute some actions - for example to show/hide toolbars.
  *
  * By default if user presses the Esc key, 'editorInteraction' event won't be fired. However, this behaviour can be changed
  * by setting {{#crossLink "CKEDITOR.plugins.ae_uicore/allowEsc:attribute"}}{{/crossLink}} config property in editor's configuration to true.
  *
  * @class ae_uicore
  */

	/**
  * Fired when user interacts somehow with the browser. This may be clicking with the mouse, pressing keyboard button,
  * or touching screen. This even will be not fired after each interaction. It will be debounced. By default the timeout
  * is 50ms. This value can be overwritten via {{#crossLink "CKEDITOR.plugins.ae_uicore/timeout:attribute"}}{{/crossLink}}
  * property of editor's configuration, like: editor.config.uicore.timeout = 100
  *
  * @memberof ae_uicore
  * @event ae_uicore#editorInteraction
  * @param {Object} data An object which contains the following properties:
  * - nativeEvent - The event as received from CKEditor.
  * - selectionData - The data, returned from {{#crossLink "CKEDITOR.plugins.ae_selectionregion/getSelectionData:method"}}{{/crossLink}}
  */

	/**
  * Fired by UI elements like Toolbars or Buttons when their state changes. The listener updates the live region with the provided data.
  *
  * @memberof ae_uicore
  * @event ae_uicore#ariaUpdate
  * @param {Object} data An object which contains the following properties:
  * - message - The provided message from the UI element.
  */

	/**
  * If set to true, the editor will still fire {{#crossLink "CKEDITOR.plugins.ae_uicore/editorInteraction:event"}}{{/crossLink}} event,
  * if user presses Esc key.
  *
  * @memberof ae_uicore
  * @attribute allowEsc
  * @default false
  * @type Boolean
  */

	/**
  * Specifies the default timeout after which the {{#crossLink "CKEDITOR.plugins.ae_uicore/editorInteraction:event"}}{{/crossLink}} event
  * will be fired.
  *
  * @memberof ae_uicore
  * @attribute timeout
  * @default 50 (ms)
  * @type Number
  */

	CKEDITOR.plugins.add('ae_uicore', {
		/**
   * Initializer lifecycle implementation for the UICore plugin.
   *
   * @memberof ae_uicore
   * @method init
   * @param {Object} editor The current CKEditor instance.
   * @protected
   */
		init: function init(editor) {
			var ariaState = [];

			var ariaElement = this._createAriaElement(editor.id);

			var uiTasksTimeout = editor.config.uicore ? editor.config.uicore.timeout : 50;

			var handleUI = CKEDITOR.tools.debounce(function (event) {
				ariaState = [];

				if (event.name !== 'keyup' || event.data.$.keyCode !== 27 || editor.config.allowEsc) {
					var selectionData = editor.getSelectionData();

					if (selectionData) {
						editor.fire('editorInteraction', {
							nativeEvent: event.data.$,
							selectionData: selectionData
						});
					}
				}
			}, uiTasksTimeout);

			var handleAria = CKEDITOR.tools.debounce(function (_event) {
				ariaElement.innerHTML = ariaState.join('. ');
			}, uiTasksTimeout);

			var handleMouseLeave = CKEDITOR.tools.debounce(function (event) {
				var aeUINodes = document.querySelectorAll('.ae-ui');

				var found = void 0;

				for (var i = 0; i < aeUINodes.length; i++) {
					if (aeUINodes[i].contains(event.data.$.relatedTarget)) {
						found = true;
						break;
					}
				}

				if (!found) {
					handleUI(event);
				}
			}, uiTasksTimeout);

			editor.on('ariaUpdate', function (event) {
				// handleAria is debounced function, so if it is being called multiple times, it will
				// be canceled until some time passes.
				// For that reason here we explicitly append the current message to the list of messages
				// and call handleAria. Since it is debounced, when some timeout passes,
				// all the messages will be applied to the live region and not only the last one.

				ariaState.push(event.data.message);

				handleAria();
			});

			editor.once('contentDom', function () {
				var editable = editor.editable();

				var focusHandler = editable.attachListener(editable, 'focus', function (event) {
					focusHandler.removeListener();

					editable.attachListener(editable, 'keyup', handleUI);
					editable.attachListener(editable, 'mouseup', handleUI);
					editable.attachListener(editable, 'mouseleave', handleMouseLeave);

					handleUI(event);
				});
			});

			editor.on('destroy', function (_event) {
				ariaElement.parentNode.removeChild(ariaElement);

				handleUI.detach();
			});
		},


		/**
   * Creates and applies an HTML element to the body of the document which will contain ARIA messages.
   *
   * @memberof ae_uicore
   * @method _createAriaElement
   * @param {String} id The provided id of the element. It will be used as prefix for the final element Id.
   * @protected
   * @return {HTMLElement} The created and applied to DOM element.
   */
		_createAriaElement: function _createAriaElement(id) {
			var statusElement = document.createElement('div');

			statusElement.className = 'ae-sr-only';

			statusElement.setAttribute('aria-live', 'polite');
			statusElement.setAttribute('role', 'status');
			statusElement.setAttribute('id', id + 'LiveRegion');

			document.body.appendChild(statusElement);

			return statusElement;
		}
	});
}

/***/ }),

/***/ "./src/oop/attribute.js":
/*!******************************!*\
  !*** ./src/oop/attribute.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _lang = __webpack_require__(/*! ./lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Attribute implementation.
 *
 * @class Attribute
 * @constructor
 */
function Attribute(config) {
	this.__config__ = config || {};
	this.__ATTRS__ = {};
}

Attribute.prototype = {
	constructor: Attribute,

	/**
  * Retrieves the value of an attribute.
  *
  * @instance
  * @memberof Attribute
  * @method get
  * @param {String} attr The attribute which value should be retrieved.
  * @return {Any} The value of the attribute.
  */
	get: function get(attr) {
		var currentAttr = this.constructor.ATTRS[attr];

		if (!currentAttr) {
			return;
		}

		if (!this._isInitialized(attr)) {
			this._init(attr);
		}

		var curValue = this.__ATTRS__[attr];

		if (currentAttr.getter) {
			curValue = this._callStringOrFunction(currentAttr.getter, curValue);
		}

		return curValue;
	},


	/**
  * Sets the value of an attribute.
  *
  * @instance
  * @memberof Attribute
  * @method set
  * @param {String} attr The attribute which value should be set.
  * @param {Any} value The value which should be set to the attribute.
  */
	set: function set(attr, value) {
		var currentAttr = this.constructor.ATTRS[attr];

		if (!currentAttr) {
			return;
		}

		if (!this._isInitialized(attr)) {
			this._init(attr);
		}

		if (currentAttr.readOnly) {
			return;
		}

		if (currentAttr.writeOnce && this._isInitialized(attr)) {
			return;
		}

		if (currentAttr.validator && !this._callStringOrFunction(currentAttr.validator, value)) {
			return;
		}

		if (currentAttr.setter) {
			value = this._callStringOrFunction(currentAttr.setter, value);
		}

		this.__ATTRS__[attr] = value;
	},


	/**
  * Calls the provided param as function with the supplied arguments.
  * If param provided as string, a corresponding function in this object will
  * be called. If provided param is a function, it will be directly called.
  *
  * @instance
  * @memberof Attribute
  * @method _callStringOrFunction
  * @param  {Any|Array} args The arguments which will be provided to the called function
  * @param  {String|Function} stringOrFunction The function which should be called
  * @protected
  * @return {Any} The returned value from the called function
  */
	_callStringOrFunction: function _callStringOrFunction(stringOrFunction, args) {
		var result = null;

		if (!_lang2.default.isArray(args)) {
			args = [args];
		}

		if (_lang2.default.isString(stringOrFunction) && _lang2.default.isFunction(this[stringOrFunction])) {
			result = this[stringOrFunction].apply(this, _toConsumableArray(args));
		} else if (_lang2.default.isFunction(stringOrFunction)) {
			result = stringOrFunction.apply(this, args);
		}

		return result;
	},


	/**
  * Initializes an attribute. Sets its default value depending on the flags of the
  * attribute and the passed configuration object to the constructor.
  *
  * @instance
  * @memberof Attribute
  * @method _init
  * @param {String} attr The name of the attribute which have to be initialized.
  * @protected
  */
	_init: function _init(attr) {
		var value = void 0;

		var currentAttr = this.constructor.ATTRS[attr];

		// Check if there is default value or passed one via configuration object
		var hasDefaultValue = Object.prototype.hasOwnProperty.call(currentAttr, 'value');
		var hasPassedValueViaConfig = Object.prototype.hasOwnProperty.call(this.__config__, attr);

		// If there is valueFn, set the value to be the result of invocation of this function
		if (currentAttr.valueFn) {
			value = this._callStringOrFunction(currentAttr.valueFn, value);

			this.__ATTRS__[attr] = value;
		}
		// else if the attribute has readOnly flag, set the default value from the attribute,
		// regardless if there is value or not
		else if (currentAttr.readOnly) {
				value = currentAttr.value;
			}
			// else if the attribute has writeOnce value, set it from the passed configuration or from the
			// default value, in this order. Otherwise, return miserable.
			else if (currentAttr.writeOnce) {
					if (hasPassedValueViaConfig) {
						value = this.__config__[attr];
					} else if (hasDefaultValue) {
						value = currentAttr.value;
					} else {
						return;
					}
				}
				// These two cases below are easy - set the value to be from the passed config or
				// from the default value, in this order.
				else if (hasPassedValueViaConfig) {
						value = this.__config__[attr];
					} else if (hasDefaultValue) {
						value = currentAttr.value;
					}

		// If there is validator, and user passed config object - check the returned value.
		// If it is false, then set as initial value the default one.
		// However, if there is no default value, just return.
		if (currentAttr.validator && hasPassedValueViaConfig && !this._callStringOrFunction(currentAttr.validator, value)) {
			if (hasDefaultValue) {
				value = currentAttr.value;
			} else {
				return;
			}
		}

		// If there is setter and user passed config object - pass the value thought the setter.
		// The value might be one from defaultFn, default value or provided from the config.
		if (currentAttr.setter && hasPassedValueViaConfig) {
			value = this._callStringOrFunction(currentAttr.setter, value);
		}

		// Finally, set the value as initial value to the storage with values.
		this.__ATTRS__[attr] = value;
	},


	/**
  * Checks if an attribute is initialized. An attribute is considered as initialized
  * when there is an own property with this name in the local collection of attribute values
  * for the current instance.
  *
  * @instance
  * @memberof Attribute
  * @method _isInitialized
  * @param {String} attr The attribute which should be checked if it is initialized.
  * @protected
  * @return {Boolean} Returns true if the attribute has been initialized, false otherwise.
  */
	_isInitialized: function _isInitialized(attr) {
		return Object.prototype.hasOwnProperty.call(this.__ATTRS__, attr);
	}
};

exports.default = Attribute;

/***/ }),

/***/ "./src/oop/base.js":
/*!*************************!*\
  !*** ./src/oop/base.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _attribute = __webpack_require__(/*! ./attribute */ "./src/oop/attribute.js");

var _attribute2 = _interopRequireDefault(_attribute);

var _lang = __webpack_require__(/*! ./lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

var _oop = __webpack_require__(/*! ./oop */ "./src/oop/oop.js");

var _oop2 = _interopRequireDefault(_oop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Quick and dirty impl of Base class.
 *
 * @class Base
 * @constructor
 */
function Base(config) {
	Base.superclass.constructor.call(this, config);

	this.init(config);
}

(0, _oop2.default)(Base, _attribute2.default, {
	/**
  * Calls the `initializer` method of each class which extends Base starting from the parent to the child.
  * Will pass the configuration object to each initializer method.
  *
  * @instance
  * @memberof Base
  * @method init
  * @param {Object} config Configuration object
  */
	init: function init(config) {
		this._callChain('initializer', config);
	},


	/**
  * Calls the `destructor` method of each class which extends Base starting from the parent to the child.
  *
  * @instance
  * @memberof Base
  * @method destroy
  */
	destroy: function destroy() {
		this._callChain('destructor');
	},


	/**
  * Calls a method of each class, which is being present in the hierarchy starting from parent to the child.
  *
  * @instance
  * @memberof Base
  * @method _callChain
  * @param {Object|Array} args The arguments with which the method should be invoked
  * @param {String} wat  The method, which should be invoked
  * @protected
  */
	_callChain: function _callChain(wat, args) {
		var arr = [];

		var ctor = this.constructor;

		while (ctor) {
			if (_lang2.default.isFunction(ctor.prototype[wat])) {
				arr.push(ctor.prototype[wat]);
			}

			ctor = ctor.superclass ? ctor.superclass.constructor : null;
		}

		arr = arr.reverse();

		args = _lang2.default.isArray(args) ? args : [args];

		for (var i = 0; i < arr.length; i++) {
			var item = arr[i];

			item.apply(this, args);
		}
	}
});

exports.default = Base;

/***/ }),

/***/ "./src/oop/lang.js":
/*!*************************!*\
  !*** ./src/oop/lang.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Provides core language utilities.
 *
 * @class Lang
 */
var Lang = {
	/**
  * Check if the passed value is an array.
  *
  * @memberof Lang
  * @method isArray
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is an array, false otherwise.
  * @static
  */
	isArray: function isArray(value) {
		return Object.prototype.toString.call(value) === '[object Array]';
	},


	/**
  * Check if the passed value is boolean.
  *
  * @memberof Lang
  * @method isBoolean
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is boolean, false otherwise.
  * @static
  */
	isBoolean: function isBoolean(value) {
		return typeof value === 'boolean';
	},


	/**
  * Check if the passed value is a function.
  *
  * @memberof Lang
  * @method isFunction
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is a function, false otherwise.
  * @static
  */
	isFunction: function isFunction(value) {
		return typeof value === 'function';
	},


	/**
  * Check if the passed value is NULL.
  *
  * @memberof Lang
  * @method isNull
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is NULL, false otherwise.
  * @static
  */
	isNull: function isNull(value) {
		return value === null;
	},


	/**
  * Check if the passed value is number.
  *
  * @memberof Lang
  * @method isNumber
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is number, false otherwise.
  * @static
  */
	isNumber: function isNumber(value) {
		return typeof value === 'number' && isFinite(value);
	},


	/**
  * Check if the passed value is an object
  *
  * @memberof Lang
  * @method isObject
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is an object, false otherwise.
  * @static
  */
	isObject: function isObject(value) {
		var valueType = typeof value === 'undefined' ? 'undefined' : _typeof(value);

		return value && (valueType === 'object' || Lang.isFunction(value));
	},


	/**
  * Check if the passed value is a string.
  *
  * @memberof Lang
  * @method isString
  * @param {Any} value The value which have to be checked.
  * @return {Boolean} True if the passed value is a string, false otherwise.
  * @static
  */
	isString: function isString(value) {
		return typeof value === 'string';
	},


	/**
  * Adds all properties from the supplier to the receiver.
  * The function will add all properties, not only these owned by the supplier.
  *
  * @memberof Lang
  * @method mix
  * @param {Object} receiver The object which will receive properties.
  * @param {Object} supplier The object which provides properties.
  * @return {Object} The modified receiver.
  * @static
  */
	mix: function mix(receiver, supplier) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;

		for (var key in supplier) {
			if (hasOwnProperty.call(supplier, key)) {
				receiver[key] = supplier[key];
			}
		}
	},


	/**
  * Converts value to Integer.
  *
  * @memberof Lang
  * @method toInt
  * @param {Any} value The value which have to be converted to Integer.
  * @return {Integer} The converted value.
  * @static
  */
	toInt: function toInt(value) {
		return parseInt(value, 10);
	}
};

exports.default = Lang;

/***/ }),

/***/ "./src/oop/oop.js":
/*!************************!*\
  !*** ./src/oop/oop.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _lang = __webpack_require__(/*! ./lang */ "./src/oop/lang.js");

var _lang2 = _interopRequireDefault(_lang);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Sets the prototype, constructor and superclass properties to support an inheritance strategy
 * that can chain constructors and methods. Static members will not be inherited.
 *
 * @memberof OOP
 * @method extend
 * @param {Function} receiver The class which will extend another class.
 * @param {Function} supplier The class which will provide the properties the child class.
 * @param {Object} protoProps Prototype properties to add/override.
 * @param {Object} staticProps Static properties to add/overwrite.
 * @return {Function} The extended class.
 * @static
 */
var extend = function extend(receiver, supplier, protoProps, staticProps) {
	if (!supplier || !receiver) {
		throw new Error('extend failed, verify dependencies');
	}

	var supplierProto = supplier.prototype;

	var receiverProto = Object.create(supplierProto);
	receiver.prototype = receiverProto;

	receiverProto.constructor = receiver;
	receiver.superclass = supplierProto;

	// assign constructor property
	if (supplier !== Object && supplierProto.constructor === Object.prototype.constructor) {
		supplierProto.constructor = supplier;
	}

	// add prototype overrides
	if (protoProps) {
		_lang2.default.mix(receiverProto, protoProps);
	}

	// add object overrides
	if (staticProps) {
		_lang2.default.mix(receiver, staticProps);
	}

	return receiver;
};

exports.default = extend;

/***/ }),

/***/ "./src/plugins/DragEvent.es.js":
/*!*************************************!*\
  !*** ./src/plugins/DragEvent.es.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DragEvent = function () {
	function DragEvent(window, document) {
		_classCallCheck(this, DragEvent);

		this.document = document;
		this.window = window;

		this.events = {
			keydown: this.keydown.bind(this),
			mousemove: this.mousemove.bind(this),
			mouseup: this.mouseup.bind(this)
		};
	}

	_createClass(DragEvent, [{
		key: 'start',
		value: function start(event) {
			event.preventDefault();
			event.stopPropagation();

			this.target = event.target;

			this.className = this.target.className;

			this.startPos = {
				x: event.clientX,
				y: event.clientY
			};

			this.update(event);

			this.document.addEventListener('keydown', this.events.keydown, false);
			this.document.addEventListener('mousemove', this.events.mousemove, false);
			this.document.addEventListener('mouseup', this.events.mouseup, false);

			this.document.body.classList.add('dragging-' + this.className);

			if (typeof this.onStart === 'function') {
				this.onStart();
			}
		}
	}, {
		key: 'update',
		value: function update(event) {
			this.currentPos = {
				x: event.clientX,
				y: event.clientY
			};

			this.delta = {
				x: event.clientX - this.startPos.x,
				y: event.clientY - this.startPos.y
			};

			this.keys = {
				alt: event.altKey,
				ctrl: event.ctrlKey,
				shift: event.shiftKey
			};
		}
	}, {
		key: 'mousemove',
		value: function mousemove(event) {
			this.update(event);

			if (typeof this.onDrag === 'function') {
				this.onDrag();
			}

			if (event.which === 0) {
				this.mouseup(event);
			}
		}
	}, {
		key: 'keydown',
		value: function keydown(event) {
			if (event.keyCode === 27) {
				this.release();
			}
		}
	}, {
		key: 'mouseup',
		value: function mouseup(event) {
			this.update(event);

			this.release();

			if (typeof this.onComplete === 'function') {
				this.onComplete();
			}
		}
	}, {
		key: 'release',
		value: function release() {
			this.document.body.classList.remove('dragging-' + this.className);

			this.document.removeEventListener('keydown', this.events.keydown, false);
			this.document.removeEventListener('mousemove', this.events.mousemove, false);
			this.document.removeEventListener('mouseup', this.events.mouseup, false);

			if (typeof this.onRelease === 'function') {
				this.onRelease();
			}
		}
	}]);

	return DragEvent;
}();

exports.DragEvent = DragEvent;
exports.default = DragEvent;

/***/ }),

/***/ "./src/plugins/Resizer.es.js":
/*!***********************************!*\
  !*** ./src/plugins/Resizer.es.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.Resizer = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _DragEvent = __webpack_require__(/*! ./DragEvent.es */ "./src/plugins/DragEvent.es.js");

var _DragEvent2 = _interopRequireDefault(_DragEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var IMAGE_HANDLES = ['tl', 'tr', 'bl', 'br'];

var POSITION_ELEMENT_FN = {
	bl: function bl(handle, left, top, box) {
		positionElement(handle, -3 + left, box.height - 4 + top);
	},
	br: function br(handle, left, top, box) {
		positionElement(handle, box.width - 4 + left, box.height - 4 + top);
	},
	rm: function rm(handle, left, top, box) {
		positionElement(handle, box.width - 4 + left, Math.round(box.height / 2) - 3 + top);
	},
	tl: function tl(handle, left, top, _box) {
		positionElement(handle, left - 3, top - 3);
	},
	tr: function tr(handle, left, top, box) {
		positionElement(handle, box.width - 4 + left, -3 + top);
	}
};

var positionElement = function positionElement(el, left, top) {
	el.style.left = left + 'px';
	el.style.top = top + 'px';
};

var getBoundingBox = function getBoundingBox(window, el) {
	var rect = el.getBoundingClientRect();

	return {
		height: rect.height,
		left: rect.left + window.pageXOffset,
		top: rect.top + window.pageYOffset,
		width: rect.width
	};
};

var Resizer = function () {
	function Resizer(editor) {
		var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		_classCallCheck(this, Resizer);

		this.cfg = cfg;
		this.editor = editor;

		this.document = editor.document ? editor.document.$ : document;
		this.window = editor.window ? editor.window.$ : window;

		this.box = null;
		this.container = null;
		this.handles = {};
		this.preview = null;
		this.previewBox = null;
		this.result = null;

		this.init();
	}

	_createClass(Resizer, [{
		key: 'init',
		value: function init() {
			var _this = this;

			this.container = this.document.createElement('div');
			this.container.id = 'ckimgrsz';

			this.preview = this.document.createElement('span');

			this.container.appendChild(this.preview);

			this.handles = {};

			IMAGE_HANDLES.forEach(function (handleName) {
				_this.handles[handleName] = _this.createHandle(handleName);
			});

			var keys = Object.keys(this.handles);

			for (var i = 0; i < keys.length; i++) {
				this.container.appendChild(this.handles[keys[i]]);
			}
		}
	}, {
		key: 'createHandle',
		value: function createHandle(name) {
			var el = this.document.createElement('i');

			el.classList.add(name);

			return el;
		}
	}, {
		key: 'isHandle',
		value: function isHandle(el) {
			var keys = Object.keys(this.handles);

			var result = false;

			for (var i = 0; i < keys.length; i++) {
				if (this.handles[keys[i]] === el) {
					result = true;
				}
			}

			return result;
		}
	}, {
		key: 'show',
		value: function show(el) {
			var uiNode = this.editor.config.uiNode || document.body;

			this.el = el;

			this.box = getBoundingBox(this.window, this.el);

			positionElement(this.container, this.box.left, this.box.top + uiNode.scrollTop);

			uiNode.appendChild(this.container);

			this.el.classList.add('ckimgrsz');

			this.showHandles();
		}
	}, {
		key: 'hide',
		value: function hide() {
			var elements = this.document.getElementsByClassName('ckimgrsz');

			for (var i = 0; i < elements.length; i++) {
				elements[i].classList.remove('ckimgrsz');
			}

			this.hideHandles();

			if (this.container.parentNode) {
				this.container.parentNode.removeChild(this.container);
			}
		}
	}, {
		key: 'initDrag',
		value: function initDrag(event) {
			var _this2 = this;

			if (event.button !== 0) {
				return;
			}

			var drag = new _DragEvent2.default(this.window, this.document);

			drag.onStart = function () {
				_this2.showPreview();

				_this2.isDragging = true;

				_this2.editor.getSelection().lock();
			};

			drag.onDrag = function () {
				_this2.calculateSize(drag);

				var editorBounds = _this2.editor.element.$.getBoundingClientRect();

				if (_this2.previewBox.width >= editorBounds.width) {
					return;
				}

				_this2.updatePreview();

				var box = _this2.previewBox;

				_this2.updateHandles(box, box.left, box.top);
			};

			drag.onRelease = function () {
				_this2.hidePreview();

				_this2.isDragging = false;

				_this2.hide();

				_this2.editor.getSelection().unlock();

				_this2.editor.fire('saveSnapshot');
			};

			drag.onComplete = function () {
				_this2.resizeComplete();

				_this2.editor.fire('saveSnapshot');
			};

			drag.start(event);
		}
	}, {
		key: 'updateHandles',
		value: function updateHandles(box) {
			var left = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
			var top = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

			var keys = Object.keys(this.handles);

			for (var i = 0; i < keys.length; i++) {
				POSITION_ELEMENT_FN[keys[i]](this.handles[keys[i]], left, top, box);
			}
		}
	}, {
		key: 'showHandles',
		value: function showHandles() {
			this.updateHandles(this.box);

			var keys = Object.keys(this.handles);

			for (var i = 0; i < keys.length; i++) {
				this.handles[keys[i]].style.display = 'block';
			}
		}
	}, {
		key: 'hideHandles',
		value: function hideHandles() {
			var keys = Object.keys(this.handles);

			for (var i = 0; i < keys.length; i++) {
				this.handles[keys[i]].style.display = 'none';
			}
		}
	}, {
		key: 'showPreview',
		value: function showPreview() {
			this.calculateSize();

			this.updatePreview();

			this.preview.style.display = 'block';
		}
	}, {
		key: 'updatePreview',
		value: function updatePreview() {
			positionElement(this.preview, this.previewBox.left, this.previewBox.top);

			this.preview.style.height = this.previewBox.height + 'px';
			this.preview.style.width = this.previewBox.width + 'px';
		}
	}, {
		key: 'hidePreview',
		value: function hidePreview() {
			var box = getBoundingBox(this.window, this.preview);

			this.result = {
				height: box.height,
				width: box.width
			};

			this.preview.style.display = 'none';
		}
	}, {
		key: 'calculateSize',
		value: function calculateSize(data) {
			this.previewBox = {
				height: this.box.height,
				left: 0,
				top: 0,
				width: this.box.width
			};

			if (!data) {
				return;
			}

			var className = data.target.className;

			if (className.indexOf('r') >= 0) {
				this.previewBox.width = Math.max(32, this.box.width + data.delta.x);
			}

			if (className.indexOf('b') >= 0) {
				this.previewBox.height = Math.max(32, this.box.height + data.delta.y);
			}

			if (className.indexOf('l') >= 0) {
				this.previewBox.width = Math.max(32, this.box.width - data.delta.x);
			}

			if (className.indexOf('t') >= 0) {
				this.previewBox.height = Math.max(32, this.box.height - data.delta.y);
			}

			if (className.indexOf('m') < 0 && !data.keys.shift) {
				var ratio = this.box.width / this.box.height;

				if (this.previewBox.width / this.previewBox.height > ratio) {
					this.previewBox.height = Math.round(this.previewBox.width / ratio);
				} else {
					this.previewBox.width = Math.round(this.previewBox.height * ratio);
				}
			}

			if (className.indexOf('l') >= 0) {
				this.previewBox.left = this.box.width - this.previewBox.width;
			}

			if (className.indexOf('t') >= 0) {
				this.previewBox.top = this.box.height - this.previewBox.height;
			}
		}
	}, {
		key: 'resizeComplete',
		value: function resizeComplete() {
			this.cfg.onComplete(this.el, this.result.width, this.result.height);
		}
	}]);

	return Resizer;
}();

exports.Resizer = Resizer;
exports.default = Resizer;

/***/ }),

/***/ "./src/plugins/addimages.js":
/*!**********************************!*\
  !*** ./src/plugins/addimages.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isIE = CKEDITOR.env.ie;

if (!CKEDITOR.plugins.get('ae_addimages')) {
	/**
  * CKEditor plugin which allows Drag&Drop of images directly into the editable area. The image will be encoded
  * as Data URI. An event `beforeImageAdd` will be fired with the list of dropped images. If any of the listeners
  * returns `false` or cancels the event, the images won't be added to the content. Otherwise,
  * an event `imageAdd` will be fired with the inserted element into the editable area.
  *
  * @class CKEDITOR.plugins.ae_addimages
  */

	/**
  * Fired before adding images to the editor.
  *
  * @event CKEDITOR.plugins.ae_addimages#beforeImageAdd
  * @instance
  * @memberof CKEDITOR.plugins.ae_addimages
  * @param {Array} imageFiles Array of image files
  */

	/**
  * Fired when an image is being added to the editor successfully.
  *
  * @event CKEDITOR.plugins.ae_addimages#imageAdd
  * @instance
  * @memberof CKEDITOR.plugins.ae_addimages
  * @param {CKEDITOR.dom.element} el The created image with src as Data URI
  * @param {File} file The image file
  */

	CKEDITOR.plugins.add('ae_addimages', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function registers a 'dragenter', 'dragover', 'drop' and `paste` events on the editing area.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			editor.once('contentDom', function () {
				var editable = editor.editable();

				editable.attachListener(editable, 'dragenter', this._onDragEnter, this, {
					editor: editor
				});

				editable.attachListener(editable, 'dragover', this._onDragOver, this, {
					editor: editor
				});

				editable.attachListener(editable, 'drop', this._onDragDrop, this, {
					editor: editor
				});

				editable.attachListener(editable, 'paste', this._onPaste, this, {
					editor: editor
				});
			}.bind(this));
		},


		/**
   * Accepts an array of dropped files to the editor. Then, it filters the images and sends them for further
   * processing to {{#crossLink "CKEDITOR.plugins.ae_addimages/_processFile:method"}}{{/crossLink}}
   *
   * @fires CKEDITOR.plugins.ae_addimages#beforeImageAdd
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _handleFiles
   * @param {Array} files Array of dropped files. Only the images from this list will be processed.
   * @param {Object} editor The current editor instance
   * @protected
   */
		_handleFiles: function _handleFiles(files, editor) {
			var file = void 0;
			var i = void 0;

			var imageFiles = [];

			for (i = 0; i < files.length; i++) {
				file = files[i];

				if (file.type.indexOf('image') === 0) {
					imageFiles.push(file);
				}
			}

			var result = editor.fire('beforeImageAdd', {
				imageFiles: imageFiles
			});

			if (result) {
				for (i = 0; i < imageFiles.length; i++) {
					file = imageFiles[i];

					this._processFile(file, editor);
				}
			}

			return false;
		},


		/**
   * Handles drag drop event. The function will create a selection from the current
   * point and will send a list of files to be processed to
   * {{#crossLink "CKEDITOR.plugins.ae_addimages/_handleFiles:method"}}{{/crossLink}} method.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _onDragDrop
   * @param {CKEDITOR.dom.event} event dragdrop event, as received natively from CKEditor
   * @protected
   */
		_onDragDrop: function _onDragDrop(event) {
			var nativeEvent = event.data.$;

			var transferFiles = nativeEvent.dataTransfer.files;

			if (transferFiles.length > 0) {
				new CKEDITOR.dom.event(nativeEvent).preventDefault();

				var editor = event.listenerData.editor;

				event.listenerData.editor.createSelectionFromPoint(nativeEvent.clientX, nativeEvent.clientY);

				this._handleFiles(transferFiles, editor);
			}
		},


		/**
   * Handles drag enter event. In case of IE, this function will prevent the event.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _onDragEnter
   * @param {DOM event} event dragenter event, as received natively from CKEditor
   * @protected
   */
		_onDragEnter: function _onDragEnter(event) {
			if (isIE) {
				this._preventEvent(event);
			}
		},


		/**
   * Handles drag over event. In case of IE, this function will prevent the event.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _onDragOver
   * @param {DOM event} event dragover event, as received natively from CKEditor
   * @protected
   */
		_onDragOver: function _onDragOver(event) {
			if (isIE) {
				this._preventEvent(event);
			}
		},


		/**
   * Checks if the pasted data is image and passes it to
   * {{#crossLink "CKEDITOR.plugins.ae_addimages/_processFile:method"}}{{/crossLink}} for processing.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _onPaste
   * @param {CKEDITOR.dom.event} event A `paste` event, as received natively from CKEditor
   * @protected
   */
		_onPaste: function _onPaste(event) {
			if (event.data && event.data.$ && event.data.$.clipboardData && event.data.$.clipboardData.items && event.data.$.clipboardData.items.length > 0) {
				var pastedData = event.data.$.clipboardData.items[0];

				if (pastedData.type.indexOf('image') === 0) {
					var imageFile = pastedData.getAsFile();

					this._processFile(imageFile, event.listenerData.editor);
				}
			}
		},


		/**
   * Prevents a native event.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _preventEvent
   * @param {DOM event} event The event to be prevented.
   * @protected
   */
		_preventEvent: function _preventEvent(event) {
			event = new CKEDITOR.dom.event(event.data.$);

			event.preventDefault();
			event.stopPropagation();
		},


		/**
   * Processes an image file. The function creates an img element and sets as source
   * a Data URI, then fires an 'imageAdd' event via CKEditor's event system.
   *
   * @fires CKEDITOR.plugins.ae_addimages#imageAdd
   * @instance
   * @memberof CKEDITOR.plugins.ae_addimages
   * @method _preventEvent
   * @param {DOM event} event The event to be prevented.
   * @protected
   */
		_processFile: function _processFile(file, editor) {
			var reader = new FileReader();

			reader.addEventListener('loadend', function () {
				var bin = reader.result;

				var el = CKEDITOR.dom.element.createFromHtml('<img src="' + bin + '">');

				editor.insertElement(el);

				var imageData = {
					el: el,
					file: file
				};

				editor.fire('imageAdd', imageData);
			});

			reader.readAsDataURL(file);
		}
	});
}

/***/ }),

/***/ "./src/plugins/autolink.js":
/*!*********************************!*\
  !*** ./src/plugins/autolink.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (!CKEDITOR.plugins.get('ae_autolink')) {
	// Disables the auto URL detection feature in IE, their lacks functionality:
	// They convert the links only on space. We do on space, comma, semicolon and Enter.
	if (/MSIE ([^;]*)|Trident.*; rv:([0-9.]+)/.test(navigator.userAgent)) {
		document.execCommand('AutoUrlDetect', false, false);
	}

	var KEY_BACK = 8;

	var KEY_COMMA = 188;

	var KEY_ENTER = 13;

	var KEY_SEMICOLON = 186;

	var KEY_SPACE = 32;

	var DELIMITERS = [KEY_COMMA, KEY_ENTER, KEY_SEMICOLON, KEY_SPACE];

	var REGEX_LAST_WORD = /[^\s]+/gim;

	var REGEX_URL = '((([A - Za - z]{ 3, 9}: (?: \\/\\/)?)(?:[-;:&=\\+\\$,\\w]+@)?[A-Za-z0-9.-]+|(https?\\:\\/\\/|www.|[-;:&=.\\+\\$,\\w]+@)[A-Za-z0-9.-]+)((?:\\/[\\+~%\\/.\\w-_]*)?\\??(?:[-\\+=&;%@.\\w_]*)#?(?:[\\w]*))((.*):(\\d*)\\/?(.*))?)';

	var REGEX_EMAIL = /[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}/i;

	/**
  * CKEditor plugin which automatically generates links when user types text which looks like URL.
  *
  * @class CKEDITOR.plugins.ae_autolink
  * @constructor
  */
	CKEDITOR.plugins.add('ae_autolink', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function registers the `keyup` event on the editing area.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			editor.once('contentDom', function () {
				var editable = editor.editable();

				editable.attachListener(editable, 'keyup', this._onKeyUp, this, {
					editor: editor
				});
			}.bind(this));

			editor.on('paste', function (event) {
				if (event.data.method === 'paste') {
					if (event.data.dataValue.indexOf('<') > -1 || event.data.dataValue.indexOf('&lt;') > -1) {
						if (event.data.dataValue.indexOf('<u><font color="') > -1) {
							event.data.dataValue = event.data.dataValue.replace(/<u><font color="#(.*?)">|<\/font><\/u>/g, '');
						}
						return;
					}

					var instance = this;

					event.data.dataValue = event.data.dataValue.replace(RegExp(REGEX_URL, 'gim'), function (url) {
						if (instance._isValidURL(url)) {
							if (instance._isValidEmail(url)) {
								return '<a href="mailto:' + url + '">' + url + '</a>';
							} else {
								return '<a href="' + url + '">' + url + '</a>';
							}
						}
					});
				}
			}.bind(this));
		},


		/**
   * Retrieves the last word introduced by the user. Reads from the current
   * caret position backwards until it finds the first white space.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _getLastWord
   * @protected
   * @return {String} The last word introduced by user
   */
		_getLastWord: function _getLastWord(editor) {
			var range = editor.getSelection().getRanges()[0];

			if (!range) {
				return;
			}

			var offset = range.startOffset;

			var previousText = '';

			// The user pressed Enter, so we have to look on the previous node
			if (this._currentKeyCode === KEY_ENTER) {
				var previousNode = range.startContainer.getPrevious();

				var lastChild = void 0;

				if (previousNode) {
					// If previous node is a SPACE, (it does not have 'getLast' method),
					// ignore it and find the previous text node
					while (!previousNode.getLast) {
						previousNode = previousNode.getPrevious();
					}

					lastChild = previousNode.getLast();

					// Depending on the browser, the last child node may be a <BR>
					// (which does not have 'getText' method),
					// so ignore it and find the previous text node
					while (lastChild && !lastChild.getText()) {
						lastChild = lastChild.getPrevious();
					}
				}

				// Check if the lastChild is already a link
				if (!(lastChild && lastChild.$.href)) {
					this._startContainer = lastChild;
					previousText = lastChild ? lastChild.getText() : '';
					this._offset = previousText.length;
				}
			} else {
				this._startContainer = range.startContainer;

				// Last character is the delimiter, ignore it
				previousText = this._startContainer.getText().substring(0, offset - 1);

				this._offset = offset - 1;
			}

			var lastWord = '';

			var match = previousText.match(REGEX_LAST_WORD);

			if (match) {
				lastWord = match.pop();
			}

			return lastWord;
		},


		/**
   * Checks if the given link is a valid Email.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method isValidEmail
   * @param {String} link The email we want to know if it is a valid Email
   * @protected
   * @return {Boolean} Returns true if the email is a valid Email, false otherwise
   */
		_isValidEmail: function _isValidEmail(email) {
			return REGEX_EMAIL.test(email);
		},


		/**
   * Checks if the given link is a valid URL.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method isValidURL
   * @param {String} link The link we want to know if it is a valid URL
   * @protected
   * @return {Boolean} Returns true if the link is a valid URL, false otherwise
   */
		_isValidURL: function _isValidURL(link) {
			return RegExp(REGEX_URL, 'i').test(link);
		},


		/**
   * Listens to the `keydown` event and if the keycode is `Backspace`, removes the previously
   * created link.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _onKeyDown
   * @param {EventFacade} event EventFacade object
   * @protected
   */
		_onKeyDown: function _onKeyDown(event) {
			var nativeEvent = event.data.$;

			var editor = event.listenerData.editor;

			var editable = editor.editable();

			editable.removeListener('keydown', this._onKeyDown);

			if (nativeEvent.keyCode === KEY_BACK) {
				event.cancel();
				event.data.preventDefault();

				this._removeLink(editor);
			}

			this._ckLink = null;
		},


		/**
   * Listens to the `Enter` and `Space` key events in order to check if the last word
   * introduced by the user should be replaced by a link element.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _onKeyUp
   * @param {EventFacade} event EventFacade object
   * @protected
   */
		_onKeyUp: function _onKeyUp(event) {
			var nativeEvent = event.data.$;

			this._currentKeyCode = nativeEvent.keyCode;

			if (DELIMITERS.indexOf(this._currentKeyCode) !== -1) {
				var editor = event.listenerData.editor;

				var lastWord = this._getLastWord(editor);

				if (this._isValidURL(lastWord)) {
					this._replaceContentByLink(editor, lastWord);
				}
			}
		},


		/**
   * Replaces content by a link element.
   *
   * @fires CKEDITOR.plugins.ae_autolink#autolinkAdd
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _replaceContentByLink
   * @param {String} content The text that has to be replaced by an link element
   * @protected
   */
		_replaceContentByLink: function _replaceContentByLink(editor, content) {
			var range = editor.createRange();
			var node = CKEDITOR.dom.element.get(this._startContainer);
			var offset = this._offset;

			// Select the content, so CKEDITOR.Link can properly replace it
			range.setStart(node, offset - content.length);
			range.setEnd(node, offset);
			range.select();

			var ckLink = new CKEDITOR.Link(editor);
			ckLink.create(content);
			this._ckLink = ckLink;

			var linkNode = ckLink.getFromSelection();
			editor.fire('autolinkAdd', linkNode);

			this._subscribeToKeyEvent(editor);

			// Now range is on the link and it is selected. We have to
			// return focus to the caret position.
			range = editor.getSelection().getRanges()[0];

			// If user pressed `Enter`, get the next editable node at position 0,
			// otherwise set the cursor at the next character of the link (the white space)
			if (this._currentKeyCode === KEY_ENTER) {
				var nextEditableNode = range.getNextEditableNode();

				range.setStart(nextEditableNode, 0);
				range.setEnd(nextEditableNode, 0);
			} else {
				var enclosedNode = range.getEnclosedNode();

				range.setStart(enclosedNode, 0);
				range.setEnd(enclosedNode, 0);
			}

			range.select();
		},


		/**
   * Fired when a URL is detected in text and converted to a link.
   *
   * @event CKEDITOR.plugins.ae_autolink#autolinkAdd
   * @memberof CKEDITOR.plugins.ae_autolink
   * @param {CKEDITOR.dom.element} el Node of the created link.
   */

		/**
   * Removes the created link element, and replaces it by its text.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _removeLink
   * @protected
   */
		_removeLink: function _removeLink(editor) {
			var range = editor.getSelection().getRanges()[0];
			var caretOffset = range.startOffset;

			// Select the link, so CKEDITOR.Link can properly remove it
			var linkNode = this._startContainer.getNext() || this._startContainer;

			var newRange = editor.createRange();
			newRange.setStart(linkNode, 0);
			newRange.setEndAfter(linkNode);
			newRange.select();

			this._ckLink.remove();

			// Return focus to the caret position
			range.setEnd(range.startContainer, caretOffset);
			range.setStart(range.startContainer, caretOffset);

			range.select();
		},


		/**
   * Subscribe to a key event of the editable aria.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolink
   * @method _subscribeToKeyEvent
   * @protected
   */
		_subscribeToKeyEvent: function _subscribeToKeyEvent(editor) {
			var editable = editor.editable();

			// Change the priority of keydown listener - 1 means the highest priority.
			// In Chrome on pressing `Enter` the listener is not being invoked.
			// See http://dev.ckeditor.com/ticket/11861 for more information.
			editable.attachListener(editable, 'keydown', this._onKeyDown, this, {
				editor: editor
			}, 1);
		}
	});
}

/***/ }),

/***/ "./src/plugins/autolist.js":
/*!*********************************!*\
  !*** ./src/plugins/autolist.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (!CKEDITOR.plugins.get('ae_autolist')) {
	var KEY_BACK = 8;

	var KEY_SPACE = 32;

	var DEFAULT_CONFIG = [{
		regex: /^\*$/,
		type: 'bulletedlist'
	}, {
		regex: /^1\.$/,
		type: 'numberedlist'
	}];

	/**
  * CKEditor plugin which automatically generates ordered/unordered list when user types text which looks like a list.
  *
  * @class CKEDITOR.plugins.ae_autolist
  * @constructor
  */
	CKEDITOR.plugins.add('ae_autolist', {
		/**
   * Initialization of the plugin, part of CKeditor plugin lifecycle.
   * The function registers the `keydown` event on the content editing area.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolist
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			editor.once('contentDom', function () {
				var editable = editor.editable();

				editable.attachListener(editable, 'keydown', this._onKeyDown, this, {
					editor: editor
				});
			}.bind(this));
		},


		/**
   * Checks for pressing the `Backspace` key in order to undo the list creation.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolist
   * @method _checkForBackspaceAndUndo
   * @param {Event} event Event object
   * @protected
   */
		_checkForBackspaceAndUndo: function _checkForBackspaceAndUndo(event) {
			var editor = event.listenerData.editor;

			var nativeEvent = event.data.$;

			var editable = editor.editable();

			editable.removeListener('keydown', this._checkForBackspaceAndUndo);

			if (nativeEvent.keyCode === KEY_BACK) {
				editor.execCommand('undo');
				editor.insertHtml(event.listenerData.bullet + '&nbsp;');
				event.data.preventDefault();
			}
		},


		/**
   * Checks current line to find match with MATCHES object to create OL or UL.
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolist
   * @method _checkLine
   * @param {editor} Editor object
   * @protected
   * @return {Object|null} Returns an object which contains the detected list config if any
   */
		_getListConfig: function _getListConfig(editor) {
			var configRegex = editor.config.autolist || DEFAULT_CONFIG;

			var range = editor.getSelection().getRanges()[0];

			var textContainer = range.endContainer.getText();

			var bullet = textContainer.substring(0, range.startOffset);

			var text = textContainer.substring(range.startOffset, textContainer.length);

			var index = 0;

			var regexLen = configRegex.length;

			var autolistCfg = null;

			while (!autolistCfg && regexLen > index) {
				var regexItem = configRegex[index];

				if (regexItem.regex.test(bullet)) {
					autolistCfg = {
						bullet: bullet,
						editor: editor,
						text: text,
						type: regexItem.type
					};

					break;
				}

				index++;
			}

			return autolistCfg;
		},


		/**
   * Create list with different types: Bulleted or Numbered list
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolist
   * @method _createList
   * @param {Object} listConfig Object that contains bullet, text and type for creating the list
   * @protected
   */
		_createList: function _createList(listConfig) {
			var editor = listConfig.editor;

			var range = editor.getSelection().getRanges()[0];

			range.endContainer.setText(listConfig.text);
			editor.execCommand(listConfig.type);

			var editable = editor.editable();

			// Subscribe to keydown in order to check if the next key press is `Backspace`.
			// If so, the creation of the list will be discarded.
			editable.attachListener(editable, 'keydown', this._checkForBackspaceAndUndo, this, {
				editor: editor,
				bullet: listConfig.bullet
			}, 1);
		},


		/**
   * Listens to the `Space` key events to check if the last word
   * introduced by the user should be replaced by a list (OL or UL)
   *
   * @instance
   * @memberof CKEDITOR.plugins.ae_autolist
   * @method _onKeyDown
   * @param {Event} event Event object
   * @protected
   */
		_onKeyDown: function _onKeyDown(event) {
			var nativeEvent = event.data.$;

			if (nativeEvent.keyCode === KEY_SPACE) {
				var listConfig = this._getListConfig(event.listenerData.editor);

				if (listConfig) {
					event.data.preventDefault();
					this._createList(listConfig);
				}
			}
		}
	});
}

/***/ }),

/***/ "./src/plugins/dragresize.js":
/*!***********************************!*\
  !*** ./src/plugins/dragresize.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * CKEditor plugin: Dragable image resizing
 * https://github.com/sstur/ck-dragresize
 * - Shows semi-transparent overlay while resizing
 * - Enforces Aspect Ratio (unless holding shift)
 * - Snap to size of other images in editor
 * - Escape while dragging cancels resize
 */
if (!CKEDITOR.plugins.get('ae_dragresize')) {
	var IMAGE_HANDLES = {
		both: ['tl', 'tm', 'tr', 'lm', 'rm', 'bl', 'bm', 'br'],
		height: ['tl', 'tm', 'tr', 'bl', 'bm', 'br'],
		scale: ['tl', 'tr', 'bl', 'br'],
		width: ['tl', 'tr', 'lm', 'rm', 'bl', 'br']
	};

	var POSITION_ELEMENT_FN = {
		bl: function bl(handle, left, top, box) {
			positionElement(handle, -3 + left, box.height - 4 + top);
		},
		bm: function bm(handle, left, top, box) {
			positionElement(handle, Math.round(box.width / 2) - 3 + left, box.height - 4 + top);
		},
		br: function br(handle, left, top, box) {
			positionElement(handle, box.width - 4 + left, box.height - 4 + top);
		},
		lm: function lm(handle, left, top, box) {
			positionElement(handle, -3 + left, Math.round(box.height / 2) - 3 + top);
		},
		tl: function tl(handle, left, top, _box) {
			positionElement(handle, left - 3, top - 3);
		},
		tm: function tm(handle, left, top, box) {
			positionElement(handle, Math.round(box.width / 2) - 3 + left, -3 + top);
		},
		tr: function tr(handle, left, top, box) {
			positionElement(handle, box.width - 4 + left, -3 + top);
		},
		rm: function rm(handle, left, top, box) {
			positionElement(handle, box.width - 4 + left, Math.round(box.height / 2) - 3 + top);
		}
	};

	var IMAGE_SNAP_TO_SIZE = 7;

	var isFirefox = 'MozAppearance' in document.documentElement.style;

	var isWebKit = 'WebkitAppearance' in document.documentElement.style;

	var enablePlugin = isWebKit || isFirefox;

	if (enablePlugin) {
		// CSS is added in a compressed form
		CKEDITOR.addCss('img::selection{color:rgba(0,0,0,0)}img.ckimgrsz{outline:1px dashed #000}#ckimgrsz{position:absolute;width:0;height:0;cursor:default;z-index:10001}#ckimgrsz span{display:none;position:absolute;top:0;left:0;width:0;height:0;background-size:100% 100%;opacity:.65;outline:1px dashed #000}#ckimgrsz i{position:absolute;display:block;width:5px;height:5px;background:#fff;border:1px solid #000}#ckimgrsz i.active,#ckimgrsz i:hover{background:#000}#ckimgrsz i.br,#ckimgrsz i.tl{cursor:nwse-resize}#ckimgrsz i.bm,#ckimgrsz i.tm{cursor:ns-resize}#ckimgrsz i.bl,#ckimgrsz i.tr{cursor:nesw-resize}#ckimgrsz i.lm,#ckimgrsz i.rm{cursor:ew-resize}body.dragging-br,body.dragging-br *,body.dragging-tl,body.dragging-tl *{cursor:nwse-resize!important}body.dragging-bm,body.dragging-bm *,body.dragging-tm,body.dragging-tm *{cursor:ns-resize!important}body.dragging-bl,body.dragging-bl *,body.dragging-tr,body.dragging-tr *{cursor:nesw-resize!important}body.dragging-lm,body.dragging-lm *,body.dragging-rm,body.dragging-rm *{cursor:ew-resize!important}');
	}

	/**
  * Initializes the plugin
  */
	CKEDITOR.plugins.add('ae_dragresize', {
		onLoad: function onLoad() {
			if (!enablePlugin) {
				return;
			}
		},
		init: function init(editor) {
			if (!enablePlugin) {
				return;
			}

			editor.once('contentDom', function (_evt) {
				_init(editor);
			});
		}
	});

	function _init(editor) {
		var window = editor.window.$;

		var document = editor.document.$;

		if (isFirefox) {
			// Disable the native image resizing
			document.execCommand('enableObjectResizing', false, false);
		}

		var snapToSize = typeof IMAGE_SNAP_TO_SIZE === 'undefined' ? null : IMAGE_SNAP_TO_SIZE;

		editor.config.imageScaleResize = editor.config.imageScaleResize || 'both';

		var resizer = new Resizer(editor, {
			imageScaleResize: editor.config.imageScaleResize,
			snapToSize: snapToSize
		});

		var mouseDownListener = function mouseDownListener(e) {
			if (resizer.isHandle(e.target)) {
				resizer.initDrag(e);
			}
		};

		document.addEventListener('mousedown', mouseDownListener, false);

		function selectionChange() {
			var selection = editor.getSelection();

			if (!selection) return;
			// If an element is selected and that element is an IMG
			if (selection.getType() !== CKEDITOR.SELECTION_NONE && selection.getStartElement().is('img')) {
				// And we're not right or middle clicking on the image
				if (!window.event || !window.event.button || window.event.button === 0) {
					resizer.show(selection.getStartElement().$);
				}
			} else {
				resizer.hide();
			}
		}

		editor.on('selectionChange', selectionChange);

		editor.on('getData', function (e) {
			var html = e.data.dataValue || '';
			html = html.replace(/<div id="ckimgrsz"([\s\S]*?)<\/div>/i, '');
			html = html.replace(/\b(ckimgrsz)\b/g, '');
			e.data.dataValue = html;
		});

		editor.on('beforeUndoImage', function () {
			// Remove the handles before undo images are saved
			resizer.hide();
		});

		editor.on('afterUndoImage', function () {
			// Restore the handles after undo images are saved
			selectionChange();
		});

		editor.on('blur', function () {
			// Remove the handles when editor loses focus
			resizer.hide();
		});

		editor.on('beforeModeUnload', function self() {
			editor.removeListener('beforeModeUnload', self);
			resizer.hide();
		});

		editor.on('destroy', function () {
			var resizeElement = document.getElementById('ckimgrsz');

			if (resizeElement) {
				resizeElement.remove();
			}

			if (isFirefox) {
				document.execCommand('enableObjectResizing', false, true);
			}

			document.removeEventListener('mousedown', mouseDownListener);
		});

		// Update the selection when the browser window is resized
		var resizeTimeout = void 0;
		editor.window.on('resize', function () {
			// Cancel any resize waiting to happen
			clearTimeout(resizeTimeout);
			// Delay resize to "debounce"
			resizeTimeout = setTimeout(selectionChange, 50);
		});
	}

	function Resizer(editor, cfg) {
		this.editor = editor;
		this.window = editor.window.$;
		this.document = editor.document.$;
		this.cfg = cfg || {};
		this.init();
	}

	Resizer.prototype = {
		init: function init() {
			var instance = this;

			var container = this.container = this.document.createElement('div');

			container.id = 'ckimgrsz';
			this.preview = this.document.createElement('span');
			container.appendChild(this.preview);

			var handles = this.handles = {};

			IMAGE_HANDLES[this.cfg.imageScaleResize].forEach(function (handleName) {
				handles[handleName] = instance.handles[handleName] = instance.createHandle(handleName);
			});

			for (var n in handles) {
				if (handles.hasOwnProperty(n)) {
					container.appendChild(handles[n]);
				}
			}
		},
		createHandle: function createHandle(name) {
			var el = this.document.createElement('i');
			el.classList.add(name);
			return el;
		},
		isHandle: function isHandle(el) {
			var handles = this.handles;
			for (var n in handles) {
				if (handles[n] === el) {
					return true;
				}
			}
			return false;
		},
		show: function show(el) {
			var uiNode = this.editor.config.uiNode;

			var scrollTop = uiNode ? uiNode.scrollTop : 0;

			this.el = el;
			if (this.cfg.snapToSize) {
				this.otherImages = toArray(this.document.getElementsByTagName('img'));
				this.otherImages.splice(this.otherImages.indexOf(el), 1);
			}
			var box = this.box = getBoundingBox(this.window, el);
			positionElement(this.container, box.left, box.top + scrollTop);

			uiNode = uiNode || document.body;

			uiNode.appendChild(this.container);

			this.el.classList.add('ckimgrsz');
			this.showHandles();
		},
		hide: function hide() {
			// Remove class from all img.ckimgrsz
			var elements = this.document.getElementsByClassName('ckimgrsz');
			for (var i = 0; i < elements.length; ++i) {
				elements[i].classList.remove('ckimgrsz');
			}
			this.hideHandles();
			if (this.container.parentNode) {
				this.container.parentNode.removeChild(this.container);
			}
		},
		initDrag: function initDrag(e) {
			if (e.button !== 0) {
				// right-click or middle-click
				return;
			}
			var resizer = this;
			var drag = new DragEvent(this.window, this.document);
			drag.onStart = function () {
				resizer.showPreview();
				resizer.isDragging = true;
				resizer.editor.getSelection().lock();
			};
			drag.onDrag = function () {
				resizer.calculateSize(this);
				resizer.updatePreview();
				var box = resizer.previewBox;
				resizer.updateHandles(box, box.left, box.top);
			};
			drag.onRelease = function () {
				resizer.isDragging = false;
				resizer.hidePreview();
				resizer.hide();
				resizer.editor.getSelection().unlock();
				// Save an undo snapshot before the image is permanently changed
				resizer.editor.fire('saveSnapshot');
			};
			drag.onComplete = function () {
				resizer.resizeComplete();
				// Save another snapshot after the image is changed
				resizer.editor.fire('saveSnapshot');
			};
			drag.start(e);
		},
		updateHandles: function updateHandles(box, left, top) {
			left = left || 0;
			top = top || 0;
			var handles = this.handles;

			for (var handle in handles) {
				if (handles.hasOwnProperty(handle)) {
					POSITION_ELEMENT_FN[handle](handles[handle], left, top, box);
				}
			}
		},
		showHandles: function showHandles() {
			var handles = this.handles;
			this.updateHandles(this.box);
			for (var n in handles) {
				if (handles.hasOwnProperty(n)) {
					handles[n].style.display = 'block';
				}
			}
		},
		hideHandles: function hideHandles() {
			var handles = this.handles;
			for (var n in handles) {
				if (handles.hasOwnProperty(n)) {
					handles[n].style.display = 'none';
				}
			}
		},
		showPreview: function showPreview() {
			this.preview.style.backgroundImage = 'url("' + this.el.src + '")';
			this.calculateSize();
			this.updatePreview();
			this.preview.style.display = 'block';
		},
		updatePreview: function updatePreview() {
			var box = this.previewBox;
			positionElement(this.preview, box.left, box.top);
			this.preview.style.width = this.previewBox.width + 'px';
			this.preview.style.height = this.previewBox.height + 'px';
		},
		hidePreview: function hidePreview() {
			var box = getBoundingBox(this.window, this.preview);
			this.result = {
				width: box.width,
				height: box.height
			};
			this.preview.style.display = 'none';
		},
		calculateSize: function calculateSize(data) {
			var box = this.previewBox = {
				top: 0,
				left: 0,
				width: this.box.width,
				height: this.box.height
			};

			if (!data) return;

			var attr = data.target.className;

			if (~attr.indexOf('r')) {
				box.width = Math.max(32, this.box.width + data.delta.x);
			}
			if (~attr.indexOf('b')) {
				box.height = Math.max(32, this.box.height + data.delta.y);
			}
			if (~attr.indexOf('l')) {
				box.width = Math.max(32, this.box.width - data.delta.x);
			}
			if (~attr.indexOf('t')) {
				box.height = Math.max(32, this.box.height - data.delta.y);
			}
			// if dragging corner, enforce aspect ratio (unless shift key is being held)
			if (attr.indexOf('m') < 0 && !data.keys.shift) {
				var ratio = this.box.width / this.box.height;
				if (box.width / box.height > ratio) {
					box.height = Math.round(box.width / ratio);
				} else {
					box.width = Math.round(box.height * ratio);
				}
			}

			var snapToSize = this.cfg.snapToSize;

			if (snapToSize) {
				var others = this.otherImages;
				for (var i = 0; i < others.length; i++) {
					var other = getBoundingBox(this.window, others[i]);
					if (Math.abs(box.width - other.width) <= snapToSize && Math.abs(box.height - other.height) <= snapToSize) {
						box.width = other.width;
						box.height = other.height;
						break;
					}
				}
			}

			// recalculate left or top position
			if (~attr.indexOf('l')) {
				box.left = this.box.width - box.width;
			}
			if (~attr.indexOf('t')) {
				box.top = this.box.height - box.height;
			}
		},
		resizeComplete: function resizeComplete() {
			resizeElement.call(this, this.el, this.result.width, this.result.height);
		}
	};

	function DragEvent(window, document) {
		this.window = window;
		this.document = document;
		this.events = {
			mousemove: bind(this.mousemove, this),
			keydown: bind(this.keydown, this),
			mouseup: bind(this.mouseup, this)
		};
	}

	DragEvent.prototype = {
		start: function start(e) {
			e.preventDefault();
			e.stopPropagation();
			this.target = e.target;
			this.attr = e.target.className;
			this.startPos = {
				x: e.clientX,
				y: e.clientY
			};
			this.update(e);
			var events = this.events;
			this.document.addEventListener('mousemove', events.mousemove, false);
			this.document.addEventListener('keydown', events.keydown, false);
			this.document.addEventListener('mouseup', events.mouseup, false);
			this.document.body.classList.add('dragging-' + this.attr);
			if (this.onStart) {
				this.onStart();
			}
		},
		update: function update(e) {
			this.currentPos = {
				x: e.clientX,
				y: e.clientY
			};
			this.delta = {
				x: e.clientX - this.startPos.x,
				y: e.clientY - this.startPos.y
			};
			this.keys = {
				shift: e.shiftKey,
				ctrl: e.ctrlKey,
				alt: e.altKey
			};
		},
		mousemove: function mousemove(e) {
			this.update(e);
			if (this.onDrag) {
				this.onDrag();
			}
			if (e.which === 0) {
				// mouse button released outside window; mouseup wasn't fired (Chrome)
				this.mouseup(e);
			}
		},
		keydown: function keydown(e) {
			// escape key cancels dragging
			if (e.keyCode === 27) {
				this.release();
			}
		},
		mouseup: function mouseup(e) {
			this.update(e);
			this.release();
			if (this.onComplete) {
				this.onComplete();
			}
		},
		release: function release() {
			this.document.body.classList.remove('dragging-' + this.attr);
			var events = this.events;
			this.document.removeEventListener('mousemove', events.mousemove, false);
			this.document.removeEventListener('keydown', events.keydown, false);
			this.document.removeEventListener('mouseup', events.mouseup, false);
			if (this.onRelease) {
				this.onRelease();
			}
		}
	};

	// helper functions
	function toArray(obj) {
		var len = obj.length;

		var arr = new Array(len);
		for (var i = 0; i < len; i++) {
			arr[i] = obj[i];
		}
		return arr;
	}

	function bind(fn, ctx) {
		if (fn.bind) {
			return fn.bind(ctx);
		}
		return function () {
			for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			fn.apply(ctx, args);
		};
	}

	function positionElement(el, left, top) {
		el.style.left = String(left) + 'px';
		el.style.top = String(top) + 'px';
	}

	function resizeElement(el, width, height) {
		var imageScaleResize = this.editor.config.imageScaleResize;
		if (imageScaleResize === 'both') {
			el.style.width = String(width) + 'px';
			el.style.height = String(height) + 'px';
		} else if (imageScaleResize === 'width' || imageScaleResize === 'scale') {
			el.style.height = 'auto';
			el.style.width = String(width) + 'px';
		} else if (imageScaleResize === 'height') {
			el.style.height = String(height) + 'px';
			el.style.width = 'auto';
		}
	}

	function getBoundingBox(window, el) {
		var rect = el.getBoundingClientRect();
		return {
			left: rect.left + window.pageXOffset,
			top: rect.top + window.pageYOffset,
			width: rect.width,
			height: rect.height
		};
	}
}

/***/ }),

/***/ "./src/plugins/dragresize_ie.js":
/*!**************************************!*\
  !*** ./src/plugins/dragresize_ie.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * CKEditor plugin: Image2
 * - Show gripper to resize images on IE
 */
if (!CKEDITOR.plugins.get('ae_dragresize_ie')) {
	var alignmentsObj = {
		center: 1,
		left: 0,
		right: 2
	};

	/*
  * Set cursor css depend on imageScaleResize config
  **/

	var cursor = {
		both: 'nwse-resize',
		height: 'ns-resize',
		scale: 'nwse-resize',
		width: 'ew-resize'
	};

	var regexPercent = /^\s*(\d+%)\s*$/i;

	var template = '<img alt="" src="" />';

	CKEDITOR.plugins.add('ae_dragresize_ie', {
		hidpi: true,

		icons: 'image',

		init: function init(editor) {
			var image = widgetDef(editor);

			// Register the widget.
			editor.widgets.add('image', image);
		},
		onLoad: function onLoad() {
			CKEDITOR.addCss('.cke_image_resizer_nwse-resize{' + 'cursor: nwse-resize;' + '}' + '.cke_image_resizer_ns-resize{' + 'cursor: ns-resize;' + '}' + '.cke_image_resizer_nwse-resize{' + 'cursor: nwse-resize;' + '}' + '.cke_image_resizer_ew-resize{' + 'cursor: ew-resize;' + '}' + '.cke_image_nocaption{' +
			// This is to remove unwanted space so resize
			// wrapper is displayed property.
			'line-height:0' + '}' + '.cke_image_resizer{' + 'display:none;' + 'position:absolute;' + 'width:10px;' + 'height:10px;' + 'bottom:-5px;' + 'right:-5px;' + 'background:#000;' + 'outline:1px solid #fff;' +
			// Prevent drag handler from being misplaced (#11207).
			'line-height:0;' + 'cursor:nwse-resize;' + '}' + '.cke_image_resizer_wrapper{' + 'position:relative;' + 'display:inline-block;' + 'line-height:0;' + '}' + '.cke_widget_wrapper:hover .cke_image_resizer,' + '.cke_image_resizer.cke_image_resizing{' + 'display:block' + '}');
		},


		requires: 'widget'
	});

	// Widget states (forms) depending on alignment and configuration.
	//
	// Non-captioned widget (inline styles)
	// 		┌──────┬───────────────────────────────┬─────────────────────────────┐
	// 		│Align │Internal form                  │Data                         │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│none  │<wrapper>                      │<img />                      │
	// 		│      │ <img />                       │                             │
	// 		│      │</wrapper>                     │                             │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│left  │<wrapper style=”float:left”>   │<img style=”float:left” />   │
	// 		│      │ <img />                       │                             │
	// 		│      │</wrapper>                     │                             │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│center│<wrapper>                      │<p style=”text-align:center”>│
	// 		│      │ <p style=”text-align:center”> │  <img />                    │
	// 		│      │   <img />                     │</p>                         │
	// 		│      │ </p>                          │                             │
	// 		│      │</wrapper>                     │                             │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│right │<wrapper style=”float:right”>  │<img style=”float:right” />  │
	// 		│      │ <img />                       │                             │
	// 		│      │</wrapper>                     │                             │
	// 		└──────┴───────────────────────────────┴─────────────────────────────┘
	//
	// Non-captioned widget (config.image2_alignClasses defined)
	// 		┌──────┬───────────────────────────────┬─────────────────────────────┐
	// 		│Align │Internal form                  │Data                         │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│none  │<wrapper>                      │<img />                      │
	// 		│      │ <img />                       │                             │
	// 		│      │</wrapper>                     │                             │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│left  │<wrapper class=”left”>         │<img class=”left” />         │
	// 		│      │ <img />                       │                             │
	// 		│      │</wrapper>                     │                             │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│center│<wrapper>                      │<p class=”center”>           │
	// 		│      │ <p class=”center”>            │ <img />                     │
	// 		│      │   <img />                     │</p>                         │
	// 		│      │ </p>                          │                             │
	// 		│      │</wrapper>                     │                             │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│right │<wrapper class=”right”>        │<img class=”right” />        │
	// 		│      │ <img />                       │                             │
	// 		│      │</wrapper>                     │                             │
	// 		└──────┴───────────────────────────────┴─────────────────────────────┘
	//
	// Captioned widget (inline styles)
	// 		┌──────┬────────────────────────────────────────┬────────────────────────────────────────┐
	// 		│Align │Internal form                           │Data                                    │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│none  │<wrapper>                               │<figure />                              │
	// 		│      │ <figure />                             │                                        │
	// 		│      │</wrapper>                              │                                        │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│left  │<wrapper style=”float:left”>            │<figure style=”float:left” />           │
	// 		│      │ <figure />                             │                                        │
	// 		│      │</wrapper>                              │                                        │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│center│<wrapper style=”text-align:center”>     │<div style=”text-align:center”>         │
	// 		│      │ <figure style=”display:inline-block” />│ <figure style=”display:inline-block” />│
	// 		│      │</wrapper>                              │</p>                                    │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│right │<wrapper style=”float:right”>           │<figure style=”float:right” />          │
	// 		│      │ <figure />                             │                                        │
	// 		│      │</wrapper>                              │                                        │
	// 		└──────┴────────────────────────────────────────┴────────────────────────────────────────┘
	//
	// Captioned widget (config.image2_alignClasses defined)
	// 		┌──────┬────────────────────────────────────────┬────────────────────────────────────────┐
	// 		│Align │Internal form                           │Data                                    │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│none  │<wrapper>                               │<figure />                              │
	// 		│      │ <figure />                             │                                        │
	// 		│      │</wrapper>                              │                                        │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│left  │<wrapper class=”left”>                  │<figure class=”left” />                 │
	// 		│      │ <figure />                             │                                        │
	// 		│      │</wrapper>                              │                                        │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│center│<wrapper class=”center”>                │<div class=”center”>                    │
	// 		│      │ <figure />                             │ <figure />                             │
	// 		│      │</wrapper>                              │</p>                                    │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│right │<wrapper class=”right”>                 │<figure class=”right” />                │
	// 		│      │ <figure />                             │                                        │
	// 		│      │</wrapper>                              │                                        │
	// 		└──────┴────────────────────────────────────────┴────────────────────────────────────────┘
	//
	// @param {CKEDITOR.editor}
	// @returns {Object}
	function widgetDef(editor) {
		editor.config.imageScaleResize = editor.config.imageScaleResize || 'both';

		editor.on('imageAdd', function (imageData) {
			editor.widgets.initOn(imageData.data.el, 'image');
		});

		var alignClasses = editor.config.image2_alignClasses;

		var captionedClass = editor.config.image2_captionedClass;

		return {
			init: function init() {
				var helpers = CKEDITOR.plugins.image2;

				var image = this.parts.image;

				var data = {
					alt: image.getAttribute('alt') || '',
					hasCaption: !!this.parts.caption,
					height: image.getAttribute('height') || '',
					// Lock ratio is on by default (#10833).
					lock: this.ready ? helpers.checkHasNaturalRatio(image) : true,
					src: image.getAttribute('src'),
					width: image.getAttribute('width') || ''
				};

				// If we used 'a' in widget#parts definition, it could happen that
				// selected element is a child of widget.parts#caption. Since there's no clever
				// way to solve it with CSS selectors, it's done like that. (#11783).
				var link = image.getAscendant('a');

				if (link && this.wrapper.contains(link)) {
					this.parts.link = link;
				}

				// Depending on configuration, read style/class from element and
				// then remove it. Removed style/class will be set on wrapper in #data listener.
				// Note: Center alignment is detected during upcast, so only left/right cases
				// are checked below.
				if (!data.align) {
					var alignElement = data.hasCaption ? this.element : image;

					// Read the initial left/right alignment from the class set on element.
					if (alignClasses) {
						if (alignElement.hasClass(alignClasses[0])) {
							data.align = 'left';
						} else if (alignElement.hasClass(alignClasses[2])) {
							data.align = 'right';
						}

						if (data.align) {
							alignElement.removeClass(alignClasses[alignmentsObj[data.align]]);
						} else {
							data.align = 'none';
						}
					}
					// Read initial float style from figure/image and then remove it.
					else {
							data.align = alignElement.getStyle('float') || 'none';
							alignElement.removeStyle('float');
						}
				}

				// Get rid of extra vertical space when there's no caption.
				// It will improve the look of the resizer.
				this.wrapper[(data.hasCaption ? 'remove' : 'add') + 'Class']('cke_image_nocaption');

				this.setData(data);

				if (editor.config.image2_disableResizer !== true) {
					setupResizer(this);
				}
			},


			// Overrides default method to handle internal mutability of Image2.
			// @see CKEDITOR.plugins.widget#addClass
			addClass: function addClass(className) {
				getStyleableElement(this).addClass(className);
			},


			allowedContent: getWidgetAllowedContent(editor),

			// This widget converts style-driven dimensions to attributes.
			contentTransformations: [['img[width]: sizeToAttribute']],

			data: function data() {
				var features = this.features;

				// Image can't be captioned when figcaption is disallowed (#11004).
				if (this.data.hasCaption && !editor.filter.checkFeature(features.caption)) {
					this.data.hasCaption = false;
				}

				// Image can't be aligned when floating is disallowed (#11004).
				if (this.data.align != 'none' && !editor.filter.checkFeature(features.align)) {
					this.data.align = 'none';
				}

				// Update widget.parts.link since it will not auto-update unless widget
				// is destroyed and re-inited.
				if (!this.data.link) {
					if (this.parts.link) {
						delete this.parts.link;
					}
				} else {
					if (!this.parts.link) {
						this.parts.link = this.parts.image.getParent();
					}
				}

				this.parts.image.setAttributes({
					alt: this.data.alt,

					contenteditable: this.parts.image.getAttribute('contenteditable') ? this.parts.image.getAttribute('contenteditable') : true,

					// This internal is required by the editor.
					'data-cke-saved-src': this.data.src,

					src: this.data.src
				});

				// If shifting non-captioned -> captioned, remove classes
				// related to styles from <img/>.
				if (this.oldData && !this.oldData.hasCaption && this.data.hasCaption) {
					for (var c in this.data.classes) {
						if (this.data.classes.hasOwnProperty(c)) {
							this.parts.image.removeClass(c);
						}
					}
				}

				// Set dimensions of the image according to gathered data.
				// Do it only when the attributes are allowed (#11004).
				if (editor.filter.checkFeature(features.dimension)) {
					setDimensions(this);
				}

				// Cache current data.
				this.oldData = CKEDITOR.tools.extend({}, this.data);
			},


			downcast: downcastWidgetElement(editor),

			draggable: false,

			// This widget has an editable caption.
			editables: {
				caption: {
					selector: 'figcaption',
					allowedContent: 'br em strong sub sup u s; a[!href,target]'
				}
			},

			features: getWidgetFeatures(editor),

			// Overrides default method to handle internal mutability of Image2.
			// @see CKEDITOR.plugins.widget#getClasses
			getClasses: function () {
				var classRegex = new RegExp('^(' + [].concat(captionedClass, alignClasses).join('|') + ')$');

				return function () {
					var classes = this.repository.parseElementClasses(getStyleableElement(this).getAttribute('class'));

					// Neither config.image2_captionedClass nor config.image2_alignClasses
					// do not belong to style classes.
					for (var c in classes) {
						if (classRegex.test(c)) {
							delete classes[c];
						}
					}

					return classes;
				};
			}(),

			getLabel: function getLabel() {
				var label = (this.data.alt || '') + ' ' + this.pathName;

				return label;
			},


			// Overrides default method to handle internal mutability of Image2.
			// @see CKEDITOR.plugins.widget#hasClass
			hasClass: function hasClass(className) {
				return getStyleableElement(this).hasClass(className);
			},


			parts: {
				caption: 'figcaption',
				image: 'img'
			},

			// Overrides default method to handle internal mutability of Image2.
			// @see CKEDITOR.plugins.widget#removeClass
			removeClass: function removeClass(className) {
				getStyleableElement(this).removeClass(className);
			},


			requiredContent: 'img[src,alt]',

			styleableElements: 'img figure',

			// Template of the widget: plain image.
			template: template,

			upcast: upcastWidgetElement(editor)
		};
	}

	/**
  * A set of Enhanced Image (image2) plugin helpers.
  *
  * @class
  * @singleton
  */
	CKEDITOR.plugins.image2 = {
		/**
   * Checks whether the current image ratio matches the natural one
   * by comparing dimensions.
   *
   * @param {CKEDITOR.dom.element} image
   * @return {Boolean}
   */
		checkHasNaturalRatio: function checkHasNaturalRatio(image) {
			var $ = image.$;

			var natural = this.getNatural(image);

			// The reason for two alternative comparisons is that the rounding can come from
			// both dimensions, e.g. there are two cases:
			// 	1. height is computed as a rounded relation of the real height and the value of width,
			//	2. width is computed as a rounded relation of the real width and the value of heigh.
			return Math.round($.clientWidth / natural.width * natural.height) == $.clientHeight || Math.round($.clientHeight / natural.height * natural.width) == $.clientWidth;
		},


		/**
   * Returns natural dimensions of the image. For modern browsers
   * it uses natural(Width|Height). For old ones (IE8) it creates
   * a new image and reads the dimensions.
   *
   * @param {CKEDITOR.dom.element} image
   * @return {Object}
   */
		getNatural: function getNatural(image) {
			var dimensions = void 0;

			if (image.$.naturalWidth) {
				dimensions = {
					height: image.$.naturalHeigh,
					width: image.$.naturalWidth
				};
			} else {
				var img = new Image();

				img.src = image.getAttribute('src');

				dimensions = {
					height: img.heigh,
					width: img.width
				};
			}

			return dimensions;
		}
	};

	// Returns a function that creates widgets from all <img> and
	// <figure class="{config.image2_captionedClass}"> elements.
	//
	// @param {CKEDITOR.editor} editor
	// @returns {Function}
	function upcastWidgetElement(editor) {
		var isCenterWrapper = centerWrapperChecker(editor);

		var captionedClass = editor.config.image2_captionedClass;

		// @param {CKEDITOR.htmlParser.element} el
		// @param {Object} data
		return function (el, data) {
			var dimensions = {
				height: 1,
				width: 1
			};

			var name = el.name;

			var image = void 0;

			// #11110 Don't initialize on pasted fake objects.
			if (el.attributes['data-cke-realelement']) {
				return;
			}

			// If a center wrapper is found, there are 3 possible cases:
			//
			// 1. <div style="text-align:center"><figure>...</figure></div>.
			//    In this case centering is done with a class set on widget.wrapper.
			//    Simply replace centering wrapper with figure (it's no longer necessary).
			//
			// 2. <p style="text-align:center"><img/></p>.
			//    Nothing to do here: <p> remains for styling purposes.
			//
			// 3. <div style="text-align:center"><img/></div>.
			//    Nothing to do here (2.) but that case is only possible in enterMode different
			//    than ENTER_P.
			if (isCenterWrapper(el)) {
				if (name == 'div') {
					var figure = el.getFirst('figure');

					// Case #1.
					if (figure) {
						el.replaceWith(figure);
						el = figure;
					}
				}
				// Cases #2 and #3 (handled transparently)

				// If there's a centering wrapper, save it in data.
				data.align = 'center';

				// Image can be wrapped in link <a><img/></a>.
				image = el.getFirst('img') || el.getFirst('a').getFirst('img');
			}

			// No center wrapper has been found.
			else if (name == 'figure' && el.hasClass(captionedClass)) {
					image = el.getFirst('img') || el.getFirst('a').getFirst('img');

					// Upcast linked image like <a><img/></a>.
				} else if (isLinkedOrStandaloneImage(el)) {
					image = el.name == 'a' ? el.children[0] : el;
				}

			if (!image) {
				return;
			}

			// If there's an image, then cool, we got a widget.
			// Now just remove dimension attributes expressed with %.
			for (var d in dimensions) {
				if (dimensions.hasOwnProperty(d)) {
					var dimension = image.attributes[d];

					if (dimension && dimension.match(regexPercent)) {
						delete image.attributes[d];
					}
				}
			}

			return el;
		};
	}

	// Returns a function which transforms the widget to the external format
	// according to the current configuration.
	//
	// @param {CKEDITOR.editor}
	function downcastWidgetElement(editor) {
		var alignClasses = editor.config.image2_alignClasses;

		// @param {CKEDITOR.htmlParser.element} el
		return function (el) {
			// In case of <a><img/></a>, <img/> is the element to hold
			// inline styles or classes (image2_alignClasses).
			var attrsHolder = el.name == 'a' ? el.getFirst() : el;

			delete attrsHolder.attributes.contenteditable;

			var attrs = attrsHolder.attributes;

			var align = this.data.align;

			// De-wrap the image from resize handle wrapper.
			// Only block widgets have one.
			if (!this.inline) {
				var resizeWrapper = el.getFirst('span');

				if (resizeWrapper) {
					resizeWrapper.replaceWith(resizeWrapper.getFirst({
						a: 1,
						img: 1
					}));
				}
			}

			if (align && align != 'none') {
				var styles = CKEDITOR.tools.parseCssText(attrs.style || '');

				// When the widget is captioned (<figure>) and internally centering is done
				// with widget's wrapper style/class, in the external data representation,
				// <figure> must be wrapped with an element holding an style/class:
				//
				// 	<div style="text-align:center">
				// 		<figure class="image" style="display:inline-block">...</figure>
				// 	</div>
				// or
				// 	<div class="some-center-class">
				// 		<figure class="image">...</figure>
				// 	</div>
				//
				if (align == 'center' && el.name == 'figure') {
					el = el.wrapWith(new CKEDITOR.htmlParser.element('div', alignClasses ? {
						class: alignClasses[1]
					} : {
						style: 'text-align:center'
					}));
				}

				// If left/right, add float style to the downcasted element.
				else if (align in {
						left: 1,
						right: 1
					}) {
						if (alignClasses) {
							attrsHolder.addClass(alignClasses[alignmentsObj[align]]);
						} else {
							styles['float'] = align;
						}
					}

				// Update element styles.
				if (!alignClasses && !CKEDITOR.tools.isEmpty(styles)) {
					attrs.style = CKEDITOR.tools.writeCssText(styles);
				}
			}

			return el;
		};
	}

	// Returns a function that checks if an element is a centering wrapper.
	//
	// @param {CKEDITOR.editor} editor
	// @returns {Function}
	function centerWrapperChecker(editor) {
		var captionedClass = editor.config.image2_captionedClass;

		var alignClasses = editor.config.image2_alignClasses;

		var validChildren = {
			a: 1,
			figure: 1,
			img: 1
		};

		return function (el) {
			// Wrapper must be either <div> or <p>.
			if (!(el.name in {
				div: 1,
				p: 1
			})) {
				return false;
			}

			var children = el.children;

			// Centering wrapper can have only one child.
			if (children.length !== 1) {
				return false;
			}

			var child = children[0];

			// Only <figure> or <img /> can be first (only) child of centering wrapper,
			// regardless of its type.
			if (!(child.name in validChildren)) {
				return false;
			}

			// If centering wrapper is <p>, only <img /> can be the child.
			//   <p style="text-align:center"><img /></p>
			if (el.name == 'p') {
				if (!isLinkedOrStandaloneImage(child)) {
					return false;
				}
			}
			// Centering <div> can hold <img/> or <figure>, depending on enterMode.
			else {
					// If a <figure> is the first (only) child, it must have a class.
					//   <div style="text-align:center"><figure>...</figure><div>
					if (child.name == 'figure') {
						if (!child.hasClass(captionedClass)) {
							return false;
						}
					} else {
						// Centering <div> can hold <img/> or <a><img/></a> only when enterMode
						// is ENTER_(BR|DIV).
						//   <div style="text-align:center"><img /></div>
						//   <div style="text-align:center"><a><img /></a></div>
						if (editor.enterMode == CKEDITOR.ENTER_P) {
							return false;
						}

						// Regardless of enterMode, a child which is not <figure> must be
						// either <img/> or <a><img/></a>.
						if (!isLinkedOrStandaloneImage(child)) {
							return false;
						}
					}
				}

			// Centering wrapper got to be... centering. If image2_alignClasses are defined,
			// check for centering class. Otherwise, check the style.
			if (alignClasses ? el.hasClass(alignClasses[1]) : CKEDITOR.tools.parseCssText(el.attributes.style || '', true)['text-align'] == 'center') {
				return true;
			}

			return false;
		};
	}

	// Checks whether element is <img/> or <a><img/></a>.
	//
	// @param {CKEDITOR.htmlParser.element}
	function isLinkedOrStandaloneImage(el) {
		if (el.name == 'img') {
			return true;
		} else if (el.name == 'a') {
			return el.children.length == 1 && el.getFirst('img');
		}

		return false;
	}

	// Sets width and height of the widget image according to current widget data.
	//
	// @param {CKEDITOR.plugins.widget} widget
	function setDimensions(widget) {
		var data = widget.data;

		var dimensions = {
			height: data.height,
			width: data.width
		};

		var image = widget.parts.image;

		for (var d in dimensions) {
			if (dimensions[d]) {
				image.setAttribute(d, dimensions[d]);
			} else {
				image.removeAttribute(d);
			}
		}
	}

	// Defines all features related to drag-driven image resizing.
	//
	// @param {CKEDITOR.plugins.widget} widget
	function setupResizer(widget) {
		var editor = widget.editor;

		var editable = editor.editable();

		var doc = editor.document;

		// Store the resizer in a widget for testing (#11004).
		var resizer = widget.resizer = doc.createElement('span');

		resizer.addClass('cke_image_resizer');
		resizer.addClass('cke_image_resizer_' + cursor[editor.config.imageScaleResize]);
		resizer.append(new CKEDITOR.dom.text('\u200B', doc));

		// Inline widgets don't need a resizer wrapper as an image spans the entire widget.
		if (!widget.inline) {
			var imageOrLink = widget.parts.link || widget.parts.image;

			var oldResizeWrapper = imageOrLink.getParent();

			var resizeWrapper = doc.createElement('span');

			resizeWrapper.addClass('cke_image_resizer_wrapper');
			resizeWrapper.append(imageOrLink);
			resizeWrapper.append(resizer);
			widget.element.append(resizeWrapper, true);

			// Remove the old wrapper which could came from e.g. pasted HTML
			// and which could be corrupted (e.g. resizer span has been lost).
			if (oldResizeWrapper.is('span')) {
				oldResizeWrapper.remove();
			}
		} else {
			widget.wrapper.append(resizer);
		}

		// Calculate values of size variables and mouse offsets.
		resizer.on('mousedown', function (evt) {
			var image = widget.parts.image;

			// "factor" can be either 1 or -1. I.e.: For right-aligned images, we need to
			// subtract the difference to get proper width, etc. Without "factor",
			// resizer starts working the opposite way.
			var factor = widget.data.align == 'right' ? -1 : 1;

			// The x-coordinate of the mouse relative to the screen
			// when button gets pressed.
			var startX = evt.data.$.screenX;

			var startY = evt.data.$.screenY;

			// The initial dimensions and aspect ratio of the image.
			var startWidth = image.$.clientWidth;

			var startHeight = image.$.clientHeight;

			var listeners = [];

			// A class applied to editable during resizing.
			var cursorClass = 'cke_image_s' + (!~factor ? 'w' : 'e');

			var nativeEvt = void 0;
			var newWidth = void 0;
			var newHeight = void 0;
			var updateData = void 0;

			var moveDiffX = void 0;
			var moveDiffY = void 0;

			// Save the undo snapshot first: before resizing.
			editor.fire('saveSnapshot');

			// Mousemove listeners are removed on mouseup.
			attachToDocuments('mousemove', onMouseMove, listeners);

			// Clean up the mousemove listener. Update widget data if valid.
			attachToDocuments('mouseup', onMouseUp, listeners);

			// The entire editable will have the special cursor while resizing goes on.
			editable.addClass(cursorClass);

			// This is to always keep the resizer element visible while resizing.
			resizer.addClass('cke_image_resizing');

			// Attaches an event to a global document if inline editor.
			// Additionally, if classic (`iframe`-based) editor, also attaches the same event to `iframe`'s document.
			function attachToDocuments(name, callback, collection) {
				var globalDoc = CKEDITOR.document;

				var listeners = [];

				if (!doc.equals(globalDoc)) {
					listeners.push(globalDoc.on(name, callback));
				}

				listeners.push(doc.on(name, callback));

				if (collection) {
					for (var i = listeners.length; i--;) {
						collection.push(listeners.pop());
					}
				}
			}

			// This is how variables refer to the geometry.
			// Note: x corresponds to moveOffset, this is the position of mouse
			// Note: o corresponds to [startX, startY].
			//
			// 	+--------------+--------------+
			// 	|              |              |
			// 	|      I       |      II      |
			// 	|              |              |
			// 	+------------- o -------------+ _ _ _
			// 	|              |              |      ^

			// 	|      VI      |     III      |      | moveDiffY
			// 	|              |         x _ _ _ _ _ v
			// 	+--------------+---------|----+
			// 	               |         |
			// 	                <------->
			// 	                moveDiffX
			function onMouseMove(evt) {
				var imageScaleResize = editor.config.imageScaleResize;

				nativeEvt = evt.data.$;

				// This is how far the mouse is from the point the button was pressed.
				moveDiffX = nativeEvt.screenX - startX;
				moveDiffY = startY - nativeEvt.screenY;

				if (imageScaleResize === 'width' || imageScaleResize === 'both' || imageScaleResize === 'scale') {
					newWidth = startWidth + factor * moveDiffX;
				}

				if (imageScaleResize === 'height' || imageScaleResize === 'both') {
					newHeight = startHeight - moveDiffY;
				}

				if (imageScaleResize === 'scale') {
					newHeight = 'auto';
				}

				newWidth = newWidth || startWidth;
				newHeight = newHeight || startHeight;

				// Don't update attributes if less than 10.
				// This is to prevent images to visually disappear.
				if (newWidth >= 15 && (newHeight >= 15 || newHeight === 'auto')) {
					image.$.style.width = newWidth + 'px';
					image.$.style.height = newHeight + 'px';

					updateData = true;
				} else {
					updateData = false;
				}
			}

			function onMouseUp() {
				var l = void 0;

				while (l = listeners.pop()) {
					l.removeListener();
				}

				// Restore default cursor by removing special class.
				editable.removeClass(cursorClass);

				// This is to bring back the regular behaviour of the resizer.
				resizer.removeClass('cke_image_resizing');

				if (updateData) {
					widget.setData({
						height: newHeight,
						width: newWidth
					});

					// Save another undo snapshot: after resizing.
					editor.fire('saveSnapshot');
				}

				// Don't update data twice or more.
				updateData = false;
			}
		});

		// Change the position of the widget resizer when data changes.
		widget.on('data', function () {
			resizer[widget.data.align == 'right' ? 'addClass' : 'removeClass']('cke_image_resizer_left');
		});

		widget.parts.image.on('click', function () {
			var selection = editor.getSelection();

			if (selection) {
				var element = selection.getStartElement();

				if (element) {
					var widgetElement = element.findOne('img');

					if (widgetElement) {
						var region = element.getClientRect();

						var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();
						region.left -= scrollPosition.x;
						region.top += scrollPosition.y;

						region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;

						editor.fire('editorInteraction', {
							nativeEvent: event,
							selectionData: {
								element: widgetElement,
								region: region
							}
						});
					}
				}
			}
		});
	}

	// Returns a set of widget allowedContent rules, depending
	// on configurations like config#image2_alignClasses or
	// config#image2_captionedClass.
	//
	// @param {CKEDITOR.editor}
	// @returns {Object}
	function getWidgetAllowedContent(editor) {
		var rules = {
			figcaption: true,
			figure: {
				classes: '!' + editor.config.image2_captionedClass
			},
			img: {
				attributes: '!src,alt,width,height'
			}
		};

		return rules;
	}

	// Returns a set of widget feature rules, depending
	// on editor configuration. Note that the following may not cover
	// all the possible cases since requiredContent supports a single
	// tag only.
	//
	// @param {CKEDITOR.editor}
	// @returns {Object}
	function getWidgetFeatures(editor) {
		var alignClasses = editor.config.image2_alignClasses;

		var features = {
			align: {
				requiredContent: 'img' + (alignClasses ? '(' + alignClasses[0] + ')' : '{float}')
			},
			caption: {
				requiredContent: 'figcaption'
			},
			dimension: {
				requiredContent: 'img[width,height]'
			}
		};

		return features;
	}

	// Returns element which is styled, considering current
	// state of the widget.
	//
	// @see CKEDITOR.plugins.widget#applyStyle
	// @param {CKEDITOR.plugins.widget} widget
	// @returns {CKEDITOR.dom.element}
	function getStyleableElement(widget) {
		return widget.data.hasCaption ? widget.element : widget.parts.image;
	}
}

CKEDITOR.config.image2_captionedClass = 'image';

/***/ }),

/***/ "./src/plugins/dragresize_ie11.js":
/*!****************************************!*\
  !*** ./src/plugins/dragresize_ie11.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @license Copyright (c) 2003-2017, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

(function () {
	if (CKEDITOR.plugins.get('ae_dragresize_ie11')) {
		return;
	}

	var template = '<img alt="" src="" />';

	var templateBlock = new CKEDITOR.template('<figure class="{captionedClass}">' + template + '<figcaption>{captionPlaceholder}</figcaption>' + '</figure>');

	var alignmentsObj = { left: 0, center: 1, right: 2 };

	var regexPercent = /^\s*(\d+%)\s*$/i;

	CKEDITOR.plugins.add('ae_dragresize_ie11', {
		requires: 'widget',
		onLoad: function onLoad() {
			CKEDITOR.addCss('.cke_image_nocaption{' +
			// This is to remove unwanted space so resize
			// wrapper is displayed property.
			'line-height:0' + '}' + '.cke_editable.cke_image_ne, .cke_editable.cke_image_ne *{cursor:ne-resize !important}' + '.cke_editable.cke_image_nw, .cke_editable.cke_image_nw *{cursor:nw-resize !important}' + '.cke_editable.cke_image_sw, .cke_editable.cke_image_sw *{cursor:sw-resize !important}' + '.cke_editable.cke_image_se, .cke_editable.cke_image_se *{cursor:se-resize !important}' + '.cke_image_resizer{' + 'display:none;' + 'position:absolute;' + 'width:10px;' + 'height:10px;' + 'background:#000;' + 'outline:1px solid #fff;' +
			// Prevent drag handler from being misplaced (#11207).
			'line-height:0;' + 'cursor:se-resize;' + '}' + '.cke_image_resizer_wrapper{' + 'position:relative;' + 'display:inline-block;' + 'line-height:0;' + '}' +
			// Top-right corner style of the resizer.
			'.cke_image_resizer.cke_image_resizer_ne{' + 'cursor:ne-resize;' + 'left:auto;' + 'right:-5px;' + 'top:-5px;' + '}' +
			// Top-left corner style of the resizer.
			'.cke_image_resizer.cke_image_resizer_nw{' + 'cursor:nw-resize;' + 'left:-5px;' + 'right:auto;' + 'top:-5px;' + '}' +
			// Bottom-right corner style of the resizer.
			'.cke_image_resizer.cke_image_resizer_se{' + 'bottom:-5px;' + 'cursor:se-resize;' + 'left:auto;' + 'right:-5px;' + '}' +
			// Bottom-left corner style of the resizer.
			'.cke_image_resizer.cke_image_resizer_sw{' + 'bottom:-5px;' + 'cursor:sw-resize;' + 'left:-5px;' + 'right:auto;' + '}' + '.cke_widget_wrapper:hover .cke_image_resizer,' + '.cke_image_resizing>.cke_image_resizer{' + 'display:block' + '}' +
			// Expand widget wrapper when linked inline image.
			'.cke_widget_wrapper>a{' + 'display:inline-block' + '}');
		},
		init: function init(editor) {
			// Adapts configuration from original image plugin. Should be removed
			// when we'll rename ae_dragresize_ie11 to image.

			var image = widgetDef(editor);

			// Register the widget.
			editor.widgets.add('image', image);

			// Add a listener to handle selection change events and properly detect editor
			// interactions on the widgets without messing with widget native selection
			editor.on('selectionChange', function (_event) {
				var selection = editor.getSelection();

				if (selection) {
					var element = selection.getSelectedElement();

					if (element) {
						var widgetElement = element.findOne('img');

						if (widgetElement) {
							var region = element.getClientRect();

							var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();
							region.left -= scrollPosition.x;
							region.top += scrollPosition.y;

							region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;

							editor.fire('editorInteraction', {
								nativeEvent: {},
								selectionData: {
									element: widgetElement,
									region: region
								}
							});
						}
					}
				}
			});
		},
		afterInit: function afterInit(editor) {
			// Integrate with align commands (justify plugin).
			var align = { left: 1, right: 1, center: 1, block: 1 };

			var integrate = alignCommandIntegrator(editor);

			for (var value in align) {
				if (align.hasOwnProperty(value)) {
					integrate(value);
				}
			}
		}
	});

	// Widget states (forms) depending on alignment and configuration.
	//
	// Non-captioned widget (inline styles)
	// 		┌──────┬───────────────────────────────┬─────────────────────────────┐
	// 		│Align │Internal form                  │Data                         │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│none  │<wrapper>                      │<img />                      │
	// 		│      │ <img />                       │                             │
	// 		│      │</wrapper>                     │                             │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│left  │<wrapper style=”float:left”>   │<img style=”float:left” />   │
	// 		│      │ <img />                       │                             │
	// 		│      │</wrapper>                     │                             │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│center│<wrapper>                      │<p style=”text-align:center”>│
	// 		│      │ <p style=”text-align:center”> │  <img />                    │
	// 		│      │   <img />                     │</p>                         │
	// 		│      │ </p>                          │                             │
	// 		│      │</wrapper>                     │                             │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│right │<wrapper style=”float:right”>  │<img style=”float:right” />  │
	// 		│      │ <img />                       │                             │
	// 		│      │</wrapper>                     │                             │
	// 		└──────┴───────────────────────────────┴─────────────────────────────┘
	//
	// Non-captioned widget (config.ae_dragresize_ie11_alignClasses defined)
	// 		┌──────┬───────────────────────────────┬─────────────────────────────┐
	// 		│Align │Internal form                  │Data                         │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│none  │<wrapper>                      │<img />                      │
	// 		│      │ <img />                       │                             │
	// 		│      │</wrapper>                     │                             │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│left  │<wrapper class=”left”>         │<img class=”left” />         │
	// 		│      │ <img />                       │                             │
	// 		│      │</wrapper>                     │                             │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│center│<wrapper>                      │<p class=”center”>           │
	// 		│      │ <p class=”center”>            │ <img />                     │
	// 		│      │   <img />                     │</p>                         │
	// 		│      │ </p>                          │                             │
	// 		│      │</wrapper>                     │                             │
	// 		├──────┼───────────────────────────────┼─────────────────────────────┤
	// 		│right │<wrapper class=”right”>        │<img class=”right” />        │
	// 		│      │ <img />                       │                             │
	// 		│      │</wrapper>                     │                             │
	// 		└──────┴───────────────────────────────┴─────────────────────────────┘
	//
	// Captioned widget (inline styles)
	// 		┌──────┬────────────────────────────────────────┬────────────────────────────────────────┐
	// 		│Align │Internal form                           │Data                                    │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│none  │<wrapper>                               │<figure />                              │
	// 		│      │ <figure />                             │                                        │
	// 		│      │</wrapper>                              │                                        │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│left  │<wrapper style=”float:left”>            │<figure style=”float:left” />           │
	// 		│      │ <figure />                             │                                        │
	// 		│      │</wrapper>                              │                                        │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│center│<wrapper style=”text-align:center”>     │<div style=”text-align:center”>         │
	// 		│      │ <figure style=”display:inline-block” />│ <figure style=”display:inline-block” />│
	// 		│      │</wrapper>                              │</p>                                    │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│right │<wrapper style=”float:right”>           │<figure style=”float:right” />          │
	// 		│      │ <figure />                             │                                        │
	// 		│      │</wrapper>                              │                                        │
	// 		└──────┴────────────────────────────────────────┴────────────────────────────────────────┘
	//
	// Captioned widget (config.ae_dragresize_ie11_alignClasses defined)
	// 		┌──────┬────────────────────────────────────────┬────────────────────────────────────────┐
	// 		│Align │Internal form                           │Data                                    │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│none  │<wrapper>                               │<figure />                              │
	// 		│      │ <figure />                             │                                        │
	// 		│      │</wrapper>                              │                                        │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│left  │<wrapper class=”left”>                  │<figure class=”left” />                 │
	// 		│      │ <figure />                             │                                        │
	// 		│      │</wrapper>                              │                                        │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│center│<wrapper class=”center”>                │<div class=”center”>                    │
	// 		│      │ <figure />                             │ <figure />                             │
	// 		│      │</wrapper>                              │</p>                                    │
	// 		├──────┼────────────────────────────────────────┼────────────────────────────────────────┤
	// 		│right │<wrapper class=”right”>                 │<figure class=”right” />                │
	// 		│      │ <figure />                             │                                        │
	// 		│      │</wrapper>                              │                                        │
	// 		└──────┴────────────────────────────────────────┴────────────────────────────────────────┘
	//
	// @param {CKEDITOR.editor}
	// @returns {Object}
	function widgetDef(editor) {
		var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

		var captionedClass = editor.config.ae_dragresize_ie11_captionedClass;

		function deflate() {
			if (this.deflated) return;

			// Remember whether widget was focused before destroyed.
			if (editor.widgets.focused == this.widget) this.focused = true;

			editor.widgets.destroy(this.widget);

			// Mark widget was destroyed.
			this.deflated = true;
		}

		function inflate() {
			var editable = editor.editable();

			var doc = editor.document;

			// Create a new widget. This widget will be either captioned
			// non-captioned, block or inline according to what is the
			// new state of the widget.
			if (this.deflated) {
				this.widget = editor.widgets.initOn(this.element, 'image', this.widget.data);

				// Once widget was re-created, it may become an inline element without
				// block wrapper (i.e. when unaligned, end not captioned). Let's do some
				// sort of autoparagraphing here (#10853).
				if (this.widget.inline && !new CKEDITOR.dom.elementPath(this.widget.wrapper, editable).block) {
					var block = doc.createElement(editor.activeEnterMode == CKEDITOR.ENTER_P ? 'p' : 'div');
					block.replace(this.widget.wrapper);
					this.widget.wrapper.move(block);
				}

				// The focus must be transferred from the old one (destroyed)
				// to the new one (just created).
				if (this.focused) {
					this.widget.focus();
					delete this.focused;
				}

				delete this.deflated;
			}

			// If now widget was destroyed just update wrapper's alignment.
			// According to the new state.
			else {
					setWrapperAlign(this.widget, alignClasses);
				}
		}

		return {
			allowedContent: getWidgetAllowedContent(editor),

			requiredContent: 'img[src,alt]',

			features: getWidgetFeatures(editor),

			styleableElements: 'img figure',

			// This widget converts style-driven dimensions to attributes.
			contentTransformations: [['img[width]: sizeToAttribute']],

			// This widget has an editable caption.
			editables: {
				caption: {
					selector: 'figcaption',
					allowedContent: 'br em strong sub sup u s; a[!href,target]'
				}
			},

			parts: {
				image: 'img',
				caption: 'figcaption'
				// parts#link defined in widget#init
			},

			// Template of the widget: plain image.
			template: template,

			data: function data() {
				var features = this.features;

				// Image can't be captioned when figcaption is disallowed (#11004).
				if (this.data.hasCaption && !editor.filter.checkFeature(features.caption)) this.data.hasCaption = false;

				// Image can't be aligned when floating is disallowed (#11004).
				if (this.data.align != 'none' && !editor.filter.checkFeature(features.align)) this.data.align = 'none';

				// Convert the internal form of the widget from the old state to the new one.
				this.shiftState({
					widget: this,
					element: this.element,
					oldData: this.oldData,
					newData: this.data,
					deflate: deflate,
					inflate: inflate
				});

				// Update widget.parts.link since it will not auto-update unless widget
				// is destroyed and re-inited.
				if (!this.data.link) {
					if (this.parts.link) delete this.parts.link;
				} else {
					if (!this.parts.link) this.parts.link = this.parts.image.getParent();
				}

				this.parts.image.setAttributes({
					src: this.data.src,

					// This internal is required by the editor.
					'data-cke-saved-src': this.data.src,

					alt: this.data.alt
				});

				// If shifting non-captioned -> captioned, remove classes
				// related to styles from <img/>.
				if (this.oldData && !this.oldData.hasCaption && this.data.hasCaption) {
					for (var c in this.data.classes) {
						if (this.data.classes.hasOwnProperty(c)) {
							this.parts.image.removeClass(c);
						}
					}
				}

				// Set dimensions of the image according to gathered data.
				// Do it only when the attributes are allowed (#11004).
				if (editor.filter.checkFeature(features.dimension)) setDimensions(this);

				// Cache current data.
				this.oldData = CKEDITOR.tools.extend({}, this.data);
			},
			init: function init() {
				var helpers = CKEDITOR.plugins.ae_dragresize_ie11;

				var image = this.parts.image;

				var data = {
					hasCaption: !!this.parts.caption,
					src: image.getAttribute('src'),
					alt: image.getAttribute('alt') || '',
					width: image.getAttribute('width') || '',
					height: image.getAttribute('height') || '',

					// Lock ratio is on by default (#10833).
					lock: this.ready ? helpers.checkHasNaturalRatio(image) : true
				};

				// If we used 'a' in widget#parts definition, it could happen that
				// selected element is a child of widget.parts#caption. Since there's no clever
				// way to solve it with CSS selectors, it's done like that. (#11783).
				var link = image.getAscendant('a');

				if (link && this.wrapper.contains(link)) this.parts.link = link;

				// Depending on configuration, read style/class from element and
				// then remove it. Removed style/class will be set on wrapper in #data listener.
				// Note: Center alignment is detected during upcast, so only left/right cases
				// are checked below.
				if (!data.align) {
					var alignElement = data.hasCaption ? this.element : image;

					// Read the initial left/right alignment from the class set on element.
					if (alignClasses) {
						if (alignElement.hasClass(alignClasses[0])) {
							data.align = 'left';
						} else if (alignElement.hasClass(alignClasses[2])) {
							data.align = 'right';
						}

						if (data.align) {
							alignElement.removeClass(alignClasses[alignmentsObj[data.align]]);
						} else {
							data.align = 'none';
						}
					}
					// Read initial float style from figure/image and then remove it.
					else {
							data.align = alignElement.getStyle('float') || 'none';
							alignElement.removeStyle('float');
						}
				}

				// Update data.link object with attributes if the link has been discovered.
				if (editor.plugins.link && this.parts.link) {
					data.link = helpers.getLinkAttributesParser()(editor, this.parts.link);

					// Get rid of cke_widget_* classes in data. Otherwise
					// they might appear in link dialog.
					var advanced = data.link.advanced;
					if (advanced && advanced.advCSSClasses) {
						advanced.advCSSClasses = CKEDITOR.tools.trim(advanced.advCSSClasses.replace(/cke_\S+/, ''));
					}
				}

				// Get rid of extra vertical space when there's no caption.
				// It will improve the look of the resizer.
				this.wrapper[(data.hasCaption ? 'remove' : 'add') + 'Class']('cke_image_nocaption');

				this.setData(data);

				// Setup dynamic image resizing with mouse.
				// Don't initialize resizer when dimensions are disallowed (#11004).
				if (editor.filter.checkFeature(this.features.dimension) && editor.config.ae_dragresize_ie11_disableResizer !== true) setupResizer(this);

				var dragHandlerStyle = this.dragHandlerContainer.$.style;
				dragHandlerStyle.setAttribute('backgroundColor', 'rgba(255, 255, 255, 1');
				dragHandlerStyle.setAttribute('opacity', '1');

				this.shiftState = helpers.stateShifter(this.editor);

				// Add widget editing option to its context menu.
				this.on('contextMenu', function (evt) {
					evt.data.image = CKEDITOR.TRISTATE_OFF;

					// Integrate context menu items for link.
					// Note that widget may be wrapped in a link, which
					// does not belong to that widget (#11814).
					if (this.parts.link || this.wrapper.getAscendant('a')) evt.data.link = evt.data.unlink = CKEDITOR.TRISTATE_OFF;
				});
			},


			// Overrides default method to handle internal mutability of ae_dragresize_ie11.
			// @see CKEDITOR.plugins.widget#addClass
			addClass: function addClass(className) {
				getStyleableElement(this).addClass(className);
			},


			// Overrides default method to handle internal mutability of ae_dragresize_ie11.
			// @see CKEDITOR.plugins.widget#hasClass
			hasClass: function hasClass(className) {
				return getStyleableElement(this).hasClass(className);
			},


			// Overrides default method to handle internal mutability of ae_dragresize_ie11.
			// @see CKEDITOR.plugins.widget#removeClass
			removeClass: function removeClass(className) {
				getStyleableElement(this).removeClass(className);
			},


			// Overrides default method to handle internal mutability of ae_dragresize_ie11.
			// @see CKEDITOR.plugins.widget#getClasses
			getClasses: function () {
				var classRegex = new RegExp('^(' + [].concat(captionedClass, alignClasses).join('|') + ')$');

				return function () {
					var classes = this.repository.parseElementClasses(getStyleableElement(this).getAttribute('class'));

					// Neither config.ae_dragresize_ie11_captionedClass nor config.ae_dragresize_ie11_alignClasses
					// do not belong to style classes.
					for (var c in classes) {
						if (classRegex.test(c)) delete classes[c];
					}

					return classes;
				};
			}(),

			upcast: upcastWidgetElement(editor),
			downcast: downcastWidgetElement(editor),

			getLabel: function getLabel() {
				var label = (this.data.alt || '') + ' ' + this.pathName;

				return this.editor.lang.widget.label.replace(/%1/, label);
			}
		};
	}

	/**
  * A set of Enhanced Image (ae_dragresize_ie11) plugin helpers.
  *
  * @class
  * @singleton
  */
	CKEDITOR.plugins.ae_dragresize_ie11 = {
		stateShifter: function stateShifter(editor) {
			// Tag name used for centering non-captioned widgets.
			var doc = editor.document;

			var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

			var captionedClass = editor.config.ae_dragresize_ie11_captionedClass;

			var editable = editor.editable();

			// The order that stateActions get executed. It matters!

			var shiftables = ['hasCaption', 'align', 'link'];

			// Atomic procedures, one per state variable.
			var stateActions = {
				align: function align(shift, oldValue, newValue) {
					var el = shift.element;

					// Alignment changed.
					if (shift.changed.align || el.$.style.marginLeft === 'auto' && el.$.style.marginRight === 'auto') {
						// No caption in the new state.
						if (!shift.newData.hasCaption) {
							// Changed to "center" (non-captioned).
							if (newValue == 'center' || el.$.style.marginLeft === 'auto' && el.$.style.marginRight === 'auto') {
								shift.deflate();
								shift.element = wrapInCentering(editor, el);
							}

							// Changed to "non-center" from "center" while caption removed.
							if (!shift.changed.hasCaption && oldValue == 'center' && newValue != 'center') {
								shift.deflate();
								shift.element = unwrapFromCentering(el);
							}
						}
					}

					// Alignment remains and "center" removed caption.
					else if (newValue == 'center' && shift.changed.hasCaption && !shift.newData.hasCaption) {
							shift.deflate();
							shift.element = wrapInCentering(editor, el);
						}

					// Finally set display for figure.
					if (!alignClasses && el.is('figure')) {
						if (newValue == 'center') el.setStyle('display', 'inline-block');else el.removeStyle('display');
					}
				},
				hasCaption: function hasCaption(shift, oldValue, newValue) {
					// This action is for real state change only.
					if (!shift.changed.hasCaption) return;

					// Get <img/> or <a><img/></a> from widget. Note that widget element might itself
					// be what we're looking for. Also element can be <p style="text-align:center"><a>...</a></p>.
					var imageOrLink = void 0;
					if (shift.element.is({ img: 1, a: 1 })) imageOrLink = shift.element;else imageOrLink = shift.element.findOne('a,img');

					// Switching hasCaption always destroys the widget.
					shift.deflate();

					// There was no caption, but the caption is to be added.
					if (newValue) {
						// Create new <figure> from widget template.
						var figure = CKEDITOR.dom.element.createFromHtml(templateBlock.output({
							captionedClass: captionedClass,
							captionPlaceholder: editor.lang.ae_dragresize_ie11.captionPlaceholder
						}), doc);

						// Replace element with <figure>.
						replaceSafely(figure, shift.element);

						// Use old <img/> or <a><img/></a> instead of the one from the template,
						// so we won't lose additional attributes.
						imageOrLink.replace(figure.findOne('img'));

						// Update widget's element.
						shift.element = figure;
					}

					// The caption was present, but now it's to be removed.
					else {
							// Unwrap <img/> or <a><img/></a> from figure.
							imageOrLink.replace(shift.element);

							// Update widget's element.
							shift.element = imageOrLink;
						}
				},
				link: function link(shift, oldValue, newValue) {
					if (shift.changed.link) {
						var img = shift.element.is('img') ? shift.element : shift.element.findOne('img');

						var link = shift.element.is('a') ? shift.element : shift.element.findOne('a');

						// Why deflate:
						// If element is <img/>, it will be wrapped into <a>,
						// which becomes a new widget.element.
						// If element is <a><img/></a>, it will be unlinked
						// so <img/> becomes a new widget.element.

						var needsDeflate = shift.element.is('a') && !newValue || shift.element.is('img') && newValue;

						var newEl = void 0;

						if (needsDeflate) shift.deflate();

						// If unlinked the image, returned element is <img>.
						if (!newValue) newEl = unwrapFromLink(link);else {
							// If linked the image, returned element is <a>.
							if (!oldValue) newEl = wrapInLink(img, shift.newData.link);

							// Set and remove all attributes associated with this state.
							var attributes = CKEDITOR.plugins.ae_dragresize_ie11.getLinkAttributesGetter()(editor, newValue);

							if (!CKEDITOR.tools.isEmpty(attributes.set)) (newEl || link).setAttributes(attributes.set);

							if (attributes.removed.length) (newEl || link).removeAttributes(attributes.removed);
						}

						if (needsDeflate) shift.element = newEl;
					}
				}
			};

			function wrapInCentering(editor, element) {
				var attribsAndStyles = {};

				if (alignClasses) attribsAndStyles.attributes = { class: alignClasses[1] };else attribsAndStyles.styles = { 'text-align': 'center' };

				// There's no gentle way to center inline element with CSS, so create p/div
				// that wraps widget contents and does the trick either with style or class.
				var center = doc.createElement(editor.activeEnterMode == CKEDITOR.ENTER_P ? 'p' : 'div', attribsAndStyles);

				// Replace element with centering wrapper.
				replaceSafely(center, element);
				element.move(center);

				return center;
			}

			function unwrapFromCentering(element) {
				var imageOrLink = element.findOne('a,img');

				imageOrLink.replace(element);

				return imageOrLink;
			}

			// Wraps <img/> -> <a><img/></a>.
			// Returns reference to <a>.
			//
			// @param {CKEDITOR.dom.element} img
			// @param {Object} linkData
			// @returns {CKEDITOR.dom.element}
			function wrapInLink(img, linkData) {
				var link = doc.createElement('a', {
					attributes: {
						href: linkData.url
					}
				});

				link.replace(img);
				img.move(link);

				return link;
			}

			// De-wraps <a><img/></a> -> <img/>.
			// Returns the reference to <img/>
			//
			// @param {CKEDITOR.dom.element} link
			// @returns {CKEDITOR.dom.element}
			function unwrapFromLink(link) {
				var img = link.findOne('img');

				img.replace(link);

				return img;
			}

			function replaceSafely(replacing, replaced) {
				if (replaced.getParent()) {
					var range = editor.createRange();

					range.moveToPosition(replaced, CKEDITOR.POSITION_BEFORE_START);

					// Remove old element. Do it before insertion to avoid a case when
					// element is moved from 'replaced' element before it, what creates
					// a tricky case which insertElementIntorRange does not handle.
					replaced.remove();

					editable.insertElementIntoRange(replacing, range);
				} else {
					replacing.replace(replaced);
				}
			}

			return function (shift) {
				var name = void 0;
				var i = void 0;

				shift.changed = {};

				for (i = 0; i < shiftables.length; i++) {
					name = shiftables[i];

					shift.changed[name] = shift.oldData ? shift.oldData[name] !== shift.newData[name] : false;
				}

				// Iterate over possible state variables.
				for (i = 0; i < shiftables.length; i++) {
					name = shiftables[i];

					stateActions[name](shift, shift.oldData ? shift.oldData[name] : null, shift.newData[name]);
				}

				shift.inflate();
			};
		},


		/**
   * Checks whether the current image ratio matches the natural one
   * by comparing dimensions.
   *
   * @param {CKEDITOR.dom.element} image
   * @return {Boolean}
   */
		checkHasNaturalRatio: function checkHasNaturalRatio(image) {
			var $ = image.$;

			var natural = this.getNatural(image);

			// The reason for two alternative comparisons is that the rounding can come from
			// both dimensions, e.g. there are two cases:
			// 	1. height is computed as a rounded relation of the real height and the value of width,
			//	2. width is computed as a rounded relation of the real width and the value of heigh.
			return Math.round($.clientWidth / natural.width * natural.height) == $.clientHeight || Math.round($.clientHeight / natural.height * natural.width) == $.clientWidth;
		},


		/**
   * Returns natural dimensions of the image. For modern browsers
   * it uses natural(Width|Height). For old ones (IE8) it creates
   * a new image and reads the dimensions.
   *
   * @param {CKEDITOR.dom.element} image
   * @return {Object}
   */
		getNatural: function getNatural(image) {
			var dimensions = void 0;

			if (image.$.naturalWidth) {
				dimensions = {
					width: image.$.naturalWidth,
					height: image.$.naturalHeight
				};
			} else {
				var img = new Image();
				img.src = image.getAttribute('src');

				dimensions = {
					width: img.width,
					height: img.height
				};
			}

			return dimensions;
		},


		/**
   * Returns an attribute getter function. Default getter comes from the Link plugin
   * and is documented by {@link CKEDITOR.plugins.link#getLinkAttributes}.
   *
   * **Note:** It is possible to override this method and use a custom getter e.g.
   * in the absence of the Link plugin.
   *
   * **Note:** If a custom getter is used, a data model format it produces
   * must be compatible with {@link CKEDITOR.plugins.link#getLinkAttributes}.
   *
   * **Note:** A custom getter must understand the data model format produced by
   * {@link #getLinkAttributesParser} to work correctly.
   *
   * @return {Function} A function that gets (composes) link attributes.
   * @since 4.5.5
   */
		getLinkAttributesGetter: function getLinkAttributesGetter() {
			// #13885
			return CKEDITOR.plugins.link.getLinkAttributes;
		},


		/**
   * Returns an attribute parser function. Default parser comes from the Link plugin
   * and is documented by {@link CKEDITOR.plugins.link#parseLinkAttributes}.
   *
   * **Note:** It is possible to override this method and use a custom parser e.g.
   * in the absence of the Link plugin.
   *
   * **Note:** If a custom parser is used, a data model format produced by the parser
   * must be compatible with {@link #getLinkAttributesGetter}.
   *
   * **Note:** If a custom parser is used, it should be compatible with the
   * {@link CKEDITOR.plugins.link#parseLinkAttributes} data model format. Otherwise the
   * Link plugin dialog may not be populated correctly with parsed data. However
   * as long as Enhanced Image is **not** used with the Link plugin dialog, any custom data model
   * will work, being stored as an internal property of Enhanced Image widget's data only.
   *
   * @return {Function} A function that parses attributes.
   * @since 4.5.5
   */
		getLinkAttributesParser: function getLinkAttributesParser() {
			// #13885
			return CKEDITOR.plugins.link.parseLinkAttributes;
		}
	};

	function setWrapperAlign(widget, alignClasses) {
		var wrapper = widget.wrapper;

		var align = widget.data.align;

		var hasCaption = widget.data.hasCaption;

		if (alignClasses) {
			// Remove all align classes first.
			for (var i = 3; i--;) {
				wrapper.removeClass(alignClasses[i]);
			}if (align == 'center') {
				// Avoid touching non-captioned, centered widgets because
				// they have the class set on the element instead of wrapper:
				//
				// 	<div class="cke_widget_wrapper">
				// 		<p class="center-class">
				// 			<img />
				// 		</p>
				// 	</div>
				if (hasCaption) {
					wrapper.addClass(alignClasses[1]);
				}
			} else if (align != 'none') {
				wrapper.addClass(alignClasses[alignmentsObj[align]]);
			}
		} else {
			if (align == 'center') {
				if (hasCaption) wrapper.setStyle('text-align', 'center');else wrapper.removeStyle('text-align');

				wrapper.removeStyle('float');
			} else {
				if (align == 'none') wrapper.removeStyle('float');else wrapper.setStyle('float', align);

				wrapper.removeStyle('text-align');
			}

			var image = wrapper.$.querySelector('img');

			var imageStyles = image.getAttribute('style');

			if (imageStyles) {
				var widthStyles = /(width:.+?;)/g.exec(imageStyles);
				var widthStyle = widthStyles[0];

				image.setAttribute('style', widthStyle);
			}
		}
	}

	// Returns a function that creates widgets from all <img> and
	// <figure class="{config.ae_dragresize_ie11_captionedClass}"> elements.
	//
	// @param {CKEDITOR.editor} editor
	// @returns {Function}
	function upcastWidgetElement(editor) {
		var isCenterWrapper = centerWrapperChecker(editor);

		var captionedClass = editor.config.ae_dragresize_ie11_captionedClass;

		// @param {CKEDITOR.htmlParser.element} el
		// @param {Object} data
		return function (el, data) {
			var dimensions = { width: 1, height: 1 };

			var name = el.name;

			var image = void 0;

			// #11110 Don't initialize on pasted fake objects.
			if (el.attributes['data-cke-realelement']) return;

			// If a center wrapper is found, there are 3 possible cases:
			//
			// 1. <div style="text-align:center"><figure>...</figure></div>.
			//    In this case centering is done with a class set on widget.wrapper.
			//    Simply replace centering wrapper with figure (it's no longer necessary).
			//
			// 2. <p style="text-align:center"><img/></p>.
			//    Nothing to do here: <p> remains for styling purposes.
			//
			// 3. <div style="text-align:center"><img/></div>.
			//    Nothing to do here (2.) but that case is only possible in enterMode different
			//    than ENTER_P.
			if (isCenterWrapper(el)) {
				if (name == 'div') {
					var figure = el.getFirst('figure');

					// Case #1.
					if (figure) {
						el.replaceWith(figure);
						el = figure;
					}
				}
				// Cases #2 and #3 (handled transparently)

				// If there's a centering wrapper, save it in data.
				data.align = 'center';

				// Image can be wrapped in link <a><img/></a>.
				image = el.getFirst('img') || el.getFirst('a').getFirst('img');
			}

			// No center wrapper has been found.
			else if (name == 'figure' && el.hasClass(captionedClass)) {
					image = el.getFirst('img') || el.getFirst('a').getFirst('img');

					// Upcast linked image like <a><img/></a>.
				} else if (isLinkedOrStandaloneImage(el)) {
					image = el.name == 'a' ? el.children[0] : el;
				}

			if (!image) return;

			// If there's an image, then cool, we got a widget.
			// Now just remove dimension attributes expressed with %.
			for (var d in dimensions) {
				if (dimensions.hasOwnProperty(d)) {
					var dimension = image.attributes[d];
					if (dimension && dimension.match(regexPercent)) delete image.attributes[d];
				}
			}

			return el;
		};
	}

	// Returns a function which transforms the widget to the external format
	// according to the current configuration.
	//
	// @param {CKEDITOR.editor}
	function downcastWidgetElement(editor) {
		var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

		// @param {CKEDITOR.htmlParser.element} el
		return function (el) {
			// In case of <a><img/></a>, <img/> is the element to hold
			// inline styles or classes (ae_dragresize_ie11_alignClasses).
			var attrsHolder = el.name == 'a' ? el.getFirst() : el;

			var attrs = attrsHolder.attributes;

			var align = this.data.align;

			// De-wrap the image from resize handle wrapper.
			// Only block widgets have one.
			if (!this.inline) {
				var resizeWrapper = el.getFirst('span');

				if (resizeWrapper) resizeWrapper.replaceWith(resizeWrapper.getFirst({ img: 1, a: 1 }));
			}

			if (align && align != 'none') {
				var styles = CKEDITOR.tools.parseCssText(attrs.style || '');

				// When the widget is captioned (<figure>) and internally centering is done
				// with widget's wrapper style/class, in the external data representation,
				// <figure> must be wrapped with an element holding an style/class:
				//
				// 	<div style="text-align:center">
				// 		<figure class="image" style="display:inline-block">...</figure>
				// 	</div>
				// or
				// 	<div class="some-center-class">
				// 		<figure class="image">...</figure>
				// 	</div>
				//
				if (align == 'center' && el.name == 'figure') {
					el = el.wrapWith(new CKEDITOR.htmlParser.element('div', alignClasses ? { class: alignClasses[1] } : { style: 'text-align:center' }));
				}

				// If left/right, add float style to the downcasted element.
				else if (align in { left: 1, right: 1 }) {
						if (alignClasses) attrsHolder.addClass(alignClasses[alignmentsObj[align]]);else styles['float'] = align;
					}

				// Update element styles.
				if (!alignClasses && !CKEDITOR.tools.isEmpty(styles)) attrs.style = CKEDITOR.tools.writeCssText(styles) + ';';
			}

			return el;
		};
	}

	// Returns a function that checks if an element is a centering wrapper.
	//
	// @param {CKEDITOR.editor} editor
	// @returns {Function}
	function centerWrapperChecker(editor) {
		var captionedClass = editor.config.ae_dragresize_ie11_captionedClass;

		var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

		var validChildren = { figure: 1, a: 1, img: 1 };

		return function (el) {
			// Wrapper must be either <div> or <p>.
			if (!(el.name in { div: 1, p: 1 })) return false;

			var children = el.children;

			// Centering wrapper can have only one child.
			if (children.length !== 1) return false;

			var child = children[0];

			// Only <figure> or <img /> can be first (only) child of centering wrapper,
			// regardless of its type.
			if (!(child.name in validChildren)) return false;

			// If centering wrapper is <p>, only <img /> can be the child.
			//   <p style="text-align:center"><img /></p>
			if (el.name == 'p') {
				if (!isLinkedOrStandaloneImage(child)) return false;
			}
			// Centering <div> can hold <img/> or <figure>, depending on enterMode.
			else {
					// If a <figure> is the first (only) child, it must have a class.
					//   <div style="text-align:center"><figure>...</figure><div>
					if (child.name == 'figure') {
						if (!child.hasClass(captionedClass)) return false;
					} else {
						// Centering <div> can hold <img/> or <a><img/></a> only when enterMode
						// is ENTER_(BR|DIV).
						//   <div style="text-align:center"><img /></div>
						//   <div style="text-align:center"><a><img /></a></div>
						if (editor.enterMode == CKEDITOR.ENTER_P) return false;

						// Regardless of enterMode, a child which is not <figure> must be
						// either <img/> or <a><img/></a>.
						if (!isLinkedOrStandaloneImage(child)) return false;
					}
				}

			// Centering wrapper got to be... centering. If ae_dragresize_ie11_alignClasses are defined,
			// check for centering class. Otherwise, check the style.
			if (alignClasses ? el.hasClass(alignClasses[1]) : CKEDITOR.tools.parseCssText(el.attributes.style || '', true)['text-align'] == 'center') return true;

			return false;
		};
	}

	// Checks whether element is <img/> or <a><img/></a>.
	//
	// @param {CKEDITOR.htmlParser.element}
	function isLinkedOrStandaloneImage(el) {
		if (el.name == 'img') return true;else if (el.name == 'a') return el.children.length == 1 && el.getFirst('img');

		return false;
	}

	// Sets width and height of the widget image according to current widget data.
	//
	// @param {CKEDITOR.plugins.widget} widget
	function setDimensions(widget) {
		var data = widget.data;

		var dimensions = { width: data.width, height: data.height };

		var image = widget.parts.image;

		for (var d in dimensions) {
			if (dimensions[d]) image.setAttribute(d, dimensions[d]);else image.removeAttribute(d);
		}
	}

	// Defines all features related to drag-driven image resizing.
	//
	// @param {CKEDITOR.plugins.widget} widget
	function setupResizer(widget) {
		var editor = widget.editor;

		var editable = editor.editable();

		var doc = editor.document;

		// Store the resizer in a widget for testing (#11004).

		var resizer = widget.resizer = doc.createElement('span');

		// Create resizer for each corner (NE, NW, SE, SW)

		var resizerNE = doc.createElement('span');

		var resizerNW = doc.createElement('span');

		var resizerSE = doc.createElement('span');

		var resizerSW = doc.createElement('span');

		resizerNE.addClass('cke_image_resizer');
		resizerNE.addClass('cke_image_resizer_ne');

		resizerNW.addClass('cke_image_resizer');
		resizerNW.addClass('cke_image_resizer_nw');

		resizerSE.addClass('cke_image_resizer');
		resizerSE.addClass('cke_image_resizer_se');

		resizerSW.addClass('cke_image_resizer');
		resizerSW.addClass('cke_image_resizer_sw');

		// Add each directional resizer as a child of resizer
		resizer.append(resizerNE);
		resizer.append(resizerNW);
		resizer.append(resizerSE);
		resizer.append(resizerSW);

		// resizer.setAttribute( 'title', editor.lang.ae_dragresize_ie11.resizer );
		resizer.append(new CKEDITOR.dom.text('\u200B', doc));

		// Inline widgets don't need a resizer wrapper as an image spans the entire widget.
		if (!widget.inline) {
			var imageOrLink = widget.parts.link || widget.parts.image;

			var oldResizeWrapper = imageOrLink.getParent();

			var resizeWrapper = doc.createElement('span');

			resizeWrapper.addClass('cke_image_resizer_wrapper');
			resizeWrapper.append(imageOrLink);
			resizeWrapper.append(resizer);
			widget.element.append(resizeWrapper, true);

			// Remove the old wrapper which could came from e.g. pasted HTML
			// and which could be corrupted (e.g. resizer span has been lost).
			if (oldResizeWrapper.is('span')) oldResizeWrapper.remove();
		} else {
			widget.wrapper.append(resizer);
		}

		// Calculate values of size variables and mouse offsets.
		resizer.on('mousedown', function (evt) {
			var image = widget.parts.image;

			// The x-coordinate of the mouse relative to the screen
			// when button gets pressed.

			var startX = evt.data.$.screenX;

			var startY = evt.data.$.screenY;

			// The initial dimensions and aspect ratio of the image.

			var startWidth = image.$.clientWidth;

			var startHeight = image.$.clientHeight;

			var ratio = startWidth / startHeight;

			var listeners = [];

			var target = evt.data.getTarget();

			var factorX = void 0;

			var factorY = void 0;

			var moveDiffX = void 0;

			var moveDiffY = void 0;

			var nativeEvt = void 0;

			var newHeight = void 0;

			var newWidth = void 0;

			var updateData = void 0;

			// "factorX" and "factorY" can be either 1 or -1. I.e.: We need to
			// add/subtract the difference to get proper width, etc. Without "factorX"
			// and "factorY", resizer starts working the opposite way.
			if (target.hasClass('cke_image_resizer_ne')) {
				factorX = 1;
				factorY = 1;
			} else if (target.hasClass('cke_image_resizer_nw')) {
				factorX = -1;
				factorY = 1;
			} else if (target.hasClass('cke_image_resizer_se')) {
				factorX = 1;
				factorY = -1;
			} else if (target.hasClass('cke_image_resizer_sw')) {
				factorX = -1;
				factorY = -1;
			}

			// A class applied to editable during resizing.
			var cursorClass = 'cke_image_' + (!~factorY ? 's' : 'n') + (!~factorX ? 'w' : 'e');

			// Save the undo snapshot first: before resizing.
			editor.fire('saveSnapshot');

			// Mousemove listeners are removed on mouseup.
			attachToDocuments('mousemove', onMouseMove, listeners);

			// Clean up the mousemove listener. Update widget data if valid.
			attachToDocuments('mouseup', onMouseUp, listeners);

			// The entire editable will have the special cursor while resizing goes on.
			editable.addClass(cursorClass);

			// This is to always keep the resizer element visible while resizing.
			resizer.addClass('cke_image_resizing');

			// Attaches an event to a global document if inline editor.
			// Additionally, if classic (`iframe`-based) editor, also attaches the same event to `iframe`'s document.
			function attachToDocuments(name, callback, collection) {
				var globalDoc = CKEDITOR.document;

				var listeners = [];

				if (!doc.equals(globalDoc)) listeners.push(globalDoc.on(name, callback));

				listeners.push(doc.on(name, callback));

				if (collection) {
					for (var i = listeners.length; i--;) {
						collection.push(listeners.pop());
					}
				}
			}

			// Calculate width first, and then adjust height, preserving ratio.
			function adjustToX() {
				newWidth = startWidth + factorX * moveDiffX;
				newHeight = Math.round(newWidth / ratio);
			}

			// Calculate height first, and then adjust width, preserving ratio.
			function adjustToY() {
				newHeight = startHeight + factorY * moveDiffY;
				newWidth = Math.round(newHeight * ratio);
			}

			// This is how variables refer to the geometry.
			// Note: x corresponds to moveOffset, this is the position of mouse
			// Note: o corresponds to [startX, startY].
			//
			// 	+--------------+--------------+
			// 	|              |              |
			// 	|      I       |      II      |
			// 	|              |              |
			// 	+------------- o -------------+ _ _ _
			// 	|              |              |      ^
			// 	|      VI      |     III      |      | moveDiffY
			// 	|              |         x _ _ _ _ _ v
			// 	+--------------+---------|----+
			// 	               |         |
			// 	                <------->
			// 	                moveDiffX
			function onMouseMove(evt) {
				nativeEvt = evt.data.$;

				// This is how far the mouse is from the point the button was pressed.
				moveDiffX = nativeEvt.screenX - startX;
				moveDiffY = startY - nativeEvt.screenY;

				// Resize with NE, SE drag handles
				if (factorX == 1) {
					if (moveDiffX <= 0) {
						adjustToY();
					} else {
						adjustToX();
					}
				}
				// Resize with NW, SW drag handles
				else {
						if (moveDiffX <= 0) {
							adjustToX();
						} else {
							adjustToY();
						}
					}

				// Don't update attributes if less than 10.
				// This is to prevent images to visually disappear.
				if (newWidth >= 15 && newHeight >= 15) {
					image.$.style.width = newWidth + 'px';
					image.$.style.height = newHeight + 'px';

					updateData = true;
				} else {
					updateData = false;
				}
			}

			function onMouseUp() {
				var l = void 0;

				while (l = listeners.pop()) {
					l.removeListener();
				} // Restore default cursor by removing special class.
				editable.removeClass(cursorClass);

				// This is to bring back the regular behaviour of the resizer.
				resizer.removeClass('cke_image_resizing');

				if (updateData) {
					widget.setData({
						height: newHeight,
						width: newWidth
					});

					// Save another undo snapshot: after resizing.
					editor.fire('saveSnapshot');
				}

				// Don't update data twice or more.
				updateData = false;
			}
		});
	}

	/**
  * Removes the alignment value of an image
  *
  * @param {CKEDITOR.dom.element} image The image element
  * @param {String} imageAlignment The image alignment value to be removed
  */
	var removeWidgetAlignment = function removeWidgetAlignment(widget, imageAlignment) {
		if (imageAlignment === 'left' || imageAlignment === 'right') {
			widget.wrapper.removeStyle('float');
		} else if (imageAlignment === 'center') {
			widget.editor.execCommand('justifyleft');
			widget.editor.execCommand('justifyleft');
		}
	};

	// Integrates widget alignment setting with justify
	// plugin's commands (execution and refreshment).
	// @param {CKEDITOR.editor} editor
	// @param {String} value 'left', 'right', 'center' or 'block'
	function alignCommandIntegrator(editor) {
		var execCallbacks = [];

		var enabled = void 0;

		return function (value) {
			var command = editor.getCommand('justify' + value);

			// Most likely, the justify plugin isn't loaded.
			if (!command) return;

			// This command will be manually refreshed along with
			// other commands after exec.
			execCallbacks.push(function () {
				command.refresh(editor, editor.elementPath());
			});

			if (value in { right: 1, left: 1, center: 1 }) {
				command.on('exec', function (evt) {
					var widget = getFocusedWidget(editor);

					if (widget) {
						if (widget.data.align === value) {
							removeWidgetAlignment(widget, value);

							delete widget.data.align;
						} else {
							widget.setData('align', value);
						}

						// Once the widget changed its align, all the align commands
						// must be refreshed: the event is to be cancelled.
						for (var i = execCallbacks.length; i--;) {
							execCallbacks[i]();
						}evt.cancel();
					}
				});
			}

			command.on('refresh', function (evt) {
				var widget = getFocusedWidget(editor);

				var allowed = { right: 1, left: 1, center: 1 };

				if (!widget) return;

				// Cache "enabled" on first use. This is because filter#checkFeature may
				// not be available during plugin's afterInit in the future — a moment when
				// alignCommandIntegrator is called.
				if (enabled === undefined) enabled = editor.filter.checkFeature(editor.widgets.registered.image.features.align);

				// Don't allow justify commands when widget alignment is disabled (#11004).
				if (!enabled) this.setState(CKEDITOR.TRISTATE_DISABLED);else {
					this.setState(widget.data.align == value ? CKEDITOR.TRISTATE_ON : value in allowed ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED);
				}

				evt.cancel();
			});
		};
	}

	// Returns the focused widget, if of the type specific for this plugin.
	// If no widget is focused, `null` is returned.
	//
	// @param {CKEDITOR.editor}
	// @returns {CKEDITOR.plugins.widget}
	function getFocusedWidget(editor) {
		var widget = editor.widgets.focused;

		if (widget && widget.name == 'image') return widget;

		return null;
	}

	// Returns a set of widget allowedContent rules, depending
	// on configurations like config#ae_dragresize_ie11_alignClasses or
	// config#ae_dragresize_ie11_captionedClass.
	//
	// @param {CKEDITOR.editor}
	// @returns {Object}
	function getWidgetAllowedContent(editor) {
		var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

		var rules = {
			// Widget may need <div> or <p> centering wrapper.
			div: {
				match: centerWrapperChecker(editor)
			},
			p: {
				match: centerWrapperChecker(editor)
			},
			img: {
				attributes: '!src,alt,width,height'
			},
			figure: {
				classes: '!' + editor.config.ae_dragresize_ie11_captionedClass
			},
			figcaption: true
		};

		if (alignClasses) {
			// Centering class from the config.
			rules.div.classes = alignClasses[1];
			rules.p.classes = rules.div.classes;

			// Left/right classes from the config.
			rules.img.classes = alignClasses[0] + ',' + alignClasses[2];
			rules.figure.classes += ',' + rules.img.classes;
		} else {
			// Centering with text-align.
			rules.div.styles = 'text-align';
			rules.p.styles = 'text-align';

			rules.img.styles = 'float';
			rules.figure.styles = 'float,display';
		}

		return rules;
	}

	// Returns a set of widget feature rules, depending
	// on editor configuration. Note that the following may not cover
	// all the possible cases since requiredContent supports a single
	// tag only.
	//
	// @param {CKEDITOR.editor}
	// @returns {Object}
	function getWidgetFeatures(editor) {
		var alignClasses = editor.config.ae_dragresize_ie11_alignClasses;

		var features = {
			dimension: {
				requiredContent: 'img[width,height]'
			},
			align: {
				requiredContent: 'img' + (alignClasses ? '(' + alignClasses[0] + ')' : '{float}')
			},
			caption: {
				requiredContent: 'figcaption'
			}
		};

		return features;
	}

	// Returns element which is styled, considering current
	// state of the widget.
	//
	// @see CKEDITOR.plugins.widget#applyStyle
	// @param {CKEDITOR.plugins.widget} widget
	// @returns {CKEDITOR.dom.element}
	function getStyleableElement(widget) {
		return widget.data.hasCaption ? widget.element : widget.parts.image;
	}
})();

/**
 * A CSS class applied to the `<figure>` element of a captioned image.
 *
 * Read more in the [documentation](#!/guide/dev_captionedimage) and see the
 * [SDK sample](http://sdk.ckeditor.com/samples/captionedimage.html).
 *
 *		// Changes the class to "captionedImage".
 *		config.ae_dragresize_ie11_captionedClass = 'captionedImage';
 *
 * @cfg {String} [ae_dragresize_ie11_captionedClass='image']
 * @member CKEDITOR.config
 */
CKEDITOR.config.ae_dragresize_ie11_captionedClass = 'image';

/***/ }),

/***/ "./src/plugins/embed.js":
/*!******************************!*\
  !*** ./src/plugins/embed.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _priorities = __webpack_require__(/*! ./priorities */ "./src/plugins/priorities.js");

/* istanbul ignore if */
if (!CKEDITOR.plugins.get('ae_embed')) {
	var REGEX_HTTP = /^https?/;

	var REGEX_DEFAULT_LINK = /<a href=/;

	CKEDITOR.DEFAULT_AE_EMBED_URL_TPL = 'http://alloy.iframe.ly/api/oembed?url={url}&callback={callback}';
	CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL = '<div data-ae-embed-url="{url}"></div>';
	CKEDITOR.DEFAULT_AE_EMBED_DEFAULT_LINK_TPL = '<a href="{url}">{url}</a>';
	/**
  * CKEditor plugin which adds the infrastructure to embed urls as media objects using an oembed
  * service. By default, and for demoing purposes only, the oembed service is hosted in iframe.ly
  * at //alloy.iframe.ly/api/oembed?url={url}&callback={callback}. Note this should be changed to
  * a self-hosted or paid service in production environments. Access to the alloy.iframe.ly endpoint
  * may be restricted per domain due to significant traffic.
  *
  * This plugin adds an `embedUrl` command that can be used to easily embed a URL and transform it
  * to an embedded content.
  *
  * @class CKEDITOR.plugins.ae_embed
  */
	CKEDITOR.plugins.add('ae_embed', {
		requires: 'widget',
		init: function init(editor) {
			var AE_EMBED_URL_TPL = new CKEDITOR.template(editor.config.embedUrlTemplate || CKEDITOR.DEFAULT_AE_EMBED_URL_TPL);
			var AE_EMBED_WIDGET_TPL = new CKEDITOR.template(editor.config.embedWidgetTpl || CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL);
			var AE_EMBED_DEFAULT_LINK_TPL = new CKEDITOR.template(editor.config.embedLinkDefaultTpl || CKEDITOR.DEFAULT_AE_EMBED_DEFAULT_LINK_TPL);

			// Default function to upcast DOM elements to embed widgets.
			// It matches CKEDITOR.DEFAULT_AE_EMBED_WIDGET_TPL
			var defaultEmbedWidgetUpcastFn = function defaultEmbedWidgetUpcastFn(element, data) {
				if (element.name === 'div' && element.attributes['data-ae-embed-url']) {
					data.url = element.attributes['data-ae-embed-url'];

					return true;
				}
			};

			// Create a embedUrl command that can be invoked to easily embed media URLs
			editor.addCommand('embedUrl', {
				exec: function exec(editor, data) {
					editor.insertHtml(AE_EMBED_WIDGET_TPL.output({
						url: data.url
					}));
				}
			});

			// Create a widget to properly handle embed operations
			editor.widgets.add('ae_embed', {
				mask: true,
				requiredContent: 'div[data-ae-embed-url]',

				/**
     * Listener to be executed every time the widget's data changes. It takes care of
     * requesting the embed object to the configured oembed service and render it in
     * the editor
     *
     * @method data
     * @param {event} event Data change event
     */
				data: function data(event) {
					var widget = this;

					var url = event.data.url;

					if (url) {
						CKEDITOR.tools.jsonp(AE_EMBED_URL_TPL, {
							url: encodeURIComponent(url)
						}, function (response) {
							if (response.html) {
								if (REGEX_DEFAULT_LINK.test(response.html)) {
									widget.createATag(url);
								} else {
									widget.element.setHtml(response.html);
								}
							} else {
								widget.createATag(url);
							}
						}, function (_msg) {
							widget.createATag(url);
						});
					}
				},
				createATag: function createATag(url) {
					this.editor.execCommand('undo');

					var aTagHtml = AE_EMBED_DEFAULT_LINK_TPL.output({
						url: url
					});

					this.editor.insertHtml(aTagHtml);
					this.editor.fire('actionPerformed', this);
				},


				/**
     * Function used to upcast an element to ae_embed widgets.
     *
     * @method upcast
     * @param {CKEDITOR.htmlParser.element} element The element to be checked
     * @param {Object} data The object that will be passed to the widget
     */
				upcast: function upcast(element, data) {
					var embedWidgetUpcastFn = editor.config.embedWidgetUpcastFn || defaultEmbedWidgetUpcastFn;

					return embedWidgetUpcastFn(element, data);
				}
			});

			// Add a listener to handle paste events and turn links into embed objects
			editor.once('contentDom', function () {
				editor.on('paste', function (event) {
					var link = event.data.dataValue;

					if (REGEX_HTTP.test(link)) {
						event.stop();

						editor.execCommand('embedUrl', {
							url: event.data.dataValue
						});
					}
				}, null, null,
				// Make sure we run before autolink's paste handler,
				// otherwise the link will be turned into an anchor and our
				// REGEX_HTTP test will fail.
				_priorities.HIGH_PRIORITY);
			});

			// Add a listener to handle selection change events and properly detect editor
			// interactions on the widgets without messing with widget native selection
			editor.on('selectionChange', function (_event) {
				var selection = editor.getSelection();

				if (selection) {
					var element = selection.getSelectedElement();

					if (element) {
						var widgetElement = element.findOne('[data-widget="ae_embed"]');

						if (widgetElement) {
							var region = element.getClientRect();

							var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();
							region.left -= scrollPosition.x;
							region.top += scrollPosition.y;

							region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;

							editor.fire('editorInteraction', {
								nativeEvent: {},
								selectionData: {
									element: widgetElement,
									region: region
								}
							});
						}
					}
				}
			});

			// Add a filter to skip filtering widget elements
			editor.filter.addElementCallback(function (element) {
				if ('data-ae-embed-url' in element.attributes) {
					return CKEDITOR.FILTER_SKIP_TREE;
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/plugins/embedurl.js":
/*!*********************************!*\
  !*** ./src/plugins/embedurl.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _Resizer = __webpack_require__(/*! ./Resizer.es */ "./src/plugins/Resizer.es.js");

var _Resizer2 = _interopRequireDefault(_Resizer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (!CKEDITOR.plugins.get('embedurl')) {
	var REGEX_HTTP = /^https?/;

	CKEDITOR.DEFAULT_LFR_EMBED_WIDGET_TPL = '<div data-embed-url="{url}" class="embed-responsive embed-responsive-16by9">{content}<div class="embed-help-message">{helpMessageIcon}<span> {helpMessage}</span></div></div><br>';

	/**
  * Enum for supported embed alignments
  * @type {Object}
  */

	var EMBED_ALIGNMENT = {
		CENTER: 'center',
		LEFT: 'left',
		RIGHT: 'right'
	};

	/**
  * Enum values for supported embed alignments
  * @type {Array}
  */

	var ALIGN_VALUES = [EMBED_ALIGNMENT.CENTER, EMBED_ALIGNMENT.LEFT, EMBED_ALIGNMENT.RIGHT];

	/**
  * Necessary styles for the center alignment
  * @type {Array.<Object>}
  */

	var CENTERED_EMBED_STYLE = [{
		name: 'display',
		value: 'block'
	}, {
		name: 'margin-left',
		value: 'auto'
	}, {
		name: 'margin-right',
		value: 'auto'
	}];

	/**
  * Retrieves the alignment value of an embed element.
  *
  * @param {CKEDITOR.dom.element} embed The embed element
  * @return {String} The alignment value
  */

	var getEmbedAlignment = function getEmbedAlignment(embed) {
		var embedAlignment = embed.getStyle('float');

		if (!embedAlignment || embedAlignment === 'inherit' || embedAlignment === 'none') {
			embedAlignment = embed.getAttribute('align');
		}

		if (!embedAlignment) {
			var centeredEmbed = CENTERED_EMBED_STYLE.every(function (style) {
				var styleCheck = embed.getStyle(style.name) === style.value;

				if (!styleCheck && style.vendorPrefixes) {
					styleCheck = style.vendorPrefixes.some(function (vendorPrefix) {
						return embed.getStyle(vendorPrefix + style.name) === style.value;
					});
				}

				return styleCheck;
			});

			embedAlignment = centeredEmbed ? EMBED_ALIGNMENT.CENTER : null;
		}

		return embedAlignment;
	};

	/**
  * Removes the alignment value of an embed
  *
  * @param {CKEDITOR.dom.element} embed The embed element
  * @param {String} embedAlignment The embed alignment value to be removed
  */

	var removeEmbedAlignment = function removeEmbedAlignment(embed, embedAlignment) {
		if (embedAlignment === EMBED_ALIGNMENT.LEFT || embedAlignment === EMBED_ALIGNMENT.RIGHT) {
			embed.removeStyle('float');

			if (embedAlignment === getEmbedAlignment(embed)) {
				embed.removeAttribute('align');
			}
		} else if (embedAlignment === EMBED_ALIGNMENT.CENTER) {
			CENTERED_EMBED_STYLE.forEach(function (style) {
				embed.removeStyle(style.name);

				if (style.vendorPrefixes) {
					style.vendorPrefixes.forEach(function (vendorPrefix) {
						return embed.removeStyle(vendorPrefix + style.name);
					});
				}
			});
		}
	};

	/**
  * Sets the alignment value of an embed
  *
  * @param {CKEDITOR.dom.element} embed The embed element
  * @param {String} embedAlignment The embed alignment value to be set
  */

	var setEmbedAlignment = function setEmbedAlignment(embed, embedAlignment) {
		removeEmbedAlignment(embed, getEmbedAlignment(embed));

		if (embedAlignment === EMBED_ALIGNMENT.LEFT || embedAlignment === EMBED_ALIGNMENT.RIGHT) {
			embed.setStyle('float', embedAlignment);
		} else if (embedAlignment === EMBED_ALIGNMENT.CENTER) {
			CENTERED_EMBED_STYLE.forEach(function (style) {
				embed.setStyle(style.name, style.value);

				if (style.vendorPrefixes) {
					style.vendorPrefixes.forEach(function (vendorPrefix) {
						return embed.setStyle(vendorPrefix + style.name, style.value);
					});
				}
			});
		}
	};

	var getSelectedElement = function getSelectedElement(editor) {
		var result = {
			alignment: null,
			element: null
		};

		var selection = editor.getSelection();

		if (selection) {
			var selectedElement = selection.getSelectedElement();

			if (selectedElement && selectedElement.getAttribute('data-cke-widget-wrapper')) {
				result.alignment = getEmbedAlignment(selectedElement);
				result.element = selectedElement;
			}
		}

		return result;
	};

	var resizeElement = function resizeElement(el, width, height) {
		var wrapperElement = el.parentElement;

		if (wrapperElement && width > 0 && height > 0) {
			var rect = wrapperElement.getBoundingClientRect();

			var pwidth = width >= rect.width ? 100 : Math.floor(width / rect.width * 100);
			var style = 'width:' + pwidth + '%;';

			wrapperElement.setAttribute('style', style);

			var widgetElement = wrapperElement.querySelector('[data-widget="embedurl"]');

			if (widgetElement) {
				var styles = JSON.parse(widgetElement.getAttribute('data-styles')) || {};

				styles.width = width + 'px';
				styles.height = height + 'px';

				widgetElement.setAttribute('data-styles', JSON.stringify(styles));

				var iframeElement = widgetElement.querySelector('iframe');

				if (iframeElement) {
					iframeElement.setAttribute('width', width);
					iframeElement.setAttribute('height', height);
				}
			}
		}
	};

	var selectWidget = function selectWidget(editor) {
		setTimeout(function () {
			var selection = editor.getSelection();

			if (selection) {
				var wrapperElement = selection.root.find('[data-cke-widget-wrapper]');

				if (wrapperElement) {
					var elementList = wrapperElement.$;
					if (elementList.length > 0) {
						var lastElement = new CKEDITOR.dom.element(elementList[elementList.length - 1]);

						var imageElement = lastElement.findOne('img');
						var widgetElement = lastElement.findOne('[data-widget="embedurl"]');

						if (imageElement && widgetElement) {
							var range = editor.createRange();

							range.setStart(widgetElement, 0);
							range.setEnd(imageElement, 1);

							selection.selectRanges([range]);
							selection.selectElement(lastElement);
						}
					}
				}
			}
		}, 0);
	};

	var currentAlignment = null;
	var currentElement = null;
	var resizer = null;

	/**
  * CKEditor plugin which adds the infrastructure to embed urls as media objects
  *
  * This plugin adds an `embedUrl` command that can be used to easily embed a URL and transform it
  * to an embedded content.
  *
  * @class CKEDITOR.plugins.embedurl
  */

	CKEDITOR.plugins.add('embedurl', {
		requires: 'widget',

		init: function init(editor) {
			var LFR_EMBED_WIDGET_TPL = new CKEDITOR.template(editor.config.embedWidgetTpl || CKEDITOR.DEFAULT_LFR_EMBED_WIDGET_TPL);

			var providers = editor.config.embedProviders || [];

			providers = providers.map(function (provider) {
				return {
					id: provider.id,
					tpl: new CKEDITOR.template('<div data-embed-id="{embedId}">' + provider.tpl + '</div>'),
					type: provider.type,
					urlSchemes: provider.urlSchemes.map(function (scheme) {
						return new RegExp(scheme);
					})
				};
			});

			var generateEmbedContent = function generateEmbedContent(url, content) {
				return LFR_EMBED_WIDGET_TPL.output({
					content: content,
					helpMessage: AlloyEditor.Strings.videoPlaybackDisabled,
					helpMessageIcon: Liferay.Util.getLexiconIconTpl('info-circle'),
					url: url
				});
			};

			var defaultEmbedWidgetUpcastFn = function defaultEmbedWidgetUpcastFn(element, data) {
				var upcastWidget = false;

				if (element.name === 'div' && element.attributes['data-embed-url']) {
					data.url = element.attributes['data-embed-url'];

					upcastWidget = true;
				} else if (element.name === 'div' && element.attributes['data-embed-id']) {
					var iframe = element.children[0];

					data.url = iframe.attributes.src;

					delete element.attributes.style;

					var embedContent = generateEmbedContent(data.url, element.getOuterHtml());

					var widgetFragment = new CKEDITOR.htmlParser.fragment.fromHtml(embedContent);

					upcastWidget = widgetFragment.children[0];

					upcastWidget.attributes['data-styles'] = element.attributes['data-styles'];
					upcastWidget.removeClass('embed-responsive');
					upcastWidget.removeClass('embed-responsive-16by9');

					element.replaceWith(upcastWidget);
				}

				return upcastWidget;
			};

			var showError = function showError(errorMsg) {
				editor.fire('error', errorMsg);

				setTimeout(function () {
					editor.getSelection().removeAllRanges();

					editor.focus();

					resizer.hide();
				}, 0);
			};

			editor.addCommand('embedUrl', {
				exec: function exec(editor, data) {
					var type = data.type;
					var url = data.url;
					var content = void 0;

					if (REGEX_HTTP.test(url)) {
						var validProvider = providers.filter(function (provider) {
							return type ? provider.type === type : true;
						}).some(function (provider) {
							var scheme = provider.urlSchemes.find(function (scheme) {
								return scheme.test(url);
							});

							if (scheme) {
								var embedId = scheme.exec(url)[1];

								content = provider.tpl.output({
									embedId: embedId
								});
							}

							return scheme;
						});

						if (validProvider) {
							editor._selectEmbedWidget = url;

							var embedContent = generateEmbedContent(url, content);

							editor.insertHtml(embedContent);
						} else {
							showError(AlloyEditor.Strings.platformNotSupported);
						}
					} else {
						showError(AlloyEditor.Strings.enterValidUrl);
					}
				}
			});

			editor.widgets.add('embedurl', {
				draggable: false,
				mask: true,
				requiredContent: 'div[data-embed-url]',

				data: function data(event) {
					var instance = this;

					// Sync dimensions and alignment with editor wrapper

					var stylesJSON = instance.element.getAttribute('data-styles');

					var styles = stylesJSON ? JSON.parse(stylesJSON) : null;

					if (!styles) {
						var iframe = instance.wrapper.findOne('iframe');

						var bounds = instance.wrapper.$.getBoundingClientRect();
						var width = iframe.getAttribute('width');

						var pwidth = width >= bounds.width ? 100 : Math.round(width / bounds.width * 100);

						styles = {
							width: pwidth + '%'
						};
					}

					instance.wrapper.setAttribute('style', CKEDITOR.tools.writeCssText(styles));

					if (editor._selectEmbedWidget === event.data.url) {
						selectWidget(editor);
					}
				},
				downcast: function downcast(widget) {
					var embedContent = widget.children[0];

					embedContent.attributes.class = 'embed-responsive embed-responsive-16by9';

					embedContent.attributes['data-styles'] = JSON.stringify(CKEDITOR.tools.parseCssText(widget.parent.attributes.style));

					embedContent.attributes.style = widget.parent.attributes.style;

					return embedContent;
				},
				upcast: function upcast(element, data) {
					var embedWidgetUpcastFn = editor.config.embedWidgetUpcastFn || defaultEmbedWidgetUpcastFn;

					return embedWidgetUpcastFn(element, data);
				}
			});

			window.addEventListener('resize', function () {
				resizer.hide();
				selectWidget(editor);
			}, false);

			editor.on('selectionChange', function (_event) {
				var selection = editor.getSelection();

				if (selection) {
					var element = selection.getSelectedElement();

					if (element) {
						var widgetElement = element.findOne('[data-widget="embedurl"]');

						if (widgetElement) {
							var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();

							var region = element.getClientRect();

							region.direction = CKEDITOR.SELECTION_BOTTOM_TO_TOP;
							region.left -= scrollPosition.x;
							region.top += scrollPosition.y;

							editor.fire('editorInteraction', {
								nativeEvent: {},
								selectionData: {
									element: widgetElement,
									region: region
								}
							});
						}

						var imageElement = element.findOne('img.cke_widget_mask');

						if (imageElement) {
							resizer.show(imageElement.$);
						}
					} else {
						resizer.hide();
					}
				}
			});

			editor.on('destroy', function () {
				var resizeElement = document.getElementById('ckimgrsz');

				if (resizeElement) {
					resizeElement.remove();
				}

				document.removeEventListener('mousedown', mouseDownListener);
			});

			editor.on('blur', function () {
				resizer.hide();
			});

			editor.filter.addElementCallback(function (element) {
				if ('data-embed-url' in element.attributes) {
					return CKEDITOR.FILTER_SKIP_TREE;
				}
			});

			var mouseDownListener = function mouseDownListener(event) {
				var result = getSelectedElement(editor);

				currentAlignment = result.alignment;
				currentElement = result.element;

				if (resizer.isHandle(event.target)) {
					resizer.initDrag(event);
				}
			};

			resizer = new _Resizer2.default(editor, {
				onComplete: function onComplete(element, width, height) {
					resizeElement(element, width, height);

					if (currentAlignment && currentElement) {
						setEmbedAlignment(currentElement, currentAlignment);
					}
					selectWidget(editor);
				}
			});

			document.addEventListener('mousedown', mouseDownListener, false);
		},

		afterInit: function afterInit(editor) {
			ALIGN_VALUES.forEach(function (alignValue) {
				var command = editor.getCommand('justify' + alignValue);

				if (command) {
					command.on('exec', function (event) {
						var selectedElement = editor.getSelection().getSelectedElement();

						if (selectedElement && selectedElement.getAttribute('data-cke-widget-wrapper')) {
							var selectedEmbed = selectedElement.findOne('[data-widget="embedurl"] [data-embed-id]');

							if (selectedEmbed) {
								var embedAlignment = getEmbedAlignment(selectedElement);

								if (embedAlignment === alignValue) {
									removeEmbedAlignment(selectedElement, alignValue);
								} else {
									setEmbedAlignment(selectedElement, alignValue);
								}

								currentElement = selectedElement;
								currentAlignment = getEmbedAlignment(selectedElement);

								var imageElement = selectedElement.findOne('img');

								if (imageElement) {
									resizer.show(imageElement.$);
								}

								event.cancel();

								var elementPath = new CKEDITOR.dom.elementPath(selectedElement);

								ALIGN_VALUES.forEach(function (alignValue) {
									var command = editor.getCommand('justify' + alignValue);

									if (command) {
										command.refresh(editor, elementPath);
									}
								});
							}
						}
					});

					command.on('refresh', function (event) {
						var lastElement = event.data.path.lastElement;

						if (lastElement && lastElement.getAttribute('data-cke-widget-wrapper') && lastElement.findOne('[data-widget] [data-embed-id]')) {
							var embedAlignment = getEmbedAlignment(lastElement);

							event.sender.setState(embedAlignment === alignValue ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF);

							event.cancel();
						}
					});
				}
			});
		}
	});
}

exports.default = CKEDITOR.plugins.get('embedurl');

/***/ }),

/***/ "./src/plugins/imagealignment.js":
/*!***************************************!*\
  !*** ./src/plugins/imagealignment.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _selectionTest = __webpack_require__(/*! ../selections/selection-test */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

if (!CKEDITOR.plugins.get('ae_imagealignment')) {
	/**
  * Enum for supported image alignments
  * @type {Object}
  */
	var IMAGE_ALIGNMENT = {
		CENTER: 'center',
		LEFT: 'left',
		RIGHT: 'right'
	};

	/**
  * Enum values for supported image alignments
  * @type {Array}
  */
	var ALIGN_VALUES = [IMAGE_ALIGNMENT.LEFT, IMAGE_ALIGNMENT.RIGHT, IMAGE_ALIGNMENT.CENTER];

	/**
  * Necessary styles for the center alignment
  * @type {Array.<Object>}
  */
	var CENTERED_IMAGE_STYLE = [{
		name: 'display',
		value: 'block'
	}, {
		name: 'margin-left',
		value: 'auto'
	}, {
		name: 'margin-right',
		value: 'auto'
	}];

	/**
  * Retrieves the alignment value of an image.
  *
  * @param {CKEDITOR.dom.element} image The image element
  * @return {String} The alignment value
  */
	var getImageAlignment = function getImageAlignment(image) {
		var imageAlignment = image.getStyle('float');

		if (!imageAlignment || imageAlignment === 'inherit' || imageAlignment === 'none') {
			imageAlignment = image.getAttribute('align');
		}

		if (!imageAlignment) {
			var centeredImage = CENTERED_IMAGE_STYLE.every(function (style) {
				var styleCheck = image.getStyle(style.name) === style.value;

				if (!styleCheck && style.vendorPrefixes) {
					styleCheck = style.vendorPrefixes.some(function (vendorPrefix) {
						return image.getStyle(vendorPrefix + style.name) === style.value;
					});
				}

				return styleCheck;
			});

			if (!imageAlignment) {
				var imageContainer = image.$.parentNode;

				if (imageContainer.style.textAlign == IMAGE_ALIGNMENT.CENTER) {
					CENTERED_IMAGE_STYLE.forEach(function (style) {
						image.setStyle(style.name, style.value);

						if (style.vendorPrefixes) {
							style.vendorPrefixes.forEach(function (vendorPrefix) {
								image.setStyle(vendorPrefix + style.name, style.value);
							});
						}
					});
					centeredImage = true;
					imageContainer.style.textAlign = '';
				}
			}

			imageAlignment = centeredImage ? IMAGE_ALIGNMENT.CENTER : null;
		}

		if (!CKEDITOR.env.edge && CKEDITOR.env.ie) {
			var p = image.findOne('p');
			if (p) {
				imageAlignment = p.getStyle('text-align');
			}
		}

		return imageAlignment;
	};

	/**
  * Removes the alignment value of an image
  *
  * @param {CKEDITOR.dom.element} image The image element
  * @param {String} imageAlignment The image alignment value to be removed
  */
	var removeImageAlignment = function removeImageAlignment(image, imageAlignment) {
		if (imageAlignment === IMAGE_ALIGNMENT.LEFT || imageAlignment === IMAGE_ALIGNMENT.RIGHT) {
			image.removeStyle('float');

			if (imageAlignment === getImageAlignment(image)) {
				image.removeAttribute('align');
			}
		} else if (imageAlignment === IMAGE_ALIGNMENT.CENTER) {
			CENTERED_IMAGE_STYLE.forEach(function (style) {
				image.removeStyle(style.name);

				if (style.vendorPrefixes) {
					style.vendorPrefixes.forEach(function (vendorPrefix) {
						image.removeStyle(vendorPrefix + style.name);
					});
				}
			});

			var imageContainer = image.$.parentNode;

			if (imageContainer.style.textAlign == IMAGE_ALIGNMENT.CENTER) {
				imageContainer.style.textAlign = '';
			}
		}
	};

	/**
  * Sets the alignment value of an image
  *
  * @param {CKEDITOR.dom.element} image The image element
  * @param {String} imageAlignment The image alignment value to be set
  */
	var setImageAlignment = function setImageAlignment(image, imageAlignment) {
		removeImageAlignment(image, getImageAlignment(image));

		if (imageAlignment === IMAGE_ALIGNMENT.LEFT || imageAlignment === IMAGE_ALIGNMENT.RIGHT) {
			image.setStyle('float', imageAlignment);
		} else if (imageAlignment === IMAGE_ALIGNMENT.CENTER) {
			CENTERED_IMAGE_STYLE.forEach(function (style) {
				image.setStyle(style.name, style.value);

				if (style.vendorPrefixes) {
					style.vendorPrefixes.forEach(function (vendorPrefix) {
						image.setStyle(vendorPrefix + style.name, style.value);
					});
				}
			});
		}
	};

	/**
  * CKEditor plugin which modifies the justify commands to properly align images. This
  * plugin is an excerpt of CKEditor's original image one that can be found at
  * https://github.com/ckeditor/ckeditor-dev/blob/master/plugins/image/plugin.js
  *
  * @class CKEDITOR.plugins.ae_imagealignment
  */
	CKEDITOR.plugins.add('ae_imagealignment', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function registers a 'paste' event on the editing area.
   *
   * @method afterInit
   * @param {Object} editor The current editor instance
   */
		afterInit: function afterInit(editor) {
			var self = this;

			ALIGN_VALUES.forEach(function (value) {
				var command = editor.getCommand('justify' + value);

				if (command) {
					command.on('exec', function (event) {
						var selectionData = editor.getSelectionData();

						if (selectionData && _selectionTest2.default.image({
							data: { selectionData: selectionData }
						})) {
							var image = selectionData.element;

							var imageAlignment = getImageAlignment(image);

							if (imageAlignment === value) {
								removeImageAlignment(image, value);
							} else {
								setImageAlignment(image, value);
							}

							event.cancel();

							self.refreshCommands(editor, new CKEDITOR.dom.elementPath(image));
						}
					});

					command.on('refresh', function (event) {
						var selectionData = {
							element: event.data.path.lastElement
						};

						if (_selectionTest2.default.image({
							data: { selectionData: selectionData }
						})) {
							var imageAlignment = getImageAlignment(selectionData.element);

							this.setState(imageAlignment === value ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF);

							event.cancel();
						}
					});
				}
			});
		},


		/**
   * Forces a refresh of the modified justify commands. This is needed because the applied changes
   * do not modify the selection, so the refresh is never triggered and the UI does not update
   * properly until the next selectionChange event.
   *
   * @param {CKEDITOR.editor} editor The editor instance
   * @param {CKEDITOR.dom.elementPath} elementPath The path of the selected image
   */
		refreshCommands: function refreshCommands(editor, elementPath) {
			ALIGN_VALUES.forEach(function (value) {
				var command = editor.getCommand('justify' + value);

				if (command) {
					command.refresh(editor, elementPath);
				}
			});
		}
	});
}

/***/ }),

/***/ "./src/plugins/index.js":
/*!******************************!*\
  !*** ./src/plugins/index.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.embedurl = undefined;

__webpack_require__(/*! ./addimages */ "./src/plugins/addimages.js");

__webpack_require__(/*! ./autolink */ "./src/plugins/autolink.js");

__webpack_require__(/*! ./autolist */ "./src/plugins/autolist.js");

__webpack_require__(/*! ./dragresize */ "./src/plugins/dragresize.js");

__webpack_require__(/*! ./dragresize_ie */ "./src/plugins/dragresize_ie.js");

__webpack_require__(/*! ./dragresize_ie11 */ "./src/plugins/dragresize_ie11.js");

__webpack_require__(/*! ./embed */ "./src/plugins/embed.js");

var _embedurl = __webpack_require__(/*! ./embedurl */ "./src/plugins/embedurl.js");

var _embedurl2 = _interopRequireDefault(_embedurl);

__webpack_require__(/*! ./imagealignment */ "./src/plugins/imagealignment.js");

__webpack_require__(/*! ./pasteimages */ "./src/plugins/pasteimages.js");

__webpack_require__(/*! ./placeholder */ "./src/plugins/placeholder.js");

__webpack_require__(/*! ./selectionkeystrokes */ "./src/plugins/selectionkeystrokes.js");

__webpack_require__(/*! ./tableresize */ "./src/plugins/tableresize.js");

__webpack_require__(/*! ./tabletools */ "./src/plugins/tabletools.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.embedurl = _embedurl2.default;

/***/ }),

/***/ "./src/plugins/pasteimages.js":
/*!************************************!*\
  !*** ./src/plugins/pasteimages.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (!CKEDITOR.plugins.get('ae_pasteimages')) {
	/**
  * CKEditor plugin which allows pasting images directly into the editable area. The image will be encoded
  * as Data URI. An event `beforeImageAdd` will be fired with the list of pasted images. If any of the listeners
  * returns `false` or cancels the event, the images won't be added to the content. Otherwise,
  * an event `imageAdd` will be fired with the inserted element into the editable area.
  *
  * @class CKEDITOR.plugins.ae_pasteimages
  */

	/**
  * Fired before adding images to the editor.
  * @event beforeImageAdd
  * @param {Array} imageFiles Array of image files
  */

	/**
  * Fired when an image is being added to the editor successfully.
  *
  * @event imageAdd
  * @param {CKEDITOR.dom.element} el The created image with src as Data URI
  * @param {File} file The image file
  */

	CKEDITOR.plugins.add('ae_pasteimages', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function registers a 'paste' event on the editing area.
   *
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			editor.once('contentDom', function () {
				var editable = editor.editable();

				editable.attachListener(editable, 'paste', this._onPaste, this, {
					editor: editor
				});
			}.bind(this));
		},


		/**
   * The function creates an img element with src the image data as Data URI.
   * Then, it fires an 'imageAdd' event via CKEditor's event system. The passed
   * params will be:
   * - `el` - the created img element
   * - `file` - the original pasted data
   *
   * @method _onPaste
   * @protected
   * @param {CKEDITOR.dom.event} event A `paste` event, as received natively from CKEditor
   */
		_onPaste: function _onPaste(event) {
			if (event.data.$.clipboardData) {
				var pastedData = event.data.$.clipboardData.items[0];
				var editor = event.listenerData.editor;

				if (pastedData.type.indexOf('image') === 0) {
					var reader = new FileReader();
					var imageFile = pastedData.getAsFile();

					reader.onload = function (event) {
						var result = editor.fire('beforeImageAdd', {
							imageFiles: imageFile
						});

						if (result) {
							var el = CKEDITOR.dom.element.createFromHtml('<img src="' + event.target.result + '">');

							editor.insertElement(el);

							var imageData = {
								el: el,
								file: imageFile
							};

							editor.fire('imageAdd', imageData);
						}
					};

					reader.readAsDataURL(imageFile);
				}
			}
		}
	});
}

/***/ }),

/***/ "./src/plugins/placeholder.js":
/*!************************************!*\
  !*** ./src/plugins/placeholder.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (!CKEDITOR.plugins.get('ae_placeholder')) {
	/**
  * CKEDITOR enterMode config set the behavior of paragraphs
  * When the content is empty CKEDITOR keeps the enterMode string
  * into the content
  * @property
  * @type {string}
  */
	var brFiller = CKEDITOR.env.needsBrFiller ? '<br>' : '';

	var enterModeEmptyValue = {
		1: ['<p>' + brFiller + '</p>'],
		2: ['', ' ', brFiller],
		3: ['<div>' + brFiller + '</div>']
	};

	/**
  * CKEditor plugin which allows adding a placeholder to the editor. In this case, if there
  * is no content to the editor, there will be hint to the user.
  *
  * @class CKEDITOR.plugins.ae_placeholder
  */

	/**
  * Specifies the placeholder class which have to be aded to editor when editor is not focused.
  *
  * @attribute placeholderClass
  * @default ae_placeholder
  * @type String
  */

	CKEDITOR.plugins.add('ae_placeholder', {
		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function registers a 'blur' and 'contentDom' event listeners.
   *
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			editor.on('blur', this._checkEmptyData, this);
			editor.on('change', this._checkEmptyData, this);
			editor.on('focus', this._removePlaceholderClass, this);
			editor.once('contentDom', this._checkEmptyData, this);
		},


		/**
   * Removes any data from the content and adds a class,
   * specified by the "placeholderClass" config attribute.
   *
   * @protected
   * @method _checkEmptyData
   * @param {CKEDITOR.dom.event} editor event, fired from CKEditor
   */
		_checkEmptyData: function _checkEmptyData(event) {
			var editor = event.editor;

			var editableNode = editor.editable();

			var innerHtml = editableNode.$.innerHTML.trim();

			var isEmpty = enterModeEmptyValue[editor.config.enterMode].some(function (element) {
				return innerHtml === element;
			});

			if (isEmpty) {
				editableNode.addClass(editor.config.placeholderClass);
			} else {
				editableNode.removeClass(editor.config.placeholderClass);
			}
		},


		/**
             * Remove placeholder class when input is focused
             *
             * @protected
             * @method _removePlaceholderClass
             + @param {CKEDITOR.dom.event} editor event, fired from CKEditor
             */
		_removePlaceholderClass: function _removePlaceholderClass(event) {
			var editor = event.editor;

			var editorNode = new CKEDITOR.dom.element(editor.element.$);

			editorNode.removeClass(editor.config.placeholderClass);
		}
	});
}

/***/ }),

/***/ "./src/plugins/priorities.js":
/*!***********************************!*\
  !*** ./src/plugins/priorities.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Priorities that can be used to control the order in which event handlers run.
 *
 * @see https://ckeditor.com/docs/ckeditor4/latest/api/CKEDITOR_event.html#method-on
 */
var DEFAULT_PRIORITY = exports.DEFAULT_PRIORITY = 10;
var HIGH_PRIORITY = exports.HIGH_PRIORITY = 5;

/***/ }),

/***/ "./src/plugins/selectionkeystrokes.js":
/*!********************************************!*\
  !*** ./src/plugins/selectionkeystrokes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (!CKEDITOR.plugins.get('ae_selectionkeystrokes')) {
	/**
  * CKEditor plugin that simulates editor interaction events based on manual keystrokes. This
  * can be used to trigger different reactions in the editor.
  *
  * @class CKEDITOR.plugins.ae_selectionkeystrokes
  */
	CKEDITOR.plugins.add('ae_selectionkeystrokes', {
		requires: 'ae_selectionregion',

		/**
   * Initialization of the plugin, part of CKEditor plugin lifecycle.
   * The function adds a command to the editor for every defined selectionKeystroke
   * in the configuration and maps it to the specified keystroke.
   *
   * @method init
   * @param {Object} editor The current editor instance
   */
		init: function init(editor) {
			if (editor.config.selectionKeystrokes) {
				editor.config.selectionKeystrokes.forEach(function (selectionKeystroke) {
					var command = new CKEDITOR.command(editor, {
						exec: function exec(editor) {
							editor.fire('editorInteraction', {
								manualSelection: selectionKeystroke.selection,
								nativeEvent: {},
								selectionData: editor.getSelectionData()
							});
						}
					});

					var commandName = 'selectionKeystroke' + selectionKeystroke.selection;

					editor.addCommand(commandName, command);
					editor.setKeystroke(selectionKeystroke.keys, commandName);
				});
			}
		}
	});
}

/***/ }),

/***/ "./src/plugins/tableresize.js":
/*!************************************!*\
  !*** ./src/plugins/tableresize.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

if (!CKEDITOR.plugins.get('ae_tableresize')) {
	var pxUnit = CKEDITOR.tools.cssLength;

	function getWidth(el) {
		return CKEDITOR.env.ie ? el.$.clientWidth : parseInt(el.getComputedStyle('width'), 10);
	}

	function getBorderWidth(element, side) {
		var computed = element.getComputedStyle('border-' + side + '-width');

		var borderMap = {
			thin: '0px',
			medium: '1px',
			thick: '2px'
		};

		if (computed.indexOf('px') < 0) {
			// look up keywords
			if (computed in borderMap && element.getComputedStyle('border-style') != 'none') {
				computed = borderMap[computed];
			} else {
				computed = 0;
			}
		}

		return parseInt(computed, 10);
	}

	// Gets the table row that contains the most columns.
	function getMasterPillarRow(table) {
		var $rows = table.$.rows;

		var maxCells = 0;

		var cellsCount = void 0;

		var $elected = void 0;

		var $tr = void 0;

		for (var i = 0, len = $rows.length; i < len; i++) {
			$tr = $rows[i];
			cellsCount = $tr.cells.length;

			if (cellsCount > maxCells) {
				maxCells = cellsCount;
				$elected = $tr;
			}
		}

		return $elected;
	}

	function buildTableColumnPillars(table) {
		var pillars = [];

		var pillarIndex = -1;

		var rtl = table.getComputedStyle('direction') === 'rtl';

		// Get the raw row element that cointains the most columns.
		var $tr = getMasterPillarRow(table);

		// Get the tbody element and position, which will be used to set the
		// top and bottom boundaries.
		var tbody = new CKEDITOR.dom.element(table.$.tBodies[0]);

		var tbodyPosition = tbody.getDocumentPosition();

		// Loop thorugh all cells, building pillars after each one of them.
		for (var i = 0, len = $tr.cells.length; i < len; i++) {
			// Both the current cell and the successive one will be used in the
			// pillar size calculation.
			var td = new CKEDITOR.dom.element($tr.cells[i]);

			var nextTd = $tr.cells[i + 1] && new CKEDITOR.dom.element($tr.cells[i + 1]);

			pillarIndex += td.$.colSpan || 1;

			// Calculate the pillar boundary positions.
			var pillarLeft = void 0;
			var pillarRight = void 0;

			var x = td.getDocumentPosition().x;

			// Calculate positions based on the current cell.
			if (rtl) {
				pillarRight = x + getBorderWidth(td, 'left');
			} else {
				pillarLeft = x + td.$.offsetWidth - getBorderWidth(td, 'right');
			}

			// Calculate positions based on the next cell, if available.
			if (nextTd) {
				x = nextTd.getDocumentPosition().x;

				if (rtl) {
					pillarLeft = x + nextTd.$.offsetWidth - getBorderWidth(nextTd, 'right');
				} else {
					pillarRight = x + getBorderWidth(nextTd, 'left');
				}
			}
			// Otherwise calculate positions based on the table (for last cell).
			else {
					x = table.getDocumentPosition().x;

					if (rtl) {
						pillarLeft = x;
					} else {
						pillarRight = x + table.$.offsetWidth;
					}
				}

			var pillarWidth = Math.max(pillarRight - pillarLeft, 4);

			// The pillar should reflects exactly the shape of the hovered
			// column border line.
			pillars.push({
				table: table,
				index: pillarIndex,
				x: pillarLeft,
				y: tbodyPosition.y,
				width: pillarWidth,
				height: tbody.$.offsetHeight,
				rtl: rtl
			});
		}

		return pillars;
	}

	function getPillarAtPosition(pillars, positionX) {
		for (var i = 0, len = pillars.length; i < len; i++) {
			var pillar = pillars[i];

			if (positionX >= pillar.x && positionX <= pillar.x + pillar.width) {
				return pillar;
			}
		}

		return null;
	}

	function cancel(evt) {
		(evt.data || evt).preventDefault();
	}

	function ColumnResizer(editor, pillar) {
		var currentShift = void 0;
		var leftShiftBoundary = void 0;
		var leftSideCells = void 0;
		var resizing = void 0;
		var rightShiftBoundary = void 0;
		var rightSideCells = void 0;
		var startOffset = void 0;

		var document = editor.document;

		var resizer = CKEDITOR.dom.element.createFromHtml('<div data-cke-temp=1 contenteditable=false unselectable=on ' + 'style="position:absolute;cursor:col-resize;filter:alpha(opacity=0);opacity:0;' + 'padding:0;background-color:#004;background-image:none;border:0px none;z-index:10"></div>', document);

		var isResizing = this.isResizing = function () {
			return resizing;
		};

		var move = this.move = function (posX) {
			var resizerNewPosition = posX - Math.round(resizer.$.offsetWidth / 2);

			if (isResizing) {
				if (resizerNewPosition === leftShiftBoundary || resizerNewPosition === rightShiftBoundary) {
					return;
				}

				resizerNewPosition = Math.max(resizerNewPosition, leftShiftBoundary);
				resizerNewPosition = Math.min(resizerNewPosition, rightShiftBoundary);

				currentShift = resizerNewPosition - startOffset;
			}

			resizer.setStyle('left', pxUnit(resizerNewPosition));
		};

		function detach() {
			resizer.removeListener('mouseup', onMouseUp);
			resizer.removeListener('mousedown', onMouseDown);
			resizer.removeListener('mousemove', onMouseMove);
		}

		function resizeStart() {
			// Before starting to resize, figure out which cells to change
			// and the boundaries of this resizing shift.

			var columnIndex = pillar.index;

			var map = CKEDITOR.tools.buildTableMap(pillar.table);

			var leftColumnCells = [];

			var rightColumnCells = [];

			var leftMinSize = Number.MAX_VALUE;

			var rightMinSize = leftMinSize;

			var rtl = pillar.rtl;

			for (var i = 0, len = map.length; i < len; i++) {
				var row = map[i];

				var leftCell = row[columnIndex + (rtl ? 1 : 0)];

				var rightCell = row[columnIndex + (rtl ? 0 : 1)];

				leftCell = leftCell && new CKEDITOR.dom.element(leftCell);
				rightCell = rightCell && new CKEDITOR.dom.element(rightCell);

				if (!leftCell || !rightCell || !leftCell.equals(rightCell)) {
					if (leftCell) {
						leftMinSize = Math.min(leftMinSize, getWidth(leftCell));
					}
					if (rightCell) {
						rightMinSize = Math.min(rightMinSize, getWidth(rightCell));
					}

					leftColumnCells.push(leftCell);
					rightColumnCells.push(rightCell);
				}
			}

			// Cache the list of cells to be resized.
			leftSideCells = leftColumnCells;
			rightSideCells = rightColumnCells;

			// Cache the resize limit boundaries.
			leftShiftBoundary = pillar.x - leftMinSize;
			rightShiftBoundary = pillar.x + rightMinSize;

			resizer.setOpacity(0.5);
			startOffset = parseInt(resizer.getStyle('left'), 10);
			currentShift = 0;
			resizing = 1;

			resizer.on('mousemove', onMouseMove);

			// Prevent the native drag behavior otherwise 'mousemove' won't fire.
			document.on('dragstart', cancel);
		}

		function resizeEnd() {
			resizing = 0;

			resizer.setOpacity(0);

			if (currentShift) {
				resizeColumn();
			}

			var table = pillar.table;
			setTimeout(function () {
				table.removeCustomData('_cke_table_pillars');
			}, 0);

			document.removeListener('dragstart', cancel);
		}

		function resizeColumn() {
			var _this = this;

			var rtl = pillar.rtl;

			var cellsCount = rtl ? rightSideCells.length : leftSideCells.length;

			// Perform the actual resize to table cells, only for those by side of the pillar.

			var _loop = function _loop(i) {
				var leftCell = leftSideCells[i];

				var rightCell = rightSideCells[i];

				var table = pillar.table;

				// Defer the resizing to avoid any interference among cells.
				CKEDITOR.tools.setTimeout(function (leftCell, leftOldWidth, rightCell, rightOldWidth, tableWidth, sizeShift) {
					// 1px is the minimum valid width (#11626).
					if (leftCell) {
						leftCell.setStyle('width', pxUnit(Math.max(leftOldWidth + sizeShift, 1)));
					}
					if (rightCell) {
						rightCell.setStyle('width', pxUnit(Math.max(rightOldWidth - sizeShift, 1)));
					}

					// If we're in the last cell, we need to resize the table as well
					if (tableWidth) {
						table.setStyle('width', pxUnit(tableWidth + sizeShift * (rtl ? -1 : 1)));
					}
				}, 0, _this, [leftCell, leftCell && getWidth(leftCell), rightCell, rightCell && getWidth(rightCell), (!leftCell || !rightCell) && getWidth(table) + getBorderWidth(table, 'left') + getBorderWidth(table, 'right'), currentShift]);
			};

			for (var i = 0; i < cellsCount; i++) {
				_loop(i);
			}
		}

		function onMouseDown(evt) {
			cancel(evt);

			resizeStart();

			document.on('mouseup', onMouseUp, this);
		}

		function onMouseUp(evt) {
			evt.removeListener();

			resizeEnd();
		}

		function onMouseMove(evt) {
			move(evt.data.getPageOffset().x);
		}

		// Clean DOM when editor is destroyed.
		editor.on('destroy', function () {
			detach();

			resizer.remove();
		});

		// Place the resizer after body to prevent it
		// from being editable.
		document.getDocumentElement().append(resizer);

		resizer.setStyles({
			width: pxUnit(pillar.width),
			height: pxUnit(pillar.height),
			left: pxUnit(pillar.x),
			top: pxUnit(pillar.y)
		});

		resizer.on('mousedown', onMouseDown, this);

		document.getBody().setStyle('cursor', 'col-resize');

		// Display the resizer to receive events but don't show it,
		// only change the cursor to resizable shape.
		resizer.show();

		this.destroy = function () {
			detach();

			document.getBody().setStyle('cursor', 'auto');

			resizer.remove();
		};
	}

	function clearPillarsCache(evt) {
		var target = evt.data.getTarget();

		if (evt.name === 'mouseout') {
			// Bypass interal mouse move.
			if (!target.is('table')) {
				return;
			}

			var dest = new CKEDITOR.dom.element(evt.data.$.relatedTarget || evt.data.$.toElement);
			while (dest && dest.$ && !dest.equals(target) && !dest.is('body')) {
				dest = dest.getParent();
			}
			if (!dest || dest.equals(target)) {
				return;
			}
		}

		target.getAscendant('table', 1).removeCustomData('_cke_table_pillars');
		evt.removeListener();
	}

	CKEDITOR.plugins.add('ae_tableresize', {
		requires: 'ae_tabletools',

		init: function init(editor) {
			editor.on('contentDom', function () {
				var resizer = void 0;

				var editable = editor.editable();

				// In Classic editor it is better to use document
				// instead of editable so event will work below body.
				editable.attachListener(editable.isInline() ? editable : editor.document, 'mousemove', function (evt) {
					evt = evt.data;

					var target = evt.getTarget();

					// FF may return document and IE8 some UFO (object with no nodeType property...)
					// instead of an element (#11823).
					if (target.type !== CKEDITOR.NODE_ELEMENT) {
						return;
					}

					var pageX = evt.getPageOffset().x;

					// If we're already attached to a pillar, simply move the
					// resizer.
					if (resizer) {
						if (resizer.isResizing()) {
							resizer.move(pageX);

							cancel(evt);

							return;
						} else {
							resizer.destroy();

							resizer = null;
						}
					}

					// Considering table, tr, td, tbody but nothing else.
					var pillars = void 0;

					if (!target.is('table') && !target.getAscendant('tbody', 1)) {
						return;
					}

					var table = target.getAscendant('table', 1);

					// Make sure the table we found is inside the container
					// (eg. we should not use tables the editor is embedded within)
					if (!editor.editable().contains(table)) {
						return;
					}

					if (!(pillars = table.getCustomData('_cke_table_pillars'))) {
						// Cache table pillars calculation result.
						table.setCustomData('_cke_table_pillars', pillars = buildTableColumnPillars(table));
						table.on('mouseout', clearPillarsCache);
						table.on('mousedown', clearPillarsCache);
					}

					var pillar = getPillarAtPosition(pillars, pageX);

					if (pillar) {
						resizer = new ColumnResizer(editor, pillar);
					}
				});
			});
		}
	});
}

/***/ }),

/***/ "./src/plugins/tabletools.js":
/*!***********************************!*\
  !*** ./src/plugins/tabletools.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * @license Copyright (c) 2003-2015, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

if (!CKEDITOR.plugins.get('ae_tabletools')) {
	var cellNodeRegex = /^(?:td|th)$/;

	function getSelectedCells(selection) {
		var ranges = selection.getRanges();
		var retval = [];
		var database = {};

		function moveOutOfCellGuard(node) {
			// Apply to the first cell only.
			if (retval.length > 0) return;

			// If we are exiting from the first </td>, then the td should definitely be
			// included.
			if (node.type == CKEDITOR.NODE_ELEMENT && cellNodeRegex.test(node.getName()) && !node.getCustomData('selected_cell')) {
				CKEDITOR.dom.element.setMarker(database, node, 'selected_cell', true);
				retval.push(node);
			}
		}

		for (var i = 0; i < ranges.length; i++) {
			var range = ranges[i];

			if (range.collapsed) {
				// Walker does not handle collapsed ranges yet - fall back to old API.
				var startNode = range.getCommonAncestor();
				var nearestCell = startNode.getAscendant('td', true) || startNode.getAscendant('th', true);
				if (nearestCell) retval.push(nearestCell);
			} else {
				var walker = new CKEDITOR.dom.walker(range);
				var node = void 0;
				walker.guard = moveOutOfCellGuard;

				while (node = walker.next()) {
					// If may be possible for us to have a range like this:
					// <td>^1</td><td>^2</td>
					// The 2nd td shouldn't be included.
					//
					// So we have to take care to include a td we've entered only when we've
					// walked into its children.

					if (node.type != CKEDITOR.NODE_ELEMENT || !node.is(CKEDITOR.dtd.table)) {
						var parent = node.getAscendant('td', true) || node.getAscendant('th', true);
						if (parent && !parent.getCustomData('selected_cell')) {
							CKEDITOR.dom.element.setMarker(database, parent, 'selected_cell', true);
							retval.push(parent);
						}
					}
				}
			}
		}

		CKEDITOR.dom.element.clearAllMarkers(database);

		return retval;
	}

	function getFocusElementAfterDelCells(cellsToDelete) {
		var i = 0;

		var last = cellsToDelete.length - 1;

		var database = {};

		var cell = void 0;

		var focusedCell = void 0;

		var tr = void 0;

		while (cell = cellsToDelete[i++]) {
			CKEDITOR.dom.element.setMarker(database, cell, 'delete_cell', true);
		} // 1.first we check left or right side focusable cell row by row;
		i = 0;
		while (cell = cellsToDelete[i++]) {
			if ((focusedCell = cell.getPrevious()) && !focusedCell.getCustomData('delete_cell') || (focusedCell = cell.getNext()) && !focusedCell.getCustomData('delete_cell')) {
				CKEDITOR.dom.element.clearAllMarkers(database);
				return focusedCell;
			}
		}

		CKEDITOR.dom.element.clearAllMarkers(database);

		// 2. then we check the toppest row (outside the selection area square) focusable cell
		tr = cellsToDelete[0].getParent();
		if (tr = tr.getPrevious()) return tr.getLast();

		// 3. last we check the lowerest  row focusable cell
		tr = cellsToDelete[last].getParent();
		if (tr = tr.getNext()) return tr.getChild(0);

		return null;
	}

	function insertRow(selection, insertBefore) {
		var cells = getSelectedCells(selection);

		var firstCell = cells[0];

		var table = firstCell.getAscendant('table');

		var doc = firstCell.getDocument();

		var startRow = cells[0].getParent();

		var startRowIndex = startRow.$.rowIndex;

		var lastCell = cells[cells.length - 1];

		var endRowIndex = lastCell.getParent().$.rowIndex + lastCell.$.rowSpan - 1;

		var endRow = new CKEDITOR.dom.element(table.$.rows[endRowIndex]);

		var rowIndex = insertBefore ? startRowIndex : endRowIndex;

		var row = insertBefore ? startRow : endRow;

		var map = CKEDITOR.tools.buildTableMap(table);

		var cloneRow = map[rowIndex];

		var nextRow = insertBefore ? map[rowIndex - 1] : map[rowIndex + 1];

		var width = map[0].length;

		var newRow = doc.createElement('tr');
		for (var i = 0; cloneRow[i] && i < width; i++) {
			var cell = void 0;
			// Check whether there's a spanning row here, do not break it.
			if (cloneRow[i].rowSpan > 1 && nextRow && cloneRow[i] == nextRow[i]) {
				cell = cloneRow[i];
				cell.rowSpan += 1;
			} else {
				cell = new CKEDITOR.dom.element(cloneRow[i]).clone();
				cell.removeAttribute('rowSpan');
				cell.appendBogus();
				newRow.append(cell);
				cell = cell.$;
			}

			i += cell.colSpan - 1;
		}

		if (insertBefore) {
			newRow.insertBefore(row);
		} else {
			newRow.insertAfter(row);
		}
	}

	function deleteRows(selectionOrRow) {
		if (selectionOrRow instanceof CKEDITOR.dom.selection) {
			var cells = getSelectedCells(selectionOrRow);

			var firstCell = cells[0];

			var table = firstCell.getAscendant('table');

			var map = CKEDITOR.tools.buildTableMap(table);

			var startRow = cells[0].getParent();

			var startRowIndex = startRow.$.rowIndex;

			var lastCell = cells[cells.length - 1];

			var endRowIndex = lastCell.getParent().$.rowIndex + lastCell.$.rowSpan - 1;

			var rowsToDelete = [];

			// Delete cell or reduce cell spans by checking through the table map.
			for (var i = startRowIndex; i <= endRowIndex; i++) {
				var mapRow = map[i];

				var row = new CKEDITOR.dom.element(table.$.rows[i]);

				for (var j = 0; j < mapRow.length; j++) {
					var cell = new CKEDITOR.dom.element(mapRow[j]);

					var cellRowIndex = cell.getParent().$.rowIndex;

					if (cell.$.rowSpan == 1) cell.remove();
					// Row spanned cell.
					else {
							// Span row of the cell, reduce spanning.
							cell.$.rowSpan -= 1;
							// Root row of the cell, root cell to next row.
							if (cellRowIndex == i) {
								var nextMapRow = map[i + 1];
								if (nextMapRow[j - 1]) {
									cell.insertAfter(new CKEDITOR.dom.element(nextMapRow[j - 1]));
								} else {
									new CKEDITOR.dom.element(table.$.rows[i + 1]).append(cell, 1);
								}
							}
						}

					j += cell.$.colSpan - 1;
				}

				rowsToDelete.push(row);
			}

			var rows = table.$.rows;

			// Where to put the cursor after rows been deleted?
			// 1. Into next sibling row if any;
			// 2. Into previous sibling row if any;
			// 3. Into table's parent element if it's the very last row.
			var cursorPosition = new CKEDITOR.dom.element(rows[endRowIndex + 1] || (startRowIndex > 0 ? rows[startRowIndex - 1] : null) || table.$.parentNode);

			for (var _i = rowsToDelete.length; _i >= 0; _i--) {
				deleteRows(rowsToDelete[_i]);
			}return cursorPosition;
		} else if (selectionOrRow instanceof CKEDITOR.dom.element) {
			var _table = selectionOrRow.getAscendant('table');

			if (_table.$.rows.length == 1) _table.remove();else selectionOrRow.remove();
		}

		return null;
	}

	function getCellColIndex(cell, isStart) {
		var row = cell.getParent();

		var rowCells = row.$.cells;

		var colIndex = 0;
		for (var i = 0; i < rowCells.length; i++) {
			var mapCell = rowCells[i];
			colIndex += isStart ? 1 : mapCell.colSpan;
			if (mapCell == cell.$) break;
		}

		return colIndex - 1;
	}

	function getColumnsIndices(cells, isStart) {
		var retval = isStart ? Infinity : 0;
		for (var i = 0; i < cells.length; i++) {
			var colIndex = getCellColIndex(cells[i], isStart);
			if (isStart ? colIndex < retval : colIndex > retval) retval = colIndex;
		}
		return retval;
	}

	function insertColumn(selection, insertBefore) {
		var cells = getSelectedCells(selection);

		var firstCell = cells[0];

		var table = firstCell.getAscendant('table');

		var startCol = getColumnsIndices(cells, 1);

		var lastCol = getColumnsIndices(cells);

		var colIndex = insertBefore ? startCol : lastCol;

		var map = CKEDITOR.tools.buildTableMap(table);

		var cloneCol = [];

		var nextCol = [];

		var height = map.length;

		for (var i = 0; i < height; i++) {
			cloneCol.push(map[i][colIndex]);
			var nextCell = insertBefore ? map[i][colIndex - 1] : map[i][colIndex + 1];
			nextCol.push(nextCell);
		}

		for (var _i2 = 0; _i2 < height; _i2++) {
			var cell = void 0;

			if (!cloneCol[_i2]) continue;

			// Check whether there's a spanning column here, do not break it.
			if (cloneCol[_i2].colSpan > 1 && nextCol[_i2] == cloneCol[_i2]) {
				cell = cloneCol[_i2];
				cell.colSpan += 1;
			} else {
				cell = new CKEDITOR.dom.element(cloneCol[_i2]).clone();
				cell.removeAttribute('colSpan');
				cell.appendBogus();
				cell[insertBefore ? 'insertBefore' : 'insertAfter'].call(cell, new CKEDITOR.dom.element(cloneCol[_i2]));
				cell = cell.$;
			}

			_i2 += cell.rowSpan - 1;
		}
	}

	function deleteColumns(selectionOrCell) {
		var cells = getSelectedCells(selectionOrCell);

		var firstCell = cells[0];

		var lastCell = cells[cells.length - 1];

		var table = firstCell.getAscendant('table');

		var map = CKEDITOR.tools.buildTableMap(table);

		var startColIndex = void 0;

		var endColIndex = void 0;

		var rowsToDelete = [];

		var rows = void 0;

		// Figure out selected cells' column indices.
		for (var i = 0, _rows = map.length; i < _rows; i++) {
			// eslint-disable-next-line sort-vars
			for (var j = 0, cols = map[i].length; j < cols; j++) {
				if (map[i][j] == firstCell.$) startColIndex = j;
				if (map[i][j] == lastCell.$) endColIndex = j;
			}
		}

		// Delete cell or reduce cell spans by checking through the table map.
		for (var _i3 = startColIndex; _i3 <= endColIndex; _i3++) {
			for (var _j = 0; _j < map.length; _j++) {
				var mapRow = map[_j];

				var row = new CKEDITOR.dom.element(table.$.rows[_j]);

				var cell = new CKEDITOR.dom.element(mapRow[_i3]);

				if (cell.$) {
					if (cell.$.colSpan == 1) cell.remove();
					// Reduce the col spans.
					else cell.$.colSpan -= 1;

					_j += cell.$.rowSpan - 1;

					if (!row.$.cells.length) rowsToDelete.push(row);
				}
			}
		}

		var firstRowCells = table.$.rows[0] && table.$.rows[0].cells;

		// Where to put the cursor after columns been deleted?
		// 1. Into next cell of the first row if any;
		// 2. Into previous cell of the first row if any;
		// 3. Into table's parent element;
		var cursorPosition = new CKEDITOR.dom.element(firstRowCells[startColIndex] || (startColIndex ? firstRowCells[startColIndex - 1] : table.$.parentNode));

		// Delete table rows only if all columns are gone (do not remove empty row).
		if (rowsToDelete.length == rows) table.remove();

		return cursorPosition;
	}

	function insertCell(selection, insertBefore) {
		var startElement = selection.getStartElement();
		var cell = startElement.getAscendant('td', 1) || startElement.getAscendant('th', 1);

		if (!cell) return;

		// Create the new cell element to be added.
		var newCell = cell.clone();
		newCell.appendBogus();

		if (insertBefore) newCell.insertBefore(cell);else newCell.insertAfter(cell);
	}

	function deleteCells(selectionOrCell) {
		if (selectionOrCell instanceof CKEDITOR.dom.selection) {
			var cellsToDelete = getSelectedCells(selectionOrCell);
			var table = cellsToDelete[0] && cellsToDelete[0].getAscendant('table');
			var cellToFocus = getFocusElementAfterDelCells(cellsToDelete);

			for (var i = cellsToDelete.length - 1; i >= 0; i--) {
				deleteCells(cellsToDelete[i]);
			}if (cellToFocus) placeCursorInCell(cellToFocus, true);else if (table) table.remove();
		} else if (selectionOrCell instanceof CKEDITOR.dom.element) {
			var tr = selectionOrCell.getParent();
			if (tr.getChildCount() == 1) tr.remove();else selectionOrCell.remove();
		}
	}

	// Remove filler at end and empty spaces around the cell content.
	function trimCell(cell) {
		var bogus = cell.getBogus();
		if (bogus) {
			bogus.remove();
		}
		cell.trim();
	}

	function placeCursorInCell(cell, placeAtEnd) {
		var docInner = cell.getDocument();

		var docOuter = CKEDITOR.document;

		// Fixing "Unspecified error" thrown in IE10 by resetting
		// selection the dirty and shameful way (#10308).
		// We can not apply this hack to IE8 because
		// it causes error (#11058).
		if (CKEDITOR.env.ie && CKEDITOR.env.version == 10) {
			docOuter.focus();
			docInner.focus();
		}

		var range = new CKEDITOR.dom.range(docInner);
		if (!range['moveToElementEdit' + (placeAtEnd ? 'End' : 'Start')](cell)) {
			range.selectNodeContents(cell);
			range.collapse(placeAtEnd ? false : true);
		}
		range.select(true);
	}

	function cellInRow(tableMap, rowIndex, cell) {
		var oRow = tableMap[rowIndex];
		if (typeof cell == 'undefined') return oRow;

		for (var c = 0; oRow && c < oRow.length; c++) {
			if (cell.is && oRow[c] == cell.$) return c;else if (c == cell) return new CKEDITOR.dom.element(oRow[c]);
		}
		return cell.is ? -1 : null;
	}

	function cellInCol(tableMap, colIndex) {
		var oCol = [];
		for (var r = 0; r < tableMap.length; r++) {
			var row = tableMap[r];
			oCol.push(row[colIndex]);

			// Avoid adding duplicate cells.
			if (row[colIndex].rowSpan > 1) r += row[colIndex].rowSpan - 1;
		}
		return oCol;
	}

	function mergeCells(selection, mergeDirection, isDetect) {
		var cells = getSelectedCells(selection);

		// Invalid merge request if:
		// 1. In batch mode despite that less than two selected.
		// 2. In solo mode while not exactly only one selected.
		// 3. Cells distributed in different table groups (e.g. from both thead and tbody).
		var commonAncestor = void 0;
		if ((mergeDirection ? cells.length != 1 : cells.length < 2) || (commonAncestor = selection.getCommonAncestor()) && commonAncestor.type == CKEDITOR.NODE_ELEMENT && commonAncestor.is('table')) return false;

		var cell = void 0;

		var firstCell = cells[0];

		var table = firstCell.getAscendant('table');

		var map = CKEDITOR.tools.buildTableMap(table);

		var mapHeight = map.length;

		var mapWidth = map[0].length;

		var startRow = firstCell.getParent().$.rowIndex;

		var startColumn = cellInRow(map, startRow, firstCell);

		if (mergeDirection) {
			var targetCell = void 0;
			try {
				var rowspan = parseInt(firstCell.getAttribute('rowspan'), 10) || 1;
				var colspan = parseInt(firstCell.getAttribute('colspan'), 10) || 1;

				targetCell = map[mergeDirection == 'up' ? startRow - rowspan : mergeDirection == 'down' ? startRow + rowspan : startRow][mergeDirection == 'left' ? startColumn - colspan : mergeDirection == 'right' ? startColumn + colspan : startColumn];
			} catch (er) {
				return false;
			}

			// 1. No cell could be merged.
			// 2. Same cell actually.
			if (!targetCell || firstCell.$ == targetCell) return false;

			// Sort in map order regardless of the DOM sequence.
			cells[mergeDirection == 'up' || mergeDirection == 'left' ? 'unshift' : 'push'](new CKEDITOR.dom.element(targetCell));
		}

		// Start from here are merging way ignorance (merge up/right, batch merge).
		var doc = firstCell.getDocument();

		var lastRowIndex = startRow;

		var totalRowSpan = 0;

		var totalColSpan = 0;

		// Use a documentFragment as buffer when appending cell contents.

		var frag = !isDetect && new CKEDITOR.dom.documentFragment(doc);

		var dimension = 0;

		for (var i = 0; i < cells.length; i++) {
			cell = cells[i];

			var tr = cell.getParent();

			var cellFirstChild = cell.getFirst();

			var colSpan = cell.$.colSpan;

			var rowSpan = cell.$.rowSpan;

			var rowIndex = tr.$.rowIndex;

			var colIndex = cellInRow(map, rowIndex, cell);

			// Accumulated the actual places taken by all selected cells.
			dimension += colSpan * rowSpan;
			// Accumulated the maximum virtual spans from column and row.
			totalColSpan = Math.max(totalColSpan, colIndex - startColumn + colSpan);
			totalRowSpan = Math.max(totalRowSpan, rowIndex - startRow + rowSpan);

			if (!isDetect) {
				// Trim all cell fillers and check to remove empty cells.
				if (trimCell(cell), cell.getChildren().count()) {
					// Merge vertically cells as two separated paragraphs.
					if (rowIndex != lastRowIndex && cellFirstChild && !(cellFirstChild.isBlockBoundary && cellFirstChild.isBlockBoundary({ br: 1 }))) {
						var last = frag.getLast(CKEDITOR.dom.walker.whitespaces(true));
						if (last && !(last.is && last.is('br'))) frag.append('br');
					}

					cell.moveChildren(frag);
				}
				if (i) {
					cell.remove();
				} else {
					cell.setHtml('');
				}
			}
			lastRowIndex = rowIndex;
		}

		if (!isDetect) {
			frag.moveChildren(firstCell);

			firstCell.appendBogus();

			if (totalColSpan >= mapWidth) firstCell.removeAttribute('rowSpan');else firstCell.$.rowSpan = totalRowSpan;

			if (totalRowSpan >= mapHeight) firstCell.removeAttribute('colSpan');else firstCell.$.colSpan = totalColSpan;

			// Swip empty <tr> left at the end of table due to the merging.
			var trs = new CKEDITOR.dom.nodeList(table.$.rows);

			var count = trs.count();

			for (var _i4 = count - 1; _i4 >= 0; _i4--) {
				var tailTr = trs.getItem(_i4);
				if (!tailTr.$.cells.length) {
					tailTr.remove();
					count++;
					continue;
				}
			}

			return firstCell;
		}
		// Be able to merge cells only if actual dimension of selected
		// cells equals to the caculated rectangle.
		else {
				return totalRowSpan * totalColSpan == dimension;
			}
	}

	function verticalSplitCell(selection, isDetect) {
		var cells = getSelectedCells(selection);
		if (cells.length > 1) return false;else if (isDetect) return true;

		var cell = cells[0];

		var tr = cell.getParent();

		var table = tr.getAscendant('table');

		var map = CKEDITOR.tools.buildTableMap(table);

		var rowIndex = tr.$.rowIndex;

		var colIndex = cellInRow(map, rowIndex, cell);

		var rowSpan = cell.$.rowSpan;

		var newCell = void 0;

		var newRowSpan = void 0;

		var newCellRowSpan = void 0;

		var newRowIndex = void 0;

		if (rowSpan > 1) {
			newRowSpan = Math.ceil(rowSpan / 2);
			newCellRowSpan = Math.floor(rowSpan / 2);
			newRowIndex = rowIndex + newRowSpan;
			var newCellTr = new CKEDITOR.dom.element(table.$.rows[newRowIndex]);

			var newCellRow = cellInRow(map, newRowIndex);

			var candidateCell = void 0;

			newCell = cell.clone();

			// Figure out where to insert the new cell by checking the vitual row.
			for (var c = 0; c < newCellRow.length; c++) {
				candidateCell = newCellRow[c];
				// Catch first cell actually following the column.
				if (candidateCell.parentNode == newCellTr.$ && c > colIndex) {
					newCell.insertBefore(new CKEDITOR.dom.element(candidateCell));
					break;
				} else {
					candidateCell = null;
				}
			}

			// The destination row is empty, append at will.
			if (!candidateCell) newCellTr.append(newCell);
		} else {
			newCellRowSpan = newRowSpan = 1;

			var _newCellTr = tr.clone();
			_newCellTr.insertAfter(tr);
			_newCellTr.append(newCell = cell.clone());

			var cellsInSameRow = cellInRow(map, rowIndex);
			for (var i = 0; i < cellsInSameRow.length; i++) {
				cellsInSameRow[i].rowSpan++;
			}
		}

		newCell.appendBogus();

		cell.$.rowSpan = newRowSpan;
		newCell.$.rowSpan = newCellRowSpan;
		if (newRowSpan == 1) cell.removeAttribute('rowSpan');
		if (newCellRowSpan == 1) newCell.removeAttribute('rowSpan');

		return newCell;
	}

	function horizontalSplitCell(selection, isDetect) {
		var cells = getSelectedCells(selection);
		if (cells.length > 1) return false;else if (isDetect) return true;

		var cell = cells[0];

		var tr = cell.getParent();

		var table = tr.getAscendant('table');

		var map = CKEDITOR.tools.buildTableMap(table);

		var rowIndex = tr.$.rowIndex;

		var colIndex = cellInRow(map, rowIndex, cell);

		var colSpan = cell.$.colSpan;

		var newColSpan = void 0;

		var newCellColSpan = void 0;

		if (colSpan > 1) {
			newColSpan = Math.ceil(colSpan / 2);
			newCellColSpan = Math.floor(colSpan / 2);
		} else {
			newCellColSpan = newColSpan = 1;
			var cellsInSameCol = cellInCol(map, colIndex);
			for (var i = 0; i < cellsInSameCol.length; i++) {
				cellsInSameCol[i].colSpan++;
			}
		}
		var newCell = cell.clone();
		newCell.insertAfter(cell);
		newCell.appendBogus();

		cell.$.colSpan = newColSpan;
		newCell.$.colSpan = newCellColSpan;
		if (newColSpan == 1) cell.removeAttribute('colSpan');
		if (newCellColSpan == 1) newCell.removeAttribute('colSpan');

		return newCell;
	}

	CKEDITOR.plugins.add('ae_tabletools', {
		init: function init(editor) {
			function createDef(def) {
				return CKEDITOR.tools.extend(def || {}, {
					contextSensitive: 1,
					refresh: function refresh(editor, path) {
						this.setState(path.contains({ td: 1, th: 1 }, 1) ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED);
					}
				});
			}
			function addCmd(name, def) {
				var cmd = editor.getCommand(name);

				if (cmd) {
					return;
				}

				cmd = editor.addCommand(name, def);
				editor.addFeature(cmd);
			}

			addCmd('rowDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					placeCursorInCell(deleteRows(selection));
				}
			}));

			addCmd('rowInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertRow(selection, true);
				}
			}));

			addCmd('rowInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertRow(selection);
				}
			}));

			addCmd('columnDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					var element = deleteColumns(selection);
					if (element) {
						placeCursorInCell(element, true);
					}
				}
			}));

			addCmd('columnInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertColumn(selection, true);
				}
			}));

			addCmd('columnInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertColumn(selection);
				}
			}));

			addCmd('cellDelete', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					deleteCells(selection);
				}
			}));

			addCmd('cellMerge', createDef({
				allowedContent: 'td[colspan,rowspan]',
				requiredContent: 'td[colspan,rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection()), true);
				}
			}));

			addCmd('cellMergeRight', createDef({
				allowedContent: 'td[colspan]',
				requiredContent: 'td[colspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection(), 'right'), true);
				}
			}));

			addCmd('cellMergeDown', createDef({
				allowedContent: 'td[rowspan]',
				requiredContent: 'td[rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(mergeCells(editor.getSelection(), 'down'), true);
				}
			}));

			addCmd('cellVerticalSplit', createDef({
				allowedContent: 'td[rowspan]',
				requiredContent: 'td[rowspan]',
				exec: function exec(editor) {
					placeCursorInCell(verticalSplitCell(editor.getSelection()));
				}
			}));

			addCmd('cellHorizontalSplit', createDef({
				allowedContent: 'td[colspan]',
				requiredContent: 'td[colspan]',
				exec: function exec(editor) {
					placeCursorInCell(horizontalSplitCell(editor.getSelection()));
				}
			}));

			addCmd('cellInsertBefore', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertCell(selection, true);
				}
			}));

			addCmd('cellInsertAfter', createDef({
				requiredContent: 'table',
				exec: function exec(editor) {
					var selection = editor.getSelection();
					insertCell(selection);
				}
			}));
		},


		getSelectedCells: getSelectedCells
	});
}

/**
 * Create a two-dimension array that reflects the actual layout of table cells,
 * with cell spans, with mappings to the original td elements.
 *
 * @param {CKEDITOR.dom.element} table
 * @member CKEDITOR.tools
 */
CKEDITOR.tools.buildTableMap = function (table) {
	var aRows = table.$.rows;

	// Row and Column counters.
	var r = -1;

	var aMap = [];

	for (var i = 0; i < aRows.length; i++) {
		r++;
		if (!aMap[r]) {
			aMap[r] = [];
		}

		var c = -1;

		for (var j = 0; j < aRows[i].cells.length; j++) {
			var oCell = aRows[i].cells[j];

			c++;
			while (aMap[r][c]) {
				c++;
			}var iColSpan = isNaN(oCell.colSpan) ? 1 : oCell.colSpan;
			var iRowSpan = isNaN(oCell.rowSpan) ? 1 : oCell.rowSpan;

			for (var rs = 0; rs < iRowSpan; rs++) {
				if (!aMap[r + rs]) aMap[r + rs] = [];

				for (var cs = 0; cs < iColSpan; cs++) {
					aMap[r + rs][c + cs] = aRows[i].cells[j];
				}
			}

			c += iColSpan - 1;
		}
	}
	return aMap;
};

/***/ }),

/***/ "./src/selections/selection-arrowbox.js":
/*!**********************************************!*\
  !*** ./src/selections/selection-arrowbox.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var tableSelectionGetArrowBoxClasses = function tableSelectionGetArrowBoxClasses() {
	return 'ae-arrow-box ae-arrow-box-bottom';
};

var SelectionGetArrowBoxClasses = {
	table: tableSelectionGetArrowBoxClasses
};

exports.default = SelectionGetArrowBoxClasses;

/***/ }),

/***/ "./src/selections/selection-position.js":
/*!**********************************************!*\
  !*** ./src/selections/selection-position.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _reactDom = __webpack_require__(/*! react-dom */ "react-dom");

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Default gutter value for toolbar positioning
var DEFAULT_GUTTER = {
	left: 0,
	top: 0
};

/**
 * Centers a Toolbar according to given rectangle
 *
 * @method centerToolbar
 * @param {Object} toolbar The toolbar to be centered
 * @param {Object} rect The rectangle according to which the Toolbar will be centered
 */
var centerToolbar = function centerToolbar(toolbar, rect) {
	var toolbarNode = _reactDom2.default.findDOMNode(toolbar);

	var nativeEditor = toolbar.context.editor.get('nativeEditor');
	var uiNode = nativeEditor.config.uiNode || document.body;
	var uiNodeStyle = getComputedStyle(uiNode);
	var uiNodeMarginLeft = parseInt(uiNodeStyle.getPropertyValue('margin-left'), 10);
	var uiNodeMarginRight = parseInt(uiNodeStyle.getPropertyValue('margin-right'), 10);
	var totalWidth = uiNodeMarginLeft + uiNode.clientWidth + uiNodeMarginRight;

	var halfNodeWidth = toolbarNode.offsetWidth / 2;
	var scrollPosition = new CKEDITOR.dom.window(window).getScrollPosition();

	var gutter = toolbar.props.gutter || DEFAULT_GUTTER;

	var widgetXY = toolbar.getWidgetXYPoint(rect.left + rect.width / 2 - scrollPosition.x, rect.top + scrollPosition.y, CKEDITOR.SELECTION_BOTTOM_TO_TOP);

	var endPosition = [rect.left + rect.width / 2 - halfNodeWidth - scrollPosition.x, rect.top - toolbarNode.offsetHeight + scrollPosition.y - gutter.top];

	if (endPosition[0] < 0) {
		endPosition[0] = 0;
	} else if (endPosition[0] > totalWidth - toolbarNode.offsetWidth) {
		endPosition[0] = totalWidth - toolbarNode.offsetWidth;
	}

	toolbar.moveToPoint(widgetXY, endPosition);
};

/**
 * Sets the position of a toolbar according to the position of the selected image
 *
 * @method imageSelectionSetPosition
 * @param {Object} payload Payload, should contain the selection data for retrieving the
 * client rectangle of the selected image
 * @return {Boolean} True, in all cases
 */
var imageSelectionSetPosition = function imageSelectionSetPosition(payload) {
	var selectionData = payload.selectionData ? payload.selectionData : payload.editorEvent ? payload.editorEvent.data.selectionData : null;

	if (selectionData && selectionData.element) {
		centerToolbar(this, selectionData.element.getClientRect());

		return true;
	}
};

/**
 * Sets the position of a toolbar according to the position of the selected image
 *
 * @method tableSelectionSetPosition
 * @param {Object} payload Object, which contains the selection data for retrieving the
 * client rectangle of the selected table
 * @return {Boolean} True, in all cases
 */
var tableSelectionSetPosition = function tableSelectionSetPosition(payload) {
	var nativeEditor = payload.editor.get('nativeEditor');
	var uiNode = nativeEditor.config.uiNode;

	var scrollTop = uiNode ? uiNode.scrollTop : 0;

	var table = new CKEDITOR.Table(nativeEditor).getFromSelection();
	var rect = table.getClientRect();
	rect.top += scrollTop;

	centerToolbar(this, rect);

	return true;
};

var SelectionSetPosition = {
	image: imageSelectionSetPosition,
	table: tableSelectionSetPosition
};

exports.default = SelectionSetPosition;

/***/ }),

/***/ "./src/selections/selection-test.js":
/*!******************************************!*\
  !*** ./src/selections/selection-test.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});
var _isRangeAtElementEnd = function _isRangeAtElementEnd(range, element) {
	// Finding if a range is at the end of an element is somewhat tricky due to how CKEditor handles
	// ranges. It might depend on wether a source node inside the element is selected or not. For now,
	// we need to cover the following cases:
	//
	// - The text length of the element is the same as the endOffset of the range
	// - Both start and end containers match the element and the start and end offsets are 1

	return element.getText().length === range.endOffset || element.equals(range.startContainer) && element.equals(range.endContainer) && range.startOffset === range.endOffset && range.endOffset === 1;
};

var embedSelectionTest = function embedSelectionTest(payload) {
	var selectionData = payload.data.selectionData;

	return !!(selectionData.element && selectionData.element.getAttribute('data-widget') === 'ae_embed');
};

var embedUrlSelectionTest = function embedUrlSelectionTest(payload) {
	var selectionData = payload.data.selectionData;

	return !!(selectionData.element && selectionData.element.getAttribute('data-widget') === 'embedurl');
};

var headingTextSelectionTest = function headingTextSelectionTest(payload) {
	var headings = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
	var nativeEditor = payload.editor.get('nativeEditor');
	var selectionData = payload.data.selectionData;
	var selectionEmpty = nativeEditor.isSelectionEmpty();

	return !!(!selectionData.element && selectionData.region && !selectionEmpty && !nativeEditor.getSelection().getCommonAncestor().isReadOnly() && nativeEditor.elementPath().contains(headings));
};

var linkSelectionTest = function linkSelectionTest(payload) {
	var nativeEditor = payload.editor.get('nativeEditor');
	var range = nativeEditor.getSelection().getRanges()[0];
	var selectionData = payload.data.selectionData;

	var element = new CKEDITOR.Link(nativeEditor).getFromSelection();
	var isSelectionEmpty = nativeEditor.isSelectionEmpty();
	var elementIsNotImage = selectionData.element ? selectionData.element.getName() !== 'img' : true;

	return !!(isSelectionEmpty && elementIsNotImage && element && element.getText().length !== range.endOffset && element && !element.isReadOnly() && !_isRangeAtElementEnd(range, element));
};

var imageSelectionTest = function imageSelectionTest(payload) {
	var selectionData = payload.data.selectionData;
	var element = selectionData.element;
	var hasImage = !!element && !!element.findOne('img');
	var isImage = !!element && element.getName() === 'img';

	return !!(element && (hasImage || isImage));
};

var textSelectionTest = function textSelectionTest(payload) {
	var nativeEditor = payload.editor.get('nativeEditor');

	var selectionEmpty = nativeEditor.isSelectionEmpty();

	var selectionData = payload.data.selectionData;

	return !!(!selectionData.element && selectionData.region && !selectionEmpty && !nativeEditor.getSelection().getCommonAncestor().isReadOnly());
};

var tableSelectionTest = function tableSelectionTest(payload) {
	var nativeEditor = payload.editor.get('nativeEditor');

	var table = new CKEDITOR.Table(nativeEditor);
	var element = table.getFromSelection();

	return !!(element && table.isEditable(element));
};

var SelectionTest = {
	embed: embedSelectionTest,
	embedUrl: embedUrlSelectionTest,
	header: headingTextSelectionTest,
	image: imageSelectionTest,
	link: linkSelectionTest,
	table: tableSelectionTest,
	text: textSelectionTest
};

exports.default = SelectionTest;

/***/ }),

/***/ "./src/selections/selections.js":
/*!**************************************!*\
  !*** ./src/selections/selections.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
	value: true
});

var _selectionArrowbox = __webpack_require__(/*! ./selection-arrowbox */ "./src/selections/selection-arrowbox.js");

var _selectionArrowbox2 = _interopRequireDefault(_selectionArrowbox);

var _selectionPosition = __webpack_require__(/*! ./selection-position */ "./src/selections/selection-position.js");

var _selectionPosition2 = _interopRequireDefault(_selectionPosition);

var _selectionTest = __webpack_require__(/*! ./selection-test */ "./src/selections/selection-test.js");

var _selectionTest2 = _interopRequireDefault(_selectionTest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Selections = [{
	name: 'embed',
	buttons: ['embedRemove', 'embedEdit'],
	test: _selectionTest2.default.embed
}, {
	name: 'embedUrl',
	buttons: ['embedVideo', 'embedVideoEdit'],
	test: _selectionTest2.default.embedUrl
}, {
	name: 'link',
	buttons: ['linkEdit'],
	test: _selectionTest2.default.link
}, {
	name: 'image',
	buttons: ['imageLeft', 'imageCenter', 'imageRight', 'removeImage'],
	setPosition: _selectionPosition2.default.image,
	test: _selectionTest2.default.image
}, {
	name: 'text',
	buttons: {
		full: [['Font', 'FontSize', 'separator', 'bold', 'italic', 'underline', 'strike', 'separator', 'link'], ['paragraphAlign', 'separator', 'ul', 'ol', 'separator', 'h1', 'h2', 'separator', 'indentBlock', 'outdentBlock', 'separator', 'TextColor', 'BGColor', 'separator', 'code', 'quote', 'separator', 'removeFormat']],

		simple: ['styles', 'bold', 'italic', 'underline', 'link']
	},
	test: _selectionTest2.default.text
}, {
	name: 'table',
	buttons: ['tableHeading', 'tableRow', 'tableColumn', 'tableCell', 'tableRemove'],
	getArrowBoxClasses: _selectionArrowbox2.default.table,
	setPosition: _selectionPosition2.default.table,
	test: _selectionTest2.default.table
}];

exports.default = Selections;

/***/ }),

/***/ "react":
/*!****************************************************************************************************!*\
  !*** external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react","umd":"react"} ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window[undefined]; }());

/***/ }),

/***/ "react-dom":
/*!***********************************************************************************************************************!*\
  !*** external {"root":"ReactDOM","commonjs2":"react-dom","commonjs":"react-dom","amd":"react-dom","umd":"react-dom"} ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() { module.exports = window[undefined]; }());

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9BbGxveUVkaXRvci93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9hZGFwdGVyL2NvcmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvYWRhcHRlci9lZGl0b3ItY29udGV4dC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9hZGFwdGVyL21haW4uanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tbWFuZHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tbWFuZHMvcmVtb3ZlLWltYWdlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tYWN0aW9uLXN0eWxlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2J1dHRvbi1jb21tYW5kLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24ta2V5c3Ryb2tlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tcHJvcHMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS9idXR0b24tc3R5bGUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9iYXNlL3Rvb2xiYXItYnV0dG9ucy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2Uvd2lkZ2V0LWFycm93LWJveC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2Uvd2lkZ2V0LWRyb3Bkb3duLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS93aWRnZXQtZXhjbHVzaXZlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2Jhc2Uvd2lkZ2V0LXBvc2l0aW9uLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tYWNjZXNzaWJpbGl0eS1pbWFnZS1hbHQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tYmFja2dyb3VuZC1jb2xvci5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1ib2xkLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWNhbWVyYS1pbWFnZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1jYW1lcmEuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tY29kZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1jb2xvci5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1jb21tYW5kLWxpc3QtaXRlbS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1jb21tYW5kcy1saXN0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWRyb3Bkb3duLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWVtYmVkLWVkaXQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tZW1iZWQtdmlkZW8tZWRpdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1lbWJlZC12aWRlby5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1lbWJlZC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1oMS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1oMi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1obGluZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1pY29uLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWltYWdlLWFsaWduLWNlbnRlci5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1pbWFnZS1hbGlnbi1sZWZ0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWltYWdlLWFsaWduLXJpZ2h0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWltYWdlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWluZGVudC1ibG9jay5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1pdGFsaWMuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24taXRlbS1zZWxlY3Rvci1hdWRpby5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1pdGVtLXNlbGVjdG9yLWltYWdlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWl0ZW0tc2VsZWN0b3ItdmlkZW8uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tbGluay1hdXRvY29tcGxldGUtbGlzdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1saW5rLWJyb3dzZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1saW5rLWVkaXQtYnJvd3NlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWxpbmstZWRpdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1saW5rLXRhcmdldC1lZGl0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLWxpbmsuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tb2wuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tb3V0ZGVudC1ibG9jay5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1wYXJhZ3JhcGgtYWxpZ24tbGVmdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1wYXJhZ3JhcGgtYWxpZ24tcmlnaHQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcGFyYWdyYXBoLWFsaWduLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXBhcmFncmFwaC1jZW50ZXIuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcGFyYWdyYXBoLWp1c3RpZnkuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcXVvdGUuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tcmVtb3ZlLWZvcm1hdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1yZW1vdmUtaW1hZ2UuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc2VwYXJhdG9yLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXNwYWNpbmcuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3RyaWtlLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN0eWxlcy1saXN0LWhlYWRlci5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1zdHlsZXMtbGlzdC1pdGVtLXJlbW92ZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1zdHlsZXMtbGlzdC1pdGVtLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN0eWxlcy1saXN0LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXN0eWxlcy5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1zdWJzY3JpcHQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tc3VwZXJzY3JpcHQuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tdGFibGUtY2VsbC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS1jb2x1bW4uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tdGFibGUtZWRpdC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS1oZWFkaW5nLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL2J1dHRvbnMvYnV0dG9uLXRhYmxlLXJlbW92ZS5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi10YWJsZS1yb3cuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tdGFibGUuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tdGFyZ2V0LWxpc3QuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9idXR0b24tdHdpdHRlci5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi11bC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi11bmRlcmxpbmUuanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL21haW4uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvdG9vbGJhcnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy90b29sYmFycy90b29sYmFyLWFkZC5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy90b29sYmFycy90b29sYmFyLXN0eWxlcy5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy91aWJyaWRnZS9idXR0b24uanN4Iiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvbXBvbmVudHMvdWlicmlkZ2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy91aWJyaWRnZS9tZW51LWJ1dHRvbi5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy91aWJyaWRnZS9tZW51LmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL3BhbmVsLW1lbnUtYnV0dG9uLmpzeCIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb21wb25lbnRzL3VpYnJpZGdlL3JpY2hjb21iby5qc3giLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29tcG9uZW50cy91aWJyaWRnZS91aWJyaWRnZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb3JlL2RlYm91bmNlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS9saW5rLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvcGx1Z2lucy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb3JlL3NlbGVjdGlvbi1yZWdpb24uanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvY29yZS90YWJsZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9jb3JlL3Rvb2xzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL2NvcmUvdWljb3JlLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL29vcC9hdHRyaWJ1dGUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvb29wL2Jhc2UuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvb29wL2xhbmcuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvb29wL29vcC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL0RyYWdFdmVudC5lcy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL1Jlc2l6ZXIuZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9hZGRpbWFnZXMuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9hdXRvbGluay5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2F1dG9saXN0LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvZHJhZ3Jlc2l6ZS5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2RyYWdyZXNpemVfaWUuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9kcmFncmVzaXplX2llMTEuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9lbWJlZC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL2VtYmVkdXJsLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvaW1hZ2VhbGlnbm1lbnQuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9pbmRleC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL3Bhc3RlaW1hZ2VzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvcGxhY2Vob2xkZXIuanMiLCJ3ZWJwYWNrOi8vQWxsb3lFZGl0b3IvLi9zcmMvcGx1Z2lucy9wcmlvcml0aWVzLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvc2VsZWN0aW9ua2V5c3Ryb2tlcy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9wbHVnaW5zL3RhYmxlcmVzaXplLmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3BsdWdpbnMvdGFibGV0b29scy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9zZWxlY3Rpb25zL3NlbGVjdGlvbi1hcnJvd2JveC5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9zZWxlY3Rpb25zL3NlbGVjdGlvbi1wb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci8uL3NyYy9zZWxlY3Rpb25zL3NlbGVjdGlvbi10ZXN0LmpzIiwid2VicGFjazovL0FsbG95RWRpdG9yLy4vc3JjL3NlbGVjdGlvbnMvc2VsZWN0aW9ucy5qcyIsIndlYnBhY2s6Ly9BbGxveUVkaXRvci9leHRlcm5hbCB7XCJyb290XCI6XCJSZWFjdFwiLFwiY29tbW9uanMyXCI6XCJyZWFjdFwiLFwiY29tbW9uanNcIjpcInJlYWN0XCIsXCJhbWRcIjpcInJlYWN0XCIsXCJ1bWRcIjpcInJlYWN0XCJ9Iiwid2VicGFjazovL0FsbG95RWRpdG9yL2V4dGVybmFsIHtcInJvb3RcIjpcIlJlYWN0RE9NXCIsXCJjb21tb25qczJcIjpcInJlYWN0LWRvbVwiLFwiY29tbW9uanNcIjpcInJlYWN0LWRvbVwiLFwiYW1kXCI6XCJyZWFjdC1kb21cIixcInVtZFwiOlwicmVhY3QtZG9tXCJ9Il0sIm5hbWVzIjpbIkVNQkVEX1ZJREVPX1dJRFRIIiwiRU1CRURfVklERU9fSEVJR0hUIiwiQ29yZSIsImNvbmZpZyIsInN1cGVyY2xhc3MiLCJjb25zdHJ1Y3RvciIsImNhbGwiLCJCYXNlIiwiaW5pdGlhbGl6ZXIiLCJub2RlIiwiZ2V0Iiwic2V0QXR0cmlidXRlIiwiZWRpdG9yIiwiQ0tFRElUT1IiLCJpbmxpbmUiLCJhbGxvd2VkQ29udGVudCIsInRvb2xiYXJzIiwicmVtb3ZlUGx1Z2lucyIsImV4dHJhUGx1Z2lucyIsImVtYmVkUHJvdmlkZXJzIiwicGxhY2Vob2xkZXJDbGFzcyIsInBhc3RlRnJvbVdvcmRSZW1vdmVTdHlsZXMiLCJwYXN0ZUZyb21Xb3JkUmVtb3ZlRm9udFN0eWxlcyIsInNlbGVjdGlvbktleXN0cm9rZXMiLCJzcHJpdGVtYXAiLCJMYW5nIiwibWl4IiwiZW52IiwiaWUiLCJlZGdlIiwicGx1Z2luIiwidmVyc2lvbiIsInJlcGxhY2UiLCJvbmNlIiwiX2FkZFJlYWRPbmx5TGlua0NsaWNrTGlzdGVuZXIiLCJlZGl0YWJsZSIsImV4dHJhQ29tbWFuZHMiLCJleHRyYUNvbW1hbmRLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImkiLCJsZW5ndGgiLCJjb21tYW5kTmFtZSIsImNvbW1hbmRzIiwiYWRkQ29tbWFuZCIsImFkZENsYXNzIiwiYmluZCIsIl9lZGl0b3IiLCJBbGxveUVkaXRvciIsImxvYWRMYW5ndWFnZVJlc291cmNlcyIsIl9yZW5kZXJVSSIsImRlc3RydWN0b3IiLCJfZGVzdHJveWVkIiwiX2VkaXRvclVJRWxlbWVudCIsIlJlYWN0RE9NIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIm5hdGl2ZUVkaXRvciIsInJlbW92ZUNsYXNzIiwiX2NsZWFyU2VsZWN0aW9ucyIsImRlc3Ryb3kiLCJpc01TU2VsZWN0aW9uIiwid2luZG93IiwiZ2V0U2VsZWN0aW9uIiwiZG9jdW1lbnQiLCIkIiwic2VsZWN0aW9uIiwiZW1wdHkiLCJnZXRXaW5kb3ciLCJyZW1vdmVBbGxSYW5nZXMiLCJvbiIsIl9kZWZhdWx0UmVhZE9ubHlDbGlja0ZuIiwiZXZlbnQiLCJtb3VzZUV2ZW50IiwiZGF0YSIsImhhc0N0cmxLZXkiLCJjdHJsS2V5IiwibWV0YUtleSIsInNob3VsZE9wZW4iLCJyZWFkT25seSIsInByZXZlbnREZWZhdWx0IiwibGlzdGVuZXJEYXRhIiwiZmlyZSIsImNrRWxlbWVudCIsImRvbSIsImVsZW1lbnRQYXRoIiwiZ2V0VGFyZ2V0IiwibGluayIsImxhc3RFbGVtZW50IiwiaHJlZiIsImF0dHJpYnV0ZXMiLCJ2YWx1ZSIsInRhcmdldCIsIl9yZWRpcmVjdExpbmsiLCJfZ2V0TmF0aXZlRWRpdG9yIiwib3BlbiIsImxvY2F0aW9uIiwiZWRpdG9yVUlFbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsInVpTm9kZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNhbGxiYWNrUmVmIiwiX21haW5VSSIsImVsZW1lbnQiLCJyZW5kZXIiLCJfdG9FbGVtZW50IiwiaXNTdHJpbmciLCJnZXRFbGVtZW50QnlJZCIsIl92YWxpZGF0ZUFsbG93ZWRDb250ZW50IiwiaXNPYmplY3QiLCJpc0Jvb2xlYW4iLCJfdmFsaWRhdGVUb29sYmFycyIsImlzTnVsbCIsIkFUVFJTIiwidmFsaWRhdG9yIiwid3JpdGVPbmNlIiwiZG9jdW1lbnRCcm93c2VMaW5rQ2FsbGJhY2siLCJpc0Z1bmN0aW9uIiwidW5kZWZpbmVkIiwiZG9jdW1lbnRCcm93c2VMaW5rVXJsIiwiaXNBcnJheSIsImlkIiwidHBsIiwidHlwZSIsInVybFNjaGVtZXMiLCJlbmFibGVDb250ZW50RWRpdGFibGUiLCJldmVudHNEZWxheSIsImlzTnVtYmVyIiwicmVtb3ZlSW1hZ2UiLCJyZW1vdmVJbWFnZUNvbW1hbmQiLCJtb2RlIiwiZ2V0dGVyIiwiQ1RSTCIsIlNISUZUIiwic3JjTm9kZSIsInNldHRlciIsImFkZCIsImJ1dHRvbnMiLCJ0YWJJbmRleCIsInN0eWxlcyIsInNlbGVjdGlvbnMiLCJTZWxlY3Rpb25zIiwiaW1wbGVtZW50T24iLCJFZGl0b3JDb250ZXh0IiwiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidG9Qcm9wcyIsImZvcndhcmRpbmdDb21wb25lbnQiLCJmb3J3YXJkUmVmIiwicHJvcHMiLCJyZWYiLCJjb250ZXh0Iiwia2V5IiwiQ29tcG9uZW50IiwiQlJJREdFX0JVVFRPTlMiLCJpbXBsZW1lbnRFdmVudFRhcmdldCIsImdldEJhc2VQYXRoIiwicGF0aCIsIkFMTE9ZRURJVE9SX0JBU0VQQVRIIiwic2NyaXB0cyIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwibWF0Y2giLCJzcmMiLCJyZWdleEJhc2VQYXRoIiwiaW5kZXhPZiIsInNsaWNlIiwiRXJyb3IiLCJjYWxsYmFjayIsIlN0cmluZ3MiLCJzZXRUaW1lb3V0IiwiX2xhbmdSZXNvdXJjZVJlcXVlc3RlZCIsImxhbmd1YWdlcyIsInVzZXJMYW5ndWFnZSIsIm5hdmlnYXRvciIsImxhbmd1YWdlIiwicGFydHMiLCJ0b0xvd2VyQ2FzZSIsImxhbmciLCJsb2NhbGUiLCJzY3JpcHRMb2FkZXIiLCJsb2FkIiwiZ2V0VXJsIiwibG9hZGVkIiwicmVzb3VyY2UiLCJiYXNlUGF0aCIsInRpbWVzdGFtcCIsImNoYXJBdCIsInRlc3QiLCJnZXRCdXR0b25zIiwicmVkdWNlIiwiYWNjIiwidmFsIiwiY29uY2F0IiwicmVnaXN0ZXJCcmlkZ2VCdXR0b24iLCJidXR0b25OYW1lIiwicGx1Z2luTmFtZSIsInB1c2giLCJPT1AiLCJleHRlbmQiLCJBdHRyaWJ1dGUiLCJCdXR0b25zIiwiU2VsZWN0aW9uR2V0QXJyb3dCb3hDbGFzc2VzIiwiU2VsZWN0aW9uU2V0UG9zaXRpb24iLCJTZWxlY3Rpb25UZXN0IiwiVG9vbGJhcnMiLCJleGVjIiwicmFuZ2VzIiwiZ2V0UmFuZ2VzIiwic3RhcnRDb250YWluZXIiLCJuZXh0UmFuZ2UiLCJyYW5nZSIsInNldFN0YXJ0Iiwic2V0RW5kIiwic2VsZWN0ZWRFbGVtZW50IiwiZ2V0U2VsZWN0ZWRFbGVtZW50IiwiZ2V0TmFtZSIsIm5hdGl2ZSIsImdldE5hdGl2ZSIsInNlbGVjdFJhbmdlcyIsInJlbW92ZSIsImFwcGx5U3R5bGUiLCJpc0FjdGl2ZSIsImdldFN0eWxlIiwibG9jayIsInJlbW92ZVN0eWxlIiwidW5sb2NrIiwiV3JhcHBlZENvbXBvbmVudCIsImNvbnRleHRUeXBlIiwiY29tbWFuZCIsImdldENvbW1hbmQiLCJzdGF0ZSIsIlRSSVNUQVRFX09OIiwiZXhlY0NvbW1hbmQiLCJtb2RpZmllc1NlbGVjdGlvbiIsInNlbGVjdGlvbkNoYW5nZSIsImtleXN0cm9rZSIsIm5hbWUiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJrZXlzdHJva2VGbiIsImZuIiwiX2RlZmF1bHRLZXlzdHJva2VDb21tYW5kIiwia2V5c3Ryb2tlSGFuZGxlciIsImtleXN0cm9rZXMiLCJzZXRLZXlzdHJva2UiLCJidXR0b25DZmciLCJ0b29scyIsIm1lcmdlIiwic3RhdGVDbGFzc2VzIiwiaXNEaXNhYmxlZCIsInN0eWxlIiwic3BsaXQiLCJjdXJyZW50TWVtYmVyIiwicHJvcGVydHkiLCJzaGlmdCIsIl9zdHlsZSIsImNoZWNrQWN0aXZlIiwiYWRkaXRpb25hbFByb3BzIiwibGlzdCIsImJ1dHRvbiIsIkFycmF5IiwiZ2V0VG9vbGJhckJ1dHRvbnMiLCJidXR0b25Qcm9wcyIsInRvb2xiYXJCdXR0b25zIiwiZmlsdGVyRXhjbHVzaXZlIiwiZmlsdGVyIiwibWFwIiwiY2ZnIiwiaW5kZXgiLCJtZXJnZUV4Y2x1c2l2ZVByb3BzIiwidGFiS2V5IiwidHJpZ2dlciIsIm1lcmdlRHJvcGRvd25Qcm9wcyIsImFycm93Qm94Q2xhc3NlcyIsImdldEludGVyYWN0aW9uUG9pbnQiLCJkaXJlY3Rpb24iLCJTRUxFQ1RJT05fVE9QX1RPX0JPVFRPTSIsIm9iaiIsIml0ZW1LZXkiLCJleHBhbmRlZCIsIml0ZW1Ecm9wZG93biIsImRyb3Bkb3duVHJpZ2dlciIsInRvZ2dsZURyb3Bkb3duIiwidG9nZ2xlRGlyZWN0aW9uIiwic2V0U3RhdGUiLCJtb3ZlRm9jdXMiLCJmaW5kRE9NTm9kZSIsImZvY3VzIiwibmV4dFByb3BzIiwicmVxdWVzdEV4Y2x1c2l2ZSIsIml0ZW1FeGNsdXNpdmUiLCJpdGVtcyIsIml0ZW0iLCJjYW5jZWxFeGNsdXNpdmUiLCJyZW5kZXJFeGNsdXNpdmUiLCJESVJFQ1RJT05fTk9ORSIsIkRJUkVDVElPTl9ORVhUIiwiRElSRUNUSU9OX1BSRVYiLCJBQ1RJT05fTk9ORSIsIkFDVElPTl9NT1ZFX0ZPQ1VTIiwiQUNUSU9OX0RJU01JU1NfRk9DVVMiLCJfaXNWYWxpZFRhcmdldCIsIl9kZXNjZW5kYW50cyIsImFjdGl2ZURlc2NlbmRhbnRFbCIsIl9hY3RpdmVEZXNjZW5kYW50IiwiYWN0aXZlRWxlbWVudCIsImZvY3VzRmlyc3RDaGlsZCIsInN0b3BQcm9wYWdhdGlvbiIsImhhbmRsZUtleSIsImFjdGlvbiIsIl9nZXRGb2N1c0FjdGlvbiIsIl9tb3ZlRm9jdXMiLCJvbkRpc21pc3MiLCJfcmVmcmVzaCIsIl9nZXRGb2N1c01vdmVEaXJlY3Rpb24iLCJkaXNtaXNzQWN0aW9uIiwiX2dldEZvY3VzRGlzbWlzc0FjdGlvbiIsImRpc21pc3MiLCJmb2N1c01vdmVEaXJlY3Rpb24iLCJfaXNWYWxpZEtleSIsImtleUNvZGUiLCJkaXNtaXNzTmV4dCIsImRpc21pc3NQcmV2IiwiY2lyY3VsYXIiLCJuZXh0IiwicHJldiIsInNoaWZLZXkiLCJ0YWdOYW1lIiwibnVtRGVzY2VuZGFudHMiLCJkZXNjZW5kYW50IiwibWF4IiwibWluIiwiZG9tTm9kZSIsImRlc2NlbmRhbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsInByaW9yaXR5RGVzY2VuZGFudHMiLCJwcm90b3R5cGUiLCJmb3JFYWNoIiwiZGF0YVRhYkluZGV4IiwiZ2V0QXR0cmlidXRlIiwic29ydCIsImEiLCJiIiwidG9JbnQiLCJzb21lIiwiX2FuaW1hdGlvbkZyYW1lSWQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImF0dHJzIiwidmlld1BhbmVTaXplIiwiZ2V0Vmlld1BhbmVTaXplIiwieCIsImxlZnQiLCJ5IiwidG9wIiwid2lkdGgiLCJldmVudFBheWxvYWQiLCJlZGl0b3JFdmVudCIsInNlbGVjdGlvbkRhdGEiLCJuYXRpdmVFdmVudCIsInBvcyIsInBhZ2VYIiwicmVnaW9uIiwiZW5kUmVjdCIsInN0YXJ0UmVjdCIsIlNFTEVDVElPTl9CT1RUT01fVE9fVE9QIiwiX2dldFhQb2ludCIsIl9nZXRZUG9pbnQiLCJldmVudFgiLCJyaWdodCIsImxlZnREaXN0IiwiYWJzIiwicmlnaHREaXN0IiwiZWxlbWVudFRhcmdldCIsIm9mZnNldFRvcCIsIm9mZnNldEhlaWdodCIsImJvdHRvbSIsImd1dHRlciIsIm9mZnNldFdpZHRoIiwiU0VMRUNUSU9OX0xFRlRfVE9fUklHSFQiLCJTRUxFQ1RJT05fUklHSFRfVE9fTEVGVCIsImRvbUVsZW1lbnQiLCJoYXNDbGFzcyIsInN0YXJ0UG9pbnQiLCJlbmRQb2ludCIsInNldFN0eWxlcyIsIm9wYWNpdHkiLCJwb2ludGVyRXZlbnRzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwic2Nyb2xsVG9wIiwiaXNWaXNpYmxlIiwiaW50ZXJhY3Rpb25Qb2ludCIsImZpbmFsWCIsImZpbmFsWSIsImluaXRpYWxYIiwiaW5pdGlhbFkiLCJwYXJzZUZsb2F0IiwiY29uc3RyYWluVG9WaWV3cG9ydCIsInJlcyIsImdldENvbnN0cmFpbmVkUG9zaXRpb24iLCJoZWlnaHQiLCJtb3ZlVG9Qb2ludCIsInVpTm9kZVN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInVpTm9kZU1hcmdpbkxlZnQiLCJwYXJzZUludCIsImdldFByb3BlcnR5VmFsdWUiLCJ1aU5vZGVNYXJnaW5SaWdodCIsInRvdGFsV2lkdGgiLCJjbGllbnRXaWR0aCIsInh5IiwiZ2V0V2lkZ2V0WFlQb2ludCIsImRlZmF1bHRQcm9wcyIsIkJ1dHRvbkFjY2Vzc2liaWxpdHlJbWFnZUFsdCIsImltYWdlQWx0IiwiY3NzQ2xhc3MiLCJnZXRTdGF0ZUNsYXNzZXMiLCJfaGFuZGxlQWx0Q2hhbmdlIiwiX2hhbmRsZUtleURvd24iLCJjb25maXJtIiwiX3VwZGF0ZUltYWdlQWx0IiwiX3JlcXVlc3RFeGNsdXNpdmUiLCJpbnN0YW5jZSIsImZvY3VzQWx0RWwiLCJyZWZzIiwicmVmQWx0SW5wdXQiLCJfZm9jdXNBbHRJbnB1dCIsIkJ1dHRvbkJhY2tncm91bmRDb2xvciIsImFjdGl2ZUNvbG9yIiwibm9ybWFsIiwiYWN0aXZlQ29sb3JDbGFzcyIsImNvbG9ycyIsIl9nZXRDb2xvcnMiLCJpdGVtU3R5bGUiLCJjbGFzcyIsInN0eWxlQ2xhc3MiLCJfY2hlY2tBY3RpdmUiLCJidXR0b25TdHlsZXNQcm9wcyIsImFjdGl2ZVN0eWxlIiwic2hvd1JlbW92ZVN0eWxlc0l0ZW0iLCJzdHlsZUNvbmZpZyIsInN0eWxlRm4iLCJfYXBwbHlTdHlsZSIsInByaW1hcnkiLCJkaXNhYmxlZCIsInN1Y2Nlc3MiLCJkYW5nZXIiLCJ3YXJuaW5nIiwiaW5mbyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsImJvb2wiLCJsYWJlbCIsInN0cmluZyIsImFycmF5T2YiLCJvYmplY3QiLCJudW1iZXIiLCJmdW5jIiwiQnV0dG9uQm9sZCIsImJvbGQiLCJCdXR0b25DYW1lcmFJbWFnZSIsInRha2VQaG90byIsInZpZGVvRWwiLCJfdmlkZW9Db250YWluZXJSZWYiLCJjdXJyZW50IiwiY2FudmFzRWwiLCJfY2FudmFzQ29udGFpbmVyUmVmIiwiZ2V0Q29udGV4dCIsIl92aWRlb0hlaWdodCIsInZpZGVvV2lkdGgiLCJkcmF3SW1hZ2UiLCJpbWdVUkwiLCJ0b0RhdGFVUkwiLCJlbCIsImNyZWF0ZUZyb21IdG1sIiwiaW5zZXJ0RWxlbWVudCIsIl9oYW5kbGVTdHJlYW1FcnJvciIsImFsZXJ0IiwiZXJyb3IiLCJfaGFuZGxlU3RyZWFtU3VjY2VzcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJ2aWRlb0hlaWdodCIsImlzTmFOIiwiX3N0cmVhbSIsInN0cmVhbSIsIm1vekdldFVzZXJNZWRpYSIsIm1velNyY09iamVjdCIsInNyY09iamVjdCIsInBsYXkiLCJfYnV0dG9uVGFrZVBob3RvUmVmIiwiY3JlYXRlUmVmIiwic3RvcCIsImdldFZpZGVvVHJhY2tzIiwidHJhY2siLCJnZXRVc2VyTWVkaWEiLCJ3ZWJraXRHZXRVc2VyTWVkaWEiLCJtc0dldFVzZXJNZWRpYSIsInZpZGVvIiwiYXVkaW8iLCJCdXR0b25DYW1lcmEiLCJwcm90b2NvbCIsImNhbWVyYURpc2FibGVkIiwiY2FtZXJhIiwiQnV0dG9uQ29kZSIsImNvZGUiLCJCdXR0b25Db2xvciIsImRhcmsiLCJkYXJrR3JheSIsInNlY29uZGFyeSIsImxpZ2h0IiwibGlnaHRlciIsIndoaXRlIiwiQnV0dG9uQ29tbWFuZExpc3RJdGVtIiwiZGVzY3JpcHRpb24iLCJfZ2V0Q2xhc3NOYW1lIiwiQnV0dG9uQ29tbWFuZHNMaXN0IiwiX3JlZiIsImxpc3RJZCIsIl9yZW5kZXJBY3Rpb25zIiwiaWNvbiIsIkJ1dHRvbkRyb3Bkb3duIiwiY2hpbGRyZW4iLCJLRVlfRU5URVIiLCJLRVlfRVNDIiwiQnV0dG9uRW1iZWRFZGl0IiwiX2NsZWFyTGluayIsImxpbmtIcmVmIiwiX2VtYmVkTGluayIsInVybCIsIl9mb2N1c0xpbmtJbnB1dCIsImxpbmtJbnB1dCIsIl9oYW5kbGVMaW5rSHJlZkNoYW5nZSIsIl9yZW1vdmVFbWJlZCIsImVtYmVkV3JhcHBlciIsImdldEFzY2VuZGFudCIsImdldEluaXRpYWxTdGF0ZSIsIm1hbnVhbFNlbGVjdGlvbiIsImVtYmVkIiwiZmluZE9uZSIsImluaXRpYWxMaW5rIiwiY2xlYXJMaW5rU3R5bGUiLCJkZWxldGVFbWJlZCIsImVkaXRMaW5rIiwiY2xlYXJJbnB1dCIsImNsZWFyIiwiX2lzVmFsaWRTdGF0ZSIsInZhbGlkU3RhdGUiLCJCdXR0b25FbWJlZFZpZGVvRWRpdCIsIl9lbWJlZFZpZGVvVVJMIiwidmlkZW9VUkwiLCJfZm9jdXNWaWRlb1VybElucHV0IiwiX2hhbmRsZVZpZGVvVVJMQ2hhbmdlIiwibmV3U3RhdGUiLCJhbGwiLCJuZXciLCJvbGQiLCJpbml0aWFsRW1iZWQiLCJpbnB1dFBsYWNlaG9sZGVyIiwicGFzdGVWaWRlb0xpbmsiLCJjbGVhclZpZGVvVVJMU3R5bGUiLCJCdXR0b25FbWJlZFZpZGVvIiwiQnV0dG9uRW1iZWQiLCJCdXR0b25IMSIsImgxIiwiQnV0dG9uSDIiLCJoMiIsIkJ1dHRvbkhsaW5lIiwiaG9yaXpvbnRhbHJ1bGUiLCJCdXR0b25JY29uIiwic3ltYm9sIiwiY2xhc3NOYW1lUHJlZml4IiwiY29tYmluZWRDbGFzc05hbWUiLCJCdXR0b25JbWFnZUFsaWduQ2VudGVyIiwiYWxpZ25DZW50ZXIiLCJCdXR0b25JbWFnZUFsaWduTGVmdCIsImFsaWduTGVmdCIsIkJ1dHRvbkltYWdlQWxpZ25SaWdodCIsImFsaWduUmlnaHQiLCJCdXR0b25JbWFnZSIsImhhbmRsZUNsaWNrIiwiZmlsZUlucHV0IiwiY2xpY2siLCJfb25JbnB1dENoYW5nZSIsImlucHV0RWwiLCJmaWxlcyIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJmaWxlIiwib25sb2FkIiwicmVzdWx0IiwiaW1hZ2VGaWxlcyIsImltYWdlRGF0YSIsInJlYWRBc0RhdGFVUkwiLCJpbnB1dFN5bGUiLCJkaXNwbGF5IiwiaW1hZ2UiLCJCdXR0b25JbmRlbnRCbG9jayIsImluZGVudCIsIkJ1dHRvbkl0YWxpYyIsIml0YWxpYyIsIkJ1dHRvbkl0ZW1TZWxlY3RvckF1ZGlvIiwiX2hhbmRsZUNsaWNrIiwiQnV0dG9uSXRlbVNlbGVjdG9ySW1hZ2UiLCJCdXR0b25JdGVtU2VsZWN0b3JWaWRlbyIsIkJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0IiwidGVybSIsImNsZWFyVGltZW91dCIsIl90aW1lb3V0IiwiX3VwZGF0ZUl0ZW1zIiwiZGVsYXkiLCJhdXRvY29tcGxldGVTZWxlY3RlZCIsInNldEF1dG9jb21wbGV0ZVN0YXRlIiwic2VsZWN0ZWQiLCJfcmVuZGVyQXV0b2NvbXBsZXRlSXRlbXMiLCJuZXh0U3RhdGUiLCJoYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2siLCJ0aXRsZSIsInByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJCdXR0b25MaW5rQnJvd3NlIiwibWVyZ2VCdXR0b25DZmdQcm9wcyIsIkJ1dHRvbkxpbmtFZGl0QnJvd3NlIiwiX2Jyb3dzZUNsaWNrIiwiYnJvd3NlTGlua0NhbGxiYWNrIiwibGlua1RhcmdldCIsImxpbmtFZGl0QnV0dG9uUmVmIiwiY2hhbmdlTGlua0NhbGxiYWNrIiwiX3VwZGF0ZUxpbmsiLCJzZWxlY3RlZEl0ZW0iLCJhcHBseSIsImxpbmtUaXRsZSIsImxpbmtVdGlscyIsIkxpbmsiLCJhcHBlbmRQcm90b2NvbCIsImxpbmtBdHRycyIsIm1vZGlmeVNlbGVjdGlvbiIsImFkdmFuY2UiLCJwbHVnaW5zIiwiY3Jlb2xlIiwib3JpZ2luIiwidXBkYXRlIiwiY3JlYXRlIiwiZ2V0RnJvbVNlbGVjdGlvbiIsIkJ1dHRvbkxpbmtFZGl0IiwiYWR2YW5jZVNlbGVjdGlvbiIsIl9oYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlIiwiX3JlbW92ZUxpbmsiLCJib29rbWFya3MiLCJjcmVhdGVCb29rbWFya3MiLCJzZWxlY3RCb29rbWFya3MiLCJfZ2V0SW5pdGlhbFN0YXRlIiwidGFyZ2V0U2VsZWN0b3IiLCJhbGxvd2VkVGFyZ2V0cyIsImhhbmRsZUxpbmtUYXJnZXRDaGFuZ2UiLCJzZWxlY3RlZFRhcmdldCIsImxpbmtUYXJnZXREZWZhdWx0IiwiQnV0dG9uTGlua1RhcmdldEVkaXQiLCJhdXRvY29tcGxldGVEcm9wZG93biIsImRhdGFGbiIsImF1dG9jb21wbGV0ZURyb3Bkb3duUHJvcHMiLCJfaGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrIiwiX3NldEF1dG9jb21wbGV0ZVN0YXRlIiwiYnV0dG9uQ2xlYXJMaW5rIiwicGxhY2Vob2xkZXJQcm9wIiwicGxhY2Vob2xkZXIiLCJyZW1vdmVMaW5rIiwic2hvd1RhcmdldFNlbGVjdG9yIiwiZGVmYXVsdExpbmtUYXJnZXQiLCJmb2N1c0xpbmtFbCIsImF1dG9jb21wbGV0ZVVybCIsImN1c3RvbUluZGV4U3RhcnQiLCJhbGxvd2VkTGlua1RhcmdldHMiLCJCdXR0b25MaW5rIiwiQnV0dG9uT3JkZXJlZExpc3QiLCJudW1iZXJlZGxpc3QiLCJCdXR0b25PdXRkZW50QmxvY2siLCJvdXRkZW50IiwiQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0IiwiQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodCIsIkJ1dHRvblBhcmFncmFwaEFsaWduIiwiYnV0dG9uQ29tbWFuZHNMaXN0IiwiYnV0dG9uQ29tbWFuZHNMaXN0SWQiLCJfZ2V0Q29tbWFuZHMiLCJhY3RpdmVDb21tYW5kIiwiYWxpZ25tZW50IiwicG9wIiwiaWNvbkNsYXNzTmFtZSIsInJvdyIsImFsaWduSnVzdGlmeSIsIkJ1dHRvblBhcmFncmFwaENlbnRlciIsIkJ1dHRvblBhcmFncmFwaEp1c3RpZnkiLCJCdXR0b25RdW90ZSIsInF1b3RlIiwiQnV0dG9uUmVtb3ZlRm9ybWF0IiwicmVtb3ZlZm9ybWF0IiwiQnV0dG9uUmVtb3ZlSW1hZ2UiLCJCdXR0b25TZXBhcmF0b3IiLCJfcHJvcHMiLCJCdXR0b25TcGFjaW5nIiwiYWN0aXZlU3BhY2luZyIsInNwYWNpbmdzIiwiX2dldFNwYWNpbmdzIiwiYWN0aXZlIiwiQnV0dG9uU3RyaWtlIiwic3RyaWtlIiwiQnV0dG9uc1N0eWxlc0xpc3RIZWFkZXIiLCJCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZSIsIl9yZW1vdmVTdHlsZXMiLCJyZW1vdmVCbG9ja3MiLCJibG9ja0l0ZW0iLCJibG9ja1N0eWxlIiwiQnV0dG9uU3R5bGVzTGlzdEl0ZW0iLCJfb25DbGljayIsInN0eWxlQ2ZnIiwibWFyZ2luIiwiX3ByZXZpZXciLCJidWlsZFByZXZpZXciLCJfX2h0bWwiLCJCdXR0b25TdHlsZXNMaXN0IiwiYmxvY2tTdHlsZXMiLCJpbmxpbmVTdHlsZXMiLCJvYmplY3RTdHlsZXMiLCJTVFlMRV9CTE9DSyIsIlNUWUxFX0lOTElORSIsIlNUWUxFX09CSkVDVCIsIl9ibG9ja1N0eWxlcyIsIl9pbmxpbmVTdHlsZXMiLCJfb2JqZWN0U3R5bGVzIiwicmVtb3ZlU3R5bGVzSXRlbSIsIl9yZW5kZXJTdHlsZXNJdGVtcyIsIkJ1dHRvblN0eWxlcyIsIl9nZXRTdHlsZXMiLCJidXR0b25TdHlsZXNMaXN0IiwiZm9ybWF0dGVkIiwiY2l0ZSIsIkJ1dHRvblN1YnNjcmlwdCIsInN1YnNjcmlwdCIsIkJ1dHRvblN1cGVyc2NyaXB0Iiwic3VwZXJzY3JpcHQiLCJCdXR0b25UYWJsZUNlbGwiLCJjZWxsIiwiY2VsbEluc2VydEJlZm9yZSIsImNlbGxJbnNlcnRBZnRlciIsImNlbGxEZWxldGUiLCJjZWxsTWVyZ2UiLCJjZWxsTWVyZ2VEb3duIiwiY2VsbE1lcmdlUmlnaHQiLCJjZWxsU3BsaXRIb3Jpem9udGFsIiwiY2VsbFNwbGl0VmVydGljYWwiLCJCdXR0b25UYWJsZUNvbHVtbiIsImNvbHVtbiIsImNvbHVtbkluc2VydEJlZm9yZSIsImNvbHVtbkluc2VydEFmdGVyIiwiY29sdW1uRGVsZXRlIiwiQnV0dG9uVGFibGVFZGl0IiwiX2NyZWF0ZVRhYmxlIiwidGFibGVVdGlscyIsIlRhYmxlIiwidGFibGVBdHRyaWJ1dGVzIiwiY29scyIsInJvd3MiLCJfaGFuZGxlQ2hhbmdlIiwiaW5wdXROYW1lIiwicm93c1JlZiIsImNvbHNSZWYiLCJ0aW1lIiwiRGF0ZSIsIm5vdyIsInJvd3NJZCIsImNvbHNJZCIsImNvbHVtbnMiLCJib3JkZXIiLCJjZWxsUGFkZGluZyIsImNlbGxTcGFjaW5nIiwiQnV0dG9uVGFibGVIZWFkaW5nIiwiYWN0aXZlSGVhZGluZyIsImdldEhlYWRpbmciLCJhY3RpdmVIZWFkaW5nSW50cm8iLCJoZWFkZXJzIiwiYWN0aXZlSGVhZGluZ0xhYmVsIiwiaGVhZGVyc05vbmUiLCJoZWFkZXJzUm93IiwiaGVhZGVyc0NvbHVtbiIsImhlYWRlcnNCb3RoIiwiQnV0dG9uVGFibGVSZW1vdmUiLCJfcmVtb3ZlVGFibGUiLCJkZWxldGVUYWJsZSIsIkJ1dHRvblRhYmxlUm93Iiwicm93SW5zZXJ0QmVmb3JlIiwicm93SW5zZXJ0QWZ0ZXIiLCJyb3dEZWxldGUiLCJCdXR0b25UYWJsZSIsInRhYmxlIiwiQnV0dG9uVGFyZ2V0TGlzdCIsImxpc3RUYXJnZXRzIiwiX3JlbmRlckxpc3RUYXJnZXRzIiwibGlua1RhcmdldFNlbGYiLCJsaW5rVGFyZ2V0QmxhbmsiLCJsaW5rVGFyZ2V0UGFyZW50IiwibGlua1RhcmdldFRvcCIsInRhcmdldHMiLCJfZ2V0QWxsb3dlZFRhcmdldEl0ZW1zIiwiTUFYX1RXRUVUX0xFTkdUSCIsIkJ1dHRvblR3aXR0ZXIiLCJfZ2V0SHJlZiIsInR3aXR0ZXIiLCJzZWxlY3RlZFRleHQiLCJnZXRTZWxlY3RlZFRleHQiLCJzdWJzdHJpbmciLCJ2aWEiLCJ0d2l0dGVySHJlZiIsIkJ1dHRvblVub3JkZXJlZGxpc3QiLCJidWxsZXRlZGxpc3QiLCJCdXR0b25VbmRlcmxpbmUiLCJ1bmRlcmxpbmUiLCJCdXR0b25PbCIsIkJ1dHRvblN0eWxlc0xpc3RIZWFkZXIiLCJCdXR0b25VbCIsIlVJIiwiX29uRGlzbWlzc1Rvb2xiYXJGb2N1cyIsImhpZGRlbiIsIl9vbkVkaXRvckludGVyYWN0aW9uIiwiX29uQWN0aW9uUGVyZm9ybWVkIiwiX29uRWRpdG9yS2V5IiwiX21vdXNlZG93bkxpc3RlbmVyIiwiX3NldFVJSGlkZGVuIiwiX2tleURvd25MaXN0ZW5lciIsImRlYm91bmNlIiwicHJldlByb3BzIiwicHJldlN0YXRlIiwibWVzc2FnZSIsIl9nZXRBdmFpbGFibGVUb29sYmFyc01lc3NhZ2UiLCJhcmlhVXBkYXRlIiwiX2FyaWFVcGRhdGVUZW1wbGF0ZXMiLCJ0ZW1wbGF0ZSIsIl9nZXRBcmlhVXBkYXRlcyIsImFyaWFVcGRhdGVzIiwibm9Ub29sYmFyIiwiYXJpYVVwZGF0ZU5vVG9vbGJhciIsIm9uZVRvb2xiYXIiLCJhcmlhVXBkYXRlT25lVG9vbGJhciIsIm1hbnlUb29sYmFycyIsImFyaWFVcGRhdGVNYW55VG9vbGJhcnMiLCJ0b29sYmFyc05vZGVMaXN0IiwidG9vbGJhck5hbWVzIiwidG9vbGJhciIsIl9nZXRBcmlhVXBkYXRlVGVtcGxhdGUiLCJvdXRwdXQiLCJqb2luIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRldGFjaCIsIl9ldmVudCIsImdldFNlbGVjdGlvbkRhdGEiLCJkb21FdmVudCIsImFsdEtleSIsInRhcmdldE5vZGUiLCJjb250YWlucyIsImlzUmVxdWlyZWQiLCJUb29sYmFyQWRkIiwiVG9vbGJhclN0eWxlcyIsIlBPU0lUSU9OX0xFRlQiLCJQT1NJVElPTl9SSUdIVCIsIl91cGRhdGVQb3NpdGlvbiIsIl9wcmV2UHJvcHMiLCJfcHJldlN0YXRlIiwiaXNDb250ZW50RWRpdGFibGUiLCJfZ2V0QnV0dG9ucyIsIl9nZXRUb29sYmFyQ2xhc3NOYW1lIiwiZ2V0QXJyb3dCb3hDbGFzc2VzIiwidXBkYXRlUG9zaXRpb24iLCJzaG93IiwiY2xpZW50UmVjdCIsImdldENsaWVudFJlY3QiLCJvZmZzZXRMZWZ0IiwicG9zaXRpb24iLCJndXR0ZXJFeGNsdXNpdmUiLCJmbG9vciIsImNhbmNlbEFuaW1hdGlvbiIsImN1cnJlbnRTZWxlY3Rpb24iLCJfZ2V0Q3VycmVudFNlbGVjdGlvbiIsImdldEFycm93Qm94Q2xhc3Nlc0ZuIiwiX2dldFNlbGVjdGlvbkZ1bmN0aW9uIiwiY3NzQ2xhc3NlcyIsImJ1dHRvbnNHcm91cCIsImdldFRvb2xiYXJCdXR0b25Hcm91cHMiLCJzZWxlY3Rpb25UeXBlIiwiaGFzR3JvdXBzIiwic2VsZWN0aW9uRm4iLCJzZWxlY3Rpb25GdW5jdGlvbiIsInRlc3RGbiIsInNldFBvc2l0aW9uRm4iLCJzZXRQb3NpdGlvbiIsIkJVVFRPTl9ERUZTIiwiZ2VuZXJhdGVCdXR0b25CcmlkZ2UiLCJidXR0b25EZWZpbml0aW9uIiwiQnV0dG9uQnJpZGdlIiwiYnV0dG9uQ29tbWFuZCIsImJ1dHRvbk9uQ2xpY2siLCJvbkNsaWNrIiwiYnV0dG9uQ2xhc3NOYW1lIiwiYnV0dG9uRGlzcGxheU5hbWUiLCJidXR0b25MYWJlbCIsImJ1dHRvblR5cGUiLCJpY29uU3R5bGUiLCJjc3NTdHlsZSIsInNraW4iLCJnZXRJY29uU3R5bGUiLCJjc3NTdHlsZVBhcnRzIiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZFNpemUiLCJkaXNwbGF5TmFtZSIsIlVJX0JVVFRPTiIsInJlcXVpcmVzIiwiYmVmb3JlSW5pdCIsInVpIiwiYWRkQnV0dG9uIiwiYWRkSGFuZGxlciIsIk1FTlVCVVRUT05fREVGUyIsImdlbmVyYXRlTWVudUJ1dHRvbkJyaWRnZSIsIm1lbnVCdXR0b25OYW1lIiwibWVudUJ1dHRvbkRlZmluaXRpb24iLCJNZW51QnV0dG9uQnJpZGdlIiwicGFuZWxNZW51QnV0dG9uRGlzcGxheU5hbWUiLCJfZ2V0TWVudUl0ZW1zIiwib25NZW51IiwibWVudUl0ZW1zIiwibWVudUl0ZW0iLCJnZXRNZW51SXRlbSIsIm1lbnVJdGVtRGVmaW5pdGlvbiIsImRlZmluaXRpb24iLCJtZW51SXRlbVN0YXRlIiwiVFJJU1RBVEVfRElTQUJMRUQiLCJVSV9NRU5VX0JVVFRPTiIsImFkZE1lbnVCdXR0b24iLCJVSV9NRU5VQlVUVE9OIiwiZ3JvdXBzIiwiZ3JvdXBzT3JkZXIiLCJfIiwibWVudUdyb3VwcyIsImFkZE1lbnVHcm91cCIsIm9yZGVyIiwiYWRkTWVudUl0ZW0iLCJncm91cCIsImFkZE1lbnVJdGVtcyIsImRlZmluaXRpb25zIiwiaXRlbU5hbWUiLCJoYXNPd25Qcm9wZXJ0eSIsInJlbW92ZU1lbnVJdGVtIiwiUEFORUxfTUVOVV9ERUZTIiwiZ2VuZXJhdGVQYW5lbE1lbnVCdXR0b25CcmlkZ2UiLCJwYW5lbE1lbnVCdXR0b25OYW1lIiwicGFuZWxNZW51QnV0dG9uRGVmaW5pdGlvbiIsIlBhbmVsTWVudUJ1dHRvbkJyaWRnZSIsInBhbmVsIiwiX2dldFBhbmVsIiwicGFuZWxNZW51QnV0dG9uT25CbG9jayIsIm9uQmxvY2siLCJoaWRlIiwiYmxvY2tFbGVtZW50IiwiYmxvY2siLCJnZXRIdG1sIiwiVUlfUEFORUxCVVRUT04iLCJhZGRQYW5lbE1lbnVCdXR0b24iLCJSSUNIX0NPTUJPX0RFRlMiLCJnZW5lcmF0ZVJpY2hDb21ib0JyaWRnZSIsInJpY2hDb21ib05hbWUiLCJyaWNoQ29tYm9EZWZpbml0aW9uIiwiUmljaENvbWJvQnJpZGdlIiwiY3VycmVudFZhbHVlIiwiZWRpdG9yQ29tYm8iLCJuZXdWYWx1ZSIsImN1cnJlbnRUYXJnZXQiLCJwcmV2aWV3IiwiX2l0ZW1zIiwic2V0VmFsdWUiLCJfc2V0VmFsdWUiLCJpbml0Iiwib25SZW5kZXIiLCJfY2FjaGVWYWx1ZSIsInJpY2hDb21ib0xhYmVsIiwiX2dldEl0ZW1zIiwicmljaENvbWJvIiwiVUlfUklDSENPTUJPIiwiYWRkUmljaENvbWJvIiwib3JpZ2luYWxVSUFkZEZuIiwidHlwZUhhbmRsZXIiLCJoYW5kbGVycyIsIl9fcHJvY2Vzc2luZ1BsdWdpbl9fIiwidGltZW91dCIsImFyZ3MiLCJkZWJvdW5jZUhhbmRsZSIsImNhbGxGbiIsImNhbGxBcmdzIiwiY2FsbENvbnRleHQiLCJSRUdFWF9CT09LTUFSS19TQ0hFTUUiLCJSRUdFWF9FTUFJTF9TQ0hFTUUiLCJSRUdFWF9VUklfU0NIRU1FIiwibW92ZVRvRWxlbWVudEVkaXRFbmQiLCJuZXh0Tm9kZSIsImdldE5leHRFZGl0YWJsZU5vZGUiLCJlcXVhbHMiLCJnZXRDb21tb25BbmNlc3RvciIsIndoaXRlc3BhY2UiLCJnZXRUZXh0Iiwib2Zmc2V0IiwiVVJJIiwiY29sbGFwc2VkIiwidGV4dCIsImluc2VydE5vZGUiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJfZ2V0Q29tcGxldGVVUkkiLCJhcHBseVRvUmFuZ2UiLCJzZWxlY3QiLCJpcyIsImdldENoaWxkcmVuIiwiY291bnQiLCJnZXRJdGVtIiwic2hyaW5rIiwiU0hSSU5LX1RFWFQiLCJhbHdheXNSZW1vdmVFbGVtZW50Iiwic2VsZWN0RWxlbWVudCIsImdldFN0YXJ0RWxlbWVudCIsInVyaSIsInNldEF0dHJpYnV0ZXMiLCJyZW1vdmVBdHRycyIsInNldEF0dHJzIiwicmVtb3ZlQXR0cmlidXRlcyIsIndyYXBQbHVnaW5MaWZlY3ljbGUiLCJtZXRob2RzIiwibWV0aG9kTmFtZSIsIm92ZXJyaWRlIiwib3JpZ2luYWxQbHVnaW5NZXRob2QiLCJwYXlsb2FkIiwicGhhc2UiLCJmaWx0ZXJVbndhbnRlZERlcGVuZGVuY2llcyIsInJlcXVpcmUiLCJwbHVnaW5zTG9hZCIsIm5hbWVzIiwic2NvcGUiLCJTZWxlY3Rpb25SZWdpb24iLCJjcmVhdGVTZWxlY3Rpb25Gcm9tUG9pbnQiLCJjcmVhdGVTZWxlY3Rpb25Gcm9tUmFuZ2UiLCJzdGFydFgiLCJzdGFydFkiLCJlbmRYIiwiZW5kWSIsImVuZCIsImVuZENvbnRhaW5lciIsImVuZE9mZnNldCIsInN0YXJ0Iiwic3RhcnRPZmZzZXQiLCJjYXJldFBvc2l0aW9uRnJvbVBvaW50Iiwib2Zmc2V0Tm9kZSIsImNyZWF0ZVJhbmdlIiwiY2FyZXRSYW5nZUZyb21Qb2ludCIsImNyZWF0ZVRleHRSYW5nZSIsImVuZFJhbmdlIiwiZHVwbGljYXRlIiwic2V0RW5kUG9pbnQiLCJnZXRDYXJldFJlZ2lvbiIsImJvb2ttYXJrTm9kZUVsIiwic3RhcnROb2RlIiwic2Nyb2xsUG9zIiwiZ2V0U2Nyb2xsUG9zaXRpb24iLCJnZXRTZWxlY3Rpb25SZWdpb24iLCJnZXRDbGllbnRSZWN0c1JlZ2lvbiIsImdldFNlbGVjdGlvbkRpcmVjdGlvbiIsImlzU2VsZWN0aW9uRW1wdHkiLCJnZXRUeXBlIiwiU0VMRUNUSU9OX05PTkUiLCJuYXRpdmVTZWxlY3Rpb24iLCJkZWZhdWx0UmVjdCIsImNsaWVudFJlY3RzIiwiSW5maW5pdHkiLCJnZXRDbGllbnRSZWN0cyIsInJhbmdlQ291bnQiLCJnZXRSYW5nZUF0IiwiYW5jaG9yTm9kZSIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiZm9jdXNOb2RlIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNPZmZzZXQiLCJOb2RlIiwiRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HIiwiYXR0ciIsIklFX05PTl9ESVJFQ1RMWV9FRElUQUJMRV9FTEVNRU5UIiwiY29sIiwiY29sZ3JvdXAiLCJ0Ym9keSIsInRkIiwidGZvb3QiLCJ0aCIsInRoZWFkIiwidHIiLCJIRUFESU5HX0JPVEgiLCJIRUFESU5HX0NPTCIsIkhFQURJTkdfTk9ORSIsIkhFQURJTkdfUk9XIiwiX2NyZWF0ZUVsZW1lbnQiLCJhcHBlbmQiLCJqIiwiYXBwZW5kQm9ndXMiLCJzZXRIZWFkaW5nIiwiaGVhZGluZyIsImZpcnN0Q2VsbCIsImNlbGxzIiwibW92ZVRvUG9zaXRpb24iLCJQT1NJVElPTl9BRlRFUl9TVEFSVCIsIndlYmtpdCIsIk5PREVfRUxFTUVOVCIsImlzRWRpdGFibGUiLCJpc1JlYWRPbmx5IiwiaGFzQXR0cmlidXRlIiwiZ2V0UGFyZW50Iiwicm93SGVhZGluZ1NldHRpbmdzIiwidEhlYWQiLCJjb2xIZWFkaW5nU2V0dGluZ3MiLCJub2RlTmFtZSIsImhlYWRpbmdTZXR0aW5ncyIsInBhcmVudCIsImdldENoaWxkQ291bnQiLCJQT1NJVElPTl9CRUZPUkVfU1RBUlQiLCJuZXdDZWxsIiwidGFibGVIZWFkIiwidGFibGVCb2R5IiwiZ2V0RWxlbWVudHNCeVRhZyIsInRhYmxlSGVhZGluZyIsImhhZENvbEhlYWRpbmciLCJuZWVkQ29sSGVhZGluZyIsIm5lZWRSb3dIZWFkaW5nIiwidGFibGVGaXJzdFJvdyIsInRhYmxlRmlyc3RSb3dDaGlsZENvdW50IiwiZ2V0Q2hpbGQiLCJyZW5hbWVOb2RlIiwiY3JlYXRlVEhlYWQiLCJwcmV2aW91c0ZpcnN0Um93IiwiZ2V0Rmlyc3QiLCJuZXdGaXJzdFJvdyIsIm5ld0ZpcnN0Um93Q2hpbGRDb3VudCIsInJlbW92ZUF0dHJpYnV0ZSIsImluc2VydEJlZm9yZSIsImhhc0NvbEhlYWRpbmciLCJoZWFkaW5nQ29tbWFuZHMiLCJqc29ucCIsInVybFRlbXBsYXRlIiwidXJsUGFyYW1zIiwiZXJyb3JDYWxsYmFjayIsImNhbGxiYWNrS2V5IiwiZ2V0TmV4dE51bWJlciIsImpzb25wQ2FsbGJhY2tzIiwicmVzcG9uc2UiLCJjbGVhblVwIiwic2NyaXB0RWxlbWVudCIsImdldEJvZHkiLCJjYW5jZWwiLCJzaW11bGF0ZSIsImV2ZW50SW5zdGFuY2UiLCJjcmVhdGVFdmVudCIsImluaXRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJhcmlhU3RhdGUiLCJhcmlhRWxlbWVudCIsIl9jcmVhdGVBcmlhRWxlbWVudCIsInVpVGFza3NUaW1lb3V0IiwidWljb3JlIiwiaGFuZGxlVUkiLCJhbGxvd0VzYyIsImhhbmRsZUFyaWEiLCJpbm5lckhUTUwiLCJoYW5kbGVNb3VzZUxlYXZlIiwiYWVVSU5vZGVzIiwiZm91bmQiLCJyZWxhdGVkVGFyZ2V0IiwiZm9jdXNIYW5kbGVyIiwiYXR0YWNoTGlzdGVuZXIiLCJyZW1vdmVMaXN0ZW5lciIsInN0YXR1c0VsZW1lbnQiLCJfX2NvbmZpZ19fIiwiX19BVFRSU19fIiwiY3VycmVudEF0dHIiLCJfaXNJbml0aWFsaXplZCIsIl9pbml0IiwiY3VyVmFsdWUiLCJfY2FsbFN0cmluZ09yRnVuY3Rpb24iLCJzZXQiLCJzdHJpbmdPckZ1bmN0aW9uIiwiaGFzRGVmYXVsdFZhbHVlIiwiaGFzUGFzc2VkVmFsdWVWaWFDb25maWciLCJ2YWx1ZUZuIiwiX2NhbGxDaGFpbiIsIndhdCIsImFyciIsImN0b3IiLCJyZXZlcnNlIiwiaXNGaW5pdGUiLCJ2YWx1ZVR5cGUiLCJyZWNlaXZlciIsInN1cHBsaWVyIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwic3VwcGxpZXJQcm90byIsInJlY2VpdmVyUHJvdG8iLCJEcmFnRXZlbnQiLCJldmVudHMiLCJrZXlkb3duIiwibW91c2Vtb3ZlIiwibW91c2V1cCIsInN0YXJ0UG9zIiwiY2xpZW50WCIsImNsaWVudFkiLCJjbGFzc0xpc3QiLCJvblN0YXJ0IiwiY3VycmVudFBvcyIsImRlbHRhIiwiYWx0IiwiY3RybCIsInNoaWZ0S2V5Iiwib25EcmFnIiwid2hpY2giLCJyZWxlYXNlIiwib25Db21wbGV0ZSIsIm9uUmVsZWFzZSIsIklNQUdFX0hBTkRMRVMiLCJQT1NJVElPTl9FTEVNRU5UX0ZOIiwiYmwiLCJoYW5kbGUiLCJib3giLCJwb3NpdGlvbkVsZW1lbnQiLCJiciIsInJtIiwicm91bmQiLCJ0bCIsIl9ib3giLCJnZXRCb3VuZGluZ0JveCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiUmVzaXplciIsImNvbnRhaW5lciIsImhhbmRsZXMiLCJwcmV2aWV3Qm94IiwiaGFuZGxlTmFtZSIsImNyZWF0ZUhhbmRsZSIsInNob3dIYW5kbGVzIiwiZWxlbWVudHMiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiaGlkZUhhbmRsZXMiLCJkcmFnIiwic2hvd1ByZXZpZXciLCJpc0RyYWdnaW5nIiwiY2FsY3VsYXRlU2l6ZSIsImVkaXRvckJvdW5kcyIsInVwZGF0ZVByZXZpZXciLCJ1cGRhdGVIYW5kbGVzIiwiaGlkZVByZXZpZXciLCJyZXNpemVDb21wbGV0ZSIsInJhdGlvIiwiaXNJRSIsIl9vbkRyYWdFbnRlciIsIl9vbkRyYWdPdmVyIiwiX29uRHJhZ0Ryb3AiLCJfb25QYXN0ZSIsIl9oYW5kbGVGaWxlcyIsIl9wcm9jZXNzRmlsZSIsInRyYW5zZmVyRmlsZXMiLCJkYXRhVHJhbnNmZXIiLCJfcHJldmVudEV2ZW50IiwiY2xpcGJvYXJkRGF0YSIsInBhc3RlZERhdGEiLCJpbWFnZUZpbGUiLCJnZXRBc0ZpbGUiLCJiaW4iLCJ1c2VyQWdlbnQiLCJLRVlfQkFDSyIsIktFWV9DT01NQSIsIktFWV9TRU1JQ09MT04iLCJLRVlfU1BBQ0UiLCJERUxJTUlURVJTIiwiUkVHRVhfTEFTVF9XT1JEIiwiUkVHRVhfVVJMIiwiUkVHRVhfRU1BSUwiLCJfb25LZXlVcCIsIm1ldGhvZCIsImRhdGFWYWx1ZSIsIlJlZ0V4cCIsIl9pc1ZhbGlkVVJMIiwiX2lzVmFsaWRFbWFpbCIsIl9nZXRMYXN0V29yZCIsInByZXZpb3VzVGV4dCIsIl9jdXJyZW50S2V5Q29kZSIsInByZXZpb3VzTm9kZSIsImdldFByZXZpb3VzIiwibGFzdENoaWxkIiwiZ2V0TGFzdCIsIl9zdGFydENvbnRhaW5lciIsIl9vZmZzZXQiLCJsYXN0V29yZCIsImVtYWlsIiwiX29uS2V5RG93biIsIl9ja0xpbmsiLCJfcmVwbGFjZUNvbnRlbnRCeUxpbmsiLCJjb250ZW50IiwiY2tMaW5rIiwibGlua05vZGUiLCJfc3Vic2NyaWJlVG9LZXlFdmVudCIsIm5leHRFZGl0YWJsZU5vZGUiLCJlbmNsb3NlZE5vZGUiLCJnZXRFbmNsb3NlZE5vZGUiLCJjYXJldE9mZnNldCIsImdldE5leHQiLCJuZXdSYW5nZSIsInNldEVuZEFmdGVyIiwiREVGQVVMVF9DT05GSUciLCJyZWdleCIsIl9jaGVja0ZvckJhY2tzcGFjZUFuZFVuZG8iLCJpbnNlcnRIdG1sIiwiYnVsbGV0IiwiX2dldExpc3RDb25maWciLCJjb25maWdSZWdleCIsImF1dG9saXN0IiwidGV4dENvbnRhaW5lciIsInJlZ2V4TGVuIiwiYXV0b2xpc3RDZmciLCJyZWdleEl0ZW0iLCJfY3JlYXRlTGlzdCIsImxpc3RDb25maWciLCJzZXRUZXh0IiwiYm90aCIsInNjYWxlIiwiYm0iLCJsbSIsInRtIiwiSU1BR0VfU05BUF9UT19TSVpFIiwiaXNGaXJlZm94IiwiZG9jdW1lbnRFbGVtZW50IiwiaXNXZWJLaXQiLCJlbmFibGVQbHVnaW4iLCJhZGRDc3MiLCJvbkxvYWQiLCJfZXZ0Iiwic25hcFRvU2l6ZSIsImltYWdlU2NhbGVSZXNpemUiLCJyZXNpemVyIiwibW91c2VEb3duTGlzdGVuZXIiLCJlIiwiaXNIYW5kbGUiLCJpbml0RHJhZyIsImh0bWwiLCJzZWxmIiwicmVzaXplRWxlbWVudCIsInJlc2l6ZVRpbWVvdXQiLCJuIiwib3RoZXJJbWFnZXMiLCJ0b0FycmF5Iiwic3BsaWNlIiwib3RoZXJzIiwib3RoZXIiLCJsZW4iLCJjdHgiLCJTdHJpbmciLCJhbGlnbm1lbnRzT2JqIiwiY2VudGVyIiwiY3Vyc29yIiwicmVnZXhQZXJjZW50IiwiaGlkcGkiLCJpY29ucyIsIndpZGdldERlZiIsIndpZGdldHMiLCJpbml0T24iLCJhbGlnbkNsYXNzZXMiLCJpbWFnZTJfYWxpZ25DbGFzc2VzIiwiY2FwdGlvbmVkQ2xhc3MiLCJpbWFnZTJfY2FwdGlvbmVkQ2xhc3MiLCJoZWxwZXJzIiwiaW1hZ2UyIiwiaGFzQ2FwdGlvbiIsImNhcHRpb24iLCJyZWFkeSIsImNoZWNrSGFzTmF0dXJhbFJhdGlvIiwid3JhcHBlciIsImFsaWduIiwiYWxpZ25FbGVtZW50Iiwic2V0RGF0YSIsImltYWdlMl9kaXNhYmxlUmVzaXplciIsInNldHVwUmVzaXplciIsImdldFN0eWxlYWJsZUVsZW1lbnQiLCJnZXRXaWRnZXRBbGxvd2VkQ29udGVudCIsImNvbnRlbnRUcmFuc2Zvcm1hdGlvbnMiLCJmZWF0dXJlcyIsImNoZWNrRmVhdHVyZSIsImNvbnRlbnRlZGl0YWJsZSIsIm9sZERhdGEiLCJjIiwiY2xhc3NlcyIsImRpbWVuc2lvbiIsInNldERpbWVuc2lvbnMiLCJkb3duY2FzdCIsImRvd25jYXN0V2lkZ2V0RWxlbWVudCIsImRyYWdnYWJsZSIsImVkaXRhYmxlcyIsInNlbGVjdG9yIiwiZ2V0V2lkZ2V0RmVhdHVyZXMiLCJnZXRDbGFzc2VzIiwiY2xhc3NSZWdleCIsInJlcG9zaXRvcnkiLCJwYXJzZUVsZW1lbnRDbGFzc2VzIiwiZ2V0TGFiZWwiLCJwYXRoTmFtZSIsInJlcXVpcmVkQ29udGVudCIsInN0eWxlYWJsZUVsZW1lbnRzIiwidXBjYXN0IiwidXBjYXN0V2lkZ2V0RWxlbWVudCIsIm5hdHVyYWwiLCJnZXROYXR1cmFsIiwiY2xpZW50SGVpZ2h0IiwiZGltZW5zaW9ucyIsIm5hdHVyYWxXaWR0aCIsIm5hdHVyYWxIZWlnaCIsImltZyIsIkltYWdlIiwiaGVpZ2giLCJpc0NlbnRlcldyYXBwZXIiLCJjZW50ZXJXcmFwcGVyQ2hlY2tlciIsImZpZ3VyZSIsInJlcGxhY2VXaXRoIiwiaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZSIsImQiLCJhdHRyc0hvbGRlciIsInJlc2l6ZVdyYXBwZXIiLCJwYXJzZUNzc1RleHQiLCJ3cmFwV2l0aCIsImh0bWxQYXJzZXIiLCJpc0VtcHR5Iiwid3JpdGVDc3NUZXh0IiwidmFsaWRDaGlsZHJlbiIsImRpdiIsInAiLCJjaGlsZCIsImVudGVyTW9kZSIsIkVOVEVSX1AiLCJ3aWRnZXQiLCJkb2MiLCJpbWFnZU9yTGluayIsIm9sZFJlc2l6ZVdyYXBwZXIiLCJldnQiLCJmYWN0b3IiLCJzY3JlZW5YIiwic2NyZWVuWSIsInN0YXJ0V2lkdGgiLCJzdGFydEhlaWdodCIsImxpc3RlbmVycyIsImN1cnNvckNsYXNzIiwibmF0aXZlRXZ0IiwibmV3V2lkdGgiLCJuZXdIZWlnaHQiLCJ1cGRhdGVEYXRhIiwibW92ZURpZmZYIiwibW92ZURpZmZZIiwiYXR0YWNoVG9Eb2N1bWVudHMiLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VVcCIsImNvbGxlY3Rpb24iLCJnbG9iYWxEb2MiLCJsIiwid2lkZ2V0RWxlbWVudCIsInNjcm9sbFBvc2l0aW9uIiwicnVsZXMiLCJmaWdjYXB0aW9uIiwidGVtcGxhdGVCbG9jayIsImFmdGVySW5pdCIsImludGVncmF0ZSIsImFsaWduQ29tbWFuZEludGVncmF0b3IiLCJhZV9kcmFncmVzaXplX2llMTFfYWxpZ25DbGFzc2VzIiwiYWVfZHJhZ3Jlc2l6ZV9pZTExX2NhcHRpb25lZENsYXNzIiwiZGVmbGF0ZSIsImRlZmxhdGVkIiwiZm9jdXNlZCIsImluZmxhdGUiLCJhY3RpdmVFbnRlck1vZGUiLCJtb3ZlIiwic2V0V3JhcHBlckFsaWduIiwic2hpZnRTdGF0ZSIsIm5ld0RhdGEiLCJhZV9kcmFncmVzaXplX2llMTEiLCJnZXRMaW5rQXR0cmlidXRlc1BhcnNlciIsImFkdmFuY2VkIiwiYWR2Q1NTQ2xhc3NlcyIsInRyaW0iLCJhZV9kcmFncmVzaXplX2llMTFfZGlzYWJsZVJlc2l6ZXIiLCJkcmFnSGFuZGxlclN0eWxlIiwiZHJhZ0hhbmRsZXJDb250YWluZXIiLCJzdGF0ZVNoaWZ0ZXIiLCJUUklTVEFURV9PRkYiLCJ1bmxpbmsiLCJzaGlmdGFibGVzIiwic3RhdGVBY3Rpb25zIiwib2xkVmFsdWUiLCJjaGFuZ2VkIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0Iiwid3JhcEluQ2VudGVyaW5nIiwidW53cmFwRnJvbUNlbnRlcmluZyIsInNldFN0eWxlIiwiY2FwdGlvblBsYWNlaG9sZGVyIiwicmVwbGFjZVNhZmVseSIsIm5lZWRzRGVmbGF0ZSIsIm5ld0VsIiwidW53cmFwRnJvbUxpbmsiLCJ3cmFwSW5MaW5rIiwiZ2V0TGlua0F0dHJpYnV0ZXNHZXR0ZXIiLCJyZW1vdmVkIiwiYXR0cmlic0FuZFN0eWxlcyIsImxpbmtEYXRhIiwicmVwbGFjaW5nIiwicmVwbGFjZWQiLCJpbnNlcnRFbGVtZW50SW50b1JhbmdlIiwibmF0dXJhbEhlaWdodCIsImdldExpbmtBdHRyaWJ1dGVzIiwicGFyc2VMaW5rQXR0cmlidXRlcyIsInF1ZXJ5U2VsZWN0b3IiLCJpbWFnZVN0eWxlcyIsIndpZHRoU3R5bGVzIiwid2lkdGhTdHlsZSIsInJlc2l6ZXJORSIsInJlc2l6ZXJOVyIsInJlc2l6ZXJTRSIsInJlc2l6ZXJTVyIsImZhY3RvclgiLCJmYWN0b3JZIiwiYWRqdXN0VG9YIiwiYWRqdXN0VG9ZIiwicmVtb3ZlV2lkZ2V0QWxpZ25tZW50IiwiaW1hZ2VBbGlnbm1lbnQiLCJleGVjQ2FsbGJhY2tzIiwiZW5hYmxlZCIsInJlZnJlc2giLCJnZXRGb2N1c2VkV2lkZ2V0IiwiYWxsb3dlZCIsInJlZ2lzdGVyZWQiLCJSRUdFWF9IVFRQIiwiUkVHRVhfREVGQVVMVF9MSU5LIiwiREVGQVVMVF9BRV9FTUJFRF9VUkxfVFBMIiwiREVGQVVMVF9BRV9FTUJFRF9XSURHRVRfVFBMIiwiREVGQVVMVF9BRV9FTUJFRF9ERUZBVUxUX0xJTktfVFBMIiwiQUVfRU1CRURfVVJMX1RQTCIsImVtYmVkVXJsVGVtcGxhdGUiLCJBRV9FTUJFRF9XSURHRVRfVFBMIiwiZW1iZWRXaWRnZXRUcGwiLCJBRV9FTUJFRF9ERUZBVUxUX0xJTktfVFBMIiwiZW1iZWRMaW5rRGVmYXVsdFRwbCIsImRlZmF1bHRFbWJlZFdpZGdldFVwY2FzdEZuIiwibWFzayIsImVuY29kZVVSSUNvbXBvbmVudCIsImNyZWF0ZUFUYWciLCJzZXRIdG1sIiwiX21zZyIsImFUYWdIdG1sIiwiZW1iZWRXaWRnZXRVcGNhc3RGbiIsIkhJR0hfUFJJT1JJVFkiLCJhZGRFbGVtZW50Q2FsbGJhY2siLCJGSUxURVJfU0tJUF9UUkVFIiwiREVGQVVMVF9MRlJfRU1CRURfV0lER0VUX1RQTCIsIkVNQkVEX0FMSUdOTUVOVCIsIkNFTlRFUiIsIkxFRlQiLCJSSUdIVCIsIkFMSUdOX1ZBTFVFUyIsIkNFTlRFUkVEX0VNQkVEX1NUWUxFIiwiZ2V0RW1iZWRBbGlnbm1lbnQiLCJlbWJlZEFsaWdubWVudCIsImNlbnRlcmVkRW1iZWQiLCJldmVyeSIsInN0eWxlQ2hlY2siLCJ2ZW5kb3JQcmVmaXhlcyIsInZlbmRvclByZWZpeCIsInJlbW92ZUVtYmVkQWxpZ25tZW50Iiwic2V0RW1iZWRBbGlnbm1lbnQiLCJ3cmFwcGVyRWxlbWVudCIsInBhcmVudEVsZW1lbnQiLCJwd2lkdGgiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJpZnJhbWVFbGVtZW50Iiwic2VsZWN0V2lkZ2V0Iiwicm9vdCIsImZpbmQiLCJlbGVtZW50TGlzdCIsImltYWdlRWxlbWVudCIsImN1cnJlbnRBbGlnbm1lbnQiLCJjdXJyZW50RWxlbWVudCIsIkxGUl9FTUJFRF9XSURHRVRfVFBMIiwicHJvdmlkZXJzIiwicHJvdmlkZXIiLCJzY2hlbWUiLCJnZW5lcmF0ZUVtYmVkQ29udGVudCIsImhlbHBNZXNzYWdlIiwidmlkZW9QbGF5YmFja0Rpc2FibGVkIiwiaGVscE1lc3NhZ2VJY29uIiwiTGlmZXJheSIsIlV0aWwiLCJnZXRMZXhpY29uSWNvblRwbCIsInVwY2FzdFdpZGdldCIsImlmcmFtZSIsImVtYmVkQ29udGVudCIsImdldE91dGVySHRtbCIsIndpZGdldEZyYWdtZW50IiwiZnJhZ21lbnQiLCJmcm9tSHRtbCIsInNob3dFcnJvciIsImVycm9yTXNnIiwidmFsaWRQcm92aWRlciIsImVtYmVkSWQiLCJfc2VsZWN0RW1iZWRXaWRnZXQiLCJwbGF0Zm9ybU5vdFN1cHBvcnRlZCIsImVudGVyVmFsaWRVcmwiLCJzdHlsZXNKU09OIiwiYm91bmRzIiwiYWxpZ25WYWx1ZSIsInNlbGVjdGVkRW1iZWQiLCJzZW5kZXIiLCJJTUFHRV9BTElHTk1FTlQiLCJDRU5URVJFRF9JTUFHRV9TVFlMRSIsImdldEltYWdlQWxpZ25tZW50IiwiY2VudGVyZWRJbWFnZSIsImltYWdlQ29udGFpbmVyIiwidGV4dEFsaWduIiwicmVtb3ZlSW1hZ2VBbGlnbm1lbnQiLCJzZXRJbWFnZUFsaWdubWVudCIsInJlZnJlc2hDb21tYW5kcyIsImVtYmVkdXJsIiwiYnJGaWxsZXIiLCJuZWVkc0JyRmlsbGVyIiwiZW50ZXJNb2RlRW1wdHlWYWx1ZSIsIl9jaGVja0VtcHR5RGF0YSIsIl9yZW1vdmVQbGFjZWhvbGRlckNsYXNzIiwiZWRpdGFibGVOb2RlIiwiaW5uZXJIdG1sIiwiZWRpdG9yTm9kZSIsIkRFRkFVTFRfUFJJT1JJVFkiLCJzZWxlY3Rpb25LZXlzdHJva2UiLCJweFVuaXQiLCJjc3NMZW5ndGgiLCJnZXRXaWR0aCIsImdldEJvcmRlcldpZHRoIiwic2lkZSIsImNvbXB1dGVkIiwiYm9yZGVyTWFwIiwidGhpbiIsIm1lZGl1bSIsInRoaWNrIiwiZ2V0TWFzdGVyUGlsbGFyUm93IiwiJHJvd3MiLCJtYXhDZWxscyIsImNlbGxzQ291bnQiLCIkZWxlY3RlZCIsIiR0ciIsImJ1aWxkVGFibGVDb2x1bW5QaWxsYXJzIiwicGlsbGFycyIsInBpbGxhckluZGV4IiwicnRsIiwidEJvZGllcyIsInRib2R5UG9zaXRpb24iLCJnZXREb2N1bWVudFBvc2l0aW9uIiwibmV4dFRkIiwiY29sU3BhbiIsInBpbGxhckxlZnQiLCJwaWxsYXJSaWdodCIsInBpbGxhcldpZHRoIiwiZ2V0UGlsbGFyQXRQb3NpdGlvbiIsInBvc2l0aW9uWCIsInBpbGxhciIsIkNvbHVtblJlc2l6ZXIiLCJjdXJyZW50U2hpZnQiLCJsZWZ0U2hpZnRCb3VuZGFyeSIsImxlZnRTaWRlQ2VsbHMiLCJyZXNpemluZyIsInJpZ2h0U2hpZnRCb3VuZGFyeSIsInJpZ2h0U2lkZUNlbGxzIiwiaXNSZXNpemluZyIsInBvc1giLCJyZXNpemVyTmV3UG9zaXRpb24iLCJvbk1vdXNlRG93biIsInJlc2l6ZVN0YXJ0IiwiY29sdW1uSW5kZXgiLCJidWlsZFRhYmxlTWFwIiwibGVmdENvbHVtbkNlbGxzIiwicmlnaHRDb2x1bW5DZWxscyIsImxlZnRNaW5TaXplIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwicmlnaHRNaW5TaXplIiwibGVmdENlbGwiLCJyaWdodENlbGwiLCJzZXRPcGFjaXR5IiwicmVzaXplRW5kIiwicmVzaXplQ29sdW1uIiwicmVtb3ZlQ3VzdG9tRGF0YSIsImxlZnRPbGRXaWR0aCIsInJpZ2h0T2xkV2lkdGgiLCJ0YWJsZVdpZHRoIiwic2l6ZVNoaWZ0IiwiZ2V0UGFnZU9mZnNldCIsImdldERvY3VtZW50RWxlbWVudCIsImNsZWFyUGlsbGFyc0NhY2hlIiwiZGVzdCIsInRvRWxlbWVudCIsImlzSW5saW5lIiwiZ2V0Q3VzdG9tRGF0YSIsInNldEN1c3RvbURhdGEiLCJjZWxsTm9kZVJlZ2V4IiwiZ2V0U2VsZWN0ZWRDZWxscyIsInJldHZhbCIsImRhdGFiYXNlIiwibW92ZU91dE9mQ2VsbEd1YXJkIiwic2V0TWFya2VyIiwibmVhcmVzdENlbGwiLCJ3YWxrZXIiLCJndWFyZCIsImR0ZCIsImNsZWFyQWxsTWFya2VycyIsImdldEZvY3VzRWxlbWVudEFmdGVyRGVsQ2VsbHMiLCJjZWxsc1RvRGVsZXRlIiwibGFzdCIsImZvY3VzZWRDZWxsIiwiaW5zZXJ0Um93IiwiZ2V0RG9jdW1lbnQiLCJzdGFydFJvdyIsInN0YXJ0Um93SW5kZXgiLCJyb3dJbmRleCIsImxhc3RDZWxsIiwiZW5kUm93SW5kZXgiLCJyb3dTcGFuIiwiZW5kUm93IiwiY2xvbmVSb3ciLCJuZXh0Um93IiwibmV3Um93IiwiY2xvbmUiLCJpbnNlcnRBZnRlciIsImRlbGV0ZVJvd3MiLCJzZWxlY3Rpb25PclJvdyIsInJvd3NUb0RlbGV0ZSIsIm1hcFJvdyIsImNlbGxSb3dJbmRleCIsIm5leHRNYXBSb3ciLCJjdXJzb3JQb3NpdGlvbiIsImdldENlbGxDb2xJbmRleCIsImlzU3RhcnQiLCJyb3dDZWxscyIsImNvbEluZGV4IiwibWFwQ2VsbCIsImdldENvbHVtbnNJbmRpY2VzIiwiaW5zZXJ0Q29sdW1uIiwic3RhcnRDb2wiLCJsYXN0Q29sIiwiY2xvbmVDb2wiLCJuZXh0Q29sIiwibmV4dENlbGwiLCJkZWxldGVDb2x1bW5zIiwic2VsZWN0aW9uT3JDZWxsIiwic3RhcnRDb2xJbmRleCIsImVuZENvbEluZGV4IiwiZmlyc3RSb3dDZWxscyIsImluc2VydENlbGwiLCJzdGFydEVsZW1lbnQiLCJkZWxldGVDZWxscyIsImNlbGxUb0ZvY3VzIiwicGxhY2VDdXJzb3JJbkNlbGwiLCJ0cmltQ2VsbCIsImJvZ3VzIiwiZ2V0Qm9ndXMiLCJwbGFjZUF0RW5kIiwiZG9jSW5uZXIiLCJkb2NPdXRlciIsImNvbGxhcHNlIiwiY2VsbEluUm93IiwidGFibGVNYXAiLCJvUm93IiwiY2VsbEluQ29sIiwib0NvbCIsInIiLCJtZXJnZUNlbGxzIiwibWVyZ2VEaXJlY3Rpb24iLCJpc0RldGVjdCIsImNvbW1vbkFuY2VzdG9yIiwibWFwSGVpZ2h0IiwibWFwV2lkdGgiLCJzdGFydENvbHVtbiIsInRhcmdldENlbGwiLCJyb3dzcGFuIiwiY29sc3BhbiIsImVyIiwibGFzdFJvd0luZGV4IiwidG90YWxSb3dTcGFuIiwidG90YWxDb2xTcGFuIiwiZnJhZyIsImRvY3VtZW50RnJhZ21lbnQiLCJjZWxsRmlyc3RDaGlsZCIsImlzQmxvY2tCb3VuZGFyeSIsIndoaXRlc3BhY2VzIiwibW92ZUNoaWxkcmVuIiwidHJzIiwibm9kZUxpc3QiLCJ0YWlsVHIiLCJ2ZXJ0aWNhbFNwbGl0Q2VsbCIsIm5ld1Jvd1NwYW4iLCJuZXdDZWxsUm93U3BhbiIsIm5ld1Jvd0luZGV4IiwiY2VpbCIsIm5ld0NlbGxUciIsIm5ld0NlbGxSb3ciLCJjYW5kaWRhdGVDZWxsIiwiY2VsbHNJblNhbWVSb3ciLCJob3Jpem9udGFsU3BsaXRDZWxsIiwibmV3Q29sU3BhbiIsIm5ld0NlbGxDb2xTcGFuIiwiY2VsbHNJblNhbWVDb2wiLCJjcmVhdGVEZWYiLCJkZWYiLCJjb250ZXh0U2Vuc2l0aXZlIiwiYWRkQ21kIiwiY21kIiwiYWRkRmVhdHVyZSIsImFSb3dzIiwiYU1hcCIsIm9DZWxsIiwiaUNvbFNwYW4iLCJpUm93U3BhbiIsInJzIiwiY3MiLCJ0YWJsZVNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyIsIkRFRkFVTFRfR1VUVEVSIiwiY2VudGVyVG9vbGJhciIsInRvb2xiYXJOb2RlIiwiaGFsZk5vZGVXaWR0aCIsIndpZGdldFhZIiwiZW5kUG9zaXRpb24iLCJpbWFnZVNlbGVjdGlvblNldFBvc2l0aW9uIiwidGFibGVTZWxlY3Rpb25TZXRQb3NpdGlvbiIsIl9pc1JhbmdlQXRFbGVtZW50RW5kIiwiZW1iZWRTZWxlY3Rpb25UZXN0IiwiZW1iZWRVcmxTZWxlY3Rpb25UZXN0IiwiaGVhZGluZ1RleHRTZWxlY3Rpb25UZXN0IiwiaGVhZGluZ3MiLCJzZWxlY3Rpb25FbXB0eSIsImxpbmtTZWxlY3Rpb25UZXN0IiwiZWxlbWVudElzTm90SW1hZ2UiLCJpbWFnZVNlbGVjdGlvblRlc3QiLCJoYXNJbWFnZSIsImlzSW1hZ2UiLCJ0ZXh0U2VsZWN0aW9uVGVzdCIsInRhYmxlU2VsZWN0aW9uVGVzdCIsImVtYmVkVXJsIiwiaGVhZGVyIiwiZnVsbCIsInNpbXBsZSJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVB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QXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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ZTdvQixVOzs7Ozs7Ozs7OztBQ2xGZixhQUFhLG9DQUFvQyxFQUFFLEk7Ozs7Ozs7Ozs7O0FDQW5ELGFBQWEsb0NBQW9DLEVBQUUsSSIsImZpbGUiOiJhbGxveS1lZGl0b3ItY29yZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2FkYXB0ZXIvbWFpbi5qc1wiKTtcbiIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi44LjVcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlO1xudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHxcbiAgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKTtcbn1cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgbG93UHJpb3JpdHlXYXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcblxudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7XG5cbi8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7XG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJpbXBvcnQgJy4uL2NvcmUnO1xuaW1wb3J0ICcuLi9wbHVnaW5zJztcblxuaW1wb3J0ICcuLi9jb21wb25lbnRzL3VpYnJpZGdlJztcblxuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgZXh0ZW5kIGZyb20gJy4uL29vcC9vb3AnO1xuaW1wb3J0IExhbmcgZnJvbSAnLi4vb29wL2xhbmcnO1xuaW1wb3J0IEJhc2UgZnJvbSAnLi4vb29wL2Jhc2UnO1xuaW1wb3J0IFNlbGVjdGlvbnMgZnJvbSAnLi4vc2VsZWN0aW9ucy9zZWxlY3Rpb25zJztcbmltcG9ydCBVSSBmcm9tICcuLi9jb21wb25lbnRzL21haW4uanN4JztcblxuaW1wb3J0IHtyZW1vdmVJbWFnZUNvbW1hbmR9IGZyb20gJy4uL2NvbW1hbmRzJztcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5jb25zdCBFTUJFRF9WSURFT19XSURUSCA9IDU2MDtcbmNvbnN0IEVNQkVEX1ZJREVPX0hFSUdIVCA9IDMxNTtcblxuLyoqXG4gKiBBbGxveUVkaXRvciBtYWluIGNsYXNzLiBDcmVhdGVzIGluc3RhbmNlIG9mIHRoZSBlZGl0b3IgYW5kIHByb3ZpZGVzIHRoZSB1c2VyIGNvbmZpZ3VyYXRpb25cbiAqIHRvIHRoZSBVSS5cbiAqXG4gKiBAY2xhc3MgQ29yZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWd1cmF0aW9uIHRvIGJlIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIENvcmUoY29uZmlnKSB7XG5cdENvcmUuc3VwZXJjbGFzcy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIGNvbmZpZyk7XG59XG5cbmV4dGVuZChcblx0Q29yZSxcblx0QmFzZSxcblx0e1xuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemVyIGxpZmVjeWNsZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIEFsbG95RWRpdG9yIGNsYXNzLiBDcmVhdGVzIGEgQ0tFZGl0b3Jcblx0XHQgKiBpbnN0YW5jZSwgcGFzc2luZyBpdCB0aGUgcHJvdmlkZWQgY29uZmlndXJhdGlvbiBhdHRyaWJ1dGVzLlxuXHRcdCAqXG5cdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQG1ldGhvZCBpbml0aWFsaXplclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3QgbGl0ZXJhbCBmb3IgdGhlIGVkaXRvci5cblx0XHQgKi9cblx0XHRpbml0aWFsaXplcihjb25maWcpIHtcblx0XHRcdGNvbnN0IG5vZGUgPSB0aGlzLmdldCgnc3JjTm9kZScpO1xuXG5cdFx0XHRpZiAodGhpcy5nZXQoJ2VuYWJsZUNvbnRlbnRFZGl0YWJsZScpKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAndHJ1ZScpO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBlZGl0b3IgPSBDS0VESVRPUi5pbmxpbmUobm9kZSk7XG5cblx0XHRcdGVkaXRvci5jb25maWcuYWxsb3dlZENvbnRlbnQgPSB0aGlzLmdldCgnYWxsb3dlZENvbnRlbnQnKTtcblxuXHRcdFx0ZWRpdG9yLmNvbmZpZy50b29sYmFycyA9IHRoaXMuZ2V0KCd0b29sYmFycycpO1xuXG5cdFx0XHRlZGl0b3IuY29uZmlnLnJlbW92ZVBsdWdpbnMgPSB0aGlzLmdldCgncmVtb3ZlUGx1Z2lucycpO1xuXG5cdFx0XHRlZGl0b3IuY29uZmlnLmV4dHJhUGx1Z2lucyA9IHRoaXMuZ2V0KCdleHRyYVBsdWdpbnMnKTtcblxuXHRcdFx0ZWRpdG9yLmNvbmZpZy5lbWJlZFByb3ZpZGVycyA9IHRoaXMuZ2V0KCdlbWJlZFByb3ZpZGVycycpO1xuXG5cdFx0XHRlZGl0b3IuY29uZmlnLnBsYWNlaG9sZGVyQ2xhc3MgPSB0aGlzLmdldCgncGxhY2Vob2xkZXJDbGFzcycpO1xuXG5cdFx0XHRlZGl0b3IuY29uZmlnLnBhc3RlRnJvbVdvcmRSZW1vdmVTdHlsZXMgPSBmYWxzZTtcblx0XHRcdGVkaXRvci5jb25maWcucGFzdGVGcm9tV29yZFJlbW92ZUZvbnRTdHlsZXMgPSBmYWxzZTtcblxuXHRcdFx0ZWRpdG9yLmNvbmZpZy5zZWxlY3Rpb25LZXlzdHJva2VzID0gdGhpcy5nZXQoJ3NlbGVjdGlvbktleXN0cm9rZXMnKTtcblxuXHRcdFx0ZWRpdG9yLmNvbmZpZy5zcHJpdGVtYXAgPSB0aGlzLmdldCgnc3ByaXRlbWFwJyk7XG5cblx0XHRcdExhbmcubWl4KGVkaXRvci5jb25maWcsIGNvbmZpZyk7XG5cblx0XHRcdGlmIChDS0VESVRPUi5lbnYuaWUgJiYgIUNLRURJVE9SLmVudi5lZGdlKSB7XG5cdFx0XHRcdGNvbnN0IHBsdWdpbiA9XG5cdFx0XHRcdFx0Q0tFRElUT1IuZW52LnZlcnNpb24gPT09IDExXG5cdFx0XHRcdFx0XHQ/ICdhZV9kcmFncmVzaXplX2llMTEnXG5cdFx0XHRcdFx0XHQ6ICdhZV9kcmFncmVzaXplX2llJztcblxuXHRcdFx0XHRlZGl0b3IuY29uZmlnLmV4dHJhUGx1Z2lucyA9IGVkaXRvci5jb25maWcuZXh0cmFQbHVnaW5zLnJlcGxhY2UoXG5cdFx0XHRcdFx0J2FlX2RyYWdyZXNpemUnLFxuXHRcdFx0XHRcdHBsdWdpblxuXHRcdFx0XHQpO1xuXHRcdFx0XHRlZGl0b3IuY29uZmlnLnJlbW92ZVBsdWdpbnMgPSBlZGl0b3IuY29uZmlnLnJlbW92ZVBsdWdpbnMucmVwbGFjZShcblx0XHRcdFx0XHQnYWVfZHJhZ3Jlc2l6ZScsXG5cdFx0XHRcdFx0cGx1Z2luXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGVkaXRvci5vbmNlKFxuXHRcdFx0XHQnY29udGVudERvbScsXG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMuX2FkZFJlYWRPbmx5TGlua0NsaWNrTGlzdGVuZXIoZWRpdG9yKTtcblxuXHRcdFx0XHRcdGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdFx0XHRjb25zdCBleHRyYUNvbW1hbmRzID0gdGhpcy5nZXQoJ2V4dHJhQ29tbWFuZHMnKTtcblxuXHRcdFx0XHRcdGNvbnN0IGV4dHJhQ29tbWFuZEtleXMgPSBPYmplY3Qua2V5cyhleHRyYUNvbW1hbmRzKTtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGV4dHJhQ29tbWFuZEtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGNvbW1hbmROYW1lID0gZXh0cmFDb21tYW5kS2V5c1tpXTtcblxuXHRcdFx0XHRcdFx0aWYgKGVkaXRvci5jb21tYW5kc1tjb21tYW5kTmFtZV0pIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGVkaXRvci5hZGRDb21tYW5kKFxuXHRcdFx0XHRcdFx0XHRjb21tYW5kTmFtZSxcblx0XHRcdFx0XHRcdFx0ZXh0cmFDb21tYW5kc1tjb21tYW5kTmFtZV1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWRpdGFibGUuYWRkQ2xhc3MoJ2FlLWVkaXRhYmxlJyk7XG5cdFx0XHRcdH0uYmluZCh0aGlzKVxuXHRcdFx0KTtcblxuXHRcdFx0dGhpcy5fZWRpdG9yID0gZWRpdG9yO1xuXG5cdFx0XHRBbGxveUVkaXRvci5sb2FkTGFuZ3VhZ2VSZXNvdXJjZXModGhpcy5fcmVuZGVyVUkuYmluZCh0aGlzKSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERlc3RydWN0b3IgbGlmZWN5Y2xlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgQWxsb3lFZHRvciBjbGFzcy4gRGVzdHJveXMgdGhlIENLRWRpdG9yXG5cdFx0ICogaW5zdGFuY2UgYW5kIGRlc3Ryb3lzIGFsbCBjcmVhdGVkIHRvb2xiYXJzLlxuXHRcdCAqXG5cdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQG1ldGhvZCBkZXN0cnVjdG9yXG5cdFx0ICovXG5cdFx0ZGVzdHJ1Y3RvcigpIHtcblx0XHRcdHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG5cblx0XHRcdGlmICh0aGlzLl9lZGl0b3JVSUVsZW1lbnQpIHtcblx0XHRcdFx0UmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSh0aGlzLl9lZGl0b3JVSUVsZW1lbnQpO1xuXHRcdFx0XHR0aGlzLl9lZGl0b3JVSUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChcblx0XHRcdFx0XHR0aGlzLl9lZGl0b3JVSUVsZW1lbnRcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gdGhpcy5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRpZiAobmF0aXZlRWRpdG9yKSB7XG5cdFx0XHRcdGNvbnN0IGVkaXRhYmxlID0gbmF0aXZlRWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdFx0aWYgKGVkaXRhYmxlKSB7XG5cdFx0XHRcdFx0ZWRpdGFibGUucmVtb3ZlQ2xhc3MoJ2FlLWVkaXRhYmxlJyk7XG5cblx0XHRcdFx0XHRpZiAodGhpcy5nZXQoJ2VuYWJsZUNvbnRlbnRFZGl0YWJsZScpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmdldCgnc3JjTm9kZScpLnNldEF0dHJpYnV0ZShcblx0XHRcdFx0XHRcdFx0J2NvbnRlbnRlZGl0YWJsZScsXG5cdFx0XHRcdFx0XHRcdCdmYWxzZSdcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5fY2xlYXJTZWxlY3Rpb25zKCk7XG5cblx0XHRcdFx0bmF0aXZlRWRpdG9yLmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2xlYXIgc2VsZWN0aW9ucyBmcm9tIHdpbmRvdyBvYmplY3Rcblx0XHQgKlxuXHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBtZXRob2QgX2NsZWFyU2VsZWN0aW9uc1xuXHRcdCAqL1xuXHRcdF9jbGVhclNlbGVjdGlvbnMoKSB7XG5cdFx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0XHRjb25zdCBpc01TU2VsZWN0aW9uID0gdHlwZW9mIHdpbmRvdy5nZXRTZWxlY3Rpb24gIT0gJ2Z1bmN0aW9uJztcblxuXHRcdFx0aWYgKGlzTVNTZWxlY3Rpb24pIHtcblx0XHRcdFx0bmF0aXZlRWRpdG9yLmRvY3VtZW50LiQuc2VsZWN0aW9uLmVtcHR5KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuYXRpdmVFZGl0b3IuZG9jdW1lbnRcblx0XHRcdFx0XHQuZ2V0V2luZG93KClcblx0XHRcdFx0XHQuJC5nZXRTZWxlY3Rpb24oKVxuXHRcdFx0XHRcdC5yZW1vdmVBbGxSYW5nZXMoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTWV0aG9kIHRvIHNldCBkZWZhdWx0IGxpbmsgYmVoYXZpb3Jcblx0XHQgKlxuXHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBtZXRob2QgX2FkZFJlYWRPbmx5TGlua0NsaWNrTGlzdGVuZXJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yXG5cdFx0ICovXG5cdFx0X2FkZFJlYWRPbmx5TGlua0NsaWNrTGlzdGVuZXIoZWRpdG9yKSB7XG5cdFx0XHRlZGl0b3IuZWRpdGFibGUoKS5vbignY2xpY2snLCB0aGlzLl9kZWZhdWx0UmVhZE9ubHlDbGlja0ZuLCB0aGlzLCB7XG5cdFx0XHRcdGVkaXRvcixcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDYWxsZWQgb24gYGNsaWNrYCBldmVudCB3aGVuIHRoZSBlZGl0b3IgaXMgaW4gcmVhZCBvbmx5IG1vZGUuIE5hdmlnYXRlcyB0byBsaW5rJ3MgVVJMIG9yIG9wZW5zXG5cdFx0ICogdGhlIGxpbmsgaW4gYSBuZXcgd2luZG93LlxuXHRcdCAqXG5cdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAZXZlbnQgcmVhZE9ubHlDbGlja1xuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAbWV0aG9kIF9kZWZhdWx0UmVhZE9ubHlDbGlja0ZuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IFRoZSBmaXJlZCBgY2xpY2tgIGV2ZW50IHBheWxvYWRcblx0XHQgKi9cblx0XHRfZGVmYXVsdFJlYWRPbmx5Q2xpY2tGbihldmVudCkge1xuXHRcdFx0Y29uc3QgbW91c2VFdmVudCA9IGV2ZW50LmRhdGEuJDtcblx0XHRcdGNvbnN0IGhhc0N0cmxLZXkgPSBtb3VzZUV2ZW50LmN0cmxLZXkgfHwgbW91c2VFdmVudC5tZXRhS2V5O1xuXHRcdFx0Y29uc3Qgc2hvdWxkT3BlbiA9IHRoaXMuX2VkaXRvci5jb25maWcucmVhZE9ubHkgfHwgaGFzQ3RybEtleTtcblxuXHRcdFx0bW91c2VFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRpZiAoIXNob3VsZE9wZW4pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3Jcblx0XHRcdFx0XHQuZWRpdGFibGUoKVxuXHRcdFx0XHRcdC5lZGl0b3IuZmlyZSgncmVhZE9ubHlDbGljaycsIGV2ZW50LmRhdGEpICE9PSBmYWxzZVxuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnN0IGNrRWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudFBhdGgoXG5cdFx0XHRcdFx0ZXZlbnQuZGF0YS5nZXRUYXJnZXQoKSxcblx0XHRcdFx0XHR0aGlzXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnN0IGxpbmsgPSBja0VsZW1lbnQubGFzdEVsZW1lbnQ7XG5cblx0XHRcdFx0aWYgKGxpbmspIHtcblx0XHRcdFx0XHRjb25zdCBocmVmID0gbGluay4kLmF0dHJpYnV0ZXMuaHJlZlxuXHRcdFx0XHRcdFx0PyBsaW5rLiQuYXR0cmlidXRlcy5ocmVmLnZhbHVlXG5cdFx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0XHRcdFx0Y29uc3QgdGFyZ2V0ID0gaGFzQ3RybEtleVxuXHRcdFx0XHRcdFx0PyAnX2JsYW5rJ1xuXHRcdFx0XHRcdFx0OiBsaW5rLiQuYXR0cmlidXRlcy50YXJnZXRcblx0XHRcdFx0XHRcdD8gbGluay4kLmF0dHJpYnV0ZXMudGFyZ2V0LnZhbHVlXG5cdFx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0XHRcdFx0dGhpcy5fcmVkaXJlY3RMaW5rKGhyZWYsIHRhcmdldCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0cmlldmVzIHRoZSBuYXRpdmUgQ0tFZGl0b3IgaW5zdGFuY2UuIEhhdmluZyB0aGlzLCB0aGUgZGV2ZWxvcGVyIG1heSB1c2UgdGhlIEFQSSBvZiBDS0VkaXRvciBPT1RCLlxuXHRcdCAqXG5cdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQG1ldGhvZCBfZ2V0TmF0aXZlRWRpdG9yXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY3VycmVudCBpbnN0YW5jZSBvZiBDS0VkaXRvci5cblx0XHQgKi9cblx0XHRfZ2V0TmF0aXZlRWRpdG9yKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2VkaXRvcjtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVkaXJlY3RzIHRoZSBicm93c2VyIHRvIGEgZ2l2ZW4gbGlua1xuXHRcdCAqXG5cdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQG1ldGhvZCBfcmVkaXJlY3RMaW5rXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgVGhlIGhyZWYgdG8gdGFrZSB0aGUgYnJvd3NlciB0b1xuXHRcdCAqIEBwYXJhbSB7c3RyaW5nPX0gdGFyZ2V0IFNwZWNpZmllcyB3aGVyZSB0byBkaXNwbGF5IHRoZSBsaW5rXG5cdFx0ICovXG5cdFx0X3JlZGlyZWN0TGluayhocmVmLCB0YXJnZXQpIHtcblx0XHRcdGlmICh0YXJnZXQgJiYgaHJlZikge1xuXHRcdFx0XHR3aW5kb3cub3BlbihocmVmLCB0YXJnZXQpO1xuXHRcdFx0fSBlbHNlIGlmIChocmVmKSB7XG5cdFx0XHRcdHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmVuZGVycyB0aGUgc3BlY2lmaWVkIGZyb20gdGhlIHVzZXIgdG9vbGJhcnMuXG5cdFx0ICpcblx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAbWV0aG9kIF9yZW5kZXJVSVxuXHRcdCAqL1xuXHRcdF9yZW5kZXJVSSgpIHtcblx0XHRcdGlmICghdGhpcy5fZGVzdHJveWVkKSB7XG5cdFx0XHRcdGNvbnN0IGVkaXRvclVJRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0XHRlZGl0b3JVSUVsZW1lbnQuY2xhc3NOYW1lID0gJ2FlLXVpJztcblxuXHRcdFx0XHRjb25zdCB1aU5vZGUgPSB0aGlzLmdldCgndWlOb2RlJykgfHwgZG9jdW1lbnQuYm9keTtcblxuXHRcdFx0XHR1aU5vZGUuYXBwZW5kQ2hpbGQoZWRpdG9yVUlFbGVtZW50KTtcblxuXHRcdFx0XHRjb25zdCBjYWxsYmFja1JlZiA9IGVsZW1lbnQgPT4ge1xuXHRcdFx0XHRcdGlmICghdGhpcy5fbWFpblVJICYmIGVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdHRoaXMuX21haW5VSSA9IGVsZW1lbnQ7XG5cdFx0XHRcdFx0XHR0aGlzLmdldCgnbmF0aXZlRWRpdG9yJykuZmlyZSgndWlSZWFkeScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHRSZWFjdERPTS5yZW5kZXIoXG5cdFx0XHRcdFx0PEVkaXRvckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3tlZGl0b3I6IHRoaXN9fT5cblx0XHRcdFx0XHRcdDxVSVxuXHRcdFx0XHRcdFx0XHRldmVudHNEZWxheT17dGhpcy5nZXQoJ2V2ZW50c0RlbGF5Jyl9XG5cdFx0XHRcdFx0XHRcdHJlZj17Y2FsbGJhY2tSZWZ9XG5cdFx0XHRcdFx0XHRcdHRvb2xiYXJzPXt0aGlzLmdldCgndG9vbGJhcnMnKX1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9FZGl0b3JDb250ZXh0LlByb3ZpZGVyPixcblx0XHRcdFx0XHRlZGl0b3JVSUVsZW1lbnRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHR0aGlzLl9lZGl0b3JVSUVsZW1lbnQgPSBlZGl0b3JVSUVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSBmdW5jdGlvbiByZXR1cm5zIGFuIEhUTUwgZWxlbWVudCBmcm9tIHRoZSBwYXNzZWQgdmFsdWUuIElmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IHNob3VsZCBiZVxuXHRcdCAqIHRoZSBJZCBvZiB0aGUgZWxlbWVudCB3aGljaCBoYXZlIHRvIGJlIHJldHJpZXZlZCBmcm9tIHRoZSBET00uXG5cdFx0ICogSWYgYW4gSFRNTCBFbGVtZW50IGlzIHBhc3NlZCwgdGhlIGVsZW1lbnQgaXRzZWxmIHdpbGwgYmUgcmV0dXJuZWQuXG5cdFx0ICpcblx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZXRob2QgX3RvRWxlbWVudFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAcGFyYW0geyEoU3RyaW5nfEhUTUxFbGVtZW50KX0gdmFsdWUgU3RyaW5nLCB3aGljaCBoYXZlIHRvIGNvcnJlc3BvbmQgdG8gYW4gSFRNTCBlbGVtZW50IGZyb20gdGhlIERPTSxcblx0XHQgKiBvciB0aGUgSFRNTCBlbGVtZW50IGl0c2VsZi4gSWYgSWQgaXMgcGFzc2VkLCB0aGUgSFRNTCBlbGVtZW50IHdpbGwgYmUgcmV0cmlldmVkIGZyb20gdGhlIERPTS5cblx0XHQgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH0gQW4gSFRNTCBlbGVtZW50LlxuXHRcdCAqL1xuXHRcdF90b0VsZW1lbnQodmFsdWUpIHtcblx0XHRcdGlmIChMYW5nLmlzU3RyaW5nKHZhbHVlKSkge1xuXHRcdFx0XHR2YWx1ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHZhbHVlKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBWYWxpZGF0ZXMgdGhlIGFsbG93ZWQgY29udGVudCBhdHRyaWJ1dGUuIExvb2tcblx0XHQgKiBbaGVyZV0oaHR0cDovL2RvY3MuY2tlZGl0b3IuY29tLyMhL2FwaS9DS0VESVRPUi5jb25maWctY2ZnLWFsbG93ZWRDb250ZW50KSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGVcblx0XHQgKiBzdXBwb3J0ZWQgdmFsdWVzLlxuXHRcdCAqXG5cdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQG1ldGhvZCBfdmFsaWRhdGVBbGxvd2VkQ29udGVudFxuXHRcdCAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY2hlY2tlZFxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIGN1cnJlbnQgdmFsdWUgaXMgdmFsaWQgY29uZmlndXJhdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlXG5cdFx0ICovXG5cdFx0X3ZhbGlkYXRlQWxsb3dlZENvbnRlbnQodmFsdWUpIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdExhbmcuaXNTdHJpbmcodmFsdWUpIHx8XG5cdFx0XHRcdExhbmcuaXNPYmplY3QodmFsdWUpIHx8XG5cdFx0XHRcdExhbmcuaXNCb29sZWFuKHZhbHVlKVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVmFsaWRhdGVzIHRoZSB2YWx1ZSBvZiB0b29sYmFycyBhdHRyaWJ1dGVcblx0XHQgKlxuXHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBtZXRob2QgX3ZhbGlkYXRlVG9vbGJhcnNcblx0XHQgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIGNoZWNrZWRcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBjdXJyZW50IHZhbHVlIGlzIHZhbGlkIHRvb2xiYXJzIGNvbmZpZ3VyYXRpb24sIGZhbHNlIG90aGVyd2lzZVxuXHRcdCAqL1xuXHRcdF92YWxpZGF0ZVRvb2xiYXJzKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gTGFuZy5pc09iamVjdCh2YWx1ZSkgfHwgTGFuZy5pc051bGwodmFsdWUpO1xuXHRcdH0sXG5cdH0sXG5cdHtcblx0XHRBVFRSUzoge1xuXHRcdFx0LyoqXG5cdFx0XHQgKiBDb25maWd1cmVzIHRoZSBhbGxvd2VkIGNvbnRlbnQgZm9yIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIEFsbG95RWRpdG9yLlxuXHRcdFx0ICogTG9vayBvbiB0aGUgW29mZmljaWFsIENLRWRpdG9yIEFQSV0oaHR0cDovL2RvY3MuY2tlZGl0b3IuY29tLyMhL2FwaS9DS0VESVRPUi5jb25maWctY2ZnLWFsbG93ZWRDb250ZW50KVxuXHRcdFx0ICogZm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZhbGlkIHZhbHVlcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGVydHkgYWxsb3dlZENvbnRlbnRcblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEB3cml0ZU9uY2Vcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFuLCBTdHJpbmcsIE9iamVjdH1cblx0XHRcdCAqL1xuXHRcdFx0YWxsb3dlZENvbnRlbnQ6IHtcblx0XHRcdFx0dmFsaWRhdG9yOiAnX3ZhbGlkYXRlQWxsb3dlZENvbnRlbnQnLFxuXHRcdFx0XHR2YWx1ZTogdHJ1ZSxcblx0XHRcdFx0d3JpdGVPbmNlOiB0cnVlLFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gY2xpY2tpbmcgb24gdGhlXG5cdFx0XHQgKiA8Y29kZT5zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1saW5rLWVkaXQtYnJvd3NlLmpzeDwvY29kZT5cblx0XHRcdCAqIGNvbXBvbmVudC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGV0eSBkb2N1bWVudEJyb3dzZUxpbmtDYWxsYmFja1xuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb258dW5kZWZpbmVkfVxuXHRcdFx0ICovXG5cdFx0XHRkb2N1bWVudEJyb3dzZUxpbmtDYWxsYmFjazoge1xuXHRcdFx0XHR2YWxpZGF0b3I6IExhbmcuaXNGdW5jdGlvbixcblx0XHRcdFx0dmFsdWU6IHVuZGVmaW5lZCxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogQ29uZmlndXJhdGlvbiBmb3IgdGhlXG5cdFx0XHQgKiA8Y29kZT5zcmMvY29tcG9uZW50cy9idXR0b25zL2J1dHRvbi1saW5rLWVkaXQtYnJvd3NlLmpzeDwvY29kZT5cblx0XHRcdCAqIGNvbXBvbmVudC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGV0eSBkb2N1bWVudEJyb3dzZUxpbmtVcmxcblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuXHRcdFx0ICogQHR5cGUge1N0cmluZ3x1bmRlZmluZWR9XG5cdFx0XHQgKi9cblx0XHRcdGRvY3VtZW50QnJvd3NlTGlua1VybDoge1xuXHRcdFx0XHR2YWxpZGF0b3I6IExhbmcuaXNTdHJpbmcsXG5cdFx0XHRcdHZhbHVlOiB1bmRlZmluZWQsXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIExpc3Qgb2YgZW1iZWQgcHJvdmlkZXJzIGZvciB2aWRlb3Ncblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGVydHkgZW1iZWRQcm92aWRlcnNcblx0XHRcdCAqIEBkZWZhdWx0IFtdXG5cdFx0XHQgKiBAdHlwZSBBcnJheX1cblx0XHRcdCAqL1xuXHRcdFx0ZW1iZWRQcm92aWRlcnM6IHtcblx0XHRcdFx0dmFsaWRhdG9yOiBMYW5nLmlzQXJyYXksXG5cdFx0XHRcdHZhbHVlOiBbXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWQ6ICdmYWNlYm9vaycsXG5cdFx0XHRcdFx0XHR0cGw6IGA8aWZyYW1lIGFsbG93RnVsbFNjcmVlbj1cInRydWVcIiBhbGxvd1RyYW5zcGFyZW5jeT1cInRydWVcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0IGZyYW1lYm9yZGVyPVwiMFwiIGhlaWdodD1cIiR7RU1CRURfVklERU9fSEVJR0hUfVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgc3JjPVwiaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL3BsdWdpbnMvdmlkZW8ucGhwP2hyZWY9e2VtYmVkSWR9J1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICZzaG93X3RleHQ9MCZ3aWR0aD0ke0VNQkVEX1ZJREVPX1dJRFRIfSZoZWlnaHQ9JHtFTUJFRF9WSURFT19IRUlHSFR9XCIgc2Nyb2xsaW5nPVwibm9cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0IHN0eWxlPVwiYm9yZGVyOm5vbmU7b3ZlcmZsb3c6aGlkZGVuXCIgd2lkdGg9XCIke0VNQkVEX1ZJREVPX1dJRFRIfX1cIj48L2lmcmFtZT5gLFxuXHRcdFx0XHRcdFx0dHlwZTogJ3ZpZGVvJyxcblx0XHRcdFx0XHRcdHVybFNjaGVtZXM6IFtcblx0XHRcdFx0XHRcdFx0JyhodHRwcz86XFxcXC9cXFxcLyg/Ond3d1xcXFwuKT9mYWNlYm9vay5jb21cXFxcL1xcXFxTKlxcXFwvdmlkZW9zXFxcXC9cXFxcUyopJyxcblx0XHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZDogJ3R3aXRjaCcsXG5cdFx0XHRcdFx0XHR0cGw6IGA8aWZyYW1lIGFsbG93ZnVsbHNjcmVlbj1cInRydWVcIiBmcmFtZWJvcmRlcj1cIjBcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0IGhlaWdodD1cIiR7RU1CRURfVklERU9fSEVJR0hUfVwiXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgc3JjPVwiaHR0cHM6Ly9wbGF5ZXIudHdpdGNoLnR2Lz9hdXRvcGxheT1mYWxzZSZ2aWRlbz17ZW1iZWRJZH1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0IHNjcm9sbGluZz1cIm5vXCIgd2lkdGg9XCIke0VNQkVEX1ZJREVPX1dJRFRIfVwiPjwvaWZyYW1lPmAsXG5cdFx0XHRcdFx0XHR0eXBlOiAndmlkZW8nLFxuXHRcdFx0XHRcdFx0dXJsU2NoZW1lczogW1xuXHRcdFx0XHRcdFx0XHQnaHR0cHM/OlxcXFwvXFxcXC8oPzp3d3dcXFxcLik/dHdpdGNoLnR2XFxcXC92aWRlb3NcXFxcLyhcXFxcUyopJCcsXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWQ6ICd2aW1lbycsXG5cdFx0XHRcdFx0XHR0cGw6IGA8aWZyYW1lIGFsbG93ZnVsbHNjcmVlbiBmcmFtZWJvcmRlcj1cIjBcIiBoZWlnaHQ9XCIke0VNQkVEX1ZJREVPX0hFSUdIVH1cIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0IG1vemFsbG93ZnVsbHNjcmVlbiBzcmM9XCJodHRwczovL3BsYXllci52aW1lby5jb20vdmlkZW8ve2VtYmVkSWR9XCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCB3ZWJraXRhbGxvd2Z1bGxzY3JlZW4gd2lkdGg9XCIke0VNQkVEX1ZJREVPX1dJRFRIfVwiPjwvaWZyYW1lPmAsXG5cdFx0XHRcdFx0XHR0eXBlOiAndmlkZW8nLFxuXHRcdFx0XHRcdFx0dXJsU2NoZW1lczogW1xuXHRcdFx0XHRcdFx0XHQnaHR0cHM/OlxcXFwvXFxcXC8oPzp3d3dcXFxcLik/dmltZW9cXFxcLmNvbVxcXFwvYWxidW1cXFxcLy4qXFxcXC92aWRlb1xcXFwvKFxcXFxTKiknLFxuXHRcdFx0XHRcdFx0XHQnaHR0cHM/OlxcXFwvXFxcXC8oPzp3d3dcXFxcLik/dmltZW9cXFxcLmNvbVxcXFwvY2hhbm5lbHNcXFxcLy4qXFxcXC8oXFxcXFMqKScsXG5cdFx0XHRcdFx0XHRcdCdodHRwcz86XFxcXC9cXFxcLyg/Ond3d1xcXFwuKT92aW1lb1xcXFwuY29tXFxcXC9ncm91cHNcXFxcLy4qXFxcXC92aWRlb3NcXFxcLyhcXFxcUyopJyxcblx0XHRcdFx0XHRcdFx0J2h0dHBzPzpcXFxcL1xcXFwvKD86d3d3XFxcXC4pP3ZpbWVvXFxcXC5jb21cXFxcLyhcXFxcUyopJCcsXG5cdFx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWQ6ICd5b3V0dWJlJyxcblx0XHRcdFx0XHRcdHRwbDogYDxpZnJhbWUgYWxsb3c9XCJhdXRvcGxheTsgZW5jcnlwdGVkLW1lZGlhXCIgYWxsb3dmdWxsc2NyZWVuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgaGVpZ2h0PVwiJHtFTUJFRF9WSURFT19IRUlHSFR9XCIgZnJhbWVib3JkZXI9XCIwXCJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCBzcmM9XCJodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC97ZW1iZWRJZH0/cmVsPTBcIlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0IHdpZHRoPVwiJHtFTUJFRF9WSURFT19XSURUSH1cIj48L2lmcmFtZT5gLFxuXHRcdFx0XHRcdFx0dHlwZTogJ3ZpZGVvJyxcblx0XHRcdFx0XHRcdHVybFNjaGVtZXM6IFtcblx0XHRcdFx0XHRcdFx0J2h0dHBzPzpcXFxcL1xcXFwvKD86d3d3XFxcXC4pP3lvdXR1YmUuY29tXFxcXC93YXRjaFxcXFw/dj0oXFxcXFMqKSQnLFxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRdLFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTcGVjaWZpZXMgd2hldGhlciBBbGxveUVkaXRvciBzZXQgdGhlIGNvbnRlbnRlZGl0YWJsZSBhdHRyaWJ1dGVcblx0XHRcdCAqIHRvIFwidHJ1ZVwiIG9uIGl0cyBzcmNOb2RlLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSBlbmFibGVDb250ZW50RWRpdGFibGVcblx0XHRcdCAqIEB0eXBlIEJvb2xlYW5cblx0XHRcdCAqIEBkZWZhdWx0IHRydWVcblx0XHRcdCAqIEB3cml0ZU9uY2Vcblx0XHRcdCAqL1xuXHRcdFx0ZW5hYmxlQ29udGVudEVkaXRhYmxlOiB7XG5cdFx0XHRcdHZhbGlkYXRvcjogTGFuZy5pc0Jvb2xlYW4sXG5cdFx0XHRcdHZhbHVlOiB0cnVlLFxuXHRcdFx0XHR3cml0ZU9uY2U6IHRydWUsXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBkZWxheSAodGltZW91dCksIGluIG1zLCBhZnRlciB3aGljaCBldmVudHMgc3VjaCBsaWtlIGtleSBvciBtb3VzZSBldmVudHMgd2lsbCBiZSBwcm9jZXNzZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BlcnR5IGV2ZW50c0RlbGF5XG5cdFx0XHQgKiBAdHlwZSB7TnVtYmVyfVxuXHRcdFx0ICovXG5cdFx0XHRldmVudHNEZWxheToge1xuXHRcdFx0XHR2YWxpZGF0b3I6IExhbmcuaXNOdW1iZXIsXG5cdFx0XHRcdHZhbHVlOiAxMDAsXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBsaXN0IG9mIGV4dHJhIGNvbW1hbmRzIHRvIGJlIGFkZGVkIHRvIHRoZSBlZGl0b3IuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BlcnR5IGV4dHJhQ29tbWFuZHNcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XG5cdFx0XHQgKi9cblx0XHRcdGV4dHJhQ29tbWFuZHM6IHtcblx0XHRcdFx0dmFsaWRhdG9yOiBMYW5nLmlzT2JqZWN0LFxuXHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdHJlbW92ZUltYWdlOiByZW1vdmVJbWFnZUNvbW1hbmQsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdyaXRlT25jZTogdHJ1ZSxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU3BlY2lmaWVzIHRoZSBleHRyYSBwbHVnaW5zIHdoaWNoIGhhdmUgdG8gYmUgbG9hZGVkIHRvIHRoZSBjdXJyZW50IENLRWRpdG9yIGluc3RhbmNlIGluIG9yZGVyIHRvXG5cdFx0XHQgKiBtYWtlIEFsbG95RWRpdG9yIHRvIHdvcmsgcHJvcGVybHkuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BlcnR5IGV4dHJhUGx1Z2luc1xuXHRcdFx0ICogQGRlZmF1bHQgJ3VpY29yZSxzZWxlY3Rpb25yZWdpb24sZHJhZ3Jlc2l6ZSxhZGRpbWFnZXMscGxhY2Vob2xkZXIsdGFibGV0b29scyx0YWJsZXJlc2l6ZSxhdXRvbGluaydcblx0XHRcdCAqIEB3cml0ZU9uY2Vcblx0XHRcdCAqIEB0eXBlIHtTdHJpbmd9XG5cdFx0XHQgKi9cblx0XHRcdGV4dHJhUGx1Z2luczoge1xuXHRcdFx0XHR2YWxpZGF0b3I6IExhbmcuaXNTdHJpbmcsXG5cdFx0XHRcdHZhbHVlOlxuXHRcdFx0XHRcdCdhZV91aWNvcmUsYWVfc2VsZWN0aW9ucmVnaW9uLGFlX3NlbGVjdGlvbmtleXN0cm9rZXMsYWVfaW1hZ2VhbGlnbm1lbnQsYWVfYWRkaW1hZ2VzLGFlX3BsYWNlaG9sZGVyLCcgK1xuXHRcdFx0XHRcdCdhZV90YWJsZXRvb2xzLGFlX3RhYmxlcmVzaXplLGFlX2F1dG9saW5rLGFlX2VtYmVkLGFlX2F1dG9saXN0LGFlX2RyYWdyZXNpemUsJyArXG5cdFx0XHRcdFx0J2FlX3VpYnJpZGdlLGFlX3JpY2hjb21ib2JyaWRnZSxhZV9wYW5lbG1lbnVidXR0b25icmlkZ2UsYWVfbWVudWJyaWRnZSxhZV9tZW51YnV0dG9uYnJpZGdlLGFlX2J1dHRvbmJyaWRnZSxmb250LGNvbG9yYnV0dG9uJyxcblx0XHRcdFx0d3JpdGVPbmNlOiB0cnVlLFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTcGVjaWZpZXMgdGhlIFwibW9kZVwiIGZvciBhbGxveSBlZGl0b3Jcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSBtb2RlXG5cdFx0XHQgKiBAZGVmYXVsdCAnc2ltcGxlJ1xuXHRcdFx0ICogQHdyaXRlT25jZVxuXHRcdFx0ICogQHR5cGUge1N0cmluZ31cblx0XHRcdCAqL1xuXHRcdFx0bW9kZToge1xuXHRcdFx0XHR2YWxpZGF0b3I6IExhbmcuaXNTdHJpbmcsXG5cdFx0XHRcdHZhbHVlOiAnc2ltcGxlJyxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0cmlldmVzIHRoZSBuYXRpdmUgQ0tFZGl0b3IgaW5zdGFuY2UuIEhhdmluZyB0aGlzLCB0aGUgZGV2ZWxvcGVyIG1heSB1c2UgdGhlIGZ1bGwgQVBJIG9mIENLRWRpdG9yLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSBuYXRpdmVFZGl0b3Jcblx0XHRcdCAqIEByZWFkT25seVxuXHRcdFx0ICogQHR5cGUge09iamVjdH1cblx0XHRcdCAqL1xuXHRcdFx0bmF0aXZlRWRpdG9yOiB7XG5cdFx0XHRcdGdldHRlcjogJ19nZXROYXRpdmVFZGl0b3InLFxuXHRcdFx0XHRyZWFkT25seTogdHJ1ZSxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU3BlY2lmaWVzIHRoZSBjbGFzcywgd2hpY2ggc2hvdWxkIGJlIGFkZGVkIGJ5IFBsYWNlaG9sZGVyIHBsdWdpblxuXHRcdFx0ICoge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9wbGFjZWhvbGRlcn19e3svY3Jvc3NMaW5rfX1cblx0XHRcdCAqIHdoZW4gZWRpdG9yIGlzIG5vdCBmb2N1c2VkLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZW1iZXJvZiBDb3JlXG5cdFx0XHQgKiBAaW5zdGFuY2Vcblx0XHRcdCAqIEBwcm9wZXJ0eSBwbGFjZWhvbGRlckNsYXNzXG5cdFx0XHQgKiBAZGVmYXVsdCAnYWUtcGxhY2Vob2xkZXInXG5cdFx0XHQgKiBAd3JpdGVPbmNlXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICovXG5cdFx0XHRwbGFjZWhvbGRlckNsYXNzOiB7XG5cdFx0XHRcdHZhbGlkYXRvcjogTGFuZy5pc1N0cmluZyxcblx0XHRcdFx0dmFsdWU6ICdhZS1wbGFjZWhvbGRlcicsXG5cdFx0XHRcdHdyaXRlT25jZTogdHJ1ZSxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogU3BlY2lmaWVzIHRoZSBwbHVnaW5zLCB3aGljaCBjb21lIGJ5IGRlZmF1bHQgd2l0aCBDS0VkaXRvciwgYnV0IHdoaWNoIGFyZSBub3QgbmVlZGVkIGJ5IEFsbG95RWRpdG9yLlxuXHRcdFx0ICogVGhlc2UgcGx1Z2lucyBhZGQgdGhlIGRlZmF1bHQgVUkgZm9yIENLZWRpdG9yLCB3aGljaCBpcyBubyBtb3JlIG5lZWRlZC4gUGxlYXNlIG5vdGUgdGhhdCBBbGxveUVkdG9yXG5cdFx0XHQgKiBjb21lcyB3aXRoIGl0cyBvd24gaGlnaGx5IG9wdGltaXplZCBjb3B5IG9mIENLRWRpdG9yIChqdXN0IGN1c3RvbWl6ZWQgdmlhIHRoZWlyIG9mZmljaWFsIGRvd25sb2FkIHBhZ2UpLlxuXHRcdFx0ICogVGhpcyB2ZXJzaW9uIGRvZXMgbm90IGNvbWUgd2l0aCB0aGUgdW5uZWVkZWQgcGx1Z2lucywgc28gdGhlIHZhbHVlIG9mIHRoaXMgcHJvcGVydHkgd29uJ3QgYmUgbmVlZGVkLlxuXHRcdFx0ICogSG93ZXZlciwgaWYgeW91IGRlY2lkZSB0byBnbyB3aXRoIHRoZSBPT1RCIHZlcnNpb24gb2YgQ0tFZGl0b3IsIHlvdSB3aWxsIGhhdmUgdG8gcmVtb3ZlIHNvbWUgb2YgdGhlXG5cdFx0XHQgKiBwbHVnaW5zIGlmIHlvdSBkZWNpZGUgdG8gdXNlIEFsbG95RWRpdG9yLiBLZWVwIGluIG1pbmQgdGhhdCByZW1vdmluZyB0aGVzZSBwbHVnaW5zIGRvZXNuJ3QgcmVtb3ZlIHRoZW1cblx0XHRcdCAqIGVudGlyZWx5IGZyb20gQ0tFZGl0b3IuIEl0IGp1c3QgcmVtb3ZlcyB0aGVtIGZyb20gaXRzIGN1cnJlbnQgaW5zdGFuY2UsIGluIHdoaWNoIHlvdSB3aWxsIHVzZSBkaWZmZXJlbnRcblx0XHRcdCAqIFVJIC0gdGhvc2Ugb2YgQWxsb3lFZGl0b3IuIFlvdSB3aWxsIGJlIGZ1bGx5IGFibGUgdG8gdXNlIGJvdGggT09UQiBDS0VkaXRvciBhbmQgQWxsb3lFZGl0b3Igb24gdGhlIHNhbWVcblx0XHRcdCAqIHBhZ2UhXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BlcnR5IHJlbW92ZVBsdWdpbnNcblx0XHRcdCAqIEBkZWZhdWx0ICdjb250ZXh0bWVudSx0b29sYmFyLGVsZW1lbnRzcGF0aCxyZXNpemUsbGlzdHN0eWxlLGxpbmsnXG5cdFx0XHQgKiBAd3JpdGVPbmNlXG5cdFx0XHQgKiBAdHlwZSB7U3RyaW5nfVxuXHRcdFx0ICovXG5cdFx0XHRyZW1vdmVQbHVnaW5zOiB7XG5cdFx0XHRcdHZhbGlkYXRvcjogTGFuZy5pc1N0cmluZyxcblx0XHRcdFx0dmFsdWU6ICdjb250ZXh0bWVudSx0b29sYmFyLGVsZW1lbnRzcGF0aCxyZXNpemUsbGlzdHN0eWxlLGxpbmsnLFxuXHRcdFx0XHR3cml0ZU9uY2U6IHRydWUsXG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFycmF5IG9mIG1hbnVhbCBzZWxlY3Rpb24gdHJpZ2dlcnMuIFRoZXkgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gbWFudWFsbHkgc2hvdyBhIHNwZWNpZmljIHNlbGVjdGlvbiB0b29sYmFyXG5cdFx0XHQgKiBieSBmb3JjaW5nIHRoZSBzZWxlY3Rpb24gdHlwZS4gQSBzZWxlY3Rpb25LZXlzdHJva2UgaXRlbSBjb25zaXN0cyBvZiBhIGtleXMgcHJvcGVydHkgd2l0aCBhIFtDS0VkaXRvciBrZXlzdHJva2Vcblx0XHRcdCAqIGRlZmluaXRpb25dKGh0dHA6Ly9kb2NzLmNrZWRpdG9yLmNvbS8jIS9hcGkvQ0tFRElUT1IuY29uZmlnLWNmZy1rZXlzdHJva2VzKSBhbmQgYSBzZWxlY3Rpb24gcHJvcGVydHkgd2l0aFxuXHRcdFx0ICogdGhlIHNlbGVjdGlvbiBuYW1lIHRvIHRyaWdnZXIuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BlcnR5IHNlbGVjdGlvbktleXN0cm9rZXNcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHRcdCAqL1xuXHRcdFx0c2VsZWN0aW9uS2V5c3Ryb2tlczoge1xuXHRcdFx0XHR2YWxpZGF0b3I6IExhbmcuaXNBcnJheSxcblx0XHRcdFx0dmFsdWU6IFtcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRrZXlzOiBDS0VESVRPUi5DVFJMICsgNzYgLyogTCovLFxuXHRcdFx0XHRcdFx0c2VsZWN0aW9uOiAnbGluaycsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRrZXlzOiBDS0VESVRPUi5DVFJMICsgQ0tFRElUT1IuU0hJRlQgKyA3NiAvKiBMKi8sXG5cdFx0XHRcdFx0XHRzZWxlY3Rpb246ICdlbWJlZCcsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XSxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIHBhdGggdG8gdGhlIHNwcml0ZW1hcCBTVkcgdXNlZCBmb3IgaWNvbnNcblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGVydHkgc3ByaXRlbWFwXG5cdFx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHRcdCAqIEB3cml0ZU9uY2Vcblx0XHRcdCAqL1xuXHRcdFx0c3ByaXRlbWFwOiB7XG5cdFx0XHRcdHZhbGlkYXRvcjogTGFuZy5pc1N0cmluZyxcblx0XHRcdFx0dmFsdWU6ICdhbGxveS1lZGl0b3IvYXNzZXRzL2ljb25zL2ljb25zLnN2ZycsXG5cdFx0XHRcdHdyaXRlT25jZTogdHJ1ZSxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIE5vZGUgSUQgb3IgSFRNbCBub2RlLCB3aGljaCBBbGxveUVkaXRvciBzaG91bGQgdXNlIGFzIGFuIGVkaXRhYmxlIGFyZWEuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1lbWJlcm9mIENvcmVcblx0XHRcdCAqIEBpbnN0YW5jZVxuXHRcdFx0ICogQHByb3BlcnR5IHNyY05vZGVcblx0XHRcdCAqIEB0eXBlIFN0cmluZyB8IE5vZGVcblx0XHRcdCAqIEB3cml0ZU9uY2Vcblx0XHRcdCAqL1xuXHRcdFx0c3JjTm9kZToge1xuXHRcdFx0XHRzZXR0ZXI6ICdfdG9FbGVtZW50Jyxcblx0XHRcdFx0d3JpdGVPbmNlOiB0cnVlLFxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBUaGUgdG9vbGJhcnMgY29uZmlndXJhdGlvbiBmb3IgdGhpcyBlZGl0b3IgaW5zdGFuY2Vcblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGVydHkge09iamVjdH0gdG9vbGJhcnNcblx0XHRcdCAqL1xuXHRcdFx0dG9vbGJhcnM6IHtcblx0XHRcdFx0dmFsaWRhdG9yOiAnX3ZhbGlkYXRlVG9vbGJhcnMnLFxuXHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdGFkZDoge1xuXHRcdFx0XHRcdFx0YnV0dG9uczogW1xuXHRcdFx0XHRcdFx0XHQnaW1hZ2VGcm9tRmlsZScsXG5cdFx0XHRcdFx0XHRcdCdlbWJlZCcsXG5cdFx0XHRcdFx0XHRcdCdjYW1lcmEnLFxuXHRcdFx0XHRcdFx0XHQnaGxpbmUnLFxuXHRcdFx0XHRcdFx0XHQndGFibGUnLFxuXHRcdFx0XHRcdFx0XSxcblx0XHRcdFx0XHRcdHRhYkluZGV4OiAyLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVzOiB7XG5cdFx0XHRcdFx0XHRzZWxlY3Rpb25zOiBTZWxlY3Rpb25zLFxuXHRcdFx0XHRcdFx0dGFiSW5kZXg6IDEsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSxcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogVGhlIE5vZGUgSUQgb3IgSFRNbCBub2RlLCB3aGVyZSBBbGxveUVkaXRvcidzIFVJIHNob3VsZCBiZSByZW5kZXJlZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWVtYmVyb2YgQ29yZVxuXHRcdFx0ICogQGluc3RhbmNlXG5cdFx0XHQgKiBAcHJvcGVydHkgdWlOb2RlXG5cdFx0XHQgKiBAdHlwZSBTdHJpbmcgfCBOb2RlXG5cdFx0XHQgKiBAd3JpdGVPbmNlXG5cdFx0XHQgKi9cblx0XHRcdHVpTm9kZToge1xuXHRcdFx0XHRzZXR0ZXI6ICdfdG9FbGVtZW50Jyxcblx0XHRcdFx0d3JpdGVPbmNlOiB0cnVlLFxuXHRcdFx0fSxcblx0XHR9LFxuXHR9XG4pO1xuXG5DS0VESVRPUi5ldmVudC5pbXBsZW1lbnRPbihDb3JlKTtcblxuZXhwb3J0IGRlZmF1bHQgQ29yZTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogUmVhY3QgY29udGV4dCB0byBhdm9pZCBleHBsaWNpdGx5IHBhc3NpbmcgdGhlIGVkaXRvciBpbnN0YW5jZSBhbGxcbiAqIHRocm91Z2ggdGhlIGNvbXBvbmVudCBoaWVyYXJjaHkgdmlhIHByb3BzLlxuICovXG5jb25zdCBFZGl0b3JDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcGFzc2VzIHRoZSBlZGl0b3IgY29udGV4dCBpbiB2aWEgYSBwcm9wLlxuICpcbiAqIENvbnRleHQgY2FuIG9ubHkgYmUgYWNjZXNzZWQgaW4gYHJlbmRlcigpYCBhbmQgaW4gbGlmZWN5Y2xlIG1ldGhvZHNcbiAqIChgY29tcG9uZW50RGlkTW91bnQoKWAgZXRjKS4gSWYgYSBjb21wb25lbnQgbmVlZHMgdG8gYWNjZXNzIGNvbnRleHRcbiAqIGVsc2V3aGVyZSwgc3VjaCBhcyBpbiBhIGNvbnN0cnVjdG9yLCB0aGUgY29udGV4dCBuZWVkcyB0byBiZSBwYXNzZWRcbiAqIGluIHZpYSBhIHByb3AuXG4gKi9cbkVkaXRvckNvbnRleHQudG9Qcm9wcyA9IENvbXBvbmVudCA9PiB7XG5cdGNvbnN0IGZvcndhcmRpbmdDb21wb25lbnQgPSBSZWFjdC5mb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiAoXG5cdFx0PEVkaXRvckNvbnRleHQuQ29uc3VtZXI+XG5cdFx0XHR7Y29udGV4dCA9PiA8Q29tcG9uZW50IHsuLi5wcm9wc30gY29udGV4dD17Y29udGV4dH0gcmVmPXtyZWZ9IC8+fVxuXHRcdDwvRWRpdG9yQ29udGV4dC5Db25zdW1lcj5cblx0KSk7XG5cdGZvcndhcmRpbmdDb21wb25lbnQua2V5ID0gQ29tcG9uZW50LmtleTtcblx0cmV0dXJuIGZvcndhcmRpbmdDb21wb25lbnQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFZGl0b3JDb250ZXh0O1xuIiwiaW1wb3J0IENvcmUgZnJvbSAnLi9jb3JlJztcbmltcG9ydCBMYW5nIGZyb20gJy4uL29vcC9sYW5nJztcblxuaW1wb3J0IEJ1dHRvbnMgZnJvbSAnLi4vY29tcG9uZW50cy9idXR0b25zJztcbmltcG9ydCBUb29sYmFycyBmcm9tICcuLi9jb21wb25lbnRzL3Rvb2xiYXJzJztcblxuaW1wb3J0IFNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcyBmcm9tICcuLi9zZWxlY3Rpb25zL3NlbGVjdGlvbi1hcnJvd2JveCc7XG5pbXBvcnQgU2VsZWN0aW9ucyBmcm9tICcuLi9zZWxlY3Rpb25zL3NlbGVjdGlvbnMnO1xuaW1wb3J0IFNlbGVjdGlvblNldFBvc2l0aW9uIGZyb20gJy4uL3NlbGVjdGlvbnMvc2VsZWN0aW9uLXBvc2l0aW9uJztcbmltcG9ydCBTZWxlY3Rpb25UZXN0IGZyb20gJy4uL3NlbGVjdGlvbnMvc2VsZWN0aW9uLXRlc3QnO1xuXG5pbXBvcnQgQXR0cmlidXRlIGZyb20gJy4uL29vcC9hdHRyaWJ1dGUnO1xuaW1wb3J0IGV4dGVuZCBmcm9tICcuLi9vb3Avb29wJztcbmltcG9ydCAnLi4vcGx1Z2lucyc7XG5cbi8vIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBjdXJyZW50bHkgcmVnaXN0ZXJlZCBwbHVnaW5zIGluIEFsbG95RWRpdG9yLlxuY29uc3QgQlJJREdFX0JVVFRPTlMgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEFsbG95RWRpdG9yLlxuICpcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICogQG1ldGhvZCBlZGl0YWJsZVxuICogQHN0YXRpY1xuICogQHBhcmFtIHtTdHJpbmd8Tm9kZX0gbm9kZSBUaGUgTm9kZSBJRCBvciBIVE1sIG5vZGUsIHdoaWNoIEFsbG95RWRpdG9yIHNob3VsZCB1c2UgYXMgYW4gZWRpdGFibGUgYXJlYS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBhdHRyaWJ1dGVzIGZvciB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiBBbGxveUVkaXRvci5cbiAqIEByZXR1cm4ge09iamVjdH0gQW4gaW5zdGFuY2Ugb2Yge3sjY3Jvc3NMaW5rIFwiQ29yZVwifX17ey9jcm9zc0xpbmt9fVxuICovXG5jb25zdCBlZGl0YWJsZSA9IGZ1bmN0aW9uKG5vZGUsIGNvbmZpZykge1xuXHRjb25maWcgPSBjb25maWcgfHwge307XG5cdGNvbmZpZy5zcmNOb2RlID0gbm9kZTtcblxuXHRBbGxveUVkaXRvci5pbXBsZW1lbnRFdmVudFRhcmdldCgpO1xuXG5cdHJldHVybiBuZXcgQ29yZShjb25maWcpO1xufTtcblxuLyoqXG4gKiBUaGUgZnVsbCBVUkwgZm9yIHRoZSBBbGxveUVkaXRvciBpbnN0YWxsYXRpb24gZGlyZWN0b3J5LlxuICogSXQgaXMgcG9zc2libGUgdG8gbWFudWFsbHkgcHJvdmlkZSB0aGUgYmFzZSBwYXRoIGJ5IHNldHRpbmcgYVxuICogZ2xvYmFsIHZhcmlhYmxlIG5hbWVkIGBBTExPWUVESVRPUl9CQVNFUEFUSGAuIFRoaXMgZ2xvYmFsIHZhcmlhYmxlXG4gKiBtdXN0IGJlIHNldCAqKmJlZm9yZSoqIHRoZSBlZGl0b3Igc2NyaXB0IGxvYWRpbmcuXG4gKlxuICogQG1lbWJlcm9mIEFsbG95RWRpdG9yXG4gKiBAbWV0aG9kIGdldEJhc2VQYXRoXG4gKiBAc3RhdGljXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBmb3VuZCBiYXNlIHBhdGhcbiAqL1xuY29uc3QgZ2V0QmFzZVBhdGggPSBmdW5jdGlvbigpIHtcblx0Ly8gRmluZCBvdXQgdGhlIGVkaXRvciBkaXJlY3RvcnkgcGF0aCwgYmFzZWQgb24gaXRzIDxzY3JpcHQ+IHRhZy5cblx0bGV0IHBhdGggPSB3aW5kb3cuQUxMT1lFRElUT1JfQkFTRVBBVEggfHwgJyc7XG5cblx0aWYgKCFwYXRoKSB7XG5cdFx0Y29uc3Qgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgbWF0Y2ggPSBzY3JpcHRzW2ldLnNyYy5tYXRjaChBbGxveUVkaXRvci5yZWdleEJhc2VQYXRoKTtcblxuXHRcdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRcdHBhdGggPSBtYXRjaFsxXTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gSW4gSUUgKG9ubHkpIHRoZSBzY3JpcHQuc3JjIHN0cmluZyBpcyB0aGUgcmF3IHZhbHVlIGVudGVyZWQgaW4gdGhlXG5cdC8vIEhUTUwgc291cmNlLiBPdGhlciBicm93c2VycyByZXR1cm4gdGhlIGZ1bGwgcmVzb2x2ZWQgVVJMIGluc3RlYWQuXG5cdGlmIChwYXRoLmluZGV4T2YoJzovJykgPT09IC0xICYmIHBhdGguc2xpY2UoMCwgMikgIT09ICcvLycpIHtcblx0XHQvLyBBYnNvbHV0ZSBwYXRoLlxuXHRcdGlmIChwYXRoLmluZGV4T2YoJy8nKSA9PT0gMCkge1xuXHRcdFx0cGF0aCA9IGxvY2F0aW9uLmhyZWYubWF0Y2goL14uKj86XFwvXFwvW14vXSovKVswXSArIHBhdGg7XG5cdFx0fVxuXHRcdC8vIFJlbGF0aXZlIHBhdGguXG5cdFx0ZWxzZSB7XG5cdFx0XHRwYXRoID0gbG9jYXRpb24uaHJlZi5tYXRjaCgvXlteP10qXFwvKD86KS8pWzBdICsgcGF0aDtcblx0XHR9XG5cdH1cblxuXHRpZiAoIXBhdGgpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHQnVGhlIEFsbG95RWRpdG9yIGluc3RhbGxhdGlvbiBwYXRoIGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGRldGVjdGVkLiBQbGVhc2Ugc2V0IHRoZSBnbG9iYWwgdmFyaWFibGUgXCJBTExPWUVESVRPUl9CQVNFUEFUSFwiIGJlZm9yZSBjcmVhdGluZyBlZGl0b3IgaW5zdGFuY2VzLidcblx0XHQpO1xuXHR9XG5cblx0cmV0dXJuIHBhdGg7XG59O1xuXG4vKipcbiAqIERldGVjdHMgYW5kIGxvYWQgdGhlIGNvcnJlc3BvbmRpbmcgbGFuZ3VhZ2UgZmlsZSBpZiBBbGxveUVkaXRvciBsYW5ndWFnZSBzdHJpbmdzIGFyZSBub3QgYWxyZWFkeSBwcmVzZW50LlxuICogVGhlIGZ1bmN0aW9uIGZpcmVzIGEge3sjY3Jvc3NMaW5rIFwiQWxsb3lFZGl0b3IvbGFuZ3VhZ2VSZXNvdXJjZXNMb2FkZWQ6ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnRcbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgbG9hZExhbmd1YWdlUmVzb3VyY2VzXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBPcHRpb25hbCBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiBBbGxveUVkaXRvciBsb2FkcyB0aGUgbGFuZ3VhZ2UgcmVzb3VyY2UuXG4gKi9cbmNvbnN0IGxvYWRMYW5ndWFnZVJlc291cmNlcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdEFsbG95RWRpdG9yLmltcGxlbWVudEV2ZW50VGFyZ2V0KCk7XG5cblx0aWYgKExhbmcuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcblx0XHRpZiAoQWxsb3lFZGl0b3IuU3RyaW5ncykge1xuXHRcdFx0c2V0VGltZW91dChjYWxsYmFjaywgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFsbG95RWRpdG9yLm9uY2UoJ2xhbmd1YWdlUmVzb3VyY2VzTG9hZGVkJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCFBbGxveUVkaXRvci5fbGFuZ1Jlc291cmNlUmVxdWVzdGVkKSB7XG5cdFx0QWxsb3lFZGl0b3IuX2xhbmdSZXNvdXJjZVJlcXVlc3RlZCA9IHRydWU7XG5cblx0XHRjb25zdCBsYW5ndWFnZXMgPSBbXG5cdFx0XHQnYWYnLFxuXHRcdFx0J2FyJyxcblx0XHRcdCdiZycsXG5cdFx0XHQnYm4nLFxuXHRcdFx0J2JzJyxcblx0XHRcdCdjYScsXG5cdFx0XHQnY3MnLFxuXHRcdFx0J2N5Jyxcblx0XHRcdCdkYScsXG5cdFx0XHQnZGUnLFxuXHRcdFx0J2VsJyxcblx0XHRcdCdlbi1hdScsXG5cdFx0XHQnZW4tY2EnLFxuXHRcdFx0J2VuLWdiJyxcblx0XHRcdCdlbicsXG5cdFx0XHQnZW8nLFxuXHRcdFx0J2VzJyxcblx0XHRcdCdldCcsXG5cdFx0XHQnZXUnLFxuXHRcdFx0J2ZhJyxcblx0XHRcdCdmaScsXG5cdFx0XHQnZm8nLFxuXHRcdFx0J2ZyLWNhJyxcblx0XHRcdCdmcicsXG5cdFx0XHQnZ2wnLFxuXHRcdFx0J2d1Jyxcblx0XHRcdCdoZScsXG5cdFx0XHQnaGknLFxuXHRcdFx0J2hyJyxcblx0XHRcdCdodScsXG5cdFx0XHQnaWQnLFxuXHRcdFx0J2lzJyxcblx0XHRcdCdpdCcsXG5cdFx0XHQnamEnLFxuXHRcdFx0J2thJyxcblx0XHRcdCdrbScsXG5cdFx0XHQna28nLFxuXHRcdFx0J2t1Jyxcblx0XHRcdCdsdCcsXG5cdFx0XHQnbHYnLFxuXHRcdFx0J21rJyxcblx0XHRcdCdtbicsXG5cdFx0XHQnbXMnLFxuXHRcdFx0J25iJyxcblx0XHRcdCdubCcsXG5cdFx0XHQnbm8nLFxuXHRcdFx0J3BsJyxcblx0XHRcdCdwdC1icicsXG5cdFx0XHQncHQnLFxuXHRcdFx0J3JvJyxcblx0XHRcdCdydScsXG5cdFx0XHQnc2knLFxuXHRcdFx0J3NrJyxcblx0XHRcdCdzbCcsXG5cdFx0XHQnc3EnLFxuXHRcdFx0J3NyLWxhdG4nLFxuXHRcdFx0J3NyJyxcblx0XHRcdCdzdicsXG5cdFx0XHQndGgnLFxuXHRcdFx0J3RyJyxcblx0XHRcdCd0dCcsXG5cdFx0XHQndWcnLFxuXHRcdFx0J3VrJyxcblx0XHRcdCd2aScsXG5cdFx0XHQnemgtY24nLFxuXHRcdFx0J3poJyxcblx0XHRdO1xuXG5cdFx0Y29uc3QgdXNlckxhbmd1YWdlID1cblx0XHRcdG5hdmlnYXRvci5sYW5ndWFnZSB8fCBuYXZpZ2F0b3IudXNlckxhbmd1YWdlIHx8ICdlbic7XG5cblx0XHRjb25zdCBwYXJ0cyA9IHVzZXJMYW5ndWFnZVxuXHRcdFx0LnRvTG93ZXJDYXNlKClcblx0XHRcdC5tYXRjaCgvKFthLXpdKykoPzotKFthLXpdKykpPy8pO1xuXHRcdGxldCBsYW5nID0gcGFydHNbMV07XG5cdFx0Y29uc3QgbG9jYWxlID0gcGFydHNbMl07XG5cblx0XHRpZiAobGFuZ3VhZ2VzLmluZGV4T2YobGFuZyArICctJyArIGxvY2FsZSkgPj0gMCkge1xuXHRcdFx0bGFuZyA9IGxhbmcgKyAnLScgKyBsb2NhbGU7XG5cdFx0fSBlbHNlIGlmIChsYW5ndWFnZXMuaW5kZXhPZihsYW5nKSA9PT0gLTEpIHtcblx0XHRcdGxhbmcgPSAnZW4nO1xuXHRcdH1cblxuXHRcdENLRURJVE9SLnNjcmlwdExvYWRlci5sb2FkKFxuXHRcdFx0QWxsb3lFZGl0b3IuZ2V0VXJsKCdsYW5nL2FsbG95LWVkaXRvci8nICsgbGFuZyArICcuanMnKSxcblx0XHRcdGZ1bmN0aW9uKGxvYWRlZCkge1xuXHRcdFx0XHRpZiAobG9hZGVkKSB7XG5cdFx0XHRcdFx0QWxsb3lFZGl0b3IuZmlyZSgnbGFuZ3VhZ2VSZXNvdXJjZXNMb2FkZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIGJhYmVsL25vLWludmFsaWQtdGhpcyAqL1xuXHRcdFx0dGhpcyAvLyBBbHdheXMgYEFsbG95RWRpdG9yYC5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgYmFiZWwvbm8taW52YWxpZC10aGlzICovXG5cdFx0KTtcblx0fVxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBmdWxsIFVSTCBmb3IgQWxsb3lFZGl0b3IgcmVzb3VyY2VzLiBCeSBkZWZhdWx0LCBVUkxzXG4gKiByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIGNvbnRhaW4gYSBxdWVyeXN0cmluZyBwYXJhbWV0ZXIgKFwidFwiKVxuICogc2V0IHRvIHRoZSB7QGxpbmsgQ0tFRElUT1IjdGltZXN0YW1wfSB2YWx1ZS5cbiAqXG4gKiBAbWVtYmVyb2YgQWxsb3lFZGl0b3JcbiAqIEBtZXRob2QgZ2V0VXJsXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVzb3VyY2UgVGhlIHJlc291cmNlIHdob3NlIGZ1bGwgVVJMIHdlIHdhbnQgdG8gZ2V0LlxuICogSXQgbWF5IGJlIGEgZnVsbCwgYWJzb2x1dGUsIG9yIHJlbGF0aXZlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIGZ1bGwgVVJMLlxuICovXG5jb25zdCBnZXRVcmwgPSBmdW5jdGlvbihyZXNvdXJjZSkge1xuXHRjb25zdCBiYXNlUGF0aCA9IEFsbG95RWRpdG9yLmdldEJhc2VQYXRoKCk7XG5cblx0Ly8gSWYgdGhpcyBpcyBub3QgYSBmdWxsIG9yIGFic29sdXRlIHBhdGguXG5cdGlmIChyZXNvdXJjZS5pbmRleE9mKCc6LycpID09PSAtMSAmJiByZXNvdXJjZS5pbmRleE9mKCcvJykgIT09IDApIHtcblx0XHRyZXNvdXJjZSA9IGJhc2VQYXRoICsgcmVzb3VyY2U7XG5cdH1cblxuXHQvLyBBZGQgdGhlIHRpbWVzdGFtcCwgZXhjZXB0IGZvciBkaXJlY3Rvcmllcy5cblx0aWYgKFxuXHRcdENLRURJVE9SLnRpbWVzdGFtcCAmJlxuXHRcdHJlc291cmNlLmNoYXJBdChyZXNvdXJjZS5sZW5ndGggLSAxKSAhPT0gJy8nICYmXG5cdFx0IS9bJj9ddD0vLnRlc3QocmVzb3VyY2UpXG5cdCkge1xuXHRcdHJlc291cmNlICs9XG5cdFx0XHQocmVzb3VyY2UuaW5kZXhPZignPycpID49IDAgPyAnJicgOiAnPycpICtcblx0XHRcdCd0PScgK1xuXHRcdFx0Q0tFRElUT1IudGltZXN0YW1wO1xuXHR9XG5cblx0cmV0dXJuIHJlc291cmNlO1xufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGV2ZW50IGZpcmluZyBhbmQgc3Vic2NyaWJpbmcgdmlhIENLRURJVE9SLmV2ZW50LlxuICpcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICogQG1ldGhvZCBpbXBsZW1lbnRFdmVudFRhcmdldFxuICogQHN0YXRpY1xuICovXG5jb25zdCBpbXBsZW1lbnRFdmVudFRhcmdldCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIUFsbG95RWRpdG9yLmZpcmUgJiYgIUFsbG95RWRpdG9yLm9uKSB7XG5cdFx0Q0tFRElUT1IuZXZlbnQuaW1wbGVtZW50T24oQWxsb3lFZGl0b3IpO1xuXHR9XG59O1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB3aGljaCBzaG91bGQgbWF0Y2ggdGhlIHNjcmlwdCB3aGljaCBoYXZlIGJlZW4gdXNlZCB0byBsb2FkIEFsbG95RWRpdG9yLlxuICpcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICogQHByb3BlcnR5IHJlZ2V4QmFzZVBhdGhcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAc3RhdGljXG4gKi9cbmNvbnN0IHJlZ2V4QmFzZVBhdGggPSAvKF58LipbXFxcXC9dKSg/OmFsbG95LWVkaXRvclteL10rfGFsbG95LWVkaXRvcilcXC5qcyg/OlxcPy4qfDsuKik/JC9pO1xuXG4vKipcbiAqIEZpcmVkIHdoZW4gQWxsb3lFZGl0b3IgZGV0ZWN0cyB0aGUgYnJvd3NlciBsYW5ndWFnZSBhbmQgbG9hZHMgdGhlIGNvcnJlc3BvbmRpbmcgbGFuZ3VhZ2UgZmlsZS4gT25jZSB0aGlzIGV2ZW50XG4gKiBpcyBmaXJlZCwgQWxsb3lFZGl0b3IuU3RyaW5ncyB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIGRhdGEuXG4gKlxuICogQGV2ZW50IGxhbmd1YWdlUmVzb3VyY2VzTG9hZGVkXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZXF1aXJlZCBwbHVnaW4gbmFtZXMgbmVlZGVkIGZvciBhIGdpdmVuIHBsdWdpblxuICogaWYgaXQgaXMgYWxyZWFkeSByZWdpc3RlcmVkIG9yIGFuIGVtcHR5IGFycmF5LlxuICpcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICogQG1ldGhvZCBnZXRCdXR0b25zXG4gKiBAcGFyYW0ge0FycmF5fSBidXR0b25zIEFuIGFycmF5IG9mIGJ1dHRvbnMgb3IgcGx1Z2luIG5hbWVzLlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgaW52b2tlZCB0byByZXNvbHZlIHRoZSByZXF1ZXN0ZWQgYnV0dG9uIG5hbWVzLlxuICogQHN0YXRpY1xuICovXG5jb25zdCBnZXRCdXR0b25zID0gZnVuY3Rpb24oYnV0dG9ucykge1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGJ1dHRvbnMucmVkdWNlKGZ1bmN0aW9uKGFjYywgdmFsKSB7XG5cdFx0XHR2YWwgPSBCUklER0VfQlVUVE9OU1t2YWxdIHx8IFt2YWxdO1xuXHRcdFx0cmV0dXJuIGFjYy5jb25jYXQodmFsKTtcblx0XHR9LCBbXSk7XG5cdH07XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgYnV0dG9uIGFuZCB0cnkgdG8gZ2V0IGl0cyByZXF1aXJlZCBwbHVnaW5zLlxuICpcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICogQG1ldGhvZCByZWdpc3RlckJyaWRnZUJ1dHRvblxuICogQHBhcmFtIHtTdHJpbmd9IGJ1dHRvbk5hbWUgVGhlIG5hbWUgb2YgdGhlIGJ1dHRvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbHVnaW5OYW1lIFRoZSBuYW1lIG9mIHRoZSBwbHVnaW4gdGhhdCByZWdpc3RlcnMgdGhlIGJ1dHRvbi5cbiAqIEBzdGF0aWNcbiAqL1xuY29uc3QgcmVnaXN0ZXJCcmlkZ2VCdXR0b24gPSBmdW5jdGlvbihidXR0b25OYW1lLCBwbHVnaW5OYW1lKSB7XG5cdGlmICghQlJJREdFX0JVVFRPTlNbcGx1Z2luTmFtZV0pIHtcblx0XHRCUklER0VfQlVUVE9OU1twbHVnaW5OYW1lXSA9IFtdO1xuXHR9XG5cblx0QlJJREdFX0JVVFRPTlNbcGx1Z2luTmFtZV0ucHVzaChidXR0b25OYW1lKTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBPT1BcbiAqIEBtZW1iZXJvZiBBbGxveUVkaXRvclxuICovXG5jb25zdCBPT1AgPSB7XG5cdGV4dGVuZCxcbn07XG5cbmV4cG9ydCB7XG5cdEF0dHJpYnV0ZSxcblx0QnV0dG9ucyxcblx0Q29yZSxcblx0TGFuZyxcblx0T09QLFxuXHRTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXMsXG5cdFNlbGVjdGlvblNldFBvc2l0aW9uLFxuXHRTZWxlY3Rpb25UZXN0LFxuXHRTZWxlY3Rpb25zLFxuXHRUb29sYmFycyxcblx0ZWRpdGFibGUsXG5cdGdldEJhc2VQYXRoLFxuXHRnZXRCdXR0b25zLFxuXHRnZXRVcmwsXG5cdGltcGxlbWVudEV2ZW50VGFyZ2V0LFxuXHRsb2FkTGFuZ3VhZ2VSZXNvdXJjZXMsXG5cdHJlZ2V4QmFzZVBhdGgsXG5cdHJlZ2lzdGVyQnJpZGdlQnV0dG9uLFxufTtcbiIsImltcG9ydCByZW1vdmVJbWFnZUNvbW1hbmQgZnJvbSAnLi9yZW1vdmUtaW1hZ2UnO1xuXG5leHBvcnQge3JlbW92ZUltYWdlQ29tbWFuZH07XG4iLCJjb25zdCByZW1vdmVJbWFnZUNvbW1hbmQgPSB7XG5cdGV4ZWM6IGVkaXRvciA9PiB7XG5cdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0aWYgKHNlbGVjdGlvbikge1xuXHRcdFx0Y29uc3QgcmFuZ2VzID0gc2VsZWN0aW9uLmdldFJhbmdlcygpO1xuXHRcdFx0Y29uc3Qgc3RhcnRDb250YWluZXIgPSByYW5nZXNbMF0uc3RhcnRDb250YWluZXI7XG5cblx0XHRcdGNvbnN0IG5leHRSYW5nZSA9IG5ldyBDS0VESVRPUi5kb20ucmFuZ2Uoc3RhcnRDb250YWluZXIpO1xuXHRcdFx0bmV4dFJhbmdlLnNldFN0YXJ0KHN0YXJ0Q29udGFpbmVyLCAwKTtcblx0XHRcdG5leHRSYW5nZS5zZXRFbmQoc3RhcnRDb250YWluZXIsIDApO1xuXG5cdFx0XHRjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRFbGVtZW50KCk7XG5cblx0XHRcdGlmIChzZWxlY3RlZEVsZW1lbnQgJiYgc2VsZWN0ZWRFbGVtZW50LmdldE5hbWUoKSA9PT0gJ2ltZycpIHtcblx0XHRcdFx0Y29uc3QgbmF0aXZlID0gc2VsZWN0aW9uLmdldE5hdGl2ZSgpO1xuXHRcdFx0XHRpZiAobmF0aXZlKSB7XG5cdFx0XHRcdFx0bmF0aXZlLnJlbW92ZUFsbFJhbmdlcygpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2VsZWN0aW9uLnNlbGVjdFJhbmdlcyhbbmV4dFJhbmdlXSk7XG5cblx0XHRcdFx0c2VsZWN0ZWRFbGVtZW50LnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHJlbW92ZUltYWdlQ29tbWFuZDtcbiIsImltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuXG4vKipcbiAqIEJ1dHRvbkFjdGlvblN0eWxlIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBhcHBseWluZyBzdHlsZSBpbXBsZW1lbnRhdGlvbiBmb3IgYVxuICogYnV0dG9uIGJhc2VkIG9uIHRoZSBgYXBwbHlTdHlsZWAgYW5kIGByZW1vdmVTdHlsZWAgQVBJIG9mIENLRURJVE9SLlxuICpcbiAqIFRvIGV4ZWN1dGUgcHJvcGVybHksIHRoZSBjb21wb25lbnQgaGFzIHRvIGV4cG9zZSB0aGUgZm9sbG93aW5nIG1ldGhvZHMgd2hpY2ggY2FuIGJlIG9idGFpbmVkXG4gKiBvdXQgb2YgdGhlIGJveCB1c2luZyB0aGUge3sjY3Jvc3NMaW5rIFwiQnV0dG9uU3R5bGVcIn19e3svY3Jvc3NMaW5rfX0gbWl4aW46XG4gKiAtIGBGdW5jdGlvbmAge3sjY3Jvc3NMaW5rIFwiQnV0dG9uU3R5bGUvaXNBY3RpdmVcIn19e3svY3Jvc3NMaW5rfX0gdG8gY2hlY2sgdGhlIGFjdGl2ZSBzdGF0ZVxuICogLSBgRnVuY3Rpb25gIHt7I2Nyb3NzTGluayBcIkJ1dHRvblN0eWxlL2dldFN0eWxlXCJ9fXt7L2Nyb3NzTGlua319IHRvIHJldHVybiB0aGUgc3R5bGUgdGhhdCBzaG91bGQgYmUgYXBwbGllZFxuICpcbiAqIEBjbGFzcyBCdXR0b25BY3Rpb25TdHlsZVxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+XG5cdGNsYXNzIEJ1dHRvbkFjdGlvblN0eWxlIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgb3IgYXBwbGllcyB0aGUgY29tcG9uZW50IHN0eWxlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25BY3Rpb25TdHlsZVxuXHRcdCAqIEBtZXRob2QgYXBwbHlTdHlsZVxuXHRcdCAqL1xuXHRcdGFwcGx5U3R5bGUgPSAoKSA9PiB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdExhbmcuaXNGdW5jdGlvbih0aGlzLmlzQWN0aXZlKSAmJlxuXHRcdFx0XHRMYW5nLmlzRnVuY3Rpb24odGhpcy5nZXRTdHlsZSlcblx0XHRcdCkge1xuXHRcdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdFx0ZWRpdG9yLmdldFNlbGVjdGlvbigpLmxvY2soKTtcblxuXHRcdFx0XHRpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG5cdFx0XHRcdFx0ZWRpdG9yLnJlbW92ZVN0eWxlKHRoaXMuZ2V0U3R5bGUoKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWRpdG9yLmFwcGx5U3R5bGUodGhpcy5nZXRTdHlsZSgpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVkaXRvci5nZXRTZWxlY3Rpb24oKS51bmxvY2soKTtcblxuXHRcdFx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcbiIsImltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuXG4vKipcbiAqIEJ1dHRvbkNvbW1hbmRBY3RpdmUgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGFuIGBpc0FjdGl2ZWAgbWV0aG9kIHRvIGRldGVybWluZSBpZlxuICogYSBjb250ZXh0LWF3YXJlIGNvbW1hbmQgaXMgY3VycmVudGx5IGluIGFuIGFjdGl2ZSBzdGF0ZS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+XG5cdGNsYXNzIEJ1dHRvbkNvbW1hbmRBY3RpdmUgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcblx0XHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdFx0LyoqXG5cdFx0ICogQ2hlY2tzIGlmIHRoZSBjb21tYW5kIGlzIGFjdGl2ZSBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuXHRcdCAqIEBtZXRob2QgaXNBY3RpdmVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBjb21tYW5kIGlzIGFjdGl2ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHRcdCAqL1xuXHRcdGlzQWN0aXZlKCkge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRjb25zdCBjb21tYW5kID0gZWRpdG9yLmdldENvbW1hbmQodGhpcy5wcm9wcy5jb21tYW5kKTtcblxuXHRcdFx0cmV0dXJuIGNvbW1hbmQgPyBjb21tYW5kLnN0YXRlID09PSBDS0VESVRPUi5UUklTVEFURV9PTiA6IGZhbHNlO1xuXHRcdH1cblx0fTtcbiIsImltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuXG4vKipcbiAqIEJ1dHRvbkNvbW1hbmQgaXMgYSBtaXhpbiB0aGF0IGV4ZWN1dGVzIGEgY29tbWFuZCB2aWEgQ0tFRElUT1IncyBBUEkuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PlxuXHRjbGFzcyBCdXR0b25Db21tYW5kIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRcdC8qKlxuXHRcdCAqIEV4ZWN1dGVzIGEgQ0tFZGl0b3IgY29tbWFuZCBhbmQgZmlyZXMgYGFjdGlvblBlcmZvcm1lZGAgZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0PX0gZGF0YSBPcHRpb25hbCBkYXRhIHRvIGJlIHBhc3NlZCB0byBDS0VESVRPUidzIGBleGVjQ29tbWFuZGAgbWV0aG9kLlxuXHRcdCAqIEBtZXRob2QgZXhlY0NvbW1hbmRcblx0XHQgKi9cblx0XHRleGVjQ29tbWFuZCA9IGRhdGEgPT4ge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRlZGl0b3IuZXhlY0NvbW1hbmQodGhpcy5wcm9wcy5jb21tYW5kLCBkYXRhKTtcblxuXHRcdFx0aWYgKHRoaXMucHJvcHMubW9kaWZpZXNTZWxlY3Rpb24pIHtcblx0XHRcdFx0ZWRpdG9yLnNlbGVjdGlvbkNoYW5nZSh0cnVlKTtcblx0XHRcdH1cblxuXHRcdFx0ZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXHRcdH07XG5cdH07XG4iLCJpbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nJztcblxuLyoqXG4gKiBCdXR0b25LZXlzdHJva2UgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGEgYGtleXN0cm9rZWAgcHJvcCB0aGF0IGFsbG93cyBjb25maWd1cmluZ1xuICogYSBmdW5jdGlvbiBvZiB0aGUgaW5zdGFuY2UgdG8gYmUgaW52b2tlZCB1cG9uIHRoZSBrZXlzdHJva2UgYWN0aXZhdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uS2V5c3Ryb2tlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT5cblx0Y2xhc3MgQnV0dG9uS2V5c3Ryb2tlIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRcdC8qKlxuXHRcdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBib3RoIG9uIHRoZSBjbGllbnQgYW5kIHNlcnZlciwgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uS2V5c3Ryb2tlXG5cdFx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsTW91bnRcblx0XHQgKi9cblx0XHRjb21wb25lbnRXaWxsTW91bnQoKSB7XG5cdFx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKHN1cGVyLmNvbXBvbmVudFdpbGxNb3VudCkpIHtcblx0XHRcdFx0c3VwZXIuY29tcG9uZW50V2lsbE1vdW50KCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRcdGNvbnN0IGtleXN0cm9rZSA9IHRoaXMucHJvcHMua2V5c3Ryb2tlO1xuXG5cdFx0XHRjb25zdCBjb21tYW5kTmFtZSA9XG5cdFx0XHRcdGtleXN0cm9rZS5uYW1lIHx8ICgoTWF0aC5yYW5kb20oKSAqIDFlOSkgPj4+IDApLnRvU3RyaW5nKCk7XG5cblx0XHRcdGxldCBjb21tYW5kID0gbmF0aXZlRWRpdG9yLmdldENvbW1hbmQoY29tbWFuZE5hbWUpO1xuXG5cdFx0XHRpZiAoIWNvbW1hbmQpIHtcblx0XHRcdFx0Y29tbWFuZCA9IG5ldyBDS0VESVRPUi5jb21tYW5kKG5hdGl2ZUVkaXRvciwge1xuXHRcdFx0XHRcdGV4ZWM6IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0Y29uc3Qga2V5c3Ryb2tlRm4gPSBrZXlzdHJva2UuZm47XG5cblx0XHRcdFx0XHRcdGlmIChMYW5nLmlzU3RyaW5nKGtleXN0cm9rZUZuKSkge1xuXHRcdFx0XHRcdFx0XHR0aGlzW2tleXN0cm9rZUZuXS5jYWxsKHRoaXMsIGVkaXRvcik7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKExhbmcuaXNGdW5jdGlvbihrZXlzdHJva2VGbikpIHtcblx0XHRcdFx0XHRcdFx0a2V5c3Ryb2tlRm4uY2FsbCh0aGlzLCBlZGl0b3IpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0uYmluZCh0aGlzKSxcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0bmF0aXZlRWRpdG9yLmFkZENvbW1hbmQoY29tbWFuZE5hbWUsIGNvbW1hbmQpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9kZWZhdWx0S2V5c3Ryb2tlQ29tbWFuZCA9XG5cdFx0XHRcdG5hdGl2ZUVkaXRvci5rZXlzdHJva2VIYW5kbGVyLmtleXN0cm9rZXNba2V5c3Ryb2tlLmtleXNdO1xuXG5cdFx0XHRuYXRpdmVFZGl0b3Iuc2V0S2V5c3Ryb2tlKGtleXN0cm9rZS5rZXlzLCBjb21tYW5kTmFtZSk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZnJvbSB0aGUgRE9NLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbktleXN0cm9rZVxuXHRcdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcblx0XHQgKi9cblx0XHRjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbFVubW91bnQpKSB7XG5cdFx0XHRcdHN1cGVyLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuY29udGV4dC5lZGl0b3Jcblx0XHRcdFx0LmdldCgnbmF0aXZlRWRpdG9yJylcblx0XHRcdFx0LnNldEtleXN0cm9rZShcblx0XHRcdFx0XHR0aGlzLnByb3BzLmtleXN0cm9rZS5rZXlzLFxuXHRcdFx0XHRcdHRoaXMuX2RlZmF1bHRLZXlzdHJva2VDb21tYW5kXG5cdFx0XHRcdCk7XG5cdFx0fVxuXHR9O1xuIiwiaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5cbi8qKlxuICogQnV0dG9uQ2ZnUHJvcHMgaXMgYSBtaXhpbiB0aGF0IHByb3ZpZGVzIGEgc3R5bGUgcHJvcCBhbmQgc29tZSBtZXRob2RzIHRvIGFwcGx5IHRoZSByZXN1bHRpbmdcbiAqIHN0eWxlIGFuZCBjaGVja2luZyBpZiBpdCBpcyBwcmVzZW50IGluIGEgZ2l2ZW4gcGF0aCBvciBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvbkNmZ1Byb3BzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT5cblx0Y2xhc3MgQnV0dG9uQ2ZnUHJvcHMgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcblx0XHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdFx0LyoqXG5cdFx0ICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzLCBwYXNzZWQgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50IHdpdGggdXNlcidzIGNvbmZpZ3VyYXRpb25cblx0XHQgKiB2aWEgYGJ1dHRvbkNmZ2AgcHJvcGVydHkuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQ2ZnUHJvcHNcblx0XHQgKiBAbWV0aG9kIG1lcmdlQnV0dG9uQ2ZnUHJvcHNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgdG8gYmUgbWVyZ2VkIHdpdGggdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXNcblx0XHQgKiBidXR0b24uIElmIG5vdCBwYXNzZWQsIHRoZSB1c2VyIGNvbmZpZ3VyYXRpb24gd2lsbCBiZSBtZXJnZWQgd2l0aCBgdGhpcy5wcm9wc2Bcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtZXJnZWQgcHJvcGVydGllc1xuXHRcdCAqL1xuXHRcdG1lcmdlQnV0dG9uQ2ZnUHJvcHMocHJvcHMgPSB0aGlzLnByb3BzKSB7XG5cdFx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0XHRjb25zdCBidXR0b25DZmcgPSBuYXRpdmVFZGl0b3IuY29uZmlnLmJ1dHRvbkNmZyB8fCB7fTtcblx0XHRcdHJldHVybiBDS0VESVRPUi50b29scy5tZXJnZShwcm9wcywgYnV0dG9uQ2ZnWydsaW5rRWRpdCddKTtcblx0XHR9XG5cdH07XG4iLCJpbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5cbi8qKlxuICogQnV0dG9uU3RhdGVDbGFzc2VzIGlzIGEgbWl4aW4gdGhhdCBkZWNvcmF0ZXMgdGhlIGRvbUVsZW1lbnQgb2YgYSBjb21wb25lbnRcbiAqIHdpdGggZGlmZmVyZW50IENTUyBjbGFzc2VzIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50LlxuICpcbiAqIFRvIGNoZWNrIGZvciBzdGF0ZSwgdGhlIGNvbXBvbmVudCBjYW4gZXhwb3NlIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAqIC0gYEZ1bmN0aW9uYCAqKmlzQWN0aXZlKiogdG8gY2hlY2sgdGhlIGFjdGl2ZSBzdGF0ZVxuICogLSBgRnVuY3Rpb25gICoqaXNEaXNhYmxlZCoqIHRvIGNoZWNrIHRoZSBkaXNhYmxlZCBzdGF0ZVxuICpcbiAqIEBjbGFzcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PlxuXHRjbGFzcyBCdXR0b25TdGF0ZUNsYXNzZXMgZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHN0YXRlIGNsYXNzZXMgYXNzb2NpYXRlZCB0byB0aGUgY3VycmVudCBlbGVtZW50J3Mgc3RhdGUsIGFjY29yZGluZ1xuXHRcdCAqIHRvIHRoZSByZXN1bHRzIG9mIHRoZSBpc0FjdGl2ZSBhbmQgaXNEaXNhYmxlZCBtZXRob2RzLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuXHRcdCAqIEBtZXRob2QgZ2V0U3RhdGVDbGFzc2VzXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBBIHN0cmluZyB3aXRoIHRoZSBzdGF0ZSBDU1MgY2xhc3Nlcy5cblx0XHQgKi9cblx0XHRnZXRTdGF0ZUNsYXNzZXMoKSB7XG5cdFx0XHRsZXQgc3RhdGVDbGFzc2VzID0gJyc7XG5cblx0XHRcdC8vIENoZWNrIGZvciBhY3RpdmUgc3RhdGVcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24odGhpcy5pc0FjdGl2ZSkgJiYgdGhpcy5pc0FjdGl2ZSgpKSB7XG5cdFx0XHRcdHN0YXRlQ2xhc3NlcyArPSAnYWUtYnV0dG9uLXByZXNzZWQnO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBmb3IgZGlzYWJsZWQgc3RhdGVcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24odGhpcy5pc0Rpc2FibGVkKSAmJiB0aGlzLmlzRGlzYWJsZWQoKSkge1xuXHRcdFx0XHRzdGF0ZUNsYXNzZXMgKz0gJyBhZS1idXR0b24tZGlzYWJsZWQnO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc3RhdGVDbGFzc2VzO1xuXHRcdH1cblx0fTtcbiIsImltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuXG4vKipcbiAqIEJ1dHRvblN0eWxlIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBhIHN0eWxlIHByb3AgYW5kIHNvbWUgbWV0aG9kcyB0byBhcHBseSB0aGUgcmVzdWx0aW5nXG4gKiBzdHlsZSBhbmQgY2hlY2tpbmcgaWYgaXQgaXMgcHJlc2VudCBpbiBhIGdpdmVuIHBhdGggb3Igc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdHlsZVxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+XG5cdGNsYXNzIEJ1dHRvblN0eWxlIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRcdC8qKlxuXHRcdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBib3RoIG9uIHRoZSBjbGllbnQgYW5kIHNlcnZlciwgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVcblx0XHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxNb3VudFxuXHRcdCAqL1xuXHRcdGNvbXBvbmVudFdpbGxNb3VudCgpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbE1vdW50KSkge1xuXHRcdFx0XHRzdXBlci5jb21wb25lbnRXaWxsTW91bnQoKTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IHN0eWxlID0gdGhpcy5wcm9wcy5zdHlsZTtcblxuXHRcdFx0aWYgKExhbmcuaXNTdHJpbmcoc3R5bGUpKSB7XG5cdFx0XHRcdGNvbnN0IHBhcnRzID0gc3R5bGUuc3BsaXQoJy4nKTtcblx0XHRcdFx0bGV0IGN1cnJlbnRNZW1iZXIgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJylcblx0XHRcdFx0XHQuY29uZmlnO1xuXHRcdFx0XHRsZXQgcHJvcGVydHkgPSBwYXJ0cy5zaGlmdCgpO1xuXG5cdFx0XHRcdHdoaWxlIChcblx0XHRcdFx0XHRwcm9wZXJ0eSAmJlxuXHRcdFx0XHRcdExhbmcuaXNPYmplY3QoY3VycmVudE1lbWJlcikgJiZcblx0XHRcdFx0XHRMYW5nLmlzT2JqZWN0KGN1cnJlbnRNZW1iZXJbcHJvcGVydHldKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjdXJyZW50TWVtYmVyID0gY3VycmVudE1lbWJlcltwcm9wZXJ0eV07XG5cdFx0XHRcdFx0cHJvcGVydHkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKExhbmcuaXNPYmplY3QoY3VycmVudE1lbWJlcikpIHtcblx0XHRcdFx0XHRzdHlsZSA9IGN1cnJlbnRNZW1iZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fc3R5bGUgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoc3R5bGUpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBiZWZvcmUgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGZyb20gdGhlIERPTS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuXHRcdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcblx0XHQgKi9cblx0XHRjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbFVubW91bnQpKSB7XG5cdFx0XHRcdHN1cGVyLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3N0eWxlID0gbnVsbDtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGluc3RhbmNlIG9mIENLRURJVE9SLnN0eWxlIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgYnV0dG9uIHN0eWxlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlXG5cdFx0ICogQG1ldGhvZCBnZXRTdHlsZVxuXHRcdCAqIEByZXR1cm4ge0NLRURJVE9SLnN0eWxlfSBUaGUgY3VycmVudCBzdHlsZSByZXByZXNlbnRhdGlvbi5cblx0XHQgKi9cblx0XHRnZXRTdHlsZSgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9zdHlsZTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBDaGVja3MgaWYgc3R5bGUgaXMgYWN0aXZlIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZVxuXHRcdCAqIEBtZXRob2QgaXNBY3RpdmVcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHN0eWxlIGlzIGFjdGl2ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHRcdCAqL1xuXHRcdGlzQWN0aXZlKCkge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdFx0Y29uc3QgZWxlbWVudFBhdGggPSBlZGl0b3IuZWxlbWVudFBhdGgoKTtcblx0XHRcdHJldHVybiB0aGlzLmdldFN0eWxlKCkuY2hlY2tBY3RpdmUoZWxlbWVudFBhdGgsIGVkaXRvcik7XG5cdFx0fVxuXHR9O1xuIiwiaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRvb2xiYXJCdXR0b25zIHByb3ZpZGVzIGEgbGlzdCBvZiBidXR0b25zIHdoaWNoIGhhdmUgdG8gYmUgZGlzcGxheWVkXG4gKiBvbiB0aGUgY3VycmVudCB0b29sYmFyIGRlcGVuZGluZyBvbiB1c2VyIHByZWZlcmVuY2VzIGFuZCBnaXZlbiBzdGF0ZS5cbiAqXG4gKiBAY2xhc3MgVG9vbGJhckJ1dHRvbnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgV3JhcHBlZENvbXBvbmVudCA9PlxuXHRjbGFzcyBUb29sYmFyQnV0dG9ucyBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuXHRcdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0XHQvKipcblx0XHQgKiBBbmFseXNlcyB0aGUgY3VycmVudCBzZWxlY3Rpb24gYW5kIHJldHVybnMgdGhlIGJ1dHRvbnMgb3IgYnV0dG9uIGdyb3VwcyB0byBiZSByZW5kZXJlZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZXRob2QgZ2V0VG9vbGJhckJ1dHRvbkdyb3Vwc1xuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IGJ1dHRvbnMgVGhlIGJ1dHRvbnMgY291bGQgYmUgc2hvd24sIHByaW9yIHRvIHRoZSBzdGF0ZSBmaWx0ZXJpbmcuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGFkZGl0aW9uYWxQcm9wcyBBZGRpdGlvbmFsIHByb3BzIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCBkb3duIHRvIHRoZSBidXR0b25zLlxuXHRcdCAqIEByZXR1cm4ge0FycmF5fSBBbiBBcnJheSB3aGljaCBjb250YWlucyB0aGUgYnV0dG9ucyBvciBidXR0b24gZ3JvdXBzIHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHRcdCAqL1xuXHRcdGdldFRvb2xiYXJCdXR0b25Hcm91cHMoYnV0dG9ucywgYWRkaXRpb25hbFByb3BzKSB7XG5cdFx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKGJ1dHRvbnMpKSB7XG5cdFx0XHRcdGJ1dHRvbnMgPSBidXR0b25zLmNhbGwodGhpcykgfHwgW107XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBidXR0b25zLnJlZHVjZSgobGlzdCwgYnV0dG9uKSA9PiB7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGJ1dHRvbikpIHtcblx0XHRcdFx0XHRsaXN0LnB1c2godGhpcy5nZXRUb29sYmFyQnV0dG9ucyhidXR0b24sIGFkZGl0aW9uYWxQcm9wcykpO1xuXHRcdFx0XHRcdHJldHVybiBsaXN0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmdldFRvb2xiYXJCdXR0b25zKGJ1dHRvbnMsIGFkZGl0aW9uYWxQcm9wcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIFtdKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBBbmFseXplcyB0aGUgY3VycmVudCBzZWxlY3Rpb24gYW5kIHRoZSBidXR0b25zIGV4Y2x1c2l2ZSBtb2RlIHZhbHVlIHRvIGZpZ3VyZSBvdXQgd2hpY2hcblx0XHQgKiBidXR0b25zIHNob3VsZCBiZSBwcmVzZW50IGluIGEgZ2l2ZW4gc3RhdGUuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgVG9vbGJhckJ1dHRvbnNcblx0XHQgKiBAbWV0aG9kIGdldFRvb2xiYXJCdXR0b25zXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gYnV0dG9ucyBUaGUgYnV0dG9ucyBjb3VsZCBiZSBzaG93biwgcHJpb3IgdG8gdGhlIHN0YXRlIGZpbHRlcmluZy5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gYWRkaXRpb25hbFByb3BzIEFkZGl0aW9uYWwgcHJvcHMgdGhhdCBzaG91bGQgYmUgcGFzc2VkIGRvd24gdG8gdGhlIGJ1dHRvbnMuXG5cdFx0ICogQHJldHVybiB7QXJyYXl9IEFuIEFycmF5IHdoaWNoIGNvbnRhaW5zIHRoZSBidXR0b25zIHRoYXQgc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHRcdCAqL1xuXHRcdGdldFRvb2xiYXJCdXR0b25zKGJ1dHRvbnMsIGFkZGl0aW9uYWxQcm9wcykge1xuXHRcdFx0Y29uc3QgYnV0dG9uUHJvcHMgPSB7fTtcblxuXHRcdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdFx0Y29uc3QgYnV0dG9uQ2ZnID0gbmF0aXZlRWRpdG9yLmNvbmZpZy5idXR0b25DZmcgfHwge307XG5cblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oYnV0dG9ucykpIHtcblx0XHRcdFx0YnV0dG9ucyA9IGJ1dHRvbnMuY2FsbCh0aGlzKSB8fCBbXTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdG9vbGJhckJ1dHRvbnMgPSB0aGlzLmZpbHRlckV4Y2x1c2l2ZShcblx0XHRcdFx0YnV0dG9uc1xuXHRcdFx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oYnV0dG9uKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHRidXR0b24gJiZcblx0XHRcdFx0XHRcdFx0KEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uXSB8fFxuXHRcdFx0XHRcdFx0XHRcdEFsbG95RWRpdG9yLkJ1dHRvbnNbYnV0dG9uLm5hbWVdKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdC5tYXAoZnVuY3Rpb24oYnV0dG9uKSB7XG5cdFx0XHRcdFx0XHRpZiAoTGFuZy5pc1N0cmluZyhidXR0b24pKSB7XG5cdFx0XHRcdFx0XHRcdGJ1dHRvblByb3BzW2J1dHRvbl0gPSBidXR0b25DZmdbYnV0dG9uXTtcblx0XHRcdFx0XHRcdFx0YnV0dG9uID0gQWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b25dO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChMYW5nLmlzU3RyaW5nKGJ1dHRvbi5uYW1lKSkge1xuXHRcdFx0XHRcdFx0XHRidXR0b25Qcm9wc1tcblx0XHRcdFx0XHRcdFx0XHRBbGxveUVkaXRvci5CdXR0b25zW2J1dHRvbi5uYW1lXS5rZXlcblx0XHRcdFx0XHRcdFx0XSA9IENLRURJVE9SLnRvb2xzLm1lcmdlKFxuXHRcdFx0XHRcdFx0XHRcdGJ1dHRvbkNmZ1tidXR0b25dLFxuXHRcdFx0XHRcdFx0XHRcdGJ1dHRvbi5jZmdcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0YnV0dG9uID0gQWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b24ubmFtZV07XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiBidXR0b247XG5cdFx0XHRcdFx0fSlcblx0XHRcdCkubWFwKGZ1bmN0aW9uKGJ1dHRvbiwgaW5kZXgpIHtcblx0XHRcdFx0bGV0IHByb3BzID0gdGhpcy5tZXJnZUV4Y2x1c2l2ZVByb3BzKFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGVkaXRvcjogdGhpcy5jb250ZXh0LmVkaXRvcixcblx0XHRcdFx0XHRcdGtleTpcblx0XHRcdFx0XHRcdFx0YnV0dG9uLmtleSAhPT0gJ3NlcGFyYXRvcidcblx0XHRcdFx0XHRcdFx0XHQ/IGJ1dHRvbi5rZXlcblx0XHRcdFx0XHRcdFx0XHQ6IGAke2J1dHRvbi5rZXl9LSR7aW5kZXh9YCxcblx0XHRcdFx0XHRcdHRhYktleTogYnV0dG9uLmtleSxcblx0XHRcdFx0XHRcdHRhYkluZGV4OlxuXHRcdFx0XHRcdFx0XHR0aGlzLnByb3BzLnRyaWdnZXIgJiZcblx0XHRcdFx0XHRcdFx0dGhpcy5wcm9wcy50cmlnZ2VyLnByb3BzLnRhYktleSA9PT0gYnV0dG9uLmtleVxuXHRcdFx0XHRcdFx0XHRcdD8gMFxuXHRcdFx0XHRcdFx0XHRcdDogLTEsXG5cdFx0XHRcdFx0XHR0cmlnZ2VyOiB0aGlzLnByb3BzLnRyaWdnZXIsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRidXR0b24ua2V5XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0cHJvcHMgPSB0aGlzLm1lcmdlRHJvcGRvd25Qcm9wcyhwcm9wcywgYnV0dG9uLmtleSk7XG5cblx0XHRcdFx0aWYgKGFkZGl0aW9uYWxQcm9wcykge1xuXHRcdFx0XHRcdHByb3BzID0gQ0tFRElUT1IudG9vbHMubWVyZ2UocHJvcHMsIGFkZGl0aW9uYWxQcm9wcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRwcm9wcyA9IENLRURJVE9SLnRvb2xzLm1lcmdlKHByb3BzLCBidXR0b25Qcm9wc1tidXR0b24ua2V5XSk7XG5cblx0XHRcdFx0cmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoYnV0dG9uLCBwcm9wcyk7XG5cdFx0XHR9LCB0aGlzKTtcblxuXHRcdFx0cmV0dXJuIHRvb2xiYXJCdXR0b25zO1xuXHRcdH1cblx0fTtcbiIsImltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nJztcblxuLyoqXG4gKiBQcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBkaXNwbGF5aW5nIFdpZGdldCBBcnJvdyBib3ggb24gdG9wIG9yIG9uIGJvdHRvbSBvZiB0aGUgd2lkZ2V0XG4gKiBkZXBlbmRpbmcgb24gdGhlIHBvaW50IG9mIHVzZXIgaW50ZXJhY3Rpb24gd2l0aCB0aGUgZWRpdG9yLlxuICpcbiAqIEBjbGFzcyBXaWRnZXRBcnJvd0JveFxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+XG5cdGNsYXNzIFdpZGdldEFycm93Qm94IGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgbGlzdCBvZiBhcnJvdyBib3ggY2xhc3NlcyBhc3NvY2lhdGVkIHRvIHRoZSBjdXJyZW50IGVsZW1lbnQncyBzdGF0ZS4gSXQgcmVsaWVzXG5cdFx0ICogb24gdGhlIGdldEludGVyYWN0aW9uUG9pbnQgbWV0aG9kIHRvIGNhbGN1bGF0ZSB0aGUgc2VsZWN0aW9uIGRpcmVjdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRBcnJvd0JveFxuXHRcdCAqIEBtZXRob2QgZ2V0QXJyb3dCb3hDbGFzc2VzXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBBIHN0cmluZyB3aXRoIHRoZSBhcnJvdyBib3ggQ1NTIGNsYXNzZXMuXG5cdFx0ICovXG5cdFx0Z2V0QXJyb3dCb3hDbGFzc2VzKCkge1xuXHRcdFx0bGV0IGFycm93Qm94Q2xhc3NlcyA9ICdhZS1hcnJvdy1ib3gnO1xuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdExhbmcuaXNGdW5jdGlvbih0aGlzLmdldEludGVyYWN0aW9uUG9pbnQpICYmXG5cdFx0XHRcdHRoaXMuZ2V0SW50ZXJhY3Rpb25Qb2ludCgpXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMuZ2V0SW50ZXJhY3Rpb25Qb2ludCgpLmRpcmVjdGlvbiA9PT1cblx0XHRcdFx0XHRDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRhcnJvd0JveENsYXNzZXMgKz0gJyBhZS1hcnJvdy1ib3gtdG9wJztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhcnJvd0JveENsYXNzZXMgKz0gJyBhZS1hcnJvdy1ib3gtYm90dG9tJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gYXJyb3dCb3hDbGFzc2VzO1xuXHRcdH1cblx0fTtcbiIsImltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nJztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIFByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIG1hbmFnaW5nIGRpZmZlcmVudCBkcm9wZG93bnMgaW5zaWRlIGEgd2lkZ2V0LlxuICpcbiAqIEBjbGFzcyBXaWRnZXREcm9wZG93blxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+XG5cdGNsYXNzIFdpZGdldERyb3Bkb3duIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdFx0dGhpcy5zdGF0ZSA9IHtcblx0XHRcdFx0Li4udGhpcy5zdGF0ZSxcblx0XHRcdFx0ZHJvcGRvd25UcmlnZ2VyOiBudWxsLFxuXHRcdFx0XHRpdGVtRHJvcGRvd246IG51bGwsXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIExpZmVjeWNsZS4gSW52b2tlZCB3aGVuIGEgY29tcG9uZW50IGlzIHJlY2VpdmluZyBuZXcgcHJvcHMuXG5cdFx0ICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG5cdFx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG5cdFx0ICovXG5cdFx0Y29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcblx0XHRcdGlmIChMYW5nLmlzRnVuY3Rpb24oc3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykpIHtcblx0XHRcdFx0c3VwZXIuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0ZHJvcGRvd25UcmlnZ2VyOiBudWxsLFxuXHRcdFx0XHRpdGVtRHJvcGRvd246IG51bGwsXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBNZXJnZXMgdGhlIHByb3ZpZGVkIG9iamVjdCB3aXRoIHR3byBtb3JlIHByb3BlcnRpZXM6XG5cdFx0ICogLSBleHBhbmRlZCAtIGJvb2xlYW4gZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgYW4gd2lkZ2V0IHNob3VsZCBiZSByZW5kZXJlZCBleGNsdXNpdmVseS5cblx0XHQgKiAtIHRvZ2dsZURyb3Bkb3duIC0gZnVuY3Rpb24sIHdoaWNoIGNhbiBiZSB1c2VkIGJ5IGFuIHdpZGdldCBpbiBvcmRlciB0byBvYnRhaW4gZXhjbHVzaXZlIHN0YXRlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG5cdFx0ICogQG1ldGhvZCBtZXJnZURyb3Bkb3duUHJvcHNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBwcm9wZXJ0aWVzIGNvbnRhaW5lciB3aGljaCBzaG91bGQgYmUgbWVyZ2VkIHdpdGggdGhlIHByb3BlcnRpZXMsIHJlbGF0ZWRcblx0XHQgKiAgICB0byBkcm9wZG93biBzdGF0ZS5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbUtleSBUaGV5IGtleSBvZiBhbiBSZWFjdCBXaWRnZXQgd2hpY2ggY29udGFpbnMgdGhlIGRyb3Bkb3duLlxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1lcmdlZCBvYmplY3QuXG5cdFx0ICovXG5cdFx0bWVyZ2VEcm9wZG93blByb3BzID0gKG9iaiwgaXRlbUtleSkgPT4ge1xuXHRcdFx0cmV0dXJuIENLRURJVE9SLnRvb2xzLm1lcmdlKG9iaiwge1xuXHRcdFx0XHRleHBhbmRlZDogdGhpcy5zdGF0ZS5pdGVtRHJvcGRvd24gPT09IGl0ZW1LZXkgPyB0cnVlIDogZmFsc2UsXG5cdFx0XHRcdHRhYkluZGV4OiB0aGlzLnN0YXRlLmRyb3Bkb3duVHJpZ2dlciA9PT0gaXRlbUtleSA/IDAgOiAtMSxcblx0XHRcdFx0dG9nZ2xlRHJvcGRvd246IHRoaXMudG9nZ2xlRHJvcGRvd24uYmluZCh0aGlzLCBpdGVtS2V5KSxcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHQvKipcblx0XHQgKiBTZXRzIHRoZSBhY3RpdmUgZHJvcGRvd24gb2YgdGhlIHdpZGdldCBvciBkaXNjYXJkcyB0aGUgdG9nZ2xlZCBpdGVtIGZyb20gdGhlIHN0YXRlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldERyb3Bkb3duXG5cdFx0ICogQG1ldGhvZCB0b2dnbGVEcm9wZG93blxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRHJvcGRvd24gVGhlIHdpZGdldCB3aGljaCByZXF1ZXN0cyB0byB0b2dnbGUgaXRzIGRyb3Bkb3duLlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB0b2dnbGVEaXJlY3Rpb24gVXNlciBtb3ZlbWVudCBkaXJlY3Rpb24gd2hlbiB0b2dnbGVkIHZpYSBrZXlib2FyZC5cblx0XHQgKi9cblx0XHR0b2dnbGVEcm9wZG93biA9IChpdGVtRHJvcGRvd24sIHRvZ2dsZURpcmVjdGlvbikgPT4ge1xuXHRcdFx0dGhpcy5zZXRTdGF0ZShcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGRyb3Bkb3duVHJpZ2dlcjogaXRlbURyb3Bkb3duLFxuXHRcdFx0XHRcdGl0ZW1Ecm9wZG93bjpcblx0XHRcdFx0XHRcdGl0ZW1Ecm9wZG93biAhPT0gdGhpcy5zdGF0ZS5pdGVtRHJvcGRvd25cblx0XHRcdFx0XHRcdFx0PyBpdGVtRHJvcGRvd25cblx0XHRcdFx0XHRcdFx0OiBudWxsLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHQoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLnN0YXRlLml0ZW1Ecm9wZG93bikge1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMubW92ZUZvY3VzKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMubW92ZUZvY3VzKHRvZ2dsZURpcmVjdGlvbik7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5mb2N1cygpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9O1xuXHR9O1xuIiwiaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuXG4vKipcbiAqIFByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIG1hbmFnaW5nIGV4Y2x1c2l2ZSBzdGF0ZSBvZiBhbiB3aWRnZXQuXG4gKiBUaGUgZXhjbHVzaXZlIHN0YXRlIG1lYW5zIHRoYXQgYSBidXR0b24gbWF5IHJlcXVlc3QgdG8gYmUgdGhlIG9ubHkgcmVuZGVyZWRcbiAqIHdpZGdldCBpbiBpdHMgcGFyZW50IGNvbnRhaW5lci4gV2lkZ2V0RXhjbHVzaXZlIHdpbGwgbWFuYWdlIHRoaXMgc3RhdGUgYnlcbiAqIGZpbHRlcmluZyBhbmQgc3VwcHJlc3NpbmcgdGhlIG90aGVyIHNpYmxpbmcgd2lkZ2V0cyBmcm9tIGRpc3BsYXlpbmcuXG4gKlxuICogQGNsYXNzIFdpZGdldEV4Y2x1c2l2ZVxuICovXG5leHBvcnQgZGVmYXVsdCBXcmFwcGVkQ29tcG9uZW50ID0+XG5cdGNsYXNzIFdpZGdldEV4Y2x1c2l2ZSBleHRlbmRzIFdyYXBwZWRDb21wb25lbnQge1xuXHRcdC8qKlxuXHRcdCAqIENhbmNlbHMgdGhlIGV4Y2x1c2l2ZSBzdGF0ZSBvZiBhbiB3aWRnZXQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0RXhjbHVzaXZlXG5cdFx0ICogQG1ldGhvZCBjYW5jZWxFeGNsdXNpdmVcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbUV4Y2x1c2l2ZSBUaGUgd2lkZ2V0IHdoaWNoIGV4Y2x1c2l2ZSBzdGF0ZSBzaG91bGQgYmUgY2FuY2VsZWQuXG5cdFx0ICovXG5cdFx0Y2FuY2VsRXhjbHVzaXZlKGl0ZW1FeGNsdXNpdmUpIHtcblx0XHRcdGlmICh0aGlzLnN0YXRlLml0ZW1FeGNsdXNpdmUgPT09IGl0ZW1FeGNsdXNpdmUpIHtcblx0XHRcdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRcdFx0aXRlbUV4Y2x1c2l2ZTogbnVsbCxcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVjZWl2aW5nIG5ldyBwcm9wcy5cblx0XHQgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG5cdFx0ICogQ2FsbGluZyB0aGlzLnNldFN0YXRlKCkgd2l0aGluIHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgdHJpZ2dlciBhbiBhZGRpdGlvbmFsIHJlbmRlci5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRFeGNsdXNpdmVcblx0XHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gbmV4dFByb3BzIE9iamVjdCBjb250YWluaW5nIHRoZSBjdXJyZW50IHNldCBvZiBwcm9wZXJ0aWVzLlxuXHRcdCAqL1xuXHRcdGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG5cdFx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKHN1cGVyLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMpKSB7XG5cdFx0XHRcdHN1cGVyLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVjZWl2aW5nIHByb3BlcnRpZXMgbWVhbnMgdGhhdCB0aGUgY29tcG9uZW50IGlzIGJlaW5nIHJlLXJlbmRlcmVkLlxuXHRcdFx0Ly8gUmUtcmVuZGVyaW5nIGlzIHRyaWdnZXJlZCBieSBlZGl0b3JJbnRlcmFjdGlvbiwgc28gd2UgaGF2ZSB0b1xuXHRcdFx0Ly8gcmVzZXQgdGhlIGV4Y2x1c2l2ZSBzdGF0ZSBhbmQgcmVuZGVyIHRoZSBVSSBhY2NvcmRpbmcgdG8gdGhlIG5ldyBzZWxlY3Rpb24uXG5cdFx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0aXRlbUV4Y2x1c2l2ZTogbnVsbCxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIEZpbHRlcnMgdGhlIGl0ZW1zIGFuZCByZXR1cm5zIG9ubHkgdGhvc2Ugd2l0aCBleGNsdXNpdmUgc3RhdGUuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0RXhjbHVzaXZlXG5cdFx0ICogQG1ldGhvZCBmaWx0ZXJFeGNsdXNpdmVcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBpdGVtcyBUaGUgd2lkZ2V0cyB0byBiZSBmaWx0ZXJlZC5cblx0XHQgKiBAcmV0dXJuIHtBcnJheXxPYmplY3R9IFRoZSBpdGVtIHdpdGggZXhlY3V0aXZlIHN0YXRlLlxuXHRcdCAqL1xuXHRcdGZpbHRlckV4Y2x1c2l2ZShpdGVtcykge1xuXHRcdFx0cmV0dXJuIGl0ZW1zLmZpbHRlcihcblx0XHRcdFx0ZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLnN0YXRlLml0ZW1FeGNsdXNpdmUpIHtcblx0XHRcdFx0XHRcdGlmICh0aGlzLnN0YXRlLml0ZW1FeGNsdXNpdmUgPT09IGl0ZW0ua2V5KSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBpdGVtO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0uYmluZCh0aGlzKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBNZXJnZXMgdGhlIHByb3ZpZGVkIG9iamVjdCB3aXRoIHRocmVlIG1vcmUgcHJvcGVydGllczpcblx0XHQgKiAtIGNhbmNlbEV4Y2x1c2l2ZSAtIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgdXNlZCBieSBhIHdpZGdldCBpbiBvcmRlciB0byBjYW5jZWwgZXhlY3V0aXZlIHN0YXRlLlxuXHRcdCAqIC0gcmVuZGVyRXhjbHVzaXZlIC0gYm9vbGVhbiBmbGFnIHdoaWNoIGluZGljYXRlcyBpZiBhbiB3aWRnZXQgc2hvdWxkIGJlIHJlbmRlcmVkIGV4Y2x1c2l2ZWx5LlxuXHRcdCAqIC0gcmVxdWVzdEV4Y2x1c2l2ZSAtIGZ1bmN0aW9uLCB3aGljaCBjYW4gYmUgdXNlZCBieSBhIHdpZGdldCBpbiBvcmRlciB0byBvYnRhaW4gZXhjbHVzaXZlIHN0YXRlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEV4Y2x1c2l2ZVxuXHRcdCAqIEBtZXRob2QgbWVyZ2VFeGNsdXNpdmVQcm9wc1xuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIHByb3BlcnRpZXMgY29udGFpbmVyIHdoaWNoIHNob3VsZCBiZSBtZXJnZWQgd2l0aCB0aGUgcHJvcGVydGllcywgcmVsYXRlZFxuXHRcdCAqICAgIHRvIGV4Y2x1c2l2ZSBzdGF0ZS5cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gaXRlbUtleSBUaGV5IGtleSBvZiBhbiBSZWFjdCBXaWRnZXQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkIGV4Y2x1c2l2ZWx5LlxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1lcmdlZCBvYmplY3QuXG5cdFx0ICovXG5cdFx0bWVyZ2VFeGNsdXNpdmVQcm9wcyhvYmosIGl0ZW1LZXkpIHtcblx0XHRcdHJldHVybiBDS0VESVRPUi50b29scy5tZXJnZShvYmosIHtcblx0XHRcdFx0Y2FuY2VsRXhjbHVzaXZlOiB0aGlzLmNhbmNlbEV4Y2x1c2l2ZS5iaW5kKHRoaXMsIGl0ZW1LZXkpLFxuXHRcdFx0XHRyZW5kZXJFeGNsdXNpdmU6IHRoaXMuc3RhdGUuaXRlbUV4Y2x1c2l2ZSA9PT0gaXRlbUtleSxcblx0XHRcdFx0cmVxdWVzdEV4Y2x1c2l2ZTogdGhpcy5yZXF1ZXN0RXhjbHVzaXZlLmJpbmQodGhpcywgaXRlbUtleSksXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXF1ZXN0cyBhbmQgc2V0cyBleGNsdXNpdmUgc3RhdGUgb2YgYW4gd2lkZ2V0LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEV4Y2x1c2l2ZVxuXHRcdCAqIEBtZXRob2QgcmVxdWVzdEV4Y2x1c2l2ZVxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtRXhjbHVzaXZlIFRoZSB3aWRnZXQgd2hpY2ggcmVxdWVzdHMgZXhjbHVzaXZlIHN0YXRlLlxuXHRcdCAqL1xuXHRcdHJlcXVlc3RFeGNsdXNpdmUgPSBpdGVtRXhjbHVzaXZlID0+IHtcblx0XHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0XHRpdGVtRXhjbHVzaXZlLFxuXHRcdFx0fSk7XG5cdFx0fTtcblx0fTtcbiIsImltcG9ydCBMYW5nIGZyb20gJy4uLy4uL29vcC9sYW5nJztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5jb25zdCBESVJFQ1RJT05fTk9ORSA9IDA7XG5jb25zdCBESVJFQ1RJT05fTkVYVCA9IDE7XG5jb25zdCBESVJFQ1RJT05fUFJFViA9IC0xO1xuXG5jb25zdCBBQ1RJT05fTk9ORSA9IDA7XG5jb25zdCBBQ1RJT05fTU9WRV9GT0NVUyA9IDE7XG5jb25zdCBBQ1RJT05fRElTTUlTU19GT0NVUyA9IDI7XG5cbi8qKlxuICogV2lkZ2V0Rm9jdXNNYW5hZ2VyIGlzIGEgbWl4aW4gdGhhdCBwcm92aWRlcyBrZXlib2FyZCBuYXZpZ2F0aW9uIGluc2lkZSBhIHdpZGdldC4gVG8gZG8gdGhpcyxcbiAqIGl0IGV4cG9zZXMgdGhlIGZvbGxvd2luZyBwcm9wcyBhbmQgbWV0aG9kczpcbiAqXG4gKiBAY2xhc3MgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT5cblx0Y2xhc3MgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGV4dGVuZHMgV3JhcHBlZENvbXBvbmVudCB7XG5cdFx0LyoqXG5cdFx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0XHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG5cdFx0ICovXG5cdFx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKHN1cGVyLmNvbXBvbmVudERpZE1vdW50KSkge1xuXHRcdFx0XHRzdXBlci5jb21wb25lbnREaWRNb3VudCgpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQncyB1cGRhdGVzIGFyZSBmbHVzaGVkIHRvIHRoZSBET00uXG5cdFx0ICogUmVmcmVzaGVzIHRoZSBkZXNjZW5kYW50cyBsaXN0LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBtZXRob2QgY29tcG9uZW50RGlkVXBkYXRlXG5cdFx0ICovXG5cdFx0Y29tcG9uZW50RGlkVXBkYXRlKCkge1xuXHRcdFx0aWYgKExhbmcuaXNGdW5jdGlvbihzdXBlci5jb21wb25lbnREaWRVcGRhdGUpKSB7XG5cdFx0XHRcdHN1cGVyLmNvbXBvbmVudERpZFVwZGF0ZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9yZWZyZXNoKCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogRm9jdXNlcyB0aGUgY3VycmVudCBhY3RpdmUgZGVzY2VuZGFudC5cblx0XHQgKlxuXHRcdCAqIFNldmVyYWwgV2lkZ2V0cyBjYW4gYmUgbmVzdGVkIGluIGEgY29tcG9uZW50IGhpZXJhcmNoeSBieSBhdHRhY2hpbmcgdGhpcyBmb2N1cyBtZXRob2QgdG9cblx0XHQgKiB0aGUgd2lkZ2V0IERPTSBub2RlLCB0cmFuc2ZlcnJpbmcgdGhlIERPTSBmb2N1cyBjb250cm9sIHRvIHRoZSBpbm5lciBGb2N1c01hbmFnZXIuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdFx0ICogQG1ldGhvZCBmb2N1c1xuXHRcdCAqL1xuXHRcdGZvY3VzID0gZXZlbnQgPT4ge1xuXHRcdFx0aWYgKCFldmVudCB8fCB0aGlzLl9pc1ZhbGlkVGFyZ2V0KGV2ZW50LnRhcmdldCkpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2Rlc2NlbmRhbnRzICYmIHRoaXMuX2Rlc2NlbmRhbnRzLmxlbmd0aCkge1xuXHRcdFx0XHRcdGNvbnN0IGFjdGl2ZURlc2NlbmRhbnRFbCA9IHRoaXMuX2Rlc2NlbmRhbnRzW1xuXHRcdFx0XHRcdFx0dGhpcy5fYWN0aXZlRGVzY2VuZGFudFxuXHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0Ly8gV2hlbiB1c2VyIGNsaWNrcyB3aXRoIHRoZSBtb3VzZSwgdGhlIGFjdGl2ZUVsZW1lbnQgaXMgYWxyZWFkeSBzZXQgYW5kIHRoZXJlXG5cdFx0XHRcdFx0Ly8gaXMgbm8gbmVlZCB0byBmb2N1cyBpdC4gRm9jdXNpbmcgb2YgdGhlIGFjdGl2ZSBkZXNjZW5kYW50ICh1c3VhbGx5IHNvbWUgYnV0dG9uKSBpcyByZXF1aXJlZFxuXHRcdFx0XHRcdC8vIGluIGNhc2Ugb2Yga2V5Ym9hcmQgbmF2aWdhdGlvbiwgYmVjYXVzZSB0aGUgZm9jdXNlZCBlbGVtZW50IG1pZ2h0IGJlIG5vdCB0aGUgZmlyc3QgYnV0dG9uLFxuXHRcdFx0XHRcdC8vIGJ1dCB0aGUgZGl2IGVsZW1lbnQsIHdoaWNoIGNvbnRhaW5zIHRoZSBidXR0b24uXG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0ZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gYWN0aXZlRGVzY2VuZGFudEVsICYmXG5cdFx0XHRcdFx0XHQhdGhpcy5wcm9wcy5mb2N1c0ZpcnN0Q2hpbGRcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGVzY2VuZGFudHMuaW5kZXhPZihcblx0XHRcdFx0XHRcdFx0XHRkb2N1bWVudC5hY3RpdmVFbGVtZW50XG5cdFx0XHRcdFx0XHRcdCkgPT09IC0xXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0YWN0aXZlRGVzY2VuZGFudEVsLmZvY3VzKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGV2ZW50KSB7XG5cdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXMgdGhlIGtleSBldmVudHMgb24gYSBET00gbm9kZSB0byBleGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBuYXZpZ2F0aW9uIHdoZW4gbmVlZGVkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgS2V5Ym9hcmQgZXZlbnQgdGhhdCB3YXMgZGV0ZWN0ZWQgb24gdGhlIHdpZGdldCBET00gbm9kZS5cblx0XHQgKiBAbWV0aG9kIGhhbmRsZUtleVxuXHRcdCAqL1xuXHRcdGhhbmRsZUtleSA9IGV2ZW50ID0+IHtcblx0XHRcdGlmICh0aGlzLl9pc1ZhbGlkVGFyZ2V0KGV2ZW50LnRhcmdldCkgJiYgdGhpcy5fZGVzY2VuZGFudHMpIHtcblx0XHRcdFx0Y29uc3QgYWN0aW9uID0gdGhpcy5fZ2V0Rm9jdXNBY3Rpb24oZXZlbnQpO1xuXG5cdFx0XHRcdGlmIChhY3Rpb24udHlwZSkge1xuXHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0XHRpZiAoYWN0aW9uLnR5cGUgPT09IEFDVElPTl9NT1ZFX0ZPQ1VTKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9tb3ZlRm9jdXMoYWN0aW9uLmRpcmVjdGlvbik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGFjdGlvbi50eXBlID09PSBBQ1RJT05fRElTTUlTU19GT0NVUykge1xuXHRcdFx0XHRcdFx0dGhpcy5wcm9wcy5vbkRpc21pc3MoYWN0aW9uLmRpcmVjdGlvbik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIE1vdmVzIHRoZSBmb2N1cyBhbW9uZyBkZXNjZW5kYW50cyBpbiB0aGUgZXNwZWNpZmllZCBkaXJlY3Rpb24uXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdFx0ICogQG1ldGhvZCBtb3ZlRm9jdXNcblx0XHQgKiBAcGFyYW0ge251bWJlcn0gZGlyZWN0aW9uIFRoZSBkaXJlY3Rpb24gKDEgb3IgLTEpIG9mIHRoZSBmb2N1cyBtb3ZlbWVudCBhbW9uZyBkZXNjZW5kYW50cy5cblx0XHQgKi9cblx0XHRtb3ZlRm9jdXMoZGlyZWN0aW9uKSB7XG5cdFx0XHRkaXJlY3Rpb24gPSBMYW5nLmlzTnVtYmVyKGRpcmVjdGlvbikgPyBkaXJlY3Rpb24gOiAwO1xuXG5cdFx0XHR0aGlzLl9tb3ZlRm9jdXMoZGlyZWN0aW9uKTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBhY3Rpb24sIGlmIGFueSwgdGhhdCBhIGtleWJvYXJkIGV2ZW50IGluIHRoZSBjdXJyZW50IGZvY3VzIG1hbmFnZXIgc3RhdGVcblx0XHQgKiBzaG91bGQgcHJvZHVjZS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0XHQgKiBAbWV0aG9kIF9nZXRGb2N1c0FjdGlvblxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBldmVudCBUaGUgS2V5Ym9hcmQgZXZlbnQuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gQW4gYWN0aW9uIG9iamVjdCB3aXRoIHR5cGUgYW5kIGRpcmVjdGlvbiBwcm9wZXJ0aWVzLlxuXHRcdCAqL1xuXHRcdF9nZXRGb2N1c0FjdGlvbihldmVudCkge1xuXHRcdFx0Y29uc3QgYWN0aW9uID0ge1xuXHRcdFx0XHR0eXBlOiBBQ1RJT05fTk9ORSxcblx0XHRcdH07XG5cblx0XHRcdGlmICh0aGlzLnByb3BzLmtleXMpIHtcblx0XHRcdFx0Y29uc3QgZGlyZWN0aW9uID0gdGhpcy5fZ2V0Rm9jdXNNb3ZlRGlyZWN0aW9uKGV2ZW50KTtcblxuXHRcdFx0XHRpZiAoZGlyZWN0aW9uKSB7XG5cdFx0XHRcdFx0YWN0aW9uLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcblx0XHRcdFx0XHRhY3Rpb24udHlwZSA9IEFDVElPTl9NT1ZFX0ZPQ1VTO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgZGlzbWlzc0FjdGlvbiA9IHRoaXMuX2dldEZvY3VzRGlzbWlzc0FjdGlvbihcblx0XHRcdFx0XHRldmVudCxcblx0XHRcdFx0XHRkaXJlY3Rpb25cblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoZGlzbWlzc0FjdGlvbi5kaXNtaXNzKSB7XG5cdFx0XHRcdFx0YWN0aW9uLmRpcmVjdGlvbiA9IGRpc21pc3NBY3Rpb24uZGlyZWN0aW9uO1xuXHRcdFx0XHRcdGFjdGlvbi50eXBlID0gQUNUSU9OX0RJU01JU1NfRk9DVVM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFjdGlvbjtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBkaXNtaXNzIGFjdGlvbiwgaWYgYW55LCB0aGUgZm9jdXMgbWFuYWdlciBzaG91bGQgZXhlY3V0ZSB0byB5aWVsZCB0aGUgZm9jdXMuIFRoaXNcblx0XHQgKiB3aWxsIGhhcHBlbiBpbiBhbnkgb2YgdGhlc2Ugc2NlbmFyaW9zIGlmIGEgZGlzbWlzcyBjYWxsYmFjayBoYXMgYmVlbiBzcGVjaWZpZWQ6XG5cdFx0ICogLSBBIGRpc21pc3Mga2V5IGhhcyBiZWVuIHByZXNzZWRcblx0XHQgKiAtIEluIGEgbm9uLWNpcmN1bGFyIGZvY3VzIG1hbmFnZXIsIHdoZW46XG5cdFx0ICogICAgIC0gVGhlIGFjdGl2ZSBkZXNjZW5kYW50IGlzIHRoZSBmaXJzdCBvbmUgYW5kIGEgcHJldiBrZXkgaGFzIGJlZW4gcHJlc3NlZC5cblx0XHQgKiAgICAgLSBUaGUgYWN0aXZlIGRlc2NlbmRhbnQgaXMgdGhlIGxhc3Qgb25lIGFuZCBhIG5leHQga2V5IGhhcyBiZWVuIHByZXNzZWQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdFx0ICogQG1ldGhvZCBfZ2V0Rm9jdXNEaXNtaXNzQWN0aW9uXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGZvY3VzTW92ZURpcmVjdGlvbiBUaGUgZm9jdXMgbW92ZW1lbnQgZGlyZWN0aW9uIChpZiBhbnkpLlxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCBUaGUgS2V5Ym9hcmQgZXZlbnQuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gQSBkaXNtaXNzIGFjdGlvbiB3aXRoIGRpc21pc3MgYW5kIGRpcmVjdGlvbiBwcm9wZXJ0aWVzLlxuXHRcdCAqL1xuXHRcdF9nZXRGb2N1c0Rpc21pc3NBY3Rpb24oZXZlbnQsIGZvY3VzTW92ZURpcmVjdGlvbikge1xuXHRcdFx0Y29uc3QgZGlzbWlzc0FjdGlvbiA9IHtcblx0XHRcdFx0ZGlyZWN0aW9uOiBmb2N1c01vdmVEaXJlY3Rpb24sXG5cdFx0XHRcdGRpc21pc3M6IGZhbHNlLFxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKHRoaXMucHJvcHMub25EaXNtaXNzKSB7XG5cdFx0XHRcdGlmICh0aGlzLl9pc1ZhbGlkS2V5KGV2ZW50LmtleUNvZGUsIHRoaXMucHJvcHMua2V5cy5kaXNtaXNzKSkge1xuXHRcdFx0XHRcdGRpc21pc3NBY3Rpb24uZGlzbWlzcyA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMuX2lzVmFsaWRLZXkoZXZlbnQua2V5Q29kZSwgdGhpcy5wcm9wcy5rZXlzLmRpc21pc3NOZXh0KVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRkaXNtaXNzQWN0aW9uLmRpc21pc3MgPSB0cnVlO1xuXHRcdFx0XHRcdGRpc21pc3NBY3Rpb24uZGlyZWN0aW9uID0gRElSRUNUSU9OX05FWFQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMuX2lzVmFsaWRLZXkoZXZlbnQua2V5Q29kZSwgdGhpcy5wcm9wcy5rZXlzLmRpc21pc3NQcmV2KVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRkaXNtaXNzQWN0aW9uLmRpc21pc3MgPSB0cnVlO1xuXHRcdFx0XHRcdGRpc21pc3NBY3Rpb24uZGlyZWN0aW9uID0gRElSRUNUSU9OX1BSRVY7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0IWRpc21pc3NBY3Rpb24uZGlzbWlzcyAmJlxuXHRcdFx0XHRcdCF0aGlzLnByb3BzLmNpcmN1bGFyICYmXG5cdFx0XHRcdFx0Zm9jdXNNb3ZlRGlyZWN0aW9uXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGRpc21pc3NBY3Rpb24uZGlzbWlzcyA9XG5cdFx0XHRcdFx0XHQoZm9jdXNNb3ZlRGlyZWN0aW9uID09PSBESVJFQ1RJT05fUFJFViAmJlxuXHRcdFx0XHRcdFx0XHR0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID09PSAwKSB8fFxuXHRcdFx0XHRcdFx0KGZvY3VzTW92ZURpcmVjdGlvbiA9PT0gRElSRUNUSU9OX05FWFQgJiZcblx0XHRcdFx0XHRcdFx0dGhpcy5fYWN0aXZlRGVzY2VuZGFudCA9PT1cblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kZXNjZW5kYW50cy5sZW5ndGggLSAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGlzbWlzc0FjdGlvbjtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBkaXJlY3Rpb24sIGlmIGFueSwgaW4gd2hpY2ggdGhlIGZvY3VzIHNob3VsZCBiZSBtb3ZlZC4gSW4gcHJlc2VuY2Ugb2YgdGhlXG5cdFx0ICogc2hpZnQga2V5IG1vZGlmaWVyLCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBtb3ZlbWVudCBpcyBpbnZlcnRlZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0XHQgKiBAbWV0aG9kIF9nZXRGb2N1c01vdmVEaXJlY3Rpb25cblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgVGhlIEtleWJvYXJkIGV2ZW50LlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBjb21wdXRlZCBkaXJlY3Rpb24gb2YgdGhlIGV4cGVjdGVkIGZvY3VzIG1vdmVtZW50LlxuXHRcdCAqL1xuXHRcdF9nZXRGb2N1c01vdmVEaXJlY3Rpb24oZXZlbnQpIHtcblx0XHRcdGxldCBkaXJlY3Rpb24gPSBESVJFQ1RJT05fTk9ORTtcblxuXHRcdFx0aWYgKHRoaXMuX2lzVmFsaWRLZXkoZXZlbnQua2V5Q29kZSwgdGhpcy5wcm9wcy5rZXlzLm5leHQpKSB7XG5cdFx0XHRcdGRpcmVjdGlvbiA9IERJUkVDVElPTl9ORVhUO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2lzVmFsaWRLZXkoZXZlbnQua2V5Q29kZSwgdGhpcy5wcm9wcy5rZXlzLnByZXYpKSB7XG5cdFx0XHRcdGRpcmVjdGlvbiA9IERJUkVDVElPTl9QUkVWO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXZlbnQuc2hpZktleSkge1xuXHRcdFx0XHRkaXJlY3Rpb24gKj0gLTE7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkaXJlY3Rpb247XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIGlmIGEgZ2l2ZW4ga2V5Q29kZSBpcyB2YWxpZCBmb3IgdGhlIGdpdmVuIHNldCBvZiBrZXlzLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBtZXRob2QgX2lzVmFsaWRLZXlcblx0XHQgKiBAcGFyYW0ge0FycmF5fE51bWJlcn0ga2V5cyBBIGtleSBzZXQuIENhbiBiZSBhIG51bWJlciBhbiBhcnJheSBvZiBudW1iZXJzIHJlcHJlc2VudGluZyB0aGUgYWxsb3dlZCBrZXlDb2Rlcy5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0ga2V5Q29kZSBBbiBldmVudCBrZXlDb2RlLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBBIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyBpZiB0aGUga2V5IGlzIHZhbGlkLlxuXHRcdCAqL1xuXHRcdF9pc1ZhbGlkS2V5KGtleUNvZGUsIGtleXMpIHtcblx0XHRcdHJldHVybiBMYW5nLmlzQXJyYXkoa2V5cylcblx0XHRcdFx0PyBrZXlzLmluZGV4T2Yoa2V5Q29kZSkgIT09IC0xXG5cdFx0XHRcdDoga2V5Q29kZSA9PT0ga2V5cztcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgaWYgYSBnaXZlbiBlbGVtZW50IGlzIHZhbGlkIGZvciBmb2N1cyBtYW5hZ2VtZW50LiBVc2VyIGlucHV0IGVsZW1lbnRzIHN1Y2ggYXNcblx0XHQgKiBpbnB1dCwgc2VsZWN0IG9yIHRleHRhcmVhIGFyZSBleGNsdWRlZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRGb2N1c01hbmFnZXJcblx0XHQgKiBAbWV0aG9kIF9pc1ZhbGlkS2V5XG5cdFx0ICogQHBhcmFtIHtET01Ob2RlfSBlbGVtZW50IEEgRE9NIGVsZW1lbnQuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IEEgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoZSBlbGVtZW50IGlzIHZhbGlkLlxuXHRcdCAqL1xuXHRcdF9pc1ZhbGlkVGFyZ2V0KGVsZW1lbnQpIHtcblx0XHRcdGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0dGFnTmFtZSAhPT0gJ2lucHV0JyAmJlxuXHRcdFx0XHR0YWdOYW1lICE9PSAnc2VsZWN0JyAmJlxuXHRcdFx0XHR0YWdOYW1lICE9PSAndGV4dGFyZWEnXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIE1vdmVzIHRoZSBmb2N1cyBhbW9uZyBkZXNjZW5kYW50cyBpbiB0aGUgZXNwZWNpZmllZCBkaXJlY3Rpb24uXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG5cdFx0ICogQG1ldGhvZCBfbW92ZUZvY3VzXG5cdFx0ICogQHBhcmFtIHtudW1iZXJ9IGRpcmVjdGlvbiBUaGUgZGlyZWN0aW9uICgxIG9yIC0xKSBvZiB0aGUgZm9jdXMgbW92ZW1lbnQgYW1vbmcgZGVzY2VuZGFudHMuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9tb3ZlRm9jdXMoZGlyZWN0aW9uKSB7XG5cdFx0XHRjb25zdCBudW1EZXNjZW5kYW50cyA9IHRoaXMuX2Rlc2NlbmRhbnRzLmxlbmd0aDtcblxuXHRcdFx0bGV0IGRlc2NlbmRhbnQgPSB0aGlzLl9kZXNjZW5kYW50c1t0aGlzLl9hY3RpdmVEZXNjZW5kYW50XTtcblxuXHRcdFx0ZGVzY2VuZGFudC5zZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JywgLTEpO1xuXG5cdFx0XHR0aGlzLl9hY3RpdmVEZXNjZW5kYW50ICs9IGRpcmVjdGlvbjtcblxuXHRcdFx0aWYgKHRoaXMucHJvcHMuY2lyY3VsYXIpIHtcblx0XHRcdFx0Ly8gQ2FsY3VsYXRlIHByb3BlciBtb2R1bG8gcmVzdWx0IHNpbmNlIHJlbWFpbmRlciBvcGVyYXRvciBkb2Vzbid0IGJlaGF2ZSBpbiB0aGVcblx0XHRcdFx0Ly8gc2FtZSB3YXkgZm9yIG5lZ2F0aXZlIG51bWJlcnNcblx0XHRcdFx0dGhpcy5fYWN0aXZlRGVzY2VuZGFudCA9XG5cdFx0XHRcdFx0KCh0aGlzLl9hY3RpdmVEZXNjZW5kYW50ICUgbnVtRGVzY2VuZGFudHMpICtcblx0XHRcdFx0XHRcdG51bURlc2NlbmRhbnRzKSAlXG5cdFx0XHRcdFx0bnVtRGVzY2VuZGFudHM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9hY3RpdmVEZXNjZW5kYW50ID0gTWF0aC5tYXgoXG5cdFx0XHRcdFx0TWF0aC5taW4odGhpcy5fYWN0aXZlRGVzY2VuZGFudCwgbnVtRGVzY2VuZGFudHMgLSAxKSxcblx0XHRcdFx0XHQwXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGRlc2NlbmRhbnQgPSB0aGlzLl9kZXNjZW5kYW50c1t0aGlzLl9hY3RpdmVEZXNjZW5kYW50XTtcblxuXHRcdFx0ZGVzY2VuZGFudC5zZXRBdHRyaWJ1dGUoJ3RhYkluZGV4JywgMCk7XG5cdFx0XHRkZXNjZW5kYW50LmZvY3VzKCk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmVmcmVzaGVzIHRoZSBkZXNjZW5kYW50cyBsaXN0IGJ5IGV4ZWN1dGluZyB0aGUgQ1NTIHNlbGVjdG9yIGFnYWluIGFuZCByZXNldHMgdGhlIGRlc2NlbmRhbnRzIHRhYkluZGV4LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldEZvY3VzTWFuYWdlclxuXHRcdCAqIEBtZXRob2QgX3JlZnJlc2hcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X3JlZnJlc2goKSB7XG5cdFx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cblx0XHRcdGlmIChkb21Ob2RlKSB7XG5cdFx0XHRcdGNvbnN0IGRlc2NlbmRhbnRzID0gZG9tTm9kZS5xdWVyeVNlbGVjdG9yQWxsKFxuXHRcdFx0XHRcdHRoaXMucHJvcHMuZGVzY2VuZGFudHNcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRsZXQgcHJpb3JpdHlEZXNjZW5kYW50cyA9IFtdO1xuXG5cdFx0XHRcdHRoaXMuX2Rlc2NlbmRhbnRzID0gW107XG5cblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZGVzY2VuZGFudHMpLmZvckVhY2goXG5cdFx0XHRcdFx0ZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgZGF0YVRhYkluZGV4ID0gaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFiaW5kZXgnKTtcblxuXHRcdFx0XHRcdFx0aWYgKGRhdGFUYWJJbmRleCkge1xuXHRcdFx0XHRcdFx0XHRwcmlvcml0eURlc2NlbmRhbnRzLnB1c2goaXRlbSk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9kZXNjZW5kYW50cy5wdXNoKGl0ZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0uYmluZCh0aGlzKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdHByaW9yaXR5RGVzY2VuZGFudHMgPSBwcmlvcml0eURlc2NlbmRhbnRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRMYW5nLnRvSW50KGEuZ2V0QXR0cmlidXRlKCdkYXRhLXRhYmluZGV4JykpID5cblx0XHRcdFx0XHRcdExhbmcudG9JbnQoYi5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFiaW5kZXgnKSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0aGlzLl9kZXNjZW5kYW50cyA9IHByaW9yaXR5RGVzY2VuZGFudHMuY29uY2F0KFxuXHRcdFx0XHRcdHRoaXMuX2Rlc2NlbmRhbnRzXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0dGhpcy5fYWN0aXZlRGVzY2VuZGFudCA9IDA7XG5cblx0XHRcdFx0dGhpcy5fZGVzY2VuZGFudHMuc29tZShcblx0XHRcdFx0XHRmdW5jdGlvbihpdGVtLCBpbmRleCkge1xuXHRcdFx0XHRcdFx0aWYgKGl0ZW0uZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpID09PSAnMCcpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fYWN0aXZlRGVzY2VuZGFudCA9IGluZGV4O1xuXHRcdFx0XHRcdFx0XHR0aGlzLmZvY3VzKCk7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fS5iaW5kKHRoaXMpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuIiwiaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwb3NpdGlvbiB3aGVyZSBhbiBXaWRnZXQgc2hvdWxkIGJlIGRpc3BsYXllZCBiYXNlZCBvbiB0aGUgcG9pbnRcbiAqIHdoZXJlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIHRoZSBlZGl0b3IuXG4gKlxuICogQGNsYXNzIFdpZGdldFBvc2l0aW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFdyYXBwZWRDb21wb25lbnQgPT5cblx0Y2xhc3MgV2lkZ2V0UG9zaXRpb24gZXh0ZW5kcyBXcmFwcGVkQ29tcG9uZW50IHtcblx0XHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdFx0LyoqXG5cdFx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0UG9zaXRpb25cblx0XHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHRcdCAqL1xuXHRcdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0XHQuLi5XcmFwcGVkQ29tcG9uZW50LmRlZmF1bHRQcm9wcyxcblx0XHRcdGd1dHRlcjoge1xuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHR0b3A6IDEwLFxuXHRcdFx0fSxcblx0XHRcdGNvbnN0cmFpblRvVmlld3BvcnQ6IHRydWUsXG5cdFx0fTtcblxuXHRcdC8qKlxuXHRcdCAqIENhbmNlbHMgYW4gc2NoZWR1bGVkIGFuaW1hdGlvbiBmcmFtZS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHRcdCAqIEBtZXRob2QgY2FuY2VsQW5pbWF0aW9uXG5cdFx0ICovXG5cdFx0Y2FuY2VsQW5pbWF0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuX2FuaW1hdGlvbkZyYW1lSWQpIHtcblx0XHRcdFx0d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGlvbkZyYW1lSWQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCBpbiBwYWdlIGNvb3JkaW5hdGVzLFxuXHRcdCAqIHJlc3RyaWN0ZWQgdG8gZml0IHRvIGdpdmVuIHZpZXdwb3J0LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG5cdFx0ICogQG1ldGhvZCBnZXRDb25zdHJhaW5lZFBvc2l0aW9uXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIFRoZSBmb2xsb3dpbmcgcHJvcGVydGllcywgcHJvdmlkZWQgYXMgbnVtYmVyczpcblx0XHQgKiAtIGhlaWdodFxuXHRcdCAqIC0gbGVmdFxuXHRcdCAqIC0gdG9wXG5cdFx0ICogLSB3aWR0aFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB2aWV3UGFuZVNpemUgT3B0aW9uYWwuIElmIG5vdCBwcm92aWRlZCwgdGhlIGN1cnJlbnQgdmlld3BvcnQgd2lsbCBiZSB1c2VkLiBTaG91bGQgY29udGFpbiBhdCBsZWFzdCB0aGVzZSBwcm9wZXJ0aWVzOlxuXHRcdCAqIC0gd2lkdGhcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGB4YCBhbmQgYHlgIHByb3BlcnRpZXMsIHdoaWNoIHJlcHJlc2VudCB0aGUgY29uc3RyYWluZWQgcG9zaXRpb24gb2YgdGhlXG5cdFx0ICogZWxlbWVudC5cblx0XHQgKi9cblx0XHRnZXRDb25zdHJhaW5lZFBvc2l0aW9uKGF0dHJzLCB2aWV3UGFuZVNpemUpIHtcblx0XHRcdHZpZXdQYW5lU2l6ZSA9XG5cdFx0XHRcdHZpZXdQYW5lU2l6ZSB8fFxuXHRcdFx0XHRuZXcgQ0tFRElUT1IuZG9tLndpbmRvdyh3aW5kb3cpLmdldFZpZXdQYW5lU2l6ZSgpO1xuXG5cdFx0XHRsZXQgeCA9IGF0dHJzLmxlZnQ7XG5cdFx0XHRsZXQgeSA9IGF0dHJzLnRvcDtcblxuXHRcdFx0aWYgKGF0dHJzLmxlZnQgKyBhdHRycy53aWR0aCA+IHZpZXdQYW5lU2l6ZS53aWR0aCkge1xuXHRcdFx0XHR4IC09IGF0dHJzLmxlZnQgKyBhdHRycy53aWR0aCAtIHZpZXdQYW5lU2l6ZS53aWR0aDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHkgPCAwKSB7XG5cdFx0XHRcdHkgPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR4LFxuXHRcdFx0XHR5LFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiwgaW4gcGFnZSBjb29yZGluYXRlcywgYWNjb3JkaW5nIHRvIHdoaWNoIGEgd2lkZ2V0IHNob3VsZCBhcHBlYXIuXG5cdFx0ICogRGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNlbGVjdGlvbiwgdGhlIHdkaWdldCBtYXkgYXBwZWFyIGFib3ZlIG9mIG9yIG9uIGJvdHRvbSBvZiB0aGUgc2VsZWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogSXQgZGVwZW5kcyBvbiB0aGUgcHJvcHMgZWRpdG9yRXZlbnQgdG8gYW5hbHl6ZSB0aGUgZm9sbG93aW5nIHVzZXItaW50ZXJhY3Rpb24gcGFyYW1ldGVyczpcblx0XHQgKiAtIHtPYmplY3R9IHNlbGVjdGlvbkRhdGEgVGhlIGRhdGEgYWJvdXQgdGhlIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yIGFzIHJldHVybmVkIGZyb21cblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRTZWxlY3Rpb25EYXRhOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqIC0ge051bWJlcn0gcG9zIENvbnRhaW5zIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgcG9zaXRpb24sIGNvbnNpZGVyZWQgYXMgbW9zdCBhcHByb3ByaWF0ZS5cblx0XHQgKiBUaGlzIG1heSBiZSB0aGUgcG9pbnQgd2hlcmUgdGhlIHVzZXIgcmVsZWFzZWQgdGhlIG1vdXNlLCBvciBqdXN0IHRoZSBiZWdpbm5pbmcgb3IgdGhlIGVuZCBvZlxuXHRcdCAqIHRoZSBzZWxlY3Rpb24uXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0SW50ZXJhY3Rpb25Qb2ludFxuXHRcdCAqIEBtZXRob2QgZ2V0SW50ZXJhY3Rpb25Qb2ludFxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gQW4gT2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0XHQgKiBkaXJlY3Rpb24sIHgsIHksIHdoZXJlIHggYW5kIHkgYXJlIGluIHBhZ2UgY29vcmRpbmF0ZXMgYW5kIGRpcmVjdGlvbiBjYW4gYmUgb25lIG9mIHRoZXNlOlxuXHRcdCAqIENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QIG9yIENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NXG5cdFx0ICovXG5cdFx0Z2V0SW50ZXJhY3Rpb25Qb2ludCgpIHtcblx0XHRcdGNvbnN0IGV2ZW50UGF5bG9hZCA9IHRoaXMucHJvcHMuZWRpdG9yRXZlbnRcblx0XHRcdFx0PyB0aGlzLnByb3BzLmVkaXRvckV2ZW50LmRhdGFcblx0XHRcdFx0OiBudWxsO1xuXG5cdFx0XHRpZiAoIWV2ZW50UGF5bG9hZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBldmVudFBheWxvYWQuc2VsZWN0aW9uRGF0YTtcblxuXHRcdFx0Y29uc3QgbmF0aXZlRXZlbnQgPSBldmVudFBheWxvYWQubmF0aXZlRXZlbnQ7XG5cblx0XHRcdGNvbnN0IHBvcyA9IHtcblx0XHRcdFx0eDogZXZlbnRQYXlsb2FkLm5hdGl2ZUV2ZW50LnBhZ2VYLFxuXHRcdFx0XHR5OiBzZWxlY3Rpb25EYXRhLnJlZ2lvbi50b3AsXG5cdFx0XHR9O1xuXG5cdFx0XHRsZXQgZGlyZWN0aW9uID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uZGlyZWN0aW9uO1xuXG5cdFx0XHRjb25zdCBlbmRSZWN0ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uZW5kUmVjdDtcblxuXHRcdFx0Y29uc3Qgc3RhcnRSZWN0ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24uc3RhcnRSZWN0O1xuXG5cdFx0XHRpZiAoZW5kUmVjdCAmJiBzdGFydFJlY3QgJiYgc3RhcnRSZWN0LnRvcCA9PT0gZW5kUmVjdC50b3ApIHtcblx0XHRcdFx0ZGlyZWN0aW9uID0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1A7XG5cdFx0XHR9XG5cblx0XHRcdGxldCB4O1xuXHRcdFx0bGV0IHk7XG5cblx0XHRcdC8vIElmIHdlIGhhdmUgdGhlIHBvaW50IHdoZXJlIHVzZXIgcmVsZWFzZWQgdGhlIG1vdXNlLCBzaG93IFRvb2xiYXIgYXQgdGhpcyBwb2ludFxuXHRcdFx0Ly8gb3RoZXJ3aXNlIHNob3cgaXQgb24gdGhlIG1pZGRsZSBvZiB0aGUgc2VsZWN0aW9uLlxuXG5cdFx0XHRpZiAocG9zLnggJiYgcG9zLnkpIHtcblx0XHRcdFx0eCA9IHRoaXMuX2dldFhQb2ludChzZWxlY3Rpb25EYXRhLCBwb3MueCk7XG5cblx0XHRcdFx0aWYgKGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1ApIHtcblx0XHRcdFx0XHR5ID0gTWF0aC5taW4ocG9zLnksIHNlbGVjdGlvbkRhdGEucmVnaW9uLnRvcCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eSA9IE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0cG9zLnksXG5cdFx0XHRcdFx0XHR0aGlzLl9nZXRZUG9pbnQoc2VsZWN0aW9uRGF0YSwgbmF0aXZlRXZlbnQpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0eCA9IHNlbGVjdGlvbkRhdGEucmVnaW9uLmxlZnQgKyBzZWxlY3Rpb25EYXRhLnJlZ2lvbi53aWR0aCAvIDI7XG5cblx0XHRcdFx0aWYgKGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT00pIHtcblx0XHRcdFx0XHR5ID0gdGhpcy5fZ2V0WVBvaW50KHNlbGVjdGlvbkRhdGEsIG5hdGl2ZUV2ZW50KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR5ID0gc2VsZWN0aW9uRGF0YS5yZWdpb24udG9wO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRpcmVjdGlvbixcblx0XHRcdFx0eCxcblx0XHRcdFx0eSxcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIFdpZGdldC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRJbnRlcmFjdGlvblBvaW50XG5cdFx0ICogQG1ldGhvZCBfZ2V0WFBvaW50XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50WCBUaGUgWCBjb29yZGluYXRlIHJlY2VpdmVkIGZyb20gdGhlIG5hdGl2ZSBldmVudCAobW91c2V1cCkuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHNlbGVjdGlvbkRhdGEgVGhlIGRhdGEgYWJvdXQgdGhlIHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yIGFzIHJldHVybmVkIGZyb20ge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9zZWxlY3Rpb25yZWdpb24vZ2V0U2VsZWN0aW9uRGF0YTptZXRob2RcIn19e3svY3Jvc3NMaW5rfX1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7TnVtYmVyfSBUaGUgY2FsY3VsYXRlZCBYIHBvaW50IGluIHBhZ2UgY29vcmRpbmF0ZXMuXG5cdFx0ICovXG5cdFx0X2dldFhQb2ludChzZWxlY3Rpb25EYXRhLCBldmVudFgpIHtcblx0XHRcdGNvbnN0IHJlZ2lvbiA9IHNlbGVjdGlvbkRhdGEucmVnaW9uO1xuXG5cdFx0XHRjb25zdCBsZWZ0ID0gcmVnaW9uLnN0YXJ0UmVjdCA/IHJlZ2lvbi5zdGFydFJlY3QubGVmdCA6IHJlZ2lvbi5sZWZ0O1xuXHRcdFx0Y29uc3QgcmlnaHQgPSByZWdpb24uZW5kUmVjdCA/IHJlZ2lvbi5lbmRSZWN0LnJpZ2h0IDogcmVnaW9uLnJpZ2h0O1xuXG5cdFx0XHRsZXQgeDtcblxuXHRcdFx0aWYgKGxlZnQgPCBldmVudFggJiYgcmlnaHQgPiBldmVudFgpIHtcblx0XHRcdFx0eCA9IGV2ZW50WDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IGxlZnREaXN0ID0gTWF0aC5hYnMobGVmdCAtIGV2ZW50WCk7XG5cdFx0XHRcdGNvbnN0IHJpZ2h0RGlzdCA9IE1hdGguYWJzKHJpZ2h0IC0gZXZlbnRYKTtcblxuXHRcdFx0XHRpZiAobGVmdERpc3QgPCByaWdodERpc3QpIHtcblx0XHRcdFx0XHQvLyB1c2VyIHJhaXNlZCB0aGUgbW91c2Ugb24gbGVmdCBvbiB0aGUgc2VsZWN0aW9uXG5cdFx0XHRcdFx0eCA9IGxlZnQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eCA9IHJpZ2h0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB4O1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSBXaWRnZXQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgV2lkZ2V0SW50ZXJhY3Rpb25Qb2ludFxuXHRcdCAqIEBtZXRob2QgX2dldFlQb2ludFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBuYXRpdmVFdmVudCBUaGUgZGF0YSBhYm91dCBldmVudCBpcyBmaXJlZFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBzZWxlY3Rpb25EYXRhIFRoZSBkYXRhIGFib3V0IHRoZSBzZWxlY3Rpb24gaW4gdGhlIGVkaXRvciBhcyByZXR1cm5lZCBmcm9tIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfc2VsZWN0aW9ucmVnaW9uL2dldFNlbGVjdGlvbkRhdGE6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEByZXR1cm4ge051bWJlcn0gVGhlIGNhbGN1bGF0ZWQgWSBwb2ludCBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuXHRcdCAqL1xuXHRcdF9nZXRZUG9pbnQoc2VsZWN0aW9uRGF0YSwgbmF0aXZlRXZlbnQpIHtcblx0XHRcdGxldCB5ID0gMDtcblxuXHRcdFx0aWYgKHNlbGVjdGlvbkRhdGEgJiYgbmF0aXZlRXZlbnQpIHtcblx0XHRcdFx0Y29uc3QgZWxlbWVudFRhcmdldCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChcblx0XHRcdFx0XHRuYXRpdmVFdmVudC50YXJnZXRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ZWxlbWVudFRhcmdldC4kICYmXG5cdFx0XHRcdFx0ZWxlbWVudFRhcmdldC5nZXRTdHlsZSgnb3ZlcmZsb3cnKSA9PT0gJ2F1dG8nXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHkgPVxuXHRcdFx0XHRcdFx0bmF0aXZlRXZlbnQudGFyZ2V0Lm9mZnNldFRvcCArXG5cdFx0XHRcdFx0XHRuYXRpdmVFdmVudC50YXJnZXQub2Zmc2V0SGVpZ2h0O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHkgPSBzZWxlY3Rpb25EYXRhLnJlZ2lvbi5ib3R0b207XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHk7XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIFdpZGdldCB0YWtpbmcgaW4gY29uc2lkZXJhdGlvbiB0aGVcblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJXaWRnZXRQb3NpdGlvbi9ndXR0ZXI6YXR0cmlidXRlXCJ9fXt7L2Nyb3NzTGlua319IGF0dHJpYnV0ZS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAbWV0aG9kICBnZXRXaWRnZXRYWVBvaW50XG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgVGhlIGxlZnQgb2Zmc2V0IGluIHBhZ2UgY29vcmRpbmF0ZXMgd2hlcmUgVG9vbGJhciBzaG91bGQgYmUgc2hvd24uXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUaGUgdG9wIG9mZnNldCBpbiBwYWdlIGNvb3JkaW5hdGVzIHdoZXJlIFRvb2xiYXIgc2hvdWxkIGJlIHNob3duLlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiBvZiB0aGUgc2VsZWN0aW9uLiBNYXkgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG5cdFx0ICogQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1Agb3IgQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT01cblx0XHQgKiBAcmV0dXJuIHtBcnJheX0gQW4gQXJyYXkgd2l0aCBsZWZ0IGFuZCB0b3Agb2Zmc2V0cyBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuXHRcdCAqL1xuXHRcdGdldFdpZGdldFhZUG9pbnQobGVmdCwgdG9wLCBkaXJlY3Rpb24pIHtcblx0XHRcdGNvbnN0IGRvbU5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcblxuXHRcdFx0Y29uc3QgZ3V0dGVyID0gdGhpcy5wcm9wcy5ndXR0ZXI7XG5cblx0XHRcdGlmIChcblx0XHRcdFx0ZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTSB8fFxuXHRcdFx0XHRkaXJlY3Rpb24gPT09IENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QXG5cdFx0XHQpIHtcblx0XHRcdFx0bGVmdCA9IGxlZnQgLSBndXR0ZXIubGVmdCAtIGRvbU5vZGUub2Zmc2V0V2lkdGggLyAyO1xuXG5cdFx0XHRcdHRvcCA9XG5cdFx0XHRcdFx0ZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTVxuXHRcdFx0XHRcdFx0PyB0b3AgKyBndXR0ZXIudG9wXG5cdFx0XHRcdFx0XHQ6IHRvcCAtIGRvbU5vZGUub2Zmc2V0SGVpZ2h0IC0gZ3V0dGVyLnRvcDtcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX0xFRlRfVE9fUklHSFQgfHxcblx0XHRcdFx0ZGlyZWN0aW9uID09PSBDS0VESVRPUi5TRUxFQ1RJT05fUklHSFRfVE9fTEVGVFxuXHRcdFx0KSB7XG5cdFx0XHRcdGxlZnQgPVxuXHRcdFx0XHRcdGRpcmVjdGlvbiA9PT0gQ0tFRElUT1IuU0VMRUNUSU9OX0xFRlRfVE9fUklHSFRcblx0XHRcdFx0XHRcdD8gbGVmdCArIGd1dHRlci5sZWZ0ICsgZG9tTm9kZS5vZmZzZXRIZWlnaHQgLyAyXG5cdFx0XHRcdFx0XHQ6IGxlZnQgLSAoMyAqIGRvbU5vZGUub2Zmc2V0SGVpZ2h0KSAvIDIgLSBndXR0ZXIubGVmdDtcblxuXHRcdFx0XHR0b3AgPSB0b3AgLSBndXR0ZXIudG9wIC0gZG9tTm9kZS5vZmZzZXRIZWlnaHQgLyAyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobGVmdCA8IDApIHtcblx0XHRcdFx0bGVmdCA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0b3AgPCAwKSB7XG5cdFx0XHRcdHRvcCA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBbbGVmdCwgdG9wXTtcblx0XHR9XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHdpZGdldCBpcyB2aXNpYmxlLCBmYWxzZSBvdGhlcndpc2Vcblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHRcdCAqIEBtZXRob2QgaXNWaXNpYmxlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgd2lkZ2V0IGlzIHZpc2libGUsIGZhbHNlIG90aGVyd2lzZVxuXHRcdCAqL1xuXHRcdGlzVmlzaWJsZSgpIHtcblx0XHRcdGNvbnN0IGRvbU5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcblxuXHRcdFx0aWYgKGRvbU5vZGUpIHtcblx0XHRcdFx0Y29uc3QgZG9tRWxlbWVudCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChkb21Ob2RlKTtcblxuXHRcdFx0XHRyZXR1cm4gZG9tRWxlbWVudC5oYXNDbGFzcygnYWxsb3ktZWRpdG9yLXZpc2libGUnKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIE1vdmVzIGEgd2lkZ2V0IGZyb20gYSBzdGFydGluZyBwb2ludCB0byBhIGRlc3RpbmF0aW9uIHBvaW50LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG5cdFx0ICogQG1ldGhvZCBtb3ZlVG9Qb2ludFxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gc3RhcnRQb2ludCBUaGUgc3RhcnRpbmcgcG9pbnQgZm9yIHRoZSBtb3ZlbWVudC5cblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9IGVuZFBvaW50IFRoZSBkZXN0aW5hdGlvbiBwb2ludCBmb3IgdGhlIG1vdmVtZW50LlxuXHRcdCAqL1xuXHRcdG1vdmVUb1BvaW50KHN0YXJ0UG9pbnQsIGVuZFBvaW50KSB7XG5cdFx0XHRjb25zdCBkb21FbGVtZW50ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KFxuXHRcdFx0XHRSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKVxuXHRcdFx0KTtcblxuXHRcdFx0ZG9tRWxlbWVudC5zZXRTdHlsZXMoe1xuXHRcdFx0XHRsZWZ0OiBzdGFydFBvaW50WzBdICsgJ3B4Jyxcblx0XHRcdFx0dG9wOiBzdGFydFBvaW50WzFdICsgJ3B4Jyxcblx0XHRcdFx0b3BhY2l0eTogMCxcblx0XHRcdFx0cG9pbnRlckV2ZW50czogJ25vbmUnLFxuXHRcdFx0fSk7XG5cblx0XHRcdGRvbUVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2FsbG95LWVkaXRvci1pbnZpc2libGUnKTtcblxuXHRcdFx0dGhpcy5fYW5pbWF0aW9uRnJhbWVJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuXHRcdFx0XHRkb21FbGVtZW50LmFkZENsYXNzKCdhZS10b29sYmFyLXRyYW5zaXRpb24nKTtcblx0XHRcdFx0ZG9tRWxlbWVudC5hZGRDbGFzcygnYWxsb3ktZWRpdG9yLXZpc2libGUnKTtcblx0XHRcdFx0ZG9tRWxlbWVudC5zZXRTdHlsZXMoe1xuXHRcdFx0XHRcdGxlZnQ6IGVuZFBvaW50WzBdICsgJ3B4Jyxcblx0XHRcdFx0XHR0b3A6IGVuZFBvaW50WzFdICsgJ3B4Jyxcblx0XHRcdFx0XHRvcGFjaXR5OiAxLFxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHQvLyAxNTBtcyB0byBtYXRjaCB0cmFuc2l0aW9uLWR1cmF0aW9uIGZvciAuYWUtdG9vbGJhci10cmFuc2l0aW9uOlxuXHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHRkb21FbGVtZW50LnNldFN0eWxlcyh7XG5cdFx0XHRcdFx0XHRwb2ludGVyRXZlbnRzOiAnJyxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSwgMTUwKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8qKlxuXHRcdCAqIFNob3dzIHRoZSB3aWRnZXQgd2l0aCB0aGUgZGVmYXVsdCBhbmltYXRpb24gdHJhbnNpdGlvbi5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBXaWRnZXRQb3NpdGlvblxuXHRcdCAqIEBtZXRob2Qgc2hvd1xuXHRcdCAqL1xuXHRcdHNob3coKSB7XG5cdFx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cdFx0XHRjb25zdCB1aU5vZGUgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgndWlOb2RlJyk7XG5cblx0XHRcdGNvbnN0IHNjcm9sbFRvcCA9IHVpTm9kZSA/IHVpTm9kZS5zY3JvbGxUb3AgOiAwO1xuXG5cdFx0XHRpZiAoIXRoaXMuaXNWaXNpYmxlKCkgJiYgZG9tTm9kZSkge1xuXHRcdFx0XHRjb25zdCBpbnRlcmFjdGlvblBvaW50ID0gdGhpcy5nZXRJbnRlcmFjdGlvblBvaW50KCk7XG5cblx0XHRcdFx0aWYgKGludGVyYWN0aW9uUG9pbnQpIHtcblx0XHRcdFx0XHRjb25zdCBkb21FbGVtZW50ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGRvbU5vZGUpO1xuXG5cdFx0XHRcdFx0bGV0IGZpbmFsWDtcblx0XHRcdFx0XHRsZXQgZmluYWxZO1xuXHRcdFx0XHRcdGxldCBpbml0aWFsWDtcblx0XHRcdFx0XHRsZXQgaW5pdGlhbFk7XG5cblx0XHRcdFx0XHRmaW5hbFggPSBpbml0aWFsWCA9IHBhcnNlRmxvYXQoZG9tRWxlbWVudC5nZXRTdHlsZSgnbGVmdCcpKTtcblx0XHRcdFx0XHRmaW5hbFkgPSBpbml0aWFsWSA9IHBhcnNlRmxvYXQoZG9tRWxlbWVudC5nZXRTdHlsZSgndG9wJykpO1xuXG5cdFx0XHRcdFx0aWYgKHRoaXMucHJvcHMuY29uc3RyYWluVG9WaWV3cG9ydCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgcmVzID0gdGhpcy5nZXRDb25zdHJhaW5lZFBvc2l0aW9uKHtcblx0XHRcdFx0XHRcdFx0aGVpZ2h0OiBwYXJzZUZsb2F0KGRvbU5vZGUub2Zmc2V0SGVpZ2h0KSxcblx0XHRcdFx0XHRcdFx0bGVmdDogZmluYWxYLFxuXHRcdFx0XHRcdFx0XHR0b3A6IGZpbmFsWSxcblx0XHRcdFx0XHRcdFx0d2lkdGg6IHBhcnNlRmxvYXQoZG9tTm9kZS5vZmZzZXRXaWR0aCksXG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0ZmluYWxYID0gcmVzLng7XG5cdFx0XHRcdFx0XHRmaW5hbFkgPSByZXMueTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRpbnRlcmFjdGlvblBvaW50LmRpcmVjdGlvbiA9PT1cblx0XHRcdFx0XHRcdENLRURJVE9SLlNFTEVDVElPTl9UT1BfVE9fQk9UVE9NXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRpbml0aWFsWSA9XG5cdFx0XHRcdFx0XHRcdHRoaXMucHJvcHMuc2VsZWN0aW9uRGF0YS5yZWdpb24uYm90dG9tICsgc2Nyb2xsVG9wO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpbml0aWFsWSA9XG5cdFx0XHRcdFx0XHRcdHRoaXMucHJvcHMuc2VsZWN0aW9uRGF0YS5yZWdpb24udG9wICsgc2Nyb2xsVG9wO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMubW92ZVRvUG9pbnQoW2luaXRpYWxYLCBpbml0aWFsWV0sIFtmaW5hbFgsIGZpbmFsWV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyB0aGUgd2lkZ2V0IHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBjdXJyZW50IGludGVyYWN0aW9uIHBvaW50LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFdpZGdldFBvc2l0aW9uXG5cdFx0ICogQG1ldGhvZCB1cGRhdGVQb3NpdGlvblxuXHRcdCAqL1xuXHRcdHVwZGF0ZVBvc2l0aW9uKCkge1xuXHRcdFx0Y29uc3QgaW50ZXJhY3Rpb25Qb2ludCA9IHRoaXMuZ2V0SW50ZXJhY3Rpb25Qb2ludCgpO1xuXG5cdFx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cblx0XHRcdGlmIChpbnRlcmFjdGlvblBvaW50ICYmIGRvbU5vZGUpIHtcblx0XHRcdFx0Y29uc3QgdWlOb2RlID1cblx0XHRcdFx0XHR0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgndWlOb2RlJykgfHwgZG9jdW1lbnQuYm9keTtcblx0XHRcdFx0Y29uc3QgdWlOb2RlU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHVpTm9kZSk7XG5cdFx0XHRcdGNvbnN0IHVpTm9kZU1hcmdpbkxlZnQgPSBwYXJzZUludChcblx0XHRcdFx0XHR1aU5vZGVTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdtYXJnaW4tbGVmdCcpLFxuXHRcdFx0XHRcdDEwXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnN0IHVpTm9kZU1hcmdpblJpZ2h0ID0gcGFyc2VJbnQoXG5cdFx0XHRcdFx0dWlOb2RlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLXJpZ2h0JyksXG5cdFx0XHRcdFx0MTBcblx0XHRcdFx0KTtcblx0XHRcdFx0Y29uc3QgdG90YWxXaWR0aCA9XG5cdFx0XHRcdFx0dWlOb2RlTWFyZ2luTGVmdCArIHVpTm9kZS5jbGllbnRXaWR0aCArIHVpTm9kZU1hcmdpblJpZ2h0O1xuXG5cdFx0XHRcdGNvbnN0IHNjcm9sbFRvcCA9XG5cdFx0XHRcdFx0dWlOb2RlLnRhZ05hbWUgIT09ICdCT0RZJyA/IHVpTm9kZS5zY3JvbGxUb3AgOiAwO1xuXG5cdFx0XHRcdGNvbnN0IHh5ID0gdGhpcy5nZXRXaWRnZXRYWVBvaW50KFxuXHRcdFx0XHRcdGludGVyYWN0aW9uUG9pbnQueCxcblx0XHRcdFx0XHRpbnRlcmFjdGlvblBvaW50LnksXG5cdFx0XHRcdFx0aW50ZXJhY3Rpb25Qb2ludC5kaXJlY3Rpb25cblx0XHRcdFx0KTtcblx0XHRcdFx0eHlbMV0gKz0gc2Nyb2xsVG9wO1xuXG5cdFx0XHRcdGlmICh4eVswXSA8IDApIHtcblx0XHRcdFx0XHR4eVswXSA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHh5WzBdID4gdG90YWxXaWR0aCAtIGRvbU5vZGUub2Zmc2V0V2lkdGgpIHtcblx0XHRcdFx0XHR4eVswXSA9IHRvdGFsV2lkdGggLSBkb21Ob2RlLm9mZnNldFdpZHRoO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGRvbU5vZGUpLnNldFN0eWxlcyh7XG5cdFx0XHRcdFx0bGVmdDogeHlbMF0gKyAncHgnLFxuXHRcdFx0XHRcdHRvcDogeHlbMV0gKyAncHgnLFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG4iLCJpbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgQnV0dG9uUHJvcHMgZnJvbSAnLi4vYmFzZS9idXR0b24tcHJvcHMnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKipcbiAqIFRoZSBCdXR0b25BY2Nlc3NpYmlsaXR5SW1hZ2VBbHQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2hhbmdpbmcgdGV4dCBjb2xvciBpbiBhIGRvY3VtZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25BY2Nlc3NpYmlsaXR5SW1hZ2VBbHRcbiAqIEB1c2VzIEJ1dHRvblByb3BzXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqXG4gKi9cbmNsYXNzIEJ1dHRvbkFjY2Vzc2liaWxpdHlJbWFnZUFsdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0c3RhdGljIGtleSA9ICdpbWFnZUFsdCc7XG5cblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHRjb25zdCBlbGVtZW50ID0gcHJvcHMuY29udGV4dC5lZGl0b3Jcblx0XHRcdC5nZXQoJ25hdGl2ZUVkaXRvcicpXG5cdFx0XHQuZ2V0U2VsZWN0aW9uKClcblx0XHRcdC5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuXHRcdGNvbnN0IGltYWdlQWx0ID0gKGVsZW1lbnQgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FsdCcpKSB8fCAnJztcblxuXHRcdHRoaXMuc3RhdGUgPSB7XG5cdFx0XHRlbGVtZW50LFxuXHRcdFx0aW1hZ2VBbHQsXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gJ2FlLWJ1dHRvbiAnICsgdGhpcy5nZXRTdGF0ZUNsYXNzZXMoKTtcblxuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZWRpdC1saW5rXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItaW5wdXQgeHhsXCI+XG5cdFx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdFx0YXJpYS1sYWJlbD1cImFsdFwiXG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWlucHV0XCJcblx0XHRcdFx0XHRcdFx0b25DaGFuZ2U9e3RoaXMuX2hhbmRsZUFsdENoYW5nZX1cblx0XHRcdFx0XHRcdFx0b25LZXlEb3duPXt0aGlzLl9oYW5kbGVLZXlEb3dufVxuXHRcdFx0XHRcdFx0XHRwbGFjZWhvbGRlcj1cImFsdFwiXG5cdFx0XHRcdFx0XHRcdHJlZj1cInJlZkFsdElucHV0XCJcblx0XHRcdFx0XHRcdFx0dGl0bGU9XCJhbHRcIlxuXHRcdFx0XHRcdFx0XHR0eXBlPVwidGV4dFwiXG5cdFx0XHRcdFx0XHRcdHZhbHVlPXt0aGlzLnN0YXRlLmltYWdlQWx0fVxuXHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbmZpcm19XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdFx0b25DbGljaz17dGhpcy5fdXBkYXRlSW1hZ2VBbHR9XG5cdFx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5jb25maXJtfT5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNoZWNrXCIgLz5cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9yZXF1ZXN0RXhjbHVzaXZlfVxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fT5cblx0XHRcdFx0XHQ8c21hbGwgY2xhc3NOYW1lPVwiYWUtaWNvbiBzbWFsbFwiPkFsdDwvc21hbGw+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRm9jdXNlcyB0aGUgdXNlciBjdXJzb3Igb24gdGhlIHdpZGdldCdzIGlucHV0LlxuXHQgKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX2ZvY3VzQWx0SW5wdXRcblx0ICovXG5cdF9mb2N1c0FsdElucHV0KCkge1xuXHRcdGNvbnN0IGluc3RhbmNlID0gdGhpcztcblxuXHRcdGNvbnN0IGZvY3VzQWx0RWwgPSBmdW5jdGlvbigpIHtcblx0XHRcdFJlYWN0RE9NLmZpbmRET01Ob2RlKGluc3RhbmNlLnJlZnMucmVmQWx0SW5wdXQpLmZvY3VzKCk7XG5cdFx0fTtcblxuXHRcdGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZvY3VzQWx0RWwpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZXRUaW1lb3V0KGZvY3VzQWx0RWwsIDApO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFdmVudCBhdHRhY2hlZCB0byBhbHQgaW5wdXQgdGhhdCBmaXJlcyB3aGVuIGl0cyB2YWx1ZSBpcyBjaGFuZ2VkXG5cdCAqXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCAgX2hhbmRsZUFsdENoYW5nZVxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG5cdCAqL1xuXHRfaGFuZGxlQWx0Q2hhbmdlID0gZXZlbnQgPT4ge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0aW1hZ2VBbHQ6IGV2ZW50LnRhcmdldC52YWx1ZSxcblx0XHR9KTtcblxuXHRcdHRoaXMuX2ZvY3VzQWx0SW5wdXQoKTtcblx0fTtcblxuXHQvKipcblx0ICogRXZlbnQgYXR0YWNoZWQgdG8gYWwgdGlucHV0IHRoYXQgZmlyZXMgd2hlbiBrZXkgaXMgZG93blxuXHQgKiBUaGlzIG1ldGhvZCBjaGVjayB0aGF0IGVudGVyIGtleSBpcyBwdXNoZWQgdG8gdXBkYXRlIHRoZSBjb21wb25lbnTCtHMgc3RhdGVcblx0ICpcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kICBfaGFuZGxlS2V5RG93blxuXHQgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50XG5cdCAqL1xuXHRfaGFuZGxlS2V5RG93biA9IGV2ZW50ID0+IHtcblx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUltYWdlQWx0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0cyB0aGUgbGluayBidXR0b24gdG8gYmUgcmVuZGVyZWQgaW4gZXhjbHVzaXZlIG1vZGUgdG8gYWxsb3cgdGhlIGNyZWF0aW9uIG9mIGEgbGluay5cblx0ICpcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF9yZXF1ZXN0RXhjbHVzaXZlXG5cdCAqL1xuXHRfcmVxdWVzdEV4Y2x1c2l2ZSA9ICgpID0+IHtcblx0XHR0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmUoQnV0dG9uQWNjZXNzaWJpbGl0eUltYWdlQWx0LmtleSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1ldGhvZCBjYWxsZWQgYnkgY2xpY2tpbmcgb2sgYnV0dG9uIG9yIHB1c2hpbmcga2V5IGVudGVyIHRvIHVwZGF0ZSBpbWFnZUFsdCBzdGF0ZSBhbmQgdG8gdXBkYXRlIGFsdCBwcm9wZXJ0eSBmcm9tIHRoZSBpbWFnZSB0aGF0IGlzIHNlbGVjdGVkXG5cdCAqIFRoaXMgbWV0aG9kIGNhbGxzIGNhbmNlbEV4Y2x1c2l2ZSB0byBzaG93IHRoZSBwcmV2aW91cyB0b29sYmFyIGJlZm9yZSBlbnRlciB0byBlZGl0IGFsdCBwcm9wZXJ0eVxuXHQgKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgIF91cGRhdGVJbWFnZUFsdFxuXHQgKi9cblx0X3VwZGF0ZUltYWdlQWx0ID0gKCkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGNvbnN0IGltYWdlQWx0ID0gdGhpcy5yZWZzLnJlZkFsdElucHV0LnZhbHVlO1xuXG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRpbWFnZUFsdCxcblx0XHR9KTtcblxuXHRcdHRoaXMuc3RhdGUuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FsdCcsIGltYWdlQWx0KTtcblxuXHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblxuXHRcdC8vIFdlIG5lZWQgdG8gY2FuY2VsRXhjbHVzaXZlIHdpdGggdGhlIGJvdW5kIHBhcmFtZXRlcnMgaW4gY2FzZSB0aGUgYnV0dG9uIGlzIHVzZWRcblx0XHQvLyBpbnNpZGUgYW5vdGhlciBpbiBleGNsdXNpdmUgbW9kZSAoc3VjaCBpcyB0aGUgY2FzZSBvZiB0aGUgYWx0IGJ1dHRvbilcblx0XHR0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBFZGl0b3JDb250ZXh0LnRvUHJvcHMoXG5cdEJ1dHRvblByb3BzKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25BY2Nlc3NpYmlsaXR5SW1hZ2VBbHQpKVxuKTtcbiIsImltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25Qcm9wcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1wcm9wcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3QgZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QuanN4JztcbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmNsYXNzIEJ1dHRvbkJhY2tncm91bmRDb2xvciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0c3RhdGljIGtleSA9ICdiYWNrZ3JvdW5kQ29sb3InO1xuXG5cdHN0YXRpYyBwcm9wVHlwZXMgPSB7XG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHN0eWxlcyBsaXN0IGlzIGV4cGFuZGVkIG9yIG5vdC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25CYWNrZ3JvdW5kQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IGV4cGFuZGVkXG5cdFx0ICovXG5cdFx0ZXhwYW5kZWQ6IFByb3BUeXBlcy5ib29sLFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxhYmVsIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZXMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQmFja2dyb3VuZENvbG9yXG5cdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGxhYmVsXG5cdFx0ICovXG5cdFx0bGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG5cblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVtb3ZlIHN0eWxlcyBpdGVtIHNob3VsZCBhcHBlYXIgaW4gdGhlIHN0eWxlcyBsaXN0LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkJhY2tncm91bmRDb2xvclxuXHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2hvd1JlbW92ZVN0eWxlc0l0ZW1cblx0XHQgKi9cblx0XHRzaG93UmVtb3ZlU3R5bGVzSXRlbTogUHJvcFR5cGVzLmJvb2wsXG5cblx0XHQvKipcblx0XHQgKiBMaXN0IG9mIHRoZSBzdHlsZXMgdGhlIGJ1dHRvbiBpcyBhYmxlIHRvIGhhbmRsZS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25CYWNrZ3JvdW5kQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge0FycmF5fSBzdHlsZXNcblx0XHQgKi9cblx0XHRzdHlsZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vYmplY3QpLFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRhYkluZGV4IG9mIHRoZSBidXR0b24gaW4gaXRzIHRvb2xiYXIgY3VycmVudCBzdGF0ZS4gQSB2YWx1ZSBvdGhlciB0aGFuIC0xXG5cdFx0ICogbWVhbnMgdGhhdCB0aGUgYnV0dG9uIGhhcyBmb2N1cyBhbmQgaXMgdGhlIGFjdGl2ZSBlbGVtZW50LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkJhY2tncm91bmRDb2xvclxuXHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0YWJJbmRleFxuXHRcdCAqL1xuXHRcdHRhYkluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuXG5cdFx0LyoqXG5cdFx0ICogQ2FsbGJhY2sgcHJvdmlkZWQgYnkgdGhlIGJ1dHRvbiBob3N0IHRvIG5vdGlmeSB3aGVuIHRoZSBzdHlsZXMgbGlzdCBoYXMgYmVlbiBleHBhbmRlZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25CYWNrZ3JvdW5kQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB0b2dnbGVEcm9wZG93blxuXHRcdCAqL1xuXHRcdHRvZ2dsZURyb3Bkb3duOiBQcm9wVHlwZXMuZnVuYyxcblx0fTtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRsZXQgYWN0aXZlQ29sb3IgPSBBbGxveUVkaXRvci5TdHJpbmdzLm5vcm1hbDtcblxuXHRcdGxldCBhY3RpdmVDb2xvckNsYXNzID0gJyc7XG5cblx0XHRjb25zdCBjb2xvcnMgPSB0aGlzLl9nZXRDb2xvcnMoKTtcblxuXHRcdGNvbnN0IGl0ZW1TdHlsZSA9IHtcblx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0Y2xhc3M6ICcnLFxuXHRcdFx0fSxcblx0XHR9O1xuXG5cdFx0Y29sb3JzLmZvckVhY2goaXRlbSA9PiB7XG5cdFx0XHRpdGVtU3R5bGUuYXR0cmlidXRlcy5jbGFzcyA9IGl0ZW0uc3R5bGVDbGFzcztcblxuXHRcdFx0aWYgKHRoaXMuX2NoZWNrQWN0aXZlKGl0ZW1TdHlsZSkpIHtcblx0XHRcdFx0YWN0aXZlQ29sb3IgPSBpdGVtLm5hbWU7XG5cblx0XHRcdFx0YWN0aXZlQ29sb3JDbGFzcyA9IGl0ZW0uc3R5bGUuYXR0cmlidXRlcy5jbGFzcztcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGNvbnN0IHtleHBhbmRlZCwgdGFiSW5kZXgsIHRvZ2dsZURyb3Bkb3dufSA9IHRoaXMucHJvcHM7XG5cblx0XHRjb25zdCBidXR0b25TdHlsZXNQcm9wcyA9IHtcblx0XHRcdGFjdGl2ZVN0eWxlOiBhY3RpdmVDb2xvcixcblx0XHRcdG9uRGlzbWlzczogdG9nZ2xlRHJvcGRvd24sXG5cdFx0XHRzaG93UmVtb3ZlU3R5bGVzSXRlbTogZmFsc2UsXG5cdFx0XHRzdHlsZXM6IGNvbG9ycyxcblx0XHR9O1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyIGFlLWhhcy1kcm9wZG93blwiPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1leHBhbmRlZD17ZXhwYW5kZWR9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtdG9vbGJhci1lbGVtZW50XCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0XHRyb2xlPVwiY29tYm9ib3hcIlxuXHRcdFx0XHRcdHRhYkluZGV4PXt0YWJJbmRleH0+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPXthY3RpdmVDb2xvckNsYXNzfT5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInRleHRib3hcIiAvPlxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdHtleHBhbmRlZCAmJiA8QnV0dG9uU3R5bGVzTGlzdCB7Li4uYnV0dG9uU3R5bGVzUHJvcHN9IC8+fVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdF9hcHBseVN0eWxlKGNsYXNzTmFtZSkge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGNvbnN0IHN0eWxlQ29uZmlnID0ge1xuXHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRjbGFzczogY2xhc3NOYW1lLFxuXHRcdFx0fSxcblx0XHR9O1xuXG5cdFx0ZWRpdG9yLmdldFNlbGVjdGlvbigpLmxvY2soKTtcblxuXHRcdHRoaXMuX2dldENvbG9ycygpLmZvckVhY2goaXRlbSA9PiB7XG5cdFx0XHRzdHlsZUNvbmZpZy5hdHRyaWJ1dGVzLmNsYXNzID0gaXRlbS5zdHlsZUNsYXNzO1xuXG5cdFx0XHRpZiAodGhpcy5fY2hlY2tBY3RpdmUoc3R5bGVDb25maWcpKSB7XG5cdFx0XHRcdGVkaXRvci5yZW1vdmVTdHlsZShuZXcgQ0tFRElUT1Iuc3R5bGUoc3R5bGVDb25maWcpKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHN0eWxlQ29uZmlnLmF0dHJpYnV0ZXMuY2xhc3MgPSBjbGFzc05hbWU7XG5cblx0XHRjb25zdCBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZShzdHlsZUNvbmZpZyk7XG5cblx0XHRlZGl0b3IuYXBwbHlTdHlsZShzdHlsZSk7XG5cblx0XHRlZGl0b3IuZ2V0U2VsZWN0aW9uKCkudW5sb2NrKCk7XG5cblx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBjb2xvciBkZWZpbml0aW9uIGlzIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQmFja2dyb3VuZENvbG9yXG5cdCAqIEBtZXRob2QgX2NoZWNrQWN0aXZlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZUNvbmZpZyBjb2xvciBkZWZpbml0aW9uIGFzIHBlciBodHRwOi8vZG9jcy5ja2VkaXRvci5jb20vIyEvYXBpL0NLRURJVE9SLnN0eWxlLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgY29sb3IgaXMgYXBwbGllZCB0byB0aGUgc2VsZWN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuXHRfY2hlY2tBY3RpdmUoc3R5bGVDb25maWcpIHtcblx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHQvLyBTdHlsZXMgd2l0aCB3aWxkY2FyZCBlbGVtZW50ICgqKSB3b24ndCBiZSBjb25zaWRlcmVkIGFjdGl2ZSBieSBDS0VkaXRvci4gRGVmYXVsdGluZ1xuXHRcdC8vIHRvIGEgJ3NwYW4nIGVsZW1lbnQgd29ya3MgZm9yIG1vc3Qgb2YgdGhvc2UgY2FzZXMgd2l0aCBubyBkZWZpbmVkIGVsZW1lbnQuXG5cdFx0c3R5bGVDb25maWcgPSBDS0VESVRPUi50b29scy5tZXJnZSh7ZWxlbWVudDogJ3NwYW4nfSwgc3R5bGVDb25maWcpO1xuXG5cdFx0Y29uc3Qgc3R5bGUgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoc3R5bGVDb25maWcpO1xuXG5cdFx0cmV0dXJuIHN0eWxlLmNoZWNrQWN0aXZlKG5hdGl2ZUVkaXRvci5lbGVtZW50UGF0aCgpLCBuYXRpdmVFZGl0b3IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYW4gYXJyYXkgb2YgY29sb3JzLiBFYWNoIGNvbG9yIGNvbnNpc3RzIG9mIHR3byBwcm9wZXJ0aWVzOlxuXHQgKiAtIG5hbWUgLSB0aGUgc3R5bGUgbmFtZSwgZm9yIGV4YW1wbGUgXCJkZWZhdWx0XCJcblx0ICogLSBzdHlsZSAtIGFuIG9iamVjdCB3aXRoIG9uZSBwcm9wZXJ0eSwgY2FsbGVkIGBlbGVtZW50YCB3aGljaCB2YWx1ZVxuXHQgKiByZXByZXNlbnRzIHRoZSBzdHlsZSB3aGljaCBoYXZlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQmFja2dyb3VuZENvbG9yXG5cdCAqIEBtZXRob2QgX2dldENvbG9yXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7QXJyYXk8b2JqZWN0Pn0gQW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBjb2xvcnMuXG5cdCAqL1xuXHRfZ2V0Q29sb3JzKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLnN0eWxlcyB8fCBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLm5vcm1hbCxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtYm9keScsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVDbGFzczogJycsXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICcnKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MucHJpbWFyeSxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtcHJpbWFyeScsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVDbGFzczogJ2JnLXByaW1hcnknLFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnYmctcHJpbWFyeScpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5kaXNhYmxlZCxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtc2Vjb25kYXJ5Jyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUNsYXNzOiAnYmctc2Vjb25kYXJ5Jyxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ2JnLXNlY29uZGFyeScpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5zdWNjZXNzLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC1zdWNjZXNzJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUNsYXNzOiAnYmctc3VjY2VzcycsXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICdiZy1zdWNjZXNzJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmRhbmdlcixcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtZGFuZ2VyJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUNsYXNzOiAnYmctZGFuZ2VyJyxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ2JnLWRhbmdlcicpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy53YXJuaW5nLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC13YXJuaW5nJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUNsYXNzOiAnYmctd2FybmluZycsXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICdiZy13YXJuaW5nJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmluZm8sXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRcdFx0Y2xhc3M6ICd0ZXh0LWluZm8nLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlQ2xhc3M6ICdiZy1pbmZvJyxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ2JnLWluZm8nKSxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblByb3BzKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25CYWNrZ3JvdW5kQ29sb3IpKTtcbiIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbktleXN0cm9rZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1rZXlzdHJva2UnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Cb2xkIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHN0eWxpbmcgYW4gc2VsZWN0aW9uIHdpdGggc3Ryb25nIChib2xkKSBzdHlsZS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQm9sZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uS2V5c3Ryb2tlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvbkJvbGQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQm9sZFxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdib2xkJyxcblx0XHRrZXlzdHJva2U6IHtcblx0XHRcdGZuOiAnZXhlY0NvbW1hbmQnLFxuXHRcdFx0a2V5czogQ0tFRElUT1IuQ1RSTCArIDY2IC8qIEIqLyxcblx0XHR9LFxuXHRcdHN0eWxlOiAnY29yZVN0eWxlc19ib2xkJyxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IGJvbGRcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkJvbGRcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2JvbGQnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQm9sZFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5ib2xkfVxuXHRcdFx0XHRhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9XG5cdFx0XHRcdGNsYXNzTmFtZT17Y3NzQ2xhc3N9XG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1ib2xkXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmJvbGR9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJib2xkXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcblx0QnV0dG9uS2V5c3Ryb2tlKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25TdHlsZShCdXR0b25Cb2xkKSkpXG4pO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25DYW1lcmFJbWFnZSBjbGFzcyB0YWtlcyBwaG90byBmcm9tIGNhbWVyYSBhbmQgaW5zZXJ0cyBpdCB0byB0aGUgY29udGVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQ2FtZXJhSW1hZ2VcbiAqL1xuY2xhc3MgQnV0dG9uQ2FtZXJhSW1hZ2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHR2aWRlb1dpZHRoOiAzMjAsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBjYW1lcmFJbWFnZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ2FtZXJhSW1hZ2Vcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2NhbWVyYUltYWdlJztcblxuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblx0XHR0aGlzLl9idXR0b25UYWtlUGhvdG9SZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcblx0XHR0aGlzLl9jYW52YXNDb250YWluZXJSZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcblx0XHR0aGlzLl92aWRlb0NvbnRhaW5lclJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdCAqXG5cdCAqIEZvY3VzZXMgdGhlIHRha2UgcGhvdG8gYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcblx0ICovXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdHRoaXMuX2J1dHRvblRha2VQaG90b1JlZi5jdXJyZW50LmZvY3VzKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZnJvbSB0aGUgRE9NLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG5cdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbFVubW91bnRcblx0ICovXG5cdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdGlmICh0aGlzLl9zdHJlYW0pIHtcblx0XHRcdGlmICh0aGlzLl9zdHJlYW0uc3RvcCkge1xuXHRcdFx0XHR0aGlzLl9zdHJlYW0uc3RvcCgpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLl9zdHJlYW0uZ2V0VmlkZW9UcmFja3MpIHtcblx0XHRcdFx0dGhpcy5fc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuXHRcdFx0XHRcdHRyYWNrLnN0b3AoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zdHJlYW0gPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ2FtZXJhSW1hZ2Vcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgZ2V0VXNlck1lZGlhID1cblx0XHRcdG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHxcblx0XHRcdG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHxcblx0XHRcdG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHxcblx0XHRcdG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYTtcblxuXHRcdGdldFVzZXJNZWRpYS5jYWxsKFxuXHRcdFx0bmF2aWdhdG9yLFxuXHRcdFx0e1xuXHRcdFx0XHR2aWRlbzogdHJ1ZSxcblx0XHRcdFx0YXVkaW86IGZhbHNlLFxuXHRcdFx0fSxcblx0XHRcdHRoaXMuX2hhbmRsZVN0cmVhbVN1Y2Nlc3MsXG5cdFx0XHR0aGlzLl9oYW5kbGVTdHJlYW1FcnJvclxuXHRcdCk7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jYW1lcmFcIj5cblx0XHRcdFx0PHZpZGVvIHJlZj17dGhpcy5fdmlkZW9Db250YWluZXJSZWZ9PlxuXHRcdFx0XHRcdFZpZGVvIHN0cmVhbSBub3QgYXZhaWxhYmxlLlxuXHRcdFx0XHQ8L3ZpZGVvPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtY2FtZXJhLXNob290XCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnRha2VQaG90b31cblx0XHRcdFx0XHRyZWY9e3RoaXMuX2J1dHRvblRha2VQaG90b1JlZn0+XG5cdFx0XHRcdFx0VGFrZSBwaG90b1xuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PGNhbnZhc1xuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWNhbWVyYS1jYW52YXNcIlxuXHRcdFx0XHRcdHJlZj17dGhpcy5fY2FudmFzQ29udGFpbmVyUmVmfVxuXHRcdFx0XHQvPlxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUYWtlcyBwaG90byBmcm9tIHRoZSB2aWRlbyBzdHJlYW0gYW5kIGluc2VydHMgaW4gaW50byBlZGl0b3IncyBjb250ZW50LlxuXHQgKlxuXHQgKiBAZmlyZXMgQnV0dG9uQ2FtZXJhSW1hZ2UjaW1hZ2VDYW1lcmFBZGRcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuXHQgKiBAbWV0aG9kIHRha2VQaG90b1xuXHQgKi9cblx0dGFrZVBob3RvID0gKCkgPT4ge1xuXHRcdGNvbnN0IHZpZGVvRWwgPSB0aGlzLl92aWRlb0NvbnRhaW5lclJlZi5jdXJyZW50O1xuXHRcdGNvbnN0IGNhbnZhc0VsID0gdGhpcy5fY2FudmFzQ29udGFpbmVyUmVmLmN1cnJlbnQ7XG5cblx0XHRjb25zdCBjb250ZXh0ID0gY2FudmFzRWwuZ2V0Q29udGV4dCgnMmQnKTtcblxuXHRcdGNvbnN0IGhlaWdodCA9IHRoaXMuX3ZpZGVvSGVpZ2h0O1xuXHRcdGNvbnN0IHdpZHRoID0gdGhpcy5wcm9wcy52aWRlb1dpZHRoO1xuXG5cdFx0aWYgKHdpZHRoICYmIGhlaWdodCkge1xuXHRcdFx0Y2FudmFzRWwud2lkdGggPSB3aWR0aDtcblx0XHRcdGNhbnZhc0VsLmhlaWdodCA9IGhlaWdodDtcblxuXHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UodmlkZW9FbCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cblx0XHRcdGNvbnN0IGltZ1VSTCA9IGNhbnZhc0VsLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG5cblx0XHRcdGNvbnN0IGVsID0gQ0tFRElUT1IuZG9tLmVsZW1lbnQuY3JlYXRlRnJvbUh0bWwoXG5cdFx0XHRcdCc8aW1nIHNyYz1cIicgKyBpbWdVUkwgKyAnXCI+J1xuXHRcdFx0KTtcblxuXHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRlZGl0b3IuaW5zZXJ0RWxlbWVudChlbCk7XG5cblx0XHRcdHRoaXMucHJvcHMuY2FuY2VsRXhjbHVzaXZlKCk7XG5cblx0XHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblxuXHRcdFx0ZWRpdG9yLmZpcmUoJ2ltYWdlQ2FtZXJhQWRkJywgZWwpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRGlzcGxheXMgZXJyb3IgbWVzc2FnZSBpbiBjYXNlIG9mIHZpZGVvIHN0cmVhbSBjYXB0dXJpbmcgZmFpbHVyZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuXHQgKiBAbWV0aG9kIF9oYW5kbGVTdHJlYW1FcnJvclxuXHQgKiBAcGFyYW0ge0V2ZW50fSBlcnJvciBUaGUgZmlyZWQgZXZlbnQgaW4gY2FzZSBvZiBlcnJvci5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2hhbmRsZVN0cmVhbUVycm9yID0gZXJyb3IgPT4ge1xuXHRcdHdpbmRvdy5hbGVydCgnQW4gZXJyb3Igb2NjdXJyZWQhICcgKyBlcnJvcik7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyBzdHJlYW1pbmcgdmlkZW8gaW4gdGhlIHZpZGVvIGVsZW1lbnQgYW5kIHNldHMgd2lkdGgvaGVpZ2h0IHRvIHRoZSB2aWRlb1xuXHQgKiBhbmQgY2FudmFzIGVsZW1lbnRzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYUltYWdlXG5cdCAqIEBtZXRob2QgX2hhbmRsZVN0cmVhbVN1Y2Nlc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbSBUaGUgdmlkZW8gc3RyZWFtXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9oYW5kbGVTdHJlYW1TdWNjZXNzID0gc3RyZWFtID0+IHtcblx0XHRjb25zdCB2aWRlb0VsID0gdGhpcy5fdmlkZW9Db250YWluZXJSZWYuY3VycmVudDtcblx0XHRjb25zdCBjYW52YXNFbCA9IHRoaXMuX2NhbnZhc0NvbnRhaW5lclJlZi5jdXJyZW50O1xuXG5cdFx0dmlkZW9FbC5hZGRFdmVudExpc3RlbmVyKFxuXHRcdFx0J2NhbnBsYXknLFxuXHRcdFx0KCkgPT4ge1xuXHRcdFx0XHRsZXQgaGVpZ2h0ID1cblx0XHRcdFx0XHR2aWRlb0VsLnZpZGVvSGVpZ2h0IC9cblx0XHRcdFx0XHQodmlkZW9FbC52aWRlb1dpZHRoIC8gdGhpcy5wcm9wcy52aWRlb1dpZHRoKTtcblxuXHRcdFx0XHRpZiAoaXNOYU4oaGVpZ2h0KSkge1xuXHRcdFx0XHRcdGhlaWdodCA9IHRoaXMucHJvcHMudmlkZW9XaWR0aCAvICg0IC8gMyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2aWRlb0VsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLnByb3BzLnZpZGVvV2lkdGgpO1xuXHRcdFx0XHR2aWRlb0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KTtcblx0XHRcdFx0Y2FudmFzRWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMucHJvcHMudmlkZW9XaWR0aCk7XG5cdFx0XHRcdGNhbnZhc0VsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KTtcblxuXHRcdFx0XHR0aGlzLl92aWRlb0hlaWdodCA9IGhlaWdodDtcblx0XHRcdH0sXG5cdFx0XHRmYWxzZVxuXHRcdCk7XG5cblx0XHR0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG5cblx0XHRpZiAobmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSkge1xuXHRcdFx0dmlkZW9FbC5tb3pTcmNPYmplY3QgPSBzdHJlYW07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZpZGVvRWwuc3JjT2JqZWN0ID0gc3RyZWFtO1xuXHRcdH1cblxuXHRcdHZpZGVvRWwucGxheSgpO1xuXG5cdFx0dGhpcy5fYnV0dG9uVGFrZVBob3RvUmVmLmN1cnJlbnQuZGlzYWJsZWQgPSBmYWxzZTtcblx0fTtcblxuXHQvKipcblx0ICogRmlyZWQgd2hlbiBhbiBpbWFnZSBpcyBiZWluZyB0YWtlbiBmcm9tIHRoZSBjYW1lcmEgYW5kIGFkZGVkIGFzIGFuIGVsZW1lbnQgdG8gdGhlIGVkaXRvci5cblx0ICpcblx0ICogQGV2ZW50IEJ1dHRvbkNhbWVyYUltYWdlI2ltYWdlQ2FtZXJhQWRkXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25DYW1lcmFJbWFnZVxuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBlbCBUaGUgY3JlYXRlZCBpbWcgZWxlbWVudCBpbiBlZGl0b3IuXG5cdCAqL1xufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25DYW1lcmFJbWFnZTtcbiIsImltcG9ydCBCdXR0b25DYW1lcmFJbWFnZSBmcm9tICcuL2J1dHRvbi1jYW1lcmEtaW1hZ2UuanN4JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkNhbWVyYSBjbGFzcyByZW5kZXJzIGluIHR3byBkaWZmZXJlbnQgd2F5czpcbiAqXG4gKiAtIE5vcm1hbDogSnVzdCBhIGJ1dHRvbiB0aGF0IGFsbG93cyB0byBzd2l0Y2ggdG8gdGhlIGVkaXRpb24gbW9kZS5cbiAqIC0gRXhjbHVzaXZlOiBSZW5kZXJzIEJ1dHRvbkNhbWVyYUltYWdlIGluIG9yZGVyIHRvIHRha2UgcGhvdG8gZnJvbSB0aGUgY2FtZXJhLlxuICpcbiAqIEBjbGFzcyBCdXR0b25DYW1lcmFcbiAqL1xuY2xhc3MgQnV0dG9uQ2FtZXJhIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBjYW1lcmFcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnY2FtZXJhJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNhbWVyYVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcblx0XHRcdHJldHVybiA8QnV0dG9uQ2FtZXJhSW1hZ2Ugey4uLnRoaXMucHJvcHN9IC8+O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBkaXNhYmxlZCA9ICEoXG5cdFx0XHRcdG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHxcblx0XHRcdFx0KG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgJiZcblx0XHRcdFx0XHRsb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzJykgfHxcblx0XHRcdFx0bmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYSB8fFxuXHRcdFx0XHRuYXZpZ2F0b3IubXNHZXRVc2VyTWVkaWFcblx0XHRcdCk7XG5cblx0XHRcdGNvbnN0IGxhYmVsID0gZGlzYWJsZWRcblx0XHRcdFx0PyBBbGxveUVkaXRvci5TdHJpbmdzLmNhbWVyYURpc2FibGVkXG5cdFx0XHRcdDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jYW1lcmE7XG5cblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtsYWJlbH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1pbWFnZS1jYW1lcmFcIlxuXHRcdFx0XHRcdGRpc2FibGVkPXtkaXNhYmxlZH1cblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmUuYmluZChCdXR0b25DYW1lcmEua2V5KX1cblx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHR0aXRsZT17bGFiZWx9PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNhbWVyYVwiIC8+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0KTtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ2FtZXJhO1xuIiwiaW1wb3J0IEJ1dHRvbkFjdGlvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWFjdGlvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkNvZGUgY2xhc3MgcHJvdmlkZXMgd3JhcHMgYSBzZWxlY3Rpb24gaW4gYHByZWAgZWxlbWVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uQ29kZVxuICogQHVzZXMgQnV0dG9uQWN0aW9uU3R5bGVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uQ29kZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db2RlXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0c3R5bGU6IHtcblx0XHRcdGVsZW1lbnQ6ICdwcmUnLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBjb2RlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db2RlXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdjb2RlJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvZGVcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5jb2RlfVxuXHRcdFx0XHRhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9XG5cdFx0XHRcdGNsYXNzTmFtZT17Y3NzQ2xhc3N9XG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1jb2RlXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5hcHBseVN0eWxlfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29kZX0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNvZGVcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25BY3Rpb25TdHlsZShCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3R5bGUoQnV0dG9uQ29kZSkpKTtcbiIsImltcG9ydCBCdXR0b25Qcm9wcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1wcm9wcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3QgZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QuanN4JztcbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkNvbG9yIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNoYW5naW5nIHRleHQgY29sb3IgaW4gYSBkb2N1bWVudC5cbiAqXG4gKlxuICogQGNsYXNzIEJ1dHRvbkNvbG9yXG4gKiBAdXNlcyBCdXR0b25Qcm9wc1xuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvbkNvbG9yIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRzdGF0aWMga2V5ID0gJ2NvbG9yJztcblxuXHRzdGF0aWMgcHJvcFR5cGVzID0ge1xuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzdHlsZXMgbGlzdCBpcyBleHBhbmRlZCBvciBub3QuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IGV4cGFuZGVkXG5cdFx0ICovXG5cdFx0ZXhwYW5kZWQ6IFByb3BUeXBlcy5ib29sLFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxhYmVsIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZXMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gbGFiZWxcblx0XHQgKi9cblx0XHRsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcblxuXHRcdC8qKlxuXHRcdCAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSByZW1vdmUgc3R5bGVzIGl0ZW0gc2hvdWxkIGFwcGVhciBpbiB0aGUgc3R5bGVzIGxpc3QuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNob3dSZW1vdmVTdHlsZXNJdGVtXG5cdFx0ICovXG5cdFx0c2hvd1JlbW92ZVN0eWxlc0l0ZW06IFByb3BUeXBlcy5ib29sLFxuXG5cdFx0LyoqXG5cdFx0ICogTGlzdCBvZiB0aGUgc3R5bGVzIHRoZSBidXR0b24gaXMgYWJsZSB0byBoYW5kbGUuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29sb3Jcblx0XHQgKiBAcHJvcGVydHkge0FycmF5fSBzdHlsZXNcblx0XHQgKi9cblx0XHRzdHlsZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vYmplY3QpLFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRhYkluZGV4IG9mIHRoZSBidXR0b24gaW4gaXRzIHRvb2xiYXIgY3VycmVudCBzdGF0ZS4gQSB2YWx1ZSBvdGhlciB0aGFuIC0xXG5cdFx0ICogbWVhbnMgdGhhdCB0aGUgYnV0dG9uIGhhcyBmb2N1cyBhbmQgaXMgdGhlIGFjdGl2ZSBlbGVtZW50LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbG9yXG5cdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IHRhYkluZGV4XG5cdFx0ICovXG5cdFx0dGFiSW5kZXg6IFByb3BUeXBlcy5udW1iZXIsXG5cblx0XHQvKipcblx0XHQgKiBDYWxsYmFjayBwcm92aWRlZCBieSB0aGUgYnV0dG9uIGhvc3QgdG8gbm90aWZ5IHdoZW4gdGhlIHN0eWxlcyBsaXN0IGhhcyBiZWVuIGV4cGFuZGVkLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbG9yXG5cdFx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gdG9nZ2xlRHJvcGRvd25cblx0XHQgKi9cblx0XHR0b2dnbGVEcm9wZG93bjogUHJvcFR5cGVzLmZ1bmMsXG5cdH07XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IGFjdGl2ZUNvbG9yID0gQWxsb3lFZGl0b3IuU3RyaW5ncy5ub3JtYWw7XG5cblx0XHRjb25zdCBjb2xvcnMgPSB0aGlzLl9nZXRDb2xvcnMoKTtcblxuXHRcdGNvbG9ycy5zb21lKGl0ZW0gPT4ge1xuXHRcdFx0aWYgKHRoaXMuX2NoZWNrQWN0aXZlKGl0ZW0uc3R5bGUpKSB7XG5cdFx0XHRcdGFjdGl2ZUNvbG9yID0gaXRlbS5uYW1lO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Y29uc3Qge2V4cGFuZGVkLCB0YWJJbmRleCwgdG9nZ2xlRHJvcGRvd259ID0gdGhpcy5wcm9wcztcblxuXHRcdGNvbnN0IGJ1dHRvblN0eWxlc1Byb3BzID0ge1xuXHRcdFx0YWN0aXZlU3R5bGU6IGFjdGl2ZUNvbG9yLFxuXHRcdFx0b25EaXNtaXNzOiB0b2dnbGVEcm9wZG93bixcblx0XHRcdHNob3dSZW1vdmVTdHlsZXNJdGVtOiBmYWxzZSxcblx0XHRcdHN0eWxlczogY29sb3JzLFxuXHRcdH07XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXIgYWUtaGFzLWRyb3Bkb3duXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXtleHBhbmRlZH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdHJvbGU9XCJjb21ib2JveFwiXG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RhYkluZGV4fT5cblx0XHRcdFx0XHQ8c3Bhbj5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNvbG9yLXBpY2tlclwiIC8+XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0e2V4cGFuZGVkICYmIDxCdXR0b25TdHlsZXNMaXN0IHsuLi5idXR0b25TdHlsZXNQcm9wc30gLz59XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0X2FwcGx5U3R5bGUoY2xhc3NOYW1lKSB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0Y29uc3Qgc3R5bGVDb25maWcgPSB7XG5cdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdGNsYXNzOiBjbGFzc05hbWUsXG5cdFx0XHR9LFxuXHRcdH07XG5cblx0XHRjb25zdCBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZShzdHlsZUNvbmZpZyk7XG5cblx0XHRlZGl0b3IuZ2V0U2VsZWN0aW9uKCkubG9jaygpO1xuXG5cdFx0dGhpcy5fZ2V0Q29sb3JzKCkuZm9yRWFjaChpdGVtID0+IHtcblx0XHRcdGlmICh0aGlzLl9jaGVja0FjdGl2ZShpdGVtLnN0eWxlKSkge1xuXHRcdFx0XHRlZGl0b3IucmVtb3ZlU3R5bGUobmV3IENLRURJVE9SLnN0eWxlKGl0ZW0uc3R5bGUpKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGVkaXRvci5hcHBseVN0eWxlKHN0eWxlKTtcblxuXHRcdGVkaXRvci5nZXRTZWxlY3Rpb24oKS51bmxvY2soKTtcblxuXHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGNvbG9yIGRlZmluaXRpb24gaXMgYXBwbGllZCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gaW4gdGhlIGVkaXRvci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db2xvclxuXHQgKiBAbWV0aG9kIF9jaGVja0FjdGl2ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3R5bGVDb25maWcgQ29sb3IgZGVmaW5pdGlvbiBhcyBwZXIgaHR0cDovL2RvY3MuY2tlZGl0b3IuY29tLyMhL2FwaS9DS0VESVRPUi5zdHlsZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbG9yIGlzIGFwcGxpZWQgdG8gdGhlIHNlbGVjdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cblx0X2NoZWNrQWN0aXZlKHN0eWxlQ29uZmlnKSB7XG5cdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0Ly8gU3R5bGVzIHdpdGggd2lsZGNhcmQgZWxlbWVudCAoKikgd29uJ3QgYmUgY29uc2lkZXJlZCBhY3RpdmUgYnkgQ0tFZGl0b3IuIERlZmF1bHRpbmdcblx0XHQvLyB0byBhICdzcGFuJyBlbGVtZW50IHdvcmtzIGZvciBtb3N0IG9mIHRob3NlIGNhc2VzIHdpdGggbm8gZGVmaW5lZCBlbGVtZW50LlxuXHRcdHN0eWxlQ29uZmlnID0gQ0tFRElUT1IudG9vbHMubWVyZ2Uoe2VsZW1lbnQ6ICdzcGFuJ30sIHN0eWxlQ29uZmlnKTtcblxuXHRcdGNvbnN0IHN0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKHN0eWxlQ29uZmlnKTtcblxuXHRcdHJldHVybiBzdHlsZS5jaGVja0FjdGl2ZShuYXRpdmVFZGl0b3IuZWxlbWVudFBhdGgoKSwgbmF0aXZlRWRpdG9yKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNvbG9ycy4gRWFjaCBjb2xvciBjb25zaXN0cyBvZiB0d28gcHJvcGVydGllczpcblx0ICogLSBuYW1lIC0gVGhlIHN0eWxlIG5hbWUsIGZvciBleGFtcGxlIFwiZGVmYXVsdFwiLlxuXHQgKiAtIHN0eWxlIC0gQW4gb2JqZWN0IHdpdGggb25lIHByb3BlcnR5LCBjYWxsZWQgYGVsZW1lbnRgIHdoaWNoIHZhbHVlXG5cdCAqICAgICAgICAgIHJlcHJlc2VudHMgdGhlIHN0eWxlIHdoaWNoIGhhdmUgdG8gYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudC5cblx0ICogLSBzdHlsZUZuIC0gVGhlIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCB0byBhcHBseSB0aGUgc3R5bGUgdG8gdGhlIGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29sb3Jcblx0ICogQG1ldGhvZCBfZ2V0Q29sb3Jcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBcnJheTxvYmplY3Q+fSBBbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGNvbG9ycy5cblx0ICovXG5cdF9nZXRDb2xvcnMoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMucHJvcHMuc3R5bGVzIHx8IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MucHJpbWFyeSxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtcHJpbWFyeScsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICd0ZXh0LXByaW1hcnknKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3Muc3VjY2Vzcyxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtc3VjY2VzcycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICd0ZXh0LXN1Y2Nlc3MnKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MuZGFuZ2VyLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC1kYW5nZXInLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAndGV4dC1kYW5nZXInKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3Mud2FybmluZyxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtd2FybmluZycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICd0ZXh0LXdhcm5pbmcnKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MuaW5mbyxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtaW5mbycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICd0ZXh0LWluZm8nKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MuZGFyayxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtZGFyaycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICd0ZXh0LWRhcmsnKSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MuZGFya0dyYXksXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRcdFx0Y2xhc3M6ICd0ZXh0LWdyYXktZGFyaycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICd0ZXh0LWdyYXktZGFyaycpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5zZWNvbmRhcnksXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRcdFx0Y2xhc3M6ICd0ZXh0LXNlY29uZGFyeScsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICd0ZXh0LXNlY29uZGFyeScpLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bmFtZTogQWxsb3lFZGl0b3IuU3RyaW5ncy5saWdodCxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3NwYW4nLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ3RleHQtZGFyaycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0c3R5bGVGbjogdGhpcy5fYXBwbHlTdHlsZS5iaW5kKHRoaXMsICd0ZXh0LWxpZ2h0JyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmxpZ2h0ZXIsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdzcGFuJyxcblx0XHRcdFx0XHRcdGF0dHJpYnV0ZXM6IHtcblx0XHRcdFx0XHRcdFx0Y2xhc3M6ICd0ZXh0LWRhcmsnLFxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAndGV4dC1saWdodGVyJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLndoaXRlLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRcdFx0XHRhdHRyaWJ1dGVzOiB7XG5cdFx0XHRcdFx0XHRcdGNsYXNzOiAndGV4dC1kYXJrJyxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzdHlsZUZuOiB0aGlzLl9hcHBseVN0eWxlLmJpbmQodGhpcywgJ3RleHQtd2hpdGUnKSxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblByb3BzKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25Db2xvcikpO1xuIiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Db21tYW5kTGlzdEl0ZW0gY2xhc3MgaXMgYSBVSSBjbGFzcyB0aGF0IHJlbmRlcnMgYSBCdXR0b25Db21tYW5kIHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlXG4gKiBhIGxpc3QgYXMgYW4gaXRlbSwgd2l0aCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdHMgYmVoYXZpb3VyLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Db21tYW5kTGlzdEl0ZW1cbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuY2xhc3MgQnV0dG9uQ29tbWFuZExpc3RJdGVtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBidXR0b25Db21tYW5kTGlzdEl0ZW1cblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnYnV0dG9uQ29tbWFuZExpc3RJdGVtJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXt0aGlzLnByb3BzLmRlc2NyaXB0aW9ufVxuXHRcdFx0XHRjbGFzc05hbWU9e3RoaXMuX2dldENsYXNzTmFtZSgpfVxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0+XG5cdFx0XHRcdHt0aGlzLnByb3BzLmRlc2NyaXB0aW9ufVxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjbGFzcyBuYW1lIG9mIFdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kTGlzdEl0ZW1cblx0ICogQG1ldGhvZCBfZ2V0Q2xhc3NOYW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgY2xhc3MgbmFtZSBvZiB0aGUgV2lkZ2V0LlxuXHQgKi9cblx0X2dldENsYXNzTmFtZSgpIHtcblx0XHRjb25zdCBjbGFzc05hbWUgPSAnYWUtY29udGFpbmVyIGFlLXRvb2xiYXItZWxlbWVudCc7XG5cblx0XHRyZXR1cm4gY2xhc3NOYW1lO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoQnV0dG9uQ29tbWFuZExpc3RJdGVtKTtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZExpc3RJdGVtIGZyb20gJy4vYnV0dG9uLWNvbW1hbmQtbGlzdC1pdGVtLmpzeCc7XG5pbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXInO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Db21tYW5kc0xpc3QgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3Igc2hvd2luZyBhIGxpc3Qgb2YgY29tbWFuZHMgdGhhdCBjYW4gYmVcbiAqIGV4ZWN1dGVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbi4uXG4gKlxuICogQGNsYXNzIEJ1dHRvbkNvbW1hbmRzTGlzdFxuICogQHVzZXMgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gKi9cbmNsYXNzIEJ1dHRvbkNvbW1hbmRzTGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kc0xpc3Rcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjaXJjdWxhcjogZmFsc2UsXG5cdFx0ZGVzY2VuZGFudHM6ICcuYWUtdG9vbGJhci1lbGVtZW50Jyxcblx0XHRrZXlzOiB7XG5cdFx0XHRkaXNtaXNzOiBbMjddLFxuXHRcdFx0ZGlzbWlzc05leHQ6IFszOV0sXG5cdFx0XHRkaXNtaXNzUHJldjogWzM3XSxcblx0XHRcdG5leHQ6IFs0MF0sXG5cdFx0XHRwcmV2OiBbMzhdLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBidXR0b25Db21tYW5kc0xpc3Rcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkNvbW1hbmRzTGlzdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnYnV0dG9uQ29tbWFuZHNMaXN0JztcblxuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblx0XHR0aGlzLl9yZWYgPSBSZWFjdC5jcmVhdGVSZWYoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50LCBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuXHQgKlxuXHQgKiBGb2N1c2VzIG9uIHRoZSBsaXN0IG5vZGUgdG8gYWxsb3cga2V5Ym9hcmQgaW50ZXJhY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZHNMaXN0XG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcblx0ICovXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdHRoaXMuX3JlZi5jdXJyZW50LmZvY3VzKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgbGlzdC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Db21tYW5kc0xpc3Rcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXZcblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtZHJvcGRvd24gYWUtYXJyb3ctYm94IGFlLWFycm93LWJveC10b3AtbGVmdFwiXG5cdFx0XHRcdG9uRm9jdXM9e3RoaXMuZm9jdXN9XG5cdFx0XHRcdG9uS2V5RG93bj17dGhpcy5oYW5kbGVLZXl9XG5cdFx0XHRcdHJlZj17dGhpcy5fcmVmfVxuXHRcdFx0XHR0YWJJbmRleD1cIjBcIj5cblx0XHRcdFx0PHVsXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtbGlzdGJveFwiXG5cdFx0XHRcdFx0aWQ9e3RoaXMucHJvcHMubGlzdElkfVxuXHRcdFx0XHRcdHJvbGU9XCJsaXN0Ym94XCI+XG5cdFx0XHRcdFx0e3RoaXMuX3JlbmRlckFjdGlvbnModGhpcy5wcm9wcy5jb21tYW5kcyl9XG5cdFx0XHRcdDwvdWw+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbmRlcnMgaW5zdGFuY2VzIG9mIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbSB3aXRoIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgcm93IGFjdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uQ29tbWFuZHNMaXN0XG5cdCAqIEBtZXRob2QgX3JlbmRlckFjdGlvbnNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBcnJheX0gUmVuZGVyZWQgaW5zdGFuY2VzIG9mIEJ1dHRvbkNvbW1hbmRMaXN0SXRlbSBjbGFzc1xuXHQgKi9cblx0X3JlbmRlckFjdGlvbnMoY29tbWFuZHMpIHtcblx0XHRsZXQgaXRlbXM7XG5cblx0XHRpZiAoY29tbWFuZHMgJiYgY29tbWFuZHMubGVuZ3RoKSB7XG5cdFx0XHRpdGVtcyA9IGNvbW1hbmRzLm1hcChmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0PGxpIGtleT17aXRlbS5jb21tYW5kfSByb2xlPVwib3B0aW9uXCI+XG5cdFx0XHRcdFx0XHQ8QnV0dG9uQ29tbWFuZExpc3RJdGVtXG5cdFx0XHRcdFx0XHRcdGNvbW1hbmQ9e2l0ZW0uY29tbWFuZH1cblx0XHRcdFx0XHRcdFx0ZGVzY3JpcHRpb249e1xuXHRcdFx0XHRcdFx0XHRcdHR5cGVvZiBpdGVtLmxhYmVsID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0XHRcdFx0PyBpdGVtLmxhYmVsXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IGl0ZW0ubGFiZWwoKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGljb249e2l0ZW0uaWNvbn1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtcztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRGb2N1c01hbmFnZXIoQnV0dG9uQ29tbWFuZHNMaXN0KTtcbiIsImltcG9ydCBXaWRnZXRGb2N1c01hbmFnZXIgZnJvbSAnLi4vYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlcic7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Ecm9wZG93biBjbGFzcyBwcm92aWRlcyBtYXJrdXAgYW5kIGtleWJvYXJkIG5hdmlnYXRpb24gYmVoYXZpb3VyIHRvIGEgZHJvcGRvd25cbiAqIG9wZW5lZCBmcm9tIGEgYnV0dG9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25Ecm9wZG93blxuICovXG5jbGFzcyBCdXR0b25Ecm9wZG93biBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Ecm9wZG93blxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjaXJjdWxhcjogZmFsc2UsXG5cdFx0ZGVzY2VuZGFudHM6ICcuYWUtdG9vbGJhci1lbGVtZW50Jyxcblx0XHRrZXlzOiB7XG5cdFx0XHRkaXNtaXNzOiBbMjddLFxuXHRcdFx0ZGlzbWlzc05leHQ6IFszOV0sXG5cdFx0XHRkaXNtaXNzUHJldjogWzM3XSxcblx0XHRcdG5leHQ6IFs0MF0sXG5cdFx0XHRwcmV2OiBbMzhdLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgZHJvcGRvd24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IGRyb3Bkb3duXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25Ecm9wZG93blxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnZHJvcGRvd24nO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRHJvcGRvd25cblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXZcblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtZHJvcGRvd24gYWUtYXJyb3ctYm94IGFlLWFycm93LWJveC10b3AtbGVmdFwiXG5cdFx0XHRcdG9uRm9jdXM9e3RoaXMuZm9jdXN9XG5cdFx0XHRcdG9uS2V5RG93bj17dGhpcy5oYW5kbGVLZXl9XG5cdFx0XHRcdHRhYkluZGV4PVwiMFwiPlxuXHRcdFx0XHQ8dWwgY2xhc3NOYW1lPVwiYWUtbGlzdGJveFwiIHJvbGU9XCJsaXN0Ym94XCI+XG5cdFx0XHRcdFx0e3RoaXMucHJvcHMuY2hpbGRyZW59XG5cdFx0XHRcdDwvdWw+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFdpZGdldEZvY3VzTWFuYWdlcihCdXR0b25Ecm9wZG93bik7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5cbmNvbnN0IEtFWV9FTlRFUiA9IDEzO1xuY29uc3QgS0VZX0VTQyA9IDI3O1xuXG4vKipcbiAqIFRoZSBCdXR0b25FbWJlZEVkaXQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgYW5kIGVkaXRpbmcgYW4gZW1iZWQgbGluayBpbiBhIGRvY3VtZW50LlxuICogUHJvdmlkZXMgVUkgZm9yIGNyZWF0aW5nIGFuZCBlZGl0aW5nIGFuIGVtYmVkIGxpbmsuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkVtYmVkRWRpdFxuICovXG5jbGFzcyBCdXR0b25FbWJlZEVkaXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgZW1iZWRFZGl0XG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2VtYmVkRWRpdCc7XG5cblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHR0aGlzLmxpbmtJbnB1dCA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXHRcdHRoaXMuc3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdCAqXG5cdCAqIEZvY3VzZXMgb24gdGhlIGxpbmsgaW5wdXQgdG8gaW1tZWRpYXRlbHkgYWxsb3cgZWRpdGluZy4gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlIGNvbXBvbmVudFxuXHQgKiBpcyByZW5kZXJlZCBpbiBleGNsdXNpdmUgbW9kZSB0byBwcmV2ZW50IGFnZ3Jlc3NpdmUgZm9jdXMgc3RlYWxpbmcuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcblx0ICovXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSB8fCB0aGlzLnByb3BzLm1hbnVhbFNlbGVjdGlvbikge1xuXHRcdFx0Ly8gV2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUgYmVmb3JlIGZvY3VzaW5nIHRvIGF2b2lkIHVuZGVzaXJlZFxuXHRcdFx0Ly8gc2Nyb2xscyBvbiB0aGUgcGFnZVxuXHRcdFx0aWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcblx0XHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9mb2N1c0xpbmtJbnB1dCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZXRUaW1lb3V0KHRoaXMuX2ZvY3VzTGlua0lucHV0LCAwKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIHdoZW4gYSBjb21wb25lbnQgaXMgcmVjZWl2aW5nIG5ldyBwcm9wcy5cblx0ICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNcblx0ICovXG5cdGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKSB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh0aGlzLmdldEluaXRpYWxTdGF0ZSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuXHQgKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGlzLnN0YXRlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuXHQgKiBAbWV0aG9kIGdldEluaXRpYWxTdGF0ZVxuXHQgKi9cblx0Z2V0SW5pdGlhbFN0YXRlKCkge1xuXHRcdC8vIENhbid0IGFjY2VzcyBjb250ZXh0IGZyb20gY29uc3RydWN0b3IsIHNvIGdldCBlZGl0b3IgZnJvbSBwcm9wcy5cblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLnByb3BzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0bGV0IGVtYmVkO1xuXG5cdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0aWYgKHNlbGVjdGlvbikge1xuXHRcdFx0Y29uc3Qgc2VsZWN0ZWRFbGVtZW50ID0gc2VsZWN0aW9uLmdldFNlbGVjdGVkRWxlbWVudCgpO1xuXG5cdFx0XHRpZiAoc2VsZWN0ZWRFbGVtZW50KSB7XG5cdFx0XHRcdGVtYmVkID0gc2VsZWN0ZWRFbGVtZW50LmZpbmRPbmUoJ1tkYXRhLXdpZGdldD1cImFlX2VtYmVkXCJdJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgaHJlZiA9IGVtYmVkID8gZW1iZWQuZ2V0QXR0cmlidXRlKCdkYXRhLWFlLWVtYmVkLXVybCcpIDogJyc7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZWxlbWVudDogZW1iZWQsXG5cdFx0XHRpbml0aWFsTGluazoge1xuXHRcdFx0XHRocmVmLFxuXHRcdFx0fSxcblx0XHRcdGxpbmtIcmVmOiBocmVmLFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjbGVhckxpbmtTdHlsZSA9IHtcblx0XHRcdG9wYWNpdHk6IHRoaXMuc3RhdGUubGlua0hyZWYgPyAxIDogMCxcblx0XHR9O1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWVkaXQtbGlua1wiPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5kZWxldGVFbWJlZH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1lbWJlZC1yZW1vdmVcIlxuXHRcdFx0XHRcdGRpc2FibGVkPXshdGhpcy5zdGF0ZS5lbGVtZW50fVxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX3JlbW92ZUVtYmVkfVxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmRlbGV0ZUVtYmVkfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJ0cmFzaFwiIGNsYXNzTmFtZT1cImFlLWljb24tc3ZnLXRyYXNoXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0IHh4bFwiPlxuXHRcdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtaW5wdXRcIlxuXHRcdFx0XHRcdFx0b25DaGFuZ2U9e3RoaXMuX2hhbmRsZUxpbmtIcmVmQ2hhbmdlfVxuXHRcdFx0XHRcdFx0b25LZXlEb3duPXt0aGlzLl9oYW5kbGVLZXlEb3dufVxuXHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9e0FsbG95RWRpdG9yLlN0cmluZ3MuZWRpdExpbmt9XG5cdFx0XHRcdFx0XHRyZWY9e3RoaXMubGlua0lucHV0fVxuXHRcdFx0XHRcdFx0dHlwZT1cInRleHRcIlxuXHRcdFx0XHRcdFx0dmFsdWU9e3RoaXMuc3RhdGUubGlua0hyZWZ9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNsZWFySW5wdXR9XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b24gYWUtYnV0dG9uLWNsZWFyXCJcblx0XHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX2NsZWFyTGlua31cblx0XHRcdFx0XHRcdHN0eWxlPXtjbGVhckxpbmtTdHlsZX1cblx0XHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNsZWFyfT5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInRpbWVzLWNsZWFyXCIgLz5cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbmZpcm19XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRkaXNhYmxlZD17IXRoaXMuX2lzVmFsaWRTdGF0ZSgpfVxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX2VtYmVkTGlua31cblx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5jb25maXJtfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJjaGVja1wiIGNsYXNzTmFtZT1cImFlLWljb24tc3ZnLWNoZWNrXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyB0aGUgbGluayBpbnB1dC4gVGhpcyBvbmx5IGNoYW5nZXMgdGhlIGNvbXBvbmVudCBpbnRlcm5hbCBzdGF0ZSwgYnV0IGRvZXMgbm90XG5cdCAqIGFmZmVjdCB0aGUgbGluayBlbGVtZW50IG9mIHRoZSBlZGl0b3IuIE9ubHkgdGhlIF9yZW1vdmVMaW5rIGFuZCBfdXBkYXRlTGluayBtZXRob2RzXG5cdCAqIGFyZSB0cmFuc2xhdGVkIHRvIHRoZSBlZGl0b3IgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcblx0ICogQG1ldGhvZCBfY2xlYXJMaW5rXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9jbGVhckxpbmsgPSAoKSA9PiB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRsaW5rSHJlZjogJycsXG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFRyaWdnZXJzIHRoZSBlbWJlZFVybCBjb21tYW5kIHRvIHRyYW5zZm9ybSB0aGUgbGluayBpbnRvIGFuIGVtYmVkIG1lZGlhIG9iamVjdFxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuXHQgKiBAbWV0aG9kIF9lbWJlZExpbmtcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2VtYmVkTGluayA9ICgpID0+IHtcblx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRuYXRpdmVFZGl0b3IuZXhlY0NvbW1hbmQoJ2VtYmVkVXJsJywge1xuXHRcdFx0dXJsOiB0aGlzLnN0YXRlLmxpbmtIcmVmLFxuXHRcdH0pO1xuXG5cdFx0Ly8gV2UgbmVlZCB0byBjYW5jZWxFeGNsdXNpdmUgd2l0aCB0aGUgYm91bmQgcGFyYW1ldGVycyBpbiBjYXNlIHRoZSBidXR0b24gaXMgdXNlZFxuXHRcdC8vIGluc2lkZSBhbm90aGVyIGluIGV4Y2x1c2l2ZSBtb2RlIChzdWNoIGlzIHRoZSBjYXNlIG9mIHRoZSBsaW5rIGJ1dHRvbilcblx0XHR0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb2N1c2VzIHRoZSB1c2VyIGN1cnNvciBvbiB0aGUgd2lkZ2V0J3MgaW5wdXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG5cdCAqIEBtZXRob2QgX2ZvY3VzTGlua0lucHV0XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9mb2N1c0xpbmtJbnB1dCA9ICgpID0+IHtcblx0XHR0aGlzLmxpbmtJbnB1dC5jdXJyZW50LmZvY3VzKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1vbml0b3JzIGtleSBpbnRlcmFjdGlvbiBpbnNpZGUgdGhlIGlucHV0IGVsZW1lbnQgdG8gcmVzcG9uZCB0byB0aGUga2V5czpcblx0ICogLSBFbnRlcjogQ3JlYXRlcy91cGRhdGVzIHRoZSBsaW5rLlxuXHQgKiAtIEVzY2FwZTogRGlzY2FyZHMgdGhlIGNoYW5nZXMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRFZGl0XG5cdCAqIEBtZXRob2QgX2hhbmRsZUtleURvd25cblx0ICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIGtleWJvYXJkIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfaGFuZGxlS2V5RG93biA9IGV2ZW50ID0+IHtcblx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VOVEVSIHx8IGV2ZW50LmtleUNvZGUgPT09IEtFWV9FU0MpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuXHRcdFx0dGhpcy5fZW1iZWRMaW5rKCk7XG5cdFx0fSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRVNDKSB7XG5cdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdC8vIFdlIG5lZWQgdG8gY2FuY2VsRXhjbHVzaXZlIHdpdGggdGhlIGJvdW5kIHBhcmFtZXRlcnMgaW4gY2FzZSB0aGUgYnV0dG9uIGlzIHVzZWRcblx0XHRcdC8vIGluc2lkZSBhbm90aGVyIGluIGV4Y2x1c2l2ZSBtb2RlIChzdWNoIGlzIHRoZSBjYXNlIG9mIHRoZSBsaW5rIGJ1dHRvbilcblx0XHRcdHRoaXMucHJvcHMuY2FuY2VsRXhjbHVzaXZlKCk7XG5cblx0XHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCBzdGF0ZSB3aGVuIHRoZSBsaW5rIGlucHV0IGNoYW5nZXMgb24gdXNlciBpbnRlcmFjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZEVkaXRcblx0ICogQG1ldGhvZCBfaGFuZGxlTGlua0hyZWZDaGFuZ2Vcblx0ICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIGNoYW5nZSBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2hhbmRsZUxpbmtIcmVmQ2hhbmdlID0gZXZlbnQgPT4ge1xuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0bGlua0hyZWY6IGV2ZW50LnRhcmdldC52YWx1ZSxcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogVmVyaWZpZXMgdGhhdCB0aGUgY3VycmVudCBsaW5rIHN0YXRlIGlzIHZhbGlkIHNvIHRoZSB1c2VyIGNhbiBzYXZlIHRoZSBsaW5rLiBBIHZhbGlkIHN0YXRlXG5cdCAqIG1lYW5zIHRoYXQgd2UgaGF2ZSBhIG5vbi1lbXB0eSBocmVmIHRoYXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgb3JpZ2luYWwgb25lLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuXHQgKiBAbWV0aG9kIF9pc1ZhbGlkU3RhdGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSBzdGF0ZSBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdCAqL1xuXHRfaXNWYWxpZFN0YXRlKCkge1xuXHRcdGNvbnN0IHZhbGlkU3RhdGUgPVxuXHRcdFx0dGhpcy5zdGF0ZS5saW5rSHJlZiAmJlxuXHRcdFx0dGhpcy5zdGF0ZS5saW5rSHJlZiAhPT0gdGhpcy5zdGF0ZS5pbml0aWFsTGluay5ocmVmO1xuXG5cdFx0cmV0dXJuIHZhbGlkU3RhdGU7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgZW1iZWQgaW4gdGhlIGVkaXRvciBlbGVtZW50LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkRWRpdFxuXHQgKiBAbWV0aG9kIF9yZW1vdmVFbWJlZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfcmVtb3ZlRW1iZWQgPSAoKSA9PiB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0Y29uc3QgZW1iZWRXcmFwcGVyID0gdGhpcy5zdGF0ZS5lbGVtZW50LmdldEFzY2VuZGFudChmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudC5oYXNDbGFzcygnY2tlX3dpZGdldF93cmFwcGVyJyk7XG5cdFx0fSk7XG5cblx0XHRlbWJlZFdyYXBwZXIucmVtb3ZlKCk7XG5cblx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVkaXRvckNvbnRleHQudG9Qcm9wcyhCdXR0b25FbWJlZEVkaXQpO1xuIiwiaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5cbmNvbnN0IEtFWV9FTlRFUiA9IDEzO1xuY29uc3QgS0VZX0VTQyA9IDI3O1xuXG4vKipcbiAqIFRoZSBCdXR0b25FbWJlZFZpZGVvRWRpdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjaGFuZ2luZyB0ZXh0IGNvbG9yIGluIGEgZG9jdW1lbnQuXG4gKlxuICogQHVzZXMgQnV0dG9uSWNvblxuICpcbiAqIEBjbGFzcyBCdXR0b25FbWJlZFZpZGVvRWRpdFxuICovXG5jbGFzcyBCdXR0b25FbWJlZFZpZGVvRWRpdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0c3RhdGljIGtleSA9ICdlbWJlZFZpZGVvRWRpdCc7XG5cblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHR0aGlzLnN0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50LCBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuXHQgKlxuXHQgKiBGb2N1c2VzIG9uIHRoZSBsaW5rIGlucHV0IHRvIGltbWVkaWF0ZWx5IGFsbG93IGVkaXRpbmcuIFRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZSBjb21wb25lbnRcblx0ICogaXMgcmVuZGVyZWQgaW4gZXhjbHVzaXZlIG1vZGUgdG8gcHJldmVudCBhZ2dyZXNzaXZlIGZvY3VzIHN0ZWFsaW5nLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkVmlkZW9FZGl0XG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcblx0ICovXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSB8fCB0aGlzLnByb3BzLm1hbnVhbFNlbGVjdGlvbikge1xuXHRcdFx0Ly8gV2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCByZW5kZXJpbmcgY3ljbGUgYmVmb3JlIGZvY3VzaW5nIHRvIGF2b2lkIHVuZGVzaXJlZFxuXHRcdFx0Ly8gc2Nyb2xscyBvbiB0aGUgcGFnZVxuXHRcdFx0aWYgKHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcblx0XHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9mb2N1c1ZpZGVvVXJsSW5wdXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2V0VGltZW91dCh0aGlzLl9mb2N1c1ZpZGVvVXJsSW5wdXQsIDApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZWNlaXZpbmcgbmV3IHByb3BzLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRWaWRlb0VkaXRcblx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG5cdCAqL1xuXHRjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkge1xuXHRcdGNvbnN0IG5ld1N0YXRlID0gdGhpcy5nZXRJbml0aWFsU3RhdGUoKTtcblxuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0YWxsOiB1bmRlZmluZWQsXG5cdFx0XHRrZXlzOiB1bmRlZmluZWQsXG5cdFx0XHRuZXc6IG5ld1N0YXRlLFxuXHRcdFx0b2xkOiB1bmRlZmluZWQsXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cblx0ICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhpcy5zdGF0ZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFZpZGVvRWRpdFxuXHQgKiBAbWV0aG9kIGdldEluaXRpYWxTdGF0ZVxuXHQgKi9cblx0Z2V0SW5pdGlhbFN0YXRlKCkge1xuXHRcdC8vIENhbid0IGFjY2VzcyBjb250ZXh0IGZyb20gY29uc3RydWN0b3IsIHNvIGdldCBlZGl0b3IgZnJvbSBwcm9wcy5cblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLnByb3BzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0bGV0IGVsZW1lbnQ7XG5cblx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRpZiAoc2VsZWN0aW9uKSB7XG5cdFx0XHRjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRFbGVtZW50KCk7XG5cblx0XHRcdGlmIChzZWxlY3RlZEVsZW1lbnQpIHtcblx0XHRcdFx0ZWxlbWVudCA9IHNlbGVjdGVkRWxlbWVudC5maW5kT25lKCdbZGF0YS13aWRnZXQ9XCJ2aWRlb2VtYmVkXCJdJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgdmlkZW9VUkwgPSBlbGVtZW50XG5cdFx0XHQ/IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWVtYmVkLXZpZGVvLXVybCcpXG5cdFx0XHQ6ICcnO1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGVsZW1lbnQsXG5cdFx0XHRpbml0aWFsRW1iZWQ6IHtcblx0XHRcdFx0dmlkZW9VUkwsXG5cdFx0XHR9LFxuXHRcdFx0dmlkZW9VUkwsXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRWaWRlb0VkaXRcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgaW5wdXRQbGFjZWhvbGRlciA9IEFsbG95RWRpdG9yLlN0cmluZ3MucGFzdGVWaWRlb0xpbms7XG5cblx0XHRjb25zdCBjbGVhclZpZGVvVVJMU3R5bGUgPSB7XG5cdFx0XHRvcGFjaXR5OiB0aGlzLnN0YXRlLnZpZGVvVVJMID8gMSA6IDAsXG5cdFx0fTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1lbWJlZC12aWRlby1lZGl0XCI+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0IHh4bFwiPlxuXHRcdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtaW5wdXRcIlxuXHRcdFx0XHRcdFx0b25DaGFuZ2U9e3RoaXMuX2hhbmRsZVZpZGVvVVJMQ2hhbmdlfVxuXHRcdFx0XHRcdFx0b25LZXlEb3duPXt0aGlzLl9oYW5kbGVLZXlEb3dufVxuXHRcdFx0XHRcdFx0cGxhY2Vob2xkZXI9e2lucHV0UGxhY2Vob2xkZXJ9XG5cdFx0XHRcdFx0XHRyZWY9XCJsaW5rSW5wdXRcIlxuXHRcdFx0XHRcdFx0dHlwZT1cInRleHRcIlxuXHRcdFx0XHRcdFx0dmFsdWU9e3RoaXMuc3RhdGUudmlkZW9VUkx9XG5cdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNsZWFySW5wdXR9XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b24gYWUtaWNvbi1yZW1vdmVcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17dGhpcy5fY2xlYXJMaW5rfVxuXHRcdFx0XHRcdFx0c3R5bGU9e2NsZWFyVmlkZW9VUkxTdHlsZX1cblx0XHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNsZWFyfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5jb25maXJtfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0ZGlzYWJsZWQ9eyF0aGlzLl9pc1ZhbGlkU3RhdGUoKX1cblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9lbWJlZFZpZGVvVVJMfVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbmZpcm19PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNoZWNrXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyB0aGUgbGluayBpbnB1dC4gVGhpcyBvbmx5IGNoYW5nZXMgdGhlIGNvbXBvbmVudCBpbnRlcm5hbCBzdGF0ZSwgYnV0IGRvZXMgbm90XG5cdCAqIGFmZmVjdCB0aGUgbGluayBlbGVtZW50IG9mIHRoZSBlZGl0b3IuIE9ubHkgdGhlIF9yZW1vdmVMaW5rIGFuZCBfdXBkYXRlTGluayBtZXRob2RzXG5cdCAqIGFyZSB0cmFuc2xhdGVkIHRvIHRoZSBlZGl0b3IgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFZpZGVvRWRpdFxuXHQgKiBAbWV0aG9kIF9jbGVhckxpbmtcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2NsZWFyTGluaygpIHtcblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdHZpZGVvVVJMOiAnJyxcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VycyB0aGUgZW1iZWRWaWRlb1VybCBjb21tYW5kIHRvIHRyYW5zZm9ybSB0aGUgbGluayBpbnRvIGFuIGVtYmVkIG1lZGlhIG9iamVjdFxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEVtYmVkVmlkZW9FZGl0XG5cdCAqIEBtZXRob2QgX2VtYmVkVmlkZW9VUkxcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2VtYmVkVmlkZW9VUkwgPSAoKSA9PiB7XG5cdFx0Y29uc3QgbmF0aXZlRWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0bmF0aXZlRWRpdG9yLmV4ZWNDb21tYW5kKCdlbWJlZFVybCcsIHtcblx0XHRcdHR5cGU6ICd2aWRlbycsXG5cdFx0XHR1cmw6IHRoaXMuc3RhdGUudmlkZW9VUkwsXG5cdFx0fSk7XG5cblx0XHQvLyBXZSBuZWVkIHRvIGNhbmNlbEV4Y2x1c2l2ZSB3aXRoIHRoZSBib3VuZCBwYXJhbWV0ZXJzIGluIGNhc2UgdGhlIGJ1dHRvbiBpcyB1c2VkXG5cdFx0Ly8gaW5zaWRlIGFub3RoZXIgaW4gZXhjbHVzaXZlIG1vZGUgKHN1Y2ggaXMgdGhlIGNhc2Ugb2YgdGhlIGxpbmsgYnV0dG9uKVxuXHRcdHRoaXMucHJvcHMuY2FuY2VsRXhjbHVzaXZlKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEZvY3VzZXMgdGhlIHVzZXIgY3Vyc29yIG9uIHRoZSB3aWRnZXQncyBpbnB1dC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFZpZGVvRWRpdFxuXHQgKiBAbWV0aG9kIF9mb2N1c1ZpZGVvVXJsSW5wdXRcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2ZvY3VzVmlkZW9VcmxJbnB1dCA9ICgpID0+IHtcblx0XHRSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzLnJlZnMubGlua0lucHV0KS5mb2N1cygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBNb25pdG9ycyBrZXkgaW50ZXJhY3Rpb24gaW5zaWRlIHRoZSBpbnB1dCBlbGVtZW50IHRvIHJlc3BvbmQgdG8gdGhlIGtleXM6XG5cdCAqIC0gRW50ZXI6IENyZWF0ZXMvdXBkYXRlcyB0aGUgbGluay5cblx0ICogLSBFc2NhcGU6IERpc2NhcmRzIHRoZSBjaGFuZ2VzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkVmlkZW9FZGl0XG5cdCAqIEBtZXRob2QgX2hhbmRsZUtleURvd25cblx0ICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIGtleWJvYXJkIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfaGFuZGxlS2V5RG93biA9IGV2ZW50ID0+IHtcblx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VOVEVSIHx8IGV2ZW50LmtleUNvZGUgPT09IEtFWV9FU0MpIHtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuXHRcdFx0dGhpcy5fZW1iZWRWaWRlb1VSTCgpO1xuXHRcdH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS0VZX0VTQykge1xuXHRcdFx0dGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCBzdGF0ZSB3aGVuIHRoZSBsaW5rIGlucHV0IGNoYW5nZXMgb24gdXNlciBpbnRlcmFjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFZpZGVvRWRpdFxuXHQgKiBAbWV0aG9kIF9oYW5kbGVWaWRlb1VSTENoYW5nZVxuXHQgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgY2hhbmdlIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfaGFuZGxlVmlkZW9VUkxDaGFuZ2UgPSBldmVudCA9PiB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHR2aWRlb1VSTDogZXZlbnQudGFyZ2V0LnZhbHVlLFxuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBWZXJpZmllcyB0aGF0IHRoZSBjdXJyZW50IGxpbmsgc3RhdGUgaXMgdmFsaWQgc28gdGhlIHVzZXIgY2FuIHNhdmUgdGhlIGxpbmsuIEEgdmFsaWQgc3RhdGVcblx0ICogbWVhbnMgdGhhdCB3ZSBoYXZlIGEgbm9uLWVtcHR5IHZpZGVvVVJMIHRoYXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgb3JpZ2luYWwgb25lLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEVtYmVkVmlkZW9FZGl0XG5cdCAqIEBtZXRob2QgX2lzVmFsaWRTdGF0ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHN0YXRlIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2Vcblx0ICovXG5cdF9pc1ZhbGlkU3RhdGUoKSB7XG5cdFx0Y29uc3QgdmFsaWRTdGF0ZSA9XG5cdFx0XHR0aGlzLnN0YXRlLnZpZGVvVVJMICYmXG5cdFx0XHR0aGlzLnN0YXRlLnZpZGVvVVJMICE9PSB0aGlzLnN0YXRlLmluaXRpYWxFbWJlZC52aWRlb1VSTDtcblxuXHRcdHJldHVybiB2YWxpZFN0YXRlO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEVkaXRvckNvbnRleHQudG9Qcm9wcyhCdXR0b25FbWJlZFZpZGVvRWRpdCk7XG4iLCJpbXBvcnQgQnV0dG9uRW1iZWRWaWRlb0VkaXQgZnJvbSAnLi9idXR0b24tZW1iZWQtdmlkZW8tZWRpdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblByb3BzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXByb3BzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25FbWJlZFZpZGVvIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNoYW5naW5nIHRleHQgY29sb3IgaW4gYSBkb2N1bWVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uRW1iZWRWaWRlb1xuICogQHVzZXMgQnV0dG9uUHJvcHNcbiAqL1xuY2xhc3MgQnV0dG9uRW1iZWRWaWRlbyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBrZXkgPSAnZW1iZWRWaWRlbyc7XG5cblx0c3RhdGljIHByb3BUeXBlcyA9IHtcblx0XHQvKipcblx0XHQgKiBUaGUgbGFiZWwgdGhhdCBzaG91bGQgYmUgdXNlZCBmb3IgYWNjZXNzaWJpbGl0eSBwdXJwb3Nlcy5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFZpZGVvXG5cdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGxhYmVsXG5cdFx0ICovXG5cdFx0bGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGFiSW5kZXggb2YgdGhlIGJ1dHRvbiBpbiBpdHMgdG9vbGJhciBjdXJyZW50IHN0YXRlLiBBIHZhbHVlIG90aGVyIHRoYW4gLTFcblx0XHQgKiBtZWFucyB0aGF0IHRoZSBidXR0b24gaGFzIGZvY3VzIGFuZCBpcyB0aGUgYWN0aXZlIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRWaWRlb1xuXHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0YWJJbmRleFxuXHRcdCAqL1xuXHRcdHRhYkluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0cmV0dXJuIDxCdXR0b25FbWJlZFZpZGVvRWRpdCB7Li4udGhpcy5wcm9wc30gLz47XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnZpZGVvfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWVtYmVkLXZpZGVvXCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmV9XG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MudmlkZW99PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInZpZGVvXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Qcm9wcyhCdXR0b25FbWJlZFZpZGVvKTtcbiIsImltcG9ydCBCdXR0b25FbWJlZEVkaXQgZnJvbSAnLi9idXR0b24tZW1iZWQtZWRpdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEJ1dHRvbktleXN0cm9rZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1rZXlzdHJva2UnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uRW1iZWQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgYW5kIGVkaXRpbmcgYW4gZW1iZWQgbGluayBpbiBhIGRvY3VtZW50LlxuICogQnV0dG9uRW1iZWQgcmVuZGVycyBpbiB0d28gZGlmZmVyZW50IG1vZGVzOlxuICpcbiAqIC0gTm9ybWFsOiBKdXN0IGEgYnV0dG9uIHRoYXQgYWxsb3dzIHRvIHN3aXRjaCB0byB0aGUgZWRpdGlvbiBtb2RlXG4gKiAtIEV4Y2x1c2l2ZTogVGhlIEJ1dHRvbkVtYmVkRWRpdCBVSSB3aXRoIGFsbCB0aGUgbGluayBlZGl0aW9uIGNvbnRyb2xzLlxuICpcbiAqIEBjbGFzcyBCdXR0b25FbWJlZFxuICogQHVzZXMgQnV0dG9uS2V5c3Ryb2tlXG4gKi9cbmNsYXNzIEJ1dHRvbkVtYmVkIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkXG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0a2V5c3Ryb2tlOiB7XG5cdFx0XHRmbjogJ19yZXF1ZXN0RXhjbHVzaXZlJyxcblx0XHRcdGtleXM6IENLRURJVE9SLkNUUkwgKyBDS0VESVRPUi5TSElGVCArIDc2IC8qIEwqLyxcblx0XHR9LFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgZW1iZWRcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkVtYmVkXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdlbWJlZCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25FbWJlZFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcblx0XHRcdHJldHVybiA8QnV0dG9uRW1iZWRFZGl0IHsuLi50aGlzLnByb3BzfSAvPjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MubGlua31cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1lbWJlZFwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5fcmVxdWVzdEV4Y2x1c2l2ZX1cblx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJwbHVzXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0cyB0aGUgbGluayBidXR0b24gdG8gYmUgcmVuZGVyZWQgaW4gZXhjbHVzaXZlIG1vZGUgdG8gYWxsb3cgdGhlIGVtYmVkZGluZyBvZiBhIGxpbmsuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uRW1iZWRcblx0ICogQG1ldGhvZCBfcmVxdWVzdEV4Y2x1c2l2ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfcmVxdWVzdEV4Y2x1c2l2ZSA9ICgpID0+IHtcblx0XHR0aGlzLnByb3BzLnJlcXVlc3RFeGNsdXNpdmUoQnV0dG9uRW1iZWQua2V5KTtcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uS2V5c3Ryb2tlKEJ1dHRvbkVtYmVkKTtcbiIsImltcG9ydCBCdXR0b25BY3Rpb25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1hY3Rpb24tc3R5bGUnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25IMSBjbGFzcyBwcm92aWRlcyB3cmFwcyBhIHNlbGVjdGlvbiBpbiBgaDFgIGVsZW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkgxXG4gKiBAdXNlcyBCdXR0b25BY3Rpb25TdHlsZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25IMSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25IMVxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdHN0eWxlOiB7XG5cdFx0XHRlbGVtZW50OiAnaDEnLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBoMVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSDFcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2gxJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkgxXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuaDF9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWgxXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5hcHBseVN0eWxlfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuaDF9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJoMVwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkFjdGlvblN0eWxlKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25TdHlsZShCdXR0b25IMSkpKTtcbiIsImltcG9ydCBCdXR0b25BY3Rpb25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1hY3Rpb24tc3R5bGUnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25IMiBjbGFzcyBwcm92aWRlcyB3cmFwcyBhIHNlbGVjdGlvbiBpbiBgaDJgIGVsZW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkgyXG4gKiBAdXNlcyBCdXR0b25BY3Rpb25TdHlsZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25IMiBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25IMlxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdHN0eWxlOiB7XG5cdFx0XHRlbGVtZW50OiAnaDInLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBoMlxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSDJcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2gyJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkgyXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuaDJ9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWgyXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5hcHBseVN0eWxlfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuaDJ9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJoMlwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkFjdGlvblN0eWxlKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25TdHlsZShCdXR0b25IMikpKTtcbiIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkhsaW5lIGNsYXNzIHByb3ZpZGVzIGluc2VydHMgaG9yaXpvbnRhbCBsaW5lLlxuICpcbiAqIEBjbGFzcyBCdXR0b25IbGluZVxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uSGxpbmUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSGxpbmVcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnaG9yaXpvbnRhbHJ1bGUnLFxuXHRcdHN0eWxlOiB7XG5cdFx0XHRlbGVtZW50OiAnaHInLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBobGluZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSGxpbmVcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2hsaW5lJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkhsaW5lXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuaG9yaXpvbnRhbHJ1bGV9XG5cdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1obGluZVwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5ob3Jpem9udGFscnVsZX0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImhyXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChCdXR0b25TdHlsZShCdXR0b25IbGluZSkpO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBCdXR0b25JY29uKHtjbGFzc05hbWUgPSAnJywgc3ltYm9sfSkge1xuXHRyZXR1cm4gKFxuXHRcdDxFZGl0b3JDb250ZXh0LkNvbnN1bWVyPlxuXHRcdFx0eyh7ZWRpdG9yfSkgPT4ge1xuXHRcdFx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSBlZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRcdFx0Y29uc3Qgc3ByaXRlbWFwID0gbmF0aXZlRWRpdG9yLmNvbmZpZy5zcHJpdGVtYXAgfHwgJyc7XG5cdFx0XHRcdGNvbnN0IHBhdGggPSBgJHtzcHJpdGVtYXB9IyR7c3ltYm9sfWA7XG5cdFx0XHRcdGNvbnN0IGNsYXNzTmFtZVByZWZpeCA9IGNsYXNzTmFtZSA/IGAgJHtjbGFzc05hbWV9YCA6ICcnO1xuXHRcdFx0XHRjb25zdCBjb21iaW5lZENsYXNzTmFtZSA9IGBhZS1zdmctaWNvbiR7Y2xhc3NOYW1lUHJlZml4fWA7XG5cblx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHQ8c3ZnIGNsYXNzTmFtZT17Y29tYmluZWRDbGFzc05hbWV9IHdpZHRoPVwiMThcIiBoZWlnaHQ9XCIxOFwiPlxuXHRcdFx0XHRcdFx0PHVzZSBocmVmPXtwYXRofSAvPlxuXHRcdFx0XHRcdDwvc3ZnPlxuXHRcdFx0XHQpO1xuXHRcdFx0fX1cblx0XHQ8L0VkaXRvckNvbnRleHQuQ29uc3VtZXI+XG5cdCk7XG59XG4iLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25JbWFnZUFsaWduQ2VudGVyIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGFsaWduaW5nIGFuIGltYWdlIGluIHRoZSBjZW50ZXIuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkltYWdlQWxpZ25DZW50ZXJcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25JbWFnZUFsaWduQ2VudGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25DZW50ZXJcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnanVzdGlmeWNlbnRlcicsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBpbWFnZUNlbnRlclxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlclxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnaW1hZ2VDZW50ZXInO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnbkNlbnRlclxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduQ2VudGVyfVxuXHRcdFx0XHRhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9XG5cdFx0XHRcdGNsYXNzTmFtZT17Y3NzQ2xhc3N9XG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1pbWFnZS1hbGlnbi1jZW50ZXJcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25DZW50ZXJ9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJhbGlnbi1pbWFnZS1jZW50ZXJcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuXHRCdXR0b25Db21tYW5kQWN0aXZlKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25JbWFnZUFsaWduQ2VudGVyKSlcbik7XG4iLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25JbWFnZUFsaWduTGVmdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhbGlnbmluZyBhbiBpbWFnZSBvbiBsZWZ0LlxuICpcbiAqIEBjbGFzcyBCdXR0b25JbWFnZUFsaWduTGVmdFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvbkltYWdlQWxpZ25MZWZ0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25MZWZ0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ2p1c3RpZnlsZWZ0Jyxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IGltYWdlTGVmdFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnbkxlZnRcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2ltYWdlTGVmdCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbWFnZUFsaWduTGVmdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduTGVmdH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24taW1hZ2UtYWxpZ24tbGVmdFwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkxlZnR9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJhbGlnbi1pbWFnZS1sZWZ0XCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcblx0QnV0dG9uQ29tbWFuZEFjdGl2ZShCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uSW1hZ2VBbGlnbkxlZnQpKVxuKTtcbiIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRBY3RpdmUgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZC1hY3RpdmUnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkltYWdlQWxpZ25SaWdodCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhbGlnbmluZyBhbiBpbWFnZSBvbiByaWdodC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0XG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kQWN0aXZlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqL1xuY2xhc3MgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25SaWdodFxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdqdXN0aWZ5cmlnaHQnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgaW1hZ2VSaWdodFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2VBbGlnblJpZ2h0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdpbWFnZVJpZ2h0JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlQWxpZ25SaWdodFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduUmlnaHR9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWltYWdlLWFsaWduLXJpZ2h0XCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduUmlnaHR9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJhbGlnbi1pbWFnZS1yaWdodFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbkNvbW1hbmRBY3RpdmUoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvbkltYWdlQWxpZ25SaWdodCkpXG4pO1xuIiwiaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25JbWFnZSBjbGFzcyBpbnNlcnRzIGFuIGltYWdlIHRvIHRoZSBjb250ZW50LlxuICpcbiAqIEBjbGFzcyBCdXR0b25JbWFnZVxuICovXG5jbGFzcyBCdXR0b25JbWFnZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBpbWFnZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2Vcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2ltYWdlRnJvbUZpbGUnO1xuXG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXHRcdHRoaXMuZmlsZUlucHV0ID0gUmVhY3QuY3JlYXRlUmVmKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGlucHV0U3lsZSA9IHtkaXNwbGF5OiAnbm9uZSd9O1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXY+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmltYWdlfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWltYWdlXCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfVxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmltYWdlfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJkb2N1bWVudC1pbWFnZVwiIC8+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXG5cdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdGFjY2VwdD1cImltYWdlLypcIlxuXHRcdFx0XHRcdG9uQ2hhbmdlPXt0aGlzLl9vbklucHV0Q2hhbmdlfVxuXHRcdFx0XHRcdHJlZj17dGhpcy5maWxlSW5wdXR9XG5cdFx0XHRcdFx0c3R5bGU9e2lucHV0U3lsZX1cblx0XHRcdFx0XHR0eXBlPVwiZmlsZVwiXG5cdFx0XHRcdC8+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNpbXVsYXRlcyBjbGljayBvbiB0aGUgaW5wdXQgZWxlbWVudC4gVGhpcyB3aWxsIG9wZW4gYnJvd3NlcidzIG5hdGl2ZSBmaWxlIG9wZW4gZGlhbG9nLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkltYWdlXG5cdCAqIEBtZXRob2QgaGFuZGxlQ2xpY2tcblx0ICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIHJlY2VpdmVkIGNsaWNrIGV2ZW50IG9uIHRoZSBidXR0b24uXG5cdCAqL1xuXHRoYW5kbGVDbGljayA9ICgpID0+IHtcblx0XHR0aGlzLmZpbGVJbnB1dC5jdXJyZW50LmNsaWNrKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE9uIGlucHV0IGNoYW5nZSwgcmVhZHMgdGhlIGNob3NlbiBmaWxlIGFuZCBmaXJlcyBhbiBldmVudCBgYmVmb3JlSW1hZ2VBZGRgIHdpdGggdGhlIGltYWdlIHdoaWNoIHdpbGwgYmUgYWRkZWRcblx0ICogdG8gdGhlIGNvbnRlbnQuIFRoZSBpbWFnZSBmaWxlIHdpbGwgYmUgcGFzc2VkIGluIHRoZSBgaW1hZ2VGaWxlc2AgcHJvcGVydHkuXG5cdCAqIElmIGFueSBvZiB0aGUgbGlzdGVuZXJzIHJldHVybnMgYGZhbHNlYCBvciBjYW5jZWxzIHRoZSBldmVudCwgdGhlIGltYWdlIHdvbid0IGJlIGFkZGVkIHRvIHRoZSBjb250ZW50LlxuXHQgKiBPdGhlcndpc2UsIGFuIGV2ZW50IGBpbWFnZUFkZGAgd2lsbCBiZSBmaXJlZCB3aXRoIHRoZSBpbnNlcnRlZCBlbGVtZW50IGludG8gdGhlIGVkaXRhYmxlIGFyZWEuXG5cdCAqIFRoZSBwYXNzZWQgcGFyYW1zIHdpbGwgYmU6XG5cdCAqIC0gYGVsYCAtIHRoZSBjcmVhdGVkIGltZyBlbGVtZW50XG5cdCAqIC0gYGZpbGVgIC0gdGhlIG9yaWdpbmFsIGltYWdlIGZpbGUgZnJvbSB0aGUgaW5wdXQgZWxlbWVudFxuXHQgKlxuXHQgKiBAZmlyZXMgQnV0dG9uSW1hZ2UjYmVmb3JlSW1hZ2VBZGRcblx0ICogQGZpcmVzIEJ1dHRvbkltYWdlI2ltYWdlQWRkXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uSW1hZ2Vcblx0ICogQG1ldGhvZCBfb25JbnB1dENoYW5nZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfb25JbnB1dENoYW5nZSA9ICgpID0+IHtcblx0XHRjb25zdCBpbnB1dEVsID0gdGhpcy5maWxlSW5wdXQuY3VycmVudDtcblxuXHRcdC8vIE9uIElFMTEgdGhlIGZ1bmN0aW9uIG1pZ2h0IGJlIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGFycmF5IG9mXG5cdFx0Ly8gZmlsZXMuIEluIHN1Y2ggYSBjYXNlLCBubyBhY3Rpb25zIHdpbGwgYmUgdGFrZW4uXG5cdFx0aWYgKCFpbnB1dEVsLmZpbGVzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0Y29uc3QgZmlsZSA9IGlucHV0RWwuZmlsZXNbMF07XG5cblx0XHRyZWFkZXIub25sb2FkID0gZXZlbnQgPT4ge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRjb25zdCByZXN1bHQgPSBlZGl0b3IuZmlyZSgnYmVmb3JlSW1hZ2VBZGQnLCB7XG5cdFx0XHRcdGltYWdlRmlsZXM6IGZpbGUsXG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHRjb25zdCBlbCA9IENLRURJVE9SLmRvbS5lbGVtZW50LmNyZWF0ZUZyb21IdG1sKFxuXHRcdFx0XHRcdGA8aW1nIHNyYz1cIiR7ZXZlbnQudGFyZ2V0LnJlc3VsdH1cIj5gXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0ZWRpdG9yLmluc2VydEVsZW1lbnQoZWwpO1xuXG5cdFx0XHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblxuXHRcdFx0XHRjb25zdCBpbWFnZURhdGEgPSB7XG5cdFx0XHRcdFx0ZWwsXG5cdFx0XHRcdFx0ZmlsZSxcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRlZGl0b3IuZmlyZSgnaW1hZ2VBZGQnLCBpbWFnZURhdGEpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRyZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcblxuXHRcdGlucHV0RWwudmFsdWUgPSAnJztcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uSW1hZ2U7XG4iLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25JbmRlbnRCbG9jayBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBpbmRlbnRpbmcgdGhlIHNlbGVjdGVkIGJsb2Nrcy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSW5kZW50QmxvY2tcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25JbmRlbnRCbG9jayBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbmRlbnRCbG9ja1xuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdpbmRlbnQnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgaW5kZW50QmxvY2tcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkluZGVudEJsb2NrXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdpbmRlbnRCbG9jayc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25JbmRlbnRCbG9ja1xuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmluZGVudH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24taW5kZW50LWJsb2NrXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmluZGVudH0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImluZGVudC1sZXNzXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcblx0QnV0dG9uQ29tbWFuZEFjdGl2ZShCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uSW5kZW50QmxvY2spKVxuKTtcbiIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEJ1dHRvbktleXN0cm9rZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1rZXlzdHJva2UnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25JdGFsaWMgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3Igc3R5bGluZyBhbiBzZWxlY3Rpb24gd2l0aCBpdGFsaWMgKGVtKSBzdHlsZS5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uSXRhbGljXG4gKiBAdXNlcyBCdXR0b25Db21tYW5kXG4gKiBAdXNlcyBCdXR0b25LZXlzdHJva2VcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uSXRhbGljIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkl0YWxpY1xuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdpdGFsaWMnLFxuXHRcdGtleXN0cm9rZToge1xuXHRcdFx0Zm46ICdleGVjQ29tbWFuZCcsXG5cdFx0XHRrZXlzOiBDS0VESVRPUi5DVFJMICsgNzMgLyogSSovLFxuXHRcdH0sXG5cdFx0c3R5bGU6ICdjb3JlU3R5bGVzX2l0YWxpYycsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBpdGFsaWNcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkl0YWxpY1xuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnaXRhbGljJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkl0YWxpY1xuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLml0YWxpY31cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24taXRhbGljXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLml0YWxpY30+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cIml0YWxpY1wiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbktleXN0cm9rZShCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3R5bGUoQnV0dG9uSXRhbGljKSkpXG4pO1xuIiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEBjbGFzcyBCdXR0b25JdGVtU2VsZWN0b3JBdWRpb1xuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICovXG5jbGFzcyBCdXR0b25JdGVtU2VsZWN0b3JBdWRpbyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ2F1ZGlvc2VsZWN0b3InLFxuXHR9O1xuXG5cdHN0YXRpYyBrZXkgPSAnYXVkaW8nO1xuXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmF1ZGlvfVxuXHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tYXVkaW9cIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9oYW5kbGVDbGlja31cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmF1ZGlvfT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiYXVkaW9cIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxuXG5cdF9oYW5kbGVDbGljayA9ICgpID0+IHtcblx0XHR0aGlzLmV4ZWNDb21tYW5kKG51bGwpO1xuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKEJ1dHRvbkl0ZW1TZWxlY3RvckF1ZGlvKTtcbiIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBAY2xhc3MgQnV0dG9uSXRlbVNlbGVjdG9ySW1hZ2VcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuY2xhc3MgQnV0dG9uSXRlbVNlbGVjdG9ySW1hZ2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdpbWFnZXNlbGVjdG9yJyxcblx0fTtcblxuXHRzdGF0aWMga2V5ID0gJ2ltYWdlJztcblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5pbWFnZX1cblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLWltYWdlXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5faGFuZGxlQ2xpY2t9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5pbWFnZX0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInBpY3R1cmVcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxuXG5cdF9oYW5kbGVDbGljayA9ICgpID0+IHtcblx0XHR0aGlzLmV4ZWNDb21tYW5kKG51bGwpO1xuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKEJ1dHRvbkl0ZW1TZWxlY3RvckltYWdlKTtcbiIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBAY2xhc3MgQnV0dG9uSXRlbVNlbGVjdG9yVmlkZW9cbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuY2xhc3MgQnV0dG9uSXRlbVNlbGVjdG9yVmlkZW8gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICd2aWRlb3NlbGVjdG9yJyxcblx0fTtcblxuXHRzdGF0aWMga2V5ID0gJ3ZpZGVvJztcblxuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy52aWRlb31cblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXZpZGVvXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5faGFuZGxlQ2xpY2t9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy52aWRlb30+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInZpZGVvXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cblxuXHRfaGFuZGxlQ2xpY2sgPSAoKSA9PiB7XG5cdFx0dGhpcy5leGVjQ29tbWFuZChudWxsKTtcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChCdXR0b25JdGVtU2VsZWN0b3JWaWRlbyk7XG4iLCJpbXBvcnQgQnV0dG9uRHJvcGRvd24gZnJvbSAnLi9idXR0b24tZHJvcGRvd24uanN4JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXInO1xuXG4vKipcbiAqIFRoZSBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBzaG93aW5nIGEgbGlzdCBvZlxuICogaXRlbXMgdGhhdCBjYW4gYmUgc2VsZWN0ZWQgZm9yIHRoZSBsaW5rLlxuICpcbiAqIEBjbGFzcyBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuICogQHVzZXMgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gKi9cbmNsYXNzIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y2lyY3VsYXI6IGZhbHNlLFxuXHRcdGRhdGE6IFtdLFxuXHRcdGRlbGF5OiAxMDAsXG5cdFx0ZGVzY2VuZGFudHM6ICcuYWUtdG9vbGJhci1lbGVtZW50Jyxcblx0XHRrZXlzOiB7XG5cdFx0XHRkaXNtaXNzOiBbMjddLFxuXHRcdFx0ZGlzbWlzc05leHQ6IFszOV0sXG5cdFx0XHRkaXNtaXNzUHJldjogWzM3XSxcblx0XHRcdG5leHQ6IFs0MF0sXG5cdFx0XHRwcmV2OiBbMzhdLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBidXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Rcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2J1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0JztcblxuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdHRoaXMuc3RhdGUgPSB7XG5cdFx0XHRpdGVtczogW10sXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZWNlaXZpbmcgbmV3IHByb3BzLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Rcblx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG5cdCAqL1xuXHRjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuXHRcdGlmICghbmV4dFByb3BzLnRlcm0gfHwgbmV4dFByb3BzLnRlcm0gIT09IHRoaXMucHJvcHMudGVybSkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuXG5cdFx0XHRpZiAobmV4dFByb3BzLnRlcm0pIHtcblx0XHRcdFx0dGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5fdXBkYXRlSXRlbXMsIHRoaXMucHJvcHMuZGVsYXkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRcdFx0aXRlbXM6IFtdLFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobmV4dFByb3BzLmF1dG9jb21wbGV0ZVNlbGVjdGVkKSB7XG5cdFx0XHRzZXRUaW1lb3V0KHRoaXMuZm9jdXMsIDApO1xuXHRcdFx0dGhpcy5wcm9wcy5zZXRBdXRvY29tcGxldGVTdGF0ZSh7XG5cdFx0XHRcdHNlbGVjdGVkOiBmYWxzZSxcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgaW1tZWRpYXRlbHkgYmVmb3JlIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBmcm9tIHRoZSBET00uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Rcblx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsVW5tb3VudFxuXHQgKi9cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGxpc3QuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3Rcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0aWYgKCF0aGlzLnByb3BzLmV4cGFuZGVkIHx8ICF0aGlzLnN0YXRlLml0ZW1zLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxCdXR0b25Ecm9wZG93bj5cblx0XHRcdFx0e3RoaXMuX3JlbmRlckF1dG9jb21wbGV0ZUl0ZW1zKHRoaXMuc3RhdGUuaXRlbXMpfVxuXHRcdFx0PC9CdXR0b25Ecm9wZG93bj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBiZWZvcmUgcmVuZGVyaW5nIHdoZW4gbmV3IHByb3BzIG9yIHN0YXRlIGFyZSBiZWluZyByZWNlaXZlZC5cblx0ICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyIG9yIHdoZW4gZm9yY2VVcGRhdGUgaXMgdXNlZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdFxuXHQgKiBAbWV0aG9kICBzaG91bGRDb21wb25lbnRVcGRhdGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBmYWxzZSB3aGVuIHRoZSB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMgYW5kIHN0YXRlIHdpbGwgbm90XG5cdCAqIHJlcXVpcmUgYSBjb21wb25lbnQgdXBkYXRlLlxuXHQgKi9cblx0c2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdG5leHRQcm9wcy5leHBhbmRlZCAhPT0gdGhpcy5wcm9wcy5leHBhbmRlZCB8fFxuXHRcdFx0bmV4dFByb3BzLnRlcm0gIT09IHRoaXMucHJvcHMudGVybSB8fFxuXHRcdFx0bmV4dFN0YXRlLml0ZW1zICE9PSB0aGlzLnN0YXRlLml0ZW1zXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIGEgc2V0IG9mIGxpc3QgaXRlbXMgZm9yIHRoZSBwcm92aWRlZCBpdGVtc1xuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG5cdCAqIEBtZXRob2QgX3JlbmRlckF1dG9jb21wbGV0ZUl0ZW1zXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIExpc3Qgb2YgYXV0b2NvbXBsZXRlIGl0ZW1zIHRvIHJlbmRlclxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0FycmF5fSBSZW5kZXJlZCBsaXN0IGl0ZW0gaW5zdGFuY2VzXG5cdCAqL1xuXHRfcmVuZGVyQXV0b2NvbXBsZXRlSXRlbXMoaXRlbXMpIHtcblx0XHRpdGVtcyA9IGl0ZW1zIHx8IFtdO1xuXG5cdFx0Y29uc3QgaGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrID0gdGhpcy5wcm9wc1xuXHRcdFx0LmhhbmRsZUxpbmtBdXRvY29tcGxldGVDbGljaztcblxuXHRcdHJldHVybiBpdGVtcy5tYXAoaXRlbSA9PiB7XG5cdFx0XHRjb25zdCBjbGFzc05hbWUgPVxuXHRcdFx0XHR0aGlzLnByb3BzLnRlcm0gPT09IGl0ZW0udXJsXG5cdFx0XHRcdFx0PyAnYWUtdG9vbGJhci1lbGVtZW50IGFjdGl2ZSdcblx0XHRcdFx0XHQ6ICdhZS10b29sYmFyLWVsZW1lbnQnO1xuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8bGkga2V5PXtpdGVtLnVybH0gcm9sZT1cIm9wdGlvblwiPlxuXHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuXHRcdFx0XHRcdFx0b25DbGljaz17aGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrfVxuXHRcdFx0XHRcdFx0ZGF0YS12YWx1ZT17aXRlbS51cmx9PlxuXHRcdFx0XHRcdFx0e2l0ZW0udGl0bGV9XG5cdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdDwvbGk+XG5cdFx0XHQpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgZGF0YSBhY2NvcmRpbmcgdG8ge3RoaXMucHJvcHMudGVybX0gYW5kIGNhbGxzIHNldFN0YXRlKCkgd2l0aCB0aGUgcmV0dXJuZWQgZGF0YVxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0XG5cdCAqIEBtZXRob2QgX3VwZGF0ZUl0ZW1zXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF91cGRhdGVJdGVtcygpIHtcblx0XHRpZiAoIXRoaXMucHJvcHMudGVybSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUodGhpcy5wcm9wcy5kYXRhKHRoaXMucHJvcHMudGVybSkpO1xuXG5cdFx0cHJvbWlzZS50aGVuKGl0ZW1zID0+IHtcblx0XHRcdGlmIChpdGVtcy5sZW5ndGggJiYgIXRoaXMucHJvcHMuZXhwYW5kZWQpIHtcblx0XHRcdFx0dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bigpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0aXRlbXMsXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRGb2N1c01hbmFnZXIoQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QpO1xuIiwiaW1wb3J0IEJ1dHRvbktleXN0cm9rZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1rZXlzdHJva2UnO1xuaW1wb3J0IEJ1dHRvbkxpbmsgZnJvbSAnLi9idXR0b24tbGluay5qc3gnO1xuaW1wb3J0IEJ1dHRvbkxpbmtFZGl0QnJvd3NlIGZyb20gJy4vYnV0dG9uLWxpbmstZWRpdC1icm93c2UuanN4JztcbmltcG9ydCBCdXR0b25Qcm9wcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1wcm9wcyc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkxpbmtCcm93c2UgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2hhbmdpbmcgdGV4dCBjb2xvciBpbiBhIGRvY3VtZW50LlxuICpcbiAqIEB1c2VzIEJ1dHRvbktleXN0cm9rZVxuICogQHVzZXMgQnV0dG9uUHJvcHNcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICpcbiAqIEBjbGFzcyBCdXR0b25MaW5rQnJvd3NlXG4gKi9cbmNsYXNzIEJ1dHRvbkxpbmtCcm93c2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGtleXN0cm9rZToge1xuXHRcdFx0Zm46ICdfcmVxdWVzdEV4Y2x1c2l2ZScsXG5cdFx0XHRrZXlzOiBDS0VESVRPUi5DVFJMICsgNzYgLyogTCovLFxuXHRcdH0sXG5cdH07XG5cblx0c3RhdGljIGtleSA9ICdsaW5rQnJvd3NlJztcblxuXHRzdGF0aWMgcHJvcFR5cGVzID0ge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSBsYWJlbCB0aGF0IHNob3VsZCBiZSB1c2VkIGZvciBhY2Nlc3NpYmlsaXR5IHB1cnBvc2VzLlxuXHRcdCAqXG5cdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGxhYmVsXG5cdFx0ICovXG5cdFx0bGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXG5cblx0XHQvKipcblx0XHQgKiBUaGUgdGFiSW5kZXggb2YgdGhlIGJ1dHRvbiBpbiBpdHMgdG9vbGJhciBjdXJyZW50IHN0YXRlLiBBIHZhbHVlIG90aGVyIHRoYW4gLTFcblx0XHQgKiBtZWFucyB0aGF0IHRoZSBidXR0b24gaGFzIGZvY3VzIGFuZCBpcyB0aGUgYWN0aXZlIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gdGFiSW5kZXhcblx0XHQgKi9cblx0XHR0YWJJbmRleDogUHJvcFR5cGVzLm51bWJlcixcblx0fTtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcblx0XHRcdHRoaXMucHJvcHMgPSB0aGlzLm1lcmdlQnV0dG9uQ2ZnUHJvcHMoKTtcblxuXHRcdFx0cmV0dXJuIDxCdXR0b25MaW5rRWRpdEJyb3dzZSB7Li4udGhpcy5wcm9wc30gLz47XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiA8QnV0dG9uTGluayB7Li4udGhpcy5wcm9wc30gLz47XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlcXVlc3RzIHRoZSBsaW5rIGJ1dHRvbiB0byBiZSByZW5kZXJlZCBpbiBleGNsdXNpdmUgbW9kZSB0byBhbGxvdyB0aGUgY3JlYXRpb24gb2YgYSBsaW5rLlxuXHQgKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX3JlcXVlc3RFeGNsdXNpdmVcblx0ICovXG5cdF9yZXF1ZXN0RXhjbHVzaXZlKCkge1xuXHRcdHRoaXMucHJvcHMucmVxdWVzdEV4Y2x1c2l2ZShCdXR0b25MaW5rQnJvd3NlLmtleSk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uUHJvcHMoXG5cdEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25LZXlzdHJva2UoQnV0dG9uTGlua0Jyb3dzZSkpXG4pO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25MaW5rRWRpdCBmcm9tICcuL2J1dHRvbi1saW5rLWVkaXQuanN4JztcbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuXG4vKipcbiAqIFRoZSBMaW5rRWRpdEJyb3dzZSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhIGxpbmsgaW4gYSBkb2N1bWVudCxcbiAqIGFuZCBhbHNvIGFsbG93cyB0byBsaW5rIHRvIGFuIGV4aXN0aW5nIGZpbGUgaW4gRE0uXG4gKiBQcm92aWRlcyBVSSBmb3IgY3JlYXRpbmcsIGVkaXRpbmcgYW5kIHJlbW92aW5nIGEgbGluay5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uTGlua0VkaXRCcm93c2VcbiAqL1xuY2xhc3MgQnV0dG9uTGlua0VkaXRCcm93c2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdHN0YXRpYyBrZXkgPSAnbGlua0VkaXRCcm93c2UnO1xuXG5cdC8qKlxuXHQgKlxuXHQgKiBAaW5oZXJpdERvY1xuXHQgKi9cblx0Y29uc3RydWN0b3IocHJvcHMpIHtcblx0XHRzdXBlcihwcm9wcyk7XG5cblx0XHRjb25zdCBsaW5rID0gbmV3IENLRURJVE9SLkxpbmsoXG5cdFx0XHQvLyBDYW4ndCBhY2Nlc3MgY29udGV4dCBmcm9tIGNvbnN0cnVjdG9yLCBzbyBnZXQgZWRpdG9yIGZyb20gcHJvcHMuXG5cdFx0XHR0aGlzLnByb3BzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJylcblx0XHQpLmdldEZyb21TZWxlY3Rpb24oKTtcblxuXHRcdGNvbnN0IGhyZWYgPSBsaW5rID8gbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSA6ICcnO1xuXG5cdFx0dGhpcy5saW5rRWRpdEJ1dHRvblJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXG5cdFx0dGhpcy5zdGF0ZSA9IHtcblx0XHRcdGVsZW1lbnQ6IGxpbmssXG5cdFx0XHRsaW5rSHJlZjogaHJlZixcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWxpbmstZWRpdC1icm93c2VcIj5cblx0XHRcdFx0PEJ1dHRvbkxpbmtFZGl0IHJlZj17dGhpcy5saW5rRWRpdEJ1dHRvblJlZn0gey4uLnRoaXMucHJvcHN9IC8+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPVwiQnJvd3NlXCJcblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX2Jyb3dzZUNsaWNrfVxuXHRcdFx0XHRcdHRpdGxlPVwiYnJvd3NlXCI+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiZm9sZGVyXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE9wZW5zIGFuIGl0ZW0gc2VsZWN0b3IgZGlhbG9nLlxuXHQgKlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX2Jyb3dzZUNsaWNrXG5cdCAqL1xuXHRfYnJvd3NlQ2xpY2sgPSAoKSA9PiB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdGNvbnN0IHVybCA9IGVkaXRvci5jb25maWcuZG9jdW1lbnRCcm93c2VMaW5rVXJsO1xuXHRcdGNvbnN0IGJyb3dzZUxpbmtDYWxsYmFjayA9IGVkaXRvci5jb25maWcuZG9jdW1lbnRCcm93c2VMaW5rQ2FsbGJhY2s7XG5cdFx0Y29uc3QgbGlua1RhcmdldCA9IHRoaXMubGlua0VkaXRCdXR0b25SZWYuY3VycmVudFxuXHRcdFx0PyB0aGlzLmxpbmtFZGl0QnV0dG9uUmVmLmN1cnJlbnQuc3RhdGUubGlua1RhcmdldFxuXHRcdFx0OiAnJztcblxuXHRcdGNvbnN0IGNoYW5nZUxpbmtDYWxsYmFjayA9IHNlbGVjdGVkSXRlbSA9PiB7XG5cdFx0XHR0aGlzLl91cGRhdGVMaW5rKHNlbGVjdGVkSXRlbS52YWx1ZSwgbGlua1RhcmdldCwgc2VsZWN0ZWRJdGVtLmhyZWYpO1xuXHRcdH07XG5cblx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKGJyb3dzZUxpbmtDYWxsYmFjaykpIHtcblx0XHRcdGJyb3dzZUxpbmtDYWxsYmFjay5hcHBseShudWxsLCBbZWRpdG9yLCB1cmwsIGNoYW5nZUxpbmtDYWxsYmFja10pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgbGluayBpbiB0aGUgZWRpdG9yIGVsZW1lbnQuIElmIHRoZSBlbGVtZW50IGRpZG4ndCBleGlzdCBwcmV2aW91c2x5LCBpdCB3aWxsXG5cdCAqIGNyZWF0ZSBhIG5ldyA8YT4gZWxlbWVudCB3aXRoIHRoZSBocmVmIHNwZWNpZmllZCBpbiB0aGUgbGluayBpbnB1dC5cblx0ICpcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF91cGRhdGVMaW5rXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsaW5rSHJlZiBocmVmIHZhbHVlIGZvciB0aGUgbGlua1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gbGlua1RhcmdldCB0YXJnZXQgdmFsdWUgZm9yIHRoZSBsaW5rXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBsaW5rVGl0bGUgaWYgdGhlIGxpbmsgaXMgYSB0aXRsZSB0aGF0IHBvaW50cyB0byBhIHdpa2kgcGFnZSAob25seSB3b3JrcyBmb3IgY3Jlb2xlKVxuXHQgKi9cblx0X3VwZGF0ZUxpbmsgPSAobGlua0hyZWYsIGxpbmtUYXJnZXQsIGxpbmtUaXRsZSkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0XHRjb25zdCBsaW5rVXRpbHMgPSBuZXcgQ0tFRElUT1IuTGluayhlZGl0b3IsIHthcHBlbmRQcm90b2NvbDogZmFsc2V9KTtcblx0XHRjb25zdCBsaW5rQXR0cnMgPSB7XG5cdFx0XHR0YXJnZXQ6IGxpbmtUYXJnZXQsXG5cdFx0fTtcblx0XHRjb25zdCBtb2RpZnlTZWxlY3Rpb24gPSB7YWR2YW5jZTogdHJ1ZX07XG5cblx0XHRpZiAobGlua0hyZWYpIHtcblx0XHRcdGlmIChlZGl0b3IucGx1Z2lucyAmJiBlZGl0b3IucGx1Z2lucy5jcmVvbGUgJiYgIWxpbmtUaXRsZSkge1xuXHRcdFx0XHRsaW5rSHJlZiA9IGxvY2F0aW9uLm9yaWdpbiArIGxpbmtIcmVmO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5zdGF0ZS5lbGVtZW50KSB7XG5cdFx0XHRcdGxpbmtBdHRycy5ocmVmID0gbGlua0hyZWY7XG5cblx0XHRcdFx0bGlua1V0aWxzLnVwZGF0ZShcblx0XHRcdFx0XHRsaW5rQXR0cnMsXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5lbGVtZW50LFxuXHRcdFx0XHRcdG1vZGlmeVNlbGVjdGlvblxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGlua1V0aWxzLmNyZWF0ZShsaW5rSHJlZiwgbGlua0F0dHJzLCBtb2RpZnlTZWxlY3Rpb24pO1xuXHRcdFx0fVxuXG5cdFx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdFx0fVxuXHR9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBFZGl0b3JDb250ZXh0LnRvUHJvcHMoQnV0dG9uTGlua0VkaXRCcm93c2UpO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBCdXR0b25DZmdQcm9wcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1wcm9wcyc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgQnV0dG9uTGlua0F1dG9jb21wbGV0ZUxpc3QgZnJvbSAnLi9idXR0b24tbGluay1hdXRvY29tcGxldGUtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkxpbmtUYXJnZXRFZGl0IGZyb20gJy4vYnV0dG9uLWxpbmstdGFyZ2V0LWVkaXQuanN4JztcbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IExhbmcgZnJvbSAnLi4vLi4vb29wL2xhbmcnO1xuaW1wb3J0IFdpZGdldERyb3Bkb3duIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWRyb3Bkb3duJztcbmltcG9ydCBXaWRnZXRGb2N1c01hbmFnZXIgZnJvbSAnLi4vYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlcic7XG5cbi8qKlxuICogVGhlIEJ1dHRvbkxpbmtFZGl0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIGFuZCBlZGl0aW5nIGEgbGluayBpbiBhIGRvY3VtZW50LlxuICogUHJvdmlkZXMgVUkgZm9yIGNyZWF0aW5nLCBlZGl0aW5nIGFuZCByZW1vdmluZyBhIGxpbmsuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkxpbmtFZGl0XG4gKiBAdXNlcyBCdXR0b25DZmdQcm9wc1xuICogQHVzZXMgV2lkZ2V0RHJvcGRvd25cbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBCdXR0b25MaW5rRWRpdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0YXBwZW5kUHJvdG9jb2w6IHRydWUsXG5cdFx0YXV0b2NvbXBsZXRlVXJsOiAnJyxcblx0XHRjaXJjdWxhcjogdHJ1ZSxcblx0XHRjdXN0b21JbmRleFN0YXJ0OiB0cnVlLFxuXHRcdGRlZmF1bHRMaW5rVGFyZ2V0OiAnJyxcblx0XHRkZXNjZW5kYW50czogJy5hZS10b29sYmFyLWVsZW1lbnQnLFxuXHRcdGtleXM6IHtcblx0XHRcdGRpc21pc3M6IFsyN10sXG5cdFx0XHRkaXNtaXNzTmV4dDogWzM5XSxcblx0XHRcdGRpc21pc3NQcmV2OiBbMzddLFxuXHRcdFx0bmV4dDogWzQwXSxcblx0XHRcdHByZXY6IFszOF0sXG5cdFx0fSxcblx0XHRzaG93VGFyZ2V0U2VsZWN0b3I6IHRydWUsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBsaW5rRWRpdFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2xpbmtFZGl0JztcblxuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdHRoaXMubGlua0lucHV0ID0gUmVhY3QuY3JlYXRlUmVmKCk7XG5cdFx0dGhpcy5zdGF0ZSA9IHRoaXMuX2dldEluaXRpYWxTdGF0ZSgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdCAqXG5cdCAqIEZvY3VzZXMgb24gdGhlIGxpbmsgaW5wdXQgdG8gaW1tZWRpYXRlbHkgYWxsb3cgZWRpdGluZy4gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgdGhlIGNvbXBvbmVudFxuXHQgKiBpcyByZW5kZXJlZCBpbiBleGNsdXNpdmUgbW9kZSB0byBwcmV2ZW50IGFnZ3Jlc3NpdmUgZm9jdXMgc3RlYWxpbmcuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBjb21wb25lbnREaWRNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50RGlkTW91bnQoKSB7XG5cdFx0aWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlIHx8IHRoaXMucHJvcHMubWFudWFsU2VsZWN0aW9uKSB7XG5cdFx0XHQvLyBXZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHJlbmRlcmluZyBjeWNsZSBiZWZvcmUgZm9jdXNpbmcgdG8gYXZvaWQgdW5kZXNpcmVkXG5cdFx0XHQvLyBzY3JvbGxzIG9uIHRoZSBwYWdlXG5cdFx0XHR0aGlzLl9mb2N1c0xpbmtJbnB1dCgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgd2hlbiBhIGNvbXBvbmVudCBpcyByZWNlaXZpbmcgbmV3IHByb3BzLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzXG5cdCAqL1xuXHRjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkge1xuXHRcdHRoaXMuc2V0U3RhdGUodGhpcy5fZ2V0SW5pdGlhbFN0YXRlKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRsZXQgdGFyZ2V0U2VsZWN0b3IgPSB7XG5cdFx0XHRhbGxvd2VkVGFyZ2V0czogdGhpcy5wcm9wcy5hbGxvd2VkVGFyZ2V0cyxcblx0XHRcdGVkaXRvcjogdGhpcy5jb250ZXh0LmVkaXRvcixcblx0XHRcdGhhbmRsZUxpbmtUYXJnZXRDaGFuZ2U6IHRoaXMuX2hhbmRsZUxpbmtUYXJnZXRDaGFuZ2UsXG5cdFx0XHRzZWxlY3RlZFRhcmdldDpcblx0XHRcdFx0dGhpcy5zdGF0ZS5saW5rVGFyZ2V0IHx8IEFsbG95RWRpdG9yLlN0cmluZ3MubGlua1RhcmdldERlZmF1bHQsXG5cdFx0fTtcblxuXHRcdHRhcmdldFNlbGVjdG9yID0gdGhpcy5tZXJnZURyb3Bkb3duUHJvcHMoXG5cdFx0XHR0YXJnZXRTZWxlY3Rvcixcblx0XHRcdEJ1dHRvbkxpbmtUYXJnZXRFZGl0LmtleVxuXHRcdCk7XG5cblx0XHRsZXQgYXV0b2NvbXBsZXRlRHJvcGRvd247XG5cblx0XHRpZiAodGhpcy5wcm9wcy5kYXRhKSB7XG5cdFx0XHRsZXQgZGF0YUZuID0gdGhpcy5wcm9wcy5kYXRhO1xuXG5cdFx0XHRpZiAoIUxhbmcuaXNGdW5jdGlvbihkYXRhRm4pKSB7XG5cdFx0XHRcdGNvbnN0IGl0ZW1zID0gdGhpcy5wcm9wcy5kYXRhO1xuXG5cdFx0XHRcdGRhdGFGbiA9ICgpID0+IGl0ZW1zO1xuXHRcdFx0fVxuXG5cdFx0XHRsZXQgYXV0b2NvbXBsZXRlRHJvcGRvd25Qcm9wcyA9IHtcblx0XHRcdFx0YXV0b2NvbXBsZXRlU2VsZWN0ZWQ6IHRoaXMuc3RhdGUuYXV0b2NvbXBsZXRlU2VsZWN0ZWQsXG5cdFx0XHRcdGRhdGE6IGRhdGFGbixcblx0XHRcdFx0ZWRpdG9yOiB0aGlzLmNvbnRleHQuZWRpdG9yLFxuXHRcdFx0XHRoYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2s6IHRoaXMuX2hhbmRsZUxpbmtBdXRvY29tcGxldGVDbGljayxcblx0XHRcdFx0b25EaXNtaXNzOiB0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3duLFxuXHRcdFx0XHRzZXRBdXRvY29tcGxldGVTdGF0ZTogdGhpcy5fc2V0QXV0b2NvbXBsZXRlU3RhdGUsXG5cdFx0XHRcdHRlcm06IHRoaXMuc3RhdGUubGlua0hyZWYsXG5cdFx0XHR9O1xuXG5cdFx0XHRhdXRvY29tcGxldGVEcm9wZG93blByb3BzID0gdGhpcy5tZXJnZURyb3Bkb3duUHJvcHMoXG5cdFx0XHRcdGF1dG9jb21wbGV0ZURyb3Bkb3duUHJvcHMsXG5cdFx0XHRcdEJ1dHRvbkxpbmtBdXRvY29tcGxldGVMaXN0LmtleVxuXHRcdFx0KTtcblxuXHRcdFx0YXV0b2NvbXBsZXRlRHJvcGRvd24gPSAoXG5cdFx0XHRcdDxCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdCB7Li4uYXV0b2NvbXBsZXRlRHJvcGRvd25Qcm9wc30gLz5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0bGV0IGJ1dHRvbkNsZWFyTGluaztcblxuXHRcdGlmICh0aGlzLnN0YXRlLmxpbmtIcmVmKSB7XG5cdFx0XHRidXR0b25DbGVhckxpbmsgPSAoXG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNsZWFySW5wdXR9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uIGFlLWJ1dHRvbi1jbGVhclwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5fY2xlYXJMaW5rfVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNsZWFyfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJ0aW1lcy1jaXJjbGVcIiAvPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcGxhY2Vob2xkZXJQcm9wID0ge307XG5cblx0XHRpZiAoIUNLRURJVE9SLmVudi5pZSAmJiBBbGxveUVkaXRvci5TdHJpbmdzKSB7XG5cdFx0XHRwbGFjZWhvbGRlclByb3AucGxhY2Vob2xkZXIgPSBBbGxveUVkaXRvci5TdHJpbmdzLmVkaXRMaW5rO1xuXHRcdH1cblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1lZGl0LWxpbmtcIj5cblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MucmVtb3ZlTGlua31cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdGRpc2FibGVkPXshdGhpcy5zdGF0ZS5lbGVtZW50fVxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX3JlbW92ZUxpbmt9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MucmVtb3ZlfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJjaGFpbi1icm9rZW5cIiAvPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItaW5wdXQgeHhsXCI+XG5cdFx0XHRcdFx0e3RoaXMucHJvcHMuc2hvd1RhcmdldFNlbGVjdG9yICYmIChcblx0XHRcdFx0XHRcdDxCdXR0b25MaW5rVGFyZ2V0RWRpdCB7Li4udGFyZ2V0U2VsZWN0b3J9IC8+XG5cdFx0XHRcdFx0KX1cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1pbnB1dFwiPlxuXHRcdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWlucHV0XCJcblx0XHRcdFx0XHRcdFx0b25DaGFuZ2U9e3RoaXMuX2hhbmRsZUxpbmtIcmVmQ2hhbmdlfVxuXHRcdFx0XHRcdFx0XHRvbktleURvd249e3RoaXMuX2hhbmRsZUtleURvd259XG5cdFx0XHRcdFx0XHRcdHsuLi5wbGFjZWhvbGRlclByb3B9XG5cdFx0XHRcdFx0XHRcdHJlZj17dGhpcy5saW5rSW5wdXR9XG5cdFx0XHRcdFx0XHRcdHR5cGU9XCJ0ZXh0XCJcblx0XHRcdFx0XHRcdFx0dmFsdWU9e3RoaXMuc3RhdGUubGlua0hyZWZ9XG5cdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0e2F1dG9jb21wbGV0ZURyb3Bkb3dufVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdHtidXR0b25DbGVhckxpbmt9XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5jb25maXJtfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0ZGlzYWJsZWQ9eyF0aGlzLl9pc1ZhbGlkU3RhdGUoKX1cblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLl91cGRhdGVMaW5rfVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbmZpcm19PlxuXHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNoZWNrXCIgY2xhc3NOYW1lPVwiYWUtaWNvbi1zdmctY2hlY2tcIiAvPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhpcy5zdGF0ZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuXHQgKiBAbWV0aG9kIF9nZXRJbml0aWFsU3RhdGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdCAqL1xuXHRfZ2V0SW5pdGlhbFN0YXRlKCkge1xuXHRcdC8vIENhbid0IGFjY2VzcyBjb250ZXh0IGZyb20gY29udHJ1Y3Rvciwgc28gZ2V0IGVkaXRvciBmcm9tIHByb3BzLlxuXHRcdGNvbnN0IHtlZGl0b3J9ID0gdGhpcy5wcm9wcy5jb250ZXh0O1xuXHRcdGNvbnN0IHtkZWZhdWx0TGlua1RhcmdldH0gPSB0aGlzLnByb3BzO1xuXG5cdFx0Y29uc3QgbGluayA9IG5ldyBDS0VESVRPUi5MaW5rKFxuXHRcdFx0ZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJylcblx0XHQpLmdldEZyb21TZWxlY3Rpb24oKTtcblx0XHRjb25zdCBocmVmID0gKGxpbmsgJiYgbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkgfHwgJyc7XG5cdFx0Y29uc3QgdGFyZ2V0ID1cblx0XHRcdChsaW5rICYmIGxpbmsuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKSkgfHwgZGVmYXVsdExpbmtUYXJnZXQ7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YXV0b2NvbXBsZXRlU2VsZWN0ZWQ6IGZhbHNlLFxuXHRcdFx0ZWxlbWVudDogbGluayxcblx0XHRcdGluaXRpYWxMaW5rOiB7XG5cdFx0XHRcdGhyZWYsXG5cdFx0XHRcdHRhcmdldCxcblx0XHRcdH0sXG5cdFx0XHRsaW5rSHJlZjogaHJlZixcblx0XHRcdGxpbmtUYXJnZXQ6IHRhcmdldCxcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIENsZWFycyB0aGUgbGluayBpbnB1dC4gVGhpcyBvbmx5IGNoYW5nZXMgdGhlIGNvbXBvbmVudCBpbnRlcm5hbCBzdGF0ZSwgYnV0IGRvZXMgbm90XG5cdCAqIGFmZmVjdCB0aGUgbGluayBlbGVtZW50IG9mIHRoZSBlZGl0b3IuIE9ubHkgdGhlIF9yZW1vdmVMaW5rIGFuZCBfdXBkYXRlTGluayBtZXRob2RzXG5cdCAqIGFyZSB0cmFuc2xhdGVkIHRvIHRoZSBlZGl0b3IgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuXHQgKiBAbWV0aG9kIF9jbGVhckxpbmtcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2NsZWFyTGluayA9ICgpID0+IHtcblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdGxpbmtIcmVmOiAnJyxcblx0XHR9KTtcblxuXHRcdHRoaXMuX2ZvY3VzTGlua0lucHV0KCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEZvY3VzZXMgdGhlIHVzZXIgY3Vyc29yIG9uIHRoZSB3aWRnZXQncyBpbnB1dC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuXHQgKiBAbWV0aG9kIF9mb2N1c0xpbmtJbnB1dFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfZm9jdXNMaW5rSW5wdXQoKSB7XG5cdFx0Y29uc3QgaW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0Y29uc3QgZm9jdXNMaW5rRWwgPSBmdW5jdGlvbigpIHtcblx0XHRcdGluc3RhbmNlLmxpbmtJbnB1dC5jdXJyZW50LmZvY3VzKCk7XG5cdFx0fTtcblxuXHRcdGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZvY3VzTGlua0VsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2V0VGltZW91dChmb2N1c0xpbmtFbCwgMCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIE1vbml0b3JzIGtleSBpbnRlcmFjdGlvbiBpbnNpZGUgdGhlIGlucHV0IGVsZW1lbnQgdG8gcmVzcG9uZCB0byB0aGUga2V5czpcblx0ICogLSBFbnRlcjogQ3JlYXRlcy91cGRhdGVzIHRoZSBsaW5rLlxuXHQgKiAtIEVzY2FwZTogRGlzY2FyZHMgdGhlIGNoYW5nZXMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua0VkaXRcblx0ICogQG1ldGhvZCBfaGFuZGxlS2V5RG93blxuXHQgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUga2V5Ym9hcmQgZXZlbnQuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9oYW5kbGVLZXlEb3duID0gZXZlbnQgPT4ge1xuXHRcdGlmIChldmVudC5rZXlDb2RlID09PSAxMyB8fCBldmVudC5rZXlDb2RlID09PSAyNykge1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZUxpbmsoKTtcblx0XHR9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IDQwKSB7XG5cdFx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0YXV0b2NvbXBsZXRlU2VsZWN0ZWQ6IHRydWUsXG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvcikuYWR2YW5jZVNlbGVjdGlvbigpO1xuXG5cdFx0XHR0aGlzLmNvbnRleHQuZWRpdG9yXG5cdFx0XHRcdC5nZXQoJ25hdGl2ZUVkaXRvcicpXG5cdFx0XHRcdC5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCBzdGF0ZSB3aGVuIHRoZSBsaW5rIGlucHV0IGNoYW5nZXMgb24gdXNlciBpbnRlcmFjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuXHQgKiBAbWV0aG9kIF9oYW5kbGVMaW5rSHJlZkNoYW5nZVxuXHQgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBUaGUgY2hhbmdlIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfaGFuZGxlTGlua0hyZWZDaGFuZ2UgPSBldmVudCA9PiB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRsaW5rSHJlZjogZXZlbnQudGFyZ2V0LnZhbHVlLFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fZm9jdXNMaW5rSW5wdXQoKTtcblx0fTtcblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgY29tcG9uZW50IHN0YXRlIHdoZW4gdGhlIGxpbmsgdGFyZ2V0IGNoYW5nZXMgb24gdXNlciBpbnRlcmFjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuXHQgKiBAbWV0aG9kIF9oYW5kbGVMaW5rVGFyZ2V0Q2hhbmdlXG5cdCAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBjbGljayBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2hhbmRsZUxpbmtUYXJnZXRDaGFuZ2UgPSBldmVudCA9PiB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRpdGVtRHJvcGRvd246IG51bGwsXG5cdFx0XHRsaW5rVGFyZ2V0OiBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXZhbHVlJyksXG5cdFx0fSk7XG5cblx0XHR0aGlzLl9mb2N1c0xpbmtJbnB1dCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQgc3RhdGUgd2hlbiBhbiBhdXRvY29tcGxldGUgbGluayByZXN1bHQgaXMgc2VsZWN0ZWQgYnkgdXNlciBpbnRlcmFjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuXHQgKiBAbWV0aG9kIF9oYW5kbGVMaW5rQXV0b2NvbXBsZXRlQ2xpY2tcblx0ICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIGNsaWNrIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfaGFuZGxlTGlua0F1dG9jb21wbGV0ZUNsaWNrKGV2ZW50KSB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRpdGVtRHJvcGRvd246IG51bGwsXG5cdFx0XHRsaW5rSHJlZjogZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS12YWx1ZScpLFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fZm9jdXNMaW5rSW5wdXQoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBWZXJpZmllcyB0aGF0IHRoZSBjdXJyZW50IGxpbmsgc3RhdGUgaXMgdmFsaWQgc28gdGhlIHVzZXIgY2FuIHNhdmUgdGhlIGxpbmsuIEEgdmFsaWQgc3RhdGVcblx0ICogbWVhbnMgdGhhdCB3ZSBoYXZlIGEgbm9uLWVtcHR5IGhyZWYgYW5kIHRoYXQgZWl0aGVyIHRoYXQgb3IgdGhlIGxpbmsgdGFyZ2V0IGFyZSBkaWZmZXJlbnRcblx0ICogZnJvbSB0aGUgb3JpZ2luYWwgbGluay5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuXHQgKiBAbWV0aG9kIF9pc1ZhbGlkU3RhdGVcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBbZGVzY3JpcHRpb25dXG5cdCAqL1xuXHRfaXNWYWxpZFN0YXRlKCkge1xuXHRcdGNvbnN0IHZhbGlkU3RhdGUgPVxuXHRcdFx0dGhpcy5zdGF0ZS5saW5rSHJlZiAmJlxuXHRcdFx0KHRoaXMuc3RhdGUubGlua0hyZWYgIT09IHRoaXMuc3RhdGUuaW5pdGlhbExpbmsuaHJlZiB8fFxuXHRcdFx0XHR0aGlzLnN0YXRlLmxpbmtUYXJnZXQgIT09IHRoaXMuc3RhdGUuaW5pdGlhbExpbmsudGFyZ2V0KTtcblxuXHRcdHJldHVybiB2YWxpZFN0YXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIGxpbmsgaW4gdGhlIGVkaXRvciBlbGVtZW50LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG5cdCAqIEBtZXRob2QgX3JlbW92ZUxpbmtcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3JlbW92ZUxpbmsgPSAoKSA9PiB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdGNvbnN0IGxpbmtVdGlscyA9IG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvcik7XG5cdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdGNvbnN0IGJvb2ttYXJrcyA9IHNlbGVjdGlvbi5jcmVhdGVCb29rbWFya3MoKTtcblxuXHRcdGxpbmtVdGlscy5yZW1vdmUodGhpcy5zdGF0ZS5lbGVtZW50LCB7YWR2YW5jZTogdHJ1ZX0pO1xuXG5cdFx0c2VsZWN0aW9uLnNlbGVjdEJvb2ttYXJrcyhib29rbWFya3MpO1xuXG5cdFx0Ly8gV2UgbmVlZCB0byBjYW5jZWxFeGNsdXNpdmUgd2l0aCB0aGUgYm91bmQgcGFyYW1ldGVycyBpbiBjYXNlIHRoZSBidXR0b24gaXMgdXNlZFxuXHRcdC8vIGluc2lkZSBhbm90aGVyIGluIGV4Y2x1c2l2ZSBtb2RlIChzdWNoIGlzIHRoZSBjYXNlIG9mIHRoZSBsaW5rIGJ1dHRvbilcblx0XHR0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXG5cdFx0ZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGUgYXV0b2NvbXBsZXRlU2VsZWN0ZWQgc3RhdGUgdG8gZm9jdXMgYW5kIHNlbGVjdCBhdXRvY29tcGxldGXCtHMgZHJvcGRvd25cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rRWRpdFxuXHQgKiBAbWV0aG9kIF9zZXRBdXRvY29tcGxldGVTdGF0ZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfc2V0QXV0b2NvbXBsZXRlU3RhdGUoc3RhdGUpIHtcblx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdGF1dG9jb21wbGV0ZVNlbGVjdGVkOiBzdGF0ZS5zZWxlY3RlZCxcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGVzIHRoZSBsaW5rIGluIHRoZSBlZGl0b3IgZWxlbWVudC4gSWYgdGhlIGVsZW1lbnQgZGlkbid0IGV4aXN0IHByZXZpb3VzbHksIGl0IHdpbGxcblx0ICogY3JlYXRlIGEgbmV3IDxhPiBlbGVtZW50IHdpdGggdGhlIGhyZWYgc3BlY2lmaWVkIGluIHRoZSBsaW5rIGlucHV0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtFZGl0XG5cdCAqIEBtZXRob2QgX3VwZGF0ZUxpbmtcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3VwZGF0ZUxpbmsgPSAoKSA9PiB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdGNvbnN0IGxpbmtVdGlscyA9IG5ldyBDS0VESVRPUi5MaW5rKGVkaXRvciwge1xuXHRcdFx0YXBwZW5kUHJvdG9jb2w6IHRoaXMucHJvcHMuYXBwZW5kUHJvdG9jb2wsXG5cdFx0fSk7XG5cdFx0Y29uc3QgbGlua0F0dHJzID0ge1xuXHRcdFx0dGFyZ2V0OiB0aGlzLnN0YXRlLmxpbmtUYXJnZXQsXG5cdFx0fTtcblx0XHRjb25zdCBtb2RpZnlTZWxlY3Rpb24gPSB7YWR2YW5jZTogdHJ1ZX07XG5cblx0XHRpZiAodGhpcy5zdGF0ZS5saW5rSHJlZikge1xuXHRcdFx0aWYgKHRoaXMuc3RhdGUuZWxlbWVudCkge1xuXHRcdFx0XHRsaW5rQXR0cnMuaHJlZiA9IHRoaXMuc3RhdGUubGlua0hyZWY7XG5cblx0XHRcdFx0bGlua1V0aWxzLnVwZGF0ZShcblx0XHRcdFx0XHRsaW5rQXR0cnMsXG5cdFx0XHRcdFx0dGhpcy5zdGF0ZS5lbGVtZW50LFxuXHRcdFx0XHRcdG1vZGlmeVNlbGVjdGlvblxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGlua1V0aWxzLmNyZWF0ZShcblx0XHRcdFx0XHR0aGlzLnN0YXRlLmxpbmtIcmVmLFxuXHRcdFx0XHRcdGxpbmtBdHRycyxcblx0XHRcdFx0XHRtb2RpZnlTZWxlY3Rpb25cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0ZWRpdG9yLmZpcmUoJ2FjdGlvblBlcmZvcm1lZCcsIHRoaXMpO1xuXHRcdH1cblxuXHRcdC8vIFdlIG5lZWQgdG8gY2FuY2VsRXhjbHVzaXZlIHdpdGggdGhlIGJvdW5kIHBhcmFtZXRlcnMgaW4gY2FzZSB0aGUgYnV0dG9uIGlzIHVzZWRcblx0XHQvLyBpbnNpZGUgYW5vdGhlciBpbiBleGNsdXNpdmUgbW9kZSAoc3VjaCBpcyB0aGUgY2FzZSBvZiB0aGUgbGluayBidXR0b24pXG5cdFx0dGhpcy5wcm9wcy5jYW5jZWxFeGNsdXNpdmUoKTtcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgRWRpdG9yQ29udGV4dC50b1Byb3BzKFxuXHRCdXR0b25DZmdQcm9wcyhXaWRnZXREcm9wZG93bihXaWRnZXRGb2N1c01hbmFnZXIoQnV0dG9uTGlua0VkaXQpKSlcbik7XG4iLCJpbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFyZ2V0TGlzdCBmcm9tICcuL2J1dHRvbi10YXJnZXQtbGlzdC5qc3gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uTGlua1RhcmdldEVkaXQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2hhbmdpbmcgdGhlIHRhcmdldCBvZiBhIGxpbmtcbiAqIGluIHRoZSBkb2N1bWVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uTGlua1RhcmdldEVkaXRcbiAqL1xuY2xhc3MgQnV0dG9uTGlua1RhcmdldEVkaXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IGxpbmtUYXJnZXRFZGl0XG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rVGFyZ2V0RWRpdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnbGlua1RhcmdldEVkaXQnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua1RhcmdldEVkaXRcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgaGFuZGxlTGlua1RhcmdldENoYW5nZSA9IHRoaXMucHJvcHMuaGFuZGxlTGlua1RhcmdldENoYW5nZTtcblx0XHRjb25zdCBhbGxvd2VkTGlua1RhcmdldHMgPSB0aGlzLnByb3BzLmFsbG93ZWRUYXJnZXRzO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXZcblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWVkaXQtbGluay10YXJnZXQgYWUtY29udGFpbmVyLWRyb3Bkb3duIGFlLWNvbnRhaW5lci1kcm9wZG93bi1tZWRpdW0gYWUtaGFzLWRyb3Bkb3duXCJcblx0XHRcdFx0dGFiSW5kZXg9XCIwXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfVxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e3RoaXMucHJvcHMuc2VsZWN0ZWRUYXJnZXR9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtdG9vbGJhci1lbGVtZW50XCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdHJvbGU9XCJjb21ib2JveFwiXG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0dGl0bGU9e3RoaXMucHJvcHMuc2VsZWN0ZWRUYXJnZXR9PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyXCI+XG5cdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24tc2VsZWN0ZWQtaXRlbVwiPlxuXHRcdFx0XHRcdFx0XHR7dGhpcy5wcm9wcy5zZWxlY3RlZFRhcmdldH1cblx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImNhcmV0LWJvdHRvbVwiIC8+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHR7dGhpcy5wcm9wcy5leHBhbmRlZCAmJiAoXG5cdFx0XHRcdFx0PEJ1dHRvblRhcmdldExpc3Rcblx0XHRcdFx0XHRcdG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0XHRcdGFsbG93ZWRMaW5rVGFyZ2V0cz17YWxsb3dlZExpbmtUYXJnZXRzfVxuXHRcdFx0XHRcdFx0aGFuZGxlTGlua1RhcmdldENoYW5nZT17aGFuZGxlTGlua1RhcmdldENoYW5nZX1cblx0XHRcdFx0XHRcdHNlbGVjdGVkVGFyZ2V0PXt0aGlzLnByb3BzLnNlbGVjdGVkVGFyZ2V0fVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdCl9XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBiZWZvcmUgcmVuZGVyaW5nIHdoZW4gbmV3IHByb3BzIG9yIHN0YXRlIGFyZSBiZWluZyByZWNlaXZlZC5cblx0ICogVGhpcyBtZXRob2QgaXMgbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyIG9yIHdoZW4gZm9yY2VVcGRhdGUgaXMgdXNlZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rVGFyZ2V0RWRpdFxuXHQgKiBAbWV0aG9kICBzaG91bGRDb21wb25lbnRVcGRhdGVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBmYWxzZSB3aGVuIHRoZSB0cmFuc2l0aW9uIHRvIHRoZSBuZXcgcHJvcHMgYW5kIHN0YXRlIHdpbGwgbm90XG5cdCAqIHJlcXVpcmUgYSBjb21wb25lbnQgdXBkYXRlLlxuXHQgKi9cblx0c2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcykge1xuXHRcdHJldHVybiAoXG5cdFx0XHRuZXh0UHJvcHMuZXhwYW5kZWQgIT09IHRoaXMucHJvcHMuZXhwYW5kZWQgfHxcblx0XHRcdG5leHRQcm9wcy5zZWxlY3RlZFRhcmdldCAhPT0gdGhpcy5wcm9wcy5zZWxlY3RlZFRhcmdldFxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uTGlua1RhcmdldEVkaXQ7XG4iLCJpbXBvcnQgQnV0dG9uQ2ZnUHJvcHMgZnJvbSAnLi4vYmFzZS9idXR0b24tcHJvcHMnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEJ1dHRvbktleXN0cm9rZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1rZXlzdHJva2UnO1xuaW1wb3J0IEJ1dHRvbkxpbmtFZGl0IGZyb20gJy4vYnV0dG9uLWxpbmstZWRpdC5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uTGluayBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhIGxpbmsgaW4gYSBkb2N1bWVudC4gQnV0dG9uTGlua1xuICogcmVuZGVycyBpbiB0d28gZGlmZmVyZW50IG1vZGVzOlxuICpcbiAqIC0gTm9ybWFsOiBKdXN0IGEgYnV0dG9uIHRoYXQgYWxsb3dzIHRvIHN3aXRjaCB0byB0aGUgZWRpdGlvbiBtb2RlXG4gKiAtIEV4Y2x1c2l2ZTogVGhlIEJ1dHRvbkxpbmtFZGl0IFVJIHdpdGggYWxsIHRoZSBsaW5rIGVkaXRpb24gY29udHJvbHMuXG4gKlxuICogQGNsYXNzIEJ1dHRvbkxpbmtcbiAqIEB1c2VzIEJ1dHRvbkNmZ1Byb3BzXG4gKiBAdXNlcyBCdXR0b25LZXlzdHJva2VcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25MaW5rIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uTGlua1xuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGtleXN0cm9rZToge1xuXHRcdFx0Zm46ICdfcmVxdWVzdEV4Y2x1c2l2ZScsXG5cdFx0XHRrZXlzOiBDS0VESVRPUi5DVFJMICsgNzYgLyogTCovLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBsaW5rXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdsaW5rJztcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBjb250YWluZWQgd2l0aGluIGEgbGluay5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rXG5cdCAqIEBtZXRob2QgaXNBY3RpdmVcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIGlzIGluc2lkZSBhIGxpbmssIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG5cdGlzQWN0aXZlKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHRuZXcgQ0tFRElUT1IuTGluayhcblx0XHRcdFx0dGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpXG5cdFx0XHQpLmdldEZyb21TZWxlY3Rpb24oKSAhPT0gbnVsbFxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbkxpbmtcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlKSB7XG5cdFx0XHRjb25zdCBwcm9wcyA9IHRoaXMubWVyZ2VCdXR0b25DZmdQcm9wcygpO1xuXG5cdFx0XHRyZXR1cm4gPEJ1dHRvbkxpbmtFZGl0IHsuLi5wcm9wc30gLz47XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmxpbmt9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tbGlua1wiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5fcmVxdWVzdEV4Y2x1c2l2ZX1cblx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rfT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJsaW5rXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0cyB0aGUgbGluayBidXR0b24gdG8gYmUgcmVuZGVyZWQgaW4gZXhjbHVzaXZlIG1vZGUgdG8gYWxsb3cgdGhlIGNyZWF0aW9uIG9mIGEgbGluay5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25MaW5rXG5cdCAqIEBtZXRob2QgX3JlcXVlc3RFeGNsdXNpdmVcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3JlcXVlc3RFeGNsdXNpdmUgPSAoKSA9PiB7XG5cdFx0dGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlKEJ1dHRvbkxpbmsua2V5KTtcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ2ZnUHJvcHMoQnV0dG9uS2V5c3Ryb2tlKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25MaW5rKSkpO1xuIiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvbk9yZGVyZWRMaXN0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIG9yZGVyZWQgbGlzdHMgaW4gYW4gZWRpdG9yLlxuICpcbiAqIEBjbGFzcyBCdXR0b25PcmRlcmVkTGlzdFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25PcmRlcmVkTGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25PcmRlcmVkTGlzdFxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdudW1iZXJlZGxpc3QnLFxuXHRcdHN0eWxlOiB7XG5cdFx0XHRlbGVtZW50OiAnb2wnLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBvbFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uT3JkZXJlZExpc3Rcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ29sJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbk9yZGVyZWRMaXN0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MubnVtYmVyZWRsaXN0fVxuXHRcdFx0XHRhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9XG5cdFx0XHRcdGNsYXNzTmFtZT17Y3NzQ2xhc3N9XG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1vbFwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5udW1iZXJlZGxpc3R9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJsaXN0LW9sXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcblx0QnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblN0eWxlKEJ1dHRvbk9yZGVyZWRMaXN0KSlcbik7XG4iLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25PdXRkZW50QmxvY2sgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3Igb3V0ZGVudGluZyBibG9ja3MuXG4gKlxuICogQGNsYXNzIEJ1dHRvbk91dGRlbnRCbG9ja1xuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvbk91dGRlbnRCbG9jayBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25PdXRkZW50QmxvY2tcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnb3V0ZGVudCcsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBvdXRkZW50QmxvY2tcblx0ICogQG1lbWJlcm9mIEJ1dHRvbk91dGRlbnRCbG9ja1xuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnb3V0ZGVudEJsb2NrJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbk91dGRlbnRCbG9ja1xuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLm91dGRlbnR9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLW91dGRlbnQtYmxvY2tcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3Mub3V0ZGVudH0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImluZGVudC1tb3JlXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcblx0QnV0dG9uQ29tbWFuZEFjdGl2ZShCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uT3V0ZGVudEJsb2NrKSlcbik7XG4iLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnQgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgYWxpZ25pbmcgYSBwYXJhZ3JhcGggb24gbGVmdC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0XG4gKlxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhBbGlnbkxlZnRcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnanVzdGlmeWxlZnQnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgcGFyYWdyYXBoTGVmdFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdwYXJhZ3JhcGhMZWZ0JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduTGVmdH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tcGFyYWdyYXBoLWFsaWduLWxlZnRcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25MZWZ0fT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiYWxpZ24tbGVmdFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbkNvbW1hbmRBY3RpdmUoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdCkpXG4pO1xuIiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZSc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhbGlnbmluZyBhIHBhcmFncmFwaCBvbiByaWdodC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZEFjdGl2ZVxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKi9cbmNsYXNzIEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodFxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdqdXN0aWZ5cmlnaHQnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgcGFyYWdyYXBoUmlnaHRcblx0ICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHRcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3BhcmFncmFwaFJpZ2h0JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHRcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnblJpZ2h0fVxuXHRcdFx0XHRhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9XG5cdFx0XHRcdGNsYXNzTmFtZT17Y3NzQ2xhc3N9XG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1wYXJhZ3JhcGgtYWxpZ24tcmlnaHRcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25SaWdodH0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImFsaWduLXJpZ2h0XCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChcblx0QnV0dG9uQ29tbWFuZEFjdGl2ZShCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodCkpXG4pO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBCdXR0b25Db21tYW5kc0xpc3QgZnJvbSAnLi9idXR0b24tY29tbWFuZHMtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblBhcmFncmFwaEFsaWduIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gd29yayB3aXRoIHRhYmxlIHJvd3MuXG4gKlxuICogQGNsYXNzIEJ1dHRvblBhcmFncmFwaEFsaWduXG4gKi9cbmNsYXNzIEJ1dHRvblBhcmFncmFwaEFsaWduIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRzdGF0aWMga2V5ID0gJ3BhcmFncmFwaEFsaWduJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEFsaWduXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGxldCBidXR0b25Db21tYW5kc0xpc3Q7XG5cdFx0bGV0IGJ1dHRvbkNvbW1hbmRzTGlzdElkO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMuZXhwYW5kZWQpIHtcblx0XHRcdGJ1dHRvbkNvbW1hbmRzTGlzdElkID0gQnV0dG9uUGFyYWdyYXBoQWxpZ24ua2V5ICsgJ0xpc3QnO1xuXHRcdFx0YnV0dG9uQ29tbWFuZHNMaXN0ID0gKFxuXHRcdFx0XHQ8QnV0dG9uQ29tbWFuZHNMaXN0XG5cdFx0XHRcdFx0Y29tbWFuZHM9e3RoaXMuX2dldENvbW1hbmRzKCl9XG5cdFx0XHRcdFx0bGlzdElkPXtidXR0b25Db21tYW5kc0xpc3RJZH1cblx0XHRcdFx0XHRpbmxpbmVJY29ucz17ZmFsc2V9XG5cdFx0XHRcdFx0b25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHQvPlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRjb25zdCBhY3RpdmVDb21tYW5kID0gdGhpcy5fZ2V0Q29tbWFuZHMoKVxuXHRcdFx0LmZpbHRlcihhbGlnbm1lbnQgPT4ge1xuXHRcdFx0XHRjb25zdCBjb21tYW5kID0gZWRpdG9yLmdldENvbW1hbmQoYWxpZ25tZW50LmNvbW1hbmQpO1xuXG5cdFx0XHRcdHJldHVybiBjb21tYW5kID8gY29tbWFuZC5zdGF0ZSA9PT0gQ0tFRElUT1IuVFJJU1RBVEVfT04gOiBmYWxzZTtcblx0XHRcdH0pXG5cdFx0XHQucG9wKCk7XG5cblx0XHRjb25zdCBpY29uQ2xhc3NOYW1lID0gYWN0aXZlQ29tbWFuZC5pY29uO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWRyb3Bkb3duIGFlLWNvbnRhaW5lci1kcm9wZG93bi14c21hbGwgYWUtaGFzLWRyb3Bkb3duXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfVxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e2FjdGl2ZUNvbW1hbmQubGFiZWx9XG5cdFx0XHRcdFx0YXJpYS1vd25zPXtidXR0b25Db21tYW5kc0xpc3RJZH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdFx0cm9sZT1cImNvbWJvYm94XCJcblx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5yb3d9PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyXCI+XG5cdFx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9e2ljb25DbGFzc05hbWV9IC8+XG5cdFx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJjYXJldC1ib3R0b21cIiAvPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0e2J1dHRvbkNvbW1hbmRzTGlzdH1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGxpc3Qgb2YgY29tbWFuZHMuIElmIGEgbGlzdCBvZiBjb21tYW5kcyB3YXMgcGFzc2VkXG5cdCAqIGFzIHByb3BlcnR5IGBjb21tYW5kc2AsIGl0IHdpbGwgdGFrZSBhIHByZWNlZGVuY2Ugb3ZlciB0aGUgZGVmYXVsdCBvbmVzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEFsaWduXG5cdCAqIEBtZXRob2QgX2dldENvbW1hbmRzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIGF2YWlsYWJsZSBjb21tYW5kcy5cblx0ICovXG5cdF9nZXRDb21tYW5kcygpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5wcm9wcy5jb21tYW5kcyB8fCBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAnanVzdGlmeWxlZnQnLFxuXHRcdFx0XHRcdGljb246ICdhbGlnbi1sZWZ0Jyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkxlZnQsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAnanVzdGlmeWNlbnRlcicsXG5cdFx0XHRcdFx0aWNvbjogJ2FsaWduLWNlbnRlcicsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25DZW50ZXIsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAnanVzdGlmeXJpZ2h0Jyxcblx0XHRcdFx0XHRpY29uOiAnYWxpZ24tcmlnaHQnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduUmlnaHQsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAnanVzdGlmeWJsb2NrJyxcblx0XHRcdFx0XHRpY29uOiAnYWxpZ24tanVzdGlmeScsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25KdXN0aWZ5LFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uUGFyYWdyYXBoQWxpZ247XG4iLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25Db21tYW5kQWN0aXZlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQtYWN0aXZlJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25QYXJhZ3JhcGhDZW50ZXIgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY2VudGVyaW5nIGEgcGFyYWdyYXBoLlxuICpcbiAqIEBjbGFzcyBCdXR0b25QYXJhZ3JhcGhDZW50ZXJcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25QYXJhZ3JhcGhDZW50ZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoQ2VudGVyXG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ2p1c3RpZnljZW50ZXInLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgcGFyYWdyYXBoQ2VudGVyXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhDZW50ZXJcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3BhcmFncmFwaENlbnRlcic7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25QYXJhZ3JhcGhDZW50ZXJcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkNlbnRlcn1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tcGFyYWdyYXBoLWNlbnRlclwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5hbGlnbkNlbnRlcn0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImFsaWduLWNlbnRlclwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbkNvbW1hbmRBY3RpdmUoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblBhcmFncmFwaENlbnRlcikpXG4pO1xuIiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZEFjdGl2ZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLWFjdGl2ZSc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBqdXN0ZnlpbmcgYSBwYXJhZ3JhcGguXG4gKlxuICogQGNsYXNzIEJ1dHRvblBhcmFncmFwaEp1c3RpZnlcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRBY3RpdmVcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEp1c3RpZnlcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnanVzdGlmeWJsb2NrJyxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHBhcmFncmFwaEp1c3RpZnlcblx0ICogQG1lbWJlcm9mIEJ1dHRvblBhcmFncmFwaEp1c3RpZnlcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3BhcmFncmFwaEp1c3RpZnknO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUGFyYWdyYXBoSnVzdGlmeVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFsaWduSnVzdGlmeX1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tcGFyYWdyYXBoLWp1c3RpZnlcIlxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWxpZ25KdXN0aWZ5fT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiYWxpZ24tanVzdGlmeVwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoXG5cdEJ1dHRvbkNvbW1hbmRBY3RpdmUoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblBhcmFncmFwaEp1c3RpZnkpKVxuKTtcbiIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25RdW90ZSBjbGFzcyB3cmFwcyBhIHNlbGVjdGlvbiBpbiBgYmxvY2txdW90ZWAgZWxlbWVudC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUXVvdGVcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uUXVvdGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUXVvdGVcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnYmxvY2txdW90ZScsXG5cdFx0c3R5bGU6IHtcblx0XHRcdGVsZW1lbnQ6ICdibG9ja3F1b3RlJyxcblx0XHR9LFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgcXVvdGVcblx0ICogQG1lbWJlcm9mIEJ1dHRvblF1b3RlXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdxdW90ZSc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25RdW90ZVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnF1b3RlfVxuXHRcdFx0XHRhcmlhLXByZXNzZWQ9e2Nzc0NsYXNzLmluZGV4T2YoJ3ByZXNzZWQnKSAhPT0gLTF9XG5cdFx0XHRcdGNsYXNzTmFtZT17Y3NzQ2xhc3N9XG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi1xdW90ZVwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5xdW90ZX0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInF1b3RlLXJpZ2h0XCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQ29tbWFuZChCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3R5bGUoQnV0dG9uUXVvdGUpKSk7XG4iLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblJlbW92ZUZvcm1hdCBjbGFzcyByZW1vdmVzIHN0eWxlIGZvcm1hdHRpbmcuXG4gKlxuICogQGNsYXNzIEJ1dHRvblJlbW92ZUZvcm1hdFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICovXG5jbGFzcyBCdXR0b25SZW1vdmVGb3JtYXQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uUmVtb3ZlRm9ybWF0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ3JlbW92ZUZvcm1hdCcsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCByZW1vdmVGb3JtYXRcblx0ICogQG1lbWJlcm9mIEJ1dHRvblJlbW92ZUZvcm1hdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAncmVtb3ZlRm9ybWF0JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblJlbW92ZUZvcm1hdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnJlbW92ZWZvcm1hdH1cblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXJlbW92ZWZvcm1hdFwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5yZW1vdmVmb3JtYXR9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJyZW1vdmUtc3R5bGVcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKEJ1dHRvblJlbW92ZUZvcm1hdCk7XG4iLCJpbXBvcnQgQnV0dG9uQ29tbWFuZCBmcm9tICcuLi9iYXNlL2J1dHRvbi1jb21tYW5kLmpzJztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcy5qcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25SZW1vdmVJbWFnZSBjbGFzcyByZW1vdmVzIGFuIGltYWdlIHVzaW5nIGEgQ0tFRElUT1IuY29tbWFuZC5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uUmVtb3ZlSW1hZ2VcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqL1xuY2xhc3MgQnV0dG9uUmVtb3ZlSW1hZ2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNvbW1hbmQ6ICdyZW1vdmVJbWFnZScsXG5cdH07XG5cblx0c3RhdGljIGtleSA9ICdyZW1vdmVJbWFnZSc7XG5cblx0LyoqXG5cdCAqIEBpbmhlcml0RG9jXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5yZW1vdmVJbWFnZX1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRvbkNsaWNrPXt0aGlzLmV4ZWNDb21tYW5kfVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5yZW1vdmVJbWFnZX0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInRpbWVzLWNpcmNsZVwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblJlbW92ZUltYWdlKSk7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TZXBhcmF0b3IgZnVuY3Rpb24gcmVuZGVycyBhIHNpbXBsZSBzZXBhcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIEJ1dHRvblNlcGFyYXRvcihfcHJvcHMpIHtcblx0cmV0dXJuIDxzcGFuIGNsYXNzTmFtZT1cImFlLXNlcGFyYXRvclwiIC8+O1xufVxuXG4vKipcbiAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuICpcbiAqIEBkZWZhdWx0IHNlcGFyYXRvclxuICogQG1lbWJlcm9mIEJ1dHRvblNlcGFyYXRvclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5CdXR0b25TZXBhcmF0b3Iua2V5ID0gJ3NlcGFyYXRvcic7XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblNlcGFyYXRvcjtcbiIsImltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblByb3BzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXByb3BzJztcbmltcG9ydCBCdXR0b25TdGF0ZUNsYXNzZXMgZnJvbSAnLi4vYmFzZS9idXR0b24tc3RhdGUtY2xhc3Nlcyc7XG5pbXBvcnQgQnV0dG9uU3R5bGVzTGlzdCBmcm9tICcuL2J1dHRvbi1zdHlsZXMtbGlzdC5qc3gnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TcGFjaW5nIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNoYW5naW5nIHRleHQgY29sb3IgaW4gYSBkb2N1bWVudC5cbiAqXG4gKiBAdXNlcyBCdXR0b25Qcm9wc1xuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKlxuICogQGNsYXNzIEJ1dHRvblNwYWNpbmdcbiAqL1xuY2xhc3MgQnV0dG9uU3BhY2luZyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBrZXkgPSAnc3BhY2luZyc7XG5cblx0c3RhdGljIHByb3BUeXBlcyA9IHtcblx0XHQvKipcblx0XHQgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgc3R5bGVzIGxpc3QgaXMgZXhwYW5kZWQgb3Igbm90LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFNwYWNpbmdcblx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IGV4cGFuZGVkXG5cdFx0ICovXG5cdFx0ZXhwYW5kZWQ6IFByb3BUeXBlcy5ib29sLFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGxhYmVsIHRoYXQgc2hvdWxkIGJlIHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZXMuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU3BhY2luZ1xuXHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBsYWJlbFxuXHRcdCAqL1xuXHRcdGxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG5cdFx0LyoqXG5cdFx0ICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHJlbW92ZSBzdHlsZXMgaXRlbSBzaG91bGQgYXBwZWFyIGluIHRoZSBzdHlsZXMgbGlzdC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBTcGFjaW5nXG5cdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBzaG93UmVtb3ZlU3R5bGVzSXRlbVxuXHRcdCAqL1xuXHRcdHNob3dSZW1vdmVTdHlsZXNJdGVtOiBQcm9wVHlwZXMuYm9vbCxcblxuXHRcdC8qKlxuXHRcdCAqIExpc3Qgb2YgdGhlIHN0eWxlcyB0aGUgYnV0dG9uIGlzIGFibGUgdG8gaGFuZGxlLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFNwYWNpbmdcblx0XHQgKiBAcHJvcGVydHkge0FycmF5fSBzdHlsZXNcblx0XHQgKi9cblx0XHRzdHlsZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vYmplY3QpLFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIHRhYkluZGV4IG9mIHRoZSBidXR0b24gaW4gaXRzIHRvb2xiYXIgY3VycmVudCBzdGF0ZS4gQSB2YWx1ZSBvdGhlciB0aGFuIC0xXG5cdFx0ICogbWVhbnMgdGhhdCB0aGUgYnV0dG9uIGhhcyBmb2N1cyBhbmQgaXMgdGhlIGFjdGl2ZSBlbGVtZW50LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFNwYWNpbmdcblx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gdGFiSW5kZXhcblx0XHQgKi9cblx0XHR0YWJJbmRleDogUHJvcFR5cGVzLm51bWJlcixcblxuXHRcdC8qKlxuXHRcdCAqIENhbGxiYWNrIHByb3ZpZGVkIGJ5IHRoZSBidXR0b24gaG9zdCB0byBub3RpZnkgd2hlbiB0aGUgc3R5bGVzIGxpc3QgaGFzIGJlZW4gZXhwYW5kZWQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU3BhY2luZ1xuXHRcdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHRvZ2dsZURyb3Bkb3duXG5cdFx0ICovXG5cdFx0dG9nZ2xlRHJvcGRvd246IFByb3BUeXBlcy5mdW5jLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGxldCBhY3RpdmVTcGFjaW5nID0gJzEuMHgnO1xuXG5cdFx0Y29uc3Qgc3BhY2luZ3MgPSB0aGlzLl9nZXRTcGFjaW5ncygpO1xuXG5cdFx0c3BhY2luZ3MuZm9yRWFjaChpdGVtID0+IHtcblx0XHRcdGlmICh0aGlzLl9jaGVja0FjdGl2ZShpdGVtLnN0eWxlKSkge1xuXHRcdFx0XHRhY3RpdmVTcGFjaW5nID0gaXRlbS5uYW1lO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Y29uc3Qge2VkaXRvciwgZXhwYW5kZWQsIHRhYkluZGV4LCB0b2dnbGVEcm9wZG93bn0gPSB0aGlzLnByb3BzO1xuXG5cdFx0Y29uc3QgYnV0dG9uU3R5bGVzUHJvcHMgPSB7XG5cdFx0XHRhY3RpdmVTdHlsZTogYWN0aXZlU3BhY2luZyxcblx0XHRcdGVkaXRvcixcblx0XHRcdG9uRGlzbWlzczogdG9nZ2xlRHJvcGRvd24sXG5cdFx0XHRzaG93UmVtb3ZlU3R5bGVzSXRlbTogZmFsc2UsXG5cdFx0XHRzdHlsZXM6IHNwYWNpbmdzLFxuXHRcdH07XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXIgYWUtY29udGFpbmVyLWRyb3Bkb3duLXNtYWxsIGFlLWhhcy1kcm9wZG93blwiPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1leHBhbmRlZD17ZXhwYW5kZWR9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtdG9vbGJhci1lbGVtZW50XCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0XHRyb2xlPVwiY29tYm9ib3hcIlxuXHRcdFx0XHRcdHRhYkluZGV4PXt0YWJJbmRleH0+XG5cdFx0XHRcdFx0PHNwYW4+XG5cdFx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJzZXBhcmF0b3JcIiAvPlxuXHRcdFx0XHRcdFx0Jm5ic3A7XG5cdFx0XHRcdFx0XHR7YWN0aXZlU3BhY2luZ31cblx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHR7ZXhwYW5kZWQgJiYgPEJ1dHRvblN0eWxlc0xpc3Qgey4uLmJ1dHRvblN0eWxlc1Byb3BzfSAvPn1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHRfYXBwbHlTdHlsZShjbGFzc05hbWUpIHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRjb25zdCBzdHlsZUNvbmZpZyA9IHtcblx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRjbGFzczogY2xhc3NOYW1lLFxuXHRcdFx0fSxcblx0XHR9O1xuXG5cdFx0Y29uc3Qgc3R5bGUgPSBuZXcgQ0tFRElUT1Iuc3R5bGUoc3R5bGVDb25maWcpO1xuXG5cdFx0ZWRpdG9yLmdldFNlbGVjdGlvbigpLmxvY2soKTtcblxuXHRcdHRoaXMuX2dldFNwYWNpbmdzKCkuZm9yRWFjaChpdGVtID0+IHtcblx0XHRcdGlmICh0aGlzLl9jaGVja0FjdGl2ZShpdGVtLnN0eWxlKSkge1xuXHRcdFx0XHRlZGl0b3IucmVtb3ZlU3R5bGUobmV3IENLRURJVE9SLnN0eWxlKGl0ZW0uc3R5bGUpKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGVkaXRvci5hcHBseVN0eWxlKHN0eWxlKTtcblxuXHRcdGVkaXRvci5nZXRTZWxlY3Rpb24oKS51bmxvY2soKTtcblxuXHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHNwYWNpbmcgZGVmaW5pdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpbiB0aGUgZWRpdG9yLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFNwYWNpbmdcblx0ICogQG1ldGhvZCBfY2hlY2tBY3RpdmVcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0eWxlQ29uZmlnIFNwYWNpbmcgZGVmaW5pdGlvbiBhcyBwZXIgaHR0cDovL2RvY3MuY2tlZGl0b3IuY29tLyMhL2FwaS9DS0VESVRPUi5zdHlsZS5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHNwYWNpbmcgaXMgYXBwbGllZCB0byB0aGUgc2VsZWN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuXHRfY2hlY2tBY3RpdmUoc3R5bGVDb25maWcpIHtcblx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRsZXQgYWN0aXZlID0gdHJ1ZTtcblxuXHRcdGNvbnN0IGVsZW1lbnRQYXRoID0gbmF0aXZlRWRpdG9yLmVsZW1lbnRQYXRoKCk7XG5cblx0XHRpZiAoZWxlbWVudFBhdGggJiYgZWxlbWVudFBhdGgubGFzdEVsZW1lbnQpIHtcblx0XHRcdHN0eWxlQ29uZmlnLmF0dHJpYnV0ZXMuY2xhc3Ncblx0XHRcdFx0LnNwbGl0KCcgJylcblx0XHRcdFx0LmZvckVhY2goZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG5cdFx0XHRcdFx0YWN0aXZlID1cblx0XHRcdFx0XHRcdGFjdGl2ZSAmJiBlbGVtZW50UGF0aC5sYXN0RWxlbWVudC5oYXNDbGFzcyhjbGFzc05hbWUpO1xuXHRcdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YWN0aXZlID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFjdGl2ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHNwYWNpbmdzLiBFYWNoIHNwYWNpbmcgY29uc2lzdHMgZnJvbSB0aHJlZSBwcm9wZXJ0aWVzOlxuXHQgKiAtIG5hbWUgLSB0aGUgc3R5bGUgbmFtZSwgZm9yIGV4YW1wbGUgXCJkZWZhdWx0XCJcblx0ICogLSBzdHlsZSAtIGFuIG9iamVjdCB3aXRoIG9uZSBwcm9wZXJ0eSwgY2FsbGVkIGBlbGVtZW50YCB3aGljaCB2YWx1ZVxuXHQgKiByZXByZXNlbnRzIHRoZSBzdHlsZSB3aGljaCBoYXZlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQuXG5cdCAqIC0gc3R5bGVGbiAtIGEgZnVuY3Rpb24gd2hpY2ggYXBwbGllcyBzZWxlY3RlZCBzdHlsZSB0byB0aGUgZWRpdG9yIHNlbGVjdGlvblxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFNwYWNpbmdcblx0ICogQG1ldGhvZCBfZ2V0U3BhY2luZ3Ncblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBcnJheTxvYmplY3Q+fSBBbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHNwYWNpbmdzLlxuXHQgKi9cblx0X2dldFNwYWNpbmdzKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLnN0eWxlcyB8fCBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnMS4weCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnMS41eCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ210LTEgbWItMScsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnbXQtMSBtYi0xJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnMi4weCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ210LTIgbWItMicsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnbXQtMiBtYi0yJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnMy4weCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ210LTMgbWItMycsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnbXQtMyBtYi0zJyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnNC4weCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ210LTQgbWItNCcsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnbXQtNCBtYi00JyksXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiAnNS4weCcsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdkaXYnLFxuXHRcdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0XHRjbGFzczogJ210LTUgbWItNScsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0dHlwZTogMSxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHN0eWxlRm46IHRoaXMuX2FwcGx5U3R5bGUuYmluZCh0aGlzLCAnbXQtNSBtYi01JyksXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Qcm9wcyhCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3BhY2luZykpO1xuIiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblN0cmlrZSBjbGFzcyBzdHlsZXMgYSBzZWxlY3Rpb24gd2l0aCBzdHJpa2Ugc3R5bGUuXG4gKlxuICogQGNsYXNzIEJ1dHRvblN0cmlrZVxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25TdHJpa2UgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3RyaWtlXG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ3N0cmlrZScsXG5cdFx0c3R5bGU6ICdjb3JlU3R5bGVzX3N0cmlrZScsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBzdHJpa2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0cmlrZVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnc3RyaWtlJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0cmlrZVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnN0cmlrZX1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tc3RyaWtlXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnN0cmlrZX0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInN0cmlrZXRocm91Z2hcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKEJ1dHRvblN0YXRlQ2xhc3NlcyhCdXR0b25TdHlsZShCdXR0b25TdHJpa2UpKSk7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25zU3R5bGVzTGlzdEhlYWRlciBjbGFzcyBwcm92aWRlcyB0aGUgaGVhZGVyIG9mIGFuIGxpc3Qgb2Ygc3R5bGUgaXRlbXMuXG4gKlxuICogQGNsYXNzIEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyXG4gKi9cbmNsYXNzIEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGtleSA9ICdidXR0b25TdHlsZXNMaXN0SGVhZGVyJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICh0aGlzLnByb3BzLnN0eWxlcyAmJiB0aGlzLnByb3BzLnN0eWxlcy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiA8c3BhbiBjbGFzc05hbWU9XCJhZS1saXN0LWhlYWRlclwiPnt0aGlzLnByb3BzLm5hbWV9PC9zcGFuPjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBwcmV2aWV3aW5nIGEgc3R5bGUgZGVmaW5pdGlvblxuICogaW5zaWRlIGEgbGlzdCBhbmQgYXBwbHlpbmcgaXQgdG8gdGhlIGN1cnJlbnQgZWRpdG9yIHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmVcbiAqL1xuY2xhc3MgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZVxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdHJlbW92ZUJsb2NrczogWydoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdwcmUnXSxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IGJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnYnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmVcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxsaSByb2xlPVwib3B0aW9uXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX3JlbW92ZVN0eWxlc31cblx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH0+XG5cdFx0XHRcdFx0e0FsbG95RWRpdG9yLlN0cmluZ3Mubm9ybWFsfVxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdDwvbGk+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBpbmxpbmUgc3R5bGVzIGFuZCBjb25maWd1cmVkIGJsb2NrIGVsZW1lbnRzIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtUmVtb3ZlXG5cdCAqIEBtZXRob2QgX3JlbW92ZVN0eWxlc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfcmVtb3ZlU3R5bGVzID0gKCkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGVkaXRvci5leGVjQ29tbWFuZCgncmVtb3ZlRm9ybWF0Jyk7XG5cblx0XHR0aGlzLnByb3BzLnJlbW92ZUJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uKGJsb2NrSXRlbSkge1xuXHRcdFx0Y29uc3QgYmxvY2tTdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZSh7ZWxlbWVudDogYmxvY2tJdGVtfSk7XG5cblx0XHRcdGVkaXRvci5yZW1vdmVTdHlsZShibG9ja1N0eWxlKTtcblx0XHR9KTtcblxuXHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmU7XG4iLCJpbXBvcnQgQnV0dG9uQWN0aW9uU3R5bGUgZnJvbSAnLi4vYmFzZS9idXR0b24tYWN0aW9uLXN0eWxlJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblN0eWxlc0xpc3RJdGVtIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIHByZXZpZXdpbmcgYSBzdHlsZSBkZWZpbml0aW9uXG4gKiBpbnNpZGUgYSBsaXN0IGFuZCBhcHBseWluZyBpdCB0byB0aGUgY3VycmVudCBlZGl0b3Igc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdHlsZXNMaXN0SXRlbVxuICogQHVzZXMgQnV0dG9uQWN0aW9uU3R5bGVcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblN0eWxlc0xpc3RJdGVtIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IGJ1dHRvblN0eWxlc0xpc3RJdGVtXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnYnV0dG9uU3R5bGVzTGlzdEl0ZW0nO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgYm90aCBvbiB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIsIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtXG5cdCAqIEBtZXRob2QgY29tcG9uZW50V2lsbE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnRXaWxsTW91bnQoKSB7XG5cdFx0Ly8gU3R5bGVzIHdpdGggd2lsZGNhcmQgZWxlbWVudCAoKikgZ2VuZXJhdGUgYW4gZW1wdHkgdGFnIGluIHRoZWlyIHByZXZpZXcgPCBjbGFzcz1cImN1c3RvbS1jbGFzc1wiIC8+LlxuXHRcdC8vIFdlIGRlZmF1bHQgdG8gZWxlbWVudCBzcGFuIGFuZCByZW1vdmUgdGhlIG1hcmdpbnMgdG8gb2J0YWluIGEgbW9yZSBjb25zaXN0ZW50IHNldCBvZiBwcmV2aWV3cy5cblx0XHRsZXQgc3R5bGVDZmcgPSB7XG5cdFx0XHRlbGVtZW50OiAnc3BhbicsXG5cdFx0XHRzdHlsZXM6IHtcblx0XHRcdFx0bWFyZ2luOiAwLFxuXHRcdFx0fSxcblx0XHR9O1xuXG5cdFx0c3R5bGVDZmcgPSBDS0VESVRPUi50b29scy5tZXJnZShzdHlsZUNmZywgdGhpcy5wcm9wcy5zdHlsZSk7XG5cblx0XHR0aGlzLl9wcmV2aWV3ID0gbmV3IENLRURJVE9SLnN0eWxlKHN0eWxlQ2ZnKS5idWlsZFByZXZpZXcoXG5cdFx0XHR0aGlzLnByb3BzLm5hbWVcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHQvLyBXZSBuZWVkIHRvIHVzZSBkYW5nZXJvdXNlbHlTZXRJbm50ZXJIVE1MIHNpbmNlIHdlJ3JlIG5vdCBpbiBjb250cm9sIG9mIHRoZSBzdHlsZVxuXHRcdC8vIHByZXZpZXcgdGhhdCBpcyBnZW5lcmF0ZWQgYnkgQ0tFZGl0b3IuXG5cdFx0Y29uc3QgY2xhc3NOYW1lID1cblx0XHRcdHRoaXMucHJvcHMubmFtZSA9PT0gdGhpcy5wcm9wcy5hY3RpdmVTdHlsZVxuXHRcdFx0XHQ/ICdhZS10b29sYmFyLWVsZW1lbnQgYWN0aXZlJ1xuXHRcdFx0XHQ6ICdhZS10b29sYmFyLWVsZW1lbnQnO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc05hbWV9XG5cdFx0XHRcdGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7X19odG1sOiB0aGlzLl9wcmV2aWV3fX1cblx0XHRcdFx0b25DbGljaz17dGhpcy5fb25DbGlja31cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHQvPlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogQXBwbGllcyB0aGUgaXRlbSBzdHlsZSB0byB0aGUgZWRpdG9yIHNlbGVjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0SXRlbVxuXHQgKiBAbWV0aG9kIF9vbkNsaWNrXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF9vbkNsaWNrID0gKCkgPT4ge1xuXHRcdGlmICh0aGlzLnByb3BzLnN0eWxlRm4pIHtcblx0XHRcdHRoaXMucHJvcHMuc3R5bGVGbigpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUeXBpY2FsbHksIHdlIHdhbnQgdGhlIHN0eWxlIHRvIGJlIHRoZSBvbmx5IG9uZSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiwgc29cblx0XHRcdC8vIHdlIGV4ZWN1dGUgdGhlICdyZW1vdmVGb3JtYXQnIGNvbW1hbmQgZmlyc3QuIE5vdGUgdGhhdCBibG9jayBzdHlsZXMgd29uJ3QgYmUgY2xlYW5lZC5cblx0XHRcdC8vIEhvd2V2ZXIsIHRoaXMgaXMgY29uc2lzdGVudCB3aXRoIG90aGVyIGVkaXRvcnMgaW1wbGVtZW50YXRpb25zIG9mIHRoaXMgZmVhdHVyZS5cblx0XHRcdHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKS5leGVjQ29tbWFuZCgncmVtb3ZlRm9ybWF0Jyk7XG5cblx0XHRcdHRoaXMuYXBwbHlTdHlsZSgpO1xuXHRcdH1cblx0fTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uQWN0aW9uU3R5bGUoQnV0dG9uU3R5bGUoQnV0dG9uU3R5bGVzTGlzdEl0ZW0pKTtcbiIsImltcG9ydCBCdXR0b25Ecm9wZG93biBmcm9tICcuL2J1dHRvbi1kcm9wZG93bi5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3RJdGVtIGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0uanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZSBmcm9tICcuL2J1dHRvbi1zdHlsZXMtbGlzdC1pdGVtLXJlbW92ZS5qc3gnO1xuaW1wb3J0IEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyIGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LWhlYWRlci5qc3gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyJztcblxuLyoqXG4gKiBUaGUgQnV0dG9uU3R5bGVzTGlzdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBzaG93aW5nIGEgbGlzdCBvZiBzdHlsZXMgdGhhdCBjYW4gYmVcbiAqIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3R5bGVzTGlzdFxuICogQHVzZXMgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gKi9cbmNsYXNzIEJ1dHRvblN0eWxlc0xpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdFxuXHQgKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBkZWZhdWx0IHByb3BlcnRpZXMuXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdGNpcmN1bGFyOiBmYWxzZSxcblx0XHRkZXNjZW5kYW50czogJy5hZS10b29sYmFyLWVsZW1lbnQnLFxuXHRcdGtleXM6IHtcblx0XHRcdGRpc21pc3M6IFsyN10sXG5cdFx0XHRkaXNtaXNzTmV4dDogWzM5XSxcblx0XHRcdGRpc21pc3NQcmV2OiBbMzddLFxuXHRcdFx0bmV4dDogWzQwXSxcblx0XHRcdHByZXY6IFszOF0sXG5cdFx0fSxcblx0XHRzaG93UmVtb3ZlU3R5bGVzSXRlbTogdHJ1ZSxcblx0fTtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG5cdCAqIEBzdGF0aWNcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAZGVmYXVsdCBidXR0b25TdHlsZXNMaXN0XG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ2J1dHRvblN0eWxlc0xpc3QnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50LCBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuXHQgKlxuXHQgKiBGb2N1c2VzIG9uIHRoZSBsaXN0IG5vZGUgdG8gYWxsb3cga2V5Ym9hcmQgaW50ZXJhY3Rpb24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdFxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5mb2N1cygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBib3RoIG9uIHRoZSBjbGllbnQgYW5kIHNlcnZlciwgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzTGlzdFxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudFdpbGxNb3VudFxuXHQgKi9cblx0Y29tcG9uZW50V2lsbE1vdW50KCkge1xuXHRcdGNvbnN0IGJsb2NrU3R5bGVzID0gW107XG5cdFx0Y29uc3QgaW5saW5lU3R5bGVzID0gW107XG5cdFx0Y29uc3Qgb2JqZWN0U3R5bGVzID0gW107XG5cblx0XHR0aGlzLnByb3BzLnN0eWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdGNvbnN0IHN0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKGl0ZW0uc3R5bGUpO1xuXG5cdFx0XHRpZiAoc3R5bGUudHlwZSA9PT0gQ0tFRElUT1IuU1RZTEVfQkxPQ0spIHtcblx0XHRcdFx0YmxvY2tTdHlsZXMucHVzaChpdGVtKTtcblx0XHRcdH0gZWxzZSBpZiAoc3R5bGUudHlwZSA9PT0gQ0tFRElUT1IuU1RZTEVfSU5MSU5FKSB7XG5cdFx0XHRcdGlubGluZVN0eWxlcy5wdXNoKGl0ZW0pO1xuXHRcdFx0fSBlbHNlIGlmIChzdHlsZS50eXBlID09PSBDS0VESVRPUi5TVFlMRV9PQkpFQ1QpIHtcblx0XHRcdFx0b2JqZWN0U3R5bGVzLnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9ibG9ja1N0eWxlcyA9IGJsb2NrU3R5bGVzO1xuXHRcdHRoaXMuX2lubGluZVN0eWxlcyA9IGlubGluZVN0eWxlcztcblx0XHR0aGlzLl9vYmplY3RTdHlsZXMgPSBvYmplY3RTdHlsZXM7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgbGlzdC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNMaXN0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGxldCByZW1vdmVTdHlsZXNJdGVtO1xuXG5cdFx0aWYgKHRoaXMucHJvcHMuc2hvd1JlbW92ZVN0eWxlc0l0ZW0pIHtcblx0XHRcdHJlbW92ZVN0eWxlc0l0ZW0gPSAoXG5cdFx0XHRcdDxCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZVxuXHRcdFx0XHRcdG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0Lz5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxCdXR0b25Ecm9wZG93biB7Li4udGhpcy5wcm9wc30+XG5cdFx0XHRcdHtyZW1vdmVTdHlsZXNJdGVtfVxuXG5cdFx0XHRcdDxCdXR0b25zU3R5bGVzTGlzdEhlYWRlclxuXHRcdFx0XHRcdG5hbWU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYmxvY2tTdHlsZXN9XG5cdFx0XHRcdFx0c3R5bGVzPXt0aGlzLl9ibG9ja1N0eWxlc31cblx0XHRcdFx0Lz5cblx0XHRcdFx0e3RoaXMuX3JlbmRlclN0eWxlc0l0ZW1zKHRoaXMuX2Jsb2NrU3R5bGVzKX1cblxuXHRcdFx0XHQ8QnV0dG9uc1N0eWxlc0xpc3RIZWFkZXJcblx0XHRcdFx0XHRuYW1lPXtBbGxveUVkaXRvci5TdHJpbmdzLmlubGluZVN0eWxlc31cblx0XHRcdFx0XHRzdHlsZXM9e3RoaXMuX2lubGluZVN0eWxlc31cblx0XHRcdFx0Lz5cblx0XHRcdFx0e3RoaXMuX3JlbmRlclN0eWxlc0l0ZW1zKHRoaXMuX2lubGluZVN0eWxlcyl9XG5cblx0XHRcdFx0PEJ1dHRvbnNTdHlsZXNMaXN0SGVhZGVyXG5cdFx0XHRcdFx0bmFtZT17QWxsb3lFZGl0b3IuU3RyaW5ncy5vYmplY3RTdHlsZXN9XG5cdFx0XHRcdFx0c3R5bGVzPXt0aGlzLl9vYmplY3RTdHlsZXN9XG5cdFx0XHRcdC8+XG5cdFx0XHRcdHt0aGlzLl9yZW5kZXJTdHlsZXNJdGVtcyh0aGlzLl9vYmplY3RTdHlsZXMpfVxuXHRcdFx0PC9CdXR0b25Ecm9wZG93bj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbmRlcnMgaW5zdGFuY2VzIG9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtIHdpdGggdGhlIHByZXZpZXcgb2YgdGhlIGNvcnJlc3BvbmRlbnQgYmxvY2ssIGlubGluZSBvciBvYmplY3Qgc3R5bGVzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN0eWxlc0xpc3Rcblx0ICogQG1ldGhvZCBfcmVuZGVyU3R5bGVzSXRlbXNcblx0ICogQHBhcmFtIHtBcnJheX0gc3R5bGVzIExpc3Qgb2Ygc3R5bGVzIGZvciB3aGljaCBwcmV2aWV3IHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBcnJheX0gUmVuZGVyZWQgaW5zdGFuY2VzIG9mIEJ1dHRvblN0eWxlc0xpc3RJdGVtIGNsYXNzXG5cdCAqL1xuXHRfcmVuZGVyU3R5bGVzSXRlbXMoc3R5bGVzKSB7XG5cdFx0bGV0IGl0ZW1zO1xuXG5cdFx0aWYgKHN0eWxlcyAmJiBzdHlsZXMubGVuZ3RoKSB7XG5cdFx0XHRpdGVtcyA9IHN0eWxlcy5tYXAoaXRlbSA9PiB7XG5cdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0PGxpIGtleT17aXRlbS5uYW1lfSByb2xlPVwib3B0aW9uXCI+XG5cdFx0XHRcdFx0XHQ8QnV0dG9uU3R5bGVzTGlzdEl0ZW1cblx0XHRcdFx0XHRcdFx0YWN0aXZlU3R5bGU9e3RoaXMucHJvcHMuYWN0aXZlU3R5bGV9XG5cdFx0XHRcdFx0XHRcdG5hbWU9e2l0ZW0ubmFtZX1cblx0XHRcdFx0XHRcdFx0c3R5bGU9e2l0ZW0uc3R5bGV9XG5cdFx0XHRcdFx0XHRcdHN0eWxlRm49e2l0ZW0uc3R5bGVGbn1cblx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0PC9saT5cblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBpdGVtcztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRGb2N1c01hbmFnZXIoQnV0dG9uU3R5bGVzTGlzdCk7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3QgZnJvbSAnLi9idXR0b24tc3R5bGVzLWxpc3QuanN4JztcbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdHlsZXMgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3Igc3R5bGluZyBhIHNlbGVjdGlvbiB3aXRoIGEgbGlzdCBvZlxuICogY29uZmlndXJhYmxlIGFuZCBjdXN0b21pemFibGUgc3R5bGVzLiBUaGUgYWxsb3dlZCBzdHlsZXMgZm9sbG93IENLRURJVE9SLlN0eWxlIGNvbmZpZ3VyYXRpb25cbiAqIChodHRwOi8vZG9jcy5ja2VkaXRvci5jb20vIyEvYXBpL0NLRURJVE9SLnN0eWxlKVxuICpcbiAqIEBjbGFzcyBCdXR0b25TdHlsZXNcbiAqL1xuY2xhc3MgQnV0dG9uU3R5bGVzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHN0eWxlc1xuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICdzdHlsZXMnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3R5bGVzXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGxldCBhY3RpdmVTdHlsZSA9IEFsbG95RWRpdG9yLlN0cmluZ3Mubm9ybWFsO1xuXG5cdFx0Y29uc3Qgc3R5bGVzID0gdGhpcy5fZ2V0U3R5bGVzKCk7XG5cblx0XHRzdHlsZXMuZm9yRWFjaChpdGVtID0+IHtcblx0XHRcdGlmICh0aGlzLl9jaGVja0FjdGl2ZShpdGVtLnN0eWxlKSkge1xuXHRcdFx0XHRhY3RpdmVTdHlsZSA9IGl0ZW0ubmFtZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGxldCBidXR0b25TdHlsZXNMaXN0O1xuXG5cdFx0aWYgKHRoaXMucHJvcHMuZXhwYW5kZWQpIHtcblx0XHRcdGJ1dHRvblN0eWxlc0xpc3QgPSAoXG5cdFx0XHRcdDxCdXR0b25TdHlsZXNMaXN0XG5cdFx0XHRcdFx0YWN0aXZlU3R5bGU9e2FjdGl2ZVN0eWxlfVxuXHRcdFx0XHRcdG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0XHRzaG93UmVtb3ZlU3R5bGVzSXRlbT17dGhpcy5wcm9wcy5zaG93UmVtb3ZlU3R5bGVzSXRlbX1cblx0XHRcdFx0XHRzdHlsZXM9e3N0eWxlc31cblx0XHRcdFx0Lz5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWRyb3Bkb3duIGFlLWhhcy1kcm9wZG93blwiPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1leHBhbmRlZD17dGhpcy5wcm9wcy5leHBhbmRlZH1cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnN0eWxlcyArICcgJyArIGFjdGl2ZVN0eWxlfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLXRvb2xiYXItZWxlbWVudFwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0XHRyb2xlPVwiY29tYm9ib3hcIlxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnN0eWxlcyArICcgJyArIGFjdGl2ZVN0eWxlfT5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lclwiPlxuXHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWRyb3Bkb3duLXNlbGVjdGVkLWl0ZW1cIj5cblx0XHRcdFx0XHRcdFx0e2FjdGl2ZVN0eWxlfVxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiY2FyZXQtYm90dG9tXCIgLz5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdHtidXR0b25TdHlsZXNMaXN0fVxuXHRcdFx0PC9kaXY+XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0eWxlIGRlZmluaXRpb24gaXMgYXBwbGllZCB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gaW4gdGhlIGVkaXRvci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNcblx0ICogQG1ldGhvZCBfY2hlY2tBY3RpdmVcblx0ICogQHBhcmFtIHtPYmplY3R9IHN0eWxlQ29uZmlnIFN0eWxlIGRlZmluaXRpb24gYXMgcGVyIGh0dHA6Ly9kb2NzLmNrZWRpdG9yLmNvbS8jIS9hcGkvQ0tFRElUT1Iuc3R5bGUuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBzdHlsZSBpcyBhcHBsaWVkIHRvIHRoZSBzZWxlY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG5cdF9jaGVja0FjdGl2ZShzdHlsZUNvbmZpZykge1xuXHRcdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdC8vIFN0eWxlcyB3aXRoIHdpbGRjYXJkIGVsZW1lbnQgKCopIHdvbid0IGJlIGNvbnNpZGVyZWQgYWN0aXZlIGJ5IENLRWRpdG9yLiBEZWZhdWx0aW5nXG5cdFx0Ly8gdG8gYSAnc3BhbicgZWxlbWVudCB3b3JrcyBmb3IgbW9zdCBvZiB0aG9zZSBjYXNlcyB3aXRoIG5vIGRlZmluZWQgZWxlbWVudC5cblx0XHRzdHlsZUNvbmZpZyA9IENLRURJVE9SLnRvb2xzLm1lcmdlKHtlbGVtZW50OiAnc3Bhbid9LCBzdHlsZUNvbmZpZyk7XG5cblx0XHRjb25zdCBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZShzdHlsZUNvbmZpZyk7XG5cblx0XHRyZXR1cm4gc3R5bGUuY2hlY2tBY3RpdmUobmF0aXZlRWRpdG9yLmVsZW1lbnRQYXRoKCksIG5hdGl2ZUVkaXRvcik7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBhcnJheSBvZiBzdHlsZXMuIEVhY2ggc3R5bGUgY29uc2lzdHMgZnJvbSB0d28gcHJvcGVydGllczpcblx0ICogLSBuYW1lIC0gdGhlIHN0eWxlIG5hbWUsIGZvciBleGFtcGxlIFwiaDFcIlxuXHQgKiAtIHN0eWxlIC0gYW4gb2JqZWN0IHdpdGggb25lIHByb3BlcnR5LCBjYWxsZWQgYGVsZW1lbnRgIHdoaWNoIHZhbHVlXG5cdCAqIHJlcHJlc2VudHMgdGhlIHN0eWxlIHdoaWNoIGhhdmUgdG8gYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25TdHlsZXNcblx0ICogQG1ldGhvZCBfZ2V0U3R5bGVzXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7QXJyYXk8b2JqZWN0Pn0gQW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBzdHlsZXMuXG5cdCAqL1xuXHRfZ2V0U3R5bGVzKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLnN0eWxlcyB8fCBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmgxLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnaDEnLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmgyLFxuXHRcdFx0XHRcdHN0eWxlOiB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiAnaDInLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmZvcm1hdHRlZCxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ3ByZScsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG5hbWU6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2l0ZSxcblx0XHRcdFx0XHRzdHlsZToge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogJ2NpdGUnLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBBbGxveUVkaXRvci5TdHJpbmdzLmNvZGUsXG5cdFx0XHRcdFx0c3R5bGU6IHtcblx0XHRcdFx0XHRcdGVsZW1lbnQ6ICdjb2RlJyxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uU3R5bGVzO1xuIiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblN1YnNjcmlwdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhcHBseWluZyBzdWJzY3JpcHQgc3R5bGUgdG8gYSB0ZXh0IHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uU3Vic2NyaXB0XG4gKlxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25TdWJzY3JpcHQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3Vic2NyaXB0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y29tbWFuZDogJ3N1YnNjcmlwdCcsXG5cdFx0c3R5bGU6ICdjb3JlU3R5bGVzX3N1YnNjcmlwdCcsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBzdWJzY3JpcHRcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN1YnNjcmlwdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAnc3Vic2NyaXB0JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN1YnNjcmlwdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnN1YnNjcmlwdH1cblx0XHRcdFx0YXJpYS1wcmVzc2VkPXtjc3NDbGFzcy5pbmRleE9mKCdwcmVzc2VkJykgIT09IC0xfVxuXHRcdFx0XHRjbGFzc05hbWU9e2Nzc0NsYXNzfVxuXHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tc3Vic2NyaXB0XCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnN1YnNjcmlwdH0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInN1YnNjcmlwdFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvbkNvbW1hbmQoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblN0eWxlKEJ1dHRvblN1YnNjcmlwdCkpKTtcbiIsImltcG9ydCBCdXR0b25Db21tYW5kIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWNvbW1hbmQnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0YXRlQ2xhc3NlcyBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdGF0ZS1jbGFzc2VzJztcbmltcG9ydCBCdXR0b25TdHlsZSBmcm9tICcuLi9iYXNlL2J1dHRvbi1zdHlsZSc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25TdXBlcnNjcmlwdCBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBhcHBseWluZyBzdXBlcnNjcmlwdCBzdHlsZSB0byBhIHRleHQgc2VsZWN0aW9uLlxuICpcbiAqIEBjbGFzcyBCdXR0b25TdXBlcnNjcmlwdFxuICpcbiAqIEB1c2VzIEJ1dHRvbkNvbW1hbmRcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICogQHVzZXMgQnV0dG9uU3R5bGVcbiAqL1xuY2xhc3MgQnV0dG9uU3VwZXJzY3JpcHQgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3VwZXJzY3JpcHRcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnc3VwZXJzY3JpcHQnLFxuXHRcdHN0eWxlOiAnY29yZVN0eWxlc19zdXBlcnNjcmlwdCcsXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBzdXBlcnNjcmlwdFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uU3VwZXJzY3JpcHRcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3N1cGVyc2NyaXB0JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblN1cGVyc2NyaXB0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGNzc0NsYXNzID0gYGFlLWJ1dHRvbiAke3RoaXMuZ2V0U3RhdGVDbGFzc2VzKCl9YDtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Muc3VwZXJzY3JpcHR9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXN1cGVyc2NyaXB0XCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnN1cGVyc2NyaXB0fT5cblx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwic3VwZXJzY3JpcHRcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuXHRCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3R5bGUoQnV0dG9uU3VwZXJzY3JpcHQpKVxuKTtcbiIsImltcG9ydCBCdXR0b25Db21tYW5kc0xpc3QgZnJvbSAnLi9idXR0b24tY29tbWFuZHMtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGVDZWxsIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gd29yayB3aXRoIHRhYmxlIGNlbGxzLlxuICpcbiAqIEBjbGFzcyBCdXR0b25UYWJsZUNlbGxcbiAqL1xuY2xhc3MgQnV0dG9uVGFibGVDZWxsIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCB0YWJsZUNlbGxcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlQ2VsbFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndGFibGVDZWxsJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlQ2VsbFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRsZXQgYnV0dG9uQ29tbWFuZHNMaXN0O1xuXHRcdGxldCBidXR0b25Db21tYW5kc0xpc3RJZDtcblxuXHRcdGlmICh0aGlzLnByb3BzLmV4cGFuZGVkKSB7XG5cdFx0XHRidXR0b25Db21tYW5kc0xpc3RJZCA9IEJ1dHRvblRhYmxlQ2VsbC5rZXkgKyAnTGlzdCc7XG5cdFx0XHRidXR0b25Db21tYW5kc0xpc3QgPSAoXG5cdFx0XHRcdDxCdXR0b25Db21tYW5kc0xpc3Rcblx0XHRcdFx0XHRjb21tYW5kcz17dGhpcy5fZ2V0Q29tbWFuZHMoKX1cblx0XHRcdFx0XHRsaXN0SWQ9e2J1dHRvbkNvbW1hbmRzTGlzdElkfVxuXHRcdFx0XHRcdG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0Lz5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyIGFlLWhhcy1kcm9wZG93blwiPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1leHBhbmRlZD17dGhpcy5wcm9wcy5leHBhbmRlZH1cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNlbGx9XG5cdFx0XHRcdFx0YXJpYS1vd25zPXtidXR0b25Db21tYW5kc0xpc3RJZH1cblx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1idXR0b25cIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY2VsbH0+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiYWRkLWNlbGxcIiAvPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0e2J1dHRvbkNvbW1hbmRzTGlzdH1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGxpc3Qgb2YgY29tbWFuZHMuIElmIGEgbGlzdCBvZiBjb21tYW5kcyB3YXMgcGFzc2VkXG5cdCAqIGFzIHByb3BlcnR5IGBjb21tYW5kc2AsIGl0IHdpbGwgdGFrZSBhIHByZWNlZGVuY2Ugb3ZlciB0aGUgZGVmYXVsdCBvbmVzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlQ2VsbFxuXHQgKiBAbWV0aG9kIF9nZXRDb21tYW5kc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBhdmFpbGFibGUgY29tbWFuZHMuXG5cdCAqL1xuXHRfZ2V0Q29tbWFuZHMoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMucHJvcHMuY29tbWFuZHMgfHwgW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ2NlbGxJbnNlcnRCZWZvcmUnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxJbnNlcnRCZWZvcmUsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAnY2VsbEluc2VydEFmdGVyJyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsSW5zZXJ0QWZ0ZXIsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAnY2VsbERlbGV0ZScsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY2VsbERlbGV0ZSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdjZWxsTWVyZ2UnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNlbGxNZXJnZSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdjZWxsTWVyZ2VEb3duJyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsTWVyZ2VEb3duLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ2NlbGxNZXJnZVJpZ2h0Jyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsTWVyZ2VSaWdodCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdjZWxsSG9yaXpvbnRhbFNwbGl0Jyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsU3BsaXRIb3Jpem9udGFsLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ2NlbGxWZXJ0aWNhbFNwbGl0Jyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jZWxsU3BsaXRWZXJ0aWNhbCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlQ2VsbDtcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQnV0dG9uQ29tbWFuZHNMaXN0IGZyb20gJy4vYnV0dG9uLWNvbW1hbmRzLWxpc3QuanN4JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGVDb2x1bW4gY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSB0byB3b3JrIHdpdGggdGFibGUgY29sdW1ucy5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVGFibGVDb2x1bW5cbiAqL1xuY2xhc3MgQnV0dG9uVGFibGVDb2x1bW4gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHRhYmxlQ29sdW1uXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUNvbHVtblxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndGFibGVDb2x1bW4nO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVDb2x1bW5cblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IGJ1dHRvbkNvbW1hbmRzTGlzdDtcblx0XHRsZXQgYnV0dG9uQ29tbWFuZHNMaXN0SWQ7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuXHRcdFx0YnV0dG9uQ29tbWFuZHNMaXN0SWQgPSBCdXR0b25UYWJsZUNvbHVtbi5rZXkgKyAnTGlzdCc7XG5cdFx0XHRidXR0b25Db21tYW5kc0xpc3QgPSAoXG5cdFx0XHRcdDxCdXR0b25Db21tYW5kc0xpc3Rcblx0XHRcdFx0XHRjb21tYW5kcz17dGhpcy5fZ2V0Q29tbWFuZHMoKX1cblx0XHRcdFx0XHRsaXN0SWQ9e2J1dHRvbkNvbW1hbmRzTGlzdElkfVxuXHRcdFx0XHRcdG9uRGlzbWlzcz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0Lz5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyIGFlLWhhcy1kcm9wZG93blwiPlxuXHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0YXJpYS1leHBhbmRlZD17dGhpcy5wcm9wcy5leHBhbmRlZH1cblx0XHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmNvbHVtbn1cblx0XHRcdFx0XHRhcmlhLW93bnM9e2J1dHRvbkNvbW1hbmRzTGlzdElkfVxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLWJ1dHRvblwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0XHRyb2xlPVwibGlzdGJveFwiXG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuY29sdW1ufT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJhZGQtY29sdW1uXCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdHtidXR0b25Db21tYW5kc0xpc3R9XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBsaXN0IG9mIGNvbW1hbmRzLiBJZiBhIGxpc3Qgb2YgY29tbWFuZHMgd2FzIHBhc3NlZFxuXHQgKiBhcyBwcm9wZXJ0eSBgY29tbWFuZHNgLCBpdCB3aWxsIHRha2UgYSBwcmVjZWRlbmNlIG92ZXIgdGhlIGRlZmF1bHQgb25lcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUNvbHVtblxuXHQgKiBAbWV0aG9kIF9nZXRDb21tYW5kc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBhdmFpbGFibGUgY29tbWFuZHMuXG5cdCAqL1xuXHRfZ2V0Q29tbWFuZHMoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMucHJvcHMuY29tbWFuZHMgfHwgW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ2NvbHVtbkluc2VydEJlZm9yZScsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3MuY29sdW1uSW5zZXJ0QmVmb3JlLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ2NvbHVtbkluc2VydEFmdGVyJyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5jb2x1bW5JbnNlcnRBZnRlcixcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdjb2x1bW5EZWxldGUnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmNvbHVtbkRlbGV0ZSxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlQ29sdW1uO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuXG5jb25zdCBLRVlfRU5URVIgPSAxMztcbmNvbnN0IEtFWV9FU0MgPSAyNztcblxuLyoqXG4gKiBUaGUgQnV0dG9uVGFibGVFZGl0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIGFuZCBlZGl0aW5nIGEgdGFibGUgaW4gYSBkb2N1bWVudC5cbiAqIFByb3ZpZGVzIFVJIGZvciBjcmVhdGluZyBhIHRhYmxlLlxuICpcbiAqIEBjbGFzcyBCdXR0b25UYWJsZUVkaXRcbiAqL1xuY2xhc3MgQnV0dG9uVGFibGVFZGl0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVFZGl0XG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqL1xuXHRzdGF0aWMgZGVmYXVsdFByb3BzID0ge1xuXHRcdHRhYmxlQXR0cmlidXRlczoge1xuXHRcdFx0Ym9yZGVyOiAxLFxuXHRcdFx0Y2VsbFBhZGRpbmc6IDAsXG5cdFx0XHRjZWxsU3BhY2luZzogMCxcblx0XHRcdHN0eWxlOiAnd2lkdGg6IDEwMCUnLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCB0YWJsZUVkaXRcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndGFibGVFZGl0JztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUVkaXRcblx0ICogQG1ldGhvZCBnZXRJbml0aWFsU3RhdGVcblx0ICovXG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXG5cdFx0dGhpcy5yb3dzUmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG5cdFx0dGhpcy5jb2xzUmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG5cdFx0dGhpcy5zdGF0ZSA9IHtcblx0XHRcdGNvbHM6IDMsXG5cdFx0XHRyb3dzOiAzLFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCAobm90IG9uIHRoZSBzZXJ2ZXIpLFxuXHQgKiBpbW1lZGlhdGVseSBhZnRlciB0aGUgaW5pdGlhbCByZW5kZXJpbmcgb2NjdXJzLlxuXHQgKlxuXHQgKiBGb2N1c2VzIG9uIHRoZSBsaW5rIGlucHV0IHRvIGltbWVkaWF0ZWx5IGFsbG93IGVkaXRpbmcuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVFZGl0XG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcblx0ICovXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdHRoaXMucm93c1JlZi5jdXJyZW50LmZvY3VzKCk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHRhYmxlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuXHQgKiBAbWV0aG9kIF9jcmVhdGVUYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfY3JlYXRlVGFibGUgPSAoKSA9PiB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdGNvbnN0IHRhYmxlVXRpbHMgPSBuZXcgQ0tFRElUT1IuVGFibGUoZWRpdG9yKTtcblxuXHRcdHRhYmxlVXRpbHMuY3JlYXRlKHtcblx0XHRcdGF0dHJzOiB0aGlzLnByb3BzLnRhYmxlQXR0cmlidXRlcyxcblx0XHRcdGNvbHM6IHRoaXMuc3RhdGUuY29scyxcblx0XHRcdHJvd3M6IHRoaXMuc3RhdGUucm93cyxcblx0XHR9KTtcblxuXHRcdHRoaXMucHJvcHMuY2FuY2VsRXhjbHVzaXZlKCk7XG5cblx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgYSBjaGFuZ2UgaW4gaW5wdXQgdmFsdWUuIFNldHMgdGhlIHByb3ZpZGVkIHZhbHVlIGZyb20gdGhlIHVzZXIgYmFjayB0byB0aGUgaW5wdXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVFZGl0XG5cdCAqIEBtZXRob2QgX2hhbmRsZUNoYW5nZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXROYW1lIFRoZSBuYW1lIG9mIHRoZSBpbnB1dCB3aGljaCB2YWx1ZSBzaG91bGQgYmUgdXBkYXRlZC5cblx0ICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgVGhlIHByb3ZpZGVkIGV2ZW50LlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfaGFuZGxlQ2hhbmdlID0gKGlucHV0TmFtZSwgZXZlbnQpID0+IHtcblx0XHRjb25zdCBzdGF0ZSA9IHt9O1xuXHRcdHN0YXRlW2lucHV0TmFtZV0gPSBldmVudC50YXJnZXQudmFsdWU7XG5cblx0XHR0aGlzLnNldFN0YXRlKHN0YXRlKTtcblx0fTtcblxuXHQvKipcblx0ICogTW9uaXRvcnMga2V5IGludGVyYWN0aW9uIGluc2lkZSB0aGUgaW5wdXQgZWxlbWVudCB0byByZXNwb25kIHRvIHRoZSBrZXlzOlxuXHQgKiAtIEVudGVyOiBDcmVhdGVzIHRoZSB0YWJsZS5cblx0ICogLSBFc2NhcGU6IERpc2NhcmRzIHRoZSBjaGFuZ2VzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuXHQgKiBAbWV0aG9kIF9oYW5kbGVLZXlEb3duXG5cdCAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFRoZSBrZXlib2FyZCBldmVudC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2hhbmRsZUtleURvd24gPSBldmVudCA9PiB7XG5cdFx0aWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWV9FTlRFUiB8fCBldmVudC5rZXlDb2RlID09PSBLRVlfRVNDKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRU5URVIpIHtcblx0XHRcdHRoaXMuX2NyZWF0ZVRhYmxlKCk7XG5cdFx0fSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSBLRVlfRVNDKSB7XG5cdFx0XHR0aGlzLnByb3BzLmNhbmNlbEV4Y2x1c2l2ZSgpO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlRWRpdFxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCB0aW1lID0gRGF0ZS5ub3coKTtcblx0XHRjb25zdCByb3dzSWQgPSB0aW1lICsgJ3Jvd3MnO1xuXHRcdGNvbnN0IGNvbHNJZCA9IHRpbWUgKyAnY29scyc7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZWRpdC10YWJsZVwiPlxuXHRcdFx0XHQ8bGFiZWwgaHRtbEZvcj17cm93c0lkfT57QWxsb3lFZGl0b3IuU3RyaW5ncy5yb3dzfTwvbGFiZWw+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0IHNtYWxsXCI+XG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1pbnB1dFwiXG5cdFx0XHRcdFx0XHRpZD17cm93c0lkfVxuXHRcdFx0XHRcdFx0b25DaGFuZ2U9e3RoaXMuX2hhbmRsZUNoYW5nZS5iaW5kKHRoaXMsICdyb3dzJyl9XG5cdFx0XHRcdFx0XHRtaW49XCIxXCJcblx0XHRcdFx0XHRcdG9uS2V5RG93bj17dGhpcy5faGFuZGxlS2V5RG93bn1cblx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPVwiUm93c1wiXG5cdFx0XHRcdFx0XHRyZWY9e3RoaXMucm93c1JlZn1cblx0XHRcdFx0XHRcdHR5cGU9XCJudW1iZXJcIlxuXHRcdFx0XHRcdFx0dmFsdWU9e3RoaXMuc3RhdGUucm93c31cblx0XHRcdFx0XHQvPlxuXHRcdFx0XHQ8L2Rpdj5cblxuXHRcdFx0XHQ8bGFiZWwgaHRtbEZvcj17Y29sc0lkfT57QWxsb3lFZGl0b3IuU3RyaW5ncy5jb2x1bW5zfTwvbGFiZWw+XG5cdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWlucHV0IHNtYWxsXCI+XG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS1pbnB1dFwiXG5cdFx0XHRcdFx0XHRpZD17Y29sc0lkfVxuXHRcdFx0XHRcdFx0b25DaGFuZ2U9e3RoaXMuX2hhbmRsZUNoYW5nZS5iaW5kKHRoaXMsICdjb2xzJyl9XG5cdFx0XHRcdFx0XHRtaW49XCIxXCJcblx0XHRcdFx0XHRcdG9uS2V5RG93bj17dGhpcy5faGFuZGxlS2V5RG93bn1cblx0XHRcdFx0XHRcdHBsYWNlaG9sZGVyPVwiQ29sdW1zXCJcblx0XHRcdFx0XHRcdHJlZj17dGhpcy5jb2xzUmVmfVxuXHRcdFx0XHRcdFx0dHlwZT1cIm51bWJlclwiXG5cdFx0XHRcdFx0XHR2YWx1ZT17dGhpcy5zdGF0ZS5jb2xzfVxuXHRcdFx0XHRcdC8+XG5cdFx0XHRcdDwvZGl2PlxuXG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWxhYmVsPVwiQ29uZmlybVwiXG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLl9jcmVhdGVUYWJsZX0+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiY2hlY2tcIiAvPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uVGFibGVFZGl0O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBCdXR0b25Db21tYW5kc0xpc3QgZnJvbSAnLi9idXR0b24tY29tbWFuZHMtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblRhYmxlSGVhZGluZyBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IHRvIHdvcmsgd2l0aCB0YWJsZSBoZWFkaW5nLlxuICpcbiAqIEBjbGFzcyBCdXR0b25UYWJsZUhlYWRpbmdcbiAqL1xuY2xhc3MgQnV0dG9uVGFibGVIZWFkaW5nIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHRhYmxlUm93XG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUhlYWRpbmdcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3RhYmxlSGVhZGluZyc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUhlYWRpbmdcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0bGV0IGJ1dHRvbkNvbW1hbmRzTGlzdDtcblx0XHRsZXQgYnV0dG9uQ29tbWFuZHNMaXN0SWQ7XG5cblx0XHRpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuXHRcdFx0YnV0dG9uQ29tbWFuZHNMaXN0SWQgPSBCdXR0b25UYWJsZUhlYWRpbmcua2V5ICsgJ0xpc3QnO1xuXHRcdFx0YnV0dG9uQ29tbWFuZHNMaXN0ID0gKFxuXHRcdFx0XHQ8QnV0dG9uQ29tbWFuZHNMaXN0XG5cdFx0XHRcdFx0Y29tbWFuZHM9e3RoaXMuX2dldENvbW1hbmRzKCl9XG5cdFx0XHRcdFx0bGlzdElkPXtidXR0b25Db21tYW5kc0xpc3RJZH1cblx0XHRcdFx0XHRvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdC8+XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGNvbnN0IGFjdGl2ZUhlYWRpbmcgPSBuZXcgQ0tFRElUT1IuVGFibGUoXG5cdFx0XHR0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJylcblx0XHQpLmdldEhlYWRpbmcoKTtcblx0XHRjb25zdCBhY3RpdmVIZWFkaW5nSW50cm8gPSBBbGxveUVkaXRvci5TdHJpbmdzLmhlYWRlcnMgKyAnOic7XG5cdFx0Y29uc3QgYWN0aXZlSGVhZGluZ0xhYmVsID1cblx0XHRcdEFsbG95RWRpdG9yLlN0cmluZ3NbJ2hlYWRlcnMnICsgYWN0aXZlSGVhZGluZ107XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24teGwgYWUtaGFzLWRyb3Bkb3duXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfVxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9XCJcIlxuXHRcdFx0XHRcdGNsYXNzTmFtZT1cImFlLXRvb2xiYXItZWxlbWVudFwiXG5cdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy50b2dnbGVEcm9wZG93bn1cblx0XHRcdFx0XHRyb2xlPVwiY29tYm9ib3hcIlxuXHRcdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHRcdHRpdGxlPVwiXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXJcIj5cblx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lci1kcm9wZG93bi1zZWxlY3RlZC1pdGVtXCI+XG5cdFx0XHRcdFx0XHRcdHthY3RpdmVIZWFkaW5nSW50cm99eycgJ31cblx0XHRcdFx0XHRcdFx0PHN0cm9uZz57YWN0aXZlSGVhZGluZ0xhYmVsfTwvc3Ryb25nPlxuXHRcdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwiY2FyZXQtYm90dG9tXCIgLz5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdHtidXR0b25Db21tYW5kc0xpc3R9XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBsaXN0IG9mIGNvbW1hbmRzLiBJZiBhIGxpc3Qgb2YgY29tbWFuZHMgd2FzIHBhc3NlZFxuXHQgKiBhcyBwcm9wZXJ0eSBgY29tbWFuZHNgLCBpdCB3aWxsIHRha2UgYSBwcmVjZWRlbmNlIG92ZXIgdGhlIGRlZmF1bHQgb25lcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZUhlYWRpbmdcblx0ICogQG1ldGhvZCBfZ2V0Q29tbWFuZHNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGNvbW1hbmRzLlxuXHQgKi9cblx0X2dldENvbW1hbmRzKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLmNvbW1hbmRzIHx8IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICd0YWJsZUhlYWRpbmdOb25lJyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5oZWFkZXJzTm9uZSxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICd0YWJsZUhlYWRpbmdSb3cnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmhlYWRlcnNSb3csXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb21tYW5kOiAndGFibGVIZWFkaW5nQ29sdW1uJyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5oZWFkZXJzQ29sdW1uLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ3RhYmxlSGVhZGluZ0JvdGgnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmhlYWRlcnNCb3RoLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdCk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uVGFibGVIZWFkaW5nO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBCdXR0b25JY29uIGZyb20gJy4vYnV0dG9uLWljb24uanN4JztcbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYWJsZVJlbW92ZSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciByZW1vdmluZyBhIHRhYmxlXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhYmxlUmVtb3ZlXG4gKi9cbmNsYXNzIEJ1dHRvblRhYmxlUmVtb3ZlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHRhYmxlUmVtb3ZlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJlbW92ZVxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndGFibGVSZW1vdmUnO1xuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFibGVSZW1vdmVcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5kZWxldGVUYWJsZX1cblx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXRhYmxlLXJlbW92ZVwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX3JlbW92ZVRhYmxlfVxuXHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuZGVsZXRlVGFibGV9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJ0cmFzaFwiIC8+XG5cdFx0XHQ8L2J1dHRvbj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHRhYmxlIGluIHRoZSBlZGl0b3IgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJlbW92ZVxuXHQgKiBAbWV0aG9kIF9yZW1vdmVUYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfcmVtb3ZlVGFibGUgPSAoKSA9PiB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXHRcdGNvbnN0IHRhYmxlVXRpbHMgPSBuZXcgQ0tFRElUT1IuVGFibGUoZWRpdG9yKTtcblxuXHRcdHRhYmxlVXRpbHMucmVtb3ZlKCk7XG5cblx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlUmVtb3ZlO1xuIiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmRzTGlzdCBmcm9tICcuL2J1dHRvbi1jb21tYW5kcy1saXN0LmpzeCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYWJsZVJvdyBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IHRvIHdvcmsgd2l0aCB0YWJsZSByb3dzLlxuICpcbiAqIEBjbGFzcyBCdXR0b25UYWJsZVJvd1xuICovXG5jbGFzcyBCdXR0b25UYWJsZVJvdyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgdGFibGVSb3dcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlUm93XG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICd0YWJsZVJvdyc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJvd1xuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRsZXQgYnV0dG9uQ29tbWFuZHNMaXN0O1xuXHRcdGxldCBidXR0b25Db21tYW5kc0xpc3RJZDtcblxuXHRcdGlmICh0aGlzLnByb3BzLmV4cGFuZGVkKSB7XG5cdFx0XHRidXR0b25Db21tYW5kc0xpc3RJZCA9IEJ1dHRvblRhYmxlUm93LmtleSArICdMaXN0Jztcblx0XHRcdGJ1dHRvbkNvbW1hbmRzTGlzdCA9IChcblx0XHRcdFx0PEJ1dHRvbkNvbW1hbmRzTGlzdFxuXHRcdFx0XHRcdGNvbW1hbmRzPXt0aGlzLl9nZXRDb21tYW5kcygpfVxuXHRcdFx0XHRcdGxpc3RJZD17YnV0dG9uQ29tbWFuZHNMaXN0SWR9XG5cdFx0XHRcdFx0b25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHQvPlxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXIgYWUtaGFzLWRyb3Bkb3duXCI+XG5cdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfVxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3Mucm93fVxuXHRcdFx0XHRcdGFyaWEtb3ducz17YnV0dG9uQ29tbWFuZHNMaXN0SWR9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRvbkNsaWNrPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufVxuXHRcdFx0XHRcdHJvbGU9XCJjb21ib2JveFwiXG5cdFx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3Mucm93fT5cblx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJhZGQtcm93XCIgLz5cblx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdHtidXR0b25Db21tYW5kc0xpc3R9XG5cdFx0XHQ8L2Rpdj5cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBsaXN0IG9mIGNvbW1hbmRzLiBJZiBhIGxpc3Qgb2YgY29tbWFuZHMgd2FzIHBhc3NlZFxuXHQgKiBhcyBwcm9wZXJ0eSBgY29tbWFuZHNgLCBpdCB3aWxsIHRha2UgYSBwcmVjZWRlbmNlIG92ZXIgdGhlIGRlZmF1bHQgb25lcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVJvd1xuXHQgKiBAbWV0aG9kIF9nZXRDb21tYW5kc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBhdmFpbGFibGUgY29tbWFuZHMuXG5cdCAqL1xuXHRfZ2V0Q29tbWFuZHMoKSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdHRoaXMucHJvcHMuY29tbWFuZHMgfHwgW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ3Jvd0luc2VydEJlZm9yZScsXG5cdFx0XHRcdFx0bGFiZWw6IEFsbG95RWRpdG9yLlN0cmluZ3Mucm93SW5zZXJ0QmVmb3JlLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29tbWFuZDogJ3Jvd0luc2VydEFmdGVyJyxcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5yb3dJbnNlcnRBZnRlcixcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNvbW1hbmQ6ICdyb3dEZWxldGUnLFxuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLnJvd0RlbGV0ZSxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHQpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlUm93O1xuIiwiaW1wb3J0IEJ1dHRvbkljb24gZnJvbSAnLi9idXR0b24taWNvbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlRWRpdCBmcm9tICcuL2J1dHRvbi10YWJsZS1lZGl0LmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYWJsZSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciBjcmVhdGluZyBhbmQgZWRpdGluZyBhIHRhYmxlIGluIGEgZG9jdW1lbnQuIEJ1dHRvblRhYmxlXG4gKiByZW5kZXJzIGluIHR3byBkaWZmZXJlbnQgbW9kZXM6XG4gKlxuICogLSBOb3JtYWw6IEp1c3QgYSBidXR0b24gdGhhdCBhbGxvd3MgdG8gc3dpdGNoIHRvIHRoZSBlZGl0aW9uIG1vZGVcbiAqIC0gRXhjbHVzaXZlOiBUaGUgQnV0dG9uVGFibGVFZGl0IFVJIHdpdGggYWxsIHRoZSB0YWJsZSBlZGl0aW9uIGNvbnRyb2xzLlxuICpcbiAqIEBjbGFzcyBCdXR0b25UYWJsZVxuICovXG5jbGFzcyBCdXR0b25UYWJsZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgdGFibGVcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhYmxlXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBrZXlcblx0ICogQHN0YXRpY1xuXHQgKi9cblx0c3RhdGljIGtleSA9ICd0YWJsZSc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYWJsZVxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcblx0XHRcdHJldHVybiA8QnV0dG9uVGFibGVFZGl0IHsuLi50aGlzLnByb3BzfSAvPjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MudGFibGV9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uXCJcblx0XHRcdFx0XHRkYXRhLXR5cGU9XCJidXR0b24tdGFibGVcIlxuXHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMucHJvcHMucmVxdWVzdEV4Y2x1c2l2ZX1cblx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy50YWJsZX0+XG5cdFx0XHRcdFx0PEJ1dHRvbkljb24gc3ltYm9sPVwidGFibGVcIiAvPlxuXHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEJ1dHRvblRhYmxlO1xuIiwiaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJy4vYnV0dG9uLWRyb3Bkb3duLmpzeCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWZvY3VzLW1hbmFnZXInO1xuXG4vKipcbiAqIFRoZSBCdXR0b25UYXJnZXRMaXN0IGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNoYW5naW5nIHRoZSB0YXJnZXQgb2YgYSBsaW5rXG4gKiBpbiB0aGUgZG9jdW1lbnQuXG4gKlxuICogQGNsYXNzIEJ1dHRvblRhcmdldExpc3RcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBCdXR0b25UYXJnZXRMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhcmdldExpc3Rcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y2lyY3VsYXI6IHRydWUsXG5cdFx0ZGVzY2VuZGFudHM6ICcuYWUtdG9vbGJhci1lbGVtZW50Jyxcblx0XHRrZXlzOiB7XG5cdFx0XHRkaXNtaXNzOiBbMjddLFxuXHRcdFx0ZGlzbWlzc05leHQ6IFszOV0sXG5cdFx0XHRkaXNtaXNzUHJldjogWzM3XSxcblx0XHRcdG5leHQ6IFs0MF0sXG5cdFx0XHRwcmV2OiBbMzhdLFxuXHRcdH0sXG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZSBuYW1lIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBhbiBhbGlhcyBvZiB0aGUgYnV0dG9uIGluIHRoZSBjb25maWd1cmF0aW9uLlxuXHQgKlxuXHQgKiBAZGVmYXVsdCBsaW5rVGFyZ2V0RWRpdFxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFyZ2V0TGlzdFxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30ga2V5XG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdHN0YXRpYyBrZXkgPSAndGFyZ2V0TGlzdCc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQsIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVGFyZ2V0TGlzdFxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKS5mb2N1cygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYXJnZXRMaXN0XG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNvbnRlbnQgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkLlxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGNvbnN0IGxpc3RUYXJnZXRzID0gdGhpcy5fcmVuZGVyTGlzdFRhcmdldHMoKTtcblxuXHRcdHJldHVybiA8QnV0dG9uRHJvcGRvd24gey4uLnRoaXMucHJvcHN9PntsaXN0VGFyZ2V0c308L0J1dHRvbkRyb3Bkb3duPjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB0aGUgYWxsb3dlZCBsaW5rIHRhcmdldCBpdGVtcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25UYXJnZXRMaXN0XG5cdCAqIEBtZXRob2QgX2dldEFsbG93ZWRUYXJnZXRJdGVtc1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0FycmF5fSBUaGUgYWxsb3dlZCB0YXJnZXQgaXRlbXMuXG5cdCAqL1xuXHRfZ2V0QWxsb3dlZFRhcmdldEl0ZW1zKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLmFsbG93ZWRMaW5rVGFyZ2V0cyB8fCBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0RGVmYXVsdCxcblx0XHRcdFx0XHR2YWx1ZTogJycsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0U2VsZixcblx0XHRcdFx0XHR2YWx1ZTogJ19zZWxmJyxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxhYmVsOiBBbGxveUVkaXRvci5TdHJpbmdzLmxpbmtUYXJnZXRCbGFuayxcblx0XHRcdFx0XHR2YWx1ZTogJ19ibGFuaycsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0UGFyZW50LFxuXHRcdFx0XHRcdHZhbHVlOiAnX3BhcmVudCcsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsYWJlbDogQWxsb3lFZGl0b3IuU3RyaW5ncy5saW5rVGFyZ2V0VG9wLFxuXHRcdFx0XHRcdHZhbHVlOiAnX3RvcCcsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIHRoZSBhbGxvd2VkIGxpbmsgdGFyZ2V0IGl0ZW1zLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblRhcmdldExpc3Rcblx0ICogQG1ldGhvZCBfcmVuZGVyTGlzdFRhcmdldHNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIHJlbmRlcmVkIGxpbmsgaXRlbXNcblx0ICovXG5cdF9yZW5kZXJMaXN0VGFyZ2V0cygpIHtcblx0XHRsZXQgdGFyZ2V0cyA9IHRoaXMuX2dldEFsbG93ZWRUYXJnZXRJdGVtcygpO1xuXG5cdFx0Y29uc3QgaGFuZGxlTGlua1RhcmdldENoYW5nZSA9IHRoaXMucHJvcHMuaGFuZGxlTGlua1RhcmdldENoYW5nZTtcblxuXHRcdHRhcmdldHMgPSB0YXJnZXRzLm1hcCh0YXJnZXQgPT4ge1xuXHRcdFx0Y29uc3QgY2xhc3NOYW1lID1cblx0XHRcdFx0dGhpcy5wcm9wcy5zZWxlY3RlZFRhcmdldCA9PT0gdGFyZ2V0LnZhbHVlXG5cdFx0XHRcdFx0PyAnYWUtdG9vbGJhci1lbGVtZW50IGFjdGl2ZSdcblx0XHRcdFx0XHQ6ICdhZS10b29sYmFyLWVsZW1lbnQnO1xuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8bGkga2V5PXt0YXJnZXQudmFsdWV9IHJvbGU9XCJvcHRpb25cIj5cblx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzTmFtZX1cblx0XHRcdFx0XHRcdGRhdGEtdmFsdWU9e3RhcmdldC52YWx1ZX1cblx0XHRcdFx0XHRcdG9uQ2xpY2s9e2hhbmRsZUxpbmtUYXJnZXRDaGFuZ2V9PlxuXHRcdFx0XHRcdFx0e3RhcmdldC5sYWJlbH1cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PC9saT5cblx0XHRcdCk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdGFyZ2V0cztcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRGb2N1c01hbmFnZXIoQnV0dG9uVGFyZ2V0TGlzdCk7XG4iLCJpbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jb25zdCBNQVhfVFdFRVRfTEVOR1RIID0gMjgwO1xuXG4vKipcbiAqIFRoZSBCdXR0b25Ud2l0dGVyIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGNyZWF0aW5nIGEgbGluayB3aGljaFxuICogYWxsb3dzIHBlb3BsZSB0byB0d2VldCBwYXJ0IG9mIHRoZSBjb250ZW50IGluIHRoZSBlZGl0b3IuXG4gKlxuICogQGNsYXNzIEJ1dHRvblR3aXR0ZXJcbiAqIEB1c2VzIEJ1dHRvblN0YXRlQ2xhc3Nlc1xuICovXG5jbGFzcyBCdXR0b25Ud2l0dGVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHQvKipcblx0ICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG5cdCAqXG5cdCAqIEBkZWZhdWx0IHR3aXR0ZXJcblx0ICogQG1lbWJlcm9mIEJ1dHRvblR3aXR0ZXJcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3R3aXR0ZXInO1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIG9yIHJlbW92ZXMgdGhlIHR3aXR0ZXIgbGluayBvbiB0aGUgc2VsZWN0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblR3aXR0ZXJcblx0ICogQG1ldGhvZCBoYW5kbGVDbGlja1xuXHQgKi9cblx0aGFuZGxlQ2xpY2sgPSAoKSA9PiB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0Y29uc3QgbGlua1V0aWxzID0gbmV3IENLRURJVE9SLkxpbmsoZWRpdG9yKTtcblxuXHRcdGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcblx0XHRcdGxpbmtVdGlscy5yZW1vdmUobGlua1V0aWxzLmdldEZyb21TZWxlY3Rpb24oKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxpbmtVdGlscy5jcmVhdGUodGhpcy5fZ2V0SHJlZigpLCB7XG5cdFx0XHRcdGNsYXNzOiAnYWUtdHdpdHRlci1saW5rJyxcblx0XHRcdFx0dGFyZ2V0OiAnX2JsYW5rJyxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGVkaXRvci5maXJlKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBjb250YWluZWQgd2l0aGluIGEgbGluayB0aGF0IHBvaW50cyB0byB0d2l0dGVyLmNvbS9pbnRlbnQvdHdlZXQuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVHdpdHRlclxuXHQgKiBAbWV0aG9kIGlzQWN0aXZlXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHNlbGVjdGlvbiBpcyBpbnNpZGUgYSB0d2l0dGVyIGxpbmssIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG5cdGlzQWN0aXZlKCkge1xuXHRcdGNvbnN0IGxpbmsgPSBuZXcgQ0tFRElUT1IuTGluayhcblx0XHRcdHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKVxuXHRcdCkuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdGxpbmsgJiZcblx0XHRcdGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJykuaW5kZXhPZigndHdpdHRlci5jb20vaW50ZW50L3R3ZWV0JykgIT09IC0xXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJlbmRlcnMgdGhlIFVJIG9mIHRoZSBidXR0b24uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVHdpdHRlclxuXHQgKiBAbWV0aG9kIHJlbmRlclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRjb25zdCBjc3NDbGFzcyA9IGBhZS1idXR0b24gJHt0aGlzLmdldFN0YXRlQ2xhc3NlcygpfWA7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLnR3aXR0ZXJ9XG5cdFx0XHRcdGNsYXNzTmFtZT17Y3NzQ2xhc3N9XG5cdFx0XHRcdGRhdGEtdHlwZT1cImJ1dHRvbi10d2l0dGVyXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5oYW5kbGVDbGlja31cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLnR3aXR0ZXJ9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJ0d2l0dGVyXCIgLz5cblx0XHRcdDwvYnV0dG9uPlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGVzIHRoZSBhcHByb3ByaWF0ZSB0d2l0dGVyIHVybCBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgdGV4dCBhbmQgdGhlIGNvbmZpZ3VyYXRpb25cblx0ICogb3B0aW9ucyByZWNlaXZlZCB2aWEgcHJvcHMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQnV0dG9uVHdpdHRlclxuXHQgKiBAbWV0aG9kIF9nZXRIcmVmXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7U3RyaW5nfSBBIHZhbGlkIHR3aXR0ZXIgdXJsIHdpdGggdGhlIHNlbGVjdGVkIHRleHQgYW5kIGdpdmVuIGNvbmZpZ3VyYXRpb24uXG5cdCAqL1xuXHRfZ2V0SHJlZigpIHtcblx0XHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0Y29uc3Qgc2VsZWN0ZWRUZXh0ID0gbmF0aXZlRWRpdG9yXG5cdFx0XHQuZ2V0U2VsZWN0aW9uKClcblx0XHRcdC5nZXRTZWxlY3RlZFRleHQoKVxuXHRcdFx0LnN1YnN0cmluZygwLCBNQVhfVFdFRVRfTEVOR1RIKTtcblx0XHRjb25zdCB1cmwgPSB0aGlzLnByb3BzLnVybDtcblx0XHRjb25zdCB2aWEgPSB0aGlzLnByb3BzLnZpYTtcblx0XHRsZXQgdHdpdHRlckhyZWYgPVxuXHRcdFx0J2h0dHBzOi8vdHdpdHRlci5jb20vaW50ZW50L3R3ZWV0P3RleHQ9JyArIHNlbGVjdGVkVGV4dDtcblxuXHRcdGlmICh1cmwpIHtcblx0XHRcdHR3aXR0ZXJIcmVmICs9ICcmdXJsPScgKyB1cmw7XG5cdFx0fVxuXG5cdFx0aWYgKHZpYSkge1xuXHRcdFx0dHdpdHRlckhyZWYgKz0gJyZ2aWE9JyArIHZpYTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHdpdHRlckhyZWY7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblR3aXR0ZXIpO1xuIiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblVub3JkZXJlZGxpc3QgY2xhc3MgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3IgY3JlYXRpbmcgdW5vcmRlcmVkIGxpc3RzIGluIGFuIGVkaXRvci5cbiAqXG4gKiBAY2xhc3MgQnV0dG9uVW5vcmRlcmVkbGlzdFxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uU3RhdGVDbGFzc2VzXG4gKiBAdXNlcyBCdXR0b25TdHlsZVxuICovXG5jbGFzcyBCdXR0b25Vbm9yZGVyZWRsaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblVub3JkZXJlZGxpc3Rcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAnYnVsbGV0ZWRsaXN0Jyxcblx0XHRzdHlsZToge1xuXHRcdFx0ZWxlbWVudDogJ3VsJyxcblx0XHR9LFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgdWxcblx0ICogQG1lbWJlcm9mIEJ1dHRvblVub3JkZXJlZGxpc3Rcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3VsJztcblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBVSSBvZiB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEJ1dHRvblVub3JkZXJlZGxpc3Rcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5idWxsZXRlZGxpc3R9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXVsXCJcblx0XHRcdFx0b25DbGljaz17dGhpcy5leGVjQ29tbWFuZH1cblx0XHRcdFx0dGFiSW5kZXg9e3RoaXMucHJvcHMudGFiSW5kZXh9XG5cdFx0XHRcdHRpdGxlPXtBbGxveUVkaXRvci5TdHJpbmdzLmJ1bGxldGVkbGlzdH0+XG5cdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cImxpc3QtdWxcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuXHRCdXR0b25TdGF0ZUNsYXNzZXMoQnV0dG9uU3R5bGUoQnV0dG9uVW5vcmRlcmVkbGlzdCkpXG4pO1xuIiwiaW1wb3J0IEJ1dHRvbkNvbW1hbmQgZnJvbSAnLi4vYmFzZS9idXR0b24tY29tbWFuZCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgQnV0dG9uS2V5c3Ryb2tlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLWtleXN0cm9rZSc7XG5pbXBvcnQgQnV0dG9uU3RhdGVDbGFzc2VzIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0YXRlLWNsYXNzZXMnO1xuaW1wb3J0IEJ1dHRvblN0eWxlIGZyb20gJy4uL2Jhc2UvYnV0dG9uLXN0eWxlJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogVGhlIEJ1dHRvblVuZGVybGluZSBjbGFzcyBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvciB1bmRlcmx5aW5nIGEgdGV4dCBzZWxlY3Rpb24uXG4gKlxuICogQGNsYXNzIEJ1dHRvblVuZGVybGluZVxuICogQHVzZXMgQnV0dG9uQ29tbWFuZFxuICogQHVzZXMgQnV0dG9uS2V5c3Ryb2tlXG4gKiBAdXNlcyBCdXR0b25TdGF0ZUNsYXNzZXNcbiAqIEB1c2VzIEJ1dHRvblN0eWxlXG4gKi9cbmNsYXNzIEJ1dHRvblVuZGVybGluZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25VbmRlcmxpbmVcblx0ICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuXHQgKi9cblx0c3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcblx0XHRjb21tYW5kOiAndW5kZXJsaW5lJyxcblx0XHRrZXlzdHJva2U6IHtcblx0XHRcdGZuOiAnZXhlY0NvbW1hbmQnLFxuXHRcdFx0a2V5czogQ0tFRElUT1IuQ1RSTCArIDg1IC8qIFUqLyxcblx0XHR9LFxuXHRcdHN0eWxlOiAnY29yZVN0eWxlc191bmRlcmxpbmUnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBUaGUgbmFtZSB3aGljaCB3aWxsIGJlIHVzZWQgYXMgYW4gYWxpYXMgb2YgdGhlIGJ1dHRvbiBpbiB0aGUgY29uZmlndXJhdGlvbi5cblx0ICpcblx0ICogQGRlZmF1bHQgdW5kZXJsaW5lXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25VbmRlcmxpbmVcblx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRzdGF0aWMga2V5ID0gJ3VuZGVybGluZSc7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGJ1dHRvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCdXR0b25VbmRlcmxpbmVcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3NzQ2xhc3MgPSBgYWUtYnV0dG9uICR7dGhpcy5nZXRTdGF0ZUNsYXNzZXMoKX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxidXR0b25cblx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy51bmRlcmxpbmV9XG5cdFx0XHRcdGFyaWEtcHJlc3NlZD17Y3NzQ2xhc3MuaW5kZXhPZigncHJlc3NlZCcpICE9PSAtMX1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc31cblx0XHRcdFx0ZGF0YS10eXBlPVwiYnV0dG9uLXVuZGVybGluZVwiXG5cdFx0XHRcdG9uQ2xpY2s9e3RoaXMuZXhlY0NvbW1hbmR9XG5cdFx0XHRcdHRhYkluZGV4PXt0aGlzLnByb3BzLnRhYkluZGV4fVxuXHRcdFx0XHR0aXRsZT17QWxsb3lFZGl0b3IuU3RyaW5ncy51bmRlcmxpbmV9PlxuXHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJ1bmRlcmxpbmVcIiAvPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Db21tYW5kKFxuXHRCdXR0b25LZXlzdHJva2UoQnV0dG9uU3RhdGVDbGFzc2VzKEJ1dHRvblN0eWxlKEJ1dHRvblVuZGVybGluZSkpKVxuKTtcbiIsImltcG9ydCBCdXR0b25BY2Nlc3NpYmlsaXR5SW1hZ2VBbHQgZnJvbSAnLi9idXR0b24tYWNjZXNzaWJpbGl0eS1pbWFnZS1hbHQuanN4JztcbmltcG9ydCBCdXR0b25CYWNrZ3JvdW5kQ29sb3IgZnJvbSAnLi9idXR0b24tYmFja2dyb3VuZC1jb2xvci5qc3gnO1xuaW1wb3J0IEJ1dHRvbkJvbGQgZnJvbSAnLi9idXR0b24tYm9sZC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkNhbWVyYUltYWdlIGZyb20gJy4vYnV0dG9uLWNhbWVyYS1pbWFnZS5qc3gnO1xuaW1wb3J0IEJ1dHRvbkNhbWVyYSBmcm9tICcuL2J1dHRvbi1jYW1lcmEuanN4JztcbmltcG9ydCBCdXR0b25Db2RlIGZyb20gJy4vYnV0dG9uLWNvZGUuanN4JztcbmltcG9ydCBCdXR0b25Db2xvciBmcm9tICcuL2J1dHRvbi1jb2xvci5qc3gnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRMaXN0SXRlbSBmcm9tICcuL2J1dHRvbi1jb21tYW5kLWxpc3QtaXRlbS5qc3gnO1xuaW1wb3J0IEJ1dHRvbkNvbW1hbmRzTGlzdCBmcm9tICcuL2J1dHRvbi1jb21tYW5kcy1saXN0LmpzeCc7XG5pbXBvcnQgQnV0dG9uRHJvcGRvd24gZnJvbSAnLi9idXR0b24tZHJvcGRvd24uanN4JztcbmltcG9ydCBCdXR0b25FbWJlZEVkaXQgZnJvbSAnLi9idXR0b24tZW1iZWQtZWRpdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkVtYmVkIGZyb20gJy4vYnV0dG9uLWVtYmVkLmpzeCc7XG5pbXBvcnQgQnV0dG9uRW1iZWRWaWRlb0VkaXQgZnJvbSAnLi9idXR0b24tZW1iZWQtdmlkZW8tZWRpdC5qc3gnO1xuaW1wb3J0IEJ1dHRvbkVtYmVkVmlkZW8gZnJvbSAnLi9idXR0b24tZW1iZWQtdmlkZW8uanN4JztcbmltcG9ydCBCdXR0b25IMSBmcm9tICcuL2J1dHRvbi1oMS5qc3gnO1xuaW1wb3J0IEJ1dHRvbkgyIGZyb20gJy4vYnV0dG9uLWgyLmpzeCc7XG5pbXBvcnQgQnV0dG9uSGxpbmUgZnJvbSAnLi9idXR0b24taGxpbmUuanN4JztcbmltcG9ydCBCdXR0b25JbWFnZUFsaWduQ2VudGVyIGZyb20gJy4vYnV0dG9uLWltYWdlLWFsaWduLWNlbnRlci5qc3gnO1xuaW1wb3J0IEJ1dHRvbkltYWdlQWxpZ25MZWZ0IGZyb20gJy4vYnV0dG9uLWltYWdlLWFsaWduLWxlZnQuanN4JztcbmltcG9ydCBCdXR0b25JbWFnZUFsaWduUmlnaHQgZnJvbSAnLi9idXR0b24taW1hZ2UtYWxpZ24tcmlnaHQuanN4JztcbmltcG9ydCBCdXR0b25JbWFnZSBmcm9tICcuL2J1dHRvbi1pbWFnZS5qc3gnO1xuaW1wb3J0IEJ1dHRvbkluZGVudEJsb2NrIGZyb20gJy4vYnV0dG9uLWluZGVudC1ibG9jay5qc3gnO1xuaW1wb3J0IEJ1dHRvbkl0YWxpYyBmcm9tICcuL2J1dHRvbi1pdGFsaWMuanN4JztcbmltcG9ydCBCdXR0b25JdGVtU2VsZWN0b3JBdWRpbyBmcm9tICcuL2J1dHRvbi1pdGVtLXNlbGVjdG9yLWF1ZGlvLmpzeCc7XG5pbXBvcnQgQnV0dG9uSXRlbVNlbGVjdG9ySW1hZ2UgZnJvbSAnLi9idXR0b24taXRlbS1zZWxlY3Rvci1pbWFnZS5qc3gnO1xuaW1wb3J0IEJ1dHRvbkl0ZW1TZWxlY3RvclZpZGVvIGZyb20gJy4vYnV0dG9uLWl0ZW0tc2VsZWN0b3ItdmlkZW8uanN4JztcbmltcG9ydCBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdCBmcm9tICcuL2J1dHRvbi1saW5rLWF1dG9jb21wbGV0ZS1saXN0LmpzeCc7XG5pbXBvcnQgQnV0dG9uTGlua0Jyb3dzZSBmcm9tICcuL2J1dHRvbi1saW5rLWJyb3dzZS5qc3gnO1xuaW1wb3J0IEJ1dHRvbkxpbmtFZGl0QnJvd3NlIGZyb20gJy4vYnV0dG9uLWxpbmstZWRpdC1icm93c2UuanN4JztcbmltcG9ydCBCdXR0b25MaW5rRWRpdCBmcm9tICcuL2J1dHRvbi1saW5rLWVkaXQuanN4JztcbmltcG9ydCBCdXR0b25MaW5rVGFyZ2V0RWRpdCBmcm9tICcuL2J1dHRvbi1saW5rLXRhcmdldC1lZGl0LmpzeCc7XG5pbXBvcnQgQnV0dG9uTGluayBmcm9tICcuL2J1dHRvbi1saW5rLmpzeCc7XG5pbXBvcnQgQnV0dG9uT2wgZnJvbSAnLi9idXR0b24tb2wuanN4JztcbmltcG9ydCBCdXR0b25PdXRkZW50QmxvY2sgZnJvbSAnLi9idXR0b24tb3V0ZGVudC1ibG9jay5qc3gnO1xuaW1wb3J0IEJ1dHRvblBhcmFncmFwaEFsaWduIGZyb20gJy4vYnV0dG9uLXBhcmFncmFwaC1hbGlnbi5qc3gnO1xuaW1wb3J0IEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdCBmcm9tICcuL2J1dHRvbi1wYXJhZ3JhcGgtYWxpZ24tbGVmdC5qc3gnO1xuaW1wb3J0IEJ1dHRvblBhcmFncmFwaEFsaWduUmlnaHQgZnJvbSAnLi9idXR0b24tcGFyYWdyYXBoLWFsaWduLXJpZ2h0LmpzeCc7XG5pbXBvcnQgQnV0dG9uUGFyYWdyYXBoQ2VudGVyIGZyb20gJy4vYnV0dG9uLXBhcmFncmFwaC1jZW50ZXIuanN4JztcbmltcG9ydCBCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5IGZyb20gJy4vYnV0dG9uLXBhcmFncmFwaC1qdXN0aWZ5LmpzeCc7XG5pbXBvcnQgQnV0dG9uUXVvdGUgZnJvbSAnLi9idXR0b24tcXVvdGUuanN4JztcbmltcG9ydCBCdXR0b25SZW1vdmVGb3JtYXQgZnJvbSAnLi9idXR0b24tcmVtb3ZlLWZvcm1hdC5qc3gnO1xuaW1wb3J0IEJ1dHRvblJlbW92ZUltYWdlIGZyb20gJy4vYnV0dG9uLXJlbW92ZS1pbWFnZS5qc3gnO1xuaW1wb3J0IEJ1dHRvblNlcGFyYXRvciBmcm9tICcuL2J1dHRvbi1zZXBhcmF0b3IuanN4JztcbmltcG9ydCBCdXR0b25TcGFjaW5nIGZyb20gJy4vYnV0dG9uLXNwYWNpbmcuanN4JztcbmltcG9ydCBCdXR0b25TdHJpa2UgZnJvbSAnLi9idXR0b24tc3RyaWtlLmpzeCc7XG5pbXBvcnQgQnV0dG9uU3R5bGVzTGlzdEhlYWRlciBmcm9tICcuL2J1dHRvbi1zdHlsZXMtbGlzdC1oZWFkZXIuanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0SXRlbVJlbW92ZSBmcm9tICcuL2J1dHRvbi1zdHlsZXMtbGlzdC1pdGVtLXJlbW92ZS5qc3gnO1xuaW1wb3J0IEJ1dHRvblN0eWxlc0xpc3RJdGVtIGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LWl0ZW0uanN4JztcbmltcG9ydCBCdXR0b25TdHlsZXNMaXN0IGZyb20gJy4vYnV0dG9uLXN0eWxlcy1saXN0LmpzeCc7XG5pbXBvcnQgQnV0dG9uU3R5bGVzIGZyb20gJy4vYnV0dG9uLXN0eWxlcy5qc3gnO1xuaW1wb3J0IEJ1dHRvblN1YnNjcmlwdCBmcm9tICcuL2J1dHRvbi1zdWJzY3JpcHQuanN4JztcbmltcG9ydCBCdXR0b25TdXBlcnNjcmlwdCBmcm9tICcuL2J1dHRvbi1zdXBlcnNjcmlwdC5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlQ2VsbCBmcm9tICcuL2J1dHRvbi10YWJsZS1jZWxsLmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFibGVDb2x1bW4gZnJvbSAnLi9idXR0b24tdGFibGUtY29sdW1uLmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFibGVFZGl0IGZyb20gJy4vYnV0dG9uLXRhYmxlLWVkaXQuanN4JztcbmltcG9ydCBCdXR0b25UYWJsZUhlYWRpbmcgZnJvbSAnLi9idXR0b24tdGFibGUtaGVhZGluZy5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlUmVtb3ZlIGZyb20gJy4vYnV0dG9uLXRhYmxlLXJlbW92ZS5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlUm93IGZyb20gJy4vYnV0dG9uLXRhYmxlLXJvdy5qc3gnO1xuaW1wb3J0IEJ1dHRvblRhYmxlIGZyb20gJy4vYnV0dG9uLXRhYmxlLmpzeCc7XG5pbXBvcnQgQnV0dG9uVGFyZ2V0TGlzdCBmcm9tICcuL2J1dHRvbi10YXJnZXQtbGlzdC5qc3gnO1xuaW1wb3J0IEJ1dHRvblR3aXR0ZXIgZnJvbSAnLi9idXR0b24tdHdpdHRlci5qc3gnO1xuaW1wb3J0IEJ1dHRvblVsIGZyb20gJy4vYnV0dG9uLXVsLmpzeCc7XG5pbXBvcnQgQnV0dG9uVW5kZXJsaW5lIGZyb20gJy4vYnV0dG9uLXVuZGVybGluZS5qc3gnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdFtCdXR0b25BY2Nlc3NpYmlsaXR5SW1hZ2VBbHQua2V5XTogQnV0dG9uQWNjZXNzaWJpbGl0eUltYWdlQWx0LFxuXHRbQnV0dG9uQmFja2dyb3VuZENvbG9yLmtleV06IEJ1dHRvbkJhY2tncm91bmRDb2xvcixcblx0W0J1dHRvbkJvbGQua2V5XTogQnV0dG9uQm9sZCxcblx0W0J1dHRvbkNhbWVyYUltYWdlLmtleV06IEJ1dHRvbkNhbWVyYUltYWdlLFxuXHRbQnV0dG9uQ2FtZXJhLmtleV06IEJ1dHRvbkNhbWVyYSxcblx0W0J1dHRvbkNvZGUua2V5XTogQnV0dG9uQ29kZSxcblx0W0J1dHRvbkNvbG9yLmtleV06IEJ1dHRvbkNvbG9yLFxuXHRbQnV0dG9uQ29tbWFuZExpc3RJdGVtLmtleV06IEJ1dHRvbkNvbW1hbmRMaXN0SXRlbSxcblx0W0J1dHRvbkNvbW1hbmRzTGlzdC5rZXldOiBCdXR0b25Db21tYW5kc0xpc3QsXG5cdFtCdXR0b25Ecm9wZG93bi5rZXldOiBCdXR0b25Ecm9wZG93bixcblx0W0J1dHRvbkVtYmVkRWRpdC5rZXldOiBCdXR0b25FbWJlZEVkaXQsXG5cdFtCdXR0b25FbWJlZC5rZXldOiBCdXR0b25FbWJlZCxcblx0W0J1dHRvbkVtYmVkVmlkZW9FZGl0LmtleV06IEJ1dHRvbkVtYmVkVmlkZW9FZGl0LFxuXHRbQnV0dG9uRW1iZWRWaWRlby5rZXldOiBCdXR0b25FbWJlZFZpZGVvLFxuXHRbQnV0dG9uSDEua2V5XTogQnV0dG9uSDEsXG5cdFtCdXR0b25IMi5rZXldOiBCdXR0b25IMixcblx0W0J1dHRvbkhsaW5lLmtleV06IEJ1dHRvbkhsaW5lLFxuXHRbQnV0dG9uSW1hZ2VBbGlnbkNlbnRlci5rZXldOiBCdXR0b25JbWFnZUFsaWduQ2VudGVyLFxuXHRbQnV0dG9uSW1hZ2VBbGlnbkxlZnQua2V5XTogQnV0dG9uSW1hZ2VBbGlnbkxlZnQsXG5cdFtCdXR0b25JbWFnZUFsaWduUmlnaHQua2V5XTogQnV0dG9uSW1hZ2VBbGlnblJpZ2h0LFxuXHRbQnV0dG9uSW1hZ2Uua2V5XTogQnV0dG9uSW1hZ2UsXG5cdFtCdXR0b25JbmRlbnRCbG9jay5rZXldOiBCdXR0b25JbmRlbnRCbG9jayxcblx0W0J1dHRvbkl0YWxpYy5rZXldOiBCdXR0b25JdGFsaWMsXG5cdFtCdXR0b25JdGVtU2VsZWN0b3JBdWRpby5rZXldOiBCdXR0b25JdGVtU2VsZWN0b3JBdWRpbyxcblx0W0J1dHRvbkl0ZW1TZWxlY3RvckltYWdlLmtleV06IEJ1dHRvbkl0ZW1TZWxlY3RvckltYWdlLFxuXHRbQnV0dG9uSXRlbVNlbGVjdG9yVmlkZW8ua2V5XTogQnV0dG9uSXRlbVNlbGVjdG9yVmlkZW8sXG5cdFtCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdC5rZXldOiBCdXR0b25MaW5rQXV0b2NvbXBsZXRlTGlzdCxcblx0W0J1dHRvbkxpbmtCcm93c2Uua2V5XTogQnV0dG9uTGlua0Jyb3dzZSxcblx0W0J1dHRvbkxpbmtFZGl0QnJvd3NlLmtleV06IEJ1dHRvbkxpbmtFZGl0QnJvd3NlLFxuXHRbQnV0dG9uTGlua0VkaXQua2V5XTogQnV0dG9uTGlua0VkaXQsXG5cdFtCdXR0b25MaW5rVGFyZ2V0RWRpdC5rZXldOiBCdXR0b25MaW5rVGFyZ2V0RWRpdCxcblx0W0J1dHRvbkxpbmsua2V5XTogQnV0dG9uTGluayxcblx0W0J1dHRvbk9sLmtleV06IEJ1dHRvbk9sLFxuXHRbQnV0dG9uT3V0ZGVudEJsb2NrLmtleV06IEJ1dHRvbk91dGRlbnRCbG9jayxcblx0W0J1dHRvblBhcmFncmFwaEFsaWduLmtleV06IEJ1dHRvblBhcmFncmFwaEFsaWduLFxuXHRbQnV0dG9uUGFyYWdyYXBoQWxpZ25MZWZ0LmtleV06IEJ1dHRvblBhcmFncmFwaEFsaWduTGVmdCxcblx0W0J1dHRvblBhcmFncmFwaEFsaWduUmlnaHQua2V5XTogQnV0dG9uUGFyYWdyYXBoQWxpZ25SaWdodCxcblx0W0J1dHRvblBhcmFncmFwaENlbnRlci5rZXldOiBCdXR0b25QYXJhZ3JhcGhDZW50ZXIsXG5cdFtCdXR0b25QYXJhZ3JhcGhKdXN0aWZ5LmtleV06IEJ1dHRvblBhcmFncmFwaEp1c3RpZnksXG5cdFtCdXR0b25RdW90ZS5rZXldOiBCdXR0b25RdW90ZSxcblx0W0J1dHRvblJlbW92ZUZvcm1hdC5rZXldOiBCdXR0b25SZW1vdmVGb3JtYXQsXG5cdFtCdXR0b25SZW1vdmVJbWFnZS5rZXldOiBCdXR0b25SZW1vdmVJbWFnZSxcblx0W0J1dHRvblNlcGFyYXRvci5rZXldOiBCdXR0b25TZXBhcmF0b3IsXG5cdFtCdXR0b25TcGFjaW5nLmtleV06IEJ1dHRvblNwYWNpbmcsXG5cdFtCdXR0b25TdHJpa2Uua2V5XTogQnV0dG9uU3RyaWtlLFxuXHRbQnV0dG9uU3R5bGVzTGlzdEhlYWRlci5rZXldOiBCdXR0b25TdHlsZXNMaXN0SGVhZGVyLFxuXHRbQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUua2V5XTogQnV0dG9uU3R5bGVzTGlzdEl0ZW1SZW1vdmUsXG5cdFtCdXR0b25TdHlsZXNMaXN0SXRlbS5rZXldOiBCdXR0b25TdHlsZXNMaXN0SXRlbSxcblx0W0J1dHRvblN0eWxlc0xpc3Qua2V5XTogQnV0dG9uU3R5bGVzTGlzdCxcblx0W0J1dHRvblN0eWxlcy5rZXldOiBCdXR0b25TdHlsZXMsXG5cdFtCdXR0b25TdWJzY3JpcHQua2V5XTogQnV0dG9uU3Vic2NyaXB0LFxuXHRbQnV0dG9uU3VwZXJzY3JpcHQua2V5XTogQnV0dG9uU3VwZXJzY3JpcHQsXG5cdFtCdXR0b25UYWJsZUNlbGwua2V5XTogQnV0dG9uVGFibGVDZWxsLFxuXHRbQnV0dG9uVGFibGVDb2x1bW4ua2V5XTogQnV0dG9uVGFibGVDb2x1bW4sXG5cdFtCdXR0b25UYWJsZUVkaXQua2V5XTogQnV0dG9uVGFibGVFZGl0LFxuXHRbQnV0dG9uVGFibGVIZWFkaW5nLmtleV06IEJ1dHRvblRhYmxlSGVhZGluZyxcblx0W0J1dHRvblRhYmxlUmVtb3ZlLmtleV06IEJ1dHRvblRhYmxlUmVtb3ZlLFxuXHRbQnV0dG9uVGFibGVSb3cua2V5XTogQnV0dG9uVGFibGVSb3csXG5cdFtCdXR0b25UYWJsZS5rZXldOiBCdXR0b25UYWJsZSxcblx0W0J1dHRvblRhcmdldExpc3Qua2V5XTogQnV0dG9uVGFyZ2V0TGlzdCxcblx0W0J1dHRvblR3aXR0ZXIua2V5XTogQnV0dG9uVHdpdHRlcixcblx0W0J1dHRvblVsLmtleV06IEJ1dHRvblVsLFxuXHRbQnV0dG9uVW5kZXJsaW5lLmtleV06IEJ1dHRvblVuZGVybGluZSxcbn07XG4iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFdpZGdldEV4Y2x1c2l2ZSBmcm9tICcuL2Jhc2Uvd2lkZ2V0LWV4Y2x1c2l2ZSc7XG5pbXBvcnQgV2lkZ2V0Rm9jdXNNYW5hZ2VyIGZyb20gJy4vYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlcic7XG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcblxuLyoqXG4gKiBUaGUgbWFpbiBlZGl0b3IgVUkgY2xhc3MgbWFuYWdlcyBhIGhpZXJhcmNoeSBvZiB3aWRnZXRzICh0b29sYmFycyBhbmQgYnV0dG9ucykuXG4gKlxuICogQGNsYXNzIFVJXG4gKiBAdXNlcyBXaWRnZXRFeGNsdXNpdmVcbiAqIEB1c2VzIFdpZGdldEZvY3VzTWFuYWdlclxuICovXG5jbGFzcyBVSSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZXMgb2YgdGhlIHByb3BlcnRpZXMgdXNlZCBpbiB0aGUgd2lkZ2V0LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFVJXG5cdCAqIEBtZXRob2QgZ2V0RGVmYXVsdFByb3BzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cblx0ICovXG5cdHN0YXRpYyBkZWZhdWx0UHJvcHMgPSB7XG5cdFx0Y2lyY3VsYXI6IHRydWUsXG5cdFx0ZGVzY2VuZGFudHM6ICdbY2xhc3NePWFlLXRvb2xiYXItXScsXG5cdFx0ZXZlbnRzRGVsYXk6IDAsXG5cdFx0a2V5czoge1xuXHRcdFx0bmV4dDogOSxcblx0XHR9LFxuXHR9O1xuXG5cdHN0YXRpYyBwcm9wVHlwZXMgPSB7XG5cdFx0LyoqXG5cdFx0ICogTG9jYWxpemVkIG1lc3NhZ2VzIGZvciBsaXZlIGFyaWEgdXBkYXRlcy4gU2hvdWxkIGluY2x1ZGUgdGhlIGZvbGxvd2luZyBtZXNzYWdlczpcblx0XHQgKiAtIG5vVG9vbGJhcjogTm90aWZpY2F0aW9uIGZvciBubyBhdmFpbGFibGUgdG9vbGJhciBpbiB0aGUgZWRpdG9yLlxuXHRcdCAqIC0gb25lVG9vbGJhcjogTm90aWZpY2F0aW9uIGZvciBqdXN0IG9uZSBhdmFpbGFibGUgdG9vbGJhciBpbiB0aGUgZWRpdG9yLlxuXHRcdCAqIC0gbWFueVRvb2xiYXJzOiBOb3RpZmljYXRpb24gZm9yIG1vcmUgdGhhbiBvbmUgYXZhaWxhYmxlIHRvb2xiYXIgaW4gdGhlIGVkaXRvci5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBVSVxuXHRcdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhcmlhVXBkYXRlc1xuXHRcdCAqL1xuXHRcdGFyaWFVcGRhdGVzOiBQcm9wVHlwZXMub2JqZWN0LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGRlbGF5IChtcyksIGFmdGVyIHdoaWNoIGtleSBvciBtb3VzZSBldmVudHMgd2lsbCBiZSBwcm9jZXNzZWQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgVUlcblx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gZXZlbnRzRGVsYXlcblx0XHQgKi9cblx0XHRldmVudHNEZWxheTogUHJvcFR5cGVzLm51bWJlcixcblxuXHRcdC8qKlxuXHRcdCAqIFRoZSB0b29sYmFycyBjb25maWd1cmF0aW9uIGZvciB0aGlzIGVkaXRvciBpbnN0YW5jZVxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFVJXG5cdFx0ICogQHByb3BlcnR5IHtPYmplY3R9IHRvb2xiYXJzXG5cdFx0ICovXG5cdFx0dG9vbGJhcnM6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcblx0fTtcblxuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdHRoaXMuc3RhdGUgPSB7XG5cdFx0XHRoaWRkZW46IGZhbHNlLFxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIG9uY2UsIG9ubHkgb24gdGhlIGNsaWVudCwgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBVSVxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRlZGl0b3Iub24oJ2VkaXRvckludGVyYWN0aW9uJywgdGhpcy5fb25FZGl0b3JJbnRlcmFjdGlvbiwgdGhpcyk7XG5cdFx0ZWRpdG9yLm9uKCdhY3Rpb25QZXJmb3JtZWQnLCB0aGlzLl9vbkFjdGlvblBlcmZvcm1lZCwgdGhpcyk7XG5cdFx0ZWRpdG9yLm9uKCdrZXknLCB0aGlzLl9vbkVkaXRvcktleSwgdGhpcyk7XG5cblx0XHQvLyBTZXQgdXAgZXZlbnRzIGZvciBoaWRpbmcgdGhlIFVJIHdoZW4gdXNlciBzdG9wcyBpbnRlcmFjdGluZyB3aXRoIHRoZSBlZGl0b3IuXG5cdFx0Ly8gVGhpcyBtYXkgaGFwcGVuIHdoZW4gaGUganVzdCBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgZWRpdG9yLiBIb3dldmVyLFxuXHRcdC8vIHRoaXMgZG9lcyBub3QgaW5jbHVkZSBhIHNpdHVhdGlvbiB3aGVuIGhlIGNsaWNrcyBvbiBzb21lIGJ1dHRvbiwgcGFydCBvZlxuXHRcdC8vIGVkaXRvcidzIFVJLlxuXG5cdFx0Ly8gSXQgaXMgbm90IGVhc3kgdG8gZGVib3VuY2UgX3NldFVJSGlkZGVuIG9uIG1vdXNlZG93biwgYmVjYXVzZSBpZiB3ZVxuXHRcdC8vIGRlYm91bmNlIGl0LCB3aGVuIHRoZSBoYW5kbGVyIGlzIGJlaW5nIGludm9rZWQsIHRoZSB0YXJnZXQgbWlnaHQgYmUgbm8gbW9yZSBwYXJ0XG5cdFx0Ly8gb2YgdGhlIGVkaXRvcidzIFVJIC0gb25BY3Rpb25QZXJmb3JtZWQgY2F1c2VzIHJlLXJlbmRlci5cblx0XHR0aGlzLl9tb3VzZWRvd25MaXN0ZW5lciA9IGV2ZW50ID0+IHtcblx0XHRcdHRoaXMuX3NldFVJSGlkZGVuKGV2ZW50LnRhcmdldCk7XG5cdFx0fTtcblxuXHRcdHRoaXMuX2tleURvd25MaXN0ZW5lciA9IENLRURJVE9SLnRvb2xzLmRlYm91bmNlKFxuXHRcdFx0X2V2ZW50ID0+IHtcblx0XHRcdFx0dGhpcy5fc2V0VUlIaWRkZW4oZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG5cdFx0XHR9LFxuXHRcdFx0dGhpcy5wcm9wcy5ldmVudHNEZWxheSxcblx0XHRcdHRoaXNcblx0XHQpO1xuXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fbW91c2Vkb3duTGlzdGVuZXIpO1xuXHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9rZXlEb3duTGlzdGVuZXIpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50J3MgdXBkYXRlcyBhcmUgZmx1c2hlZCB0byB0aGUgRE9NLlxuXHQgKiBGaXJlcyBgYXJpYVVwZGF0ZWAgZXZlbnQgcGFzc2luZyBBUklBIHJlbGF0ZWQgbWVzc2FnZXMuXG5cdCAqIEZpcmVzIGBlZGl0b3JVcGRhdGVgIGV2ZW50IHBhc3NpbmcgdGhlIHByZXZpb3VzIGFuZCBjdXJyZW50IHByb3BlcnRpZXMgYW5kIHN0YXRlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFVJXG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkVXBkYXRlXG5cdCAqL1xuXHRjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcblx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRpZiAoZG9tTm9kZSkge1xuXHRcdFx0ZWRpdG9yLmZpcmUoJ2FyaWFVcGRhdGUnLCB7XG5cdFx0XHRcdG1lc3NhZ2U6IHRoaXMuX2dldEF2YWlsYWJsZVRvb2xiYXJzTWVzc2FnZShkb21Ob2RlKSxcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGVkaXRvci5maXJlKCdlZGl0b3JVcGRhdGUnLCB7XG5cdFx0XHRwcmV2UHJvcHMsXG5cdFx0XHRwcmV2U3RhdGUsXG5cdFx0XHRwcm9wczogdGhpcy5wcm9wcyxcblx0XHRcdHN0YXRlOiB0aGlzLnN0YXRlLFxuXHRcdH0pO1xuXHR9XG5cblx0X2dldEFyaWFVcGRhdGVUZW1wbGF0ZShhcmlhVXBkYXRlKSB7XG5cdFx0aWYgKCF0aGlzLl9hcmlhVXBkYXRlVGVtcGxhdGVzKSB7XG5cdFx0XHR0aGlzLl9hcmlhVXBkYXRlVGVtcGxhdGVzID0ge307XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9hcmlhVXBkYXRlVGVtcGxhdGVzW2FyaWFVcGRhdGVdKSB7XG5cdFx0XHR0aGlzLl9hcmlhVXBkYXRlVGVtcGxhdGVzW2FyaWFVcGRhdGVdID0gbmV3IENLRURJVE9SLnRlbXBsYXRlKFxuXHRcdFx0XHR0aGlzLl9nZXRBcmlhVXBkYXRlcygpW2FyaWFVcGRhdGVdXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9hcmlhVXBkYXRlVGVtcGxhdGVzW2FyaWFVcGRhdGVdO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRlbXBsYXRlcyBmb3IgQVJJQSBtZXNzYWdlcy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBVSVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX2dldEFyaWFVcGRhdGVzXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQVJJQSByZWxhdGVzIG1lc3NhZ2VzLiBEZWZhdWx0OlxuXHQgKiB7XG5cdCAqICAgICAgbm9Ub29sYmFyOiBBbGxveUVkaXRvci5TdHJpbmdzLmFyaWFVcGRhdGVOb1Rvb2xiYXIsXG5cdCAqICAgICAgb25lVG9vbGJhcjogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlT25lVG9vbGJhcixcblx0ICogICAgICBtYW55VG9vbGJhcnM6IEFsbG95RWRpdG9yLlN0cmluZ3MuYXJpYVVwZGF0ZU1hbnlUb29sYmFyc1xuXHQgKiAgfVxuXHQgKi9cblx0X2dldEFyaWFVcGRhdGVzKCkge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLnByb3BzLmFyaWFVcGRhdGVzIHx8IHtcblx0XHRcdFx0bm9Ub29sYmFyOiBBbGxveUVkaXRvci5TdHJpbmdzLmFyaWFVcGRhdGVOb1Rvb2xiYXIsXG5cdFx0XHRcdG9uZVRvb2xiYXI6IEFsbG95RWRpdG9yLlN0cmluZ3MuYXJpYVVwZGF0ZU9uZVRvb2xiYXIsXG5cdFx0XHRcdG1hbnlUb29sYmFyczogQWxsb3lFZGl0b3IuU3RyaW5ncy5hcmlhVXBkYXRlTWFueVRvb2xiYXJzLFxuXHRcdFx0fVxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhbiBBUklBIG1lc3NhZ2Ugd2hpY2ggcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIGN1cnJlbnRseSBhdmFpbGFibGUgdG9vbGJhcnMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVUlcblx0ICogQG1ldGhvZCBfZ2V0QXZhaWxhYmxlVG9vbGJhcnNNZXNzYWdlXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZG9tTm9kZSBUaGUgRE9NIG5vZGUgZnJvbSB3aGljaCB0aGUgYXZhaWxhYmxlIHRvb2xiYXJzIHdpbGwgYmUgcmV0cmlldmVkLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBBUklBIG1lc3NhZ2UgZm9yIHRoZSBudW1iZXIgb2YgYXZhaWxhYmxlIHRvb2xiYXJzXG5cdCAqL1xuXHRfZ2V0QXZhaWxhYmxlVG9vbGJhcnNNZXNzYWdlKGRvbU5vZGUpIHtcblx0XHRjb25zdCB0b29sYmFyc05vZGVMaXN0ID0gZG9tTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT1cInRvb2xiYXJcIl0nKTtcblxuXHRcdGlmICghdG9vbGJhcnNOb2RlTGlzdC5sZW5ndGgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9nZXRBcmlhVXBkYXRlcygpLm5vVG9vbGJhcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgdG9vbGJhck5hbWVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlXG5cdFx0XHRcdC5jYWxsKHRvb2xiYXJzTm9kZUxpc3QpXG5cdFx0XHRcdC5tYXAodG9vbGJhciA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIHRvb2xiYXIuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRjb25zdCBhcmlhVXBkYXRlID1cblx0XHRcdFx0dG9vbGJhck5hbWVzLmxlbmd0aCA9PT0gMSA/ICdvbmVUb29sYmFyJyA6ICdtYW55VG9vbGJhcnMnO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5fZ2V0QXJpYVVwZGF0ZVRlbXBsYXRlKGFyaWFVcGRhdGUpLm91dHB1dCh7XG5cdFx0XHRcdHRvb2xiYXJzOiB0b29sYmFyTmFtZXNcblx0XHRcdFx0XHQuam9pbignLCcpXG5cdFx0XHRcdFx0LnJlcGxhY2UoLywoW14sXSopJC8sICcgYW5kICcgKyAnJDEnKSxcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgaW1tZWRpYXRlbHkgYmVmb3JlIGEgY29tcG9uZW50IGlzIHVubW91bnRlZCBmcm9tIHRoZSBET00uXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVUlcblx0ICogQG1ldGhvZCBjb21wb25lbnRXaWxsVW5tb3VudFxuXHQgKi9cblx0Y29tcG9uZW50V2lsbFVubW91bnQoKSB7XG5cdFx0aWYgKHRoaXMuX21vdXNlZG93bkxpc3RlbmVyKSB7XG5cdFx0XHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9tb3VzZWRvd25MaXN0ZW5lcik7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuX2tleURvd25MaXN0ZW5lcikge1xuXHRcdFx0dGhpcy5fa2V5RG93bkxpc3RlbmVyLmRldGFjaCgpO1xuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2tleURvd25MaXN0ZW5lcik7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgVUkgb2YgdGhlIGVkaXRvci4gVGhpcyBtYXkgaW5jbHVkZSBzZXZlcmFsIHRvb2xiYXJzIGFuZCBidXR0b25zLlxuXHQgKiBUaGUgZWRpdG9yJ3MgVUkgYWxzbyB0YWtlcyBjYXJlIG9mIHJlbmRlcmluZyB0aGUgaXRlbXMgaW4gZXhjbHVzaXZlIG1vZGUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVUlcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0aWYgKHRoaXMuc3RhdGUuaGlkZGVuKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRsZXQgdG9vbGJhcnMgPSBPYmplY3Qua2V5cyh0aGlzLnByb3BzLnRvb2xiYXJzKS5tYXAodG9vbGJhciA9PiB7XG5cdFx0XHRyZXR1cm4gQWxsb3lFZGl0b3IuVG9vbGJhcnNbdG9vbGJhcl0gfHwgd2luZG93W3Rvb2xiYXJdO1xuXHRcdH0pO1xuXG5cdFx0dG9vbGJhcnMgPSB0aGlzLmZpbHRlckV4Y2x1c2l2ZSh0b29sYmFycykubWFwKHRvb2xiYXIgPT4ge1xuXHRcdFx0Y29uc3QgcHJvcHMgPSB0aGlzLm1lcmdlRXhjbHVzaXZlUHJvcHMoXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjb25maWc6IHRoaXMucHJvcHMudG9vbGJhcnNbdG9vbGJhci5rZXldLFxuXHRcdFx0XHRcdGVkaXRvcjogdGhpcy5jb250ZXh0LmVkaXRvcixcblx0XHRcdFx0XHRlZGl0b3JFdmVudDogdGhpcy5zdGF0ZS5lZGl0b3JFdmVudCxcblx0XHRcdFx0XHRrZXk6IHRvb2xiYXIua2V5LFxuXHRcdFx0XHRcdG9uRGlzbWlzczogdGhpcy5fb25EaXNtaXNzVG9vbGJhckZvY3VzLFxuXHRcdFx0XHRcdHNlbGVjdGlvbkRhdGE6IHRoaXMuc3RhdGUuc2VsZWN0aW9uRGF0YSxcblx0XHRcdFx0fSxcblx0XHRcdFx0dG9vbGJhci5rZXlcblx0XHRcdCk7XG5cblx0XHRcdHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHRvb2xiYXIsIHByb3BzKTtcblx0XHR9KTtcblxuXHRcdHJldHVybiAoXG5cdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLXRvb2xiYXJzXCIgb25LZXlEb3duPXt0aGlzLmhhbmRsZUtleX0+XG5cdFx0XHRcdHt0b29sYmFyc31cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlzdGVuZXIgdG8gdGhlIGVkaXRvcidzIGBhY3Rpb25QZXJmb3JtZWRgIGV2ZW50LiBTZXRzIHN0YXRlIGFuZCByZWRyYXdzIHRoZSBVSSBvZiB0aGUgZWRpdG9yLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFVJXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfb25BY3Rpb25QZXJmb3JtZWRcblx0ICogQHBhcmFtIHtTeW50ZXRpY0V2ZW50fSBldmVudCBUaGUgcHJvdmlkZWQgZXZlbnRcblx0ICovXG5cdF9vbkFjdGlvblBlcmZvcm1lZChfZXZlbnQpIHtcblx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRlZGl0b3IuZm9jdXMoKTtcblxuXHRcdHRoaXMuc2V0U3RhdGUoe1xuXHRcdFx0aXRlbUV4Y2x1c2l2ZTogbnVsbCxcblx0XHRcdHNlbGVjdGlvbkRhdGE6IGVkaXRvci5nZXRTZWxlY3Rpb25EYXRhKCksXG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogRXhlY3V0ZWQgd2hlbiBhIGRpc21pc3Mga2V5IGlzIHByZXNzZWQgb3ZlciBhIHRvb2xiYXIgdG8gcmV0dXJuIHRoZSBmb2N1cyB0byB0aGUgZWRpdG9yLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFVJXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfb25EaXNtaXNzVG9vbGJhckZvY3VzXG5cdCAqL1xuXHRfb25EaXNtaXNzVG9vbGJhckZvY3VzID0gKCkgPT4ge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdGVkaXRvci5mb2N1cygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBMaXN0ZW5lciB0byB0aGUgZWRpdG9yJ3MgYHVzZXJJbnRlcmFjdGlvbmAgZXZlbnQuIFJldHJpZXZlcyB0aGUgZGF0YSBhYm91dCB0aGUgdXNlciBzZWxlY3Rpb24gYW5kXG5cdCAqIHByb3ZpZGVzIGl0IHZpYSBjb21wb25lbnQncyBzdGF0ZSBwcm9wZXJ0eS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBVSVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX29uRWRpdG9ySW50ZXJhY3Rpb25cblx0ICogQHBhcmFtIHtTeW50ZXRpY0V2ZW50fSBldmVudCBUaGUgcHJvdmlkZWQgZXZlbnRcblx0ICovXG5cdF9vbkVkaXRvckludGVyYWN0aW9uKGV2ZW50KSB7XG5cdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRlZGl0b3JFdmVudDogZXZlbnQsXG5cdFx0XHRoaWRkZW46IGZhbHNlLFxuXHRcdFx0aXRlbUV4Y2x1c2l2ZTogbnVsbCxcblx0XHRcdHNlbGVjdGlvbkRhdGE6IGV2ZW50LmRhdGEuc2VsZWN0aW9uRGF0YSxcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGb2N1c2VzIG9uIHRoZSBhY3RpdmUgdG9vbGJhciB3aGVuIHRoZSBjb21iaW5hdGlvbiBBTFQrRjEwIGlzIHByZXNzZWQgaW5zaWRlIHRoZSBlZGl0b3IuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVUlcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAbWV0aG9kIF9vbkVkaXRvcktleVxuXHQgKi9cblx0X29uRWRpdG9yS2V5KGV2ZW50KSB7XG5cdFx0Y29uc3QgbmF0aXZlRXZlbnQgPSBldmVudC5kYXRhLmRvbUV2ZW50LiQ7XG5cblx0XHRpZiAobmF0aXZlRXZlbnQuYWx0S2V5ICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IDEyMSkge1xuXHRcdFx0dGhpcy5mb2N1cygpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgdGhlIHRhcmdldCB3aXRoIHdoaWNoIHRoZSB1c2VyIGludGVyYWN0ZWQgaXMgcGFydCBvZiBlZGl0b3IncyBVSSBvciBpdCBpc1xuXHQgKiB0aGUgZWRpdGFibGUgYXJlYS4gSWYgbm9uZSBvZiB0aGVzZSwgc2V0cyB0aGUgc3RhdGUgb2YgZWRpdG9yJ3MgVUkgdG8gYmUgaGlkZGVuLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFVJXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQG1ldGhvZCBfc2V0VUlIaWRkZW5cblx0ICogQHBhcmFtIHtET01FbGVtZW50fSB0YXJnZXQgVGhlIERPTSBlbGVtZW50IHdpdGggd2hpY2ggdXNlciBpbnRlcmFjdGVkIGxhc3RseS5cblx0ICovXG5cdF9zZXRVSUhpZGRlbih0YXJnZXQpIHtcblx0XHRjb25zdCBkb21Ob2RlID0gUmVhY3RET00uZmluZERPTU5vZGUodGhpcyk7XG5cblx0XHRpZiAoZG9tTm9kZSkge1xuXHRcdFx0Y29uc3QgZWRpdGFibGUgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJykuZWRpdGFibGUoKTtcblx0XHRcdGNvbnN0IHBhcmVudE5vZGUgPSB0YXJnZXQucGFyZW50Tm9kZTtcblx0XHRcdGNvbnN0IHRhcmdldE5vZGUgPSBuZXcgQ0tFRElUT1IuZG9tLm5vZGUodGFyZ2V0KTtcblxuXHRcdFx0aWYgKCFlZGl0YWJsZSkge1xuXHRcdFx0XHR0aGlzLnNldFN0YXRlKHtcblx0XHRcdFx0XHRoaWRkZW46IHRydWUsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGV0IHJlcyA9XG5cdFx0XHRcdFx0ZWRpdGFibGUuJCA9PT0gdGFyZ2V0IHx8XG5cdFx0XHRcdFx0ZWRpdGFibGUuY29udGFpbnModGFyZ2V0Tm9kZSkgfHxcblx0XHRcdFx0XHRuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoZG9tTm9kZSkuY29udGFpbnModGFyZ2V0Tm9kZSk7XG5cblx0XHRcdFx0aWYgKHBhcmVudE5vZGUpIHtcblx0XHRcdFx0XHRyZXMgPSByZXMgfHwgcGFyZW50Tm9kZS5pZCA9PT0gJ2NraW1ncnN6Jztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICghcmVzKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRcdFx0XHRoaWRkZW46IHRydWUsXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBGaXJlZCB3aGVuIGNvbXBvbmVudCB1cGRhdGVzIGFuZCB3aGVuIGl0IGlzIHJlbmRlcmVkIGluIHRoZSBET00uXG4gKiBUaGUgcGF5bG9hZCBjb25zaXN0cyBmcm9tIGEgYG1lc3NhZ2VgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhlIEFSSUEgbWVzc2FnZS5cbiAqXG4gKiBAZXZlbnQgYXJpYVVwZGF0ZVxuICovXG5cbi8qKlxuICogRmlyZWQgd2hlbiBjb21wb25lbnQgdXBkYXRlcy4gVGhlIHBheWxvYWQgY29uc2lzdHMgZnJvbSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICogLSBwcmV2UHJvcHMgLSBUaGUgcHJldmlvdXMgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50XG4gKiAtIHByZXZTdGF0ZSAtIFRoZSBwcmV2aW91cyBzdGF0ZSBvZiB0aGUgY29tcG9uZW50XG4gKiAtIHByb3BzIC0gVGhlIGN1cnJlbnQgcHJvcGVydGllcyBvZiB0aGUgY29tcG9uZW50XG4gKiAtIHN0YXRlIC0gVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNvbXBvbmVudFxuICpcbiAqIEBldmVudCBhcmlhVXBkYXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0RXhjbHVzaXZlKFdpZGdldEZvY3VzTWFuYWdlcihVSSkpO1xuIiwiaW1wb3J0IFRvb2xiYXJBZGQgZnJvbSAnLi90b29sYmFyLWFkZC5qc3gnO1xuaW1wb3J0IFRvb2xiYXJTdHlsZXMgZnJvbSAnLi90b29sYmFyLXN0eWxlcy5qc3gnO1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdFtUb29sYmFyQWRkLmtleV06IFRvb2xiYXJBZGQsXG5cdFtUb29sYmFyU3R5bGVzLmtleV06IFRvb2xiYXJTdHlsZXMsXG59O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgVG9vbGJhckJ1dHRvbnMgZnJvbSAnLi4vYmFzZS90b29sYmFyLWJ1dHRvbnMnO1xuaW1wb3J0IFdpZGdldEFycm93Qm94IGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWFycm93LWJveCc7XG5pbXBvcnQgV2lkZ2V0RHJvcGRvd24gZnJvbSAnLi4vYmFzZS93aWRnZXQtZHJvcGRvd24nO1xuaW1wb3J0IFdpZGdldEV4Y2x1c2l2ZSBmcm9tICcuLi9iYXNlL3dpZGdldC1leGNsdXNpdmUnO1xuaW1wb3J0IFdpZGdldEZvY3VzTWFuYWdlciBmcm9tICcuLi9iYXNlL3dpZGdldC1mb2N1cy1tYW5hZ2VyJztcbmltcG9ydCBXaWRnZXRQb3NpdGlvbiBmcm9tICcuLi9iYXNlL3dpZGdldC1wb3NpdGlvbic7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuLi9idXR0b25zL2J1dHRvbi1pY29uLmpzeCc7XG5cbmNvbnN0IFBPU0lUSU9OX0xFRlQgPSAxO1xuY29uc3QgUE9TSVRJT05fUklHSFQgPSAyO1xuXG4vKipcbiAqIFRoZSBUb29sYmFyQWRkIGNsYXNzIHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIGFkZGluZyBjb250ZW50IHRvIHRoZSBlZGl0b3IuXG4gKlxuICogQGNsYXNzIFRvb2xiYXJBZGRcbiAqIEB1c2VzIFRvb2xiYXJCdXR0b25zXG4gKiBAdXNlcyBXaWRnZXRBcnJvd0JveFxuICogQHVzZXMgV2lkZ2V0RHJvcGRvd25cbiAqIEB1c2VzIFdpZGdldEV4Y2x1c2l2ZVxuICogQHVzZXMgV2lkZ2V0Rm9jdXNNYW5hZ2VyXG4gKiBAdXNlcyBXaWRnZXRQb3NpdGlvblxuICovXG5jbGFzcyBUb29sYmFyQWRkIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRjb25zdHJ1Y3Rvcihwcm9wcykge1xuXHRcdHN1cGVyKHByb3BzKTtcblxuXHRcdHRoaXMuc3RhdGUgPSB7fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBMaWZlY3ljbGUuIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50IChub3Qgb24gdGhlIHNlcnZlciksXG5cdCAqIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZE1vdW50XG5cdCAqL1xuXHRjb21wb25lbnREaWRNb3VudCgpIHtcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgY29tcG9uZW50J3MgdXBkYXRlcyBhcmUgZmx1c2hlZCB0byB0aGUgRE9NLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBub3QgY2FsbGVkIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuXHQgKiBAbWV0aG9kIGNvbXBvbmVudERpZFVwZGF0ZVxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJldlByb3BzIFRoZSBwcmV2aW91cyBzdGF0ZSBvZiB0aGUgY29tcG9uZW50J3MgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IHByZXZTdGF0ZSBDb21wb25lbnQncyBwcmV2aW91cyBzdGF0ZS5cblx0ICovXG5cdGNvbXBvbmVudERpZFVwZGF0ZShfcHJldlByb3BzLCBfcHJldlN0YXRlKSB7XG5cdFx0dGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblxuXHRcdC8vIEluIGNhc2Ugb2YgZXhjbHVzaXZlIHJlbmRlcmluZywgZm9jdXMgdGhlIGZpcnN0IGRlc2NlbmRhbnQgKGJ1dHRvbilcblx0XHQvLyBzbyB0aGUgdXNlciB3aWxsIGJlIGFibGUgdG8gc3RhcnQgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgYnV0dG9ucyBpbW1lZGlhdGVseS5cblx0XHRpZiAodGhpcy5wcm9wcy5yZW5kZXJFeGNsdXNpdmUpIHtcblx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBSZW5kZXJzIHRoZSBidXR0b25zIGZvciBhZGRpbmcgY29udGVudCBvciBoaWRlcyB0aGUgdG9vbGJhclxuXHQgKiBpZiB1c2VyIGludGVyYWN0ZWQgd2l0aCBhIG5vbi1lZGl0YWJsZSBlbGVtZW50LlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcblx0ICogQG1ldGhvZCByZW5kZXJcblx0ICogQHJldHVybiB7T2JqZWN0fG51bGx9IFRoZSBjb250ZW50IHdoaWNoIHNob3VsZCBiZSByZW5kZXJlZC5cblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHQvLyBTb21lIG9wZXJhdGlvbnMgc3VjaCBhcyBgcmVxdWVzdEV4Y2x1c2l2ZWAgbWF5IGZvcmNlIGVkaXRvciB0byBibHVyIHdoaWNoIHdpbGxcblx0XHQvLyBpbnZhbGlkYXRlIHRoZSBgcHJvcHMuZWRpdG9yRXZlbnRgIHN0b3JlZCB2YWx1ZSwgd2l0aG91dCBjYXVzaW5nIGEgYHByb3BzYCBjaGFuZ2UuXG5cdFx0Ly8gRm9yIGV4YW1wbGUsIGlmIHRoZSBlZGl0b3IgaXMgZW1wdHksIGBhZV9wbGFjZWhvbGRlcmAgcGx1Z2luIHdpbGwgcmVtb3ZlXG5cdFx0Ly8gdGhlIHRhcmdldCBmcm9tIHRoZSBET00gYW5kIHdpbGwgcHJldmVudCBgYWRkYCB0b29sYmFyIGZyb20gcmVuZGVyaW5nLlxuXHRcdC8vXG5cdFx0Ly8gSXQgc2hvdWxkIGJlIHNhZmUgdG8gYXNzdW1lIHRoYXQgaWYgeW91IGhhdmUgYmVlbiBhYmxlIHRvIHJlbmRlciB0aGUgdG9vbGJhclxuXHRcdC8vIGFuZCByZXF1ZXN0IHRoZSBleGNsdXNpdmUgbW9kZSwgdGhlbiByZW5kZXJpbmcgbWlnaHQgYmUga2VwdCB1bnRpbCB0aGUgZXhjbHVzaXZlIG1vZGUgaXMgbGVmdC5cblx0XHRpZiAoXG5cdFx0XHQhdGhpcy5zdGF0ZS5pdGVtRXhjbHVzaXZlICYmXG5cdFx0XHR0aGlzLnByb3BzLmVkaXRvckV2ZW50ICYmXG5cdFx0XHR0aGlzLnByb3BzLmVkaXRvckV2ZW50LmRhdGEubmF0aXZlRXZlbnQudGFyZ2V0ICYmXG5cdFx0XHQhdGhpcy5wcm9wcy5lZGl0b3JFdmVudC5kYXRhLm5hdGl2ZUV2ZW50LnRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0Y29uc3QgYnV0dG9ucyA9IHRoaXMuX2dldEJ1dHRvbnMoKTtcblx0XHRjb25zdCBjbGFzc05hbWUgPSB0aGlzLl9nZXRUb29sYmFyQ2xhc3NOYW1lKCk7XG5cblx0XHRyZXR1cm4gKFxuXHRcdFx0PGRpdlxuXHRcdFx0XHRhcmlhLWxhYmVsPXtBbGxveUVkaXRvci5TdHJpbmdzLmFkZH1cblx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc05hbWV9XG5cdFx0XHRcdGRhdGEtdGFiaW5kZXg9e3RoaXMucHJvcHMuY29uZmlnLnRhYkluZGV4IHx8IDB9XG5cdFx0XHRcdG9uRm9jdXM9e3RoaXMuZm9jdXMuYmluZCh0aGlzKX1cblx0XHRcdFx0b25LZXlEb3duPXt0aGlzLmhhbmRsZUtleS5iaW5kKHRoaXMpfVxuXHRcdFx0XHRyb2xlPVwidG9vbGJhclwiXG5cdFx0XHRcdHRhYkluZGV4PVwiLTFcIj5cblx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXJcIj57YnV0dG9uc308L2Rpdj5cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyBhIGxpc3Qgb2YgYnV0dG9ucyB0aGF0IHdpbGwgZXZlbnR1YWxseSByZW5kZXIgdG8gSFRNTC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG5cdCAqIEBtZXRob2QgX2dldEJ1dHRvbnNcblx0ICogQHByb3RlY3RlZFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBidXR0b25zIHdoaWNoIGhhdmUgdG8gYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRfZ2V0QnV0dG9ucygpIHtcblx0XHRsZXQgYnV0dG9ucztcblxuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0YnV0dG9ucyA9IHRoaXMuZ2V0VG9vbGJhckJ1dHRvbnModGhpcy5wcm9wcy5jb25maWcuYnV0dG9ucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGEgJiYgdGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhLnJlZ2lvbikge1xuXHRcdFx0XHRidXR0b25zID0gKFxuXHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdGFyaWEtbGFiZWw9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWRkfVxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lPVwiYWUtYnV0dG9uIGFlLWJ1dHRvbi1hZGRcIlxuXHRcdFx0XHRcdFx0b25DbGljaz17dGhpcy5wcm9wcy5yZXF1ZXN0RXhjbHVzaXZlLmJpbmQoXG5cdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFRvb2xiYXJBZGQua2V5XG5cdFx0XHRcdFx0XHQpfVxuXHRcdFx0XHRcdFx0dGl0bGU9e0FsbG95RWRpdG9yLlN0cmluZ3MuYWRkfT5cblx0XHRcdFx0XHRcdDxCdXR0b25JY29uIHN5bWJvbD1cInBsdXNcIiAvPlxuXHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBidXR0b25zO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNsYXNzIG5hbWUgb2YgdGhlIHRvb2xiYXIgaW4gY2FzZSBvZiBib3RoIGV4Y2x1c2l2ZSBhbmQgbm9ybWFsIG1vZGUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuXHQgKiBAbWV0aG9kIF9nZXRUb29sYmFyQ2xhc3NOYW1lXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgY2xhc3MgbmFtZSB3aGljaCBoYXZlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIERPTSBlbGVtZW50LlxuXHQgKi9cblx0X2dldFRvb2xiYXJDbGFzc05hbWUoKSB7XG5cdFx0bGV0IGNzc0NsYXNzID0gJ2FlLXRvb2xiYXItYWRkJztcblxuXHRcdGlmICh0aGlzLnByb3BzLnJlbmRlckV4Y2x1c2l2ZSkge1xuXHRcdFx0Y3NzQ2xhc3MgPSAnYWUtdG9vbGJhciAnICsgdGhpcy5nZXRBcnJvd0JveENsYXNzZXMoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY3NzQ2xhc3M7XG5cdH1cblxuXHQvKipcblx0ICogQ2FsY3VsYXRlcyBhbmQgc2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2xiYXIgaW4gZXhjbHVzaXZlIG9yIG5vcm1hbCBtb2RlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFRvb2xiYXJBZGRcblx0ICogQG1ldGhvZCBfdXBkYXRlUG9zaXRpb25cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X3VwZGF0ZVBvc2l0aW9uKCkge1xuXHRcdGxldCByZWdpb247XG5cblx0XHQvLyBJZiBjb21wb25lbnQgaXMgbm90IG1vdW50ZWQsIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG9cblx0XHRpZiAoIVJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMucHJvcHMucmVuZGVyRXhjbHVzaXZlKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XG5cdFx0XHR0aGlzLnNob3coKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHRoaXMucHJvcHMuc2VsZWN0aW9uRGF0YSkge1xuXHRcdFx0XHRyZWdpb24gPSB0aGlzLnByb3BzLnNlbGVjdGlvbkRhdGEucmVnaW9uO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVnaW9uKSB7XG5cdFx0XHRcdGNvbnN0IGRvbU5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcblxuXHRcdFx0XHRjb25zdCBkb21FbGVtZW50ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGRvbU5vZGUpO1xuXG5cdFx0XHRcdGNvbnN0IHN0YXJ0UmVjdCA9IHJlZ2lvbi5zdGFydFJlY3QgfHwgcmVnaW9uO1xuXG5cdFx0XHRcdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0XHRjb25zdCBjbGllbnRSZWN0ID0gbmF0aXZlRWRpdG9yLmVkaXRhYmxlKCkuZ2V0Q2xpZW50UmVjdCgpO1xuXG5cdFx0XHRcdGxldCBvZmZzZXRMZWZ0O1xuXG5cdFx0XHRcdGNvbnN0IHBvc2l0aW9uID1cblx0XHRcdFx0XHR0aGlzLnByb3BzLmNvbmZpZy5wb3NpdGlvbiB8fCB0aGlzLnByb3BzLnBvc2l0aW9uO1xuXG5cdFx0XHRcdGlmIChwb3NpdGlvbiA9PT0gUE9TSVRJT05fTEVGVCkge1xuXHRcdFx0XHRcdG9mZnNldExlZnQgPVxuXHRcdFx0XHRcdFx0Y2xpZW50UmVjdC5sZWZ0IC1cblx0XHRcdFx0XHRcdGRvbU5vZGUub2Zmc2V0V2lkdGggLVxuXHRcdFx0XHRcdFx0dGhpcy5wcm9wcy5ndXR0ZXJFeGNsdXNpdmUubGVmdCArXG5cdFx0XHRcdFx0XHQncHgnO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG9mZnNldExlZnQgPVxuXHRcdFx0XHRcdFx0Y2xpZW50UmVjdC5yaWdodCArXG5cdFx0XHRcdFx0XHR0aGlzLnByb3BzLmd1dHRlckV4Y2x1c2l2ZS5sZWZ0ICtcblx0XHRcdFx0XHRcdCdweCc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkb21Ob2RlLnN0eWxlLmxlZnQgPSBvZmZzZXRMZWZ0O1xuXG5cdFx0XHRcdGRvbU5vZGUuc3R5bGUudG9wID1cblx0XHRcdFx0XHRNYXRoLmZsb29yKChyZWdpb24uYm90dG9tICsgcmVnaW9uLnRvcCkgLyAyKSArICdweCc7XG5cblx0XHRcdFx0Y29uc3QgdWlOb2RlID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ3VpTm9kZScpO1xuXG5cdFx0XHRcdGNvbnN0IHNjcm9sbFRvcCA9IHVpTm9kZSA/IHVpTm9kZS5zY3JvbGxUb3AgOiAwO1xuXG5cdFx0XHRcdGlmIChuYXRpdmVFZGl0b3IuZWxlbWVudC5nZXRTdHlsZSgnb3ZlcmZsb3cnKSAhPT0gJ2F1dG8nKSB7XG5cdFx0XHRcdFx0ZG9tTm9kZS5zdHlsZS50b3AgPVxuXHRcdFx0XHRcdFx0TWF0aC5mbG9vcihcblx0XHRcdFx0XHRcdFx0cmVnaW9uLnRvcCAtXG5cdFx0XHRcdFx0XHRcdFx0ZG9tTm9kZS5vZmZzZXRIZWlnaHQgLyAyICtcblx0XHRcdFx0XHRcdFx0XHRzdGFydFJlY3QuaGVpZ2h0IC8gMiArXG5cdFx0XHRcdFx0XHRcdFx0c2Nyb2xsVG9wXG5cdFx0XHRcdFx0XHQpICsgJ3B4Jztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkb21Ob2RlLnN0eWxlLnRvcCA9XG5cdFx0XHRcdFx0XHRNYXRoLmZsb29yKFxuXHRcdFx0XHRcdFx0XHRuYXRpdmVFZGl0b3IuZWxlbWVudC4kLm9mZnNldFRvcCArXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnRSZWN0LmhlaWdodCAvIDIgLVxuXHRcdFx0XHRcdFx0XHRcdGRvbU5vZGUub2Zmc2V0SGVpZ2h0IC8gMlxuXHRcdFx0XHRcdFx0KSArICdweCc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkb21Ob2RlLnN0eWxlLm9wYWNpdHkgPSAxO1xuXG5cdFx0XHRcdGRvbUVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2FlLWFycm93LWJveCcpO1xuXG5cdFx0XHRcdHRoaXMuY2FuY2VsQW5pbWF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgYWRkXG4gKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5Ub29sYmFyQWRkLmtleSA9ICdhZGQnO1xuXG4vKipcbiAqIERlZmluZXMgdGhlIGNvbnN0YW50IGZvciBwb3NpdGlvbmluZyB0aGUgVG9vbGJhciBvbiBsZWZ0IG9mIHRoZSBlZGl0YWJsZSBhcmVhLlxuICpcbiAqIEBkZWZhdWx0IDFcbiAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG4gKiBAcHJvcGVydHkge1N0cmluZ30gbGVmdFxuICogQHN0YXRpY1xuICovXG5Ub29sYmFyQWRkLmxlZnQgPSBQT1NJVElPTl9MRUZUO1xuXG4vKipcbiAqIERlZmluZXMgdGhlIGNvbnN0YW50IGZvciBwb3NpdGlvbmluZyB0aGUgVG9vbGJhciBvbiByaWdodCBvZiB0aGUgZWRpdGFibGUgYXJlYS5cbiAqXG4gKiBAZGVmYXVsdCAyXG4gKiBAbWVtYmVyb2YgVG9vbGJhckFkZFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJpZ2h0XG4gKiBAc3RhdGljXG4gKi9cblRvb2xiYXJBZGQucmlnaHQgPSBQT1NJVElPTl9SSUdIVDtcblxuLyoqXG4gKiBMaWZlY3ljbGUuIFJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVzIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHdpZGdldC5cbiAqXG4gKiBAaW5zdGFuY2VcbiAqIEBtZW1iZXJvZiBUb29sYmFyQWRkXG4gKiBAbWV0aG9kIGdldERlZmF1bHRQcm9wc1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICovXG5Ub29sYmFyQWRkLmRlZmF1bHRQcm9wcyA9IHtcblx0Y2lyY3VsYXI6IHRydWUsXG5cdGRlc2NlbmRhbnRzOiAnLmFlLWJ1dHRvbicsXG5cdGd1dHRlckV4Y2x1c2l2ZToge1xuXHRcdGxlZnQ6IDEwLFxuXHRcdHRvcDogMCxcblx0fSxcblx0a2V5czoge1xuXHRcdGRpc21pc3M6IFsyN10sXG5cdFx0bmV4dDogWzM5LCA0MF0sXG5cdFx0cHJldjogWzM3LCAzOF0sXG5cdH0sXG5cdHBvc2l0aW9uOiBQT1NJVElPTl9MRUZULFxufTtcblxuZXhwb3J0IGRlZmF1bHQgV2lkZ2V0QXJyb3dCb3goXG5cdFdpZGdldERyb3Bkb3duKFxuXHRcdFdpZGdldEV4Y2x1c2l2ZShcblx0XHRcdFdpZGdldEZvY3VzTWFuYWdlcihXaWRnZXRQb3NpdGlvbihUb29sYmFyQnV0dG9ucyhUb29sYmFyQWRkKSkpXG5cdFx0KVxuXHQpXG4pO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IFRvb2xiYXJCdXR0b25zIGZyb20gJy4uL2Jhc2UvdG9vbGJhci1idXR0b25zJztcbmltcG9ydCBXaWRnZXRBcnJvd0JveCBmcm9tICcuLi9iYXNlL3dpZGdldC1hcnJvdy1ib3gnO1xuaW1wb3J0IFdpZGdldERyb3Bkb3duIGZyb20gJy4uL2Jhc2Uvd2lkZ2V0LWRyb3Bkb3duJztcbmltcG9ydCBXaWRnZXRFeGNsdXNpdmUgZnJvbSAnLi4vYmFzZS93aWRnZXQtZXhjbHVzaXZlJztcbmltcG9ydCBXaWRnZXRGb2N1c01hbmFnZXIgZnJvbSAnLi4vYmFzZS93aWRnZXQtZm9jdXMtbWFuYWdlcic7XG5pbXBvcnQgV2lkZ2V0UG9zaXRpb24gZnJvbSAnLi4vYmFzZS93aWRnZXQtcG9zaXRpb24nO1xuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5pbXBvcnQgTGFuZyBmcm9tICcuLi8uLi9vb3AvbGFuZyc7XG5cbi8qKlxuICogVGhlIFRvb2xiYXJTdHlsZXMgY2xhc3MgaG9zdHMgdGhlIGJ1dHRvbnMgZm9yIHN0eWxpbmcgYSB0ZXh0IHNlbGVjdGlvbi5cbiAqXG4gKiBAY2xhc3MgVG9vbGJhclN0eWxlc1xuICogQHVzZXMgVG9vbGJhckJ1dHRvbnNcbiAqIEB1c2VzIFdpZGdldEFycm93Qm94XG4gKiBAdXNlcyBXaWRnZXREcm9wZG93blxuICogQHVzZXMgV2lkZ2V0RXhjbHVzaXZlXG4gKiBAdXNlcyBXaWRnZXRGb2N1c01hbmFnZXJcbiAqIEB1c2VzIFdpZGdldFBvc2l0aW9uXG4gKi9cbmNsYXNzIFRvb2xiYXJTdHlsZXMgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0c3VwZXIocHJvcHMpO1xuXG5cdFx0dGhpcy5zdGF0ZSA9IHt9O1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gSW52b2tlZCBvbmNlLCBvbmx5IG9uIHRoZSBjbGllbnQgKG5vdCBvbiB0aGUgc2VydmVyKSxcblx0ICogaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGluaXRpYWwgcmVuZGVyaW5nIG9jY3Vycy5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkTW91bnRcblx0ICovXG5cdGNvbXBvbmVudERpZE1vdW50KCkge1xuXHRcdHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG5cdH1cblxuXHQvKipcblx0ICogTGlmZWN5Y2xlLiBJbnZva2VkIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQncyB1cGRhdGVzIGFyZSBmbHVzaGVkIHRvIHRoZSBET00uXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG5vdCBjYWxsZWQgZm9yIHRoZSBpbml0aWFsIHJlbmRlci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG5cdCAqIEBtZXRob2QgY29tcG9uZW50RGlkVXBkYXRlXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcmV2UHJvcHMgVGhlIHByZXZpb3VzIHN0YXRlIG9mIHRoZSBjb21wb25lbnQncyBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcHJldlN0YXRlIENvbXBvbmVudCdzIHByZXZpb3VzIHN0YXRlLlxuXHQgKi9cblx0Y29tcG9uZW50RGlkVXBkYXRlKF9wcmV2UHJvcHMsIF9wcmV2U3RhdGUpIHtcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpZmVjeWNsZS4gUmVuZGVycyB0aGUgYnV0dG9ucyBmb3IgYWRkaW5nIGNvbnRlbnQgb3IgaGlkZXMgdGhlIHRvb2xiYXJcblx0ICogaWYgdXNlciBpbnRlcmFjdGVkIHdpdGggYSBub24tZWRpdGFibGUgZWxlbWVudC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG5cdCAqIEBtZXRob2QgcmVuZGVyXG5cdCAqIEByZXR1cm4ge09iamVjdHxudWxsfSBUaGUgY29udGVudCB3aGljaCBzaG91bGQgYmUgcmVuZGVyZWQuXG5cdCAqL1xuXHRyZW5kZXIoKSB7XG5cdFx0Y29uc3QgY3VycmVudFNlbGVjdGlvbiA9IHRoaXMuX2dldEN1cnJlbnRTZWxlY3Rpb24oKTtcblxuXHRcdGlmIChjdXJyZW50U2VsZWN0aW9uKSB7XG5cdFx0XHRjb25zdCBnZXRBcnJvd0JveENsYXNzZXNGbiA9IHRoaXMuX2dldFNlbGVjdGlvbkZ1bmN0aW9uKFxuXHRcdFx0XHRjdXJyZW50U2VsZWN0aW9uLmdldEFycm93Qm94Q2xhc3Nlc1xuXHRcdFx0KTtcblx0XHRcdGxldCBhcnJvd0JveENsYXNzZXM7XG5cblx0XHRcdGlmIChnZXRBcnJvd0JveENsYXNzZXNGbikge1xuXHRcdFx0XHRhcnJvd0JveENsYXNzZXMgPSBnZXRBcnJvd0JveENsYXNzZXNGbigpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXJyb3dCb3hDbGFzc2VzID0gdGhpcy5nZXRBcnJvd0JveENsYXNzZXMoKTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY3NzQ2xhc3NlcyA9ICdhZS10b29sYmFyLXN0eWxlcyAnICsgYXJyb3dCb3hDbGFzc2VzO1xuXG5cdFx0XHRsZXQgYnV0dG9ucyA9IGN1cnJlbnRTZWxlY3Rpb24uYnV0dG9ucztcblxuXHRcdFx0aWYgKHR5cGVvZiBidXR0b25zID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShidXR0b25zKSkge1xuXHRcdFx0XHRidXR0b25zID1cblx0XHRcdFx0XHRidXR0b25zW3RoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCdtb2RlJyldIHx8XG5cdFx0XHRcdFx0YnV0dG9uc1snc2ltcGxlJ107XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGJ1dHRvbnNHcm91cCA9IHRoaXMuZ2V0VG9vbGJhckJ1dHRvbkdyb3VwcyhidXR0b25zLCB7XG5cdFx0XHRcdG1hbnVhbFNlbGVjdGlvbjogdGhpcy5wcm9wcy5lZGl0b3JFdmVudFxuXHRcdFx0XHRcdD8gdGhpcy5wcm9wcy5lZGl0b3JFdmVudC5kYXRhLm1hbnVhbFNlbGVjdGlvblxuXHRcdFx0XHRcdDogbnVsbCxcblx0XHRcdFx0c2VsZWN0aW9uVHlwZTogY3VycmVudFNlbGVjdGlvbi5uYW1lLFxuXHRcdFx0fSk7XG5cblx0XHRcdGNvbnN0IGhhc0dyb3VwcyA9XG5cdFx0XHRcdGJ1dHRvbnNHcm91cC5maWx0ZXIoZnVuY3Rpb24oYnV0dG9uKSB7XG5cdFx0XHRcdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkoYnV0dG9uKTtcblx0XHRcdFx0fSkubGVuZ3RoID4gMDtcblxuXHRcdFx0bGV0IGNsYXNzTmFtZSA9ICdhZS1jb250YWluZXInO1xuXG5cdFx0XHRpZiAoaGFzR3JvdXBzKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSArPSAnIGFlLWNvbnRhaW5lci1jb2x1bW4nO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0YXJpYS1sYWJlbD17QWxsb3lFZGl0b3IuU3RyaW5ncy5zdHlsZXN9XG5cdFx0XHRcdFx0Y2xhc3NOYW1lPXtjc3NDbGFzc2VzfVxuXHRcdFx0XHRcdGRhdGEtdGFiaW5kZXg9e3RoaXMucHJvcHMuY29uZmlnLnRhYkluZGV4IHx8IDB9XG5cdFx0XHRcdFx0b25Gb2N1cz17dGhpcy5mb2N1cy5iaW5kKHRoaXMpfVxuXHRcdFx0XHRcdG9uS2V5RG93bj17dGhpcy5oYW5kbGVLZXkuYmluZCh0aGlzKX1cblx0XHRcdFx0XHRyb2xlPVwidG9vbGJhclwiXG5cdFx0XHRcdFx0dGFiSW5kZXg9XCItMVwiPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWV9PlxuXHRcdFx0XHRcdFx0e2J1dHRvbnNHcm91cC5tYXAoZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG5cdFx0XHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLXJvd1wiIGtleT17aW5kZXh9PlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7dmFsdWUubWFwKGZ1bmN0aW9uKGJ1dHRvbikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBidXR0b247XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0pfVxuXHRcdFx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pfVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogUmV0cmlldmUgYSBmdW5jdGlvbiBmcm9tIFN0cmluZy4gSXQgY29udmVydHMgYSBmdWxseSBxdWFsaWZpZWQgc3RyaW5nIGludG8gdGhlIG1hcHBlZCBmdW5jdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG5cdCAqIEBtZXRob2QgX2dldFNlbGVjdGlvbkZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBzZWxlY3Rpb25GbiBBIGZ1bmN0aW9uLCBvciBhIGZ1bGx5IHF1YWxpZmllZCBzdHJpbmcgcG9pbnRpbmcgdG8gdGhlIGRlc2lyZWQgb25lIChlLmcuICdBbGxveUVkaXRvci5TZWxlY3Rpb25UZXN0LmltYWdlJykuXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBtYXBwZWQgZnVuY3Rpb24uXG5cdCAqL1xuXHRfZ2V0U2VsZWN0aW9uRnVuY3Rpb24oc2VsZWN0aW9uRm4pIHtcblx0XHRsZXQgc2VsZWN0aW9uRnVuY3Rpb247XG5cblx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKHNlbGVjdGlvbkZuKSkge1xuXHRcdFx0c2VsZWN0aW9uRnVuY3Rpb24gPSBzZWxlY3Rpb25Gbjtcblx0XHR9IGVsc2UgaWYgKExhbmcuaXNTdHJpbmcoc2VsZWN0aW9uRm4pKSB7XG5cdFx0XHRjb25zdCBwYXJ0cyA9IHNlbGVjdGlvbkZuLnNwbGl0KCcuJyk7XG5cdFx0XHRsZXQgY3VycmVudE1lbWJlciA9IHdpbmRvdztcblx0XHRcdGxldCBwcm9wZXJ0eSA9IHBhcnRzLnNoaWZ0KCk7XG5cblx0XHRcdHdoaWxlIChcblx0XHRcdFx0cHJvcGVydHkgJiZcblx0XHRcdFx0TGFuZy5pc09iamVjdChjdXJyZW50TWVtYmVyKSAmJlxuXHRcdFx0XHRMYW5nLmlzT2JqZWN0KGN1cnJlbnRNZW1iZXJbcHJvcGVydHldKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGN1cnJlbnRNZW1iZXIgPSBjdXJyZW50TWVtYmVyW3Byb3BlcnR5XTtcblx0XHRcdFx0cHJvcGVydHkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKGN1cnJlbnRNZW1iZXIpKSB7XG5cdFx0XHRcdHNlbGVjdGlvbkZ1bmN0aW9uID0gY3VycmVudE1lbWJlcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gc2VsZWN0aW9uRnVuY3Rpb247XG5cdH1cblxuXHQvKipcblx0ICogQW5hbHl6ZXMgdGhlIGN1cnJlbnQgZWRpdG9yIHNlbGVjdGlvbiBhbmQgcmV0dXJucyB0aGUgc2VsZWN0aW9uIGNvbmZpZ3VyYXRpb24gdGhhdCBtYXRjaGVzLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIFRvb2xiYXJTdHlsZXNcblx0ICogQG1ldGhvZCBfZ2V0Q3VycmVudFNlbGVjdGlvblxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIG1hdGNoZWQgc2VsZWN0aW9uIGNvbmZpZ3VyYXRpb24uXG5cdCAqL1xuXHRfZ2V0Q3VycmVudFNlbGVjdGlvbigpIHtcblx0XHRjb25zdCBldmVudFBheWxvYWQgPSB0aGlzLnByb3BzLmVkaXRvckV2ZW50XG5cdFx0XHQ/IHRoaXMucHJvcHMuZWRpdG9yRXZlbnQuZGF0YVxuXHRcdFx0OiBudWxsO1xuXHRcdGxldCBzZWxlY3Rpb247XG5cblx0XHRpZiAoZXZlbnRQYXlsb2FkKSB7XG5cdFx0XHR0aGlzLnByb3BzLmNvbmZpZy5zZWxlY3Rpb25zLnNvbWUoZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRjb25zdCB0ZXN0Rm4gPSB0aGlzLl9nZXRTZWxlY3Rpb25GdW5jdGlvbihpdGVtLnRlc3QpO1xuXHRcdFx0XHRsZXQgcmVzdWx0O1xuXG5cdFx0XHRcdGlmICh0ZXN0Rm4pIHtcblx0XHRcdFx0XHRyZXN1bHQgPVxuXHRcdFx0XHRcdFx0ZXZlbnRQYXlsb2FkLm1hbnVhbFNlbGVjdGlvbiA9PT0gaXRlbS5uYW1lIHx8XG5cdFx0XHRcdFx0XHR0ZXN0Rm4oe1xuXHRcdFx0XHRcdFx0XHRkYXRhOiBldmVudFBheWxvYWQsXG5cdFx0XHRcdFx0XHRcdGVkaXRvcjogdGhpcy5jb250ZXh0LmVkaXRvcixcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHRcdHNlbGVjdGlvbiA9IGl0ZW07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlbGVjdGlvbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGVzIGFuZCBzZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbGJhci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBUb29sYmFyU3R5bGVzXG5cdCAqIEBtZXRob2QgX3VwZGF0ZVBvc2l0aW9uXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdF91cGRhdGVQb3NpdGlvbigpIHtcblx0XHQvLyBJZiBjb21wb25lbnQgaXMgbm90IG1vdW50ZWQsIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG9cblx0XHRpZiAoIVJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29uc3QgY3VycmVudFNlbGVjdGlvbiA9IHRoaXMuX2dldEN1cnJlbnRTZWxlY3Rpb24oKTtcblx0XHRsZXQgcmVzdWx0O1xuXG5cdFx0Ly8gSWYgY3VycmVudCBzZWxlY3Rpb24gaGFzIGEgZnVuY3Rpb24gY2FsbGVkIGBzZXRQb3NpdGlvbmAsIGNhbGwgaXRcblx0XHQvLyBhbmQgY2hlY2sgdGhlIHJldHVybmVkIHZhbHVlLiBJZiBmYWxzZSwgZmFsbGJhY2sgdG8gdGhlIGRlZmF1bHQgcG9zaXRpb25pbmcgbG9naWMuXG5cdFx0aWYgKGN1cnJlbnRTZWxlY3Rpb24pIHtcblx0XHRcdGNvbnN0IHNldFBvc2l0aW9uRm4gPSB0aGlzLl9nZXRTZWxlY3Rpb25GdW5jdGlvbihcblx0XHRcdFx0Y3VycmVudFNlbGVjdGlvbi5zZXRQb3NpdGlvblxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKHNldFBvc2l0aW9uRm4pIHtcblx0XHRcdFx0cmVzdWx0ID0gc2V0UG9zaXRpb25Gbi5jYWxsKHRoaXMsIHtcblx0XHRcdFx0XHRlZGl0b3I6IHRoaXMuY29udGV4dC5lZGl0b3IsXG5cdFx0XHRcdFx0ZWRpdG9yRXZlbnQ6IHRoaXMucHJvcHMuZWRpdG9yRXZlbnQsXG5cdFx0XHRcdFx0c2VsZWN0aW9uRGF0YTogdGhpcy5wcm9wcy5zZWxlY3Rpb25EYXRhLFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIXJlc3VsdCkge1xuXHRcdFx0dGhpcy51cGRhdGVQb3NpdGlvbigpO1xuXHRcdFx0dGhpcy5zaG93KCk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogTGlmZWN5Y2xlLiBSZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlcyBvZiB0aGUgcHJvcGVydGllcyB1c2VkIGluIHRoZSB3aWRnZXQuXG4gKlxuICogQGluc3RhbmNlXG4gKiBAbWVtYmVyb2YgVG9vbGJhclN0eWxlc1xuICogQG1ldGhvZCBnZXREZWZhdWx0UHJvcHNcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGRlZmF1bHQgcHJvcGVydGllcy5cbiAqL1xuVG9vbGJhclN0eWxlcy5kZWZhdWx0UHJvcHMgPSB7XG5cdGNpcmN1bGFyOiB0cnVlLFxuXHRkZXNjZW5kYW50czogJy5hZS1pbnB1dCwgLmFlLWJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIC5hZS10b29sYmFyLWVsZW1lbnQnLFxuXHRrZXlzOiB7XG5cdFx0ZGlzbWlzczogWzI3XSxcblx0XHRuZXh0OiBbMzksIDQwXSxcblx0XHRwcmV2OiBbMzcsIDM4XSxcblx0fSxcbn07XG5cbi8qKlxuICogVGhlIG5hbWUgd2hpY2ggd2lsbCBiZSB1c2VkIGFzIGFuIGFsaWFzIG9mIHRoZSBidXR0b24gaW4gdGhlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQGRlZmF1bHQgc3R5bGVzXG4gKiBAbWVtYmVyb2YgVG9vbGJhclN0eWxlc1xuICogQHByb3BlcnR5IHtTdHJpbmd9IGtleVxuICogQHN0YXRpY1xuICovXG5Ub29sYmFyU3R5bGVzLmtleSA9ICdzdHlsZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBXaWRnZXRBcnJvd0JveChcblx0V2lkZ2V0RHJvcGRvd24oXG5cdFx0V2lkZ2V0RXhjbHVzaXZlKFxuXHRcdFx0V2lkZ2V0Rm9jdXNNYW5hZ2VyKFdpZGdldFBvc2l0aW9uKFRvb2xiYXJCdXR0b25zKFRvb2xiYXJTdHlsZXMpKSlcblx0XHQpXG5cdClcbik7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IEVkaXRvckNvbnRleHQgZnJvbSAnLi4vLi4vYWRhcHRlci9lZGl0b3ItY29udGV4dCc7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfYnV0dG9uYnJpZGdlJykpIHtcblx0Y29uc3QgQlVUVE9OX0RFRlMgPSB7fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIGEgQnV0dG9uQnJpZGdlIFJlYWN0IGNsYXNzIGZvciBhIGdpdmVuIGJ1dHRvbiBkZWZpbml0aW9uIGlmIGl0IGhhcyBub3QgYmVlblxuXHQgKiBhbHJlYWR5IGNyZWF0ZWQgYmFzZWQgb24gdGhlIGJ1dHRvbiBuYW1lIGFuZCBkZWZpbml0aW9uLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAbWV0aG9kIGdlbmVyYXRlQnV0dG9uQnJpZGdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBidXR0b25OYW1lIFRoZSBidXR0b24ncyBuYW1lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBidXR0b25EZWZpbml0aW9uIFRoZSBidXR0b24ncyBkZWZpbml0aW9uXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGdlbmVyYXRlZCBvciBhbHJlYWR5IGV4aXN0aW5nIFJlYWN0IEJ1dHRvbiBDbGFzc1xuXHQgKi9cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZUJ1dHRvbkJyaWRnZShidXR0b25OYW1lLCBidXR0b25EZWZpbml0aW9uLCBlZGl0b3IpIHtcblx0XHRsZXQgQnV0dG9uQnJpZGdlID0gQWxsb3lFZGl0b3IuQnV0dG9uc1tidXR0b25OYW1lXTtcblxuXHRcdEJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXSA9IEJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXSB8fCB7fTtcblx0XHRCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bYnV0dG9uTmFtZV0gPVxuXHRcdFx0QlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW2J1dHRvbk5hbWVdIHx8IGJ1dHRvbkRlZmluaXRpb247XG5cblx0XHRpZiAoIUJ1dHRvbkJyaWRnZSkge1xuXHRcdFx0QnV0dG9uQnJpZGdlID0gY2xhc3MgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXHRcdFx0XHRzdGF0aWMgY29udGV4dFR5cGUgPSBFZGl0b3JDb250ZXh0O1xuXG5cdFx0XHRcdHN0YXRpYyBkaXNwbGF5TmFtZSA9IGJ1dHRvbk5hbWU7XG5cblx0XHRcdFx0c3RhdGljIGtleSA9IGJ1dHRvbk5hbWU7XG5cblx0XHRcdFx0Ly8gQVBJIG5vdCB5ZXQgaW1wbGVtZW50ZWQgaW5zaWRlIHRoZSBidXR0b25cblx0XHRcdFx0Ly8gYnJpZGdlLiBCeSBtb2NraW5nIHRoZSB1bnN1cHBvcnRlZCBtZXRob2QsIHdlIHByZXZlbnRcblx0XHRcdFx0Ly8gcGx1Z2lucyBmcm9tIGNyYXNoaW5nIGlmIHRoZXkgbWFrZSB1c2Ugb2YgaXQuXG5cdFx0XHRcdHRvRmVhdHVyZSgpIHt9XG5cblx0XHRcdFx0cmVuZGVyKCkge1xuXHRcdFx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0XHRcdGNvbnN0IGJ1dHRvbkNsYXNzTmFtZSA9ICdhZS1idXR0b24gYWUtYnV0dG9uLWJyaWRnZSc7XG5cblx0XHRcdFx0XHRjb25zdCBidXR0b25EaXNwbGF5TmFtZSA9XG5cdFx0XHRcdFx0XHRCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bYnV0dG9uTmFtZV0ubmFtZSB8fFxuXHRcdFx0XHRcdFx0QlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW2J1dHRvbk5hbWVdLmNvbW1hbmQgfHxcblx0XHRcdFx0XHRcdGJ1dHRvbk5hbWU7XG5cblx0XHRcdFx0XHRjb25zdCBidXR0b25MYWJlbCA9XG5cdFx0XHRcdFx0XHRCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bYnV0dG9uTmFtZV0ubGFiZWw7XG5cblx0XHRcdFx0XHRjb25zdCBidXR0b25UeXBlID0gJ2J1dHRvbi0nICsgYnV0dG9uRGlzcGxheU5hbWU7XG5cblx0XHRcdFx0XHRjb25zdCBpY29uQ2xhc3NOYW1lID0gJ2FlLWljb24tJyArIGJ1dHRvbkRpc3BsYXlOYW1lO1xuXG5cdFx0XHRcdFx0Y29uc3QgaWNvblN0eWxlID0ge307XG5cblx0XHRcdFx0XHRjb25zdCBjc3NTdHlsZSA9IENLRURJVE9SLnNraW4uZ2V0SWNvblN0eWxlKFxuXHRcdFx0XHRcdFx0YnV0dG9uRGlzcGxheU5hbWVcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKGNzc1N0eWxlKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBjc3NTdHlsZVBhcnRzID0gY3NzU3R5bGUuc3BsaXQoJzsnKTtcblxuXHRcdFx0XHRcdFx0aWNvblN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGNzc1N0eWxlUGFydHNbMF0uc3Vic3RyaW5nKFxuXHRcdFx0XHRcdFx0XHRjc3NTdHlsZVBhcnRzWzBdLmluZGV4T2YoJzonKSArIDFcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRpY29uU3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gY3NzU3R5bGVQYXJ0c1sxXS5zdWJzdHJpbmcoXG5cdFx0XHRcdFx0XHRcdGNzc1N0eWxlUGFydHNbMV0uaW5kZXhPZignOicpICsgMVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGljb25TdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IGNzc1N0eWxlUGFydHNbMl0uc3Vic3RyaW5nKFxuXHRcdFx0XHRcdFx0XHRjc3NTdHlsZVBhcnRzWzJdLmluZGV4T2YoJzonKSArIDFcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdFx0YXJpYS1sYWJlbD17YnV0dG9uTGFiZWx9XG5cdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17YnV0dG9uQ2xhc3NOYW1lfVxuXHRcdFx0XHRcdFx0XHRkYXRhLXR5cGU9e2J1dHRvblR5cGV9XG5cdFx0XHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMuX2hhbmRsZUNsaWNrfVxuXHRcdFx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHRcdFx0dGl0bGU9e2J1dHRvbkxhYmVsfT5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3NOYW1lPXtpY29uQ2xhc3NOYW1lfSBzdHlsZT17aWNvblN0eWxlfSAvPlxuXHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9oYW5kbGVDbGljayA9ICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdFx0XHRjb25zdCBidXR0b25Db21tYW5kID1cblx0XHRcdFx0XHRcdEJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVtidXR0b25OYW1lXS5jb21tYW5kO1xuXG5cdFx0XHRcdFx0Y29uc3QgYnV0dG9uT25DbGljayA9XG5cdFx0XHRcdFx0XHRCVVRUT05fREVGU1tlZGl0b3IubmFtZV1bYnV0dG9uTmFtZV0ub25DbGljaztcblxuXHRcdFx0XHRcdGlmIChidXR0b25PbkNsaWNrKSB7XG5cdFx0XHRcdFx0XHRidXR0b25PbkNsaWNrLmNhbGwodGhpcyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGVkaXRvci5leGVjQ29tbWFuZChidXR0b25Db21tYW5kKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0XHRBbGxveUVkaXRvci5CdXR0b25zW2J1dHRvbk5hbWVdID0gQnV0dG9uQnJpZGdlO1xuXHRcdH1cblxuXHRcdHJldHVybiBCdXR0b25CcmlkZ2U7XG5cdH1cblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHRpZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdidXR0b24nKSkge1xuXHRcdENLRURJVE9SLlVJX0JVVFRPTiA9ICdidXR0b24nO1xuXG5cdFx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2J1dHRvbicsIHt9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gdGhhdCBicmlkZ2VzIHRoZSBzdXBwb3J0IG9mZmVyZWQgYnkgQ0tFZGl0b3IgQnV0dG9uIHBsdWdpbi4gSXQgdGFrZXMgb3ZlciB0aGVcblx0ICogcmVzcG9uc2liaWxpdHkgb2YgcmVnaXN0ZXJpbmcgYW5kIGNyZWF0aW5nIGJ1dHRvbnMgdmlhOlxuXHQgKiAtIGVkaXRvci51aS5hZGRCdXR0b24obmFtZSwgZGVmaW5pdGlvbilcblx0ICogLSBlZGl0b3IudWkuYWRkKG5hbWUsIENLRURJVE9SLlVJX0JVVFRPTiwgZGVmaW5pdGlvbilcblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfYnV0dG9uYnJpZGdlXG5cdCAqIEByZXF1aXJlcyBDS0VESVRPUi5wbHVnaW5zLmFlX3VpYnJpZGdlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX2J1dHRvbmJyaWRnZScsIHtcblx0XHRyZXF1aXJlczogWydhZV91aWJyaWRnZSddLFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBhZGQgaGFuZGxlciBmb3IgVUlfQlVUVE9OIHRvIG91ciBvd24uIFdlIGRvIHRoaXMgaW4gdGhlIGluaXQgcGhhc2UgdG8gb3ZlcnJpZGVcblx0XHQgKiB0aGUgb25lIGluIHRoZSBuYXRpdmUgcGx1Z2luIGluIGNhc2UgaXQncyBwcmVzZW50LlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBpbml0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgQ0tFZGl0b3IgaW5zdGFuY2UgYmVpbmcgaW5pdGlhbGl6ZWRcblx0XHQgKi9cblx0XHRiZWZvcmVJbml0KGVkaXRvcikge1xuXHRcdFx0ZWRpdG9yLnVpLmFkZEJ1dHRvbiA9IGZ1bmN0aW9uKGJ1dHRvbk5hbWUsIGJ1dHRvbkRlZmluaXRpb24pIHtcblx0XHRcdFx0dGhpcy5hZGQoYnV0dG9uTmFtZSwgQ0tFRElUT1IuVUlfQlVUVE9OLCBidXR0b25EZWZpbml0aW9uKTtcblx0XHRcdH07XG5cblx0XHRcdGVkaXRvci51aS5hZGRIYW5kbGVyKENLRURJVE9SLlVJX0JVVFRPTiwge1xuXHRcdFx0XHRhZGQ6IGdlbmVyYXRlQnV0dG9uQnJpZGdlLFxuXHRcdFx0XHRjcmVhdGUoYnV0dG9uRGVmaW5pdGlvbikge1xuXHRcdFx0XHRcdGNvbnN0IGJ1dHRvbk5hbWUgPVxuXHRcdFx0XHRcdFx0J2J1dHRvbkJyaWRnZScgKyAoKE1hdGgucmFuZG9tKCkgKiAxZTkpID4+PiAwKTtcblx0XHRcdFx0XHRjb25zdCBCdXR0b25CcmlkZ2UgPSBnZW5lcmF0ZUJ1dHRvbkJyaWRnZShcblx0XHRcdFx0XHRcdGJ1dHRvbk5hbWUsXG5cdFx0XHRcdFx0XHRidXR0b25EZWZpbml0aW9uXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgQnV0dG9uQnJpZGdlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblx0XHR9LFxuXHR9KTtcbn1cbiIsImltcG9ydCAnLi9idXR0b24uanN4JztcbmltcG9ydCAnLi9tZW51LWJ1dHRvbi5qc3gnO1xuaW1wb3J0ICcuL21lbnUuanN4JztcbmltcG9ydCAnLi9wYW5lbC1tZW51LWJ1dHRvbi5qc3gnO1xuaW1wb3J0ICcuL3JpY2hjb21iby5qc3gnO1xuaW1wb3J0ICcuL3VpYnJpZGdlJztcbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQnV0dG9uRHJvcGRvd24gZnJvbSAnLi4vYnV0dG9ucy9idXR0b24tZHJvcGRvd24uanN4JztcbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX21lbnVidXR0b25icmlkZ2UnKSkge1xuXHRjb25zdCBNRU5VQlVUVE9OX0RFRlMgPSB7fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIGEgTWVudUJ1dHRvbkJyaWRnZSBSZWFjdCBjbGFzcyBmb3IgYSBnaXZlbiBtZW51QnV0dG9uIGRlZmluaXRpb24gaWYgaXQgaGFzIG5vdCBiZWVuXG5cdCAqIGFscmVhZHkgY3JlYXRlZCBiYXNlZCBvbiB0aGUgYnV0dG9uIG5hbWUgYW5kIGRlZmluaXRpb24uXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBtZXRob2QgZ2VuZXJhdGVNZW51QnV0dG9uQnJpZGdlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBtZW51QnV0dG9uTmFtZSBUaGUgbWVudUJ1dHRvbidzIG5hbWVcblx0ICogQHBhcmFtIHtPYmplY3R9IG1lbnVCdXR0b25EZWZpbml0aW9uIFRoZSBtZW51QnV0dG9uJ3MgZGVmaW5pdGlvblxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBnZW5lcmF0ZWQgb3IgYWxyZWFkeSBleGlzdGluZyBSZWFjdCBNZW51QnV0dG9uIENsYXNzXG5cdCAqL1xuXHRmdW5jdGlvbiBnZW5lcmF0ZU1lbnVCdXR0b25CcmlkZ2UoXG5cdFx0bWVudUJ1dHRvbk5hbWUsXG5cdFx0bWVudUJ1dHRvbkRlZmluaXRpb24sXG5cdFx0ZWRpdG9yXG5cdCkge1xuXHRcdGxldCBNZW51QnV0dG9uQnJpZGdlID0gQWxsb3lFZGl0b3IuQnV0dG9uc1ttZW51QnV0dG9uTmFtZV07XG5cblx0XHRNRU5VQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdID0gTUVOVUJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXSB8fCB7fTtcblx0XHRNRU5VQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW21lbnVCdXR0b25OYW1lXSA9XG5cdFx0XHRNRU5VQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW21lbnVCdXR0b25OYW1lXSB8fFxuXHRcdFx0bWVudUJ1dHRvbkRlZmluaXRpb247XG5cblx0XHRpZiAoIU1lbnVCdXR0b25CcmlkZ2UpIHtcblx0XHRcdE1lbnVCdXR0b25CcmlkZ2UgPSBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdFx0XHRcdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0XHRcdFx0c3RhdGljIGRpc3BsYXlOYW1lID0gbWVudUJ1dHRvbk5hbWU7XG5cblx0XHRcdFx0c3RhdGljIGtleSA9IG1lbnVCdXR0b25OYW1lO1xuXG5cdFx0XHRcdC8vIEFQSSBub3QgeWV0IGltcGxlbWVudGVkIGluc2lkZSB0aGUgbWVudWJ1dHRvblxuXHRcdFx0XHQvLyBicmlkZ2UuIEJ5IG1vY2tpbmcgdGhlIHVuc3VwcG9ydGVkIG1ldGhvZCwgd2UgcHJldmVudFxuXHRcdFx0XHQvLyBwbHVnaW5zIGZyb20gY3Jhc2hpbmcgaWYgdGhleSBtYWtlIHVzZSBvZiBpdC5cblx0XHRcdFx0dG9GZWF0dXJlKCkge31cblxuXHRcdFx0XHRyZW5kZXIoKSB7XG5cdFx0XHRcdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5jb250ZXh0LmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdFx0XHRcdFx0Y29uc3QgcGFuZWxNZW51QnV0dG9uRGlzcGxheU5hbWUgPVxuXHRcdFx0XHRcdFx0TUVOVUJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVttZW51QnV0dG9uTmFtZV0ubmFtZSB8fFxuXHRcdFx0XHRcdFx0TUVOVUJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVttZW51QnV0dG9uTmFtZV0uY29tbWFuZCB8fFxuXHRcdFx0XHRcdFx0bWVudUJ1dHRvbk5hbWU7XG5cblx0XHRcdFx0XHRjb25zdCBidXR0b25DbGFzc05hbWUgPSAnYWUtYnV0dG9uIGFlLWJ1dHRvbi1icmlkZ2UnO1xuXG5cdFx0XHRcdFx0Y29uc3QgaWNvbkNsYXNzTmFtZSA9XG5cdFx0XHRcdFx0XHQnYWUtaWNvbi0nICsgcGFuZWxNZW51QnV0dG9uRGlzcGxheU5hbWU7XG5cblx0XHRcdFx0XHRjb25zdCBpY29uU3R5bGUgPSB7fTtcblxuXHRcdFx0XHRcdGNvbnN0IGNzc1N0eWxlID0gQ0tFRElUT1Iuc2tpbi5nZXRJY29uU3R5bGUoXG5cdFx0XHRcdFx0XHRwYW5lbE1lbnVCdXR0b25EaXNwbGF5TmFtZVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAoY3NzU3R5bGUpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGNzc1N0eWxlUGFydHMgPSBjc3NTdHlsZS5zcGxpdCgnOycpO1xuXG5cdFx0XHRcdFx0XHRpY29uU3R5bGUuYmFja2dyb3VuZEltYWdlID0gY3NzU3R5bGVQYXJ0c1swXS5zdWJzdHJpbmcoXG5cdFx0XHRcdFx0XHRcdGNzc1N0eWxlUGFydHNbMF0uaW5kZXhPZignOicpICsgMVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGljb25TdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSBjc3NTdHlsZVBhcnRzWzFdLnN1YnN0cmluZyhcblx0XHRcdFx0XHRcdFx0Y3NzU3R5bGVQYXJ0c1sxXS5pbmRleE9mKCc6JykgKyAxXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0aWNvblN0eWxlLmJhY2tncm91bmRTaXplID0gY3NzU3R5bGVQYXJ0c1syXS5zdWJzdHJpbmcoXG5cdFx0XHRcdFx0XHRcdGNzc1N0eWxlUGFydHNbMl0uaW5kZXhPZignOicpICsgMVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0PGRpdiBjbGFzc05hbWU9XCJhZS1jb250YWluZXIgYWUtaGFzLWRyb3Bkb3duXCI+XG5cdFx0XHRcdFx0XHRcdDxidXR0b25cblx0XHRcdFx0XHRcdFx0XHRhcmlhLWV4cGFuZGVkPXt0aGlzLnByb3BzLmV4cGFuZGVkfVxuXHRcdFx0XHRcdFx0XHRcdGFyaWEtbGFiZWw9e1xuXHRcdFx0XHRcdFx0XHRcdFx0TUVOVUJVVFRPTl9ERUZTW2VkaXRvci5uYW1lXVttZW51QnV0dG9uTmFtZV1cblx0XHRcdFx0XHRcdFx0XHRcdFx0LmxhYmVsXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17YnV0dG9uQ2xhc3NOYW1lfVxuXHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdFx0XHRcdFx0cm9sZT1cImNvbWJvYm94XCJcblx0XHRcdFx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHRcdFx0XHR0aXRsZT17XG5cdFx0XHRcdFx0XHRcdFx0XHRNRU5VQlVUVE9OX0RFRlNbZWRpdG9yLm5hbWVdW21lbnVCdXR0b25OYW1lXVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQubGFiZWxcblx0XHRcdFx0XHRcdFx0XHR9PlxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuXG5cdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9e2ljb25DbGFzc05hbWV9XG5cdFx0XHRcdFx0XHRcdFx0XHRzdHlsZT17aWNvblN0eWxlfVxuXHRcdFx0XHRcdFx0XHRcdC8+XG5cdFx0XHRcdFx0XHRcdDwvYnV0dG9uPlxuXHRcdFx0XHRcdFx0XHR7dGhpcy5wcm9wcy5leHBhbmRlZCAmJiAoXG5cdFx0XHRcdFx0XHRcdFx0PEJ1dHRvbkRyb3Bkb3duXG5cdFx0XHRcdFx0XHRcdFx0XHRvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259PlxuXHRcdFx0XHRcdFx0XHRcdFx0e3RoaXMuX2dldE1lbnVJdGVtcygpfVxuXHRcdFx0XHRcdFx0XHRcdDwvQnV0dG9uRHJvcGRvd24+XG5cdFx0XHRcdFx0XHRcdCl9XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2dldE1lbnVJdGVtcygpIHtcblx0XHRcdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdFx0XHRcdFx0Y29uc3QgaXRlbXMgPSBtZW51QnV0dG9uRGVmaW5pdGlvbi5vbk1lbnUoKTtcblx0XHRcdFx0XHRjb25zdCBtZW51SXRlbXMgPSBPYmplY3Qua2V5cyhpdGVtcykubWFwKGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgbWVudUl0ZW0gPSBlZGl0b3IuZ2V0TWVudUl0ZW0oa2V5KTtcblxuXHRcdFx0XHRcdFx0aWYgKCFtZW51SXRlbSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgbWVudUl0ZW1EZWZpbml0aW9uID1cblx0XHRcdFx0XHRcdFx0bWVudUl0ZW0uZGVmaW5pdGlvbiB8fCBtZW51SXRlbTtcblx0XHRcdFx0XHRcdGNvbnN0IG1lbnVJdGVtU3RhdGUgPSBpdGVtc1trZXldO1xuXG5cdFx0XHRcdFx0XHRjb25zdCBjbGFzc05hbWUgPVxuXHRcdFx0XHRcdFx0XHQnYWUtdG9vbGJhci1lbGVtZW50ICcgK1xuXHRcdFx0XHRcdFx0XHQobWVudUl0ZW1TdGF0ZSA9PT0gQ0tFRElUT1IuVFJJU1RBVEVfT05cblx0XHRcdFx0XHRcdFx0XHQ/ICdhY3RpdmUnXG5cdFx0XHRcdFx0XHRcdFx0OiAnJyk7XG5cdFx0XHRcdFx0XHRjb25zdCBkaXNhYmxlZCA9XG5cdFx0XHRcdFx0XHRcdG1lbnVJdGVtU3RhdGUgPT09IENLRURJVE9SLlRSSVNUQVRFX0RJU0FCTEVEO1xuXHRcdFx0XHRcdFx0Y29uc3Qgb25DbGljayA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRpZiAobWVudUl0ZW1EZWZpbml0aW9uLmNvbW1hbmQpIHtcblx0XHRcdFx0XHRcdFx0XHRlZGl0b3IuZXhlY0NvbW1hbmQobWVudUl0ZW1EZWZpbml0aW9uLmNvbW1hbmQpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKG1lbnVJdGVtRGVmaW5pdGlvbi5vbkNsaWNrKSB7XG5cdFx0XHRcdFx0XHRcdFx0bWVudUl0ZW1EZWZpbml0aW9uLm9uQ2xpY2suYXBwbHkoXG5cdFx0XHRcdFx0XHRcdFx0XHRtZW51SXRlbURlZmluaXRpb25cblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRcdFx0XHQ8bGkga2V5PXttZW51SXRlbS5uYW1lfSByb2xlPVwib3B0aW9uXCI+XG5cdFx0XHRcdFx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXtjbGFzc05hbWV9XG5cdFx0XHRcdFx0XHRcdFx0XHRkaXNhYmxlZD17ZGlzYWJsZWR9XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkNsaWNrPXtvbkNsaWNrfT5cblx0XHRcdFx0XHRcdFx0XHRcdHttZW51SXRlbURlZmluaXRpb24ubGFiZWx9XG5cdFx0XHRcdFx0XHRcdFx0PC9idXR0b24+XG5cdFx0XHRcdFx0XHRcdDwvbGk+XG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG1lbnVJdGVtcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0QWxsb3lFZGl0b3IuQnV0dG9uc1ttZW51QnV0dG9uTmFtZV0gPSBNZW51QnV0dG9uQnJpZGdlO1xuXHRcdH1cblxuXHRcdHJldHVybiBNZW51QnV0dG9uQnJpZGdlO1xuXHR9XG5cblx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0aWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnbWVudWJ1dHRvbicpKSB7XG5cdFx0Q0tFRElUT1IuVUlfTUVOVV9CVVRUT04gPSAnbWVudWJ1dHRvbic7XG5cblx0XHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnbWVudWJ1dHRvbicsIHt9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gdGhhdCBicmlkZ2VzIHRoZSBzdXBwb3J0IG9mZmVyZWQgYnkgQ0tFZGl0b3IgTWVudUJ1dHRvbiBwbHVnaW4uIEl0IHRha2VzIG92ZXIgdGhlXG5cdCAqIHJlc3BvbnNpYmlsaXR5IG9mIHJlZ2lzdGVyaW5nIGFuZCBjcmVhdGluZyBtZW51QnV0dG9ucyB2aWE6XG5cdCAqIC0gZWRpdG9yLnVpLmFkZE1lbnVCdXR0b24obmFtZSwgZGVmaW5pdGlvbilcblx0ICogLSBlZGl0b3IudWkuYWRkKG5hbWUsIENLRURJVE9SLlVJX01FTlVCVVRUT04sIGRlZmluaXRpb24pXG5cdCAqXG5cdCAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX21lbnVidXR0b25icmlkZ2Vcblx0ICogQHJlcXVpcmVzIENLRURJVE9SLnBsdWdpbnMuYWVfdWlicmlkZ2Vcblx0ICogQHJlcXVpcmVzIENLRURJVE9SLnBsdWdpbnMuYWVfbWVudWJyaWRnZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV9tZW51YnV0dG9uYnJpZGdlJywge1xuXHRcdHJlcXVpcmVzOiBbJ2FlX3VpYnJpZGdlJywgJ2FlX21lbnVicmlkZ2UnXSxcblxuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgYWRkIGhhbmRsZXIgZm9yIFVJX01FTlVCVVRUT04gdG8gb3VyIG93bi4gV2UgZG8gdGhpcyBpbiB0aGUgaW5pdCBwaGFzZSB0byBvdmVycmlkZVxuXHRcdCAqIHRoZSBvbmUgaW4gdGhlIG5hdGl2ZSBwbHVnaW4gaW4gY2FzZSBpdCdzIHByZXNlbnQuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIGluaXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBDS0VkaXRvciBpbnN0YW5jZSBiZWluZyBpbml0aWFsaXplZFxuXHRcdCAqL1xuXHRcdGJlZm9yZUluaXQoZWRpdG9yKSB7XG5cdFx0XHRlZGl0b3IudWkuYWRkTWVudUJ1dHRvbiA9IGZ1bmN0aW9uKFxuXHRcdFx0XHRtZW51QnV0dG9uTmFtZSxcblx0XHRcdFx0bWVudUJ1dHRvbkRlZmluaXRpb25cblx0XHRcdCkge1xuXHRcdFx0XHR0aGlzLmFkZChcblx0XHRcdFx0XHRtZW51QnV0dG9uTmFtZSxcblx0XHRcdFx0XHRDS0VESVRPUi5VSV9NRU5VQlVUVE9OLFxuXHRcdFx0XHRcdG1lbnVCdXR0b25EZWZpbml0aW9uXG5cdFx0XHRcdCk7XG5cdFx0XHR9O1xuXG5cdFx0XHRlZGl0b3IudWkuYWRkSGFuZGxlcihDS0VESVRPUi5VSV9NRU5VQlVUVE9OLCB7XG5cdFx0XHRcdGFkZDogZ2VuZXJhdGVNZW51QnV0dG9uQnJpZGdlLFxuXHRcdFx0XHRjcmVhdGUobWVudUJ1dHRvbkRlZmluaXRpb24pIHtcblx0XHRcdFx0XHRjb25zdCBtZW51QnV0dG9uTmFtZSA9XG5cdFx0XHRcdFx0XHQnYnV0dG9uQnJpZGdlJyArICgoTWF0aC5yYW5kb20oKSAqIDFlOSkgPj4+IDApO1xuXHRcdFx0XHRcdGNvbnN0IE1lbnVCdXR0b25CcmlkZ2UgPSBnZW5lcmF0ZU1lbnVCdXR0b25CcmlkZ2UoXG5cdFx0XHRcdFx0XHRtZW51QnV0dG9uTmFtZSxcblx0XHRcdFx0XHRcdG1lbnVCdXR0b25EZWZpbml0aW9uXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdHJldHVybiBuZXcgTWVudUJ1dHRvbkJyaWRnZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX21lbnVicmlkZ2UnKSkge1xuXHQvKipcblx0ICogQ0tFZGl0b3IgcGx1Z2luIHRoYXQgYnJpZGdlcyB0aGUgc3VwcG9ydCBvZmZlcmVkIGJ5IENLRWRpdG9yIE1lbnUgcGx1Z2luLiBJdCB0YWtlcyBvdmVyIHRoZVxuXHQgKiByZXNwb25zaWJpbGl0eSBvZiBhZGRpbmcsIHJlbW92aW5nIGFuZCByZXRyaWV2aW5nIG1lbnUgZ3JvdXBzIGFuZCBpdGVtc1xuXHQgKiAtIGVkaXRvci5hZGRNZW51R3JvdXAobmFtZSwgb3JkZXIpXG5cdCAqIC0gZWRpdG9yLmFkZE1lbnVJdGVtKG5hbWUsIGRlZmluaXRpb24pXG5cdCAqIC0gZWRpdG9yLmFkZE1lbnVJdGVtcyhkZWZpbml0aW9ucylcblx0ICogLSBlZGl0b3IuZ2V0TWVudUl0ZW0obmFtZSlcblx0ICogLSBlZGl0b3IucmVtb3ZlTWVudUl0ZW0obmFtZSlcblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfbWVudWJyaWRnZVxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV9tZW51YnJpZGdlJywge1xuXHRcdC8qKlxuXHRcdCAqIFNldCB0aGUgYWRkIGhhbmRsZXIgZm9yIFVJX0JVVFRPTiB0byBvdXIgb3duLiBXZSBkbyB0aGlzIGluIHRoZSBpbml0IHBoYXNlIHRvIG92ZXJyaWRlXG5cdFx0ICogdGhlIG9uZSBpbiB0aGUgbmF0aXZlIHBsdWdpbiBpbiBjYXNlIGl0J3MgcHJlc2VudC5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgaW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIENLRWRpdG9yIGluc3RhbmNlIGJlaW5nIGluaXRpYWxpemVkXG5cdFx0ICovXG5cdFx0YmVmb3JlSW5pdChlZGl0b3IpIHtcblx0XHRcdC8vIERvIG5vdGhpbmcgaWYgdGhlIHJlYWwgbWVudSBwbHVnaW4gaXMgcHJlc2VudFxuXHRcdFx0aWYgKENLRURJVE9SLnBsdWdpbnMuZ2V0KCdtZW51JykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBncm91cHMgPSBbXTtcblx0XHRcdGNvbnN0IGdyb3Vwc09yZGVyID0gKGVkaXRvci5fLm1lbnVHcm91cHMgPSB7fSk7XG5cdFx0XHRjb25zdCBtZW51SXRlbXMgPSAoZWRpdG9yLl8ubWVudUl0ZW1zID0ge30pO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRncm91cHNPcmRlcltncm91cHNbaV1dID0gaSArIDE7XG5cdFx0XHR9XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmVnaXN0ZXJzIGFuIGl0ZW0gZ3JvdXAgdG8gdGhlIGVkaXRvciBjb250ZXh0IG1lbnUgaW4gb3JkZXIgdG8gbWFrZSBpdFxuXHRcdFx0ICogcG9zc2libGUgdG8gYXNzb2NpYXRlIGl0IHdpdGggbWVudSBpdGVtcyBsYXRlci5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWV0aG9kIGFkZE1lbnVHcm91cFxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgU3BlY2lmeSBhIGdyb3VwIG5hbWUuXG5cdFx0XHQgKiBAcGFyYW0ge051bWJlcn0gW29yZGVyPTEwMF0gRGVmaW5lIHRoZSBkaXNwbGF5IHNlcXVlbmNlIG9mIHRoaXMgZ3JvdXBcblx0XHRcdCAqIGluc2lkZSB0aGUgbWVudS4gQSBzbWFsbGVyIHZhbHVlIGdldHMgZGlzcGxheWVkIGZpcnN0LlxuXHRcdFx0ICovXG5cdFx0XHRlZGl0b3IuYWRkTWVudUdyb3VwID0gZnVuY3Rpb24obmFtZSwgb3JkZXIpIHtcblx0XHRcdFx0Z3JvdXBzT3JkZXJbbmFtZV0gPSBvcmRlciB8fCAxMDA7XG5cdFx0XHR9O1xuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFkZHMgYW4gaXRlbSBmcm9tIHRoZSBzcGVjaWZpZWQgZGVmaW5pdGlvbiB0byB0aGUgZWRpdG9yIGNvbnRleHQgbWVudS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWV0aG9kIGFkZE1lbnVJdGVtXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbWVudSBpdGVtIG5hbWUuXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZGVmaW5pdGlvbiBUaGUgbWVudSBpdGVtIGRlZmluaXRpb24uXG5cdFx0XHQgKi9cblx0XHRcdGVkaXRvci5hZGRNZW51SXRlbSA9IGZ1bmN0aW9uKG5hbWUsIGRlZmluaXRpb24pIHtcblx0XHRcdFx0aWYgKGdyb3Vwc09yZGVyW2RlZmluaXRpb24uZ3JvdXBdKSB7XG5cdFx0XHRcdFx0bWVudUl0ZW1zW25hbWVdID0ge1xuXHRcdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRcdGRlZmluaXRpb24sXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBBZGRzIG9uZSBvciBtb3JlIGl0ZW1zIGZyb20gdGhlIHNwZWNpZmllZCBkZWZpbml0aW9uIG9iamVjdCB0byB0aGUgZWRpdG9yIGNvbnRleHQgbWVudS5cblx0XHRcdCAqXG5cdFx0XHQgKiBAbWV0aG9kIGFkZE1lbnVJdGVtc1xuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGRlZmluaXRpb25zIE9iamVjdCB3aGVyZSBrZXlzIGFyZSB1c2VkIGFzIGl0ZW1OYW1lIGFuZCBjb3JyZXNwb25kaW5nIHZhbHVlcyBhcyBkZWZpbml0aW9uIGZvciBhIHtAbGluayAjYWRkTWVudUl0ZW19IGNhbGwuXG5cdFx0XHQgKi9cblx0XHRcdGVkaXRvci5hZGRNZW51SXRlbXMgPSBmdW5jdGlvbihkZWZpbml0aW9ucykge1xuXHRcdFx0XHRmb3IgKGNvbnN0IGl0ZW1OYW1lIGluIGRlZmluaXRpb25zKSB7XG5cdFx0XHRcdFx0aWYgKGRlZmluaXRpb25zLmhhc093blByb3BlcnR5KGl0ZW1OYW1lKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5hZGRNZW51SXRlbShpdGVtTmFtZSwgZGVmaW5pdGlvbnNbaXRlbU5hbWVdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0cmlldmVzIGEgcGFydGljdWxhciBtZW51IGl0ZW0gZGVmaW5pdGlvbiBmcm9tIHRoZSBlZGl0b3IgY29udGV4dCBtZW51LlxuXHRcdFx0ICpcblx0XHRcdCAqIEBtZXRob2QgZ2V0TWVudUl0ZW1cblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBkZXNpcmVkIG1lbnUgaXRlbS5cblx0XHRcdCAqIEByZXR1cm4ge09iamVjdH1cblx0XHRcdCAqL1xuXHRcdFx0ZWRpdG9yLmdldE1lbnVJdGVtID0gZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHRyZXR1cm4gbWVudUl0ZW1zW25hbWVdO1xuXHRcdFx0fTtcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZW1vdmVzIGEgcGFydGljdWxhciBtZW51IGl0ZW0gYWRkZWQgYmVmb3JlIGZyb20gdGhlIGVkaXRvciBjb250ZXh0IG1lbnUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQG1ldGhvZCAgcmVtb3ZlTWVudUl0ZW1cblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBkZXNpcmVkIG1lbnUgaXRlbS5cblx0XHRcdCAqL1xuXHRcdFx0ZWRpdG9yLnJlbW92ZU1lbnVJdGVtID0gZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHRkZWxldGUgbWVudUl0ZW1zW25hbWVdO1xuXHRcdFx0fTtcblx0XHR9LFxuXHR9KTtcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgQnV0dG9uRHJvcGRvd24gZnJvbSAnLi4vYnV0dG9ucy9idXR0b24tZHJvcGRvd24uanN4JztcbmltcG9ydCBFZGl0b3JDb250ZXh0IGZyb20gJy4uLy4uL2FkYXB0ZXIvZWRpdG9yLWNvbnRleHQnO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3BhbmVsbWVudWJ1dHRvbmJyaWRnZScpKSB7XG5cdGNvbnN0IFBBTkVMX01FTlVfREVGUyA9IHt9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSBQYW5lbE1lbnVCdXR0b25CcmlkZ2UgUmVhY3QgY2xhc3MgZm9yIGEgZ2l2ZW4gcGFuZWxtZW51YnV0dG9uIGRlZmluaXRpb24gaWYgaXQgaGFzIG5vdCBiZWVuXG5cdCAqIGFscmVhZHkgY3JlYXRlZCBiYXNlZCBvbiB0aGUgcGFuZWxtZW51YnV0dG9uIG5hbWUgYW5kIGRlZmluaXRpb24uXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBtZXRob2QgZ2VuZXJhdGVQYW5lbE1lbnVCdXR0b25CcmlkZ2Vcblx0ICogQHBhcmFtIHtTdHJpbmd9IHBhbmVsTWVudUJ1dHRvbk5hbWUgVGhlIHBhbmVsIGJ1dHRvbiBuYW1lXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYW5lbE1lbnVCdXR0b25EZWZpbml0aW9uIFRoZSBwYW5lbCBidXR0b24gZGVmaW5pdGlvblxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBnZW5lcmF0ZWQgb3IgYWxyZWFkeSBleGlzdGluZyBSZWFjdCBQYW5lbE1lbnVCdXR0b24gQ2xhc3Ncblx0ICovXG5cdGNvbnN0IGdlbmVyYXRlUGFuZWxNZW51QnV0dG9uQnJpZGdlID0gZnVuY3Rpb24oXG5cdFx0cGFuZWxNZW51QnV0dG9uTmFtZSxcblx0XHRwYW5lbE1lbnVCdXR0b25EZWZpbml0aW9uLFxuXHRcdGVkaXRvclxuXHQpIHtcblx0XHRsZXQgUGFuZWxNZW51QnV0dG9uQnJpZGdlID0gQWxsb3lFZGl0b3IuQnV0dG9uc1twYW5lbE1lbnVCdXR0b25OYW1lXTtcblxuXHRcdFBBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV0gPSBQQU5FTF9NRU5VX0RFRlNbZWRpdG9yLm5hbWVdIHx8IHt9O1xuXHRcdFBBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV1bcGFuZWxNZW51QnV0dG9uTmFtZV0gPVxuXHRcdFx0UEFORUxfTUVOVV9ERUZTW2VkaXRvci5uYW1lXVtwYW5lbE1lbnVCdXR0b25OYW1lXSB8fFxuXHRcdFx0cGFuZWxNZW51QnV0dG9uRGVmaW5pdGlvbjtcblxuXHRcdGlmICghUGFuZWxNZW51QnV0dG9uQnJpZGdlKSB7XG5cdFx0XHRQYW5lbE1lbnVCdXR0b25CcmlkZ2UgPSBjbGFzcyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdFx0XHRcdHN0YXRpYyBjb250ZXh0VHlwZSA9IEVkaXRvckNvbnRleHQ7XG5cblx0XHRcdFx0c3RhdGljIGRpc3BsYXlOYW1lID0gcGFuZWxNZW51QnV0dG9uTmFtZTtcblxuXHRcdFx0XHRzdGF0aWMga2V5ID0gcGFuZWxNZW51QnV0dG9uTmFtZTtcblxuXHRcdFx0XHQvLyBBUEkgbm90IHlldCBpbXBsZW1lbnRlZCBpbnNpZGUgdGhlIHBhbmVsIG1lbnUgYnV0dG9uIGJyaWRnZS4gQnkgbW9ja2luZyB0aGUgdW5zdXBwb3J0ZWQgbWV0aG9kcywgd2Vcblx0XHRcdFx0Ly8gcHJldmVudCBwbHVnaW5zIGZyb20gY3Jhc2hpbmcgaWYgdGhleSBtYWtlIHVzZSBvZiB0aGVtLlxuXHRcdFx0XHRjcmVhdGVQYW5lbCgpIHt9XG5cblx0XHRcdFx0cmVuZGVyKCkge1xuXHRcdFx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0XHRcdGNvbnN0IHBhbmVsTWVudUJ1dHRvbkRpc3BsYXlOYW1lID1cblx0XHRcdFx0XHRcdFBBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV1bcGFuZWxNZW51QnV0dG9uTmFtZV1cblx0XHRcdFx0XHRcdFx0Lm5hbWUgfHxcblx0XHRcdFx0XHRcdFBBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV1bcGFuZWxNZW51QnV0dG9uTmFtZV1cblx0XHRcdFx0XHRcdFx0LmNvbW1hbmQgfHxcblx0XHRcdFx0XHRcdHBhbmVsTWVudUJ1dHRvbk5hbWU7XG5cblx0XHRcdFx0XHRjb25zdCBidXR0b25DbGFzc05hbWUgPSAnYWUtYnV0dG9uIGFlLWJ1dHRvbi1icmlkZ2UnO1xuXG5cdFx0XHRcdFx0Y29uc3QgaWNvbkNsYXNzTmFtZSA9XG5cdFx0XHRcdFx0XHQnYWUtaWNvbi0nICsgcGFuZWxNZW51QnV0dG9uRGlzcGxheU5hbWU7XG5cblx0XHRcdFx0XHRjb25zdCBpY29uU3R5bGUgPSB7fTtcblxuXHRcdFx0XHRcdGNvbnN0IGNzc1N0eWxlID0gQ0tFRElUT1Iuc2tpbi5nZXRJY29uU3R5bGUoXG5cdFx0XHRcdFx0XHRwYW5lbE1lbnVCdXR0b25EaXNwbGF5TmFtZVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAoY3NzU3R5bGUpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGNzc1N0eWxlUGFydHMgPSBjc3NTdHlsZS5zcGxpdCgnOycpO1xuXG5cdFx0XHRcdFx0XHRpY29uU3R5bGUuYmFja2dyb3VuZEltYWdlID0gY3NzU3R5bGVQYXJ0c1swXS5zdWJzdHJpbmcoXG5cdFx0XHRcdFx0XHRcdGNzc1N0eWxlUGFydHNbMF0uaW5kZXhPZignOicpICsgMVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGljb25TdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSBjc3NTdHlsZVBhcnRzWzFdLnN1YnN0cmluZyhcblx0XHRcdFx0XHRcdFx0Y3NzU3R5bGVQYXJ0c1sxXS5pbmRleE9mKCc6JykgKyAxXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0aWNvblN0eWxlLmJhY2tncm91bmRTaXplID0gY3NzU3R5bGVQYXJ0c1syXS5zdWJzdHJpbmcoXG5cdFx0XHRcdFx0XHRcdGNzc1N0eWxlUGFydHNbMl0uaW5kZXhPZignOicpICsgMVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsZXQgcGFuZWw7XG5cblx0XHRcdFx0XHRpZiAodGhpcy5wcm9wcy5leHBhbmRlZCkge1xuXHRcdFx0XHRcdFx0cGFuZWwgPSB0aGlzLl9nZXRQYW5lbCgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHQ8ZGl2IGNsYXNzTmFtZT1cImFlLWNvbnRhaW5lciBhZS1oYXMtZHJvcGRvd25cIj5cblx0XHRcdFx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRcdGFyaWEtZXhwYW5kZWQ9e3RoaXMucHJvcHMuZXhwYW5kZWR9XG5cdFx0XHRcdFx0XHRcdFx0YXJpYS1sYWJlbD17XG5cdFx0XHRcdFx0XHRcdFx0XHRQQU5FTF9NRU5VX0RFRlNbZWRpdG9yLm5hbWVdW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYW5lbE1lbnVCdXR0b25OYW1lXG5cdFx0XHRcdFx0XHRcdFx0XHRdLmxhYmVsXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGNsYXNzTmFtZT17YnV0dG9uQ2xhc3NOYW1lfVxuXHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdFx0XHRcdFx0cm9sZT1cImNvbWJvYm94XCJcblx0XHRcdFx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHRcdFx0XHR0aXRsZT17XG5cdFx0XHRcdFx0XHRcdFx0XHRQQU5FTF9NRU5VX0RFRlNbZWRpdG9yLm5hbWVdW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYW5lbE1lbnVCdXR0b25OYW1lXG5cdFx0XHRcdFx0XHRcdFx0XHRdLmxhYmVsXG5cdFx0XHRcdFx0XHRcdFx0fT5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXtpY29uQ2xhc3NOYW1lfVxuXHRcdFx0XHRcdFx0XHRcdFx0c3R5bGU9e2ljb25TdHlsZX1cblx0XHRcdFx0XHRcdFx0XHQvPlxuXHRcdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHRcdFx0e3BhbmVsfVxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9nZXRQYW5lbCgpIHtcblx0XHRcdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdFx0XHRjb25zdCBwYW5lbE1lbnVCdXR0b25PbkJsb2NrID1cblx0XHRcdFx0XHRcdFBBTkVMX01FTlVfREVGU1tlZGl0b3IubmFtZV1bcGFuZWxNZW51QnV0dG9uTmFtZV1cblx0XHRcdFx0XHRcdFx0Lm9uQmxvY2s7XG5cblx0XHRcdFx0XHRjb25zdCBwYW5lbCA9IHtcblx0XHRcdFx0XHRcdGhpZGU6IHRoaXMucHJvcHMudG9nZ2xlRHJvcGRvd24sXG5cdFx0XHRcdFx0XHRzaG93OiB0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3duLFxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRjb25zdCBibG9ja0VsZW1lbnQgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoJ2RpdicpO1xuXG5cdFx0XHRcdFx0Y29uc3QgYmxvY2sgPSB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiBibG9ja0VsZW1lbnQsXG5cdFx0XHRcdFx0XHRrZXlzOiB7fSxcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0XHRcdFx0XHRpZiAocGFuZWxNZW51QnV0dG9uT25CbG9jaykge1xuXHRcdFx0XHRcdFx0cGFuZWxNZW51QnV0dG9uT25CbG9jay5jYWxsKHRoaXMsIHBhbmVsLCBibG9jayk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gVE9ET1xuXHRcdFx0XHRcdC8vIFVzZSBibG9jay5rZXlzIHRvIGNvbmZpZ3VyZSB0aGUgcGFuZWwga2V5Ym9hcmQgbmF2aWdhdGlvblxuXG5cdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdDxCdXR0b25Ecm9wZG93biBvbkRpc21pc3M9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259PlxuXHRcdFx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHRcdFx0Y2xhc3NOYW1lPXtibG9ja0VsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpfVxuXHRcdFx0XHRcdFx0XHRcdGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7XG5cdFx0XHRcdFx0XHRcdFx0XHRfX2h0bWw6IGJsb2NrRWxlbWVudC5nZXRIdG1sKCksXG5cdFx0XHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdDwvQnV0dG9uRHJvcGRvd24+XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0QWxsb3lFZGl0b3IuQnV0dG9uc1twYW5lbE1lbnVCdXR0b25OYW1lXSA9IFBhbmVsTWVudUJ1dHRvbkJyaWRnZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gUGFuZWxNZW51QnV0dG9uQnJpZGdlO1xuXHR9O1xuXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdGlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ3BhbmVsbWVudWJ1dHRvbicpKSB7XG5cdFx0Q0tFRElUT1IuVUlfUEFORUxCVVRUT04gPSAncGFuZWxtZW51YnV0dG9uJztcblxuXHRcdENLRURJVE9SLnBsdWdpbnMuYWRkKCdwYW5lbG1lbnVidXR0b24nLCB7fSk7XG5cdH1cblxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuXHRpZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdwYW5lbGJ1dHRvbicpKSB7XG5cdFx0Q0tFRElUT1IuVUlfUEFORUxCVVRUT04gPSAncGFuZWxidXR0b24nO1xuXG5cdFx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ3BhbmVsYnV0dG9uJywge30pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENLRWRpdG9yIHBsdWdpbiB0aGF0IGJyaWRnZXMgdGhlIHN1cHBvcnQgb2ZmZXJlZCBieSBDS0VkaXRvciBQYW5lbEJ1dHRvbiBwbHVnaW4uIEl0IHRha2VzIG92ZXIgdGhlXG5cdCAqIHJlc3BvbnNpYmlsaXR5IG9mIHJlZ2lzdGVyaW5nIGFuZCBjcmVhdGluZyBidXR0b25zIHZpYTpcblx0ICogLSBlZGl0b3IudWkuYWRkUGFuZWxNZW51QnV0dG9uKG5hbWUsIGRlZmluaXRpb24pXG5cdCAqIC0gZWRpdG9yLnVpLmFkZChuYW1lLCBDS0VESVRPUi5VSV9QQU5FTEJVVFRPTiwgZGVmaW5pdGlvbilcblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfcGFuZWxtZW51YnV0dG9uYnJpZGdlXG5cdCAqIEByZXF1aXJlcyBDS0VESVRPUi5wbHVnaW5zLmFlX3VpYnJpZGdlXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3BhbmVsbWVudWJ1dHRvbmJyaWRnZScsIHtcblx0XHRyZXF1aXJlczogWydhZV91aWJyaWRnZSddLFxuXG5cdFx0LyoqXG5cdFx0ICogU2V0IHRoZSBhZGQgaGFuZGxlciBmb3IgVUlfUEFORUxCVVRUT04gdG8gb3VyIG93bi4gV2UgZG8gdGhpcyBpbiB0aGUgaW5pdCBwaGFzZSB0byBvdmVycmlkZVxuXHRcdCAqIHRoZSBvbmUgaW4gdGhlIG5hdGl2ZSBwbHVnaW4gaW4gY2FzZSBpdCdzIHByZXNlbnRcblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgaW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIENLRWRpdG9yIGluc3RhbmNlIGJlaW5nIGluaXRpYWxpemVkXG5cdFx0ICovXG5cdFx0YmVmb3JlSW5pdChlZGl0b3IpIHtcblx0XHRcdGVkaXRvci51aS5hZGRQYW5lbE1lbnVCdXR0b24gPSBmdW5jdGlvbihcblx0XHRcdFx0cGFuZWxNZW51QnV0dG9uTmFtZSxcblx0XHRcdFx0cGFuZWxNZW51QnV0dG9uRGVmaW5pdGlvblxuXHRcdFx0KSB7XG5cdFx0XHRcdHRoaXMuYWRkKFxuXHRcdFx0XHRcdHBhbmVsTWVudUJ1dHRvbk5hbWUsXG5cdFx0XHRcdFx0Q0tFRElUT1IuVUlfUEFORUxCVVRUT04sXG5cdFx0XHRcdFx0cGFuZWxNZW51QnV0dG9uRGVmaW5pdGlvblxuXHRcdFx0XHQpO1xuXHRcdFx0fTtcblxuXHRcdFx0ZWRpdG9yLnVpLmFkZEhhbmRsZXIoQ0tFRElUT1IuVUlfUEFORUxCVVRUT04sIHtcblx0XHRcdFx0YWRkOiBnZW5lcmF0ZVBhbmVsTWVudUJ1dHRvbkJyaWRnZSxcblx0XHRcdFx0Y3JlYXRlKHBhbmVsTWVudUJ1dHRvbkRlZmluaXRpb24pIHtcblx0XHRcdFx0XHRjb25zdCBwYW5lbE1lbnVCdXR0b25OYW1lID1cblx0XHRcdFx0XHRcdCdwYW5lbE1lbnVCdXR0b25CcmlkZ2UnICsgKChNYXRoLnJhbmRvbSgpICogMWU5KSA+Pj4gMCk7XG5cdFx0XHRcdFx0Y29uc3QgUGFuZWxNZW51QnV0dG9uQnJpZGdlID0gZ2VuZXJhdGVQYW5lbE1lbnVCdXR0b25CcmlkZ2UoXG5cdFx0XHRcdFx0XHRwYW5lbE1lbnVCdXR0b25OYW1lLFxuXHRcdFx0XHRcdFx0cGFuZWxNZW51QnV0dG9uRGVmaW5pdGlvblxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFBhbmVsTWVudUJ1dHRvbkJyaWRnZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IEJ1dHRvbkRyb3Bkb3duIGZyb20gJy4uL2J1dHRvbnMvYnV0dG9uLWRyb3Bkb3duLmpzeCc7XG5pbXBvcnQgQnV0dG9uSWNvbiBmcm9tICcuLi9idXR0b25zL2J1dHRvbi1pY29uLmpzeCc7XG5pbXBvcnQgRWRpdG9yQ29udGV4dCBmcm9tICcuLi8uLi9hZGFwdGVyL2VkaXRvci1jb250ZXh0JztcblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9yaWNoY29tYm9icmlkZ2UnKSkge1xuXHRjb25zdCBSSUNIX0NPTUJPX0RFRlMgPSB7fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIGEgUmljaENvbWJvQnJpZGdlIFJlYWN0IGNsYXNzIGZvciBhIGdpdmVuIHJpY2hjb21ibyBkZWZpbml0aW9uIGlmIGl0IGhhcyBub3QgYmVlblxuXHQgKiBhbHJlYWR5IGNyZWF0ZWQgYmFzZWQgb24gdGhlIHJpY2hjb21ibyBuYW1lIGFuZCBkZWZpbml0aW9uLlxuXHQgKlxuXHQgKiBAbWV0aG9kIGdlbmVyYXRlUmljaENvbWJvQnJpZGdlXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSByaWNoQ29tYm9OYW1lIFRoZSByaWNoIGNvbWJvIG5hbWVcblx0ICogQHBhcmFtIHtPYmplY3R9IHJpY2hDb21ib0RlZmluaXRpb24gVGhlIHJpY2ggY29tYm8gZGVmaW5pdGlvblxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBnZW5lcmF0ZWQgb3IgYWxyZWFkeSBleGlzdGluZyBSZWFjdCBSaWNoQ29tYm8gQ2xhc3Ncblx0ICovXG5cdGNvbnN0IGdlbmVyYXRlUmljaENvbWJvQnJpZGdlID0gZnVuY3Rpb24oXG5cdFx0cmljaENvbWJvTmFtZSxcblx0XHRyaWNoQ29tYm9EZWZpbml0aW9uLFxuXHRcdGVkaXRvclxuXHQpIHtcblx0XHRsZXQgUmljaENvbWJvQnJpZGdlID0gQWxsb3lFZGl0b3IuQnV0dG9uc1tyaWNoQ29tYm9OYW1lXTtcblxuXHRcdFJJQ0hfQ09NQk9fREVGU1tlZGl0b3IubmFtZV0gPSBSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdIHx8IHt9O1xuXHRcdFJJQ0hfQ09NQk9fREVGU1tlZGl0b3IubmFtZV1bcmljaENvbWJvTmFtZV0gPVxuXHRcdFx0UklDSF9DT01CT19ERUZTW2VkaXRvci5uYW1lXVtyaWNoQ29tYm9OYW1lXSB8fCByaWNoQ29tYm9EZWZpbml0aW9uO1xuXHRcdFJJQ0hfQ09NQk9fREVGU1tlZGl0b3IubmFtZV1bcmljaENvbWJvTmFtZV0uY3VycmVudFZhbHVlID0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKCFSaWNoQ29tYm9CcmlkZ2UpIHtcblx0XHRcdFJpY2hDb21ib0JyaWRnZSA9IGNsYXNzIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcblx0XHRcdFx0c3RhdGljIGNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcblxuXHRcdFx0XHRzdGF0aWMgZGlzcGxheU5hbWUgPSByaWNoQ29tYm9OYW1lO1xuXG5cdFx0XHRcdHN0YXRpYyBrZXkgPSByaWNoQ29tYm9OYW1lO1xuXG5cdFx0XHRcdGNvbnN0cnVjdG9yKHByb3BzKSB7XG5cdFx0XHRcdFx0c3VwZXIocHJvcHMpO1xuXHRcdFx0XHRcdHRoaXMuc3RhdGUgPSB7XG5cdFx0XHRcdFx0XHR2YWx1ZTpcblx0XHRcdFx0XHRcdFx0UklDSF9DT01CT19ERUZTW2VkaXRvci5uYW1lXVtyaWNoQ29tYm9OYW1lXVxuXHRcdFx0XHRcdFx0XHRcdC5jdXJyZW50VmFsdWUsXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFQSSBub3QgeWV0IGltcGxlbWVudGVkIGluc2lkZSB0aGUgcmljaGNvbWJvIGJyaWRnZS4gQnkgbW9ja2luZyB0aGUgdW5zdXBwb3J0ZWQgbWV0aG9kcywgd2Vcblx0XHRcdFx0Ly8gcHJldmVudCBwbHVnaW5zIGZyb20gY3Jhc2hpbmcgaWYgdGhleSBtYWtlIHVzZSBvZiB0aGVtLlxuXHRcdFx0XHRjb21taXQoKSB7fVxuXHRcdFx0XHRjcmVhdGVQYW5lbCgpIHt9XG5cdFx0XHRcdGRpc2FibGUoKSB7fVxuXHRcdFx0XHRlbmFibGUoKSB7fVxuXHRcdFx0XHRnZXRTdGF0ZSgpIHt9XG5cdFx0XHRcdGhpZGVHcm91cCgpIHt9XG5cdFx0XHRcdGhpZGVJdGVtKCkge31cblx0XHRcdFx0bWFyaygpIHt9XG5cdFx0XHRcdHNob3dBbGwoKSB7fVxuXHRcdFx0XHRzdGFydEdyb3VwKCkge31cblx0XHRcdFx0dW5tYXJrQWxsKCkge31cblxuXHRcdFx0XHRhZGQodmFsdWUsIHByZXZpZXcsIHRpdGxlKSB7XG5cdFx0XHRcdFx0dGhpcy5faXRlbXMucHVzaCh7XG5cdFx0XHRcdFx0XHRwcmV2aWV3LFxuXHRcdFx0XHRcdFx0dGl0bGUsXG5cdFx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbXBvbmVudFdpbGxNb3VudCgpIHtcblx0XHRcdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdFx0XHRjb25zdCBlZGl0b3JDb21ibyA9XG5cdFx0XHRcdFx0XHRSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW3JpY2hDb21ib05hbWVdO1xuXG5cdFx0XHRcdFx0dGhpcy5faXRlbXMgPSBbXTtcblxuXHRcdFx0XHRcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZTtcblxuXHRcdFx0XHRcdGlmIChlZGl0b3JDb21iby5pbml0KSB7XG5cdFx0XHRcdFx0XHRlZGl0b3JDb21iby5pbml0LmNhbGwodGhpcyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGVkaXRvckNvbWJvLm9uUmVuZGVyKSB7XG5cdFx0XHRcdFx0XHRlZGl0b3JDb21iby5vblJlbmRlci5jYWxsKHRoaXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuXHRcdFx0XHRcdHRoaXMuX2NhY2hlVmFsdWUodGhpcy5zdGF0ZS52YWx1ZSk7XG5cblx0XHRcdFx0XHR0aGlzLnNldFZhbHVlID0gdGhpcy5fY2FjaGVWYWx1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGdldFZhbHVlKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnN0YXRlLnZhbHVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVuZGVyKCkge1xuXHRcdFx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0XHRcdGNvbnN0IHJpY2hDb21ib0xhYmVsID1cblx0XHRcdFx0XHRcdFJJQ0hfQ09NQk9fREVGU1tlZGl0b3IubmFtZV1bcmljaENvbWJvTmFtZV1cblx0XHRcdFx0XHRcdFx0LmN1cnJlbnRWYWx1ZSB8fCByaWNoQ29tYm9EZWZpbml0aW9uLmxhYmVsO1xuXG5cdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyLWRyb3Bkb3duIGFlLWhhcy1kcm9wZG93blwiPlxuXHRcdFx0XHRcdFx0XHQ8YnV0dG9uXG5cdFx0XHRcdFx0XHRcdFx0YXJpYS1leHBhbmRlZD17dGhpcy5wcm9wcy5leHBhbmRlZH1cblx0XHRcdFx0XHRcdFx0XHRhcmlhLWxhYmVsPXtyaWNoQ29tYm9MYWJlbH1cblx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9XCJhZS10b29sYmFyLWVsZW1lbnRcIlxuXHRcdFx0XHRcdFx0XHRcdG9uQ2xpY2s9e3RoaXMucHJvcHMudG9nZ2xlRHJvcGRvd259XG5cdFx0XHRcdFx0XHRcdFx0cm9sZT1cImNvbWJvYm94XCJcblx0XHRcdFx0XHRcdFx0XHR0YWJJbmRleD17dGhpcy5wcm9wcy50YWJJbmRleH1cblx0XHRcdFx0XHRcdFx0XHR0aXRsZT17cmljaENvbWJvTGFiZWx9PlxuXHRcdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3NOYW1lPVwiYWUtY29udGFpbmVyXCI+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzc05hbWU9XCJhZS1jb250YWluZXItZHJvcGRvd24tc2VsZWN0ZWQtaXRlbVwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7cmljaENvbWJvTGFiZWx9XG5cdFx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8QnV0dG9uSWNvbiBzeW1ib2w9XCJjYXJldC1ib3R0b21cIiAvPlxuXHRcdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0XHRcdFx0e3RoaXMucHJvcHMuZXhwYW5kZWQgJiYgKFxuXHRcdFx0XHRcdFx0XHRcdDxCdXR0b25Ecm9wZG93blxuXHRcdFx0XHRcdFx0XHRcdFx0b25EaXNtaXNzPXt0aGlzLnByb3BzLnRvZ2dsZURyb3Bkb3dufT5cblx0XHRcdFx0XHRcdFx0XHRcdHt0aGlzLl9nZXRJdGVtcygpfVxuXHRcdFx0XHRcdFx0XHRcdDwvQnV0dG9uRHJvcGRvd24+XG5cdFx0XHRcdFx0XHRcdCl9XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0X2NhY2hlVmFsdWUodmFsdWUpIHtcblx0XHRcdFx0XHRjb25zdCBlZGl0b3IgPSB0aGlzLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0XHRcdFx0XHRSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW1xuXHRcdFx0XHRcdFx0cmljaENvbWJvTmFtZVxuXHRcdFx0XHRcdF0uY3VycmVudFZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRfZ2V0SXRlbXMoKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmljaENvbWJvID0gdGhpcztcblxuXHRcdFx0XHRcdGNvbnN0IGl0ZW1zID0gdGhpcy5faXRlbXMubWFwKFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBjbGFzc05hbWUgPVxuXHRcdFx0XHRcdFx0XHRcdCdhZS10b29sYmFyLWVsZW1lbnQgJyArXG5cdFx0XHRcdFx0XHRcdFx0KGl0ZW0udmFsdWUgPT09IHRoaXMuc3RhdGUudmFsdWVcblx0XHRcdFx0XHRcdFx0XHRcdD8gJ2FjdGl2ZSdcblx0XHRcdFx0XHRcdFx0XHRcdDogJycpO1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiAoXG5cdFx0XHRcdFx0XHRcdFx0PGxpIGtleT17aXRlbS50aXRsZX0gcm9sZT1cIm9wdGlvblwiPlxuXHRcdFx0XHRcdFx0XHRcdFx0PGJ1dHRvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzc05hbWU9e2NsYXNzTmFtZX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3tcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfX2h0bWw6IGl0ZW0ucHJldmlldyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0fX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS12YWx1ZT17aXRlbS52YWx1ZX1cblx0XHRcdFx0XHRcdFx0XHRcdFx0b25DbGljaz17cmljaENvbWJvLl9vbkNsaWNrfVxuXHRcdFx0XHRcdFx0XHRcdFx0Lz5cblx0XHRcdFx0XHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fS5iaW5kKHRoaXMpXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdHJldHVybiBpdGVtcztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdF9vbkNsaWNrID0gZXZlbnQgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuY29udGV4dC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblxuXHRcdFx0XHRcdGNvbnN0IGVkaXRvckNvbWJvID1cblx0XHRcdFx0XHRcdFJJQ0hfQ09NQk9fREVGU1tlZGl0b3IubmFtZV1bcmljaENvbWJvTmFtZV07XG5cblx0XHRcdFx0XHRpZiAoZWRpdG9yQ29tYm8ub25DbGljaykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbmV3VmFsdWUgPSBldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcblx0XHRcdFx0XHRcdFx0J2RhdGEtdmFsdWUnXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRlZGl0b3JDb21iby5vbkNsaWNrLmNhbGwodGhpcywgbmV3VmFsdWUpO1xuXG5cdFx0XHRcdFx0XHRSSUNIX0NPTUJPX0RFRlNbZWRpdG9yLm5hbWVdW1xuXHRcdFx0XHRcdFx0XHRyaWNoQ29tYm9OYW1lXG5cdFx0XHRcdFx0XHRdLmN1cnJlbnRWYWx1ZSA9IG5ld1ZhbHVlO1xuXG5cdFx0XHRcdFx0XHRlZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdF9zZXRWYWx1ZSh2YWx1ZSkge1xuXHRcdFx0XHRcdHRoaXMuX2NhY2hlVmFsdWUodmFsdWUpO1xuXG5cdFx0XHRcdFx0dGhpcy5zZXRTdGF0ZSh7XG5cdFx0XHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0QWxsb3lFZGl0b3IuQnV0dG9uc1tyaWNoQ29tYm9OYW1lXSA9IFJpY2hDb21ib0JyaWRnZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gUmljaENvbWJvQnJpZGdlO1xuXHR9O1xuXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cdGlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ3JpY2hjb21ibycpKSB7XG5cdFx0Q0tFRElUT1IuVUlfUklDSENPTUJPID0gJ3JpY2hjb21ibyc7XG5cblx0XHRDS0VESVRPUi5wbHVnaW5zLmFkZCgncmljaGNvbWJvJywge30pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENLRWRpdG9yIHBsdWdpbiB0aGF0IGJyaWRnZXMgdGhlIHN1cHBvcnQgb2ZmZXJlZCBieSBDS0VkaXRvciBSaWNoQ29tYm8gcGx1Z2luLiBJdCB0YWtlcyBvdmVyIHRoZVxuXHQgKiByZXNwb25zaWJpbGl0eSBvZiByZWdpc3RlcmluZyBhbmQgY3JlYXRpbmcgcmljaCBjb21ibyBlbGVtZW50cyB2aWE6XG5cdCAqIC0gZWRpdG9yLnVpLmFkZFJpY2hDb21ibyhuYW1lLCBkZWZpbml0aW9uKVxuXHQgKiAtIGVkaXRvci51aS5hZGQobmFtZSwgQ0tFRElUT1IuVUlfUklDSENPTUJPLCBkZWZpbml0aW9uKVxuXHQgKlxuXHQgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9yaWNoY29tYm9icmlkZ2Vcblx0ICogQHJlcXVpcmVzIENLRURJVE9SLnBsdWdpbnMuYWVfdWlicmlkZ2Vcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfcmljaGNvbWJvYnJpZGdlJywge1xuXHRcdHJlcXVpcmVzOiBbJ2FlX3VpYnJpZGdlJ10sXG5cblx0XHQvKipcblx0XHQgKiBTZXQgdGhlIGFkZCBoYW5kbGVyIGZvciBVSV9SSUNIQ09NQk8gdG8gb3VyIG93bi4gV2UgZG8gdGhpcyBpbiB0aGUgaW5pdCBwaGFzZSB0byBvdmVycmlkZVxuXHRcdCAqIHRoZSBvbmUgaW4gdGhlIG9yaWdpbmFsIHBsdWdpbiBpbiBjYXNlIGl0J3MgcHJlc2VudFxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBpbml0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgQ0tFZGl0b3IgaW5zdGFuY2UgYmVpbmcgaW5pdGlhbGl6ZWRcblx0XHQgKi9cblx0XHRiZWZvcmVJbml0KGVkaXRvcikge1xuXHRcdFx0ZWRpdG9yLnVpLmFkZFJpY2hDb21ibyA9IGZ1bmN0aW9uKFxuXHRcdFx0XHRyaWNoQ29tYm9OYW1lLFxuXHRcdFx0XHRyaWNoQ29tYm9EZWZpbml0aW9uXG5cdFx0XHQpIHtcblx0XHRcdFx0dGhpcy5hZGQoXG5cdFx0XHRcdFx0cmljaENvbWJvTmFtZSxcblx0XHRcdFx0XHRDS0VESVRPUi5VSV9SSUNIQ09NQk8sXG5cdFx0XHRcdFx0cmljaENvbWJvRGVmaW5pdGlvblxuXHRcdFx0XHQpO1xuXHRcdFx0fTtcblxuXHRcdFx0ZWRpdG9yLnVpLmFkZEhhbmRsZXIoQ0tFRElUT1IuVUlfUklDSENPTUJPLCB7XG5cdFx0XHRcdGFkZDogZ2VuZXJhdGVSaWNoQ29tYm9CcmlkZ2UsXG5cdFx0XHRcdGNyZWF0ZShyaWNoQ29tYm9EZWZpbml0aW9uKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmljaENvbWJvTmFtZSA9XG5cdFx0XHRcdFx0XHQncmljaENvbWJvQnJpZGdlJyArICgoTWF0aC5yYW5kb20oKSAqIDFlOSkgPj4+IDApO1xuXHRcdFx0XHRcdGNvbnN0IFJpY2hDb21ib0JyaWRnZSA9IGdlbmVyYXRlUmljaENvbWJvQnJpZGdlKFxuXHRcdFx0XHRcdFx0cmljaENvbWJvTmFtZSxcblx0XHRcdFx0XHRcdHJpY2hDb21ib0RlZmluaXRpb25cblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBSaWNoQ29tYm9CcmlkZ2UoKTtcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXHRcdH0sXG5cdH0pO1xufVxuIiwiLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV91aWJyaWRnZScpKSB7XG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gdGhhdCBleHRlbmRzIENLRURJVE9SLnVpLmFkZCBmdW5jdGlvbiBzbyBhbiBhZGQgaGFuZGxlciBjYW4gYmUgc3BlY2lmaWVkXG5cdCAqIG9uIHRvcCBvZiB0aGUgb3JpZ2luYWwgb25lcy4gSXQgYnJpZGdlcyB0aGUgY2FsbHMgdG8gYWRkIGNvbXBvbmVudHMgdmlhOlxuXHQgKiAtIGVkaXRvci51aS5hZGQobmFtZSwgdHlwZSwgZGVmaW5pdGlvbilcblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfdWlicmlkZ2Vcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfdWlicmlkZ2UnLCB7XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBiZWZvcmVJbml0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2Vcblx0XHQgKi9cblx0XHRiZWZvcmVJbml0KGVkaXRvcikge1xuXHRcdFx0Y29uc3Qgb3JpZ2luYWxVSUFkZEZuID0gZWRpdG9yLnVpLmFkZDtcblxuXHRcdFx0ZWRpdG9yLnVpLmFkZCA9IGZ1bmN0aW9uKG5hbWUsIHR5cGUsIGRlZmluaXRpb24pIHtcblx0XHRcdFx0b3JpZ2luYWxVSUFkZEZuLmNhbGwodGhpcywgbmFtZSwgdHlwZSwgZGVmaW5pdGlvbik7XG5cblx0XHRcdFx0Y29uc3QgdHlwZUhhbmRsZXIgPSB0aGlzLl8uaGFuZGxlcnNbdHlwZV07XG5cblx0XHRcdFx0aWYgKHR5cGVIYW5kbGVyICYmIHR5cGVIYW5kbGVyLmFkZCkge1xuXHRcdFx0XHRcdHR5cGVIYW5kbGVyLmFkZChuYW1lLCBkZWZpbml0aW9uLCBlZGl0b3IpO1xuXHRcdFx0XHRcdEFsbG95RWRpdG9yLnJlZ2lzdGVyQnJpZGdlQnV0dG9uKFxuXHRcdFx0XHRcdFx0bmFtZSxcblx0XHRcdFx0XHRcdGVkaXRvci5fX3Byb2Nlc3NpbmdQbHVnaW5fXy5wbHVnaW4ubmFtZVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIERlYm91bmNlIHV0aWwgZnVuY3Rpb24uIElmIGEgZnVuY3Rpb24gZXhlY3V0aW9uIGlzIGV4cGVuc2l2ZSwgaXQgbWlnaHQgYmUgZGVib3VuY2VkLiBUaGlzIG1lYW5zXG4gKiB0aGF0IGl0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgc29tZSBhbW91bnQgb2YgdGltZSBhZnRlciBpdHMgbGFzdCBjYWxsLiBGb3IgZXhhbXBsZSwgaWYgd2UgYXR0YWNoIGFcbiAqIGEgZnVuY3Rpb24gb24gc2Nyb2xsIGV2ZW50LCBpdCBtaWdodCBiZSBjYWxsZWQgaHVuZHJlZHMgdGltZXMgcGVyIHNlY29uZC4gSW4gdGhpcyBjYXNlIGl0IG1heSBiZVxuICogZGVib3VuY2VkIHdpdGgsIGxldCdzIHNheSAxMDBtcy4gVGhlIHJlYWwgZXhlY3V0aW9uIG9mIHRoaXMgZnVuY3Rpb24gd2lsbCBoYXBwZW4gMTAwbXMgYWZ0ZXIgbGFzdFxuICogc2Nyb2xsIGV2ZW50LlxuICpcbiAqIEBtZW1iZXJvZiBDS0VESVRPUi50b29sc1xuICogQG1ldGhvZCBkZWJvdW5jZVxuICogQHBhcmFtIHtBcnJheX0gYXJncyBBbiBhcnJheSBvZiBhcmd1bWVudHMgd2hpY2ggdGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB3aGljaCBoYXMgdG8gYmUgY2FsbGVkIGFmdGVyIGdpdmVuIHRpbWVvdXQuXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBUaGUgY29udGV4dCBpbiB3aGljaCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQuIFRoaXMgYXJndW1lbnQgaXMgb3B0aW9uYWwuXG4gKiBAc3RhdGljXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGNhbGxiYWNrLCB0aW1lb3V0LCBjb250ZXh0LCBhcmdzID0gW10pIHtcblx0bGV0IGRlYm91bmNlSGFuZGxlO1xuXG5cdGNvbnN0IGNhbGxGbiA9IGZ1bmN0aW9uKC4uLmNhbGxBcmdzKSB7XG5cdFx0LyogZXNsaW50LWRpc2FibGUgYmFiZWwvbm8taW52YWxpZC10aGlzICovXG5cdFx0Y29uc3QgY2FsbENvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG5cdFx0LyogZXNsaW50LWVuYWJsZSBiYWJlbC9uby1pbnZhbGlkLXRoaXMgKi9cblxuXHRcdGNsZWFyVGltZW91dChkZWJvdW5jZUhhbmRsZSk7XG5cblx0XHRkZWJvdW5jZUhhbmRsZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRjYWxsYmFjay5hcHBseShjYWxsQ29udGV4dCwgWy4uLmNhbGxBcmdzLCAuLi5hcmdzXSk7XG5cdFx0fSwgdGltZW91dCk7XG5cdH07XG5cblx0Y2FsbEZuLmRldGFjaCA9IGZ1bmN0aW9uKCkge1xuXHRcdGNsZWFyVGltZW91dChkZWJvdW5jZUhhbmRsZSk7XG5cdH07XG5cblx0cmV0dXJuIGNhbGxGbjtcbn1cblxuQ0tFRElUT1IudG9vbHMuZGVib3VuY2UgPSBDS0VESVRPUi50b29scy5kZWJvdW5jZSB8fCBkZWJvdW5jZTtcblxuZXhwb3J0IGRlZmF1bHQgZGVib3VuY2U7XG4iLCJpbXBvcnQgZGVib3VuY2UgZnJvbSAnLi9kZWJvdW5jZSc7XG5pbXBvcnQgJy4vbGluayc7XG5pbXBvcnQgJy4vcGx1Z2lucyc7XG5pbXBvcnQgJy4vc2VsZWN0aW9uLXJlZ2lvbic7XG5pbXBvcnQgJy4vdGFibGUnO1xuaW1wb3J0ICcuL3Rvb2xzJztcbmltcG9ydCAnLi91aWNvcmUnO1xuXG5leHBvcnQge2RlYm91bmNlfTtcbiIsImNvbnN0IFJFR0VYX0JPT0tNQVJLX1NDSEVNRSA9IC9eIy4qL2k7XG5jb25zdCBSRUdFWF9FTUFJTF9TQ0hFTUUgPSAvXlthLXowLTlcXHUwNDMwLVxcdTA0NEYuXy1dK0AvaTtcbmNvbnN0IFJFR0VYX1VSSV9TQ0hFTUUgPSAvXig/OlthLXpdW2EtejAtOStcXC0uXSopOnxeXFwvL2k7XG5cbi8qKlxuICogTGluayBjbGFzcyB1dGlsaXR5LiBQcm92aWRlcyBtZXRob2RzIGZvciBjcmVhdGUsIGRlbGV0ZSBhbmQgdXBkYXRlIGxpbmtzLlxuICpcbiAqIEBjbGFzcyBDS0VESVRPUi5MaW5rXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIENLRWRpdG9yIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBMaW5rKGVkaXRvciwgY29uZmlnKSB7XG5cdHRoaXMuX2VkaXRvciA9IGVkaXRvcjtcblx0dGhpcy5hcHBlbmRQcm90b2NvbCA9XG5cdFx0Y29uZmlnICYmIGNvbmZpZy5hcHBlbmRQcm90b2NvbCA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XG59XG5cbkxpbmsucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogTGluayxcblxuXHQvKipcblx0ICogQWR2YW5jZXMgdGhlIGVkaXRvciBzZWxlY3Rpb24gdG8gdGhlIG5leHQgYXZhaWxhYmxlIHBvc2l0aW9uIGFmdGVyIGFcblx0ICogZ2l2ZW4gbGluayBvciB0aGUgb25lIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5MaW5rXG5cdCAqIEBtZXRob2QgYWR2YW5jZVNlbGVjdGlvblxuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBsaW5rIFRoZSBsaW5rIGVsZW1lbnQgd2hpY2ggbGluayBzdHlsZSBzaG91bGQgYmUgcmVtb3ZlZC5cblx0ICovXG5cdGFkdmFuY2VTZWxlY3Rpb24obGluaykge1xuXHRcdGxpbmsgPSBsaW5rIHx8IHRoaXMuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG5cdFx0Y29uc3QgcmFuZ2UgPSB0aGlzLl9lZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cblx0XHRpZiAobGluaykge1xuXHRcdFx0cmFuZ2UubW92ZVRvRWxlbWVudEVkaXRFbmQobGluayk7XG5cblx0XHRcdGNvbnN0IG5leHROb2RlID0gcmFuZ2UuZ2V0TmV4dEVkaXRhYmxlTm9kZSgpO1xuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5leHROb2RlICYmXG5cdFx0XHRcdCF0aGlzLl9lZGl0b3IuZWxlbWVudC5lcXVhbHMobmV4dE5vZGUuZ2V0Q29tbW9uQW5jZXN0b3IobGluaykpXG5cdFx0XHQpIHtcblx0XHRcdFx0Y29uc3Qgd2hpdGVzcGFjZSA9IC9cXHMvLmV4ZWMobmV4dE5vZGUuZ2V0VGV4dCgpKTtcblxuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSB3aGl0ZXNwYWNlID8gd2hpdGVzcGFjZS5pbmRleCArIDEgOiAwO1xuXG5cdFx0XHRcdHJhbmdlLnNldFN0YXJ0KG5leHROb2RlLCBvZmZzZXQpO1xuXHRcdFx0XHRyYW5nZS5zZXRFbmQobmV4dE5vZGUsIG9mZnNldCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fZWRpdG9yLmdldFNlbGVjdGlvbigpLnNlbGVjdFJhbmdlcyhbcmFuZ2VdKTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgbGluayB3aXRoIGdpdmVuIFVSSSBhcyBocmVmLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLkxpbmtcblx0ICogQG1ldGhvZCBjcmVhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIEEgY29uZmlnIG9iamVjdCB3aXRoIGxpbmsgYXR0cmlidXRlcy4gVGhlc2UgbWlnaHQgYmUgYXJiaXRyYXJ5IERPTSBhdHRyaWJ1dGVzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gbW9kaWZ5U2VsZWN0aW9uIEEgY29uZmlnIG9iamVjdCB3aXRoIGFuIGFkdmFuY2UgYXR0cmlidXRlIHRvIGluZGljYXRlIGlmIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIG1vdmVkIGFmdGVyIHRoZSBsaW5rIGNyZWF0aW9uLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gVVJJIFRoZSBVUkkgb2YgdGhlIGxpbmsuXG5cdCAqL1xuXHRjcmVhdGUoVVJJLCBhdHRycywgbW9kaWZ5U2VsZWN0aW9uKSB7XG5cdFx0Y29uc3Qgc2VsZWN0aW9uID0gdGhpcy5fZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0Y29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VzKClbMF07XG5cblx0XHRpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG5cdFx0XHRjb25zdCB0ZXh0ID0gbmV3IENLRURJVE9SLmRvbS50ZXh0KFVSSSwgdGhpcy5fZWRpdG9yLmRvY3VtZW50KTtcblx0XHRcdHJhbmdlLmluc2VydE5vZGUodGV4dCk7XG5cdFx0XHRyYW5nZS5zZWxlY3ROb2RlQ29udGVudHModGV4dCk7XG5cdFx0fVxuXG5cdFx0VVJJID0gdGhpcy5fZ2V0Q29tcGxldGVVUkkoVVJJKTtcblxuXHRcdGNvbnN0IGxpbmtBdHRycyA9IENLRURJVE9SLnRvb2xzLm1lcmdlKFxuXHRcdFx0e1xuXHRcdFx0XHQnZGF0YS1ja2Utc2F2ZWQtaHJlZic6IFVSSSxcblx0XHRcdFx0aHJlZjogVVJJLFxuXHRcdFx0fSxcblx0XHRcdGF0dHJzXG5cdFx0KTtcblxuXHRcdGNvbnN0IHN0eWxlID0gbmV3IENLRURJVE9SLnN0eWxlKHtcblx0XHRcdGF0dHJpYnV0ZXM6IGxpbmtBdHRycyxcblx0XHRcdGVsZW1lbnQ6ICdhJyxcblx0XHR9KTtcblxuXHRcdHN0eWxlLnR5cGUgPSBDS0VESVRPUi5TVFlMRV9JTkxJTkU7XG5cdFx0c3R5bGUuYXBwbHlUb1JhbmdlKHJhbmdlLCB0aGlzLl9lZGl0b3IpO1xuXG5cdFx0aWYgKG1vZGlmeVNlbGVjdGlvbiAmJiBtb2RpZnlTZWxlY3Rpb24uYWR2YW5jZSkge1xuXHRcdFx0dGhpcy5hZHZhbmNlU2VsZWN0aW9uKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJhbmdlLnNlbGVjdCgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmV0cmlldmVzIGEgbGluayBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5MaW5rXG5cdCAqIEBtZXRob2QgZ2V0RnJvbVNlbGVjdGlvblxuXHQgKiBAcmV0dXJuIHtDS0VESVRPUi5kb20uZWxlbWVudH0gVGhlIHJldHJpZXZlZCBsaW5rIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuXHQgKi9cblx0Z2V0RnJvbVNlbGVjdGlvbigpIHtcblx0XHRjb25zdCBzZWxlY3Rpb24gPSB0aGlzLl9lZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRFbGVtZW50KCk7XG5cblx0XHRpZiAoc2VsZWN0ZWRFbGVtZW50ICYmIHNlbGVjdGVkRWxlbWVudC5pcygnYScpKSB7XG5cdFx0XHRyZXR1cm4gc2VsZWN0ZWRFbGVtZW50O1xuXHRcdH1cblxuXHRcdGlmIChzZWxlY3RlZEVsZW1lbnQgJiYgQ0tFRElUT1IuZW52LmllKSB7XG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IHNlbGVjdGVkRWxlbWVudC5nZXRDaGlsZHJlbigpO1xuXG5cdFx0XHRjb25zdCBjb3VudCA9IGNoaWxkcmVuLmNvdW50KCk7XG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0XHRjb25zdCBub2RlID0gY2hpbGRyZW4uZ2V0SXRlbShpKTtcblxuXHRcdFx0XHRpZiAobm9kZS5pcygnYScpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZXMoKVswXTtcblxuXHRcdGlmIChyYW5nZSkge1xuXHRcdFx0cmFuZ2Uuc2hyaW5rKENLRURJVE9SLlNIUklOS19URVhUKTtcblxuXHRcdFx0cmV0dXJuIHRoaXMuX2VkaXRvclxuXHRcdFx0XHQuZWxlbWVudFBhdGgocmFuZ2UuZ2V0Q29tbW9uQW5jZXN0b3IoKSlcblx0XHRcdFx0LmNvbnRhaW5zKCdhJywgMSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYSBsaW5rIGZyb20gdGhlIGVkaXRvci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5MaW5rXG5cdCAqIEBtZXRob2QgcmVtb3ZlXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGxpbmsgVGhlIGxpbmsgZWxlbWVudCB3aGljaCBsaW5rIHN0eWxlIHNob3VsZCBiZSByZW1vdmVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gbW9kaWZ5U2VsZWN0aW9uIEEgY29uZmlnIG9iamVjdCB3aXRoIGFuIGFkdmFuY2UgYXR0cmlidXRlIHRvIGluZGljYXRlIGlmIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIG1vdmVkIGFmdGVyIHRoZSBsaW5rIGNyZWF0aW9uLlxuXHQgKi9cblx0cmVtb3ZlKGxpbmssIG1vZGlmeVNlbGVjdGlvbikge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcblxuXHRcdGlmIChsaW5rKSB7XG5cdFx0XHRpZiAobW9kaWZ5U2VsZWN0aW9uICYmIG1vZGlmeVNlbGVjdGlvbi5hZHZhbmNlKSB7XG5cdFx0XHRcdHRoaXMuYWR2YW5jZVNlbGVjdGlvbigpO1xuXHRcdFx0fVxuXG5cdFx0XHRsaW5rLnJlbW92ZShlZGl0b3IpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBzdHlsZSA9IG5ldyBDS0VESVRPUi5zdHlsZSh7XG5cdFx0XHRcdGFsd2F5c1JlbW92ZUVsZW1lbnQ6IDEsXG5cdFx0XHRcdGVsZW1lbnQ6ICdhJyxcblx0XHRcdFx0dHlwZTogQ0tFRElUT1IuU1RZTEVfSU5MSU5FLFxuXHRcdFx0fSk7XG5cblx0XHRcdC8vICdyZW1vdmVTdHlsZSgpJyByZW1vdmVzIHRoZSBzdHlsZSBmcm9tIHRoZSBlZGl0b3IncyBjdXJyZW50IHNlbGVjdGlvbi5cblx0XHRcdC8vICBXZSBuZWVkIHRvIGZvcmNlIHRoZSBzZWxlY3Rpb24gdG8gYmUgdGhlIHdob2xlIGxpbmsgZWxlbWVudFxuXHRcdFx0Ly8gIHRvIHJlbW92ZSBpdCBwcm9wZXJseS5cblxuXHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0c2VsZWN0aW9uLnNlbGVjdEVsZW1lbnQoc2VsZWN0aW9uLmdldFN0YXJ0RWxlbWVudCgpKTtcblxuXHRcdFx0ZWRpdG9yLnJlbW92ZVN0eWxlKHN0eWxlKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIGhyZWYgb2YgYW4gYWxyZWFkeSBleGlzdGluZyBsaW5rLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLkxpbmtcblx0ICogQG1ldGhvZCB1cGRhdGVcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gbGluayBUaGUgbGluayBlbGVtZW50IHdoaWNoIGhyZWYgc2hvdWxkIGJlIHJlbW92ZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gYXR0cnMgVGhlIGF0dHJpYnV0ZXMgdG8gdXBkYXRlIG9yIHJlbW92ZS4gQXR0cmlidXRlcyB3aXRoIG51bGwgdmFsdWVzIHdpbGwgYmUgcmVtb3ZlZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG1vZGlmeVNlbGVjdGlvbiBBIGNvbmZpZyBvYmplY3Qgd2l0aCBhbiBhZHZhbmNlIGF0dHJpYnV0ZSB0byBpbmRpY2F0ZSBpZiB0aGUgc2VsZWN0aW9uIHNob3VsZCBiZSBtb3ZlZCBhZnRlciB0aGUgbGluayBjcmVhdGlvbi5cblx0ICovXG5cdHVwZGF0ZShhdHRycywgbGluaywgbW9kaWZ5U2VsZWN0aW9uKSB7XG5cdFx0Y29uc3QgaW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0bGluayA9IGxpbmsgfHwgdGhpcy5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cblx0XHRpZiAodHlwZW9mIGF0dHJzID09PSAnc3RyaW5nJykge1xuXHRcdFx0Y29uc3QgdXJpID0gaW5zdGFuY2UuX2dldENvbXBsZXRlVVJJKGF0dHJzKTtcblxuXHRcdFx0bGluay5zZXRBdHRyaWJ1dGVzKHtcblx0XHRcdFx0J2RhdGEtY2tlLXNhdmVkLWhyZWYnOiB1cmksXG5cdFx0XHRcdGhyZWY6IHVyaSxcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGF0dHJzID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Y29uc3QgcmVtb3ZlQXR0cnMgPSBbXTtcblxuXHRcdFx0Y29uc3Qgc2V0QXR0cnMgPSB7fTtcblxuXHRcdFx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdGlmIChhdHRyc1trZXldID09PSBudWxsKSB7XG5cdFx0XHRcdFx0aWYgKGtleSA9PT0gJ2hyZWYnKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVBdHRycy5wdXNoKCdkYXRhLWNrZS1zYXZlZC1ocmVmJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVtb3ZlQXR0cnMucHVzaChrZXkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmIChrZXkgPT09ICdocmVmJykge1xuXHRcdFx0XHRcdFx0Y29uc3QgdXJpID0gaW5zdGFuY2UuX2dldENvbXBsZXRlVVJJKGF0dHJzW2tleV0pO1xuXG5cdFx0XHRcdFx0XHRzZXRBdHRyc1snZGF0YS1ja2Utc2F2ZWQtaHJlZiddID0gdXJpO1xuXHRcdFx0XHRcdFx0c2V0QXR0cnNba2V5XSA9IHVyaTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2V0QXR0cnNba2V5XSA9IGF0dHJzW2tleV07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0bGluay5yZW1vdmVBdHRyaWJ1dGVzKHJlbW92ZUF0dHJzKTtcblx0XHRcdGxpbmsuc2V0QXR0cmlidXRlcyhzZXRBdHRycyk7XG5cdFx0fVxuXG5cdFx0aWYgKG1vZGlmeVNlbGVjdGlvbiAmJiBtb2RpZnlTZWxlY3Rpb24uYWR2YW5jZSkge1xuXHRcdFx0dGhpcy5hZHZhbmNlU2VsZWN0aW9uKGxpbmspO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIHRoZSBVUkkgYmVnaW5zIHdpdGggYSAnIycgc3ltYm9sIHRvIGRldGVybWluZSBpZiBpdCdzIGFuIG9uIHBhZ2UgYm9va21hcmsuXG5cdCAqIElmIGl0IGRvZXNuJ3QsIGl0IHRoZW4gY2hlY2tzIGlmIHRoZSBVUkkgaGFzIGFuICdAJyBzeW1ib2wuIElmIGl0IGRvZXMgYW5kIHRoZSBVUklcblx0ICogbG9va3MgbGlrZSBhbiBlbWFpbCBhbmQgZG9lc24ndCBoYXZlICdtYWlsdG86JywgJ21haWx0bzonIGlzIGFkZGVkIHRvIHRoZSBVUkkuXG5cdCAqIElmIGl0IGRvZXNuJ3QgYW5kIHRoZSBVUkkgZG9lc24ndCBoYXZlIGEgc2NoZW1lLCB0aGUgZGVmYXVsdCAnaHR0cCcgc2NoZW1lIHdpdGhcblx0ICogaGllcmFyY2hpY2FsIHBhdGggJy8vJyBpcyBhZGRlZCB0byB0aGUgVVJJLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLkxpbmtcblx0ICogQG1ldGhvZCBfZ2V0Q29tcGxldGVVUklcblx0ICogQHBhcmFtIHtTdHJpbmd9IFVSSSBUaGUgVVJJIG9mIHRoZSBsaW5rLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGhlIFVSSSB1cGRhdGVkIHdpdGggdGhlIHByb3RvY29sLlxuXHQgKi9cblx0X2dldENvbXBsZXRlVVJJKFVSSSkge1xuXHRcdGlmIChSRUdFWF9CT09LTUFSS19TQ0hFTUUudGVzdChVUkkpKSB7XG5cdFx0XHRyZXR1cm4gVVJJO1xuXHRcdH0gZWxzZSBpZiAoUkVHRVhfRU1BSUxfU0NIRU1FLnRlc3QoVVJJKSkge1xuXHRcdFx0VVJJID0gJ21haWx0bzonICsgVVJJO1xuXHRcdH0gZWxzZSBpZiAoIVJFR0VYX1VSSV9TQ0hFTUUudGVzdChVUkkpKSB7XG5cdFx0XHRVUkkgPSB0aGlzLmFwcGVuZFByb3RvY29sID8gJ2h0dHA6Ly8nICsgVVJJIDogVVJJO1xuXHRcdH1cblxuXHRcdHJldHVybiBVUkk7XG5cdH0sXG59O1xuXG5DS0VESVRPUi5MaW5rID0gQ0tFRElUT1IuTGluayB8fCBMaW5rO1xuIiwiLy8gV3JhcHMgZWFjaCBvZiB0aGUgcGx1Z2luIGxpZmVjeWNsZSBtZXRob2RzIGluIGEgY2xvc3VyZSB0aGF0IHdpbGxcbi8vIHNldCB1cCB0aGUgZWRpdG9yLl9fcHJvY2Vzc2luZ1BsdWdpbl9fIHZhcmlhYmxlIHNvIGl0IGNhbiBiZSBnbG9iYWxseVxuLy8gYWNjZXNzZWQgZXhwb3NpbmcgdGhlIHBsdWdpbiBiZWluZyBwcm9jZXNzZWQgYW5kIHRoZSBsaWZlY3ljbGUgcGhhc2Vcbi8vIGluIHdoaWNoIGl0IGlzIGhhcHBlbmluZ1xuLy9cbi8vIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gVGhlIHBsdWdpbiB0byB3cmFwIGxpZmVjeWNsZSBtZXRob2RzXG5jb25zdCB3cmFwUGx1Z2luTGlmZWN5Y2xlID0gZnVuY3Rpb24ocGx1Z2luKSB7XG5cdGNvbnN0IG1ldGhvZHMgPSBbJ2JlZm9yZUluaXQnLCAnaW5pdCcsICdhZnRlckluaXQnXTtcblxuXHRtZXRob2RzLmZvckVhY2goZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuXHRcdGlmIChwbHVnaW5bbWV0aG9kTmFtZV0pIHtcblx0XHRcdHBsdWdpblttZXRob2ROYW1lXSA9IENLRURJVE9SLnRvb2xzLm92ZXJyaWRlKFxuXHRcdFx0XHRwbHVnaW5bbWV0aG9kTmFtZV0sXG5cdFx0XHRcdGZ1bmN0aW9uKG9yaWdpbmFsUGx1Z2luTWV0aG9kKSB7XG5cdFx0XHRcdFx0Y29uc3QgcGF5bG9hZCA9IHtcblx0XHRcdFx0XHRcdHBoYXNlOiBtZXRob2ROYW1lLFxuXHRcdFx0XHRcdFx0cGx1Z2luLFxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRlZGl0b3IuX19wcm9jZXNzaW5nUGx1Z2luX18gPSBwYXlsb2FkO1xuXG5cdFx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFiZWwvbm8taW52YWxpZC10aGlzXG5cdFx0XHRcdFx0XHRvcmlnaW5hbFBsdWdpbk1ldGhvZC5jYWxsKHRoaXMsIGVkaXRvcik7XG5cblx0XHRcdFx0XHRcdGVkaXRvci5fX3Byb2Nlc3NpbmdQbHVnaW5fXyA9IG51bGw7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdH0pO1xufTtcblxuLy8gRmlsdGVycyB0aGUgcmVxdWlyZXMgb2JqZWN0IHRvIHJlbW92ZSB1bndhbnRlZCBkZXBlbmRlbmNpZXMuIEF0IHRoaXMgcG9pbnRcbi8vIG9ubHkgJ3Rvb2xiYXInIGhhcyBiZWVuIGlkZW50aWZpZWQsIGJ1dCBtb3JlIGNhbiBhcHBlYXIuIEFuIHVud2FudGVkIHBsdWdpblxuLy8gZGVwZW5kZW5jeSBpcyBvbmUgdGhhdCBwcmV2ZW50cyBhIG5lY2Vzc2FyeSBwbHVnaW4gZnJvbSBiZWluZyByZW1vdmVkXG4vL1xuLy8gQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gcmVxdWlyZXMgVGhlIHJlcXVpcmVzIG9iamVjdFxuLy8gQHJldHVybiB7c3RyaW5nfSBUaGUgZmlsdGVyZWQgcmVxdWlyZXMgb2JqZWN0XG5jb25zdCBmaWx0ZXJVbndhbnRlZERlcGVuZGVuY2llcyA9IGZ1bmN0aW9uKHJlcXVpcmVzKSB7XG5cdGlmICh0eXBlb2YgcmVxdWlyZXMgPT09ICdzdHJpbmcnKSB7XG5cdFx0cmVxdWlyZXMgPSByZXF1aXJlcy5zcGxpdCgnLCcpO1xuXHR9XG5cblx0cmV0dXJuIHJlcXVpcmVzLmZpbHRlcihmdW5jdGlvbihyZXF1aXJlKSB7XG5cdFx0cmV0dXJuIHJlcXVpcmUgIT09ICd0b29sYmFyJztcblx0fSk7XG59O1xuXG4vKipcbiAqIENLRURJVE9SLnBsdWdpbnMgY2xhc3MgdXRpbGl0eSB3aGljaCBhZGRzIGFkZGl0aW9uYWwgbWV0aG9kcyB0byB0aG9zZSBvZiBDS0VkaXRvci5cbiAqXG4gKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2luc1xuICovXG5cbi8qKlxuICogT3ZlcnJpZGVzIENLRURJVE9SLnBsdWdpbnMubG9hZCBtZXRob2Qgc28gd2UgY2FuIGV4dGVuZCB0aGUgbGlmZWN5Y2xlIG1ldGhvZHMgb2ZcbiAqIHRoZSBsb2FkZWQgcGx1Z2lucyB0byBhZGQgc29tZSBtZXRhaW5mb3JtYXRpb24gYWJvdXQgdGhlIHBsdWdpbiBiZWluZyBwcm9jZXNzZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZy9BcnJheX0gbmFtZXMgVGhlIG5hbWUgb2YgdGhlIHJlc291cmNlIHRvIGxvYWQuIEl0IG1heSBiZSBhXG4gKiBzdHJpbmcgd2l0aCBhIHNpbmdsZSByZXNvdXJjZSBuYW1lLCBvciBhbiBhcnJheSB3aXRoIHNldmVyYWwgbmFtZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIGFsbCByZXNvdXJjZXNcbiAqIGFyZSBsb2FkZWQuIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgbG9hZGVkIG5hbWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzY29wZV0gVGhlIHNjb3BlIG9iamVjdCB0byBiZSB1c2VkIGZvciB0aGUgY2FsbGJhY2sgY2FsbC5cbiAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zXG4gKiBAbWV0aG9kIGxvYWRcbiAqIEBzdGF0aWNcbiAqL1xuQ0tFRElUT1IucGx1Z2lucy5sb2FkID0gQ0tFRElUT1IudG9vbHMub3ZlcnJpZGUoQ0tFRElUT1IucGx1Z2lucy5sb2FkLCBmdW5jdGlvbihcblx0cGx1Z2luc0xvYWRcbikge1xuXHQvLyBXcmFwIG9yaWdpbmFsIGxvYWQgZnVuY3Rpb24gc28gd2UgY2FuIHRyYW5zZm9ybSB0aGUgcGx1Z2luIGlucHV0IHBhcmFtZXRlclxuXHQvLyBiZWZvcmUgcGFzc2luZyBpdCBkb3duIHRvIHRoZSBvcmlnaW5hbCBjYWxsYmFja1xuXHRyZXR1cm4gZnVuY3Rpb24obmFtZXMsIGNhbGxiYWNrLCBzY29wZSkge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBiYWJlbC9uby1pbnZhbGlkLXRoaXNcblx0XHRwbHVnaW5zTG9hZC5jYWxsKHRoaXMsIG5hbWVzLCBmdW5jdGlvbihwbHVnaW5zKSB7XG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0T2JqZWN0LmtleXMocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbihwbHVnaW5OYW1lKSB7XG5cdFx0XHRcdFx0Y29uc3QgcGx1Z2luID0gcGx1Z2luc1twbHVnaW5OYW1lXTtcblxuXHRcdFx0XHRcdGlmIChwbHVnaW4ucmVxdWlyZXMpIHtcblx0XHRcdFx0XHRcdHBsdWdpbi5yZXF1aXJlcyA9IGZpbHRlclVud2FudGVkRGVwZW5kZW5jaWVzKFxuXHRcdFx0XHRcdFx0XHRwbHVnaW4ucmVxdWlyZXNcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0d3JhcFBsdWdpbkxpZmVjeWNsZShwbHVnaW4pO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKHNjb3BlLCBwbHVnaW5zKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcbn0pO1xuIiwiaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfc2VsZWN0aW9ucmVnaW9uJykpIHtcblx0Q0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT00gPSAwO1xuXHRDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUCA9IDE7XG5cdENLRURJVE9SLlNFTEVDVElPTl9MRUZUX1RPX1JJR0hUID0gMjtcblx0Q0tFRElUT1IuU0VMRUNUSU9OX1JJR0hUX1RPX0xFRlQgPSAzO1xuXG5cdC8qKlxuXHQgKiBTZWxlY3Rpb25SZWdpb24gdXRpbGl0eSBjbGFzcyB3aGljaCBwcm92aWRlcyBtZXRhZGF0YSBhYm91dCB0aGUgc2VsZWN0aW9uLiBUaGUgbWV0YWRhdGEgbWF5IGJlIHRoZSBzdGFydCBhbmQgZW5kXG5cdCAqIHJlY3RhbmdsZXMsIGNhcmV0IHJlZ2lvbiwgZXRjLiAqKlRoaXMgY2xhc3MgaXMgbm90IGludGVuZGVkIHRvIGJlIHVzZWQgc3RhbmRhbG9uZS4gSXRzIGZ1bmN0aW9ucyB3aWxsXG5cdCAqIGJlIG1lcmdlZCBpbnRvIGVhY2ggZWRpdG9yIGluc3RhbmNlLCBzbyB0aGUgZGV2ZWxvcGVyIG1heSB1c2UgdGhlbSBkaXJlY3RseSB2aWEgdGhlIGVkaXRvciwgd2l0aG91dCBtYWtpbmdcblx0ICogYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyoqLlxuXHQgKlxuXHQgKiBAY2xhc3MgU2VsZWN0aW9uUmVnaW9uXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0ZnVuY3Rpb24gU2VsZWN0aW9uUmVnaW9uKCkge31cblxuXHRTZWxlY3Rpb25SZWdpb24ucHJvdG90eXBlID0ge1xuXHRcdGNvbnN0cnVjdG9yOiBTZWxlY3Rpb25SZWdpb24sXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIHNlbGVjdGlvbiBmcm9tIHR3byBwb2ludHMgaW4gcGFnZSBjb29yZGluYXRlcy5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cblx0XHQgKiBAbWV0aG9kIGNyZWF0ZVNlbGVjdGlvbkZyb21Qb2ludFxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4IFggcG9pbnQgaW4gcGFnZSBjb29yZGluYXRlcy5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0geSBZIHBvaW50IGluIHBhZ2UgY29vcmRpbmF0ZXMuXG5cdFx0ICovXG5cdFx0Y3JlYXRlU2VsZWN0aW9uRnJvbVBvaW50KHgsIHkpIHtcblx0XHRcdHRoaXMuY3JlYXRlU2VsZWN0aW9uRnJvbVJhbmdlKHgsIHksIHgsIHkpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIHNlbGVjdGlvbiBmcm9tIHJhbmdlLiBBIHJhbmdlIGNvbnNpc3RzIGZyb20gdHdvIHBvaW50cyBpbiBwYWdlIGNvb3JkaW5hdGVzLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFNlbGVjdGlvblJlZ2lvblxuXHRcdCAqIEBtZXRob2QgY3JlYXRlU2VsZWN0aW9uRnJvbVJhbmdlXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0WCBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50LlxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFkgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBwb2ludC5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gZW5kWCBYIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC5cblx0XHQgKiBAcGFyYW0ge051bWJlcn0gZW5kWSBZIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBwb2ludC5cblx0XHQgKi9cblx0XHRjcmVhdGVTZWxlY3Rpb25Gcm9tUmFuZ2Uoc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFkpIHtcblx0XHRcdGxldCBlbmQ7XG5cdFx0XHRsZXQgZW5kQ29udGFpbmVyO1xuXHRcdFx0bGV0IGVuZE9mZnNldDtcblx0XHRcdGxldCByYW5nZTtcblx0XHRcdGxldCBzdGFydDtcblx0XHRcdGxldCBzdGFydENvbnRhaW5lcjtcblx0XHRcdGxldCBzdGFydE9mZnNldDtcblxuXHRcdFx0aWYgKHR5cGVvZiBkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHN0YXJ0ID0gZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludChzdGFydFgsIHN0YXJ0WSk7XG5cdFx0XHRcdGVuZCA9IGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoZW5kWCwgZW5kWSk7XG5cblx0XHRcdFx0c3RhcnRDb250YWluZXIgPSBzdGFydC5vZmZzZXROb2RlO1xuXHRcdFx0XHRlbmRDb250YWluZXIgPSBlbmQub2Zmc2V0Tm9kZTtcblxuXHRcdFx0XHRzdGFydE9mZnNldCA9IHN0YXJ0Lm9mZnNldDtcblx0XHRcdFx0ZW5kT2Zmc2V0ID0gZW5kLm9mZnNldDtcblxuXHRcdFx0XHRyYW5nZSA9IHRoaXMuY3JlYXRlUmFuZ2UoKTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50LmNhcmV0UmFuZ2VGcm9tUG9pbnQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0c3RhcnQgPSBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50KHN0YXJ0WCwgc3RhcnRZKTtcblx0XHRcdFx0ZW5kID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludChlbmRYLCBlbmRZKTtcblxuXHRcdFx0XHRzdGFydENvbnRhaW5lciA9IHN0YXJ0LnN0YXJ0Q29udGFpbmVyO1xuXHRcdFx0XHRlbmRDb250YWluZXIgPSBlbmQuc3RhcnRDb250YWluZXI7XG5cblx0XHRcdFx0c3RhcnRPZmZzZXQgPSBzdGFydC5zdGFydE9mZnNldDtcblx0XHRcdFx0ZW5kT2Zmc2V0ID0gZW5kLnN0YXJ0T2Zmc2V0O1xuXG5cdFx0XHRcdHJhbmdlID0gdGhpcy5jcmVhdGVSYW5nZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmFuZ2UgJiYgZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKSB7XG5cdFx0XHRcdHJhbmdlLnNldFN0YXJ0KFxuXHRcdFx0XHRcdG5ldyBDS0VESVRPUi5kb20ubm9kZShzdGFydENvbnRhaW5lciksXG5cdFx0XHRcdFx0c3RhcnRPZmZzZXRcblx0XHRcdFx0KTtcblx0XHRcdFx0cmFuZ2Uuc2V0RW5kKG5ldyBDS0VESVRPUi5kb20ubm9kZShlbmRDb250YWluZXIpLCBlbmRPZmZzZXQpO1xuXG5cdFx0XHRcdHRoaXMuZ2V0U2VsZWN0aW9uKCkuc2VsZWN0UmFuZ2VzKFtyYW5nZV0pO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5jcmVhdGVUZXh0UmFuZ2UgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdFx0XHRzZWxlY3Rpb24udW5sb2NrKCk7XG5cblx0XHRcdFx0cmFuZ2UgPSBkb2N1bWVudC5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuXHRcdFx0XHRyYW5nZS5tb3ZlVG9Qb2ludChzdGFydFgsIHN0YXJ0WSk7XG5cblx0XHRcdFx0Y29uc3QgZW5kUmFuZ2UgPSByYW5nZS5kdXBsaWNhdGUoKTtcblx0XHRcdFx0ZW5kUmFuZ2UubW92ZVRvUG9pbnQoZW5kWCwgZW5kWSk7XG5cblx0XHRcdFx0cmFuZ2Uuc2V0RW5kUG9pbnQoJ0VuZFRvRW5kJywgZW5kUmFuZ2UpO1xuXHRcdFx0XHRyYW5nZS5zZWxlY3QoKTtcblxuXHRcdFx0XHR0aGlzLmdldFNlbGVjdGlvbigpLmxvY2soKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgcmVnaW9uIG9mIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBjYXJldC4gVGhlIHBvaW50cyBhcmUgaW4gcGFnZSBjb29yZGluYXRlcy5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cblx0XHQgKiBAbWV0aG9kIGdldENhcmV0UmVnaW9uXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0XHQgKiAtIGJvdHRvbVxuXHRcdCAqIC0gbGVmdFxuXHRcdCAqIC0gcmlnaHRcblx0XHQgKiAtIHRvcFxuXHRcdCAqL1xuXHRcdGdldENhcmV0UmVnaW9uKCkge1xuXHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdFx0bGV0IHJlZ2lvbiA9IHtcblx0XHRcdFx0Ym90dG9tOiAwLFxuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgYm9va21hcmtzID0gc2VsZWN0aW9uLmNyZWF0ZUJvb2ttYXJrcygpO1xuXG5cdFx0XHRpZiAoIWJvb2ttYXJrcy5sZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIHJlZ2lvbjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgYm9va21hcmtOb2RlRWwgPSBib29rbWFya3NbMF0uc3RhcnROb2RlLiQ7XG5cblx0XHRcdGJvb2ttYXJrTm9kZUVsLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcblxuXHRcdFx0cmVnaW9uID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGJvb2ttYXJrTm9kZUVsKS5nZXRDbGllbnRSZWN0KCk7XG5cblx0XHRcdGJvb2ttYXJrTm9kZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYm9va21hcmtOb2RlRWwpO1xuXG5cdFx0XHRjb25zdCBzY3JvbGxQb3MgPSBuZXcgQ0tFRElUT1IuZG9tLndpbmRvdyhcblx0XHRcdFx0d2luZG93XG5cdFx0XHQpLmdldFNjcm9sbFBvc2l0aW9uKCk7XG5cblx0XHRcdHJlZ2lvbi5ib3R0b20gPSBzY3JvbGxQb3MueSArIHJlZ2lvbi5ib3R0b207XG5cdFx0XHRyZWdpb24ubGVmdCA9IHNjcm9sbFBvcy54ICsgcmVnaW9uLmxlZnQ7XG5cdFx0XHRyZWdpb24ucmlnaHQgPSBzY3JvbGxQb3MueCArIHJlZ2lvbi5yaWdodDtcblx0XHRcdHJlZ2lvbi50b3AgPSBzY3JvbGxQb3MueSArIHJlZ2lvbi50b3A7XG5cblx0XHRcdHJldHVybiByZWdpb247XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgZGF0YSBmb3IgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIFNlbGVjdGlvblJlZ2lvblxuXHRcdCAqIEBtZXRob2QgZ2V0U2VsZWN0aW9uRGF0YVxuXHRcdCAqIEByZXR1cm4ge09iamVjdHxudWxsfSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgZGF0YTpcblx0XHQgKiAtIGVsZW1lbnQgLSBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGVsZW1lbnQsIGlmIGFueVxuXHRcdCAqIC0gdGV4dCAtIFRoZSBzZWxlY3RlZCB0ZXh0XG5cdFx0ICogLSByZWdpb24gLSBUaGUgZGF0YSwgcmV0dXJuZWQgZnJvbSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRTZWxlY3Rpb25SZWdpb246bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319XG5cdFx0ICovXG5cdFx0Z2V0U2VsZWN0aW9uRGF0YSgpIHtcblx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRcdGlmICghc2VsZWN0aW9uLmdldE5hdGl2ZSgpKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCByZXN1bHQgPSB7XG5cdFx0XHRcdGVsZW1lbnQ6IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKSxcblx0XHRcdFx0dGV4dDogc2VsZWN0aW9uLmdldFNlbGVjdGVkVGV4dCgpLFxuXHRcdFx0fTtcblxuXHRcdFx0cmVzdWx0LnJlZ2lvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uUmVnaW9uKHNlbGVjdGlvbik7XG5cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdGhlIHJlZ2lvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG5cdFx0ICogQG1ldGhvZCBnZXRTZWxlY3Rpb25SZWdpb25cblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgb2JqZWN0IHdoaWNoIGlzIGJlaW5nIHJldHVybmVkIGZyb21cblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3NlbGVjdGlvbnJlZ2lvbi9nZXRDbGllbnRSZWN0c1JlZ2lvbjptZXRob2RcIn19e3svY3Jvc3NMaW5rfX0gd2l0aCB0aHJlZSBtb3JlIHByb3BlcnRpZXM6XG5cdFx0ICogLSBkaXJlY3Rpb24gLSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzZWxlY3Rpb24uIENhbiBiZSBvbmUgb2YgdGhlc2U6XG5cdFx0ICogICAxLiBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTVxuXHRcdCAqICAgMi4gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1Bcblx0XHQgKiAtIGhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHNlbGVjdGlvbiByZWdpb25cblx0XHQgKiAtIHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSBzZWxlY3Rpb24gcmVnaW9uXG5cdFx0ICovXG5cdFx0Z2V0U2VsZWN0aW9uUmVnaW9uKCkge1xuXHRcdFx0Y29uc3QgcmVnaW9uID0gdGhpcy5nZXRDbGllbnRSZWN0c1JlZ2lvbigpO1xuXG5cdFx0XHRyZWdpb24uZGlyZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb25EaXJlY3Rpb24oKTtcblxuXHRcdFx0cmVnaW9uLmhlaWdodCA9IHJlZ2lvbi5ib3R0b20gLSByZWdpb24udG9wO1xuXHRcdFx0cmVnaW9uLndpZHRoID0gcmVnaW9uLnJpZ2h0IC0gcmVnaW9uLmxlZnQ7XG5cblx0XHRcdHJldHVybiByZWdpb247XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgZW1wdHksIGZhbHNlIG90aGVyd2lzZS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cblx0XHQgKiBAbWV0aG9kIGlzU2VsZWN0aW9uRW1wdHlcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGVtcHR5LCBmYWxzZSBvdGhlcndpc2UuXG5cdFx0ICovXG5cdFx0aXNTZWxlY3Rpb25FbXB0eSgpIHtcblx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRcdGlmIChzZWxlY3Rpb24uZ2V0VHlwZSgpID09PSBDS0VESVRPUi5TRUxFQ1RJT05fTk9ORSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcmFuZ2VzID0gc2VsZWN0aW9uLmdldFJhbmdlcygpO1xuXHRcdFx0cmV0dXJuIHJhbmdlcyAmJiByYW5nZXMubGVuZ3RoID09PSAxICYmIHJhbmdlc1swXS5jb2xsYXBzZWQ7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgb2JqZWN0IHdpdGggZGF0YSBhYm91dCB0aGUgW2NsaWVudCByZWN0YW5nbGVzXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC5nZXRDbGllbnRSZWN0cykgb2YgdGhlIHNlbGVjdGlvbixcblx0XHQgKiBub3JtYWxpemVkIGFjcm9zcyBicm93c2VzLiBBbGwgb2Zmc2V0cyBiZWxvdyBhcmUgaW4gcGFnZSBjb29yZGluYXRlcy5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBTZWxlY3Rpb25SZWdpb25cblx0XHQgKiBAbWV0aG9kIGdldENsaWVudFJlY3RzUmVnaW9uXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgZGF0YTpcblx0XHQgKiAtIGJvdHRvbSAtIGJvdHRvbSBvZmZzZXQgb2YgYWxsIGNsaWVudCByZWN0YW5nbGVzXG5cdFx0ICogLSBsZWZ0IC0gbGVmdCBvZmZzZXQgb2YgYWxsIGNsaWVudCByZWN0YW5nbGVzXG5cdFx0ICogLSByaWdodCAtIHJpZ2h0IG9mZnNldCBvZiBhbGwgY2xpZW50IHJlY3RhbmdsZXNcblx0XHQgKiAtIHRvcCAtIHRvcCBvZmZzZXQgb2YgYWxsIGNsaWVudCByZWN0YW5nbGVzXG5cdFx0ICogLSBzdGFydFJlY3QgLSBBbiBPYmplY3QsIHdoaWNoIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb246XG5cdFx0ICogICAgICsgYm90dG9tIC0gYm90dG9tIG9mZnNldFxuXHRcdCAqICAgICArIGhlaWdodCAtIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuXHRcdCAqICAgICArIGxlZnQgLSBsZWZ0IG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uXG5cdFx0ICogICAgICsgcmlnaHQgLSByaWdodCBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvblxuXHRcdCAqICAgICArIHRvcCAtIHRvcCBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvblxuXHRcdCAqICAgICArIHdpZHRoIC0gdGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcblx0XHQgKiAtIGVuZFJlY3QgLSBBbiBPYmplY3QsIHdoaWNoIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgaW5mb3JtYXRpb246XG5cdFx0ICogICAgICsgYm90dG9tIC0gYm90dG9tIG9mZnNldFxuXHRcdCAqICAgICArIGhlaWdodCAtIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuXHRcdCAqICAgICArIGxlZnQgLSBsZWZ0IG9mZnNldCBvZiB0aGUgc2VsZWN0aW9uXG5cdFx0ICogICAgICsgcmlnaHQgLSByaWdodCBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvblxuXHRcdCAqICAgICArIHRvcCAtIHRvcCBvZmZzZXQgb2YgdGhlIHNlbGVjdGlvblxuXHRcdCAqICAgICArIHdpZHRoIC0gdGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcblx0XHQgKlxuXHRcdCAqIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBzZWxlY3Rpb24sIHRoZSBvYmplY3RzIHdpbGwgYmUgZmlsbGVkIHdpdGggMC5cblx0XHQgKi9cblx0XHRnZXRDbGllbnRSZWN0c1JlZ2lvbigpIHtcblx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRjb25zdCBuYXRpdmVTZWxlY3Rpb24gPSBzZWxlY3Rpb24uZ2V0TmF0aXZlKCk7XG5cblx0XHRcdGNvbnN0IGRlZmF1bHRSZWN0ID0ge1xuXHRcdFx0XHRib3R0b206IDAsXG5cdFx0XHRcdGhlaWdodDogMCxcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0cmlnaHQ6IDAsXG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0d2lkdGg6IDAsXG5cdFx0XHR9O1xuXG5cdFx0XHRsZXQgcmVnaW9uID0ge1xuXHRcdFx0XHRib3R0b206IDAsXG5cdFx0XHRcdGVuZFJlY3Q6IGRlZmF1bHRSZWN0LFxuXHRcdFx0XHRsZWZ0OiAwLFxuXHRcdFx0XHRyaWdodDogMCxcblx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRzdGFydFJlY3Q6IGRlZmF1bHRSZWN0LFxuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCFuYXRpdmVTZWxlY3Rpb24pIHtcblx0XHRcdFx0cmV0dXJuIHJlZ2lvbjtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGJvdHRvbSA9IDA7XG5cdFx0XHRsZXQgY2xpZW50UmVjdHM7XG5cdFx0XHRsZXQgbGVmdCA9IEluZmluaXR5O1xuXHRcdFx0bGV0IHJpZ2h0ID0gLUluZmluaXR5O1xuXHRcdFx0bGV0IHRvcCA9IEluZmluaXR5O1xuXG5cdFx0XHRpZiAobmF0aXZlU2VsZWN0aW9uLmNyZWF0ZVJhbmdlKSB7XG5cdFx0XHRcdGNsaWVudFJlY3RzID0gbmF0aXZlU2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZ2V0Q2xpZW50UmVjdHMoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsaWVudFJlY3RzID1cblx0XHRcdFx0XHRuYXRpdmVTZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDBcblx0XHRcdFx0XHRcdD8gbmF0aXZlU2VsZWN0aW9uLmdldFJhbmdlQXQoMCkuZ2V0Q2xpZW50UmVjdHMoKVxuXHRcdFx0XHRcdFx0OiBbXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNsaWVudFJlY3RzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRyZWdpb24gPSB0aGlzLmdldENhcmV0UmVnaW9uKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gY2xpZW50UmVjdHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBpdGVtID0gY2xpZW50UmVjdHNbaV07XG5cblx0XHRcdFx0XHRpZiAoaXRlbS5sZWZ0IDwgbGVmdCkge1xuXHRcdFx0XHRcdFx0bGVmdCA9IGl0ZW0ubGVmdDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaXRlbS5yaWdodCA+IHJpZ2h0KSB7XG5cdFx0XHRcdFx0XHRyaWdodCA9IGl0ZW0ucmlnaHQ7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGl0ZW0udG9wIDwgdG9wKSB7XG5cdFx0XHRcdFx0XHR0b3AgPSBpdGVtLnRvcDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaXRlbS5ib3R0b20gPiBib3R0b20pIHtcblx0XHRcdFx0XHRcdGJvdHRvbSA9IGl0ZW0uYm90dG9tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHNjcm9sbFBvcyA9IG5ldyBDS0VESVRPUi5kb20ud2luZG93KFxuXHRcdFx0XHRcdHdpbmRvd1xuXHRcdFx0XHQpLmdldFNjcm9sbFBvc2l0aW9uKCk7XG5cblx0XHRcdFx0cmVnaW9uLmJvdHRvbSA9IHNjcm9sbFBvcy55ICsgYm90dG9tO1xuXHRcdFx0XHRyZWdpb24ubGVmdCA9IHNjcm9sbFBvcy54ICsgbGVmdDtcblx0XHRcdFx0cmVnaW9uLnJpZ2h0ID0gc2Nyb2xsUG9zLnggKyByaWdodDtcblx0XHRcdFx0cmVnaW9uLnRvcCA9IHNjcm9sbFBvcy55ICsgdG9wO1xuXG5cdFx0XHRcdGlmIChjbGllbnRSZWN0cy5sZW5ndGgpIHtcblx0XHRcdFx0XHRjb25zdCBlbmRSZWN0ID0gY2xpZW50UmVjdHNbY2xpZW50UmVjdHMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnRSZWN0ID0gY2xpZW50UmVjdHNbMF07XG5cblx0XHRcdFx0XHRyZWdpb24uZW5kUmVjdCA9IHtcblx0XHRcdFx0XHRcdGJvdHRvbTogc2Nyb2xsUG9zLnkgKyBlbmRSZWN0LmJvdHRvbSxcblx0XHRcdFx0XHRcdGhlaWdodDogZW5kUmVjdC5oZWlnaHQsXG5cdFx0XHRcdFx0XHRsZWZ0OiBzY3JvbGxQb3MueCArIGVuZFJlY3QubGVmdCxcblx0XHRcdFx0XHRcdHJpZ2h0OiBzY3JvbGxQb3MueCArIGVuZFJlY3QucmlnaHQsXG5cdFx0XHRcdFx0XHR0b3A6IHNjcm9sbFBvcy55ICsgZW5kUmVjdC50b3AsXG5cdFx0XHRcdFx0XHR3aWR0aDogZW5kUmVjdC53aWR0aCxcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0cmVnaW9uLnN0YXJ0UmVjdCA9IHtcblx0XHRcdFx0XHRcdGJvdHRvbTogc2Nyb2xsUG9zLnkgKyBzdGFydFJlY3QuYm90dG9tLFxuXHRcdFx0XHRcdFx0aGVpZ2h0OiBzdGFydFJlY3QuaGVpZ2h0LFxuXHRcdFx0XHRcdFx0bGVmdDogc2Nyb2xsUG9zLnggKyBzdGFydFJlY3QubGVmdCxcblx0XHRcdFx0XHRcdHJpZ2h0OiBzY3JvbGxQb3MueCArIHN0YXJ0UmVjdC5yaWdodCxcblx0XHRcdFx0XHRcdHRvcDogc2Nyb2xsUG9zLnkgKyBzdGFydFJlY3QudG9wLFxuXHRcdFx0XHRcdFx0d2lkdGg6IHN0YXJ0UmVjdC53aWR0aCxcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiByZWdpb247XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHJpZXZlcyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzZWxlY3Rpb24uIFRoZSBkaXJlY3Rpb24gaXMgZnJvbSB0b3AgdG8gYm90dG9tIG9yIGZyb20gYm90dG9tIHRvIHRvcC5cblx0XHQgKiBGb3IgSUUgPCA5IGl0IGlzIG5vdCBwb3NzaWJsZSwgc28gdGhlIGRpcmVjdGlvbiBmb3IgdGhlc2UgYnJvd3NlcnMgd2lsbCBiZSBhbHdheXMgQ0tFRElUT1IuU0VMRUNUSU9OX1RPUF9UT19CT1RUT00uXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgU2VsZWN0aW9uUmVnaW9uXG5cdFx0ICogQG1ldGhvZCBnZXRTZWxlY3Rpb25EaXJlY3Rpb25cblx0XHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgYSBudW1iZXIgd2hpY2ggcmVwcmVzZW50cyBzZWxlY3Rpb24gZGlyZWN0aW9uLiBJdCBtaWdodCBiZSBvbmUgb2YgdGhlc2U6XG5cdFx0ICogLSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTTtcblx0XHQgKiAtIENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QO1xuXHRcdCAqL1xuXHRcdGdldFNlbGVjdGlvbkRpcmVjdGlvbigpIHtcblx0XHRcdGxldCBkaXJlY3Rpb24gPSBDS0VESVRPUi5TRUxFQ1RJT05fVE9QX1RPX0JPVFRPTTtcblx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRjb25zdCBuYXRpdmVTZWxlY3Rpb24gPSBzZWxlY3Rpb24uZ2V0TmF0aXZlKCk7XG5cblx0XHRcdGlmICghbmF0aXZlU2VsZWN0aW9uKSB7XG5cdFx0XHRcdHJldHVybiBkaXJlY3Rpb247XG5cdFx0XHR9XG5cblx0XHRcdGxldCBhbmNob3JOb2RlO1xuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdChhbmNob3JOb2RlID0gbmF0aXZlU2VsZWN0aW9uLmFuY2hvck5vZGUpICYmXG5cdFx0XHRcdGFuY2hvck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHRcdCkge1xuXHRcdFx0XHRjb25zdCBwb3NpdGlvbiA9IGFuY2hvck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oXG5cdFx0XHRcdFx0bmF0aXZlU2VsZWN0aW9uLmZvY3VzTm9kZVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQoIXBvc2l0aW9uICYmXG5cdFx0XHRcdFx0XHRuYXRpdmVTZWxlY3Rpb24uYW5jaG9yT2Zmc2V0ID5cblx0XHRcdFx0XHRcdFx0bmF0aXZlU2VsZWN0aW9uLmZvY3VzT2Zmc2V0KSB8fFxuXHRcdFx0XHRcdHBvc2l0aW9uID09PSBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElOR1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRkaXJlY3Rpb24gPSBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGlyZWN0aW9uO1xuXHRcdH0sXG5cdH07XG5cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3NlbGVjdGlvbnJlZ2lvbicsIHtcblx0XHRpbml0KGVkaXRvcikge1xuXHRcdFx0bGV0IGF0dHI7XG5cdFx0XHRjb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblx0XHRcdGZvciAoYXR0ciBpbiBTZWxlY3Rpb25SZWdpb24ucHJvdG90eXBlKSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRoYXNPd25Qcm9wZXJ0eS5jYWxsKFNlbGVjdGlvblJlZ2lvbi5wcm90b3R5cGUsIGF0dHIpICYmXG5cdFx0XHRcdFx0dHlwZW9mIGVkaXRvclthdHRyXSA9PT0gJ3VuZGVmaW5lZCdcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZWRpdG9yW2F0dHJdID0gU2VsZWN0aW9uUmVnaW9uLnByb3RvdHlwZVthdHRyXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdH0pO1xufVxuIiwiY29uc3QgSUVfTk9OX0RJUkVDVExZX0VESVRBQkxFX0VMRU1FTlQgPSB7XG5cdHRhYmxlOiAxLFxuXHRjb2w6IDEsXG5cdGNvbGdyb3VwOiAxLFxuXHR0Ym9keTogMSxcblx0dGQ6IDEsXG5cdHRmb290OiAxLFxuXHR0aDogMSxcblx0dGhlYWQ6IDEsXG5cdHRyOiAxLFxufTtcblxuLyoqXG4gKiBUYWJsZSBjbGFzcyB1dGlsaXR5LiBQcm92aWRlcyBtZXRob2RzIGZvciBjcmVhdGUsIGRlbGV0ZSBhbmQgdXBkYXRlIHRhYmxlcy5cbiAqXG4gKiBAY2xhc3MgQ0tFRElUT1IuVGFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgQ0tFZGl0b3IgaW5zdGFuY2UuXG4gKi9cblxuZnVuY3Rpb24gVGFibGUoZWRpdG9yKSB7XG5cdHRoaXMuX2VkaXRvciA9IGVkaXRvcjtcbn1cblxuVGFibGUuSEVBRElOR19CT1RIID0gJ0JvdGgnO1xuVGFibGUuSEVBRElOR19DT0wgPSAnQ29sdW1uJztcblRhYmxlLkhFQURJTkdfTk9ORSA9ICdOb25lJztcblRhYmxlLkhFQURJTkdfUk9XID0gJ1Jvdyc7XG5cblRhYmxlLnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IFRhYmxlLFxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgdGFibGUuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IuVGFibGVcblx0ICogQG1ldGhvZCBjcmVhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUYWJsZSBjb25maWd1cmF0aW9uIG9iamVjdFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjcmVhdGVkIHRhYmxlXG5cdCAqL1xuXHRjcmVhdGUoY29uZmlnKSB7XG5cdFx0Y29uc3QgZWRpdG9yID0gdGhpcy5fZWRpdG9yO1xuXHRcdGNvbnN0IHRhYmxlID0gdGhpcy5fY3JlYXRlRWxlbWVudCgndGFibGUnKTtcblxuXHRcdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuXHRcdC8vIEdlbmVyYXRlIHRoZSByb3dzIGFuZCBjb2xzLlxuXHRcdGNvbnN0IHRib2R5ID0gdGFibGUuYXBwZW5kKHRoaXMuX2NyZWF0ZUVsZW1lbnQoJ3Rib2R5JykpO1xuXHRcdGNvbnN0IHJvd3MgPSBjb25maWcucm93cyB8fCAxO1xuXHRcdGNvbnN0IGNvbHMgPSBjb25maWcuY29scyB8fCAxO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcblx0XHRcdGNvbnN0IHJvdyA9IHRib2R5LmFwcGVuZCh0aGlzLl9jcmVhdGVFbGVtZW50KCd0cicpKTtcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgY29sczsgaisrKSB7XG5cdFx0XHRcdGNvbnN0IGNlbGwgPSByb3cuYXBwZW5kKHRoaXMuX2NyZWF0ZUVsZW1lbnQoJ3RkJykpO1xuXG5cdFx0XHRcdGNlbGwuYXBwZW5kQm9ndXMoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnNldEF0dHJpYnV0ZXModGFibGUsIGNvbmZpZy5hdHRycyk7XG5cdFx0dGhpcy5zZXRIZWFkaW5nKHRhYmxlLCBjb25maWcuaGVhZGluZyk7XG5cblx0XHQvLyBJbnNlcnQgdGhlIHRhYmxlIGVsZW1lbnQgaWYgd2UncmUgY3JlYXRpbmcgb25lLlxuXHRcdGVkaXRvci5pbnNlcnRFbGVtZW50KHRhYmxlKTtcblxuXHRcdGNvbnN0IGZpcnN0Q2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCh0YWJsZS4kLnJvd3NbMF0uY2VsbHNbMF0pO1xuXHRcdGNvbnN0IHJhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG5cdFx0cmFuZ2UubW92ZVRvUG9zaXRpb24oZmlyc3RDZWxsLCBDS0VESVRPUi5QT1NJVElPTl9BRlRFUl9TVEFSVCk7XG5cdFx0cmFuZ2Uuc2VsZWN0KCk7XG5cblx0XHRyZXR1cm4gdGFibGU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyBhIHRhYmxlIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG5cdCAqIEBtZXRob2QgZ2V0RnJvbVNlbGVjdGlvblxuXHQgKiBAcmV0dXJuIHtDS0VESVRPUi5kb20uZWxlbWVudH0gVGhlIHJldHJpZXZlZCB0YWJsZSBvciBudWxsIGlmIG5vdCBmb3VuZC5cblx0ICovXG5cdGdldEZyb21TZWxlY3Rpb24oKSB7XG5cdFx0bGV0IHRhYmxlO1xuXHRcdGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuX2VkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRjb25zdCBzZWxlY3RlZCA9IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuXHRcdGlmIChzZWxlY3RlZCAmJiBzZWxlY3RlZC5pcygndGFibGUnKSkge1xuXHRcdFx0dGFibGUgPSBzZWxlY3RlZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgcmFuZ2VzID0gc2VsZWN0aW9uLmdldFJhbmdlcygpO1xuXG5cdFx0XHRpZiAocmFuZ2VzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Ly8gV2Via2l0IGNvdWxkIHJlcG9ydCB0aGUgZm9sbG93aW5nIHJhbmdlIG9uIGNlbGwgc2VsZWN0aW9uICgjNDk0OCk6XG5cdFx0XHRcdC8vIDx0YWJsZT48dHI+PHRkPlsmbmJzcDs8L3RkPjwvdHI+PC90YWJsZT5dXG5cblx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblx0XHRcdFx0aWYgKENLRURJVE9SLmVudi53ZWJraXQpIHtcblx0XHRcdFx0XHRyYW5nZXNbMF0uc2hyaW5rKENLRURJVE9SLk5PREVfRUxFTUVOVCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0YWJsZSA9IHRoaXMuX2VkaXRvclxuXHRcdFx0XHRcdC5lbGVtZW50UGF0aChyYW5nZXNbMF0uZ2V0Q29tbW9uQW5jZXN0b3IodHJ1ZSkpXG5cdFx0XHRcdFx0LmNvbnRhaW5zKCd0YWJsZScsIDEpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0YWJsZTtcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2tzIGlmIGEgZ2l2ZW4gdGFibGUgY2FuIGJlIGNvbnNpZGVyZWQgYXMgZWRpdGFibGUuIFRoaXMgbWV0aG9kXG5cdCAqIHdvcmthcm91bmRzIGEgbGltaXRhdGlvbiBvZiBJRSB3aGVyZSBmb3Igc29tZSBlbGVtZW50cyAobGlrZSB0YWJsZSksXG5cdCAqIGBpc0NvbnRlbnRFZGl0YWJsZWAgcmV0dXJucyBhbHdheXMgZmFsc2UuIFRoaXMgaXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBzdXBwb3J0XG5cdCAqIGBjb250ZW50ZWRpdGFibGVgIG9uIHN1Y2ggZWxlbWVudHMuIEhvd2V2ZXIsIGRlc3BpdGUgc3VjaCBlbGVtZW50c1xuXHQgKiBjYW5ub3QgYmUgc2V0IGFzIGNvbnRlbnQgZWRpdGFibGUgZGlyZWN0bHksIGEgY29udGVudCBlZGl0YWJsZSBTUEFOLFxuXHQgKiBvciBESVYgZWxlbWVudCBjYW4gYmUgcGxhY2VkIGluc2lkZSB0aGUgaW5kaXZpZHVhbCB0YWJsZSBjZWxscy5cblx0ICogU2VlIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1Mzc4MzclMjh2PVZTLjg1JTI5LmFzcHhcblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuXHQgKiBAbWV0aG9kIGlzRWRpdGFibGVcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZWwgVGhlIHRhYmxlIGVsZW1lbnQgdG8gdGVzdCBpZiBlZGl0YWJsZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0aXNFZGl0YWJsZShlbCkge1xuXHRcdGlmICghQ0tFRElUT1IuZW52LmllIHx8ICFlbC5pcyhJRV9OT05fRElSRUNUTFlfRURJVEFCTEVfRUxFTUVOVCkpIHtcblx0XHRcdHJldHVybiAhZWwuaXNSZWFkT25seSgpO1xuXHRcdH1cblxuXHRcdGlmIChlbC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XG5cdFx0XHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSAhPT0gJ2ZhbHNlJztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5pc0VkaXRhYmxlKGVsLmdldFBhcmVudCgpKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB3aGljaCBoZWFkaW5nIHN0eWxlIGlzIHNldCBmb3IgdGhlIGdpdmVuIHRhYmxlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG5cdCAqIEBtZXRob2QgZ2V0SGVhZGluZ1xuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSB0YWJsZSBUaGUgdGFibGUgdG8gZ2F0aGVyIHRoZSBoZWFkaW5nIGZyb20uIElmIG51bGwsIGl0IHdpbGwgYmUgcmV0cmlldmVkIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBoZWFkaW5nIG9mIHRoZSB0YWJsZS4gRXhwZWN0ZWQgdmFsdWVzIGFyZSBgQ0tFRElUT1IuVGFibGUuTk9ORWAsIGBDS0VESVRPUi5UYWJsZS5ST1dgLCBgQ0tFRElUT1IuVGFibGUuQ09MYCBhbmQgYENLRURJVE9SLlRhYmxlLkJPVEhgLlxuXHQgKi9cblx0Z2V0SGVhZGluZyh0YWJsZSkge1xuXHRcdHRhYmxlID0gdGFibGUgfHwgdGhpcy5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cblx0XHRpZiAoIXRhYmxlKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRjb25zdCByb3dIZWFkaW5nU2V0dGluZ3MgPSB0YWJsZS4kLnRIZWFkICE9PSBudWxsO1xuXG5cdFx0bGV0IGNvbEhlYWRpbmdTZXR0aW5ncyA9IHRydWU7XG5cblx0XHQvLyBDaGVjayBpZiBhbGwgb2YgdGhlIGZpcnN0IGNlbGxzIGluIGV2ZXJ5IHJvdyBhcmUgVEhcblx0XHRmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0YWJsZS4kLnJvd3MubGVuZ3RoOyByb3crKykge1xuXHRcdFx0Ly8gSWYganVzdCBvbmUgY2VsbCBpc24ndCBhIFRIIHRoZW4gaXQgaXNuJ3QgYSBoZWFkZXIgY29sdW1uXG5cdFx0XHRjb25zdCBjZWxsID0gdGFibGUuJC5yb3dzW3Jvd10uY2VsbHNbMF07XG5cblx0XHRcdGlmIChjZWxsICYmIGNlbGwubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ3RoJykge1xuXHRcdFx0XHRjb2xIZWFkaW5nU2V0dGluZ3MgPSBmYWxzZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IGhlYWRpbmdTZXR0aW5ncyA9IFRhYmxlLkhFQURJTkdfTk9ORTtcblxuXHRcdGlmIChyb3dIZWFkaW5nU2V0dGluZ3MpIHtcblx0XHRcdGhlYWRpbmdTZXR0aW5ncyA9IFRhYmxlLkhFQURJTkdfUk9XO1xuXHRcdH1cblxuXHRcdGlmIChjb2xIZWFkaW5nU2V0dGluZ3MpIHtcblx0XHRcdGhlYWRpbmdTZXR0aW5ncyA9XG5cdFx0XHRcdGhlYWRpbmdTZXR0aW5ncyA9PT0gVGFibGUuSEVBRElOR19ST1dcblx0XHRcdFx0XHQ/IFRhYmxlLkhFQURJTkdfQk9USFxuXHRcdFx0XHRcdDogVGFibGUuSEVBRElOR19DT0w7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhlYWRpbmdTZXR0aW5ncztcblx0fSxcblxuXHQvKipcblx0ICogUmVtb3ZlcyBhIHRhYmxlIGZyb20gdGhlIGVkaXRvci5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuXHQgKiBAbWV0aG9kIHJlbW92ZVxuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSB0YWJsZSBUaGUgdGFibGUgZWxlbWVudCB3aGljaCB0YWJsZSBzdHlsZSBzaG91bGQgYmUgcmVtb3ZlZC5cblx0ICovXG5cdHJlbW92ZSh0YWJsZSkge1xuXHRcdGNvbnN0IGVkaXRvciA9IHRoaXMuX2VkaXRvcjtcblxuXHRcdGlmICh0YWJsZSkge1xuXHRcdFx0dGFibGUucmVtb3ZlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhYmxlID0gZWRpdG9yLmVsZW1lbnRQYXRoKCkuY29udGFpbnMoJ3RhYmxlJywgMSk7XG5cblx0XHRcdGlmICh0YWJsZSkge1xuXHRcdFx0XHQvLyBJZiB0aGUgdGFibGUncyBwYXJlbnQgaGFzIG9ubHkgb25lIGNoaWxkIHJlbW92ZSBpdCBhcyB3ZWxsICh1bmxlc3MgaXQncyBhIHRhYmxlIGNlbGwsIG9yIHRoZSBlZGl0YWJsZSBlbGVtZW50KSAoIzU0MTYsICM2Mjg5LCAjMTIxMTApXG5cdFx0XHRcdGNvbnN0IHBhcmVudCA9IHRhYmxlLmdldFBhcmVudCgpO1xuXHRcdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRwYXJlbnQuZ2V0Q2hpbGRDb3VudCgpID09PSAxICYmXG5cdFx0XHRcdFx0IXBhcmVudC5pcygndGQnLCAndGgnKSAmJlxuXHRcdFx0XHRcdCFwYXJlbnQuZXF1YWxzKGVkaXRhYmxlKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHR0YWJsZSA9IHBhcmVudDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHJhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG5cdFx0XHRcdHJhbmdlLm1vdmVUb1Bvc2l0aW9uKHRhYmxlLCBDS0VESVRPUi5QT1NJVElPTl9CRUZPUkVfU1RBUlQpO1xuXHRcdFx0XHR0YWJsZS5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFzc2lnbnMgcHJvdmlkZWQgYXR0cmlidXRlcyB0byBhIHRhYmxlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLlRhYmxlXG5cdCAqIEBtZXRob2Qgc2V0QXR0cmlidXRlc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFibGUgVGhlIHRhYmxlIHRvIHdoaWNoIHRoZSBhdHRyaWJ1dGVzIHNob3VsZCBiZSBhc3NpZ25lZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXR0cnMgVGhlIGF0dHJpYnV0ZXMgd2hpY2ggaGF2ZSB0byBiZSBhc3NpZ25lZCB0byB0aGUgdGFibGVcblx0ICovXG5cdHNldEF0dHJpYnV0ZXModGFibGUsIGF0dHJzKSB7XG5cdFx0aWYgKGF0dHJzKSB7XG5cdFx0XHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbihhdHRyKSB7XG5cdFx0XHRcdHRhYmxlLnNldEF0dHJpYnV0ZShhdHRyLCBhdHRyc1thdHRyXSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGFwcHJvcHJpYXRlIHRhYmxlIGhlYWRpbmcgc3R5bGUgdG8gYSB0YWJsZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuXHQgKiBAbWV0aG9kIHNldEhlYWRpbmdcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gdGFibGUgVGhlIHRhYmxlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGhlYWRpbmcgc2hvdWxkIGJlIHNldC4gSWYgbnVsbCwgaXQgd2lsbCBiZSByZXRyaWV2ZWQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkaW5nIFRoZSB0YWJsZSBoZWFkaW5nIHRvIGJlIHNldC4gQWNjZXB0ZWQgdmFsdWVzIGFyZTogYENLRURJVE9SLlRhYmxlLk5PTkVgLCBgQ0tFRElUT1IuVGFibGUuUk9XYCwgYENLRURJVE9SLlRhYmxlLkNPTGAgYW5kIGBDS0VESVRPUi5UYWJsZS5CT1RIYC5cblx0ICovXG5cdHNldEhlYWRpbmcodGFibGUsIGhlYWRpbmcpIHtcblx0XHR0YWJsZSA9IHRhYmxlIHx8IHRoaXMuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IG5ld0NlbGw7XG5cdFx0bGV0IHRhYmxlSGVhZDtcblx0XHRjb25zdCB0YWJsZUJvZHkgPSB0YWJsZS5nZXRFbGVtZW50c0J5VGFnKCd0Ym9keScpLmdldEl0ZW0oMCk7XG5cblx0XHRsZXQgdGFibGVIZWFkaW5nID0gdGhpcy5nZXRIZWFkaW5nKHRhYmxlKTtcblx0XHRjb25zdCBoYWRDb2xIZWFkaW5nID1cblx0XHRcdHRhYmxlSGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19DT0wgfHxcblx0XHRcdHRhYmxlSGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19CT1RIO1xuXG5cdFx0Y29uc3QgbmVlZENvbEhlYWRpbmcgPVxuXHRcdFx0aGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19DT0wgfHwgaGVhZGluZyA9PT0gVGFibGUuSEVBRElOR19CT1RIO1xuXHRcdGNvbnN0IG5lZWRSb3dIZWFkaW5nID1cblx0XHRcdGhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfUk9XIHx8IGhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfQk9USDtcblxuXHRcdC8vIElmIHdlIG5lZWQgcm93IGhlYWRpbmcgYW5kIGRvbid0IGhhdmUgYSA8dGhlYWQ+IGVsZW1lbnQgeWV0LCBtb3ZlIHRoZVxuXHRcdC8vIGZpcnN0IHJvdyBvZiB0aGUgdGFibGUgdG8gdGhlIGhlYWQgYW5kIGNvbnZlcnQgdGhlIG5vZGVzIHRvIDx0aD4gb25lcy5cblx0XHRpZiAoIXRhYmxlLiQudEhlYWQgJiYgbmVlZFJvd0hlYWRpbmcpIHtcblx0XHRcdGNvbnN0IHRhYmxlRmlyc3RSb3cgPSB0YWJsZUJvZHkuZ2V0RWxlbWVudHNCeVRhZygndHInKS5nZXRJdGVtKDApO1xuXHRcdFx0Y29uc3QgdGFibGVGaXJzdFJvd0NoaWxkQ291bnQgPSB0YWJsZUZpcnN0Um93LmdldENoaWxkQ291bnQoKTtcblxuXHRcdFx0Ly8gQ2hhbmdlIFREIHRvIFRIOlxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IHRhYmxlRmlyc3RSb3dDaGlsZENvdW50OyBpKyspIHtcblx0XHRcdFx0Y29uc3QgY2VsbCA9IHRhYmxlRmlyc3RSb3cuZ2V0Q2hpbGQoaSk7XG5cblx0XHRcdFx0Ly8gU2tpcCBib29rbWFyayBub2Rlcy4gKCM2MTU1KVxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0Y2VsbC50eXBlID09PSBDS0VESVRPUi5OT0RFX0VMRU1FTlQgJiZcblx0XHRcdFx0XHQhY2VsbC5kYXRhKCdja2UtYm9va21hcmsnKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjZWxsLnJlbmFtZU5vZGUoJ3RoJyk7XG5cdFx0XHRcdFx0Y2VsbC5zZXRBdHRyaWJ1dGUoJ3Njb3BlJywgJ2NvbCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRhYmxlSGVhZCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQodGFibGUuJC5jcmVhdGVUSGVhZCgpKTtcblx0XHRcdHRhYmxlSGVhZC5hcHBlbmQodGFibGVGaXJzdFJvdy5yZW1vdmUoKSk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZG9uJ3QgbmVlZCByb3cgaGVhZGluZyBhbmQgd2UgaGF2ZSBhIDx0aGVhZD4gZWxlbWVudCwgbW92ZSB0aGVcblx0XHQvLyByb3cgb3V0IG9mIHRoZXJlIGFuZCBpbnRvIHRoZSA8dGJvZHk+IGVsZW1lbnQuXG5cdFx0aWYgKHRhYmxlLiQudEhlYWQgIT09IG51bGwgJiYgIW5lZWRSb3dIZWFkaW5nKSB7XG5cdFx0XHQvLyBNb3ZlIHRoZSByb3cgb3V0IG9mIHRoZSBUSGVhZCBhbmQgcHV0IGl0IGluIHRoZSBUQm9keTpcblx0XHRcdHRhYmxlSGVhZCA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQodGFibGUuJC50SGVhZCk7XG5cblx0XHRcdGNvbnN0IHByZXZpb3VzRmlyc3RSb3cgPSB0YWJsZUJvZHkuZ2V0Rmlyc3QoKTtcblxuXHRcdFx0d2hpbGUgKHRhYmxlSGVhZC5nZXRDaGlsZENvdW50KCkgPiAwKSB7XG5cdFx0XHRcdGNvbnN0IG5ld0ZpcnN0Um93ID0gdGFibGVIZWFkLmdldEZpcnN0KCk7XG5cdFx0XHRcdGNvbnN0IG5ld0ZpcnN0Um93Q2hpbGRDb3VudCA9IG5ld0ZpcnN0Um93LmdldENoaWxkQ291bnQoKTtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbmV3Rmlyc3RSb3dDaGlsZENvdW50OyBpKyspIHtcblx0XHRcdFx0XHRuZXdDZWxsID0gbmV3Rmlyc3RSb3cuZ2V0Q2hpbGQoaSk7XG5cblx0XHRcdFx0XHRpZiAobmV3Q2VsbC50eXBlID09PSBDS0VESVRPUi5OT0RFX0VMRU1FTlQpIHtcblx0XHRcdFx0XHRcdG5ld0NlbGwucmVuYW1lTm9kZSgndGQnKTtcblx0XHRcdFx0XHRcdG5ld0NlbGwucmVtb3ZlQXR0cmlidXRlKCdzY29wZScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5ld0ZpcnN0Um93Lmluc2VydEJlZm9yZShwcmV2aW91c0ZpcnN0Um93KTtcblx0XHRcdH1cblxuXHRcdFx0dGFibGVIZWFkLnJlbW92ZSgpO1xuXHRcdH1cblxuXHRcdHRhYmxlSGVhZGluZyA9IHRoaXMuZ2V0SGVhZGluZyh0YWJsZSk7XG5cdFx0Y29uc3QgaGFzQ29sSGVhZGluZyA9XG5cdFx0XHR0YWJsZUhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfQ09MIHx8XG5cdFx0XHR0YWJsZUhlYWRpbmcgPT09IFRhYmxlLkhFQURJTkdfQk9USDtcblxuXHRcdC8vIElmIHdlIG5lZWQgY29sdW1uIGhlYWRpbmcgYW5kIHRoZSB0YWJsZSBkb2Vzbid0IGhhdmUgaXQsIGNvbnZlcnQgZXZlcnkgZmlyc3QgY2VsbCBpblxuXHRcdC8vIGV2ZXJ5IHJvdyBpbnRvIGEgYDx0aCBzY29wZT1cInJvd1wiPmAgZWxlbWVudC5cblx0XHRpZiAoIWhhc0NvbEhlYWRpbmcgJiYgbmVlZENvbEhlYWRpbmcpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCB0YWJsZS4kLnJvd3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHRhYmxlLiQucm93c1tpXS5jZWxsc1swXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAndGgnKSB7XG5cdFx0XHRcdFx0bmV3Q2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChcblx0XHRcdFx0XHRcdHRhYmxlLiQucm93c1tpXS5jZWxsc1swXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0bmV3Q2VsbC5yZW5hbWVOb2RlKCd0aCcpO1xuXHRcdFx0XHRcdG5ld0NlbGwuc2V0QXR0cmlidXRlKCdzY29wZScsICdyb3cnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHdlIGRvbid0IG5lZWQgY29sdW1uIGhlYWRpbmcgYnV0IHRoZSB0YWJsZSBoYXMgaXQsIGNvbnZlcnQgZXZlcnkgZmlyc3QgY2VsbCBpbiBldmVyeVxuXHRcdC8vIHJvdyBiYWNrIGludG8gYSBgPHRkPmAgZWxlbWVudC5cblx0XHRpZiAoaGFkQ29sSGVhZGluZyAmJiAhbmVlZENvbEhlYWRpbmcpIHtcblx0XHRcdGZvciAoaSA9IDA7IGkgPCB0YWJsZS4kLnJvd3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3Qgcm93ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHRhYmxlLiQucm93c1tpXSk7XG5cblx0XHRcdFx0aWYgKHJvdy5nZXRQYXJlbnQoKS5nZXROYW1lKCkgPT09ICd0Ym9keScpIHtcblx0XHRcdFx0XHRuZXdDZWxsID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHJvdy4kLmNlbGxzWzBdKTtcblx0XHRcdFx0XHRuZXdDZWxsLnJlbmFtZU5vZGUoJ3RkJyk7XG5cdFx0XHRcdFx0bmV3Q2VsbC5yZW1vdmVBdHRyaWJ1dGUoJ3Njb3BlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQgdXNpbmcgdGhlIHBhc3NlZCB0YWcgbmFtZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5UYWJsZVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBtZXRob2QgX2NyZWF0ZUVsZW1lbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIHRhZyBuYW1lIGZyb20gd2hpY2ggYW4gZWxlbWVudCBzaG91bGQgYmUgY3JlYXRlZFxuXHQgKiBAcmV0dXJuIHtDS0VESVRPUi5kb20uZWxlbWVudH0gSW5zdGFuY2Ugb2YgQ0tFRElUT1IgRE9NIGVsZW1lbnQgY2xhc3Ncblx0ICovXG5cdF9jcmVhdGVFbGVtZW50KG5hbWUpIHtcblx0XHRyZXR1cm4gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KG5hbWUsIHRoaXMuX2VkaXRvci5kb2N1bWVudCk7XG5cdH0sXG59O1xuXG5DS0VESVRPUi5vbignaW5zdGFuY2VSZWFkeScsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdGNvbnN0IGhlYWRpbmdDb21tYW5kcyA9IFtcblx0XHRUYWJsZS5IRUFESU5HX05PTkUsXG5cdFx0VGFibGUuSEVBRElOR19ST1csXG5cdFx0VGFibGUuSEVBRElOR19DT0wsXG5cdFx0VGFibGUuSEVBRElOR19CT1RILFxuXHRdO1xuXG5cdGNvbnN0IHRhYmxlVXRpbHMgPSBuZXcgVGFibGUoZXZlbnQuZWRpdG9yKTtcblxuXHRoZWFkaW5nQ29tbWFuZHMuZm9yRWFjaChmdW5jdGlvbihoZWFkaW5nKSB7XG5cdFx0ZXZlbnQuZWRpdG9yLmFkZENvbW1hbmQoJ3RhYmxlSGVhZGluZycgKyBoZWFkaW5nLCB7XG5cdFx0XHRleGVjKF9lZGl0b3IpIHtcblx0XHRcdFx0dGFibGVVdGlscy5zZXRIZWFkaW5nKG51bGwsIGhlYWRpbmcpO1xuXHRcdFx0fSxcblx0XHR9KTtcblx0fSk7XG59KTtcblxuQ0tFRElUT1IuVGFibGUgPSBDS0VESVRPUi5UYWJsZSB8fCBUYWJsZTtcbiIsIi8qKlxuICogQ0tFRElUT1IudG9vbHMgY2xhc3MgdXRpbGl0eSB3aGljaCBhZGRzIGFkZGl0aW9uYWwgbWV0aG9kcyB0byB0aG9zZSBvZiBDS0VkaXRvci5cbiAqXG4gKiBAY2xhc3MgQ0tFRElUT1IudG9vbHNcbiAqL1xuXG4vKipcbiAqIFNlbmRzIGEgcmVxdWVzdCB1c2luZyB0aGUgSlNPTlAgdGVjaG5pcXVlLlxuICpcbiAqIEBtZW1iZXJvZiBDS0VESVRPUi50b29sc1xuICogQG1ldGhvZCBqc29ucFxuICogQHBhcmFtIHtDS0VESVRPUi50ZW1wbGF0ZX0gdXJsVGVtcGxhdGUgVGhlIHRlbXBsYXRlIG9mIHRoZSBVUkwgdG8gYmUgcmVxdWVzdGVkLiBBbGwgcHJvcGVydGllcyBwYXNzZWQgaW4gYHVybFBhcmFtc2AgY2FuIGJlIHVzZWQsIHBsdXMgYSBge2NhbGxiYWNrfWAsIHdoaWNoIHJlcHJlc2VudCBhIEpTT05QIGNhbGxiYWNrLCBtdXN0IGJlIGRlZmluZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBpbiBjYXNlIG9mIHN1Y2Nlc3MuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcnJvckNhbGxiYWNrIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGluIGNhc2Ugb2YgZmFpbHVyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSB1cmxQYXJhbXMgUGFyYW1ldGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIGB1cmxUZW1wbGF0ZWAuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqICAtIGlkOiB0aGUgdHJhbnNhY3Rpb24gSURcbiAqICAtIGEgYGNhbmNlbCgpYCBtZXRob2RcbiAqIEBzdGF0aWNcbiAqL1xuQ0tFRElUT1IudG9vbHMuanNvbnAgPSBmdW5jdGlvbihcblx0dXJsVGVtcGxhdGUsXG5cdHVybFBhcmFtcyxcblx0Y2FsbGJhY2ssXG5cdGVycm9yQ2FsbGJhY2tcbikge1xuXHRjb25zdCBjYWxsYmFja0tleSA9IENLRURJVE9SLnRvb2xzLmdldE5leHROdW1iZXIoKTtcblxuXHR1cmxQYXJhbXMgPSB1cmxQYXJhbXMgfHwge307XG5cdHVybFBhcmFtcy5jYWxsYmFjayA9ICdDS0VESVRPUi5fLmpzb25wQ2FsbGJhY2tzWycgKyBjYWxsYmFja0tleSArICddJztcblxuXHRpZiAoIUNLRURJVE9SLl8uanNvbnBDYWxsYmFja3MpIHtcblx0XHRDS0VESVRPUi5fLmpzb25wQ2FsbGJhY2tzID0ge307XG5cdH1cblxuXHRDS0VESVRPUi5fLmpzb25wQ2FsbGJhY2tzW2NhbGxiYWNrS2V5XSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG5cdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdGNsZWFuVXAoKTtcblxuXHRcdFx0Y2FsbGJhY2socmVzcG9uc2UpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdGxldCBzY3JpcHRFbGVtZW50ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCdzY3JpcHQnKTtcblx0c2NyaXB0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3NyYycsIHVybFRlbXBsYXRlLm91dHB1dCh1cmxQYXJhbXMpKTtcblx0c2NyaXB0RWxlbWVudC5vbignZXJyb3InLCBmdW5jdGlvbigpIHtcblx0XHRjbGVhblVwKCk7XG5cblx0XHRpZiAoZXJyb3JDYWxsYmFjaykge1xuXHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gY2xlYW5VcCgpIHtcblx0XHRpZiAoc2NyaXB0RWxlbWVudCkge1xuXHRcdFx0c2NyaXB0RWxlbWVudC5yZW1vdmUoKTtcblx0XHRcdGRlbGV0ZSBDS0VESVRPUi5fLmpzb25wQ2FsbGJhY2tzW2NhbGxiYWNrS2V5XTtcblx0XHRcdHNjcmlwdEVsZW1lbnQgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdENLRURJVE9SLmRvY3VtZW50LmdldEJvZHkoKS5hcHBlbmQoc2NyaXB0RWxlbWVudCk7XG5cblx0cmV0dXJuIHtcblx0XHRjYW5jZWw6IGNsZWFuVXAsXG5cdFx0aWQ6IGNhbGxiYWNrS2V5LFxuXHR9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IG9iamVjdCBjb250YWluaW5nIGFsbCBvZiB0aGUgcHJvcGVydGllcyBvZiBhbGwgdGhlIHN1cHBsaWVkXG4gKiBvYmplY3RzLiBUaGUgcHJvcGVydGllcyBmcm9tIGxhdGVyIG9iamVjdHMgd2lsbCBvdmVyd3JpdGUgdGhvc2UgaW4gZWFybGllclxuICogb2JqZWN0cy5cbiAqXG4gKiBQYXNzaW5nIGluIGEgc2luZ2xlIG9iamVjdCB3aWxsIGNyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiBpdC5cbiAqXG4gKiBAbWVtYmVyb2YgQ0tFRElUT1IudG9vbHNcbiAqIEBtZXRob2QgbWVyZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RzKiBPbmUgb3IgbW9yZSBvYmplY3RzIHRvIG1lcmdlLlxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBtZXJnZWQgb2JqZWN0LlxuICogQHN0YXRpY1xuICovXG5DS0VESVRPUi50b29scy5tZXJnZSA9XG5cdENLRURJVE9SLnRvb2xzLm1lcmdlIHx8XG5cdGZ1bmN0aW9uKC4uLmFyZ3MpIHtcblx0XHRjb25zdCByZXN1bHQgPSB7fTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuXHRcdFx0Y29uc3Qgb2JqID0gYXJnc1tpXTtcblxuXHRcdFx0Zm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG5cdFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG5cdFx0XHRcdFx0cmVzdWx0W2tleV0gPSBvYmpba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cbi8qKlxuICogU2ltdWxhdGVzIGV2ZW50IG9uIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogQG1lbWJlcm9mIENLRURJVE9SLnRvb2xzXG4gKiBAbWV0aG9kIHNpbXVsYXRlXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgb24gd2hpY2ggdGhlIGV2ZW50IHNob3VkIGJlIHNpbXVhbHRlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgd2hpY2ggaGF2ZSB0byBiZSBzaW11bGF0ZWQuXG4gKiBAc3RhdGljXG4gKi9cbkNLRURJVE9SLnRvb2xzLnNpbXVsYXRlID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnQpIHtcblx0Y29uc3QgZXZlbnRJbnN0YW5jZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudHMnKTtcblx0ZXZlbnRJbnN0YW5jZS5pbml0RXZlbnQoZXZlbnQsIHRydWUsIGZhbHNlKTtcblx0ZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50SW5zdGFuY2UpO1xufTtcbiIsImlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3VpY29yZScpKSB7XG5cdC8qKlxuXHQgKiBVSUNvcmUgY2xhc3Mgd2hpY2ggd2lsbCBoYW5kbGUgdXNlciBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgZWRpdG9yLiBUaGVzZSBpbnRlcmFjdGlvbnNcblx0ICogbWlnaHQgYmUgdHJpZ2dlcmVkIHZpYSBtb3VzZSwga2V5Ym9hcmQgb3IgdG91Y2ggZGV2aWNlcy4gVGhlIGNsYXNzIGZpbGwgZmlyZSBhbiBldmVudCB2aWFcblx0ICogQ0tFZGl0b3IncyBldmVudCBzeXN0ZW0gLSBcImVkaXRvckludGVyYWN0aW9uXCIuIFRoZSBVSSBtYXkgbGlzdGVuIHRvIHRoaXMgZXZlbnQgYW5kXG5cdCAqIGV4ZWN1dGUgc29tZSBhY3Rpb25zIC0gZm9yIGV4YW1wbGUgdG8gc2hvdy9oaWRlIHRvb2xiYXJzLlxuXHQgKlxuXHQgKiBCeSBkZWZhdWx0IGlmIHVzZXIgcHJlc3NlcyB0aGUgRXNjIGtleSwgJ2VkaXRvckludGVyYWN0aW9uJyBldmVudCB3b24ndCBiZSBmaXJlZC4gSG93ZXZlciwgdGhpcyBiZWhhdmlvdXIgY2FuIGJlIGNoYW5nZWRcblx0ICogYnkgc2V0dGluZyB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3VpY29yZS9hbGxvd0VzYzphdHRyaWJ1dGVcIn19e3svY3Jvc3NMaW5rfX0gY29uZmlnIHByb3BlcnR5IGluIGVkaXRvcidzIGNvbmZpZ3VyYXRpb24gdG8gdHJ1ZS5cblx0ICpcblx0ICogQGNsYXNzIGFlX3VpY29yZVxuXHQgKi9cblxuXHQvKipcblx0ICogRmlyZWQgd2hlbiB1c2VyIGludGVyYWN0cyBzb21laG93IHdpdGggdGhlIGJyb3dzZXIuIFRoaXMgbWF5IGJlIGNsaWNraW5nIHdpdGggdGhlIG1vdXNlLCBwcmVzc2luZyBrZXlib2FyZCBidXR0b24sXG5cdCAqIG9yIHRvdWNoaW5nIHNjcmVlbi4gVGhpcyBldmVuIHdpbGwgYmUgbm90IGZpcmVkIGFmdGVyIGVhY2ggaW50ZXJhY3Rpb24uIEl0IHdpbGwgYmUgZGVib3VuY2VkLiBCeSBkZWZhdWx0IHRoZSB0aW1lb3V0XG5cdCAqIGlzIDUwbXMuIFRoaXMgdmFsdWUgY2FuIGJlIG92ZXJ3cml0dGVuIHZpYSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3VpY29yZS90aW1lb3V0OmF0dHJpYnV0ZVwifX17ey9jcm9zc0xpbmt9fVxuXHQgKiBwcm9wZXJ0eSBvZiBlZGl0b3IncyBjb25maWd1cmF0aW9uLCBsaWtlOiBlZGl0b3IuY29uZmlnLnVpY29yZS50aW1lb3V0ID0gMTAwXG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBhZV91aWNvcmVcblx0ICogQGV2ZW50IGFlX3VpY29yZSNlZGl0b3JJbnRlcmFjdGlvblxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBBbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXHQgKiAtIG5hdGl2ZUV2ZW50IC0gVGhlIGV2ZW50IGFzIHJlY2VpdmVkIGZyb20gQ0tFZGl0b3IuXG5cdCAqIC0gc2VsZWN0aW9uRGF0YSAtIFRoZSBkYXRhLCByZXR1cm5lZCBmcm9tIHt7I2Nyb3NzTGluayBcIkNLRURJVE9SLnBsdWdpbnMuYWVfc2VsZWN0aW9ucmVnaW9uL2dldFNlbGVjdGlvbkRhdGE6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBGaXJlZCBieSBVSSBlbGVtZW50cyBsaWtlIFRvb2xiYXJzIG9yIEJ1dHRvbnMgd2hlbiB0aGVpciBzdGF0ZSBjaGFuZ2VzLiBUaGUgbGlzdGVuZXIgdXBkYXRlcyB0aGUgbGl2ZSByZWdpb24gd2l0aCB0aGUgcHJvdmlkZWQgZGF0YS5cblx0ICpcblx0ICogQG1lbWJlcm9mIGFlX3VpY29yZVxuXHQgKiBAZXZlbnQgYWVfdWljb3JlI2FyaWFVcGRhdGVcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcblx0ICogLSBtZXNzYWdlIC0gVGhlIHByb3ZpZGVkIG1lc3NhZ2UgZnJvbSB0aGUgVUkgZWxlbWVudC5cblx0ICovXG5cblx0LyoqXG5cdCAqIElmIHNldCB0byB0cnVlLCB0aGUgZWRpdG9yIHdpbGwgc3RpbGwgZmlyZSB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX3VpY29yZS9lZGl0b3JJbnRlcmFjdGlvbjpldmVudFwifX17ey9jcm9zc0xpbmt9fSBldmVudCxcblx0ICogaWYgdXNlciBwcmVzc2VzIEVzYyBrZXkuXG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBhZV91aWNvcmVcblx0ICogQGF0dHJpYnV0ZSBhbGxvd0VzY1xuXHQgKiBAZGVmYXVsdCBmYWxzZVxuXHQgKiBAdHlwZSBCb29sZWFuXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBTcGVjaWZpZXMgdGhlIGRlZmF1bHQgdGltZW91dCBhZnRlciB3aGljaCB0aGUge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV91aWNvcmUvZWRpdG9ySW50ZXJhY3Rpb246ZXZlbnRcIn19e3svY3Jvc3NMaW5rfX0gZXZlbnRcblx0ICogd2lsbCBiZSBmaXJlZC5cblx0ICpcblx0ICogQG1lbWJlcm9mIGFlX3VpY29yZVxuXHQgKiBAYXR0cmlidXRlIHRpbWVvdXRcblx0ICogQGRlZmF1bHQgNTAgKG1zKVxuXHQgKiBAdHlwZSBOdW1iZXJcblx0ICovXG5cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3VpY29yZScsIHtcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXplciBsaWZlY3ljbGUgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBVSUNvcmUgcGx1Z2luLlxuXHRcdCAqXG5cdFx0ICogQG1lbWJlcm9mIGFlX3VpY29yZVxuXHRcdCAqIEBtZXRob2QgaW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgQ0tFZGl0b3IgaW5zdGFuY2UuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdGluaXQoZWRpdG9yKSB7XG5cdFx0XHRsZXQgYXJpYVN0YXRlID0gW107XG5cblx0XHRcdGNvbnN0IGFyaWFFbGVtZW50ID0gdGhpcy5fY3JlYXRlQXJpYUVsZW1lbnQoZWRpdG9yLmlkKTtcblxuXHRcdFx0Y29uc3QgdWlUYXNrc1RpbWVvdXQgPSBlZGl0b3IuY29uZmlnLnVpY29yZVxuXHRcdFx0XHQ/IGVkaXRvci5jb25maWcudWljb3JlLnRpbWVvdXRcblx0XHRcdFx0OiA1MDtcblxuXHRcdFx0Y29uc3QgaGFuZGxlVUkgPSBDS0VESVRPUi50b29scy5kZWJvdW5jZShmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRhcmlhU3RhdGUgPSBbXTtcblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ZXZlbnQubmFtZSAhPT0gJ2tleXVwJyB8fFxuXHRcdFx0XHRcdGV2ZW50LmRhdGEuJC5rZXlDb2RlICE9PSAyNyB8fFxuXHRcdFx0XHRcdGVkaXRvci5jb25maWcuYWxsb3dFc2Ncblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uRGF0YSA9IGVkaXRvci5nZXRTZWxlY3Rpb25EYXRhKCk7XG5cblx0XHRcdFx0XHRpZiAoc2VsZWN0aW9uRGF0YSkge1xuXHRcdFx0XHRcdFx0ZWRpdG9yLmZpcmUoJ2VkaXRvckludGVyYWN0aW9uJywge1xuXHRcdFx0XHRcdFx0XHRuYXRpdmVFdmVudDogZXZlbnQuZGF0YS4kLFxuXHRcdFx0XHRcdFx0XHRzZWxlY3Rpb25EYXRhLFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LCB1aVRhc2tzVGltZW91dCk7XG5cblx0XHRcdGNvbnN0IGhhbmRsZUFyaWEgPSBDS0VESVRPUi50b29scy5kZWJvdW5jZShmdW5jdGlvbihfZXZlbnQpIHtcblx0XHRcdFx0YXJpYUVsZW1lbnQuaW5uZXJIVE1MID0gYXJpYVN0YXRlLmpvaW4oJy4gJyk7XG5cdFx0XHR9LCB1aVRhc2tzVGltZW91dCk7XG5cblx0XHRcdGNvbnN0IGhhbmRsZU1vdXNlTGVhdmUgPSBDS0VESVRPUi50b29scy5kZWJvdW5jZShmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRjb25zdCBhZVVJTm9kZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYWUtdWknKTtcblxuXHRcdFx0XHRsZXQgZm91bmQ7XG5cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhZVVJTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoYWVVSU5vZGVzW2ldLmNvbnRhaW5zKGV2ZW50LmRhdGEuJC5yZWxhdGVkVGFyZ2V0KSkge1xuXHRcdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCFmb3VuZCkge1xuXHRcdFx0XHRcdGhhbmRsZVVJKGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdWlUYXNrc1RpbWVvdXQpO1xuXG5cdFx0XHRlZGl0b3Iub24oJ2FyaWFVcGRhdGUnLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHQvLyBoYW5kbGVBcmlhIGlzIGRlYm91bmNlZCBmdW5jdGlvbiwgc28gaWYgaXQgaXMgYmVpbmcgY2FsbGVkIG11bHRpcGxlIHRpbWVzLCBpdCB3aWxsXG5cdFx0XHRcdC8vIGJlIGNhbmNlbGVkIHVudGlsIHNvbWUgdGltZSBwYXNzZXMuXG5cdFx0XHRcdC8vIEZvciB0aGF0IHJlYXNvbiBoZXJlIHdlIGV4cGxpY2l0bHkgYXBwZW5kIHRoZSBjdXJyZW50IG1lc3NhZ2UgdG8gdGhlIGxpc3Qgb2YgbWVzc2FnZXNcblx0XHRcdFx0Ly8gYW5kIGNhbGwgaGFuZGxlQXJpYS4gU2luY2UgaXQgaXMgZGVib3VuY2VkLCB3aGVuIHNvbWUgdGltZW91dCBwYXNzZXMsXG5cdFx0XHRcdC8vIGFsbCB0aGUgbWVzc2FnZXMgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBsaXZlIHJlZ2lvbiBhbmQgbm90IG9ubHkgdGhlIGxhc3Qgb25lLlxuXG5cdFx0XHRcdGFyaWFTdGF0ZS5wdXNoKGV2ZW50LmRhdGEubWVzc2FnZSk7XG5cblx0XHRcdFx0aGFuZGxlQXJpYSgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGVkaXRvci5vbmNlKCdjb250ZW50RG9tJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdFx0Y29uc3QgZm9jdXNIYW5kbGVyID0gZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoXG5cdFx0XHRcdFx0ZWRpdGFibGUsXG5cdFx0XHRcdFx0J2ZvY3VzJyxcblx0XHRcdFx0XHRmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0Zm9jdXNIYW5kbGVyLnJlbW92ZUxpc3RlbmVyKCk7XG5cblx0XHRcdFx0XHRcdGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKGVkaXRhYmxlLCAna2V5dXAnLCBoYW5kbGVVSSk7XG5cdFx0XHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihlZGl0YWJsZSwgJ21vdXNldXAnLCBoYW5kbGVVSSk7XG5cdFx0XHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0XHRcdFx0ZWRpdGFibGUsXG5cdFx0XHRcdFx0XHRcdCdtb3VzZWxlYXZlJyxcblx0XHRcdFx0XHRcdFx0aGFuZGxlTW91c2VMZWF2ZVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0aGFuZGxlVUkoZXZlbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRlZGl0b3Iub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbihfZXZlbnQpIHtcblx0XHRcdFx0YXJpYUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhcmlhRWxlbWVudCk7XG5cblx0XHRcdFx0aGFuZGxlVUkuZGV0YWNoKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlcyBhbmQgYXBwbGllcyBhbiBIVE1MIGVsZW1lbnQgdG8gdGhlIGJvZHkgb2YgdGhlIGRvY3VtZW50IHdoaWNoIHdpbGwgY29udGFpbiBBUklBIG1lc3NhZ2VzLlxuXHRcdCAqXG5cdFx0ICogQG1lbWJlcm9mIGFlX3VpY29yZVxuXHRcdCAqIEBtZXRob2QgX2NyZWF0ZUFyaWFFbGVtZW50XG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGlkIFRoZSBwcm92aWRlZCBpZCBvZiB0aGUgZWxlbWVudC4gSXQgd2lsbCBiZSB1c2VkIGFzIHByZWZpeCBmb3IgdGhlIGZpbmFsIGVsZW1lbnQgSWQuXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSBUaGUgY3JlYXRlZCBhbmQgYXBwbGllZCB0byBET00gZWxlbWVudC5cblx0XHQgKi9cblx0XHRfY3JlYXRlQXJpYUVsZW1lbnQoaWQpIHtcblx0XHRcdGNvbnN0IHN0YXR1c0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuXHRcdFx0c3RhdHVzRWxlbWVudC5jbGFzc05hbWUgPSAnYWUtc3Itb25seSc7XG5cblx0XHRcdHN0YXR1c0VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XG5cdFx0XHRzdGF0dXNFbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdzdGF0dXMnKTtcblx0XHRcdHN0YXR1c0VsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGlkICsgJ0xpdmVSZWdpb24nKTtcblxuXHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0dXNFbGVtZW50KTtcblxuXHRcdFx0cmV0dXJuIHN0YXR1c0VsZW1lbnQ7XG5cdFx0fSxcblx0fSk7XG59XG4iLCJpbXBvcnQgTGFuZyBmcm9tICcuL2xhbmcnO1xuXG4vKipcbiAqIEF0dHJpYnV0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAY2xhc3MgQXR0cmlidXRlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQXR0cmlidXRlKGNvbmZpZykge1xuXHR0aGlzLl9fY29uZmlnX18gPSBjb25maWcgfHwge307XG5cdHRoaXMuX19BVFRSU19fID0ge307XG59XG5cbkF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBBdHRyaWJ1dGUsXG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEF0dHJpYnV0ZVxuXHQgKiBAbWV0aG9kIGdldFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBUaGUgYXR0cmlidXRlIHdoaWNoIHZhbHVlIHNob3VsZCBiZSByZXRyaWV2ZWQuXG5cdCAqIEByZXR1cm4ge0FueX0gVGhlIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG5cdCAqL1xuXHRnZXQoYXR0cikge1xuXHRcdGNvbnN0IGN1cnJlbnRBdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5BVFRSU1thdHRyXTtcblxuXHRcdGlmICghY3VycmVudEF0dHIpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX2lzSW5pdGlhbGl6ZWQoYXR0cikpIHtcblx0XHRcdHRoaXMuX2luaXQoYXR0cik7XG5cdFx0fVxuXG5cdFx0bGV0IGN1clZhbHVlID0gdGhpcy5fX0FUVFJTX19bYXR0cl07XG5cblx0XHRpZiAoY3VycmVudEF0dHIuZ2V0dGVyKSB7XG5cdFx0XHRjdXJWYWx1ZSA9IHRoaXMuX2NhbGxTdHJpbmdPckZ1bmN0aW9uKGN1cnJlbnRBdHRyLmdldHRlciwgY3VyVmFsdWUpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjdXJWYWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEF0dHJpYnV0ZVxuXHQgKiBAbWV0aG9kIHNldFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBUaGUgYXR0cmlidXRlIHdoaWNoIHZhbHVlIHNob3VsZCBiZSBzZXQuXG5cdCAqIEBwYXJhbSB7QW55fSB2YWx1ZSBUaGUgdmFsdWUgd2hpY2ggc2hvdWxkIGJlIHNldCB0byB0aGUgYXR0cmlidXRlLlxuXHQgKi9cblx0c2V0KGF0dHIsIHZhbHVlKSB7XG5cdFx0Y29uc3QgY3VycmVudEF0dHIgPSB0aGlzLmNvbnN0cnVjdG9yLkFUVFJTW2F0dHJdO1xuXG5cdFx0aWYgKCFjdXJyZW50QXR0cikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5faXNJbml0aWFsaXplZChhdHRyKSkge1xuXHRcdFx0dGhpcy5faW5pdChhdHRyKTtcblx0XHR9XG5cblx0XHRpZiAoY3VycmVudEF0dHIucmVhZE9ubHkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoY3VycmVudEF0dHIud3JpdGVPbmNlICYmIHRoaXMuX2lzSW5pdGlhbGl6ZWQoYXR0cikpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoXG5cdFx0XHRjdXJyZW50QXR0ci52YWxpZGF0b3IgJiZcblx0XHRcdCF0aGlzLl9jYWxsU3RyaW5nT3JGdW5jdGlvbihjdXJyZW50QXR0ci52YWxpZGF0b3IsIHZhbHVlKVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChjdXJyZW50QXR0ci5zZXR0ZXIpIHtcblx0XHRcdHZhbHVlID0gdGhpcy5fY2FsbFN0cmluZ09yRnVuY3Rpb24oY3VycmVudEF0dHIuc2V0dGVyLCB2YWx1ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fX0FUVFJTX19bYXR0cl0gPSB2YWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogQ2FsbHMgdGhlIHByb3ZpZGVkIHBhcmFtIGFzIGZ1bmN0aW9uIHdpdGggdGhlIHN1cHBsaWVkIGFyZ3VtZW50cy5cblx0ICogSWYgcGFyYW0gcHJvdmlkZWQgYXMgc3RyaW5nLCBhIGNvcnJlc3BvbmRpbmcgZnVuY3Rpb24gaW4gdGhpcyBvYmplY3Qgd2lsbFxuXHQgKiBiZSBjYWxsZWQuIElmIHByb3ZpZGVkIHBhcmFtIGlzIGEgZnVuY3Rpb24sIGl0IHdpbGwgYmUgZGlyZWN0bHkgY2FsbGVkLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEF0dHJpYnV0ZVxuXHQgKiBAbWV0aG9kIF9jYWxsU3RyaW5nT3JGdW5jdGlvblxuXHQgKiBAcGFyYW0gIHtBbnl8QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB3aGljaCB3aWxsIGJlIHByb3ZpZGVkIHRvIHRoZSBjYWxsZWQgZnVuY3Rpb25cblx0ICogQHBhcmFtICB7U3RyaW5nfEZ1bmN0aW9ufSBzdHJpbmdPckZ1bmN0aW9uIFRoZSBmdW5jdGlvbiB3aGljaCBzaG91bGQgYmUgY2FsbGVkXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHJldHVybiB7QW55fSBUaGUgcmV0dXJuZWQgdmFsdWUgZnJvbSB0aGUgY2FsbGVkIGZ1bmN0aW9uXG5cdCAqL1xuXHRfY2FsbFN0cmluZ09yRnVuY3Rpb24oc3RyaW5nT3JGdW5jdGlvbiwgYXJncykge1xuXHRcdGxldCByZXN1bHQgPSBudWxsO1xuXG5cdFx0aWYgKCFMYW5nLmlzQXJyYXkoYXJncykpIHtcblx0XHRcdGFyZ3MgPSBbYXJnc107XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0TGFuZy5pc1N0cmluZyhzdHJpbmdPckZ1bmN0aW9uKSAmJlxuXHRcdFx0TGFuZy5pc0Z1bmN0aW9uKHRoaXNbc3RyaW5nT3JGdW5jdGlvbl0pXG5cdFx0KSB7XG5cdFx0XHRyZXN1bHQgPSB0aGlzW3N0cmluZ09yRnVuY3Rpb25dKC4uLmFyZ3MpO1xuXHRcdH0gZWxzZSBpZiAoTGFuZy5pc0Z1bmN0aW9uKHN0cmluZ09yRnVuY3Rpb24pKSB7XG5cdFx0XHRyZXN1bHQgPSBzdHJpbmdPckZ1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIGFuIGF0dHJpYnV0ZS4gU2V0cyBpdHMgZGVmYXVsdCB2YWx1ZSBkZXBlbmRpbmcgb24gdGhlIGZsYWdzIG9mIHRoZVxuXHQgKiBhdHRyaWJ1dGUgYW5kIHRoZSBwYXNzZWQgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gdGhlIGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIEF0dHJpYnV0ZVxuXHQgKiBAbWV0aG9kIF9pbml0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgd2hpY2ggaGF2ZSB0byBiZSBpbml0aWFsaXplZC5cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X2luaXQoYXR0cikge1xuXHRcdGxldCB2YWx1ZTtcblxuXHRcdGNvbnN0IGN1cnJlbnRBdHRyID0gdGhpcy5jb25zdHJ1Y3Rvci5BVFRSU1thdHRyXTtcblxuXHRcdC8vIENoZWNrIGlmIHRoZXJlIGlzIGRlZmF1bHQgdmFsdWUgb3IgcGFzc2VkIG9uZSB2aWEgY29uZmlndXJhdGlvbiBvYmplY3Rcblx0XHRjb25zdCBoYXNEZWZhdWx0VmFsdWUgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG5cdFx0XHRjdXJyZW50QXR0cixcblx0XHRcdCd2YWx1ZSdcblx0XHQpO1xuXHRcdGNvbnN0IGhhc1Bhc3NlZFZhbHVlVmlhQ29uZmlnID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuXHRcdFx0dGhpcy5fX2NvbmZpZ19fLFxuXHRcdFx0YXR0clxuXHRcdCk7XG5cblx0XHQvLyBJZiB0aGVyZSBpcyB2YWx1ZUZuLCBzZXQgdGhlIHZhbHVlIHRvIGJlIHRoZSByZXN1bHQgb2YgaW52b2NhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uXG5cdFx0aWYgKGN1cnJlbnRBdHRyLnZhbHVlRm4pIHtcblx0XHRcdHZhbHVlID0gdGhpcy5fY2FsbFN0cmluZ09yRnVuY3Rpb24oY3VycmVudEF0dHIudmFsdWVGbiwgdmFsdWUpO1xuXG5cdFx0XHR0aGlzLl9fQVRUUlNfX1thdHRyXSA9IHZhbHVlO1xuXHRcdH1cblx0XHQvLyBlbHNlIGlmIHRoZSBhdHRyaWJ1dGUgaGFzIHJlYWRPbmx5IGZsYWcsIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSBhdHRyaWJ1dGUsXG5cdFx0Ly8gcmVnYXJkbGVzcyBpZiB0aGVyZSBpcyB2YWx1ZSBvciBub3Rcblx0XHRlbHNlIGlmIChjdXJyZW50QXR0ci5yZWFkT25seSkge1xuXHRcdFx0dmFsdWUgPSBjdXJyZW50QXR0ci52YWx1ZTtcblx0XHR9XG5cdFx0Ly8gZWxzZSBpZiB0aGUgYXR0cmlidXRlIGhhcyB3cml0ZU9uY2UgdmFsdWUsIHNldCBpdCBmcm9tIHRoZSBwYXNzZWQgY29uZmlndXJhdGlvbiBvciBmcm9tIHRoZVxuXHRcdC8vIGRlZmF1bHQgdmFsdWUsIGluIHRoaXMgb3JkZXIuIE90aGVyd2lzZSwgcmV0dXJuIG1pc2VyYWJsZS5cblx0XHRlbHNlIGlmIChjdXJyZW50QXR0ci53cml0ZU9uY2UpIHtcblx0XHRcdGlmIChoYXNQYXNzZWRWYWx1ZVZpYUNvbmZpZykge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuX19jb25maWdfX1thdHRyXTtcblx0XHRcdH0gZWxzZSBpZiAoaGFzRGVmYXVsdFZhbHVlKSB7XG5cdFx0XHRcdHZhbHVlID0gY3VycmVudEF0dHIudmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIFRoZXNlIHR3byBjYXNlcyBiZWxvdyBhcmUgZWFzeSAtIHNldCB0aGUgdmFsdWUgdG8gYmUgZnJvbSB0aGUgcGFzc2VkIGNvbmZpZyBvclxuXHRcdC8vIGZyb20gdGhlIGRlZmF1bHQgdmFsdWUsIGluIHRoaXMgb3JkZXIuXG5cdFx0ZWxzZSBpZiAoaGFzUGFzc2VkVmFsdWVWaWFDb25maWcpIHtcblx0XHRcdHZhbHVlID0gdGhpcy5fX2NvbmZpZ19fW2F0dHJdO1xuXHRcdH0gZWxzZSBpZiAoaGFzRGVmYXVsdFZhbHVlKSB7XG5cdFx0XHR2YWx1ZSA9IGN1cnJlbnRBdHRyLnZhbHVlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGlzIHZhbGlkYXRvciwgYW5kIHVzZXIgcGFzc2VkIGNvbmZpZyBvYmplY3QgLSBjaGVjayB0aGUgcmV0dXJuZWQgdmFsdWUuXG5cdFx0Ly8gSWYgaXQgaXMgZmFsc2UsIHRoZW4gc2V0IGFzIGluaXRpYWwgdmFsdWUgdGhlIGRlZmF1bHQgb25lLlxuXHRcdC8vIEhvd2V2ZXIsIGlmIHRoZXJlIGlzIG5vIGRlZmF1bHQgdmFsdWUsIGp1c3QgcmV0dXJuLlxuXHRcdGlmIChcblx0XHRcdGN1cnJlbnRBdHRyLnZhbGlkYXRvciAmJlxuXHRcdFx0aGFzUGFzc2VkVmFsdWVWaWFDb25maWcgJiZcblx0XHRcdCF0aGlzLl9jYWxsU3RyaW5nT3JGdW5jdGlvbihjdXJyZW50QXR0ci52YWxpZGF0b3IsIHZhbHVlKVxuXHRcdCkge1xuXHRcdFx0aWYgKGhhc0RlZmF1bHRWYWx1ZSkge1xuXHRcdFx0XHR2YWx1ZSA9IGN1cnJlbnRBdHRyLnZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGlzIHNldHRlciBhbmQgdXNlciBwYXNzZWQgY29uZmlnIG9iamVjdCAtIHBhc3MgdGhlIHZhbHVlIHRob3VnaHQgdGhlIHNldHRlci5cblx0XHQvLyBUaGUgdmFsdWUgbWlnaHQgYmUgb25lIGZyb20gZGVmYXVsdEZuLCBkZWZhdWx0IHZhbHVlIG9yIHByb3ZpZGVkIGZyb20gdGhlIGNvbmZpZy5cblx0XHRpZiAoY3VycmVudEF0dHIuc2V0dGVyICYmIGhhc1Bhc3NlZFZhbHVlVmlhQ29uZmlnKSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMuX2NhbGxTdHJpbmdPckZ1bmN0aW9uKGN1cnJlbnRBdHRyLnNldHRlciwgdmFsdWUpO1xuXHRcdH1cblxuXHRcdC8vIEZpbmFsbHksIHNldCB0aGUgdmFsdWUgYXMgaW5pdGlhbCB2YWx1ZSB0byB0aGUgc3RvcmFnZSB3aXRoIHZhbHVlcy5cblx0XHR0aGlzLl9fQVRUUlNfX1thdHRyXSA9IHZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVja3MgaWYgYW4gYXR0cmlidXRlIGlzIGluaXRpYWxpemVkLiBBbiBhdHRyaWJ1dGUgaXMgY29uc2lkZXJlZCBhcyBpbml0aWFsaXplZFxuXHQgKiB3aGVuIHRoZXJlIGlzIGFuIG93biBwcm9wZXJ0eSB3aXRoIHRoaXMgbmFtZSBpbiB0aGUgbG9jYWwgY29sbGVjdGlvbiBvZiBhdHRyaWJ1dGUgdmFsdWVzXG5cdCAqIGZvciB0aGUgY3VycmVudCBpbnN0YW5jZS5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBBdHRyaWJ1dGVcblx0ICogQG1ldGhvZCBfaXNJbml0aWFsaXplZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBUaGUgYXR0cmlidXRlIHdoaWNoIHNob3VsZCBiZSBjaGVja2VkIGlmIGl0IGlzIGluaXRpYWxpemVkLlxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgYXR0cmlidXRlIGhhcyBiZWVuIGluaXRpYWxpemVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuXHRfaXNJbml0aWFsaXplZChhdHRyKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9fQVRUUlNfXywgYXR0cik7XG5cdH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBBdHRyaWJ1dGU7XG4iLCJpbXBvcnQgQXR0cmlidXRlIGZyb20gJy4vYXR0cmlidXRlJztcbmltcG9ydCBMYW5nIGZyb20gJy4vbGFuZyc7XG5pbXBvcnQgZXh0ZW5kIGZyb20gJy4vb29wJztcblxuLyoqXG4gKiBRdWljayBhbmQgZGlydHkgaW1wbCBvZiBCYXNlIGNsYXNzLlxuICpcbiAqIEBjbGFzcyBCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQmFzZShjb25maWcpIHtcblx0QmFzZS5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgY29uZmlnKTtcblxuXHR0aGlzLmluaXQoY29uZmlnKTtcbn1cblxuZXh0ZW5kKEJhc2UsIEF0dHJpYnV0ZSwge1xuXHQvKipcblx0ICogQ2FsbHMgdGhlIGBpbml0aWFsaXplcmAgbWV0aG9kIG9mIGVhY2ggY2xhc3Mgd2hpY2ggZXh0ZW5kcyBCYXNlIHN0YXJ0aW5nIGZyb20gdGhlIHBhcmVudCB0byB0aGUgY2hpbGQuXG5cdCAqIFdpbGwgcGFzcyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgdG8gZWFjaCBpbml0aWFsaXplciBtZXRob2QuXG5cdCAqXG5cdCAqIEBpbnN0YW5jZVxuXHQgKiBAbWVtYmVyb2YgQmFzZVxuXHQgKiBAbWV0aG9kIGluaXRcblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdFxuXHQgKi9cblx0aW5pdChjb25maWcpIHtcblx0XHR0aGlzLl9jYWxsQ2hhaW4oJ2luaXRpYWxpemVyJywgY29uZmlnKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2FsbHMgdGhlIGBkZXN0cnVjdG9yYCBtZXRob2Qgb2YgZWFjaCBjbGFzcyB3aGljaCBleHRlbmRzIEJhc2Ugc3RhcnRpbmcgZnJvbSB0aGUgcGFyZW50IHRvIHRoZSBjaGlsZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCYXNlXG5cdCAqIEBtZXRob2QgZGVzdHJveVxuXHQgKi9cblx0ZGVzdHJveSgpIHtcblx0XHR0aGlzLl9jYWxsQ2hhaW4oJ2Rlc3RydWN0b3InKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2FsbHMgYSBtZXRob2Qgb2YgZWFjaCBjbGFzcywgd2hpY2ggaXMgYmVpbmcgcHJlc2VudCBpbiB0aGUgaGllcmFyY2h5IHN0YXJ0aW5nIGZyb20gcGFyZW50IHRvIHRoZSBjaGlsZC5cblx0ICpcblx0ICogQGluc3RhbmNlXG5cdCAqIEBtZW1iZXJvZiBCYXNlXG5cdCAqIEBtZXRob2QgX2NhbGxDaGFpblxuXHQgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHdpdGggd2hpY2ggdGhlIG1ldGhvZCBzaG91bGQgYmUgaW52b2tlZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gd2F0ICBUaGUgbWV0aG9kLCB3aGljaCBzaG91bGQgYmUgaW52b2tlZFxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfY2FsbENoYWluKHdhdCwgYXJncykge1xuXHRcdGxldCBhcnIgPSBbXTtcblxuXHRcdGxldCBjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuXHRcdHdoaWxlIChjdG9yKSB7XG5cdFx0XHRpZiAoTGFuZy5pc0Z1bmN0aW9uKGN0b3IucHJvdG90eXBlW3dhdF0pKSB7XG5cdFx0XHRcdGFyci5wdXNoKGN0b3IucHJvdG90eXBlW3dhdF0pO1xuXHRcdFx0fVxuXG5cdFx0XHRjdG9yID0gY3Rvci5zdXBlcmNsYXNzID8gY3Rvci5zdXBlcmNsYXNzLmNvbnN0cnVjdG9yIDogbnVsbDtcblx0XHR9XG5cblx0XHRhcnIgPSBhcnIucmV2ZXJzZSgpO1xuXG5cdFx0YXJncyA9IExhbmcuaXNBcnJheShhcmdzKSA/IGFyZ3MgOiBbYXJnc107XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgaXRlbSA9IGFycltpXTtcblxuXHRcdFx0aXRlbS5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHR9XG5cdH0sXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQmFzZTtcbiIsIi8qKlxuICogUHJvdmlkZXMgY29yZSBsYW5ndWFnZSB1dGlsaXRpZXMuXG4gKlxuICogQGNsYXNzIExhbmdcbiAqL1xuY29uc3QgTGFuZyA9IHtcblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gYXJyYXkuXG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBMYW5nXG5cdCAqIEBtZXRob2QgaXNBcnJheVxuXHQgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY2hlY2tlZC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGFuIGFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdGlzQXJyYXkodmFsdWUpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBib29sZWFuLlxuXHQgKlxuXHQgKiBAbWVtYmVyb2YgTGFuZ1xuXHQgKiBAbWV0aG9kIGlzQm9vbGVhblxuXHQgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY2hlY2tlZC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGJvb2xlYW4sIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0aXNCb29sZWFuKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBMYW5nXG5cdCAqIEBtZXRob2QgaXNGdW5jdGlvblxuXHQgKiBAcGFyYW0ge0FueX0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIGhhdmUgdG8gYmUgY2hlY2tlZC5cblx0ICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0aXNGdW5jdGlvbih2YWx1ZSkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgTlVMTC5cblx0ICpcblx0ICogQG1lbWJlcm9mIExhbmdcblx0ICogQG1ldGhvZCBpc051bGxcblx0ICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNoZWNrZWQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBOVUxMLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqIEBzdGF0aWNcblx0ICovXG5cdGlzTnVsbCh2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBudW1iZXIuXG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBMYW5nXG5cdCAqIEBtZXRob2QgaXNOdW1iZXJcblx0ICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNoZWNrZWQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBudW1iZXIsIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0aXNOdW1iZXIodmFsdWUpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gb2JqZWN0XG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBMYW5nXG5cdCAqIEBtZXRob2QgaXNPYmplY3Rcblx0ICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNoZWNrZWQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhbiBvYmplY3QsIGZhbHNlIG90aGVyd2lzZS5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0aXNPYmplY3QodmFsdWUpIHtcblx0XHRjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cblx0XHRyZXR1cm4gdmFsdWUgJiYgKHZhbHVlVHlwZSA9PT0gJ29iamVjdCcgfHwgTGFuZy5pc0Z1bmN0aW9uKHZhbHVlKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgYSBzdHJpbmcuXG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBMYW5nXG5cdCAqIEBtZXRob2QgaXNTdHJpbmdcblx0ICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNoZWNrZWQuXG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIHN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRpc1N0cmluZyh2YWx1ZSkge1xuXHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGRzIGFsbCBwcm9wZXJ0aWVzIGZyb20gdGhlIHN1cHBsaWVyIHRvIHRoZSByZWNlaXZlci5cblx0ICogVGhlIGZ1bmN0aW9uIHdpbGwgYWRkIGFsbCBwcm9wZXJ0aWVzLCBub3Qgb25seSB0aGVzZSBvd25lZCBieSB0aGUgc3VwcGxpZXIuXG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBMYW5nXG5cdCAqIEBtZXRob2QgbWl4XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByZWNlaXZlciBUaGUgb2JqZWN0IHdoaWNoIHdpbGwgcmVjZWl2ZSBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gc3VwcGxpZXIgVGhlIG9iamVjdCB3aGljaCBwcm92aWRlcyBwcm9wZXJ0aWVzLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBtb2RpZmllZCByZWNlaXZlci5cblx0ICogQHN0YXRpY1xuXHQgKi9cblx0bWl4KHJlY2VpdmVyLCBzdXBwbGllcikge1xuXHRcdGNvbnN0IGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuXHRcdGZvciAoY29uc3Qga2V5IGluIHN1cHBsaWVyKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzdXBwbGllciwga2V5KSkge1xuXHRcdFx0XHRyZWNlaXZlcltrZXldID0gc3VwcGxpZXJba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHZhbHVlIHRvIEludGVnZXIuXG5cdCAqXG5cdCAqIEBtZW1iZXJvZiBMYW5nXG5cdCAqIEBtZXRob2QgdG9JbnRcblx0ICogQHBhcmFtIHtBbnl9IHZhbHVlIFRoZSB2YWx1ZSB3aGljaCBoYXZlIHRvIGJlIGNvbnZlcnRlZCB0byBJbnRlZ2VyLlxuXHQgKiBAcmV0dXJuIHtJbnRlZ2VyfSBUaGUgY29udmVydGVkIHZhbHVlLlxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHR0b0ludCh2YWx1ZSkge1xuXHRcdHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuXHR9LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgTGFuZztcbiIsImltcG9ydCBMYW5nIGZyb20gJy4vbGFuZyc7XG5cbi8qKlxuICogU2V0cyB0aGUgcHJvdG90eXBlLCBjb25zdHJ1Y3RvciBhbmQgc3VwZXJjbGFzcyBwcm9wZXJ0aWVzIHRvIHN1cHBvcnQgYW4gaW5oZXJpdGFuY2Ugc3RyYXRlZ3lcbiAqIHRoYXQgY2FuIGNoYWluIGNvbnN0cnVjdG9ycyBhbmQgbWV0aG9kcy4gU3RhdGljIG1lbWJlcnMgd2lsbCBub3QgYmUgaW5oZXJpdGVkLlxuICpcbiAqIEBtZW1iZXJvZiBPT1BcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWNlaXZlciBUaGUgY2xhc3Mgd2hpY2ggd2lsbCBleHRlbmQgYW5vdGhlciBjbGFzcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN1cHBsaWVyIFRoZSBjbGFzcyB3aGljaCB3aWxsIHByb3ZpZGUgdGhlIHByb3BlcnRpZXMgdGhlIGNoaWxkIGNsYXNzLlxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvUHJvcHMgUHJvdG90eXBlIHByb3BlcnRpZXMgdG8gYWRkL292ZXJyaWRlLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRpY1Byb3BzIFN0YXRpYyBwcm9wZXJ0aWVzIHRvIGFkZC9vdmVyd3JpdGUuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGV4dGVuZGVkIGNsYXNzLlxuICogQHN0YXRpY1xuICovXG5jb25zdCBleHRlbmQgPSBmdW5jdGlvbihyZWNlaXZlciwgc3VwcGxpZXIsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG5cdGlmICghc3VwcGxpZXIgfHwgIXJlY2VpdmVyKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdleHRlbmQgZmFpbGVkLCB2ZXJpZnkgZGVwZW5kZW5jaWVzJyk7XG5cdH1cblxuXHRjb25zdCBzdXBwbGllclByb3RvID0gc3VwcGxpZXIucHJvdG90eXBlO1xuXG5cdGNvbnN0IHJlY2VpdmVyUHJvdG8gPSBPYmplY3QuY3JlYXRlKHN1cHBsaWVyUHJvdG8pO1xuXHRyZWNlaXZlci5wcm90b3R5cGUgPSByZWNlaXZlclByb3RvO1xuXG5cdHJlY2VpdmVyUHJvdG8uY29uc3RydWN0b3IgPSByZWNlaXZlcjtcblx0cmVjZWl2ZXIuc3VwZXJjbGFzcyA9IHN1cHBsaWVyUHJvdG87XG5cblx0Ly8gYXNzaWduIGNvbnN0cnVjdG9yIHByb3BlcnR5XG5cdGlmIChcblx0XHRzdXBwbGllciAhPT0gT2JqZWN0ICYmXG5cdFx0c3VwcGxpZXJQcm90by5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvclxuXHQpIHtcblx0XHRzdXBwbGllclByb3RvLmNvbnN0cnVjdG9yID0gc3VwcGxpZXI7XG5cdH1cblxuXHQvLyBhZGQgcHJvdG90eXBlIG92ZXJyaWRlc1xuXHRpZiAocHJvdG9Qcm9wcykge1xuXHRcdExhbmcubWl4KHJlY2VpdmVyUHJvdG8sIHByb3RvUHJvcHMpO1xuXHR9XG5cblx0Ly8gYWRkIG9iamVjdCBvdmVycmlkZXNcblx0aWYgKHN0YXRpY1Byb3BzKSB7XG5cdFx0TGFuZy5taXgocmVjZWl2ZXIsIHN0YXRpY1Byb3BzKTtcblx0fVxuXG5cdHJldHVybiByZWNlaXZlcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGV4dGVuZDtcbiIsImNsYXNzIERyYWdFdmVudCB7XG5cdGNvbnN0cnVjdG9yKHdpbmRvdywgZG9jdW1lbnQpIHtcblx0XHR0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG5cdFx0dGhpcy53aW5kb3cgPSB3aW5kb3c7XG5cblx0XHR0aGlzLmV2ZW50cyA9IHtcblx0XHRcdGtleWRvd246IHRoaXMua2V5ZG93bi5iaW5kKHRoaXMpLFxuXHRcdFx0bW91c2Vtb3ZlOiB0aGlzLm1vdXNlbW92ZS5iaW5kKHRoaXMpLFxuXHRcdFx0bW91c2V1cDogdGhpcy5tb3VzZXVwLmJpbmQodGhpcyksXG5cdFx0fTtcblx0fVxuXG5cdHN0YXJ0KGV2ZW50KSB7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuXHRcdHRoaXMudGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0dGhpcy5jbGFzc05hbWUgPSB0aGlzLnRhcmdldC5jbGFzc05hbWU7XG5cblx0XHR0aGlzLnN0YXJ0UG9zID0ge1xuXHRcdFx0eDogZXZlbnQuY2xpZW50WCxcblx0XHRcdHk6IGV2ZW50LmNsaWVudFksXG5cdFx0fTtcblxuXHRcdHRoaXMudXBkYXRlKGV2ZW50KTtcblxuXHRcdHRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuZXZlbnRzLmtleWRvd24sIGZhbHNlKTtcblx0XHR0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG5cdFx0XHQnbW91c2Vtb3ZlJyxcblx0XHRcdHRoaXMuZXZlbnRzLm1vdXNlbW92ZSxcblx0XHRcdGZhbHNlXG5cdFx0KTtcblx0XHR0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmV2ZW50cy5tb3VzZXVwLCBmYWxzZSk7XG5cblx0XHR0aGlzLmRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChgZHJhZ2dpbmctJHt0aGlzLmNsYXNzTmFtZX1gKTtcblxuXHRcdGlmICh0eXBlb2YgdGhpcy5vblN0YXJ0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLm9uU3RhcnQoKTtcblx0XHR9XG5cdH1cblxuXHR1cGRhdGUoZXZlbnQpIHtcblx0XHR0aGlzLmN1cnJlbnRQb3MgPSB7XG5cdFx0XHR4OiBldmVudC5jbGllbnRYLFxuXHRcdFx0eTogZXZlbnQuY2xpZW50WSxcblx0XHR9O1xuXG5cdFx0dGhpcy5kZWx0YSA9IHtcblx0XHRcdHg6IGV2ZW50LmNsaWVudFggLSB0aGlzLnN0YXJ0UG9zLngsXG5cdFx0XHR5OiBldmVudC5jbGllbnRZIC0gdGhpcy5zdGFydFBvcy55LFxuXHRcdH07XG5cblx0XHR0aGlzLmtleXMgPSB7XG5cdFx0XHRhbHQ6IGV2ZW50LmFsdEtleSxcblx0XHRcdGN0cmw6IGV2ZW50LmN0cmxLZXksXG5cdFx0XHRzaGlmdDogZXZlbnQuc2hpZnRLZXksXG5cdFx0fTtcblx0fVxuXG5cdG1vdXNlbW92ZShldmVudCkge1xuXHRcdHRoaXMudXBkYXRlKGV2ZW50KTtcblxuXHRcdGlmICh0eXBlb2YgdGhpcy5vbkRyYWcgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRoaXMub25EcmFnKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGV2ZW50LndoaWNoID09PSAwKSB7XG5cdFx0XHR0aGlzLm1vdXNldXAoZXZlbnQpO1xuXHRcdH1cblx0fVxuXG5cdGtleWRvd24oZXZlbnQpIHtcblx0XHRpZiAoZXZlbnQua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdHRoaXMucmVsZWFzZSgpO1xuXHRcdH1cblx0fVxuXG5cdG1vdXNldXAoZXZlbnQpIHtcblx0XHR0aGlzLnVwZGF0ZShldmVudCk7XG5cblx0XHR0aGlzLnJlbGVhc2UoKTtcblxuXHRcdGlmICh0eXBlb2YgdGhpcy5vbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR0aGlzLm9uQ29tcGxldGUoKTtcblx0XHR9XG5cdH1cblxuXHRyZWxlYXNlKCkge1xuXHRcdHRoaXMuZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKGBkcmFnZ2luZy0ke3RoaXMuY2xhc3NOYW1lfWApO1xuXG5cdFx0dGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuXHRcdFx0J2tleWRvd24nLFxuXHRcdFx0dGhpcy5ldmVudHMua2V5ZG93bixcblx0XHRcdGZhbHNlXG5cdFx0KTtcblx0XHR0aGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG5cdFx0XHQnbW91c2Vtb3ZlJyxcblx0XHRcdHRoaXMuZXZlbnRzLm1vdXNlbW92ZSxcblx0XHRcdGZhbHNlXG5cdFx0KTtcblx0XHR0aGlzLmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXG5cdFx0XHQnbW91c2V1cCcsXG5cdFx0XHR0aGlzLmV2ZW50cy5tb3VzZXVwLFxuXHRcdFx0ZmFsc2Vcblx0XHQpO1xuXG5cdFx0aWYgKHR5cGVvZiB0aGlzLm9uUmVsZWFzZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0dGhpcy5vblJlbGVhc2UoKTtcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IHtEcmFnRXZlbnR9O1xuZXhwb3J0IGRlZmF1bHQgRHJhZ0V2ZW50O1xuIiwiaW1wb3J0IERyYWdFdmVudCBmcm9tICcuL0RyYWdFdmVudC5lcyc7XG5cbmNvbnN0IElNQUdFX0hBTkRMRVMgPSBbJ3RsJywgJ3RyJywgJ2JsJywgJ2JyJ107XG5cbmNvbnN0IFBPU0lUSU9OX0VMRU1FTlRfRk4gPSB7XG5cdGJsKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcblx0XHRwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCAtMyArIGxlZnQsIGJveC5oZWlnaHQgLSA0ICsgdG9wKTtcblx0fSxcblx0YnIoaGFuZGxlLCBsZWZ0LCB0b3AsIGJveCkge1xuXHRcdHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIGJveC53aWR0aCAtIDQgKyBsZWZ0LCBib3guaGVpZ2h0IC0gNCArIHRvcCk7XG5cdH0sXG5cdHJtKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcblx0XHRwb3NpdGlvbkVsZW1lbnQoXG5cdFx0XHRoYW5kbGUsXG5cdFx0XHRib3gud2lkdGggLSA0ICsgbGVmdCxcblx0XHRcdE1hdGgucm91bmQoYm94LmhlaWdodCAvIDIpIC0gMyArIHRvcFxuXHRcdCk7XG5cdH0sXG5cdHRsKGhhbmRsZSwgbGVmdCwgdG9wLCBfYm94KSB7XG5cdFx0cG9zaXRpb25FbGVtZW50KGhhbmRsZSwgbGVmdCAtIDMsIHRvcCAtIDMpO1xuXHR9LFxuXHR0cihoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG5cdFx0cG9zaXRpb25FbGVtZW50KGhhbmRsZSwgYm94LndpZHRoIC0gNCArIGxlZnQsIC0zICsgdG9wKTtcblx0fSxcbn07XG5cbmNvbnN0IHBvc2l0aW9uRWxlbWVudCA9IChlbCwgbGVmdCwgdG9wKSA9PiB7XG5cdGVsLnN0eWxlLmxlZnQgPSBgJHtsZWZ0fXB4YDtcblx0ZWwuc3R5bGUudG9wID0gYCR7dG9wfXB4YDtcbn07XG5cbmNvbnN0IGdldEJvdW5kaW5nQm94ID0gKHdpbmRvdywgZWwpID0+IHtcblx0Y29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdHJldHVybiB7XG5cdFx0aGVpZ2h0OiByZWN0LmhlaWdodCxcblx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQsXG5cdFx0dG9wOiByZWN0LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCxcblx0XHR3aWR0aDogcmVjdC53aWR0aCxcblx0fTtcbn07XG5cbmNsYXNzIFJlc2l6ZXIge1xuXHRjb25zdHJ1Y3RvcihlZGl0b3IsIGNmZyA9IHt9KSB7XG5cdFx0dGhpcy5jZmcgPSBjZmc7XG5cdFx0dGhpcy5lZGl0b3IgPSBlZGl0b3I7XG5cblx0XHR0aGlzLmRvY3VtZW50ID0gZWRpdG9yLmRvY3VtZW50ID8gZWRpdG9yLmRvY3VtZW50LiQgOiBkb2N1bWVudDtcblx0XHR0aGlzLndpbmRvdyA9IGVkaXRvci53aW5kb3cgPyBlZGl0b3Iud2luZG93LiQgOiB3aW5kb3c7XG5cblx0XHR0aGlzLmJveCA9IG51bGw7XG5cdFx0dGhpcy5jb250YWluZXIgPSBudWxsO1xuXHRcdHRoaXMuaGFuZGxlcyA9IHt9O1xuXHRcdHRoaXMucHJldmlldyA9IG51bGw7XG5cdFx0dGhpcy5wcmV2aWV3Qm94ID0gbnVsbDtcblx0XHR0aGlzLnJlc3VsdCA9IG51bGw7XG5cblx0XHR0aGlzLmluaXQoKTtcblx0fVxuXG5cdGluaXQoKSB7XG5cdFx0dGhpcy5jb250YWluZXIgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdHRoaXMuY29udGFpbmVyLmlkID0gJ2NraW1ncnN6JztcblxuXHRcdHRoaXMucHJldmlldyA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG5cdFx0dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5wcmV2aWV3KTtcblxuXHRcdHRoaXMuaGFuZGxlcyA9IHt9O1xuXG5cdFx0SU1BR0VfSEFORExFUy5mb3JFYWNoKGhhbmRsZU5hbWUgPT4ge1xuXHRcdFx0dGhpcy5oYW5kbGVzW2hhbmRsZU5hbWVdID0gdGhpcy5jcmVhdGVIYW5kbGUoaGFuZGxlTmFtZSk7XG5cdFx0fSk7XG5cblx0XHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5oYW5kbGVzKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5oYW5kbGVzW2tleXNbaV1dKTtcblx0XHR9XG5cdH1cblxuXHRjcmVhdGVIYW5kbGUobmFtZSkge1xuXHRcdGNvbnN0IGVsID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJyk7XG5cblx0XHRlbC5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuXG5cdFx0cmV0dXJuIGVsO1xuXHR9XG5cblx0aXNIYW5kbGUoZWwpIHtcblx0XHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5oYW5kbGVzKTtcblxuXHRcdGxldCByZXN1bHQgPSBmYWxzZTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuaGFuZGxlc1trZXlzW2ldXSA9PT0gZWwpIHtcblx0XHRcdFx0cmVzdWx0ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0c2hvdyhlbCkge1xuXHRcdGNvbnN0IHVpTm9kZSA9IHRoaXMuZWRpdG9yLmNvbmZpZy51aU5vZGUgfHwgZG9jdW1lbnQuYm9keTtcblxuXHRcdHRoaXMuZWwgPSBlbDtcblxuXHRcdHRoaXMuYm94ID0gZ2V0Qm91bmRpbmdCb3godGhpcy53aW5kb3csIHRoaXMuZWwpO1xuXG5cdFx0cG9zaXRpb25FbGVtZW50KFxuXHRcdFx0dGhpcy5jb250YWluZXIsXG5cdFx0XHR0aGlzLmJveC5sZWZ0LFxuXHRcdFx0dGhpcy5ib3gudG9wICsgdWlOb2RlLnNjcm9sbFRvcFxuXHRcdCk7XG5cblx0XHR1aU5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO1xuXG5cdFx0dGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdja2ltZ3JzeicpO1xuXG5cdFx0dGhpcy5zaG93SGFuZGxlcygpO1xuXHR9XG5cblx0aGlkZSgpIHtcblx0XHRjb25zdCBlbGVtZW50cyA9IHRoaXMuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2tpbWdyc3onKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGVsZW1lbnRzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2NraW1ncnN6Jyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5oaWRlSGFuZGxlcygpO1xuXG5cdFx0aWYgKHRoaXMuY29udGFpbmVyLnBhcmVudE5vZGUpIHtcblx0XHRcdHRoaXMuY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jb250YWluZXIpO1xuXHRcdH1cblx0fVxuXG5cdGluaXREcmFnKGV2ZW50KSB7XG5cdFx0aWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGRyYWcgPSBuZXcgRHJhZ0V2ZW50KHRoaXMud2luZG93LCB0aGlzLmRvY3VtZW50KTtcblxuXHRcdGRyYWcub25TdGFydCA9ICgpID0+IHtcblx0XHRcdHRoaXMuc2hvd1ByZXZpZXcoKTtcblxuXHRcdFx0dGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcblxuXHRcdFx0dGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKCkubG9jaygpO1xuXHRcdH07XG5cblx0XHRkcmFnLm9uRHJhZyA9ICgpID0+IHtcblx0XHRcdHRoaXMuY2FsY3VsYXRlU2l6ZShkcmFnKTtcblxuXHRcdFx0Y29uc3QgZWRpdG9yQm91bmRzID0gdGhpcy5lZGl0b3IuZWxlbWVudC4kLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0XHRpZiAodGhpcy5wcmV2aWV3Qm94LndpZHRoID49IGVkaXRvckJvdW5kcy53aWR0aCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMudXBkYXRlUHJldmlldygpO1xuXG5cdFx0XHRjb25zdCBib3ggPSB0aGlzLnByZXZpZXdCb3g7XG5cblx0XHRcdHRoaXMudXBkYXRlSGFuZGxlcyhib3gsIGJveC5sZWZ0LCBib3gudG9wKTtcblx0XHR9O1xuXG5cdFx0ZHJhZy5vblJlbGVhc2UgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLmhpZGVQcmV2aWV3KCk7XG5cblx0XHRcdHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuXG5cdFx0XHR0aGlzLmhpZGUoKTtcblxuXHRcdFx0dGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKCkudW5sb2NrKCk7XG5cblx0XHRcdHRoaXMuZWRpdG9yLmZpcmUoJ3NhdmVTbmFwc2hvdCcpO1xuXHRcdH07XG5cblx0XHRkcmFnLm9uQ29tcGxldGUgPSAoKSA9PiB7XG5cdFx0XHR0aGlzLnJlc2l6ZUNvbXBsZXRlKCk7XG5cblx0XHRcdHRoaXMuZWRpdG9yLmZpcmUoJ3NhdmVTbmFwc2hvdCcpO1xuXHRcdH07XG5cblx0XHRkcmFnLnN0YXJ0KGV2ZW50KTtcblx0fVxuXG5cdHVwZGF0ZUhhbmRsZXMoYm94LCBsZWZ0ID0gMCwgdG9wID0gMCkge1xuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmhhbmRsZXMpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRQT1NJVElPTl9FTEVNRU5UX0ZOW2tleXNbaV1dKHRoaXMuaGFuZGxlc1trZXlzW2ldXSwgbGVmdCwgdG9wLCBib3gpO1xuXHRcdH1cblx0fVxuXG5cdHNob3dIYW5kbGVzKCkge1xuXHRcdHRoaXMudXBkYXRlSGFuZGxlcyh0aGlzLmJveCk7XG5cblx0XHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5oYW5kbGVzKTtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5oYW5kbGVzW2tleXNbaV1dLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRcdH1cblx0fVxuXG5cdGhpZGVIYW5kbGVzKCkge1xuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLmhhbmRsZXMpO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLmhhbmRsZXNba2V5c1tpXV0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHR9XG5cdH1cblxuXHRzaG93UHJldmlldygpIHtcblx0XHR0aGlzLmNhbGN1bGF0ZVNpemUoKTtcblxuXHRcdHRoaXMudXBkYXRlUHJldmlldygpO1xuXG5cdFx0dGhpcy5wcmV2aWV3LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHR9XG5cblx0dXBkYXRlUHJldmlldygpIHtcblx0XHRwb3NpdGlvbkVsZW1lbnQoXG5cdFx0XHR0aGlzLnByZXZpZXcsXG5cdFx0XHR0aGlzLnByZXZpZXdCb3gubGVmdCxcblx0XHRcdHRoaXMucHJldmlld0JveC50b3Bcblx0XHQpO1xuXG5cdFx0dGhpcy5wcmV2aWV3LnN0eWxlLmhlaWdodCA9IGAke3RoaXMucHJldmlld0JveC5oZWlnaHR9cHhgO1xuXHRcdHRoaXMucHJldmlldy5zdHlsZS53aWR0aCA9IGAke3RoaXMucHJldmlld0JveC53aWR0aH1weGA7XG5cdH1cblxuXHRoaWRlUHJldmlldygpIHtcblx0XHRjb25zdCBib3ggPSBnZXRCb3VuZGluZ0JveCh0aGlzLndpbmRvdywgdGhpcy5wcmV2aWV3KTtcblxuXHRcdHRoaXMucmVzdWx0ID0ge1xuXHRcdFx0aGVpZ2h0OiBib3guaGVpZ2h0LFxuXHRcdFx0d2lkdGg6IGJveC53aWR0aCxcblx0XHR9O1xuXG5cdFx0dGhpcy5wcmV2aWV3LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdH1cblxuXHRjYWxjdWxhdGVTaXplKGRhdGEpIHtcblx0XHR0aGlzLnByZXZpZXdCb3ggPSB7XG5cdFx0XHRoZWlnaHQ6IHRoaXMuYm94LmhlaWdodCxcblx0XHRcdGxlZnQ6IDAsXG5cdFx0XHR0b3A6IDAsXG5cdFx0XHR3aWR0aDogdGhpcy5ib3gud2lkdGgsXG5cdFx0fTtcblxuXHRcdGlmICghZGF0YSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNsYXNzTmFtZSA9IGRhdGEudGFyZ2V0LmNsYXNzTmFtZTtcblxuXHRcdGlmIChjbGFzc05hbWUuaW5kZXhPZigncicpID49IDApIHtcblx0XHRcdHRoaXMucHJldmlld0JveC53aWR0aCA9IE1hdGgubWF4KDMyLCB0aGlzLmJveC53aWR0aCArIGRhdGEuZGVsdGEueCk7XG5cdFx0fVxuXG5cdFx0aWYgKGNsYXNzTmFtZS5pbmRleE9mKCdiJykgPj0gMCkge1xuXHRcdFx0dGhpcy5wcmV2aWV3Qm94LmhlaWdodCA9IE1hdGgubWF4KFxuXHRcdFx0XHQzMixcblx0XHRcdFx0dGhpcy5ib3guaGVpZ2h0ICsgZGF0YS5kZWx0YS55XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChjbGFzc05hbWUuaW5kZXhPZignbCcpID49IDApIHtcblx0XHRcdHRoaXMucHJldmlld0JveC53aWR0aCA9IE1hdGgubWF4KDMyLCB0aGlzLmJveC53aWR0aCAtIGRhdGEuZGVsdGEueCk7XG5cdFx0fVxuXG5cdFx0aWYgKGNsYXNzTmFtZS5pbmRleE9mKCd0JykgPj0gMCkge1xuXHRcdFx0dGhpcy5wcmV2aWV3Qm94LmhlaWdodCA9IE1hdGgubWF4KFxuXHRcdFx0XHQzMixcblx0XHRcdFx0dGhpcy5ib3guaGVpZ2h0IC0gZGF0YS5kZWx0YS55XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChjbGFzc05hbWUuaW5kZXhPZignbScpIDwgMCAmJiAhZGF0YS5rZXlzLnNoaWZ0KSB7XG5cdFx0XHRjb25zdCByYXRpbyA9IHRoaXMuYm94LndpZHRoIC8gdGhpcy5ib3guaGVpZ2h0O1xuXG5cdFx0XHRpZiAodGhpcy5wcmV2aWV3Qm94LndpZHRoIC8gdGhpcy5wcmV2aWV3Qm94LmhlaWdodCA+IHJhdGlvKSB7XG5cdFx0XHRcdHRoaXMucHJldmlld0JveC5oZWlnaHQgPSBNYXRoLnJvdW5kKFxuXHRcdFx0XHRcdHRoaXMucHJldmlld0JveC53aWR0aCAvIHJhdGlvXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnByZXZpZXdCb3gud2lkdGggPSBNYXRoLnJvdW5kKFxuXHRcdFx0XHRcdHRoaXMucHJldmlld0JveC5oZWlnaHQgKiByYXRpb1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChjbGFzc05hbWUuaW5kZXhPZignbCcpID49IDApIHtcblx0XHRcdHRoaXMucHJldmlld0JveC5sZWZ0ID0gdGhpcy5ib3gud2lkdGggLSB0aGlzLnByZXZpZXdCb3gud2lkdGg7XG5cdFx0fVxuXG5cdFx0aWYgKGNsYXNzTmFtZS5pbmRleE9mKCd0JykgPj0gMCkge1xuXHRcdFx0dGhpcy5wcmV2aWV3Qm94LnRvcCA9IHRoaXMuYm94LmhlaWdodCAtIHRoaXMucHJldmlld0JveC5oZWlnaHQ7XG5cdFx0fVxuXHR9XG5cblx0cmVzaXplQ29tcGxldGUoKSB7XG5cdFx0dGhpcy5jZmcub25Db21wbGV0ZSh0aGlzLmVsLCB0aGlzLnJlc3VsdC53aWR0aCwgdGhpcy5yZXN1bHQuaGVpZ2h0KTtcblx0fVxufVxuXG5leHBvcnQge1Jlc2l6ZXJ9O1xuZXhwb3J0IGRlZmF1bHQgUmVzaXplcjtcbiIsImNvbnN0IGlzSUUgPSBDS0VESVRPUi5lbnYuaWU7XG5cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2FkZGltYWdlcycpKSB7XG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gd2hpY2ggYWxsb3dzIERyYWcmRHJvcCBvZiBpbWFnZXMgZGlyZWN0bHkgaW50byB0aGUgZWRpdGFibGUgYXJlYS4gVGhlIGltYWdlIHdpbGwgYmUgZW5jb2RlZFxuXHQgKiBhcyBEYXRhIFVSSS4gQW4gZXZlbnQgYGJlZm9yZUltYWdlQWRkYCB3aWxsIGJlIGZpcmVkIHdpdGggdGhlIGxpc3Qgb2YgZHJvcHBlZCBpbWFnZXMuIElmIGFueSBvZiB0aGUgbGlzdGVuZXJzXG5cdCAqIHJldHVybnMgYGZhbHNlYCBvciBjYW5jZWxzIHRoZSBldmVudCwgdGhlIGltYWdlcyB3b24ndCBiZSBhZGRlZCB0byB0aGUgY29udGVudC4gT3RoZXJ3aXNlLFxuXHQgKiBhbiBldmVudCBgaW1hZ2VBZGRgIHdpbGwgYmUgZmlyZWQgd2l0aCB0aGUgaW5zZXJ0ZWQgZWxlbWVudCBpbnRvIHRoZSBlZGl0YWJsZSBhcmVhLlxuXHQgKlxuXHQgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcblx0ICovXG5cblx0LyoqXG5cdCAqIEZpcmVkIGJlZm9yZSBhZGRpbmcgaW1hZ2VzIHRvIHRoZSBlZGl0b3IuXG5cdCAqXG5cdCAqIEBldmVudCBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcyNiZWZvcmVJbWFnZUFkZFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGltYWdlRmlsZXMgQXJyYXkgb2YgaW1hZ2UgZmlsZXNcblx0ICovXG5cblx0LyoqXG5cdCAqIEZpcmVkIHdoZW4gYW4gaW1hZ2UgaXMgYmVpbmcgYWRkZWQgdG8gdGhlIGVkaXRvciBzdWNjZXNzZnVsbHkuXG5cdCAqXG5cdCAqIEBldmVudCBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcyNpbWFnZUFkZFxuXHQgKiBAaW5zdGFuY2Vcblx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGVsIFRoZSBjcmVhdGVkIGltYWdlIHdpdGggc3JjIGFzIERhdGEgVVJJXG5cdCAqIEBwYXJhbSB7RmlsZX0gZmlsZSBUaGUgaW1hZ2UgZmlsZVxuXHQgKi9cblxuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfYWRkaW1hZ2VzJywge1xuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBwbHVnaW4sIHBhcnQgb2YgQ0tFZGl0b3IgcGx1Z2luIGxpZmVjeWNsZS5cblx0XHQgKiBUaGUgZnVuY3Rpb24gcmVnaXN0ZXJzIGEgJ2RyYWdlbnRlcicsICdkcmFnb3ZlcicsICdkcm9wJyBhbmQgYHBhc3RlYCBldmVudHMgb24gdGhlIGVkaXRpbmcgYXJlYS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuXHRcdCAqIEBtZXRob2QgaW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICovXG5cdFx0aW5pdChlZGl0b3IpIHtcblx0XHRcdGVkaXRvci5vbmNlKFxuXHRcdFx0XHQnY29udGVudERvbScsXG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0XHRcdGVkaXRhYmxlLFxuXHRcdFx0XHRcdFx0J2RyYWdlbnRlcicsXG5cdFx0XHRcdFx0XHR0aGlzLl9vbkRyYWdFbnRlcixcblx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGVkaXRvcixcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0ZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoXG5cdFx0XHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0XHRcdCdkcmFnb3ZlcicsXG5cdFx0XHRcdFx0XHR0aGlzLl9vbkRyYWdPdmVyLFxuXHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0ZWRpdG9yLFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0XHRcdGVkaXRhYmxlLFxuXHRcdFx0XHRcdFx0J2Ryb3AnLFxuXHRcdFx0XHRcdFx0dGhpcy5fb25EcmFnRHJvcCxcblx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGVkaXRvcixcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0ZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoXG5cdFx0XHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0XHRcdCdwYXN0ZScsXG5cdFx0XHRcdFx0XHR0aGlzLl9vblBhc3RlLFxuXHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0ZWRpdG9yLFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0uYmluZCh0aGlzKVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWNjZXB0cyBhbiBhcnJheSBvZiBkcm9wcGVkIGZpbGVzIHRvIHRoZSBlZGl0b3IuIFRoZW4sIGl0IGZpbHRlcnMgdGhlIGltYWdlcyBhbmQgc2VuZHMgdGhlbSBmb3IgZnVydGhlclxuXHRcdCAqIHByb2Nlc3NpbmcgdG8ge3sjY3Jvc3NMaW5rIFwiQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXMvX3Byb2Nlc3NGaWxlOm1ldGhvZFwifX17ey9jcm9zc0xpbmt9fVxuXHRcdCAqXG5cdFx0ICogQGZpcmVzIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzI2JlZm9yZUltYWdlQWRkXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG5cdFx0ICogQG1ldGhvZCBfaGFuZGxlRmlsZXNcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBmaWxlcyBBcnJheSBvZiBkcm9wcGVkIGZpbGVzLiBPbmx5IHRoZSBpbWFnZXMgZnJvbSB0aGlzIGxpc3Qgd2lsbCBiZSBwcm9jZXNzZWQuXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2Vcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X2hhbmRsZUZpbGVzKGZpbGVzLCBlZGl0b3IpIHtcblx0XHRcdGxldCBmaWxlO1xuXHRcdFx0bGV0IGk7XG5cblx0XHRcdGNvbnN0IGltYWdlRmlsZXMgPSBbXTtcblxuXHRcdFx0Zm9yIChpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGZpbGUgPSBmaWxlc1tpXTtcblxuXHRcdFx0XHRpZiAoZmlsZS50eXBlLmluZGV4T2YoJ2ltYWdlJykgPT09IDApIHtcblx0XHRcdFx0XHRpbWFnZUZpbGVzLnB1c2goZmlsZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gZWRpdG9yLmZpcmUoJ2JlZm9yZUltYWdlQWRkJywge1xuXHRcdFx0XHRpbWFnZUZpbGVzLFxuXHRcdFx0fSk7XG5cblx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGltYWdlRmlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRmaWxlID0gaW1hZ2VGaWxlc1tpXTtcblxuXHRcdFx0XHRcdHRoaXMuX3Byb2Nlc3NGaWxlKGZpbGUsIGVkaXRvcik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVzIGRyYWcgZHJvcCBldmVudC4gVGhlIGZ1bmN0aW9uIHdpbGwgY3JlYXRlIGEgc2VsZWN0aW9uIGZyb20gdGhlIGN1cnJlbnRcblx0XHQgKiBwb2ludCBhbmQgd2lsbCBzZW5kIGEgbGlzdCBvZiBmaWxlcyB0byBiZSBwcm9jZXNzZWQgdG9cblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcy9faGFuZGxlRmlsZXM6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319IG1ldGhvZC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuXHRcdCAqIEBtZXRob2QgX29uRHJhZ0Ryb3Bcblx0XHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5ldmVudH0gZXZlbnQgZHJhZ2Ryb3AgZXZlbnQsIGFzIHJlY2VpdmVkIG5hdGl2ZWx5IGZyb20gQ0tFZGl0b3Jcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X29uRHJhZ0Ryb3AoZXZlbnQpIHtcblx0XHRcdGNvbnN0IG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS4kO1xuXG5cdFx0XHRjb25zdCB0cmFuc2ZlckZpbGVzID0gbmF0aXZlRXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzO1xuXG5cdFx0XHRpZiAodHJhbnNmZXJGaWxlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdG5ldyBDS0VESVRPUi5kb20uZXZlbnQobmF0aXZlRXZlbnQpLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0Y29uc3QgZWRpdG9yID0gZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcjtcblxuXHRcdFx0XHRldmVudC5saXN0ZW5lckRhdGEuZWRpdG9yLmNyZWF0ZVNlbGVjdGlvbkZyb21Qb2ludChcblx0XHRcdFx0XHRuYXRpdmVFdmVudC5jbGllbnRYLFxuXHRcdFx0XHRcdG5hdGl2ZUV2ZW50LmNsaWVudFlcblx0XHRcdFx0KTtcblxuXHRcdFx0XHR0aGlzLl9oYW5kbGVGaWxlcyh0cmFuc2ZlckZpbGVzLCBlZGl0b3IpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBIYW5kbGVzIGRyYWcgZW50ZXIgZXZlbnQuIEluIGNhc2Ugb2YgSUUsIHRoaXMgZnVuY3Rpb24gd2lsbCBwcmV2ZW50IHRoZSBldmVudC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuXHRcdCAqIEBtZXRob2QgX29uRHJhZ0VudGVyXG5cdFx0ICogQHBhcmFtIHtET00gZXZlbnR9IGV2ZW50IGRyYWdlbnRlciBldmVudCwgYXMgcmVjZWl2ZWQgbmF0aXZlbHkgZnJvbSBDS0VkaXRvclxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRfb25EcmFnRW50ZXIoZXZlbnQpIHtcblx0XHRcdGlmIChpc0lFKSB7XG5cdFx0XHRcdHRoaXMuX3ByZXZlbnRFdmVudChldmVudCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEhhbmRsZXMgZHJhZyBvdmVyIGV2ZW50LiBJbiBjYXNlIG9mIElFLCB0aGlzIGZ1bmN0aW9uIHdpbGwgcHJldmVudCB0aGUgZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hZGRpbWFnZXNcblx0XHQgKiBAbWV0aG9kIF9vbkRyYWdPdmVyXG5cdFx0ICogQHBhcmFtIHtET00gZXZlbnR9IGV2ZW50IGRyYWdvdmVyIGV2ZW50LCBhcyByZWNlaXZlZCBuYXRpdmVseSBmcm9tIENLRWRpdG9yXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9vbkRyYWdPdmVyKGV2ZW50KSB7XG5cdFx0XHRpZiAoaXNJRSkge1xuXHRcdFx0XHR0aGlzLl9wcmV2ZW50RXZlbnQoZXZlbnQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDaGVja3MgaWYgdGhlIHBhc3RlZCBkYXRhIGlzIGltYWdlIGFuZCBwYXNzZXMgaXQgdG9cblx0XHQgKiB7eyNjcm9zc0xpbmsgXCJDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcy9fcHJvY2Vzc0ZpbGU6bWV0aG9kXCJ9fXt7L2Nyb3NzTGlua319IGZvciBwcm9jZXNzaW5nLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYWRkaW1hZ2VzXG5cdFx0ICogQG1ldGhvZCBfb25QYXN0ZVxuXHRcdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmV2ZW50fSBldmVudCBBIGBwYXN0ZWAgZXZlbnQsIGFzIHJlY2VpdmVkIG5hdGl2ZWx5IGZyb20gQ0tFZGl0b3Jcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X29uUGFzdGUoZXZlbnQpIHtcblx0XHRcdGlmIChcblx0XHRcdFx0ZXZlbnQuZGF0YSAmJlxuXHRcdFx0XHRldmVudC5kYXRhLiQgJiZcblx0XHRcdFx0ZXZlbnQuZGF0YS4kLmNsaXBib2FyZERhdGEgJiZcblx0XHRcdFx0ZXZlbnQuZGF0YS4kLmNsaXBib2FyZERhdGEuaXRlbXMgJiZcblx0XHRcdFx0ZXZlbnQuZGF0YS4kLmNsaXBib2FyZERhdGEuaXRlbXMubGVuZ3RoID4gMFxuXHRcdFx0KSB7XG5cdFx0XHRcdGNvbnN0IHBhc3RlZERhdGEgPSBldmVudC5kYXRhLiQuY2xpcGJvYXJkRGF0YS5pdGVtc1swXTtcblxuXHRcdFx0XHRpZiAocGFzdGVkRGF0YS50eXBlLmluZGV4T2YoJ2ltYWdlJykgPT09IDApIHtcblx0XHRcdFx0XHRjb25zdCBpbWFnZUZpbGUgPSBwYXN0ZWREYXRhLmdldEFzRmlsZSgpO1xuXG5cdFx0XHRcdFx0dGhpcy5fcHJvY2Vzc0ZpbGUoaW1hZ2VGaWxlLCBldmVudC5saXN0ZW5lckRhdGEuZWRpdG9yKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQcmV2ZW50cyBhIG5hdGl2ZSBldmVudC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuXHRcdCAqIEBtZXRob2QgX3ByZXZlbnRFdmVudFxuXHRcdCAqIEBwYXJhbSB7RE9NIGV2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gYmUgcHJldmVudGVkLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRfcHJldmVudEV2ZW50KGV2ZW50KSB7XG5cdFx0XHRldmVudCA9IG5ldyBDS0VESVRPUi5kb20uZXZlbnQoZXZlbnQuZGF0YS4kKTtcblxuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBQcm9jZXNzZXMgYW4gaW1hZ2UgZmlsZS4gVGhlIGZ1bmN0aW9uIGNyZWF0ZXMgYW4gaW1nIGVsZW1lbnQgYW5kIHNldHMgYXMgc291cmNlXG5cdFx0ICogYSBEYXRhIFVSSSwgdGhlbiBmaXJlcyBhbiAnaW1hZ2VBZGQnIGV2ZW50IHZpYSBDS0VkaXRvcidzIGV2ZW50IHN5c3RlbS5cblx0XHQgKlxuXHRcdCAqIEBmaXJlcyBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlcyNpbWFnZUFkZFxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2FkZGltYWdlc1xuXHRcdCAqIEBtZXRob2QgX3ByZXZlbnRFdmVudFxuXHRcdCAqIEBwYXJhbSB7RE9NIGV2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gYmUgcHJldmVudGVkLlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRfcHJvY2Vzc0ZpbGUoZmlsZSwgZWRpdG9yKSB7XG5cdFx0XHRjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG5cdFx0XHRyZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVuZCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjb25zdCBiaW4gPSByZWFkZXIucmVzdWx0O1xuXG5cdFx0XHRcdGNvbnN0IGVsID0gQ0tFRElUT1IuZG9tLmVsZW1lbnQuY3JlYXRlRnJvbUh0bWwoXG5cdFx0XHRcdFx0JzxpbWcgc3JjPVwiJyArIGJpbiArICdcIj4nXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0ZWRpdG9yLmluc2VydEVsZW1lbnQoZWwpO1xuXG5cdFx0XHRcdGNvbnN0IGltYWdlRGF0YSA9IHtcblx0XHRcdFx0XHRlbCxcblx0XHRcdFx0XHRmaWxlLFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGVkaXRvci5maXJlKCdpbWFnZUFkZCcsIGltYWdlRGF0YSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCJpZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9hdXRvbGluaycpKSB7XG5cdC8vIERpc2FibGVzIHRoZSBhdXRvIFVSTCBkZXRlY3Rpb24gZmVhdHVyZSBpbiBJRSwgdGhlaXIgbGFja3MgZnVuY3Rpb25hbGl0eTpcblx0Ly8gVGhleSBjb252ZXJ0IHRoZSBsaW5rcyBvbmx5IG9uIHNwYWNlLiBXZSBkbyBvbiBzcGFjZSwgY29tbWEsIHNlbWljb2xvbiBhbmQgRW50ZXIuXG5cdGlmICgvTVNJRSAoW147XSopfFRyaWRlbnQuKjsgcnY6KFswLTkuXSspLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG5cdFx0ZG9jdW1lbnQuZXhlY0NvbW1hbmQoJ0F1dG9VcmxEZXRlY3QnLCBmYWxzZSwgZmFsc2UpO1xuXHR9XG5cblx0Y29uc3QgS0VZX0JBQ0sgPSA4O1xuXG5cdGNvbnN0IEtFWV9DT01NQSA9IDE4ODtcblxuXHRjb25zdCBLRVlfRU5URVIgPSAxMztcblxuXHRjb25zdCBLRVlfU0VNSUNPTE9OID0gMTg2O1xuXG5cdGNvbnN0IEtFWV9TUEFDRSA9IDMyO1xuXG5cdGNvbnN0IERFTElNSVRFUlMgPSBbS0VZX0NPTU1BLCBLRVlfRU5URVIsIEtFWV9TRU1JQ09MT04sIEtFWV9TUEFDRV07XG5cblx0Y29uc3QgUkVHRVhfTEFTVF9XT1JEID0gL1teXFxzXSsvZ2ltO1xuXG5cdGNvbnN0IFJFR0VYX1VSTCA9XG5cdFx0JygoKFtBIC0gWmEgLSB6XXsgMywgOX06ICg/OiBcXFxcL1xcXFwvKT8pKD86Wy07OiY9XFxcXCtcXFxcJCxcXFxcd10rQCk/W0EtWmEtejAtOS4tXSt8KGh0dHBzP1xcXFw6XFxcXC9cXFxcL3x3d3cufFstOzomPS5cXFxcK1xcXFwkLFxcXFx3XStAKVtBLVphLXowLTkuLV0rKSgoPzpcXFxcL1tcXFxcK34lXFxcXC8uXFxcXHctX10qKT9cXFxcPz8oPzpbLVxcXFwrPSY7JUAuXFxcXHdfXSopIz8oPzpbXFxcXHddKikpKCguKik6KFxcXFxkKilcXFxcLz8oLiopKT8pJztcblxuXHRjb25zdCBSRUdFWF9FTUFJTCA9IC9bYS16QS1aMC05Ll8tXStAW2EtekEtWjAtOS4tXStcXC5bYS16QS1aXXsyLDR9L2k7XG5cblx0LyoqXG5cdCAqIENLRWRpdG9yIHBsdWdpbiB3aGljaCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlcyBsaW5rcyB3aGVuIHVzZXIgdHlwZXMgdGV4dCB3aGljaCBsb29rcyBsaWtlIFVSTC5cblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfYXV0b2xpbmsnLCB7XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuXHRcdCAqIFRoZSBmdW5jdGlvbiByZWdpc3RlcnMgdGhlIGBrZXl1cGAgZXZlbnQgb24gdGhlIGVkaXRpbmcgYXJlYS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBpbml0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2Vcblx0XHQgKi9cblx0XHRpbml0KGVkaXRvcikge1xuXHRcdFx0ZWRpdG9yLm9uY2UoXG5cdFx0XHRcdCdjb250ZW50RG9tJyxcblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y29uc3QgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuXHRcdFx0XHRcdGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKFxuXHRcdFx0XHRcdFx0ZWRpdGFibGUsXG5cdFx0XHRcdFx0XHQna2V5dXAnLFxuXHRcdFx0XHRcdFx0dGhpcy5fb25LZXlVcCxcblx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGVkaXRvcixcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9LmJpbmQodGhpcylcblx0XHRcdCk7XG5cblx0XHRcdGVkaXRvci5vbihcblx0XHRcdFx0J3Bhc3RlJyxcblx0XHRcdFx0ZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRpZiAoZXZlbnQuZGF0YS5tZXRob2QgPT09ICdwYXN0ZScpIHtcblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0ZXZlbnQuZGF0YS5kYXRhVmFsdWUuaW5kZXhPZignPCcpID4gLTEgfHxcblx0XHRcdFx0XHRcdFx0ZXZlbnQuZGF0YS5kYXRhVmFsdWUuaW5kZXhPZignJmx0OycpID4gLTFcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdFx0ZXZlbnQuZGF0YS5kYXRhVmFsdWUuaW5kZXhPZihcblx0XHRcdFx0XHRcdFx0XHRcdCc8dT48Zm9udCBjb2xvcj1cIidcblx0XHRcdFx0XHRcdFx0XHQpID4gLTFcblx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0ZXZlbnQuZGF0YS5kYXRhVmFsdWUgPSBldmVudC5kYXRhLmRhdGFWYWx1ZS5yZXBsYWNlKFxuXHRcdFx0XHRcdFx0XHRcdFx0Lzx1Pjxmb250IGNvbG9yPVwiIyguKj8pXCI+fDxcXC9mb250PjxcXC91Pi9nLFxuXHRcdFx0XHRcdFx0XHRcdFx0Jydcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgaW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0XHRcdFx0XHRldmVudC5kYXRhLmRhdGFWYWx1ZSA9IGV2ZW50LmRhdGEuZGF0YVZhbHVlLnJlcGxhY2UoXG5cdFx0XHRcdFx0XHRcdFJlZ0V4cChSRUdFWF9VUkwsICdnaW0nKSxcblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24odXJsKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGluc3RhbmNlLl9pc1ZhbGlkVVJMKHVybCkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChpbnN0YW5jZS5faXNWYWxpZEVtYWlsKHVybCkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQnPGEgaHJlZj1cIm1haWx0bzonICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1cmwgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCdcIj4nICtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1cmwgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCc8L2E+J1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQnPGEgaHJlZj1cIicgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVybCArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0J1wiPicgK1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVybCArXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0JzwvYT4nXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fS5iaW5kKHRoaXMpXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXRyaWV2ZXMgdGhlIGxhc3Qgd29yZCBpbnRyb2R1Y2VkIGJ5IHRoZSB1c2VyLiBSZWFkcyBmcm9tIHRoZSBjdXJyZW50XG5cdFx0ICogY2FyZXQgcG9zaXRpb24gYmFja3dhcmRzIHVudGlsIGl0IGZpbmRzIHRoZSBmaXJzdCB3aGl0ZSBzcGFjZS5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBfZ2V0TGFzdFdvcmRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgbGFzdCB3b3JkIGludHJvZHVjZWQgYnkgdXNlclxuXHRcdCAqL1xuXHRcdF9nZXRMYXN0V29yZChlZGl0b3IpIHtcblx0XHRcdGNvbnN0IHJhbmdlID0gZWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFJhbmdlcygpWzBdO1xuXG5cdFx0XHRpZiAoIXJhbmdlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQ7XG5cblx0XHRcdGxldCBwcmV2aW91c1RleHQgPSAnJztcblxuXHRcdFx0Ly8gVGhlIHVzZXIgcHJlc3NlZCBFbnRlciwgc28gd2UgaGF2ZSB0byBsb29rIG9uIHRoZSBwcmV2aW91cyBub2RlXG5cdFx0XHRpZiAodGhpcy5fY3VycmVudEtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuXHRcdFx0XHRsZXQgcHJldmlvdXNOb2RlID0gcmFuZ2Uuc3RhcnRDb250YWluZXIuZ2V0UHJldmlvdXMoKTtcblxuXHRcdFx0XHRsZXQgbGFzdENoaWxkO1xuXG5cdFx0XHRcdGlmIChwcmV2aW91c05vZGUpIHtcblx0XHRcdFx0XHQvLyBJZiBwcmV2aW91cyBub2RlIGlzIGEgU1BBQ0UsIChpdCBkb2VzIG5vdCBoYXZlICdnZXRMYXN0JyBtZXRob2QpLFxuXHRcdFx0XHRcdC8vIGlnbm9yZSBpdCBhbmQgZmluZCB0aGUgcHJldmlvdXMgdGV4dCBub2RlXG5cdFx0XHRcdFx0d2hpbGUgKCFwcmV2aW91c05vZGUuZ2V0TGFzdCkge1xuXHRcdFx0XHRcdFx0cHJldmlvdXNOb2RlID0gcHJldmlvdXNOb2RlLmdldFByZXZpb3VzKCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGFzdENoaWxkID0gcHJldmlvdXNOb2RlLmdldExhc3QoKTtcblxuXHRcdFx0XHRcdC8vIERlcGVuZGluZyBvbiB0aGUgYnJvd3NlciwgdGhlIGxhc3QgY2hpbGQgbm9kZSBtYXkgYmUgYSA8QlI+XG5cdFx0XHRcdFx0Ly8gKHdoaWNoIGRvZXMgbm90IGhhdmUgJ2dldFRleHQnIG1ldGhvZCksXG5cdFx0XHRcdFx0Ly8gc28gaWdub3JlIGl0IGFuZCBmaW5kIHRoZSBwcmV2aW91cyB0ZXh0IG5vZGVcblx0XHRcdFx0XHR3aGlsZSAobGFzdENoaWxkICYmICFsYXN0Q2hpbGQuZ2V0VGV4dCgpKSB7XG5cdFx0XHRcdFx0XHRsYXN0Q2hpbGQgPSBsYXN0Q2hpbGQuZ2V0UHJldmlvdXMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDaGVjayBpZiB0aGUgbGFzdENoaWxkIGlzIGFscmVhZHkgYSBsaW5rXG5cdFx0XHRcdGlmICghKGxhc3RDaGlsZCAmJiBsYXN0Q2hpbGQuJC5ocmVmKSkge1xuXHRcdFx0XHRcdHRoaXMuX3N0YXJ0Q29udGFpbmVyID0gbGFzdENoaWxkO1xuXHRcdFx0XHRcdHByZXZpb3VzVGV4dCA9IGxhc3RDaGlsZCA/IGxhc3RDaGlsZC5nZXRUZXh0KCkgOiAnJztcblx0XHRcdFx0XHR0aGlzLl9vZmZzZXQgPSBwcmV2aW91c1RleHQubGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9zdGFydENvbnRhaW5lciA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuXG5cdFx0XHRcdC8vIExhc3QgY2hhcmFjdGVyIGlzIHRoZSBkZWxpbWl0ZXIsIGlnbm9yZSBpdFxuXHRcdFx0XHRwcmV2aW91c1RleHQgPSB0aGlzLl9zdGFydENvbnRhaW5lclxuXHRcdFx0XHRcdC5nZXRUZXh0KClcblx0XHRcdFx0XHQuc3Vic3RyaW5nKDAsIG9mZnNldCAtIDEpO1xuXG5cdFx0XHRcdHRoaXMuX29mZnNldCA9IG9mZnNldCAtIDE7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBsYXN0V29yZCA9ICcnO1xuXG5cdFx0XHRjb25zdCBtYXRjaCA9IHByZXZpb3VzVGV4dC5tYXRjaChSRUdFWF9MQVNUX1dPUkQpO1xuXG5cdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0bGFzdFdvcmQgPSBtYXRjaC5wb3AoKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxhc3RXb3JkO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDaGVja3MgaWYgdGhlIGdpdmVuIGxpbmsgaXMgYSB2YWxpZCBFbWFpbC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBpc1ZhbGlkRW1haWxcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbGluayBUaGUgZW1haWwgd2Ugd2FudCB0byBrbm93IGlmIGl0IGlzIGEgdmFsaWQgRW1haWxcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBlbWFpbCBpcyBhIHZhbGlkIEVtYWlsLCBmYWxzZSBvdGhlcndpc2Vcblx0XHQgKi9cblx0XHRfaXNWYWxpZEVtYWlsKGVtYWlsKSB7XG5cdFx0XHRyZXR1cm4gUkVHRVhfRU1BSUwudGVzdChlbWFpbCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gbGluayBpcyBhIHZhbGlkIFVSTC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBpc1ZhbGlkVVJMXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd9IGxpbmsgVGhlIGxpbmsgd2Ugd2FudCB0byBrbm93IGlmIGl0IGlzIGEgdmFsaWQgVVJMXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgbGluayBpcyBhIHZhbGlkIFVSTCwgZmFsc2Ugb3RoZXJ3aXNlXG5cdFx0ICovXG5cdFx0X2lzVmFsaWRVUkwobGluaykge1xuXHRcdFx0cmV0dXJuIFJlZ0V4cChSRUdFWF9VUkwsICdpJykudGVzdChsaW5rKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTGlzdGVucyB0byB0aGUgYGtleWRvd25gIGV2ZW50IGFuZCBpZiB0aGUga2V5Y29kZSBpcyBgQmFja3NwYWNlYCwgcmVtb3ZlcyB0aGUgcHJldmlvdXNseVxuXHRcdCAqIGNyZWF0ZWQgbGluay5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBfb25LZXlEb3duXG5cdFx0ICogQHBhcmFtIHtFdmVudEZhY2FkZX0gZXZlbnQgRXZlbnRGYWNhZGUgb2JqZWN0XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9vbktleURvd24oZXZlbnQpIHtcblx0XHRcdGNvbnN0IG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS4kO1xuXG5cdFx0XHRjb25zdCBlZGl0b3IgPSBldmVudC5saXN0ZW5lckRhdGEuZWRpdG9yO1xuXG5cdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRlZGl0YWJsZS5yZW1vdmVMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93bik7XG5cblx0XHRcdGlmIChuYXRpdmVFdmVudC5rZXlDb2RlID09PSBLRVlfQkFDSykge1xuXHRcdFx0XHRldmVudC5jYW5jZWwoKTtcblx0XHRcdFx0ZXZlbnQuZGF0YS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0XHRcdHRoaXMuX3JlbW92ZUxpbmsoZWRpdG9yKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fY2tMaW5rID0gbnVsbDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogTGlzdGVucyB0byB0aGUgYEVudGVyYCBhbmQgYFNwYWNlYCBrZXkgZXZlbnRzIGluIG9yZGVyIHRvIGNoZWNrIGlmIHRoZSBsYXN0IHdvcmRcblx0XHQgKiBpbnRyb2R1Y2VkIGJ5IHRoZSB1c2VyIHNob3VsZCBiZSByZXBsYWNlZCBieSBhIGxpbmsgZWxlbWVudC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBfb25LZXlVcFxuXHRcdCAqIEBwYXJhbSB7RXZlbnRGYWNhZGV9IGV2ZW50IEV2ZW50RmFjYWRlIG9iamVjdFxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRfb25LZXlVcChldmVudCkge1xuXHRcdFx0Y29uc3QgbmF0aXZlRXZlbnQgPSBldmVudC5kYXRhLiQ7XG5cblx0XHRcdHRoaXMuX2N1cnJlbnRLZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuXHRcdFx0aWYgKERFTElNSVRFUlMuaW5kZXhPZih0aGlzLl9jdXJyZW50S2V5Q29kZSkgIT09IC0xKSB7XG5cdFx0XHRcdGNvbnN0IGVkaXRvciA9IGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3I7XG5cblx0XHRcdFx0Y29uc3QgbGFzdFdvcmQgPSB0aGlzLl9nZXRMYXN0V29yZChlZGl0b3IpO1xuXG5cdFx0XHRcdGlmICh0aGlzLl9pc1ZhbGlkVVJMKGxhc3RXb3JkKSkge1xuXHRcdFx0XHRcdHRoaXMuX3JlcGxhY2VDb250ZW50QnlMaW5rKGVkaXRvciwgbGFzdFdvcmQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlcGxhY2VzIGNvbnRlbnQgYnkgYSBsaW5rIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBAZmlyZXMgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGluayNhdXRvbGlua0FkZFxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rXG5cdFx0ICogQG1ldGhvZCBfcmVwbGFjZUNvbnRlbnRCeUxpbmtcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gY29udGVudCBUaGUgdGV4dCB0aGF0IGhhcyB0byBiZSByZXBsYWNlZCBieSBhbiBsaW5rIGVsZW1lbnRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X3JlcGxhY2VDb250ZW50QnlMaW5rKGVkaXRvciwgY29udGVudCkge1xuXHRcdFx0bGV0IHJhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG5cdFx0XHRjb25zdCBub2RlID0gQ0tFRElUT1IuZG9tLmVsZW1lbnQuZ2V0KHRoaXMuX3N0YXJ0Q29udGFpbmVyKTtcblx0XHRcdGNvbnN0IG9mZnNldCA9IHRoaXMuX29mZnNldDtcblxuXHRcdFx0Ly8gU2VsZWN0IHRoZSBjb250ZW50LCBzbyBDS0VESVRPUi5MaW5rIGNhbiBwcm9wZXJseSByZXBsYWNlIGl0XG5cdFx0XHRyYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQgLSBjb250ZW50Lmxlbmd0aCk7XG5cdFx0XHRyYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcblx0XHRcdHJhbmdlLnNlbGVjdCgpO1xuXG5cdFx0XHRjb25zdCBja0xpbmsgPSBuZXcgQ0tFRElUT1IuTGluayhlZGl0b3IpO1xuXHRcdFx0Y2tMaW5rLmNyZWF0ZShjb250ZW50KTtcblx0XHRcdHRoaXMuX2NrTGluayA9IGNrTGluaztcblxuXHRcdFx0Y29uc3QgbGlua05vZGUgPSBja0xpbmsuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXHRcdFx0ZWRpdG9yLmZpcmUoJ2F1dG9saW5rQWRkJywgbGlua05vZGUpO1xuXG5cdFx0XHR0aGlzLl9zdWJzY3JpYmVUb0tleUV2ZW50KGVkaXRvcik7XG5cblx0XHRcdC8vIE5vdyByYW5nZSBpcyBvbiB0aGUgbGluayBhbmQgaXQgaXMgc2VsZWN0ZWQuIFdlIGhhdmUgdG9cblx0XHRcdC8vIHJldHVybiBmb2N1cyB0byB0aGUgY2FyZXQgcG9zaXRpb24uXG5cdFx0XHRyYW5nZSA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKS5nZXRSYW5nZXMoKVswXTtcblxuXHRcdFx0Ly8gSWYgdXNlciBwcmVzc2VkIGBFbnRlcmAsIGdldCB0aGUgbmV4dCBlZGl0YWJsZSBub2RlIGF0IHBvc2l0aW9uIDAsXG5cdFx0XHQvLyBvdGhlcndpc2Ugc2V0IHRoZSBjdXJzb3IgYXQgdGhlIG5leHQgY2hhcmFjdGVyIG9mIHRoZSBsaW5rICh0aGUgd2hpdGUgc3BhY2UpXG5cdFx0XHRpZiAodGhpcy5fY3VycmVudEtleUNvZGUgPT09IEtFWV9FTlRFUikge1xuXHRcdFx0XHRjb25zdCBuZXh0RWRpdGFibGVOb2RlID0gcmFuZ2UuZ2V0TmV4dEVkaXRhYmxlTm9kZSgpO1xuXG5cdFx0XHRcdHJhbmdlLnNldFN0YXJ0KG5leHRFZGl0YWJsZU5vZGUsIDApO1xuXHRcdFx0XHRyYW5nZS5zZXRFbmQobmV4dEVkaXRhYmxlTm9kZSwgMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb25zdCBlbmNsb3NlZE5vZGUgPSByYW5nZS5nZXRFbmNsb3NlZE5vZGUoKTtcblxuXHRcdFx0XHRyYW5nZS5zZXRTdGFydChlbmNsb3NlZE5vZGUsIDApO1xuXHRcdFx0XHRyYW5nZS5zZXRFbmQoZW5jbG9zZWROb2RlLCAwKTtcblx0XHRcdH1cblxuXHRcdFx0cmFuZ2Uuc2VsZWN0KCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZpcmVkIHdoZW4gYSBVUkwgaXMgZGV0ZWN0ZWQgaW4gdGV4dCBhbmQgY29udmVydGVkIHRvIGEgbGluay5cblx0XHQgKlxuXHRcdCAqIEBldmVudCBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saW5rI2F1dG9saW5rQWRkXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcblx0XHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBlbCBOb2RlIG9mIHRoZSBjcmVhdGVkIGxpbmsuXG5cdFx0ICovXG5cblx0XHQvKipcblx0XHQgKiBSZW1vdmVzIHRoZSBjcmVhdGVkIGxpbmsgZWxlbWVudCwgYW5kIHJlcGxhY2VzIGl0IGJ5IGl0cyB0ZXh0LlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpbmtcblx0XHQgKiBAbWV0aG9kIF9yZW1vdmVMaW5rXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9yZW1vdmVMaW5rKGVkaXRvcikge1xuXHRcdFx0Y29uc3QgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cdFx0XHRjb25zdCBjYXJldE9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuXG5cdFx0XHQvLyBTZWxlY3QgdGhlIGxpbmssIHNvIENLRURJVE9SLkxpbmsgY2FuIHByb3Blcmx5IHJlbW92ZSBpdFxuXHRcdFx0Y29uc3QgbGlua05vZGUgPVxuXHRcdFx0XHR0aGlzLl9zdGFydENvbnRhaW5lci5nZXROZXh0KCkgfHwgdGhpcy5fc3RhcnRDb250YWluZXI7XG5cblx0XHRcdGNvbnN0IG5ld1JhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG5cdFx0XHRuZXdSYW5nZS5zZXRTdGFydChsaW5rTm9kZSwgMCk7XG5cdFx0XHRuZXdSYW5nZS5zZXRFbmRBZnRlcihsaW5rTm9kZSk7XG5cdFx0XHRuZXdSYW5nZS5zZWxlY3QoKTtcblxuXHRcdFx0dGhpcy5fY2tMaW5rLnJlbW92ZSgpO1xuXG5cdFx0XHQvLyBSZXR1cm4gZm9jdXMgdG8gdGhlIGNhcmV0IHBvc2l0aW9uXG5cdFx0XHRyYW5nZS5zZXRFbmQocmFuZ2Uuc3RhcnRDb250YWluZXIsIGNhcmV0T2Zmc2V0KTtcblx0XHRcdHJhbmdlLnNldFN0YXJ0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBjYXJldE9mZnNldCk7XG5cblx0XHRcdHJhbmdlLnNlbGVjdCgpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBTdWJzY3JpYmUgdG8gYSBrZXkgZXZlbnQgb2YgdGhlIGVkaXRhYmxlIGFyaWEuXG5cdFx0ICpcblx0XHQgKiBAaW5zdGFuY2Vcblx0XHQgKiBAbWVtYmVyb2YgQ0tFRElUT1IucGx1Z2lucy5hZV9hdXRvbGlua1xuXHRcdCAqIEBtZXRob2QgX3N1YnNjcmliZVRvS2V5RXZlbnRcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X3N1YnNjcmliZVRvS2V5RXZlbnQoZWRpdG9yKSB7XG5cdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHQvLyBDaGFuZ2UgdGhlIHByaW9yaXR5IG9mIGtleWRvd24gbGlzdGVuZXIgLSAxIG1lYW5zIHRoZSBoaWdoZXN0IHByaW9yaXR5LlxuXHRcdFx0Ly8gSW4gQ2hyb21lIG9uIHByZXNzaW5nIGBFbnRlcmAgdGhlIGxpc3RlbmVyIGlzIG5vdCBiZWluZyBpbnZva2VkLlxuXHRcdFx0Ly8gU2VlIGh0dHA6Ly9kZXYuY2tlZGl0b3IuY29tL3RpY2tldC8xMTg2MSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblx0XHRcdGVkaXRhYmxlLmF0dGFjaExpc3RlbmVyKFxuXHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0J2tleWRvd24nLFxuXHRcdFx0XHR0aGlzLl9vbktleURvd24sXG5cdFx0XHRcdHRoaXMsXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdDFcblx0XHRcdCk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCJpZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9hdXRvbGlzdCcpKSB7XG5cdGNvbnN0IEtFWV9CQUNLID0gODtcblxuXHRjb25zdCBLRVlfU1BBQ0UgPSAzMjtcblxuXHRjb25zdCBERUZBVUxUX0NPTkZJRyA9IFtcblx0XHR7XG5cdFx0XHRyZWdleDogL15cXCokLyxcblx0XHRcdHR5cGU6ICdidWxsZXRlZGxpc3QnLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0cmVnZXg6IC9eMVxcLiQvLFxuXHRcdFx0dHlwZTogJ251bWJlcmVkbGlzdCcsXG5cdFx0fSxcblx0XTtcblxuXHQvKipcblx0ICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVzIG9yZGVyZWQvdW5vcmRlcmVkIGxpc3Qgd2hlbiB1c2VyIHR5cGVzIHRleHQgd2hpY2ggbG9va3MgbGlrZSBhIGxpc3QuXG5cdCAqXG5cdCAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saXN0XG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX2F1dG9saXN0Jywge1xuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemF0aW9uIG9mIHRoZSBwbHVnaW4sIHBhcnQgb2YgQ0tlZGl0b3IgcGx1Z2luIGxpZmVjeWNsZS5cblx0XHQgKiBUaGUgZnVuY3Rpb24gcmVnaXN0ZXJzIHRoZSBga2V5ZG93bmAgZXZlbnQgb24gdGhlIGNvbnRlbnQgZWRpdGluZyBhcmVhLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpc3Rcblx0XHQgKiBAbWV0aG9kIGluaXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuXHRcdCAqL1xuXHRcdGluaXQoZWRpdG9yKSB7XG5cdFx0XHRlZGl0b3Iub25jZShcblx0XHRcdFx0J2NvbnRlbnREb20nLFxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRcdFx0ZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoXG5cdFx0XHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0XHRcdCdrZXlkb3duJyxcblx0XHRcdFx0XHRcdHRoaXMuX29uS2V5RG93bixcblx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGVkaXRvcixcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9LmJpbmQodGhpcylcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrcyBmb3IgcHJlc3NpbmcgdGhlIGBCYWNrc3BhY2VgIGtleSBpbiBvcmRlciB0byB1bmRvIHRoZSBsaXN0IGNyZWF0aW9uLlxuXHRcdCAqXG5cdFx0ICogQGluc3RhbmNlXG5cdFx0ICogQG1lbWJlcm9mIENLRURJVE9SLnBsdWdpbnMuYWVfYXV0b2xpc3Rcblx0XHQgKiBAbWV0aG9kIF9jaGVja0ZvckJhY2tzcGFjZUFuZFVuZG9cblx0XHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCBFdmVudCBvYmplY3Rcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X2NoZWNrRm9yQmFja3NwYWNlQW5kVW5kbyhldmVudCkge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcjtcblxuXHRcdFx0Y29uc3QgbmF0aXZlRXZlbnQgPSBldmVudC5kYXRhLiQ7XG5cblx0XHRcdGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdGVkaXRhYmxlLnJlbW92ZUxpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fY2hlY2tGb3JCYWNrc3BhY2VBbmRVbmRvKTtcblxuXHRcdFx0aWYgKG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IEtFWV9CQUNLKSB7XG5cdFx0XHRcdGVkaXRvci5leGVjQ29tbWFuZCgndW5kbycpO1xuXHRcdFx0XHRlZGl0b3IuaW5zZXJ0SHRtbChldmVudC5saXN0ZW5lckRhdGEuYnVsbGV0ICsgJyZuYnNwOycpO1xuXHRcdFx0XHRldmVudC5kYXRhLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENoZWNrcyBjdXJyZW50IGxpbmUgdG8gZmluZCBtYXRjaCB3aXRoIE1BVENIRVMgb2JqZWN0IHRvIGNyZWF0ZSBPTCBvciBVTC5cblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saXN0XG5cdFx0ICogQG1ldGhvZCBfY2hlY2tMaW5lXG5cdFx0ICogQHBhcmFtIHtlZGl0b3J9IEVkaXRvciBvYmplY3Rcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fG51bGx9IFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBkZXRlY3RlZCBsaXN0IGNvbmZpZyBpZiBhbnlcblx0XHQgKi9cblx0XHRfZ2V0TGlzdENvbmZpZyhlZGl0b3IpIHtcblx0XHRcdGNvbnN0IGNvbmZpZ1JlZ2V4ID0gZWRpdG9yLmNvbmZpZy5hdXRvbGlzdCB8fCBERUZBVUxUX0NPTkZJRztcblxuXHRcdFx0Y29uc3QgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cblx0XHRcdGNvbnN0IHRleHRDb250YWluZXIgPSByYW5nZS5lbmRDb250YWluZXIuZ2V0VGV4dCgpO1xuXG5cdFx0XHRjb25zdCBidWxsZXQgPSB0ZXh0Q29udGFpbmVyLnN1YnN0cmluZygwLCByYW5nZS5zdGFydE9mZnNldCk7XG5cblx0XHRcdGNvbnN0IHRleHQgPSB0ZXh0Q29udGFpbmVyLnN1YnN0cmluZyhcblx0XHRcdFx0cmFuZ2Uuc3RhcnRPZmZzZXQsXG5cdFx0XHRcdHRleHRDb250YWluZXIubGVuZ3RoXG5cdFx0XHQpO1xuXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXG5cdFx0XHRjb25zdCByZWdleExlbiA9IGNvbmZpZ1JlZ2V4Lmxlbmd0aDtcblxuXHRcdFx0bGV0IGF1dG9saXN0Q2ZnID0gbnVsbDtcblxuXHRcdFx0d2hpbGUgKCFhdXRvbGlzdENmZyAmJiByZWdleExlbiA+IGluZGV4KSB7XG5cdFx0XHRcdGNvbnN0IHJlZ2V4SXRlbSA9IGNvbmZpZ1JlZ2V4W2luZGV4XTtcblxuXHRcdFx0XHRpZiAocmVnZXhJdGVtLnJlZ2V4LnRlc3QoYnVsbGV0KSkge1xuXHRcdFx0XHRcdGF1dG9saXN0Q2ZnID0ge1xuXHRcdFx0XHRcdFx0YnVsbGV0LFxuXHRcdFx0XHRcdFx0ZWRpdG9yLFxuXHRcdFx0XHRcdFx0dGV4dCxcblx0XHRcdFx0XHRcdHR5cGU6IHJlZ2V4SXRlbS50eXBlLFxuXHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBhdXRvbGlzdENmZztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ3JlYXRlIGxpc3Qgd2l0aCBkaWZmZXJlbnQgdHlwZXM6IEJ1bGxldGVkIG9yIE51bWJlcmVkIGxpc3Rcblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saXN0XG5cdFx0ICogQG1ldGhvZCBfY3JlYXRlTGlzdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBsaXN0Q29uZmlnIE9iamVjdCB0aGF0IGNvbnRhaW5zIGJ1bGxldCwgdGV4dCBhbmQgdHlwZSBmb3IgY3JlYXRpbmcgdGhlIGxpc3Rcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X2NyZWF0ZUxpc3QobGlzdENvbmZpZykge1xuXHRcdFx0Y29uc3QgZWRpdG9yID0gbGlzdENvbmZpZy5lZGl0b3I7XG5cblx0XHRcdGNvbnN0IHJhbmdlID0gZWRpdG9yLmdldFNlbGVjdGlvbigpLmdldFJhbmdlcygpWzBdO1xuXG5cdFx0XHRyYW5nZS5lbmRDb250YWluZXIuc2V0VGV4dChsaXN0Q29uZmlnLnRleHQpO1xuXHRcdFx0ZWRpdG9yLmV4ZWNDb21tYW5kKGxpc3RDb25maWcudHlwZSk7XG5cblx0XHRcdGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdC8vIFN1YnNjcmliZSB0byBrZXlkb3duIGluIG9yZGVyIHRvIGNoZWNrIGlmIHRoZSBuZXh0IGtleSBwcmVzcyBpcyBgQmFja3NwYWNlYC5cblx0XHRcdC8vIElmIHNvLCB0aGUgY3JlYXRpb24gb2YgdGhlIGxpc3Qgd2lsbCBiZSBkaXNjYXJkZWQuXG5cdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0ZWRpdGFibGUsXG5cdFx0XHRcdCdrZXlkb3duJyxcblx0XHRcdFx0dGhpcy5fY2hlY2tGb3JCYWNrc3BhY2VBbmRVbmRvLFxuXHRcdFx0XHR0aGlzLFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZWRpdG9yLFxuXHRcdFx0XHRcdGJ1bGxldDogbGlzdENvbmZpZy5idWxsZXQsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdDFcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIExpc3RlbnMgdG8gdGhlIGBTcGFjZWAga2V5IGV2ZW50cyB0byBjaGVjayBpZiB0aGUgbGFzdCB3b3JkXG5cdFx0ICogaW50cm9kdWNlZCBieSB0aGUgdXNlciBzaG91bGQgYmUgcmVwbGFjZWQgYnkgYSBsaXN0IChPTCBvciBVTClcblx0XHQgKlxuXHRcdCAqIEBpbnN0YW5jZVxuXHRcdCAqIEBtZW1iZXJvZiBDS0VESVRPUi5wbHVnaW5zLmFlX2F1dG9saXN0XG5cdFx0ICogQG1ldGhvZCBfb25LZXlEb3duXG5cdFx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgRXZlbnQgb2JqZWN0XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9vbktleURvd24oZXZlbnQpIHtcblx0XHRcdGNvbnN0IG5hdGl2ZUV2ZW50ID0gZXZlbnQuZGF0YS4kO1xuXG5cdFx0XHRpZiAobmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gS0VZX1NQQUNFKSB7XG5cdFx0XHRcdGNvbnN0IGxpc3RDb25maWcgPSB0aGlzLl9nZXRMaXN0Q29uZmlnKFxuXHRcdFx0XHRcdGV2ZW50Lmxpc3RlbmVyRGF0YS5lZGl0b3Jcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAobGlzdENvbmZpZykge1xuXHRcdFx0XHRcdGV2ZW50LmRhdGEucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHR0aGlzLl9jcmVhdGVMaXN0KGxpc3RDb25maWcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIENLRWRpdG9yIHBsdWdpbjogRHJhZ2FibGUgaW1hZ2UgcmVzaXppbmdcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zc3R1ci9jay1kcmFncmVzaXplXG4gKiAtIFNob3dzIHNlbWktdHJhbnNwYXJlbnQgb3ZlcmxheSB3aGlsZSByZXNpemluZ1xuICogLSBFbmZvcmNlcyBBc3BlY3QgUmF0aW8gKHVubGVzcyBob2xkaW5nIHNoaWZ0KVxuICogLSBTbmFwIHRvIHNpemUgb2Ygb3RoZXIgaW1hZ2VzIGluIGVkaXRvclxuICogLSBFc2NhcGUgd2hpbGUgZHJhZ2dpbmcgY2FuY2VscyByZXNpemVcbiAqL1xuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfZHJhZ3Jlc2l6ZScpKSB7XG5cdGNvbnN0IElNQUdFX0hBTkRMRVMgPSB7XG5cdFx0Ym90aDogWyd0bCcsICd0bScsICd0cicsICdsbScsICdybScsICdibCcsICdibScsICdiciddLFxuXHRcdGhlaWdodDogWyd0bCcsICd0bScsICd0cicsICdibCcsICdibScsICdiciddLFxuXHRcdHNjYWxlOiBbJ3RsJywgJ3RyJywgJ2JsJywgJ2JyJ10sXG5cdFx0d2lkdGg6IFsndGwnLCAndHInLCAnbG0nLCAncm0nLCAnYmwnLCAnYnInXSxcblx0fTtcblxuXHRjb25zdCBQT1NJVElPTl9FTEVNRU5UX0ZOID0ge1xuXHRcdGJsKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcblx0XHRcdHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIC0zICsgbGVmdCwgYm94LmhlaWdodCAtIDQgKyB0b3ApO1xuXHRcdH0sXG5cdFx0Ym0oaGFuZGxlLCBsZWZ0LCB0b3AsIGJveCkge1xuXHRcdFx0cG9zaXRpb25FbGVtZW50KFxuXHRcdFx0XHRoYW5kbGUsXG5cdFx0XHRcdE1hdGgucm91bmQoYm94LndpZHRoIC8gMikgLSAzICsgbGVmdCxcblx0XHRcdFx0Ym94LmhlaWdodCAtIDQgKyB0b3Bcblx0XHRcdCk7XG5cdFx0fSxcblx0XHRicihoYW5kbGUsIGxlZnQsIHRvcCwgYm94KSB7XG5cdFx0XHRwb3NpdGlvbkVsZW1lbnQoaGFuZGxlLCBib3gud2lkdGggLSA0ICsgbGVmdCwgYm94LmhlaWdodCAtIDQgKyB0b3ApO1xuXHRcdH0sXG5cdFx0bG0oaGFuZGxlLCBsZWZ0LCB0b3AsIGJveCkge1xuXHRcdFx0cG9zaXRpb25FbGVtZW50KFxuXHRcdFx0XHRoYW5kbGUsXG5cdFx0XHRcdC0zICsgbGVmdCxcblx0XHRcdFx0TWF0aC5yb3VuZChib3guaGVpZ2h0IC8gMikgLSAzICsgdG9wXG5cdFx0XHQpO1xuXHRcdH0sXG5cdFx0dGwoaGFuZGxlLCBsZWZ0LCB0b3AsIF9ib3gpIHtcblx0XHRcdHBvc2l0aW9uRWxlbWVudChoYW5kbGUsIGxlZnQgLSAzLCB0b3AgLSAzKTtcblx0XHR9LFxuXHRcdHRtKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcblx0XHRcdHBvc2l0aW9uRWxlbWVudChcblx0XHRcdFx0aGFuZGxlLFxuXHRcdFx0XHRNYXRoLnJvdW5kKGJveC53aWR0aCAvIDIpIC0gMyArIGxlZnQsXG5cdFx0XHRcdC0zICsgdG9wXG5cdFx0XHQpO1xuXHRcdH0sXG5cdFx0dHIoaGFuZGxlLCBsZWZ0LCB0b3AsIGJveCkge1xuXHRcdFx0cG9zaXRpb25FbGVtZW50KGhhbmRsZSwgYm94LndpZHRoIC0gNCArIGxlZnQsIC0zICsgdG9wKTtcblx0XHR9LFxuXHRcdHJtKGhhbmRsZSwgbGVmdCwgdG9wLCBib3gpIHtcblx0XHRcdHBvc2l0aW9uRWxlbWVudChcblx0XHRcdFx0aGFuZGxlLFxuXHRcdFx0XHRib3gud2lkdGggLSA0ICsgbGVmdCxcblx0XHRcdFx0TWF0aC5yb3VuZChib3guaGVpZ2h0IC8gMikgLSAzICsgdG9wXG5cdFx0XHQpO1xuXHRcdH0sXG5cdH07XG5cblx0Y29uc3QgSU1BR0VfU05BUF9UT19TSVpFID0gNztcblxuXHRjb25zdCBpc0ZpcmVmb3ggPSAnTW96QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuXG5cdGNvbnN0IGlzV2ViS2l0ID0gJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZTtcblxuXHRjb25zdCBlbmFibGVQbHVnaW4gPSBpc1dlYktpdCB8fCBpc0ZpcmVmb3g7XG5cblx0aWYgKGVuYWJsZVBsdWdpbikge1xuXHRcdC8vIENTUyBpcyBhZGRlZCBpbiBhIGNvbXByZXNzZWQgZm9ybVxuXHRcdENLRURJVE9SLmFkZENzcyhcblx0XHRcdCdpbWc6OnNlbGVjdGlvbntjb2xvcjpyZ2JhKDAsMCwwLDApfWltZy5ja2ltZ3JzentvdXRsaW5lOjFweCBkYXNoZWQgIzAwMH0jY2tpbWdyc3p7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MDtoZWlnaHQ6MDtjdXJzb3I6ZGVmYXVsdDt6LWluZGV4OjEwMDAxfSNja2ltZ3JzeiBzcGFue2Rpc3BsYXk6bm9uZTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MDtoZWlnaHQ6MDtiYWNrZ3JvdW5kLXNpemU6MTAwJSAxMDAlO29wYWNpdHk6LjY1O291dGxpbmU6MXB4IGRhc2hlZCAjMDAwfSNja2ltZ3JzeiBpe3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7d2lkdGg6NXB4O2hlaWdodDo1cHg7YmFja2dyb3VuZDojZmZmO2JvcmRlcjoxcHggc29saWQgIzAwMH0jY2tpbWdyc3ogaS5hY3RpdmUsI2NraW1ncnN6IGk6aG92ZXJ7YmFja2dyb3VuZDojMDAwfSNja2ltZ3JzeiBpLmJyLCNja2ltZ3JzeiBpLnRse2N1cnNvcjpud3NlLXJlc2l6ZX0jY2tpbWdyc3ogaS5ibSwjY2tpbWdyc3ogaS50bXtjdXJzb3I6bnMtcmVzaXplfSNja2ltZ3JzeiBpLmJsLCNja2ltZ3JzeiBpLnRye2N1cnNvcjpuZXN3LXJlc2l6ZX0jY2tpbWdyc3ogaS5sbSwjY2tpbWdyc3ogaS5ybXtjdXJzb3I6ZXctcmVzaXplfWJvZHkuZHJhZ2dpbmctYnIsYm9keS5kcmFnZ2luZy1iciAqLGJvZHkuZHJhZ2dpbmctdGwsYm9keS5kcmFnZ2luZy10bCAqe2N1cnNvcjpud3NlLXJlc2l6ZSFpbXBvcnRhbnR9Ym9keS5kcmFnZ2luZy1ibSxib2R5LmRyYWdnaW5nLWJtICosYm9keS5kcmFnZ2luZy10bSxib2R5LmRyYWdnaW5nLXRtICp7Y3Vyc29yOm5zLXJlc2l6ZSFpbXBvcnRhbnR9Ym9keS5kcmFnZ2luZy1ibCxib2R5LmRyYWdnaW5nLWJsICosYm9keS5kcmFnZ2luZy10cixib2R5LmRyYWdnaW5nLXRyICp7Y3Vyc29yOm5lc3ctcmVzaXplIWltcG9ydGFudH1ib2R5LmRyYWdnaW5nLWxtLGJvZHkuZHJhZ2dpbmctbG0gKixib2R5LmRyYWdnaW5nLXJtLGJvZHkuZHJhZ2dpbmctcm0gKntjdXJzb3I6ZXctcmVzaXplIWltcG9ydGFudH0nXG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luXG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfZHJhZ3Jlc2l6ZScsIHtcblx0XHRvbkxvYWQoKSB7XG5cdFx0XHRpZiAoIWVuYWJsZVBsdWdpbikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRpbml0KGVkaXRvcikge1xuXHRcdFx0aWYgKCFlbmFibGVQbHVnaW4pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRlZGl0b3Iub25jZSgnY29udGVudERvbScsIGZ1bmN0aW9uKF9ldnQpIHtcblx0XHRcdFx0aW5pdChlZGl0b3IpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0fSk7XG5cblx0ZnVuY3Rpb24gaW5pdChlZGl0b3IpIHtcblx0XHRjb25zdCB3aW5kb3cgPSBlZGl0b3Iud2luZG93LiQ7XG5cblx0XHRjb25zdCBkb2N1bWVudCA9IGVkaXRvci5kb2N1bWVudC4kO1xuXG5cdFx0aWYgKGlzRmlyZWZveCkge1xuXHRcdFx0Ly8gRGlzYWJsZSB0aGUgbmF0aXZlIGltYWdlIHJlc2l6aW5nXG5cdFx0XHRkb2N1bWVudC5leGVjQ29tbWFuZCgnZW5hYmxlT2JqZWN0UmVzaXppbmcnLCBmYWxzZSwgZmFsc2UpO1xuXHRcdH1cblxuXHRcdGNvbnN0IHNuYXBUb1NpemUgPVxuXHRcdFx0dHlwZW9mIElNQUdFX1NOQVBfVE9fU0laRSA9PT0gJ3VuZGVmaW5lZCdcblx0XHRcdFx0PyBudWxsXG5cdFx0XHRcdDogSU1BR0VfU05BUF9UT19TSVpFO1xuXG5cdFx0ZWRpdG9yLmNvbmZpZy5pbWFnZVNjYWxlUmVzaXplID1cblx0XHRcdGVkaXRvci5jb25maWcuaW1hZ2VTY2FsZVJlc2l6ZSB8fCAnYm90aCc7XG5cblx0XHRjb25zdCByZXNpemVyID0gbmV3IFJlc2l6ZXIoZWRpdG9yLCB7XG5cdFx0XHRpbWFnZVNjYWxlUmVzaXplOiBlZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemUsXG5cdFx0XHRzbmFwVG9TaXplLFxuXHRcdH0pO1xuXG5cdFx0Y29uc3QgbW91c2VEb3duTGlzdGVuZXIgPSBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAocmVzaXplci5pc0hhbmRsZShlLnRhcmdldCkpIHtcblx0XHRcdFx0cmVzaXplci5pbml0RHJhZyhlKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2VEb3duTGlzdGVuZXIsIGZhbHNlKTtcblxuXHRcdGZ1bmN0aW9uIHNlbGVjdGlvbkNoYW5nZSgpIHtcblx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdFx0aWYgKCFzZWxlY3Rpb24pIHJldHVybjtcblx0XHRcdC8vIElmIGFuIGVsZW1lbnQgaXMgc2VsZWN0ZWQgYW5kIHRoYXQgZWxlbWVudCBpcyBhbiBJTUdcblx0XHRcdGlmIChcblx0XHRcdFx0c2VsZWN0aW9uLmdldFR5cGUoKSAhPT0gQ0tFRElUT1IuU0VMRUNUSU9OX05PTkUgJiZcblx0XHRcdFx0c2VsZWN0aW9uLmdldFN0YXJ0RWxlbWVudCgpLmlzKCdpbWcnKVxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIEFuZCB3ZSdyZSBub3QgcmlnaHQgb3IgbWlkZGxlIGNsaWNraW5nIG9uIHRoZSBpbWFnZVxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0IXdpbmRvdy5ldmVudCB8fFxuXHRcdFx0XHRcdCF3aW5kb3cuZXZlbnQuYnV0dG9uIHx8XG5cdFx0XHRcdFx0d2luZG93LmV2ZW50LmJ1dHRvbiA9PT0gMFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXNpemVyLnNob3coc2VsZWN0aW9uLmdldFN0YXJ0RWxlbWVudCgpLiQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXNpemVyLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRlZGl0b3Iub24oJ3NlbGVjdGlvbkNoYW5nZScsIHNlbGVjdGlvbkNoYW5nZSk7XG5cblx0XHRlZGl0b3Iub24oJ2dldERhdGEnLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRsZXQgaHRtbCA9IGUuZGF0YS5kYXRhVmFsdWUgfHwgJyc7XG5cdFx0XHRodG1sID0gaHRtbC5yZXBsYWNlKC88ZGl2IGlkPVwiY2tpbWdyc3pcIihbXFxzXFxTXSo/KTxcXC9kaXY+L2ksICcnKTtcblx0XHRcdGh0bWwgPSBodG1sLnJlcGxhY2UoL1xcYihja2ltZ3JzeilcXGIvZywgJycpO1xuXHRcdFx0ZS5kYXRhLmRhdGFWYWx1ZSA9IGh0bWw7XG5cdFx0fSk7XG5cblx0XHRlZGl0b3Iub24oJ2JlZm9yZVVuZG9JbWFnZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gUmVtb3ZlIHRoZSBoYW5kbGVzIGJlZm9yZSB1bmRvIGltYWdlcyBhcmUgc2F2ZWRcblx0XHRcdHJlc2l6ZXIuaGlkZSgpO1xuXHRcdH0pO1xuXG5cdFx0ZWRpdG9yLm9uKCdhZnRlclVuZG9JbWFnZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gUmVzdG9yZSB0aGUgaGFuZGxlcyBhZnRlciB1bmRvIGltYWdlcyBhcmUgc2F2ZWRcblx0XHRcdHNlbGVjdGlvbkNoYW5nZSgpO1xuXHRcdH0pO1xuXG5cdFx0ZWRpdG9yLm9uKCdibHVyJywgZnVuY3Rpb24oKSB7XG5cdFx0XHQvLyBSZW1vdmUgdGhlIGhhbmRsZXMgd2hlbiBlZGl0b3IgbG9zZXMgZm9jdXNcblx0XHRcdHJlc2l6ZXIuaGlkZSgpO1xuXHRcdH0pO1xuXG5cdFx0ZWRpdG9yLm9uKCdiZWZvcmVNb2RlVW5sb2FkJywgZnVuY3Rpb24gc2VsZigpIHtcblx0XHRcdGVkaXRvci5yZW1vdmVMaXN0ZW5lcignYmVmb3JlTW9kZVVubG9hZCcsIHNlbGYpO1xuXHRcdFx0cmVzaXplci5oaWRlKCk7XG5cdFx0fSk7XG5cblx0XHRlZGl0b3Iub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnN0IHJlc2l6ZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2tpbWdyc3onKTtcblxuXHRcdFx0aWYgKHJlc2l6ZUVsZW1lbnQpIHtcblx0XHRcdFx0cmVzaXplRWxlbWVudC5yZW1vdmUoKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzRmlyZWZveCkge1xuXHRcdFx0XHRkb2N1bWVudC5leGVjQ29tbWFuZCgnZW5hYmxlT2JqZWN0UmVzaXppbmcnLCBmYWxzZSwgdHJ1ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlRG93bkxpc3RlbmVyKTtcblx0XHR9KTtcblxuXHRcdC8vIFVwZGF0ZSB0aGUgc2VsZWN0aW9uIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93IGlzIHJlc2l6ZWRcblx0XHRsZXQgcmVzaXplVGltZW91dDtcblx0XHRlZGl0b3Iud2luZG93Lm9uKCdyZXNpemUnLCBmdW5jdGlvbigpIHtcblx0XHRcdC8vIENhbmNlbCBhbnkgcmVzaXplIHdhaXRpbmcgdG8gaGFwcGVuXG5cdFx0XHRjbGVhclRpbWVvdXQocmVzaXplVGltZW91dCk7XG5cdFx0XHQvLyBEZWxheSByZXNpemUgdG8gXCJkZWJvdW5jZVwiXG5cdFx0XHRyZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dChzZWxlY3Rpb25DaGFuZ2UsIDUwKTtcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIFJlc2l6ZXIoZWRpdG9yLCBjZmcpIHtcblx0XHR0aGlzLmVkaXRvciA9IGVkaXRvcjtcblx0XHR0aGlzLndpbmRvdyA9IGVkaXRvci53aW5kb3cuJDtcblx0XHR0aGlzLmRvY3VtZW50ID0gZWRpdG9yLmRvY3VtZW50LiQ7XG5cdFx0dGhpcy5jZmcgPSBjZmcgfHwge307XG5cdFx0dGhpcy5pbml0KCk7XG5cdH1cblxuXHRSZXNpemVyLnByb3RvdHlwZSA9IHtcblx0XHRpbml0KCkge1xuXHRcdFx0Y29uc3QgaW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0XHRjb25zdCBjb250YWluZXIgPSAodGhpcy5jb250YWluZXIgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdCdkaXYnXG5cdFx0XHQpKTtcblxuXHRcdFx0Y29udGFpbmVyLmlkID0gJ2NraW1ncnN6Jztcblx0XHRcdHRoaXMucHJldmlldyA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMucHJldmlldyk7XG5cblx0XHRcdGNvbnN0IGhhbmRsZXMgPSAodGhpcy5oYW5kbGVzID0ge30pO1xuXG5cdFx0XHRJTUFHRV9IQU5ETEVTW3RoaXMuY2ZnLmltYWdlU2NhbGVSZXNpemVdLmZvckVhY2goZnVuY3Rpb24oXG5cdFx0XHRcdGhhbmRsZU5hbWVcblx0XHRcdCkge1xuXHRcdFx0XHRoYW5kbGVzW2hhbmRsZU5hbWVdID0gaW5zdGFuY2UuaGFuZGxlc1tcblx0XHRcdFx0XHRoYW5kbGVOYW1lXG5cdFx0XHRcdF0gPSBpbnN0YW5jZS5jcmVhdGVIYW5kbGUoaGFuZGxlTmFtZSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Zm9yIChjb25zdCBuIGluIGhhbmRsZXMpIHtcblx0XHRcdFx0aWYgKGhhbmRsZXMuaGFzT3duUHJvcGVydHkobikpIHtcblx0XHRcdFx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQoaGFuZGxlc1tuXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdGNyZWF0ZUhhbmRsZShuYW1lKSB7XG5cdFx0XHRjb25zdCBlbCA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpO1xuXHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChuYW1lKTtcblx0XHRcdHJldHVybiBlbDtcblx0XHR9LFxuXHRcdGlzSGFuZGxlKGVsKSB7XG5cdFx0XHRjb25zdCBoYW5kbGVzID0gdGhpcy5oYW5kbGVzO1xuXHRcdFx0Zm9yIChjb25zdCBuIGluIGhhbmRsZXMpIHtcblx0XHRcdFx0aWYgKGhhbmRsZXNbbl0gPT09IGVsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHNob3coZWwpIHtcblx0XHRcdGxldCB1aU5vZGUgPSB0aGlzLmVkaXRvci5jb25maWcudWlOb2RlO1xuXG5cdFx0XHRjb25zdCBzY3JvbGxUb3AgPSB1aU5vZGUgPyB1aU5vZGUuc2Nyb2xsVG9wIDogMDtcblxuXHRcdFx0dGhpcy5lbCA9IGVsO1xuXHRcdFx0aWYgKHRoaXMuY2ZnLnNuYXBUb1NpemUpIHtcblx0XHRcdFx0dGhpcy5vdGhlckltYWdlcyA9IHRvQXJyYXkoXG5cdFx0XHRcdFx0dGhpcy5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW1nJylcblx0XHRcdFx0KTtcblx0XHRcdFx0dGhpcy5vdGhlckltYWdlcy5zcGxpY2UodGhpcy5vdGhlckltYWdlcy5pbmRleE9mKGVsKSwgMSk7XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBib3ggPSAodGhpcy5ib3ggPSBnZXRCb3VuZGluZ0JveCh0aGlzLndpbmRvdywgZWwpKTtcblx0XHRcdHBvc2l0aW9uRWxlbWVudCh0aGlzLmNvbnRhaW5lciwgYm94LmxlZnQsIGJveC50b3AgKyBzY3JvbGxUb3ApO1xuXG5cdFx0XHR1aU5vZGUgPSB1aU5vZGUgfHwgZG9jdW1lbnQuYm9keTtcblxuXHRcdFx0dWlOb2RlLmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcblxuXHRcdFx0dGhpcy5lbC5jbGFzc0xpc3QuYWRkKCdja2ltZ3JzeicpO1xuXHRcdFx0dGhpcy5zaG93SGFuZGxlcygpO1xuXHRcdH0sXG5cdFx0aGlkZSgpIHtcblx0XHRcdC8vIFJlbW92ZSBjbGFzcyBmcm9tIGFsbCBpbWcuY2tpbWdyc3pcblx0XHRcdGNvbnN0IGVsZW1lbnRzID0gdGhpcy5kb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdja2ltZ3JzeicpO1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRlbGVtZW50c1tpXS5jbGFzc0xpc3QucmVtb3ZlKCdja2ltZ3JzeicpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5oaWRlSGFuZGxlcygpO1xuXHRcdFx0aWYgKHRoaXMuY29udGFpbmVyLnBhcmVudE5vZGUpIHtcblx0XHRcdFx0dGhpcy5jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRpbml0RHJhZyhlKSB7XG5cdFx0XHRpZiAoZS5idXR0b24gIT09IDApIHtcblx0XHRcdFx0Ly8gcmlnaHQtY2xpY2sgb3IgbWlkZGxlLWNsaWNrXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHJlc2l6ZXIgPSB0aGlzO1xuXHRcdFx0Y29uc3QgZHJhZyA9IG5ldyBEcmFnRXZlbnQodGhpcy53aW5kb3csIHRoaXMuZG9jdW1lbnQpO1xuXHRcdFx0ZHJhZy5vblN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlc2l6ZXIuc2hvd1ByZXZpZXcoKTtcblx0XHRcdFx0cmVzaXplci5pc0RyYWdnaW5nID0gdHJ1ZTtcblx0XHRcdFx0cmVzaXplci5lZGl0b3IuZ2V0U2VsZWN0aW9uKCkubG9jaygpO1xuXHRcdFx0fTtcblx0XHRcdGRyYWcub25EcmFnID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlc2l6ZXIuY2FsY3VsYXRlU2l6ZSh0aGlzKTtcblx0XHRcdFx0cmVzaXplci51cGRhdGVQcmV2aWV3KCk7XG5cdFx0XHRcdGNvbnN0IGJveCA9IHJlc2l6ZXIucHJldmlld0JveDtcblx0XHRcdFx0cmVzaXplci51cGRhdGVIYW5kbGVzKGJveCwgYm94LmxlZnQsIGJveC50b3ApO1xuXHRcdFx0fTtcblx0XHRcdGRyYWcub25SZWxlYXNlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlc2l6ZXIuaXNEcmFnZ2luZyA9IGZhbHNlO1xuXHRcdFx0XHRyZXNpemVyLmhpZGVQcmV2aWV3KCk7XG5cdFx0XHRcdHJlc2l6ZXIuaGlkZSgpO1xuXHRcdFx0XHRyZXNpemVyLmVkaXRvci5nZXRTZWxlY3Rpb24oKS51bmxvY2soKTtcblx0XHRcdFx0Ly8gU2F2ZSBhbiB1bmRvIHNuYXBzaG90IGJlZm9yZSB0aGUgaW1hZ2UgaXMgcGVybWFuZW50bHkgY2hhbmdlZFxuXHRcdFx0XHRyZXNpemVyLmVkaXRvci5maXJlKCdzYXZlU25hcHNob3QnKTtcblx0XHRcdH07XG5cdFx0XHRkcmFnLm9uQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVzaXplci5yZXNpemVDb21wbGV0ZSgpO1xuXHRcdFx0XHQvLyBTYXZlIGFub3RoZXIgc25hcHNob3QgYWZ0ZXIgdGhlIGltYWdlIGlzIGNoYW5nZWRcblx0XHRcdFx0cmVzaXplci5lZGl0b3IuZmlyZSgnc2F2ZVNuYXBzaG90Jyk7XG5cdFx0XHR9O1xuXHRcdFx0ZHJhZy5zdGFydChlKTtcblx0XHR9LFxuXHRcdHVwZGF0ZUhhbmRsZXMoYm94LCBsZWZ0LCB0b3ApIHtcblx0XHRcdGxlZnQgPSBsZWZ0IHx8IDA7XG5cdFx0XHR0b3AgPSB0b3AgfHwgMDtcblx0XHRcdGNvbnN0IGhhbmRsZXMgPSB0aGlzLmhhbmRsZXM7XG5cblx0XHRcdGZvciAoY29uc3QgaGFuZGxlIGluIGhhbmRsZXMpIHtcblx0XHRcdFx0aWYgKGhhbmRsZXMuaGFzT3duUHJvcGVydHkoaGFuZGxlKSkge1xuXHRcdFx0XHRcdFBPU0lUSU9OX0VMRU1FTlRfRk5baGFuZGxlXShcblx0XHRcdFx0XHRcdGhhbmRsZXNbaGFuZGxlXSxcblx0XHRcdFx0XHRcdGxlZnQsXG5cdFx0XHRcdFx0XHR0b3AsXG5cdFx0XHRcdFx0XHRib3hcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzaG93SGFuZGxlcygpIHtcblx0XHRcdGNvbnN0IGhhbmRsZXMgPSB0aGlzLmhhbmRsZXM7XG5cdFx0XHR0aGlzLnVwZGF0ZUhhbmRsZXModGhpcy5ib3gpO1xuXHRcdFx0Zm9yIChjb25zdCBuIGluIGhhbmRsZXMpIHtcblx0XHRcdFx0aWYgKGhhbmRsZXMuaGFzT3duUHJvcGVydHkobikpIHtcblx0XHRcdFx0XHRoYW5kbGVzW25dLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRoaWRlSGFuZGxlcygpIHtcblx0XHRcdGNvbnN0IGhhbmRsZXMgPSB0aGlzLmhhbmRsZXM7XG5cdFx0XHRmb3IgKGNvbnN0IG4gaW4gaGFuZGxlcykge1xuXHRcdFx0XHRpZiAoaGFuZGxlcy5oYXNPd25Qcm9wZXJ0eShuKSkge1xuXHRcdFx0XHRcdGhhbmRsZXNbbl0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2hvd1ByZXZpZXcoKSB7XG5cdFx0XHR0aGlzLnByZXZpZXcuc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJ3VybChcIicgKyB0aGlzLmVsLnNyYyArICdcIiknO1xuXHRcdFx0dGhpcy5jYWxjdWxhdGVTaXplKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZVByZXZpZXcoKTtcblx0XHRcdHRoaXMucHJldmlldy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0XHR9LFxuXHRcdHVwZGF0ZVByZXZpZXcoKSB7XG5cdFx0XHRjb25zdCBib3ggPSB0aGlzLnByZXZpZXdCb3g7XG5cdFx0XHRwb3NpdGlvbkVsZW1lbnQodGhpcy5wcmV2aWV3LCBib3gubGVmdCwgYm94LnRvcCk7XG5cdFx0XHR0aGlzLnByZXZpZXcuc3R5bGUud2lkdGggPSB0aGlzLnByZXZpZXdCb3gud2lkdGggKyAncHgnO1xuXHRcdFx0dGhpcy5wcmV2aWV3LnN0eWxlLmhlaWdodCA9IHRoaXMucHJldmlld0JveC5oZWlnaHQgKyAncHgnO1xuXHRcdH0sXG5cdFx0aGlkZVByZXZpZXcoKSB7XG5cdFx0XHRjb25zdCBib3ggPSBnZXRCb3VuZGluZ0JveCh0aGlzLndpbmRvdywgdGhpcy5wcmV2aWV3KTtcblx0XHRcdHRoaXMucmVzdWx0ID0ge1xuXHRcdFx0XHR3aWR0aDogYm94LndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IGJveC5oZWlnaHQsXG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5wcmV2aWV3LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0fSxcblx0XHRjYWxjdWxhdGVTaXplKGRhdGEpIHtcblx0XHRcdGNvbnN0IGJveCA9ICh0aGlzLnByZXZpZXdCb3ggPSB7XG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0bGVmdDogMCxcblx0XHRcdFx0d2lkdGg6IHRoaXMuYm94LndpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IHRoaXMuYm94LmhlaWdodCxcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoIWRhdGEpIHJldHVybjtcblxuXHRcdFx0Y29uc3QgYXR0ciA9IGRhdGEudGFyZ2V0LmNsYXNzTmFtZTtcblxuXHRcdFx0aWYgKH5hdHRyLmluZGV4T2YoJ3InKSkge1xuXHRcdFx0XHRib3gud2lkdGggPSBNYXRoLm1heCgzMiwgdGhpcy5ib3gud2lkdGggKyBkYXRhLmRlbHRhLngpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKH5hdHRyLmluZGV4T2YoJ2InKSkge1xuXHRcdFx0XHRib3guaGVpZ2h0ID0gTWF0aC5tYXgoMzIsIHRoaXMuYm94LmhlaWdodCArIGRhdGEuZGVsdGEueSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAofmF0dHIuaW5kZXhPZignbCcpKSB7XG5cdFx0XHRcdGJveC53aWR0aCA9IE1hdGgubWF4KDMyLCB0aGlzLmJveC53aWR0aCAtIGRhdGEuZGVsdGEueCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAofmF0dHIuaW5kZXhPZigndCcpKSB7XG5cdFx0XHRcdGJveC5oZWlnaHQgPSBNYXRoLm1heCgzMiwgdGhpcy5ib3guaGVpZ2h0IC0gZGF0YS5kZWx0YS55KTtcblx0XHRcdH1cblx0XHRcdC8vIGlmIGRyYWdnaW5nIGNvcm5lciwgZW5mb3JjZSBhc3BlY3QgcmF0aW8gKHVubGVzcyBzaGlmdCBrZXkgaXMgYmVpbmcgaGVsZClcblx0XHRcdGlmIChhdHRyLmluZGV4T2YoJ20nKSA8IDAgJiYgIWRhdGEua2V5cy5zaGlmdCkge1xuXHRcdFx0XHRjb25zdCByYXRpbyA9IHRoaXMuYm94LndpZHRoIC8gdGhpcy5ib3guaGVpZ2h0O1xuXHRcdFx0XHRpZiAoYm94LndpZHRoIC8gYm94LmhlaWdodCA+IHJhdGlvKSB7XG5cdFx0XHRcdFx0Ym94LmhlaWdodCA9IE1hdGgucm91bmQoYm94LndpZHRoIC8gcmF0aW8pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJveC53aWR0aCA9IE1hdGgucm91bmQoYm94LmhlaWdodCAqIHJhdGlvKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzbmFwVG9TaXplID0gdGhpcy5jZmcuc25hcFRvU2l6ZTtcblxuXHRcdFx0aWYgKHNuYXBUb1NpemUpIHtcblx0XHRcdFx0Y29uc3Qgb3RoZXJzID0gdGhpcy5vdGhlckltYWdlcztcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBvdGhlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBvdGhlciA9IGdldEJvdW5kaW5nQm94KHRoaXMud2luZG93LCBvdGhlcnNbaV0pO1xuXHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdE1hdGguYWJzKGJveC53aWR0aCAtIG90aGVyLndpZHRoKSA8PSBzbmFwVG9TaXplICYmXG5cdFx0XHRcdFx0XHRNYXRoLmFicyhib3guaGVpZ2h0IC0gb3RoZXIuaGVpZ2h0KSA8PSBzbmFwVG9TaXplXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRib3gud2lkdGggPSBvdGhlci53aWR0aDtcblx0XHRcdFx0XHRcdGJveC5oZWlnaHQgPSBvdGhlci5oZWlnaHQ7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVjYWxjdWxhdGUgbGVmdCBvciB0b3AgcG9zaXRpb25cblx0XHRcdGlmICh+YXR0ci5pbmRleE9mKCdsJykpIHtcblx0XHRcdFx0Ym94LmxlZnQgPSB0aGlzLmJveC53aWR0aCAtIGJveC53aWR0aDtcblx0XHRcdH1cblx0XHRcdGlmICh+YXR0ci5pbmRleE9mKCd0JykpIHtcblx0XHRcdFx0Ym94LnRvcCA9IHRoaXMuYm94LmhlaWdodCAtIGJveC5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRyZXNpemVDb21wbGV0ZSgpIHtcblx0XHRcdHJlc2l6ZUVsZW1lbnQuY2FsbChcblx0XHRcdFx0dGhpcyxcblx0XHRcdFx0dGhpcy5lbCxcblx0XHRcdFx0dGhpcy5yZXN1bHQud2lkdGgsXG5cdFx0XHRcdHRoaXMucmVzdWx0LmhlaWdodFxuXHRcdFx0KTtcblx0XHR9LFxuXHR9O1xuXG5cdGZ1bmN0aW9uIERyYWdFdmVudCh3aW5kb3csIGRvY3VtZW50KSB7XG5cdFx0dGhpcy53aW5kb3cgPSB3aW5kb3c7XG5cdFx0dGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuXHRcdHRoaXMuZXZlbnRzID0ge1xuXHRcdFx0bW91c2Vtb3ZlOiBiaW5kKHRoaXMubW91c2Vtb3ZlLCB0aGlzKSxcblx0XHRcdGtleWRvd246IGJpbmQodGhpcy5rZXlkb3duLCB0aGlzKSxcblx0XHRcdG1vdXNldXA6IGJpbmQodGhpcy5tb3VzZXVwLCB0aGlzKSxcblx0XHR9O1xuXHR9XG5cblx0RHJhZ0V2ZW50LnByb3RvdHlwZSA9IHtcblx0XHRzdGFydChlKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0dGhpcy50YXJnZXQgPSBlLnRhcmdldDtcblx0XHRcdHRoaXMuYXR0ciA9IGUudGFyZ2V0LmNsYXNzTmFtZTtcblx0XHRcdHRoaXMuc3RhcnRQb3MgPSB7XG5cdFx0XHRcdHg6IGUuY2xpZW50WCxcblx0XHRcdFx0eTogZS5jbGllbnRZLFxuXHRcdFx0fTtcblx0XHRcdHRoaXMudXBkYXRlKGUpO1xuXHRcdFx0Y29uc3QgZXZlbnRzID0gdGhpcy5ldmVudHM7XG5cdFx0XHR0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG5cdFx0XHRcdCdtb3VzZW1vdmUnLFxuXHRcdFx0XHRldmVudHMubW91c2Vtb3ZlLFxuXHRcdFx0XHRmYWxzZVxuXHRcdFx0KTtcblx0XHRcdHRoaXMuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGV2ZW50cy5rZXlkb3duLCBmYWxzZSk7XG5cdFx0XHR0aGlzLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBldmVudHMubW91c2V1cCwgZmFsc2UpO1xuXHRcdFx0dGhpcy5kb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ2RyYWdnaW5nLScgKyB0aGlzLmF0dHIpO1xuXHRcdFx0aWYgKHRoaXMub25TdGFydCkge1xuXHRcdFx0XHR0aGlzLm9uU3RhcnQoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHVwZGF0ZShlKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRQb3MgPSB7XG5cdFx0XHRcdHg6IGUuY2xpZW50WCxcblx0XHRcdFx0eTogZS5jbGllbnRZLFxuXHRcdFx0fTtcblx0XHRcdHRoaXMuZGVsdGEgPSB7XG5cdFx0XHRcdHg6IGUuY2xpZW50WCAtIHRoaXMuc3RhcnRQb3MueCxcblx0XHRcdFx0eTogZS5jbGllbnRZIC0gdGhpcy5zdGFydFBvcy55LFxuXHRcdFx0fTtcblx0XHRcdHRoaXMua2V5cyA9IHtcblx0XHRcdFx0c2hpZnQ6IGUuc2hpZnRLZXksXG5cdFx0XHRcdGN0cmw6IGUuY3RybEtleSxcblx0XHRcdFx0YWx0OiBlLmFsdEtleSxcblx0XHRcdH07XG5cdFx0fSxcblx0XHRtb3VzZW1vdmUoZSkge1xuXHRcdFx0dGhpcy51cGRhdGUoZSk7XG5cdFx0XHRpZiAodGhpcy5vbkRyYWcpIHtcblx0XHRcdFx0dGhpcy5vbkRyYWcoKTtcblx0XHRcdH1cblx0XHRcdGlmIChlLndoaWNoID09PSAwKSB7XG5cdFx0XHRcdC8vIG1vdXNlIGJ1dHRvbiByZWxlYXNlZCBvdXRzaWRlIHdpbmRvdzsgbW91c2V1cCB3YXNuJ3QgZmlyZWQgKENocm9tZSlcblx0XHRcdFx0dGhpcy5tb3VzZXVwKGUpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0a2V5ZG93bihlKSB7XG5cdFx0XHQvLyBlc2NhcGUga2V5IGNhbmNlbHMgZHJhZ2dpbmdcblx0XHRcdGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG5cdFx0XHRcdHRoaXMucmVsZWFzZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0bW91c2V1cChlKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZShlKTtcblx0XHRcdHRoaXMucmVsZWFzZSgpO1xuXHRcdFx0aWYgKHRoaXMub25Db21wbGV0ZSkge1xuXHRcdFx0XHR0aGlzLm9uQ29tcGxldGUoKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHJlbGVhc2UoKSB7XG5cdFx0XHR0aGlzLmRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZ2dpbmctJyArIHRoaXMuYXR0cik7XG5cdFx0XHRjb25zdCBldmVudHMgPSB0aGlzLmV2ZW50cztcblx0XHRcdHRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcblx0XHRcdFx0J21vdXNlbW92ZScsXG5cdFx0XHRcdGV2ZW50cy5tb3VzZW1vdmUsXG5cdFx0XHRcdGZhbHNlXG5cdFx0XHQpO1xuXHRcdFx0dGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXZlbnRzLmtleWRvd24sIGZhbHNlKTtcblx0XHRcdHRoaXMuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGV2ZW50cy5tb3VzZXVwLCBmYWxzZSk7XG5cdFx0XHRpZiAodGhpcy5vblJlbGVhc2UpIHtcblx0XHRcdFx0dGhpcy5vblJlbGVhc2UoKTtcblx0XHRcdH1cblx0XHR9LFxuXHR9O1xuXG5cdC8vIGhlbHBlciBmdW5jdGlvbnNcblx0ZnVuY3Rpb24gdG9BcnJheShvYmopIHtcblx0XHRjb25zdCBsZW4gPSBvYmoubGVuZ3RoO1xuXG5cdFx0Y29uc3QgYXJyID0gbmV3IEFycmF5KGxlbik7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0YXJyW2ldID0gb2JqW2ldO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyO1xuXHR9XG5cblx0ZnVuY3Rpb24gYmluZChmbiwgY3R4KSB7XG5cdFx0aWYgKGZuLmJpbmQpIHtcblx0XHRcdHJldHVybiBmbi5iaW5kKGN0eCk7XG5cdFx0fVxuXHRcdHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG5cdFx0XHRmbi5hcHBseShjdHgsIGFyZ3MpO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBwb3NpdGlvbkVsZW1lbnQoZWwsIGxlZnQsIHRvcCkge1xuXHRcdGVsLnN0eWxlLmxlZnQgPSBTdHJpbmcobGVmdCkgKyAncHgnO1xuXHRcdGVsLnN0eWxlLnRvcCA9IFN0cmluZyh0b3ApICsgJ3B4Jztcblx0fVxuXG5cdGZ1bmN0aW9uIHJlc2l6ZUVsZW1lbnQoZWwsIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRjb25zdCBpbWFnZVNjYWxlUmVzaXplID0gdGhpcy5lZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemU7XG5cdFx0aWYgKGltYWdlU2NhbGVSZXNpemUgPT09ICdib3RoJykge1xuXHRcdFx0ZWwuc3R5bGUud2lkdGggPSBTdHJpbmcod2lkdGgpICsgJ3B4Jztcblx0XHRcdGVsLnN0eWxlLmhlaWdodCA9IFN0cmluZyhoZWlnaHQpICsgJ3B4Jztcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0aW1hZ2VTY2FsZVJlc2l6ZSA9PT0gJ3dpZHRoJyB8fFxuXHRcdFx0aW1hZ2VTY2FsZVJlc2l6ZSA9PT0gJ3NjYWxlJ1xuXHRcdCkge1xuXHRcdFx0ZWwuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuXHRcdFx0ZWwuc3R5bGUud2lkdGggPSBTdHJpbmcod2lkdGgpICsgJ3B4Jztcblx0XHR9IGVsc2UgaWYgKGltYWdlU2NhbGVSZXNpemUgPT09ICdoZWlnaHQnKSB7XG5cdFx0XHRlbC5zdHlsZS5oZWlnaHQgPSBTdHJpbmcoaGVpZ2h0KSArICdweCc7XG5cdFx0XHRlbC5zdHlsZS53aWR0aCA9ICdhdXRvJztcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRCb3VuZGluZ0JveCh3aW5kb3csIGVsKSB7XG5cdFx0Y29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQsXG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxuXHRcdFx0d2lkdGg6IHJlY3Qud2lkdGgsXG5cdFx0XHRoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuXHRcdH07XG5cdH1cbn1cbiIsIi8qKlxuICogQ0tFZGl0b3IgcGx1Z2luOiBJbWFnZTJcbiAqIC0gU2hvdyBncmlwcGVyIHRvIHJlc2l6ZSBpbWFnZXMgb24gSUVcbiAqL1xuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfZHJhZ3Jlc2l6ZV9pZScpKSB7XG5cdGNvbnN0IGFsaWdubWVudHNPYmogPSB7XG5cdFx0Y2VudGVyOiAxLFxuXHRcdGxlZnQ6IDAsXG5cdFx0cmlnaHQ6IDIsXG5cdH07XG5cblx0Lypcblx0ICogU2V0IGN1cnNvciBjc3MgZGVwZW5kIG9uIGltYWdlU2NhbGVSZXNpemUgY29uZmlnXG5cdCAqKi9cblxuXHRjb25zdCBjdXJzb3IgPSB7XG5cdFx0Ym90aDogJ253c2UtcmVzaXplJyxcblx0XHRoZWlnaHQ6ICducy1yZXNpemUnLFxuXHRcdHNjYWxlOiAnbndzZS1yZXNpemUnLFxuXHRcdHdpZHRoOiAnZXctcmVzaXplJyxcblx0fTtcblxuXHRjb25zdCByZWdleFBlcmNlbnQgPSAvXlxccyooXFxkKyUpXFxzKiQvaTtcblxuXHRjb25zdCB0ZW1wbGF0ZSA9ICc8aW1nIGFsdD1cIlwiIHNyYz1cIlwiIC8+JztcblxuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfZHJhZ3Jlc2l6ZV9pZScsIHtcblx0XHRoaWRwaTogdHJ1ZSxcblxuXHRcdGljb25zOiAnaW1hZ2UnLFxuXG5cdFx0aW5pdChlZGl0b3IpIHtcblx0XHRcdGNvbnN0IGltYWdlID0gd2lkZ2V0RGVmKGVkaXRvcik7XG5cblx0XHRcdC8vIFJlZ2lzdGVyIHRoZSB3aWRnZXQuXG5cdFx0XHRlZGl0b3Iud2lkZ2V0cy5hZGQoJ2ltYWdlJywgaW1hZ2UpO1xuXHRcdH0sXG5cblx0XHRvbkxvYWQoKSB7XG5cdFx0XHRDS0VESVRPUi5hZGRDc3MoXG5cdFx0XHRcdCcuY2tlX2ltYWdlX3Jlc2l6ZXJfbndzZS1yZXNpemV7JyArXG5cdFx0XHRcdFx0J2N1cnNvcjogbndzZS1yZXNpemU7JyArXG5cdFx0XHRcdFx0J30nICtcblx0XHRcdFx0XHQnLmNrZV9pbWFnZV9yZXNpemVyX25zLXJlc2l6ZXsnICtcblx0XHRcdFx0XHQnY3Vyc29yOiBucy1yZXNpemU7JyArXG5cdFx0XHRcdFx0J30nICtcblx0XHRcdFx0XHQnLmNrZV9pbWFnZV9yZXNpemVyX253c2UtcmVzaXpleycgK1xuXHRcdFx0XHRcdCdjdXJzb3I6IG53c2UtcmVzaXplOycgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Jy5ja2VfaW1hZ2VfcmVzaXplcl9ldy1yZXNpemV7JyArXG5cdFx0XHRcdFx0J2N1cnNvcjogZXctcmVzaXplOycgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Jy5ja2VfaW1hZ2Vfbm9jYXB0aW9ueycgK1xuXHRcdFx0XHRcdC8vIFRoaXMgaXMgdG8gcmVtb3ZlIHVud2FudGVkIHNwYWNlIHNvIHJlc2l6ZVxuXHRcdFx0XHRcdC8vIHdyYXBwZXIgaXMgZGlzcGxheWVkIHByb3BlcnR5LlxuXHRcdFx0XHRcdCdsaW5lLWhlaWdodDowJyArXG5cdFx0XHRcdFx0J30nICtcblx0XHRcdFx0XHQnLmNrZV9pbWFnZV9yZXNpemVyeycgK1xuXHRcdFx0XHRcdCdkaXNwbGF5Om5vbmU7JyArXG5cdFx0XHRcdFx0J3Bvc2l0aW9uOmFic29sdXRlOycgK1xuXHRcdFx0XHRcdCd3aWR0aDoxMHB4OycgK1xuXHRcdFx0XHRcdCdoZWlnaHQ6MTBweDsnICtcblx0XHRcdFx0XHQnYm90dG9tOi01cHg7JyArXG5cdFx0XHRcdFx0J3JpZ2h0Oi01cHg7JyArXG5cdFx0XHRcdFx0J2JhY2tncm91bmQ6IzAwMDsnICtcblx0XHRcdFx0XHQnb3V0bGluZToxcHggc29saWQgI2ZmZjsnICtcblx0XHRcdFx0XHQvLyBQcmV2ZW50IGRyYWcgaGFuZGxlciBmcm9tIGJlaW5nIG1pc3BsYWNlZCAoIzExMjA3KS5cblx0XHRcdFx0XHQnbGluZS1oZWlnaHQ6MDsnICtcblx0XHRcdFx0XHQnY3Vyc29yOm53c2UtcmVzaXplOycgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Jy5ja2VfaW1hZ2VfcmVzaXplcl93cmFwcGVyeycgK1xuXHRcdFx0XHRcdCdwb3NpdGlvbjpyZWxhdGl2ZTsnICtcblx0XHRcdFx0XHQnZGlzcGxheTppbmxpbmUtYmxvY2s7JyArXG5cdFx0XHRcdFx0J2xpbmUtaGVpZ2h0OjA7JyArXG5cdFx0XHRcdFx0J30nICtcblx0XHRcdFx0XHQnLmNrZV93aWRnZXRfd3JhcHBlcjpob3ZlciAuY2tlX2ltYWdlX3Jlc2l6ZXIsJyArXG5cdFx0XHRcdFx0Jy5ja2VfaW1hZ2VfcmVzaXplci5ja2VfaW1hZ2VfcmVzaXppbmd7JyArXG5cdFx0XHRcdFx0J2Rpc3BsYXk6YmxvY2snICtcblx0XHRcdFx0XHQnfSdcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdHJlcXVpcmVzOiAnd2lkZ2V0Jyxcblx0fSk7XG5cblx0Ly8gV2lkZ2V0IHN0YXRlcyAoZm9ybXMpIGRlcGVuZGluZyBvbiBhbGlnbm1lbnQgYW5kIGNvbmZpZ3VyYXRpb24uXG5cdC8vXG5cdC8vIE5vbi1jYXB0aW9uZWQgd2lkZ2V0IChpbmxpbmUgc3R5bGVzKVxuXHQvLyBcdFx04pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG5cdC8vIFx0XHTilIJBbGlnbiDilIJJbnRlcm5hbCBmb3JtICAgICAgICAgICAgICAgICAg4pSCRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCbm9uZSAg4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgIOKUgjxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJsZWZ0ICDilII8d3JhcHBlciBzdHlsZT3igJ1mbG9hdDpsZWZ04oCdPiAgIOKUgjxpbWcgc3R5bGU94oCdZmxvYXQ6bGVmdOKAnSAvPiAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCY2VudGVy4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgIOKUgjxwIHN0eWxlPeKAnXRleHQtYWxpZ246Y2VudGVy4oCdPuKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxwIHN0eWxlPeKAnXRleHQtYWxpZ246Y2VudGVy4oCdPiDilIIgIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCICAgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgIOKUgjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJyaWdodCDilII8d3JhcHBlciBzdHlsZT3igJ1mbG9hdDpyaWdodOKAnT4gIOKUgjxpbWcgc3R5bGU94oCdZmxvYXQ6cmlnaHTigJ0gLz4gIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuXHQvL1xuXHQvLyBOb24tY2FwdGlvbmVkIHdpZGdldCAoY29uZmlnLmltYWdlMl9hbGlnbkNsYXNzZXMgZGVmaW5lZClcblx0Ly8gXHRcdOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuXHQvLyBcdFx04pSCQWxpZ24g4pSCSW50ZXJuYWwgZm9ybSAgICAgICAgICAgICAgICAgIOKUgkRhdGEgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgm5vbmUgIOKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICDilII8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCbGVmdCAg4pSCPHdyYXBwZXIgY2xhc3M94oCdbGVmdOKAnT4gICAgICAgICDilII8aW1nIGNsYXNzPeKAnWxlZnTigJ0gLz4gICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgmNlbnRlcuKUgjx3cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICDilII8cCBjbGFzcz3igJ1jZW50ZXLigJ0+ICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8cCBjbGFzcz3igJ1jZW50ZXLigJ0+ICAgICAgICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiAgIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICDilII8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCcmlnaHQg4pSCPHdyYXBwZXIgY2xhc3M94oCdcmlnaHTigJ0+ICAgICAgICDilII8aW1nIGNsYXNzPeKAnXJpZ2h04oCdIC8+ICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJTilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcblx0Ly9cblx0Ly8gQ2FwdGlvbmVkIHdpZGdldCAoaW5saW5lIHN0eWxlcylcblx0Ly8gXHRcdOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuXHQvLyBcdFx04pSCQWxpZ24g4pSCSW50ZXJuYWwgZm9ybSAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgkRhdGEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCbm9uZSAg4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgjxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJsZWZ0ICDilII8d3JhcHBlciBzdHlsZT3igJ1mbG9hdDpsZWZ04oCdPiAgICAgICAgICAgIOKUgjxmaWd1cmUgc3R5bGU94oCdZmxvYXQ6bGVmdOKAnSAvPiAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCY2VudGVy4pSCPHdyYXBwZXIgc3R5bGU94oCddGV4dC1hbGlnbjpjZW50ZXLigJ0+ICAgICDilII8ZGl2IHN0eWxlPeKAnXRleHQtYWxpZ246Y2VudGVy4oCdPiAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgc3R5bGU94oCdZGlzcGxheTppbmxpbmUtYmxvY2vigJ0gLz7ilIIgPGZpZ3VyZSBzdHlsZT3igJ1kaXNwbGF5OmlubGluZS1ibG9ja+KAnSAvPuKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCcmlnaHQg4pSCPHdyYXBwZXIgc3R5bGU94oCdZmxvYXQ6cmlnaHTigJ0+ICAgICAgICAgICDilII8ZmlndXJlIHN0eWxlPeKAnWZsb2F0OnJpZ2h04oCdIC8+ICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJTilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcblx0Ly9cblx0Ly8gQ2FwdGlvbmVkIHdpZGdldCAoY29uZmlnLmltYWdlMl9hbGlnbkNsYXNzZXMgZGVmaW5lZClcblx0Ly8gXHRcdOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuXHQvLyBcdFx04pSCQWxpZ24g4pSCSW50ZXJuYWwgZm9ybSAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgkRhdGEgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCbm9uZSAg4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgjxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJsZWZ0ICDilII8d3JhcHBlciBjbGFzcz3igJ1sZWZ04oCdPiAgICAgICAgICAgICAgICAgIOKUgjxmaWd1cmUgY2xhc3M94oCdbGVmdOKAnSAvPiAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCY2VudGVy4pSCPHdyYXBwZXIgY2xhc3M94oCdY2VudGVy4oCdPiAgICAgICAgICAgICAgICDilII8ZGl2IGNsYXNzPeKAnWNlbnRlcuKAnT4gICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilII8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgnJpZ2h0IOKUgjx3cmFwcGVyIGNsYXNzPeKAnXJpZ2h04oCdPiAgICAgICAgICAgICAgICAg4pSCPGZpZ3VyZSBjbGFzcz3igJ1yaWdodOKAnSAvPiAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSU4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG5cdC8vXG5cdC8vIEBwYXJhbSB7Q0tFRElUT1IuZWRpdG9yfVxuXHQvLyBAcmV0dXJucyB7T2JqZWN0fVxuXHRmdW5jdGlvbiB3aWRnZXREZWYoZWRpdG9yKSB7XG5cdFx0ZWRpdG9yLmNvbmZpZy5pbWFnZVNjYWxlUmVzaXplID1cblx0XHRcdGVkaXRvci5jb25maWcuaW1hZ2VTY2FsZVJlc2l6ZSB8fCAnYm90aCc7XG5cblx0XHRlZGl0b3Iub24oJ2ltYWdlQWRkJywgZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG5cdFx0XHRlZGl0b3Iud2lkZ2V0cy5pbml0T24oaW1hZ2VEYXRhLmRhdGEuZWwsICdpbWFnZScpO1xuXHRcdH0pO1xuXG5cdFx0Y29uc3QgYWxpZ25DbGFzc2VzID0gZWRpdG9yLmNvbmZpZy5pbWFnZTJfYWxpZ25DbGFzc2VzO1xuXG5cdFx0Y29uc3QgY2FwdGlvbmVkQ2xhc3MgPSBlZGl0b3IuY29uZmlnLmltYWdlMl9jYXB0aW9uZWRDbGFzcztcblxuXHRcdHJldHVybiB7XG5cdFx0XHRpbml0KCkge1xuXHRcdFx0XHRjb25zdCBoZWxwZXJzID0gQ0tFRElUT1IucGx1Z2lucy5pbWFnZTI7XG5cblx0XHRcdFx0Y29uc3QgaW1hZ2UgPSB0aGlzLnBhcnRzLmltYWdlO1xuXG5cdFx0XHRcdGNvbnN0IGRhdGEgPSB7XG5cdFx0XHRcdFx0YWx0OiBpbWFnZS5nZXRBdHRyaWJ1dGUoJ2FsdCcpIHx8ICcnLFxuXHRcdFx0XHRcdGhhc0NhcHRpb246ICEhdGhpcy5wYXJ0cy5jYXB0aW9uLFxuXHRcdFx0XHRcdGhlaWdodDogaW1hZ2UuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSB8fCAnJyxcblx0XHRcdFx0XHQvLyBMb2NrIHJhdGlvIGlzIG9uIGJ5IGRlZmF1bHQgKCMxMDgzMykuXG5cdFx0XHRcdFx0bG9jazogdGhpcy5yZWFkeVxuXHRcdFx0XHRcdFx0PyBoZWxwZXJzLmNoZWNrSGFzTmF0dXJhbFJhdGlvKGltYWdlKVxuXHRcdFx0XHRcdFx0OiB0cnVlLFxuXHRcdFx0XHRcdHNyYzogaW1hZ2UuZ2V0QXR0cmlidXRlKCdzcmMnKSxcblx0XHRcdFx0XHR3aWR0aDogaW1hZ2UuZ2V0QXR0cmlidXRlKCd3aWR0aCcpIHx8ICcnLFxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIElmIHdlIHVzZWQgJ2EnIGluIHdpZGdldCNwYXJ0cyBkZWZpbml0aW9uLCBpdCBjb3VsZCBoYXBwZW4gdGhhdFxuXHRcdFx0XHQvLyBzZWxlY3RlZCBlbGVtZW50IGlzIGEgY2hpbGQgb2Ygd2lkZ2V0LnBhcnRzI2NhcHRpb24uIFNpbmNlIHRoZXJlJ3Mgbm8gY2xldmVyXG5cdFx0XHRcdC8vIHdheSB0byBzb2x2ZSBpdCB3aXRoIENTUyBzZWxlY3RvcnMsIGl0J3MgZG9uZSBsaWtlIHRoYXQuICgjMTE3ODMpLlxuXHRcdFx0XHRjb25zdCBsaW5rID0gaW1hZ2UuZ2V0QXNjZW5kYW50KCdhJyk7XG5cblx0XHRcdFx0aWYgKGxpbmsgJiYgdGhpcy53cmFwcGVyLmNvbnRhaW5zKGxpbmspKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXJ0cy5saW5rID0gbGluaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIERlcGVuZGluZyBvbiBjb25maWd1cmF0aW9uLCByZWFkIHN0eWxlL2NsYXNzIGZyb20gZWxlbWVudCBhbmRcblx0XHRcdFx0Ly8gdGhlbiByZW1vdmUgaXQuIFJlbW92ZWQgc3R5bGUvY2xhc3Mgd2lsbCBiZSBzZXQgb24gd3JhcHBlciBpbiAjZGF0YSBsaXN0ZW5lci5cblx0XHRcdFx0Ly8gTm90ZTogQ2VudGVyIGFsaWdubWVudCBpcyBkZXRlY3RlZCBkdXJpbmcgdXBjYXN0LCBzbyBvbmx5IGxlZnQvcmlnaHQgY2FzZXNcblx0XHRcdFx0Ly8gYXJlIGNoZWNrZWQgYmVsb3cuXG5cdFx0XHRcdGlmICghZGF0YS5hbGlnbikge1xuXHRcdFx0XHRcdGNvbnN0IGFsaWduRWxlbWVudCA9IGRhdGEuaGFzQ2FwdGlvbiA/IHRoaXMuZWxlbWVudCA6IGltYWdlO1xuXG5cdFx0XHRcdFx0Ly8gUmVhZCB0aGUgaW5pdGlhbCBsZWZ0L3JpZ2h0IGFsaWdubWVudCBmcm9tIHRoZSBjbGFzcyBzZXQgb24gZWxlbWVudC5cblx0XHRcdFx0XHRpZiAoYWxpZ25DbGFzc2VzKSB7XG5cdFx0XHRcdFx0XHRpZiAoYWxpZ25FbGVtZW50Lmhhc0NsYXNzKGFsaWduQ2xhc3Nlc1swXSkpIHtcblx0XHRcdFx0XHRcdFx0ZGF0YS5hbGlnbiA9ICdsZWZ0Jztcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYWxpZ25FbGVtZW50Lmhhc0NsYXNzKGFsaWduQ2xhc3Nlc1syXSkpIHtcblx0XHRcdFx0XHRcdFx0ZGF0YS5hbGlnbiA9ICdyaWdodCc7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChkYXRhLmFsaWduKSB7XG5cdFx0XHRcdFx0XHRcdGFsaWduRWxlbWVudC5yZW1vdmVDbGFzcyhcblx0XHRcdFx0XHRcdFx0XHRhbGlnbkNsYXNzZXNbYWxpZ25tZW50c09ialtkYXRhLmFsaWduXV1cblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGRhdGEuYWxpZ24gPSAnbm9uZSc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFJlYWQgaW5pdGlhbCBmbG9hdCBzdHlsZSBmcm9tIGZpZ3VyZS9pbWFnZSBhbmQgdGhlbiByZW1vdmUgaXQuXG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRkYXRhLmFsaWduID0gYWxpZ25FbGVtZW50LmdldFN0eWxlKCdmbG9hdCcpIHx8ICdub25lJztcblx0XHRcdFx0XHRcdGFsaWduRWxlbWVudC5yZW1vdmVTdHlsZSgnZmxvYXQnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgcmlkIG9mIGV4dHJhIHZlcnRpY2FsIHNwYWNlIHdoZW4gdGhlcmUncyBubyBjYXB0aW9uLlxuXHRcdFx0XHQvLyBJdCB3aWxsIGltcHJvdmUgdGhlIGxvb2sgb2YgdGhlIHJlc2l6ZXIuXG5cdFx0XHRcdHRoaXMud3JhcHBlclsoZGF0YS5oYXNDYXB0aW9uID8gJ3JlbW92ZScgOiAnYWRkJykgKyAnQ2xhc3MnXShcblx0XHRcdFx0XHQnY2tlX2ltYWdlX25vY2FwdGlvbidcblx0XHRcdFx0KTtcblxuXHRcdFx0XHR0aGlzLnNldERhdGEoZGF0YSk7XG5cblx0XHRcdFx0aWYgKGVkaXRvci5jb25maWcuaW1hZ2UyX2Rpc2FibGVSZXNpemVyICE9PSB0cnVlKSB7XG5cdFx0XHRcdFx0c2V0dXBSZXNpemVyKHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBPdmVycmlkZXMgZGVmYXVsdCBtZXRob2QgdG8gaGFuZGxlIGludGVybmFsIG11dGFiaWxpdHkgb2YgSW1hZ2UyLlxuXHRcdFx0Ly8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNhZGRDbGFzc1xuXHRcdFx0YWRkQ2xhc3MoY2xhc3NOYW1lKSB7XG5cdFx0XHRcdGdldFN0eWxlYWJsZUVsZW1lbnQodGhpcykuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcblx0XHRcdH0sXG5cblx0XHRcdGFsbG93ZWRDb250ZW50OiBnZXRXaWRnZXRBbGxvd2VkQ29udGVudChlZGl0b3IpLFxuXG5cdFx0XHQvLyBUaGlzIHdpZGdldCBjb252ZXJ0cyBzdHlsZS1kcml2ZW4gZGltZW5zaW9ucyB0byBhdHRyaWJ1dGVzLlxuXHRcdFx0Y29udGVudFRyYW5zZm9ybWF0aW9uczogW1snaW1nW3dpZHRoXTogc2l6ZVRvQXR0cmlidXRlJ11dLFxuXG5cdFx0XHRkYXRhKCkge1xuXHRcdFx0XHRjb25zdCBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXM7XG5cblx0XHRcdFx0Ly8gSW1hZ2UgY2FuJ3QgYmUgY2FwdGlvbmVkIHdoZW4gZmlnY2FwdGlvbiBpcyBkaXNhbGxvd2VkICgjMTEwMDQpLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy5kYXRhLmhhc0NhcHRpb24gJiZcblx0XHRcdFx0XHQhZWRpdG9yLmZpbHRlci5jaGVja0ZlYXR1cmUoZmVhdHVyZXMuY2FwdGlvbilcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmhhc0NhcHRpb24gPSBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEltYWdlIGNhbid0IGJlIGFsaWduZWQgd2hlbiBmbG9hdGluZyBpcyBkaXNhbGxvd2VkICgjMTEwMDQpLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy5kYXRhLmFsaWduICE9ICdub25lJyAmJlxuXHRcdFx0XHRcdCFlZGl0b3IuZmlsdGVyLmNoZWNrRmVhdHVyZShmZWF0dXJlcy5hbGlnbilcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0dGhpcy5kYXRhLmFsaWduID0gJ25vbmUnO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVXBkYXRlIHdpZGdldC5wYXJ0cy5saW5rIHNpbmNlIGl0IHdpbGwgbm90IGF1dG8tdXBkYXRlIHVubGVzcyB3aWRnZXRcblx0XHRcdFx0Ly8gaXMgZGVzdHJveWVkIGFuZCByZS1pbml0ZWQuXG5cdFx0XHRcdGlmICghdGhpcy5kYXRhLmxpbmspIHtcblx0XHRcdFx0XHRpZiAodGhpcy5wYXJ0cy5saW5rKSB7XG5cdFx0XHRcdFx0XHRkZWxldGUgdGhpcy5wYXJ0cy5saW5rO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIXRoaXMucGFydHMubGluaykge1xuXHRcdFx0XHRcdFx0dGhpcy5wYXJ0cy5saW5rID0gdGhpcy5wYXJ0cy5pbWFnZS5nZXRQYXJlbnQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnBhcnRzLmltYWdlLnNldEF0dHJpYnV0ZXMoe1xuXHRcdFx0XHRcdGFsdDogdGhpcy5kYXRhLmFsdCxcblxuXHRcdFx0XHRcdGNvbnRlbnRlZGl0YWJsZTogdGhpcy5wYXJ0cy5pbWFnZS5nZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0XHQnY29udGVudGVkaXRhYmxlJ1xuXHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdD8gdGhpcy5wYXJ0cy5pbWFnZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpXG5cdFx0XHRcdFx0XHQ6IHRydWUsXG5cblx0XHRcdFx0XHQvLyBUaGlzIGludGVybmFsIGlzIHJlcXVpcmVkIGJ5IHRoZSBlZGl0b3IuXG5cdFx0XHRcdFx0J2RhdGEtY2tlLXNhdmVkLXNyYyc6IHRoaXMuZGF0YS5zcmMsXG5cblx0XHRcdFx0XHRzcmM6IHRoaXMuZGF0YS5zcmMsXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIElmIHNoaWZ0aW5nIG5vbi1jYXB0aW9uZWQgLT4gY2FwdGlvbmVkLCByZW1vdmUgY2xhc3Nlc1xuXHRcdFx0XHQvLyByZWxhdGVkIHRvIHN0eWxlcyBmcm9tIDxpbWcvPi5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMub2xkRGF0YSAmJlxuXHRcdFx0XHRcdCF0aGlzLm9sZERhdGEuaGFzQ2FwdGlvbiAmJlxuXHRcdFx0XHRcdHRoaXMuZGF0YS5oYXNDYXB0aW9uXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGZvciAoY29uc3QgYyBpbiB0aGlzLmRhdGEuY2xhc3Nlcykge1xuXHRcdFx0XHRcdFx0aWYgKHRoaXMuZGF0YS5jbGFzc2VzLmhhc093blByb3BlcnR5KGMpKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMucGFydHMuaW1hZ2UucmVtb3ZlQ2xhc3MoYyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGRpbWVuc2lvbnMgb2YgdGhlIGltYWdlIGFjY29yZGluZyB0byBnYXRoZXJlZCBkYXRhLlxuXHRcdFx0XHQvLyBEbyBpdCBvbmx5IHdoZW4gdGhlIGF0dHJpYnV0ZXMgYXJlIGFsbG93ZWQgKCMxMTAwNCkuXG5cdFx0XHRcdGlmIChlZGl0b3IuZmlsdGVyLmNoZWNrRmVhdHVyZShmZWF0dXJlcy5kaW1lbnNpb24pKSB7XG5cdFx0XHRcdFx0c2V0RGltZW5zaW9ucyh0aGlzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhY2hlIGN1cnJlbnQgZGF0YS5cblx0XHRcdFx0dGhpcy5vbGREYXRhID0gQ0tFRElUT1IudG9vbHMuZXh0ZW5kKHt9LCB0aGlzLmRhdGEpO1xuXHRcdFx0fSxcblxuXHRcdFx0ZG93bmNhc3Q6IGRvd25jYXN0V2lkZ2V0RWxlbWVudChlZGl0b3IpLFxuXG5cdFx0XHRkcmFnZ2FibGU6IGZhbHNlLFxuXG5cdFx0XHQvLyBUaGlzIHdpZGdldCBoYXMgYW4gZWRpdGFibGUgY2FwdGlvbi5cblx0XHRcdGVkaXRhYmxlczoge1xuXHRcdFx0XHRjYXB0aW9uOiB7XG5cdFx0XHRcdFx0c2VsZWN0b3I6ICdmaWdjYXB0aW9uJyxcblx0XHRcdFx0XHRhbGxvd2VkQ29udGVudDogJ2JyIGVtIHN0cm9uZyBzdWIgc3VwIHUgczsgYVshaHJlZix0YXJnZXRdJyxcblx0XHRcdFx0fSxcblx0XHRcdH0sXG5cblx0XHRcdGZlYXR1cmVzOiBnZXRXaWRnZXRGZWF0dXJlcyhlZGl0b3IpLFxuXG5cdFx0XHQvLyBPdmVycmlkZXMgZGVmYXVsdCBtZXRob2QgdG8gaGFuZGxlIGludGVybmFsIG11dGFiaWxpdHkgb2YgSW1hZ2UyLlxuXHRcdFx0Ly8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNnZXRDbGFzc2VzXG5cdFx0XHRnZXRDbGFzc2VzOiAoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbnN0IGNsYXNzUmVnZXggPSBuZXcgUmVnRXhwKFxuXHRcdFx0XHRcdCdeKCcgK1xuXHRcdFx0XHRcdFx0W10uY29uY2F0KGNhcHRpb25lZENsYXNzLCBhbGlnbkNsYXNzZXMpLmpvaW4oJ3wnKSArXG5cdFx0XHRcdFx0XHQnKSQnXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGNvbnN0IGNsYXNzZXMgPSB0aGlzLnJlcG9zaXRvcnkucGFyc2VFbGVtZW50Q2xhc3Nlcyhcblx0XHRcdFx0XHRcdGdldFN0eWxlYWJsZUVsZW1lbnQodGhpcykuZ2V0QXR0cmlidXRlKCdjbGFzcycpXG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdC8vIE5laXRoZXIgY29uZmlnLmltYWdlMl9jYXB0aW9uZWRDbGFzcyBub3IgY29uZmlnLmltYWdlMl9hbGlnbkNsYXNzZXNcblx0XHRcdFx0XHQvLyBkbyBub3QgYmVsb25nIHRvIHN0eWxlIGNsYXNzZXMuXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBjIGluIGNsYXNzZXMpIHtcblx0XHRcdFx0XHRcdGlmIChjbGFzc1JlZ2V4LnRlc3QoYykpIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGNsYXNzZXNbY107XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGNsYXNzZXM7XG5cdFx0XHRcdH07XG5cdFx0XHR9KSgpLFxuXG5cdFx0XHRnZXRMYWJlbCgpIHtcblx0XHRcdFx0Y29uc3QgbGFiZWwgPSAodGhpcy5kYXRhLmFsdCB8fCAnJykgKyAnICcgKyB0aGlzLnBhdGhOYW1lO1xuXG5cdFx0XHRcdHJldHVybiBsYWJlbDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIE92ZXJyaWRlcyBkZWZhdWx0IG1ldGhvZCB0byBoYW5kbGUgaW50ZXJuYWwgbXV0YWJpbGl0eSBvZiBJbWFnZTIuXG5cdFx0XHQvLyBAc2VlIENLRURJVE9SLnBsdWdpbnMud2lkZ2V0I2hhc0NsYXNzXG5cdFx0XHRoYXNDbGFzcyhjbGFzc05hbWUpIHtcblx0XHRcdFx0cmV0dXJuIGdldFN0eWxlYWJsZUVsZW1lbnQodGhpcykuaGFzQ2xhc3MoY2xhc3NOYW1lKTtcblx0XHRcdH0sXG5cblx0XHRcdHBhcnRzOiB7XG5cdFx0XHRcdGNhcHRpb246ICdmaWdjYXB0aW9uJyxcblx0XHRcdFx0aW1hZ2U6ICdpbWcnLFxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gT3ZlcnJpZGVzIGRlZmF1bHQgbWV0aG9kIHRvIGhhbmRsZSBpbnRlcm5hbCBtdXRhYmlsaXR5IG9mIEltYWdlMi5cblx0XHRcdC8vIEBzZWUgQ0tFRElUT1IucGx1Z2lucy53aWRnZXQjcmVtb3ZlQ2xhc3Ncblx0XHRcdHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge1xuXHRcdFx0XHRnZXRTdHlsZWFibGVFbGVtZW50KHRoaXMpLnJlbW92ZUNsYXNzKGNsYXNzTmFtZSk7XG5cdFx0XHR9LFxuXG5cdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICdpbWdbc3JjLGFsdF0nLFxuXG5cdFx0XHRzdHlsZWFibGVFbGVtZW50czogJ2ltZyBmaWd1cmUnLFxuXG5cdFx0XHQvLyBUZW1wbGF0ZSBvZiB0aGUgd2lkZ2V0OiBwbGFpbiBpbWFnZS5cblx0XHRcdHRlbXBsYXRlLFxuXG5cdFx0XHR1cGNhc3Q6IHVwY2FzdFdpZGdldEVsZW1lbnQoZWRpdG9yKSxcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2V0IG9mIEVuaGFuY2VkIEltYWdlIChpbWFnZTIpIHBsdWdpbiBoZWxwZXJzLlxuXHQgKlxuXHQgKiBAY2xhc3Ncblx0ICogQHNpbmdsZXRvblxuXHQgKi9cblx0Q0tFRElUT1IucGx1Z2lucy5pbWFnZTIgPSB7XG5cdFx0LyoqXG5cdFx0ICogQ2hlY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgaW1hZ2UgcmF0aW8gbWF0Y2hlcyB0aGUgbmF0dXJhbCBvbmVcblx0XHQgKiBieSBjb21wYXJpbmcgZGltZW5zaW9ucy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGltYWdlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRjaGVja0hhc05hdHVyYWxSYXRpbyhpbWFnZSkge1xuXHRcdFx0Y29uc3QgJCA9IGltYWdlLiQ7XG5cblx0XHRcdGNvbnN0IG5hdHVyYWwgPSB0aGlzLmdldE5hdHVyYWwoaW1hZ2UpO1xuXG5cdFx0XHQvLyBUaGUgcmVhc29uIGZvciB0d28gYWx0ZXJuYXRpdmUgY29tcGFyaXNvbnMgaXMgdGhhdCB0aGUgcm91bmRpbmcgY2FuIGNvbWUgZnJvbVxuXHRcdFx0Ly8gYm90aCBkaW1lbnNpb25zLCBlLmcuIHRoZXJlIGFyZSB0d28gY2FzZXM6XG5cdFx0XHQvLyBcdDEuIGhlaWdodCBpcyBjb21wdXRlZCBhcyBhIHJvdW5kZWQgcmVsYXRpb24gb2YgdGhlIHJlYWwgaGVpZ2h0IGFuZCB0aGUgdmFsdWUgb2Ygd2lkdGgsXG5cdFx0XHQvL1x0Mi4gd2lkdGggaXMgY29tcHV0ZWQgYXMgYSByb3VuZGVkIHJlbGF0aW9uIG9mIHRoZSByZWFsIHdpZHRoIGFuZCB0aGUgdmFsdWUgb2YgaGVpZ2guXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRNYXRoLnJvdW5kKCgkLmNsaWVudFdpZHRoIC8gbmF0dXJhbC53aWR0aCkgKiBuYXR1cmFsLmhlaWdodCkgPT1cblx0XHRcdFx0XHQkLmNsaWVudEhlaWdodCB8fFxuXHRcdFx0XHRNYXRoLnJvdW5kKCgkLmNsaWVudEhlaWdodCAvIG5hdHVyYWwuaGVpZ2h0KSAqIG5hdHVyYWwud2lkdGgpID09XG5cdFx0XHRcdFx0JC5jbGllbnRXaWR0aFxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBuYXR1cmFsIGRpbWVuc2lvbnMgb2YgdGhlIGltYWdlLiBGb3IgbW9kZXJuIGJyb3dzZXJzXG5cdFx0ICogaXQgdXNlcyBuYXR1cmFsKFdpZHRofEhlaWdodCkuIEZvciBvbGQgb25lcyAoSUU4KSBpdCBjcmVhdGVzXG5cdFx0ICogYSBuZXcgaW1hZ2UgYW5kIHJlYWRzIHRoZSBkaW1lbnNpb25zLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gaW1hZ2Vcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0Z2V0TmF0dXJhbChpbWFnZSkge1xuXHRcdFx0bGV0IGRpbWVuc2lvbnM7XG5cblx0XHRcdGlmIChpbWFnZS4kLm5hdHVyYWxXaWR0aCkge1xuXHRcdFx0XHRkaW1lbnNpb25zID0ge1xuXHRcdFx0XHRcdGhlaWdodDogaW1hZ2UuJC5uYXR1cmFsSGVpZ2gsXG5cdFx0XHRcdFx0d2lkdGg6IGltYWdlLiQubmF0dXJhbFdpZHRoLFxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG5cblx0XHRcdFx0aW1nLnNyYyA9IGltYWdlLmdldEF0dHJpYnV0ZSgnc3JjJyk7XG5cblx0XHRcdFx0ZGltZW5zaW9ucyA9IHtcblx0XHRcdFx0XHRoZWlnaHQ6IGltZy5oZWlnaCxcblx0XHRcdFx0XHR3aWR0aDogaW1nLndpZHRoLFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGltZW5zaW9ucztcblx0XHR9LFxuXHR9O1xuXG5cdC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgd2lkZ2V0cyBmcm9tIGFsbCA8aW1nPiBhbmRcblx0Ly8gPGZpZ3VyZSBjbGFzcz1cIntjb25maWcuaW1hZ2UyX2NhcHRpb25lZENsYXNzfVwiPiBlbGVtZW50cy5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9IGVkaXRvclxuXHQvLyBAcmV0dXJucyB7RnVuY3Rpb259XG5cdGZ1bmN0aW9uIHVwY2FzdFdpZGdldEVsZW1lbnQoZWRpdG9yKSB7XG5cdFx0Y29uc3QgaXNDZW50ZXJXcmFwcGVyID0gY2VudGVyV3JhcHBlckNoZWNrZXIoZWRpdG9yKTtcblxuXHRcdGNvbnN0IGNhcHRpb25lZENsYXNzID0gZWRpdG9yLmNvbmZpZy5pbWFnZTJfY2FwdGlvbmVkQ2xhc3M7XG5cblx0XHQvLyBAcGFyYW0ge0NLRURJVE9SLmh0bWxQYXJzZXIuZWxlbWVudH0gZWxcblx0XHQvLyBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHRcdHJldHVybiBmdW5jdGlvbihlbCwgZGF0YSkge1xuXHRcdFx0Y29uc3QgZGltZW5zaW9ucyA9IHtcblx0XHRcdFx0aGVpZ2h0OiAxLFxuXHRcdFx0XHR3aWR0aDogMSxcblx0XHRcdH07XG5cblx0XHRcdGNvbnN0IG5hbWUgPSBlbC5uYW1lO1xuXG5cdFx0XHRsZXQgaW1hZ2U7XG5cblx0XHRcdC8vICMxMTExMCBEb24ndCBpbml0aWFsaXplIG9uIHBhc3RlZCBmYWtlIG9iamVjdHMuXG5cdFx0XHRpZiAoZWwuYXR0cmlidXRlc1snZGF0YS1ja2UtcmVhbGVsZW1lbnQnXSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgY2VudGVyIHdyYXBwZXIgaXMgZm91bmQsIHRoZXJlIGFyZSAzIHBvc3NpYmxlIGNhc2VzOlxuXHRcdFx0Ly9cblx0XHRcdC8vIDEuIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxmaWd1cmU+Li4uPC9maWd1cmU+PC9kaXY+LlxuXHRcdFx0Ly8gICAgSW4gdGhpcyBjYXNlIGNlbnRlcmluZyBpcyBkb25lIHdpdGggYSBjbGFzcyBzZXQgb24gd2lkZ2V0LndyYXBwZXIuXG5cdFx0XHQvLyAgICBTaW1wbHkgcmVwbGFjZSBjZW50ZXJpbmcgd3JhcHBlciB3aXRoIGZpZ3VyZSAoaXQncyBubyBsb25nZXIgbmVjZXNzYXJ5KS5cblx0XHRcdC8vXG5cdFx0XHQvLyAyLiA8cCBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZy8+PC9wPi5cblx0XHRcdC8vICAgIE5vdGhpbmcgdG8gZG8gaGVyZTogPHA+IHJlbWFpbnMgZm9yIHN0eWxpbmcgcHVycG9zZXMuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gMy4gPGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZy8+PC9kaXY+LlxuXHRcdFx0Ly8gICAgTm90aGluZyB0byBkbyBoZXJlICgyLikgYnV0IHRoYXQgY2FzZSBpcyBvbmx5IHBvc3NpYmxlIGluIGVudGVyTW9kZSBkaWZmZXJlbnRcblx0XHRcdC8vICAgIHRoYW4gRU5URVJfUC5cblx0XHRcdGlmIChpc0NlbnRlcldyYXBwZXIoZWwpKSB7XG5cdFx0XHRcdGlmIChuYW1lID09ICdkaXYnKSB7XG5cdFx0XHRcdFx0Y29uc3QgZmlndXJlID0gZWwuZ2V0Rmlyc3QoJ2ZpZ3VyZScpO1xuXG5cdFx0XHRcdFx0Ly8gQ2FzZSAjMS5cblx0XHRcdFx0XHRpZiAoZmlndXJlKSB7XG5cdFx0XHRcdFx0XHRlbC5yZXBsYWNlV2l0aChmaWd1cmUpO1xuXHRcdFx0XHRcdFx0ZWwgPSBmaWd1cmU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENhc2VzICMyIGFuZCAjMyAoaGFuZGxlZCB0cmFuc3BhcmVudGx5KVxuXG5cdFx0XHRcdC8vIElmIHRoZXJlJ3MgYSBjZW50ZXJpbmcgd3JhcHBlciwgc2F2ZSBpdCBpbiBkYXRhLlxuXHRcdFx0XHRkYXRhLmFsaWduID0gJ2NlbnRlcic7XG5cblx0XHRcdFx0Ly8gSW1hZ2UgY2FuIGJlIHdyYXBwZWQgaW4gbGluayA8YT48aW1nLz48L2E+LlxuXHRcdFx0XHRpbWFnZSA9IGVsLmdldEZpcnN0KCdpbWcnKSB8fCBlbC5nZXRGaXJzdCgnYScpLmdldEZpcnN0KCdpbWcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gY2VudGVyIHdyYXBwZXIgaGFzIGJlZW4gZm91bmQuXG5cdFx0XHRlbHNlIGlmIChuYW1lID09ICdmaWd1cmUnICYmIGVsLmhhc0NsYXNzKGNhcHRpb25lZENsYXNzKSkge1xuXHRcdFx0XHRpbWFnZSA9IGVsLmdldEZpcnN0KCdpbWcnKSB8fCBlbC5nZXRGaXJzdCgnYScpLmdldEZpcnN0KCdpbWcnKTtcblxuXHRcdFx0XHQvLyBVcGNhc3QgbGlua2VkIGltYWdlIGxpa2UgPGE+PGltZy8+PC9hPi5cblx0XHRcdH0gZWxzZSBpZiAoaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZShlbCkpIHtcblx0XHRcdFx0aW1hZ2UgPSBlbC5uYW1lID09ICdhJyA/IGVsLmNoaWxkcmVuWzBdIDogZWw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaW1hZ2UpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIGFuIGltYWdlLCB0aGVuIGNvb2wsIHdlIGdvdCBhIHdpZGdldC5cblx0XHRcdC8vIE5vdyBqdXN0IHJlbW92ZSBkaW1lbnNpb24gYXR0cmlidXRlcyBleHByZXNzZWQgd2l0aCAlLlxuXHRcdFx0Zm9yIChjb25zdCBkIGluIGRpbWVuc2lvbnMpIHtcblx0XHRcdFx0aWYgKGRpbWVuc2lvbnMuaGFzT3duUHJvcGVydHkoZCkpIHtcblx0XHRcdFx0XHRjb25zdCBkaW1lbnNpb24gPSBpbWFnZS5hdHRyaWJ1dGVzW2RdO1xuXG5cdFx0XHRcdFx0aWYgKGRpbWVuc2lvbiAmJiBkaW1lbnNpb24ubWF0Y2gocmVnZXhQZXJjZW50KSkge1xuXHRcdFx0XHRcdFx0ZGVsZXRlIGltYWdlLmF0dHJpYnV0ZXNbZF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbDtcblx0XHR9O1xuXHR9XG5cblx0Ly8gUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHdpZGdldCB0byB0aGUgZXh0ZXJuYWwgZm9ybWF0XG5cdC8vIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uLlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn1cblx0ZnVuY3Rpb24gZG93bmNhc3RXaWRnZXRFbGVtZW50KGVkaXRvcikge1xuXHRcdGNvbnN0IGFsaWduQ2xhc3NlcyA9IGVkaXRvci5jb25maWcuaW1hZ2UyX2FsaWduQ2xhc3NlcztcblxuXHRcdC8vIEBwYXJhbSB7Q0tFRElUT1IuaHRtbFBhcnNlci5lbGVtZW50fSBlbFxuXHRcdHJldHVybiBmdW5jdGlvbihlbCkge1xuXHRcdFx0Ly8gSW4gY2FzZSBvZiA8YT48aW1nLz48L2E+LCA8aW1nLz4gaXMgdGhlIGVsZW1lbnQgdG8gaG9sZFxuXHRcdFx0Ly8gaW5saW5lIHN0eWxlcyBvciBjbGFzc2VzIChpbWFnZTJfYWxpZ25DbGFzc2VzKS5cblx0XHRcdGNvbnN0IGF0dHJzSG9sZGVyID0gZWwubmFtZSA9PSAnYScgPyBlbC5nZXRGaXJzdCgpIDogZWw7XG5cblx0XHRcdGRlbGV0ZSBhdHRyc0hvbGRlci5hdHRyaWJ1dGVzLmNvbnRlbnRlZGl0YWJsZTtcblxuXHRcdFx0Y29uc3QgYXR0cnMgPSBhdHRyc0hvbGRlci5hdHRyaWJ1dGVzO1xuXG5cdFx0XHRjb25zdCBhbGlnbiA9IHRoaXMuZGF0YS5hbGlnbjtcblxuXHRcdFx0Ly8gRGUtd3JhcCB0aGUgaW1hZ2UgZnJvbSByZXNpemUgaGFuZGxlIHdyYXBwZXIuXG5cdFx0XHQvLyBPbmx5IGJsb2NrIHdpZGdldHMgaGF2ZSBvbmUuXG5cdFx0XHRpZiAoIXRoaXMuaW5saW5lKSB7XG5cdFx0XHRcdGNvbnN0IHJlc2l6ZVdyYXBwZXIgPSBlbC5nZXRGaXJzdCgnc3BhbicpO1xuXG5cdFx0XHRcdGlmIChyZXNpemVXcmFwcGVyKSB7XG5cdFx0XHRcdFx0cmVzaXplV3JhcHBlci5yZXBsYWNlV2l0aChcblx0XHRcdFx0XHRcdHJlc2l6ZVdyYXBwZXIuZ2V0Rmlyc3Qoe1xuXHRcdFx0XHRcdFx0XHRhOiAxLFxuXHRcdFx0XHRcdFx0XHRpbWc6IDEsXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKGFsaWduICYmIGFsaWduICE9ICdub25lJykge1xuXHRcdFx0XHRjb25zdCBzdHlsZXMgPSBDS0VESVRPUi50b29scy5wYXJzZUNzc1RleHQoYXR0cnMuc3R5bGUgfHwgJycpO1xuXG5cdFx0XHRcdC8vIFdoZW4gdGhlIHdpZGdldCBpcyBjYXB0aW9uZWQgKDxmaWd1cmU+KSBhbmQgaW50ZXJuYWxseSBjZW50ZXJpbmcgaXMgZG9uZVxuXHRcdFx0XHQvLyB3aXRoIHdpZGdldCdzIHdyYXBwZXIgc3R5bGUvY2xhc3MsIGluIHRoZSBleHRlcm5hbCBkYXRhIHJlcHJlc2VudGF0aW9uLFxuXHRcdFx0XHQvLyA8ZmlndXJlPiBtdXN0IGJlIHdyYXBwZWQgd2l0aCBhbiBlbGVtZW50IGhvbGRpbmcgYW4gc3R5bGUvY2xhc3M6XG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIFx0PGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+XG5cdFx0XHRcdC8vIFx0XHQ8ZmlndXJlIGNsYXNzPVwiaW1hZ2VcIiBzdHlsZT1cImRpc3BsYXk6aW5saW5lLWJsb2NrXCI+Li4uPC9maWd1cmU+XG5cdFx0XHRcdC8vIFx0PC9kaXY+XG5cdFx0XHRcdC8vIG9yXG5cdFx0XHRcdC8vIFx0PGRpdiBjbGFzcz1cInNvbWUtY2VudGVyLWNsYXNzXCI+XG5cdFx0XHRcdC8vIFx0XHQ8ZmlndXJlIGNsYXNzPVwiaW1hZ2VcIj4uLi48L2ZpZ3VyZT5cblx0XHRcdFx0Ly8gXHQ8L2Rpdj5cblx0XHRcdFx0Ly9cblx0XHRcdFx0aWYgKGFsaWduID09ICdjZW50ZXInICYmIGVsLm5hbWUgPT0gJ2ZpZ3VyZScpIHtcblx0XHRcdFx0XHRlbCA9IGVsLndyYXBXaXRoKFxuXHRcdFx0XHRcdFx0bmV3IENLRURJVE9SLmh0bWxQYXJzZXIuZWxlbWVudChcblx0XHRcdFx0XHRcdFx0J2RpdicsXG5cdFx0XHRcdFx0XHRcdGFsaWduQ2xhc3Nlc1xuXHRcdFx0XHRcdFx0XHRcdD8ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbGFzczogYWxpZ25DbGFzc2VzWzFdLFxuXHRcdFx0XHRcdFx0XHRcdCAgfVxuXHRcdFx0XHRcdFx0XHRcdDoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdHlsZTogJ3RleHQtYWxpZ246Y2VudGVyJyxcblx0XHRcdFx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gSWYgbGVmdC9yaWdodCwgYWRkIGZsb2F0IHN0eWxlIHRvIHRoZSBkb3duY2FzdGVkIGVsZW1lbnQuXG5cdFx0XHRcdGVsc2UgaWYgKFxuXHRcdFx0XHRcdGFsaWduIGluXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0bGVmdDogMSxcblx0XHRcdFx0XHRcdHJpZ2h0OiAxLFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0aWYgKGFsaWduQ2xhc3Nlcykge1xuXHRcdFx0XHRcdFx0YXR0cnNIb2xkZXIuYWRkQ2xhc3MoXG5cdFx0XHRcdFx0XHRcdGFsaWduQ2xhc3Nlc1thbGlnbm1lbnRzT2JqW2FsaWduXV1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0eWxlc1snZmxvYXQnXSA9IGFsaWduO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFVwZGF0ZSBlbGVtZW50IHN0eWxlcy5cblx0XHRcdFx0aWYgKCFhbGlnbkNsYXNzZXMgJiYgIUNLRURJVE9SLnRvb2xzLmlzRW1wdHkoc3R5bGVzKSkge1xuXHRcdFx0XHRcdGF0dHJzLnN0eWxlID0gQ0tFRElUT1IudG9vbHMud3JpdGVDc3NUZXh0KHN0eWxlcyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsO1xuXHRcdH07XG5cdH1cblxuXHQvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgaWYgYW4gZWxlbWVudCBpcyBhIGNlbnRlcmluZyB3cmFwcGVyLlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn0gZWRpdG9yXG5cdC8vIEByZXR1cm5zIHtGdW5jdGlvbn1cblx0ZnVuY3Rpb24gY2VudGVyV3JhcHBlckNoZWNrZXIoZWRpdG9yKSB7XG5cdFx0Y29uc3QgY2FwdGlvbmVkQ2xhc3MgPSBlZGl0b3IuY29uZmlnLmltYWdlMl9jYXB0aW9uZWRDbGFzcztcblxuXHRcdGNvbnN0IGFsaWduQ2xhc3NlcyA9IGVkaXRvci5jb25maWcuaW1hZ2UyX2FsaWduQ2xhc3NlcztcblxuXHRcdGNvbnN0IHZhbGlkQ2hpbGRyZW4gPSB7XG5cdFx0XHRhOiAxLFxuXHRcdFx0ZmlndXJlOiAxLFxuXHRcdFx0aW1nOiAxLFxuXHRcdH07XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oZWwpIHtcblx0XHRcdC8vIFdyYXBwZXIgbXVzdCBiZSBlaXRoZXIgPGRpdj4gb3IgPHA+LlxuXHRcdFx0aWYgKFxuXHRcdFx0XHQhKFxuXHRcdFx0XHRcdGVsLm5hbWUgaW5cblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRkaXY6IDEsXG5cdFx0XHRcdFx0XHRwOiAxLFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY2hpbGRyZW4gPSBlbC5jaGlsZHJlbjtcblxuXHRcdFx0Ly8gQ2VudGVyaW5nIHdyYXBwZXIgY2FuIGhhdmUgb25seSBvbmUgY2hpbGQuXG5cdFx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoICE9PSAxKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgY2hpbGQgPSBjaGlsZHJlblswXTtcblxuXHRcdFx0Ly8gT25seSA8ZmlndXJlPiBvciA8aW1nIC8+IGNhbiBiZSBmaXJzdCAob25seSkgY2hpbGQgb2YgY2VudGVyaW5nIHdyYXBwZXIsXG5cdFx0XHQvLyByZWdhcmRsZXNzIG9mIGl0cyB0eXBlLlxuXHRcdFx0aWYgKCEoY2hpbGQubmFtZSBpbiB2YWxpZENoaWxkcmVuKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGNlbnRlcmluZyB3cmFwcGVyIGlzIDxwPiwgb25seSA8aW1nIC8+IGNhbiBiZSB0aGUgY2hpbGQuXG5cdFx0XHQvLyAgIDxwIHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48aW1nIC8+PC9wPlxuXHRcdFx0aWYgKGVsLm5hbWUgPT0gJ3AnKSB7XG5cdFx0XHRcdGlmICghaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZShjaGlsZCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIENlbnRlcmluZyA8ZGl2PiBjYW4gaG9sZCA8aW1nLz4gb3IgPGZpZ3VyZT4sIGRlcGVuZGluZyBvbiBlbnRlck1vZGUuXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly8gSWYgYSA8ZmlndXJlPiBpcyB0aGUgZmlyc3QgKG9ubHkpIGNoaWxkLCBpdCBtdXN0IGhhdmUgYSBjbGFzcy5cblx0XHRcdFx0Ly8gICA8ZGl2IHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48ZmlndXJlPi4uLjwvZmlndXJlPjxkaXY+XG5cdFx0XHRcdGlmIChjaGlsZC5uYW1lID09ICdmaWd1cmUnKSB7XG5cdFx0XHRcdFx0aWYgKCFjaGlsZC5oYXNDbGFzcyhjYXB0aW9uZWRDbGFzcykpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQ2VudGVyaW5nIDxkaXY+IGNhbiBob2xkIDxpbWcvPiBvciA8YT48aW1nLz48L2E+IG9ubHkgd2hlbiBlbnRlck1vZGVcblx0XHRcdFx0XHQvLyBpcyBFTlRFUl8oQlJ8RElWKS5cblx0XHRcdFx0XHQvLyAgIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxpbWcgLz48L2Rpdj5cblx0XHRcdFx0XHQvLyAgIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxhPjxpbWcgLz48L2E+PC9kaXY+XG5cdFx0XHRcdFx0aWYgKGVkaXRvci5lbnRlck1vZGUgPT0gQ0tFRElUT1IuRU5URVJfUCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlZ2FyZGxlc3Mgb2YgZW50ZXJNb2RlLCBhIGNoaWxkIHdoaWNoIGlzIG5vdCA8ZmlndXJlPiBtdXN0IGJlXG5cdFx0XHRcdFx0Ly8gZWl0aGVyIDxpbWcvPiBvciA8YT48aW1nLz48L2E+LlxuXHRcdFx0XHRcdGlmICghaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZShjaGlsZCkpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2VudGVyaW5nIHdyYXBwZXIgZ290IHRvIGJlLi4uIGNlbnRlcmluZy4gSWYgaW1hZ2UyX2FsaWduQ2xhc3NlcyBhcmUgZGVmaW5lZCxcblx0XHRcdC8vIGNoZWNrIGZvciBjZW50ZXJpbmcgY2xhc3MuIE90aGVyd2lzZSwgY2hlY2sgdGhlIHN0eWxlLlxuXHRcdFx0aWYgKFxuXHRcdFx0XHRhbGlnbkNsYXNzZXNcblx0XHRcdFx0XHQ/IGVsLmhhc0NsYXNzKGFsaWduQ2xhc3Nlc1sxXSlcblx0XHRcdFx0XHQ6IENLRURJVE9SLnRvb2xzLnBhcnNlQ3NzVGV4dChcblx0XHRcdFx0XHRcdFx0ZWwuYXR0cmlidXRlcy5zdHlsZSB8fCAnJyxcblx0XHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCAgKVsndGV4dC1hbGlnbiddID09ICdjZW50ZXInXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gQ2hlY2tzIHdoZXRoZXIgZWxlbWVudCBpcyA8aW1nLz4gb3IgPGE+PGltZy8+PC9hPi5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5odG1sUGFyc2VyLmVsZW1lbnR9XG5cdGZ1bmN0aW9uIGlzTGlua2VkT3JTdGFuZGFsb25lSW1hZ2UoZWwpIHtcblx0XHRpZiAoZWwubmFtZSA9PSAnaW1nJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIGlmIChlbC5uYW1lID09ICdhJykge1xuXHRcdFx0cmV0dXJuIGVsLmNoaWxkcmVuLmxlbmd0aCA9PSAxICYmIGVsLmdldEZpcnN0KCdpbWcnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBTZXRzIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHdpZGdldCBpbWFnZSBhY2NvcmRpbmcgdG8gY3VycmVudCB3aWRnZXQgZGF0YS5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5wbHVnaW5zLndpZGdldH0gd2lkZ2V0XG5cdGZ1bmN0aW9uIHNldERpbWVuc2lvbnMod2lkZ2V0KSB7XG5cdFx0Y29uc3QgZGF0YSA9IHdpZGdldC5kYXRhO1xuXG5cdFx0Y29uc3QgZGltZW5zaW9ucyA9IHtcblx0XHRcdGhlaWdodDogZGF0YS5oZWlnaHQsXG5cdFx0XHR3aWR0aDogZGF0YS53aWR0aCxcblx0XHR9O1xuXG5cdFx0Y29uc3QgaW1hZ2UgPSB3aWRnZXQucGFydHMuaW1hZ2U7XG5cblx0XHRmb3IgKGNvbnN0IGQgaW4gZGltZW5zaW9ucykge1xuXHRcdFx0aWYgKGRpbWVuc2lvbnNbZF0pIHtcblx0XHRcdFx0aW1hZ2Uuc2V0QXR0cmlidXRlKGQsIGRpbWVuc2lvbnNbZF0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aW1hZ2UucmVtb3ZlQXR0cmlidXRlKGQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIERlZmluZXMgYWxsIGZlYXR1cmVzIHJlbGF0ZWQgdG8gZHJhZy1kcml2ZW4gaW1hZ2UgcmVzaXppbmcuXG5cdC8vXG5cdC8vIEBwYXJhbSB7Q0tFRElUT1IucGx1Z2lucy53aWRnZXR9IHdpZGdldFxuXHRmdW5jdGlvbiBzZXR1cFJlc2l6ZXIod2lkZ2V0KSB7XG5cdFx0Y29uc3QgZWRpdG9yID0gd2lkZ2V0LmVkaXRvcjtcblxuXHRcdGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRjb25zdCBkb2MgPSBlZGl0b3IuZG9jdW1lbnQ7XG5cblx0XHQvLyBTdG9yZSB0aGUgcmVzaXplciBpbiBhIHdpZGdldCBmb3IgdGVzdGluZyAoIzExMDA0KS5cblx0XHRjb25zdCByZXNpemVyID0gKHdpZGdldC5yZXNpemVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSk7XG5cblx0XHRyZXNpemVyLmFkZENsYXNzKCdja2VfaW1hZ2VfcmVzaXplcicpO1xuXHRcdHJlc2l6ZXIuYWRkQ2xhc3MoXG5cdFx0XHQnY2tlX2ltYWdlX3Jlc2l6ZXJfJyArIGN1cnNvcltlZGl0b3IuY29uZmlnLmltYWdlU2NhbGVSZXNpemVdXG5cdFx0KTtcblx0XHRyZXNpemVyLmFwcGVuZChuZXcgQ0tFRElUT1IuZG9tLnRleHQoJ1xcdTIwMGInLCBkb2MpKTtcblxuXHRcdC8vIElubGluZSB3aWRnZXRzIGRvbid0IG5lZWQgYSByZXNpemVyIHdyYXBwZXIgYXMgYW4gaW1hZ2Ugc3BhbnMgdGhlIGVudGlyZSB3aWRnZXQuXG5cdFx0aWYgKCF3aWRnZXQuaW5saW5lKSB7XG5cdFx0XHRjb25zdCBpbWFnZU9yTGluayA9IHdpZGdldC5wYXJ0cy5saW5rIHx8IHdpZGdldC5wYXJ0cy5pbWFnZTtcblxuXHRcdFx0Y29uc3Qgb2xkUmVzaXplV3JhcHBlciA9IGltYWdlT3JMaW5rLmdldFBhcmVudCgpO1xuXG5cdFx0XHRjb25zdCByZXNpemVXcmFwcGVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblxuXHRcdFx0cmVzaXplV3JhcHBlci5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXJfd3JhcHBlcicpO1xuXHRcdFx0cmVzaXplV3JhcHBlci5hcHBlbmQoaW1hZ2VPckxpbmspO1xuXHRcdFx0cmVzaXplV3JhcHBlci5hcHBlbmQocmVzaXplcik7XG5cdFx0XHR3aWRnZXQuZWxlbWVudC5hcHBlbmQocmVzaXplV3JhcHBlciwgdHJ1ZSk7XG5cblx0XHRcdC8vIFJlbW92ZSB0aGUgb2xkIHdyYXBwZXIgd2hpY2ggY291bGQgY2FtZSBmcm9tIGUuZy4gcGFzdGVkIEhUTUxcblx0XHRcdC8vIGFuZCB3aGljaCBjb3VsZCBiZSBjb3JydXB0ZWQgKGUuZy4gcmVzaXplciBzcGFuIGhhcyBiZWVuIGxvc3QpLlxuXHRcdFx0aWYgKG9sZFJlc2l6ZVdyYXBwZXIuaXMoJ3NwYW4nKSkge1xuXHRcdFx0XHRvbGRSZXNpemVXcmFwcGVyLnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aWRnZXQud3JhcHBlci5hcHBlbmQocmVzaXplcik7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHZhbHVlcyBvZiBzaXplIHZhcmlhYmxlcyBhbmQgbW91c2Ugb2Zmc2V0cy5cblx0XHRyZXNpemVyLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbihldnQpIHtcblx0XHRcdGNvbnN0IGltYWdlID0gd2lkZ2V0LnBhcnRzLmltYWdlO1xuXG5cdFx0XHQvLyBcImZhY3RvclwiIGNhbiBiZSBlaXRoZXIgMSBvciAtMS4gSS5lLjogRm9yIHJpZ2h0LWFsaWduZWQgaW1hZ2VzLCB3ZSBuZWVkIHRvXG5cdFx0XHQvLyBzdWJ0cmFjdCB0aGUgZGlmZmVyZW5jZSB0byBnZXQgcHJvcGVyIHdpZHRoLCBldGMuIFdpdGhvdXQgXCJmYWN0b3JcIixcblx0XHRcdC8vIHJlc2l6ZXIgc3RhcnRzIHdvcmtpbmcgdGhlIG9wcG9zaXRlIHdheS5cblx0XHRcdGNvbnN0IGZhY3RvciA9IHdpZGdldC5kYXRhLmFsaWduID09ICdyaWdodCcgPyAtMSA6IDE7XG5cblx0XHRcdC8vIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG1vdXNlIHJlbGF0aXZlIHRvIHRoZSBzY3JlZW5cblx0XHRcdC8vIHdoZW4gYnV0dG9uIGdldHMgcHJlc3NlZC5cblx0XHRcdGNvbnN0IHN0YXJ0WCA9IGV2dC5kYXRhLiQuc2NyZWVuWDtcblxuXHRcdFx0Y29uc3Qgc3RhcnRZID0gZXZ0LmRhdGEuJC5zY3JlZW5ZO1xuXG5cdFx0XHQvLyBUaGUgaW5pdGlhbCBkaW1lbnNpb25zIGFuZCBhc3BlY3QgcmF0aW8gb2YgdGhlIGltYWdlLlxuXHRcdFx0Y29uc3Qgc3RhcnRXaWR0aCA9IGltYWdlLiQuY2xpZW50V2lkdGg7XG5cblx0XHRcdGNvbnN0IHN0YXJ0SGVpZ2h0ID0gaW1hZ2UuJC5jbGllbnRIZWlnaHQ7XG5cblx0XHRcdGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuXG5cdFx0XHQvLyBBIGNsYXNzIGFwcGxpZWQgdG8gZWRpdGFibGUgZHVyaW5nIHJlc2l6aW5nLlxuXHRcdFx0Y29uc3QgY3Vyc29yQ2xhc3MgPSAnY2tlX2ltYWdlX3MnICsgKCF+ZmFjdG9yID8gJ3cnIDogJ2UnKTtcblxuXHRcdFx0bGV0IG5hdGl2ZUV2dDtcblx0XHRcdGxldCBuZXdXaWR0aDtcblx0XHRcdGxldCBuZXdIZWlnaHQ7XG5cdFx0XHRsZXQgdXBkYXRlRGF0YTtcblxuXHRcdFx0bGV0IG1vdmVEaWZmWDtcblx0XHRcdGxldCBtb3ZlRGlmZlk7XG5cblx0XHRcdC8vIFNhdmUgdGhlIHVuZG8gc25hcHNob3QgZmlyc3Q6IGJlZm9yZSByZXNpemluZy5cblx0XHRcdGVkaXRvci5maXJlKCdzYXZlU25hcHNob3QnKTtcblxuXHRcdFx0Ly8gTW91c2Vtb3ZlIGxpc3RlbmVycyBhcmUgcmVtb3ZlZCBvbiBtb3VzZXVwLlxuXHRcdFx0YXR0YWNoVG9Eb2N1bWVudHMoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlLCBsaXN0ZW5lcnMpO1xuXG5cdFx0XHQvLyBDbGVhbiB1cCB0aGUgbW91c2Vtb3ZlIGxpc3RlbmVyLiBVcGRhdGUgd2lkZ2V0IGRhdGEgaWYgdmFsaWQuXG5cdFx0XHRhdHRhY2hUb0RvY3VtZW50cygnbW91c2V1cCcsIG9uTW91c2VVcCwgbGlzdGVuZXJzKTtcblxuXHRcdFx0Ly8gVGhlIGVudGlyZSBlZGl0YWJsZSB3aWxsIGhhdmUgdGhlIHNwZWNpYWwgY3Vyc29yIHdoaWxlIHJlc2l6aW5nIGdvZXMgb24uXG5cdFx0XHRlZGl0YWJsZS5hZGRDbGFzcyhjdXJzb3JDbGFzcyk7XG5cblx0XHRcdC8vIFRoaXMgaXMgdG8gYWx3YXlzIGtlZXAgdGhlIHJlc2l6ZXIgZWxlbWVudCB2aXNpYmxlIHdoaWxlIHJlc2l6aW5nLlxuXHRcdFx0cmVzaXplci5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6aW5nJyk7XG5cblx0XHRcdC8vIEF0dGFjaGVzIGFuIGV2ZW50IHRvIGEgZ2xvYmFsIGRvY3VtZW50IGlmIGlubGluZSBlZGl0b3IuXG5cdFx0XHQvLyBBZGRpdGlvbmFsbHksIGlmIGNsYXNzaWMgKGBpZnJhbWVgLWJhc2VkKSBlZGl0b3IsIGFsc28gYXR0YWNoZXMgdGhlIHNhbWUgZXZlbnQgdG8gYGlmcmFtZWAncyBkb2N1bWVudC5cblx0XHRcdGZ1bmN0aW9uIGF0dGFjaFRvRG9jdW1lbnRzKG5hbWUsIGNhbGxiYWNrLCBjb2xsZWN0aW9uKSB7XG5cdFx0XHRcdGNvbnN0IGdsb2JhbERvYyA9IENLRURJVE9SLmRvY3VtZW50O1xuXG5cdFx0XHRcdGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuXG5cdFx0XHRcdGlmICghZG9jLmVxdWFscyhnbG9iYWxEb2MpKSB7XG5cdFx0XHRcdFx0bGlzdGVuZXJzLnB1c2goZ2xvYmFsRG9jLm9uKG5hbWUsIGNhbGxiYWNrKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsaXN0ZW5lcnMucHVzaChkb2Mub24obmFtZSwgY2FsbGJhY2spKTtcblxuXHRcdFx0XHRpZiAoY29sbGVjdGlvbikge1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpLS07ICkge1xuXHRcdFx0XHRcdFx0Y29sbGVjdGlvbi5wdXNoKGxpc3RlbmVycy5wb3AoKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoaXMgaXMgaG93IHZhcmlhYmxlcyByZWZlciB0byB0aGUgZ2VvbWV0cnkuXG5cdFx0XHQvLyBOb3RlOiB4IGNvcnJlc3BvbmRzIHRvIG1vdmVPZmZzZXQsIHRoaXMgaXMgdGhlIHBvc2l0aW9uIG9mIG1vdXNlXG5cdFx0XHQvLyBOb3RlOiBvIGNvcnJlc3BvbmRzIHRvIFtzdGFydFgsIHN0YXJ0WV0uXG5cdFx0XHQvL1xuXHRcdFx0Ly8gXHQrLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rXG5cdFx0XHQvLyBcdHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcblx0XHRcdC8vIFx0fCAgICAgIEkgICAgICAgfCAgICAgIElJICAgICAgfFxuXHRcdFx0Ly8gXHR8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG5cdFx0XHQvLyBcdCstLS0tLS0tLS0tLS0tIG8gLS0tLS0tLS0tLS0tLSsgXyBfIF9cblx0XHRcdC8vIFx0fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgIF5cblxuXHRcdFx0Ly8gXHR8ICAgICAgVkkgICAgICB8ICAgICBJSUkgICAgICB8ICAgICAgfCBtb3ZlRGlmZllcblx0XHRcdC8vIFx0fCAgICAgICAgICAgICAgfCAgICAgICAgIHggXyBfIF8gXyBfIHZcblx0XHRcdC8vIFx0Ky0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLXwtLS0tK1xuXHRcdFx0Ly8gXHQgICAgICAgICAgICAgICB8ICAgICAgICAgfFxuXHRcdFx0Ly8gXHQgICAgICAgICAgICAgICAgPC0tLS0tLS0+XG5cdFx0XHQvLyBcdCAgICAgICAgICAgICAgICBtb3ZlRGlmZlhcblx0XHRcdGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2dCkge1xuXHRcdFx0XHRjb25zdCBpbWFnZVNjYWxlUmVzaXplID0gZWRpdG9yLmNvbmZpZy5pbWFnZVNjYWxlUmVzaXplO1xuXG5cdFx0XHRcdG5hdGl2ZUV2dCA9IGV2dC5kYXRhLiQ7XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyBob3cgZmFyIHRoZSBtb3VzZSBpcyBmcm9tIHRoZSBwb2ludCB0aGUgYnV0dG9uIHdhcyBwcmVzc2VkLlxuXHRcdFx0XHRtb3ZlRGlmZlggPSBuYXRpdmVFdnQuc2NyZWVuWCAtIHN0YXJ0WDtcblx0XHRcdFx0bW92ZURpZmZZID0gc3RhcnRZIC0gbmF0aXZlRXZ0LnNjcmVlblk7XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGltYWdlU2NhbGVSZXNpemUgPT09ICd3aWR0aCcgfHxcblx0XHRcdFx0XHRpbWFnZVNjYWxlUmVzaXplID09PSAnYm90aCcgfHxcblx0XHRcdFx0XHRpbWFnZVNjYWxlUmVzaXplID09PSAnc2NhbGUnXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdG5ld1dpZHRoID0gc3RhcnRXaWR0aCArIGZhY3RvciAqIG1vdmVEaWZmWDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRpbWFnZVNjYWxlUmVzaXplID09PSAnaGVpZ2h0JyB8fFxuXHRcdFx0XHRcdGltYWdlU2NhbGVSZXNpemUgPT09ICdib3RoJ1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRuZXdIZWlnaHQgPSBzdGFydEhlaWdodCAtIG1vdmVEaWZmWTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChpbWFnZVNjYWxlUmVzaXplID09PSAnc2NhbGUnKSB7XG5cdFx0XHRcdFx0bmV3SGVpZ2h0ID0gJ2F1dG8nO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bmV3V2lkdGggPSBuZXdXaWR0aCB8fCBzdGFydFdpZHRoO1xuXHRcdFx0XHRuZXdIZWlnaHQgPSBuZXdIZWlnaHQgfHwgc3RhcnRIZWlnaHQ7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgdXBkYXRlIGF0dHJpYnV0ZXMgaWYgbGVzcyB0aGFuIDEwLlxuXHRcdFx0XHQvLyBUaGlzIGlzIHRvIHByZXZlbnQgaW1hZ2VzIHRvIHZpc3VhbGx5IGRpc2FwcGVhci5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG5ld1dpZHRoID49IDE1ICYmXG5cdFx0XHRcdFx0KG5ld0hlaWdodCA+PSAxNSB8fCBuZXdIZWlnaHQgPT09ICdhdXRvJylcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0aW1hZ2UuJC5zdHlsZS53aWR0aCA9IG5ld1dpZHRoICsgJ3B4Jztcblx0XHRcdFx0XHRpbWFnZS4kLnN0eWxlLmhlaWdodCA9IG5ld0hlaWdodCArICdweCc7XG5cblx0XHRcdFx0XHR1cGRhdGVEYXRhID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR1cGRhdGVEYXRhID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuXHRcdFx0XHRsZXQgbDtcblxuXHRcdFx0XHR3aGlsZSAoKGwgPSBsaXN0ZW5lcnMucG9wKCkpKSB7XG5cdFx0XHRcdFx0bC5yZW1vdmVMaXN0ZW5lcigpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSBkZWZhdWx0IGN1cnNvciBieSByZW1vdmluZyBzcGVjaWFsIGNsYXNzLlxuXHRcdFx0XHRlZGl0YWJsZS5yZW1vdmVDbGFzcyhjdXJzb3JDbGFzcyk7XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyB0byBicmluZyBiYWNrIHRoZSByZWd1bGFyIGJlaGF2aW91ciBvZiB0aGUgcmVzaXplci5cblx0XHRcdFx0cmVzaXplci5yZW1vdmVDbGFzcygnY2tlX2ltYWdlX3Jlc2l6aW5nJyk7XG5cblx0XHRcdFx0aWYgKHVwZGF0ZURhdGEpIHtcblx0XHRcdFx0XHR3aWRnZXQuc2V0RGF0YSh7XG5cdFx0XHRcdFx0XHRoZWlnaHQ6IG5ld0hlaWdodCxcblx0XHRcdFx0XHRcdHdpZHRoOiBuZXdXaWR0aCxcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8vIFNhdmUgYW5vdGhlciB1bmRvIHNuYXBzaG90OiBhZnRlciByZXNpemluZy5cblx0XHRcdFx0XHRlZGl0b3IuZmlyZSgnc2F2ZVNuYXBzaG90Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEb24ndCB1cGRhdGUgZGF0YSB0d2ljZSBvciBtb3JlLlxuXHRcdFx0XHR1cGRhdGVEYXRhID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBDaGFuZ2UgdGhlIHBvc2l0aW9uIG9mIHRoZSB3aWRnZXQgcmVzaXplciB3aGVuIGRhdGEgY2hhbmdlcy5cblx0XHR3aWRnZXQub24oJ2RhdGEnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJlc2l6ZXJbd2lkZ2V0LmRhdGEuYWxpZ24gPT0gJ3JpZ2h0JyA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShcblx0XHRcdFx0J2NrZV9pbWFnZV9yZXNpemVyX2xlZnQnXG5cdFx0XHQpO1xuXHRcdH0pO1xuXG5cdFx0d2lkZ2V0LnBhcnRzLmltYWdlLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0XHRpZiAoc2VsZWN0aW9uKSB7XG5cdFx0XHRcdGNvbnN0IGVsZW1lbnQgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbGVtZW50KCk7XG5cblx0XHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0XHRjb25zdCB3aWRnZXRFbGVtZW50ID0gZWxlbWVudC5maW5kT25lKCdpbWcnKTtcblxuXHRcdFx0XHRcdGlmICh3aWRnZXRFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRjb25zdCByZWdpb24gPSBlbGVtZW50LmdldENsaWVudFJlY3QoKTtcblxuXHRcdFx0XHRcdFx0Y29uc3Qgc2Nyb2xsUG9zaXRpb24gPSBuZXcgQ0tFRElUT1IuZG9tLndpbmRvdyhcblx0XHRcdFx0XHRcdFx0d2luZG93XG5cdFx0XHRcdFx0XHQpLmdldFNjcm9sbFBvc2l0aW9uKCk7XG5cdFx0XHRcdFx0XHRyZWdpb24ubGVmdCAtPSBzY3JvbGxQb3NpdGlvbi54O1xuXHRcdFx0XHRcdFx0cmVnaW9uLnRvcCArPSBzY3JvbGxQb3NpdGlvbi55O1xuXG5cdFx0XHRcdFx0XHRyZWdpb24uZGlyZWN0aW9uID0gQ0tFRElUT1IuU0VMRUNUSU9OX0JPVFRPTV9UT19UT1A7XG5cblx0XHRcdFx0XHRcdGVkaXRvci5maXJlKCdlZGl0b3JJbnRlcmFjdGlvbicsIHtcblx0XHRcdFx0XHRcdFx0bmF0aXZlRXZlbnQ6IGV2ZW50LFxuXHRcdFx0XHRcdFx0XHRzZWxlY3Rpb25EYXRhOiB7XG5cdFx0XHRcdFx0XHRcdFx0ZWxlbWVudDogd2lkZ2V0RWxlbWVudCxcblx0XHRcdFx0XHRcdFx0XHRyZWdpb24sXG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8vIFJldHVybnMgYSBzZXQgb2Ygd2lkZ2V0IGFsbG93ZWRDb250ZW50IHJ1bGVzLCBkZXBlbmRpbmdcblx0Ly8gb24gY29uZmlndXJhdGlvbnMgbGlrZSBjb25maWcjaW1hZ2UyX2FsaWduQ2xhc3NlcyBvclxuXHQvLyBjb25maWcjaW1hZ2UyX2NhcHRpb25lZENsYXNzLlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn1cblx0Ly8gQHJldHVybnMge09iamVjdH1cblx0ZnVuY3Rpb24gZ2V0V2lkZ2V0QWxsb3dlZENvbnRlbnQoZWRpdG9yKSB7XG5cdFx0Y29uc3QgcnVsZXMgPSB7XG5cdFx0XHRmaWdjYXB0aW9uOiB0cnVlLFxuXHRcdFx0ZmlndXJlOiB7XG5cdFx0XHRcdGNsYXNzZXM6ICchJyArIGVkaXRvci5jb25maWcuaW1hZ2UyX2NhcHRpb25lZENsYXNzLFxuXHRcdFx0fSxcblx0XHRcdGltZzoge1xuXHRcdFx0XHRhdHRyaWJ1dGVzOiAnIXNyYyxhbHQsd2lkdGgsaGVpZ2h0Jyxcblx0XHRcdH0sXG5cdFx0fTtcblxuXHRcdHJldHVybiBydWxlcztcblx0fVxuXG5cdC8vIFJldHVybnMgYSBzZXQgb2Ygd2lkZ2V0IGZlYXR1cmUgcnVsZXMsIGRlcGVuZGluZ1xuXHQvLyBvbiBlZGl0b3IgY29uZmlndXJhdGlvbi4gTm90ZSB0aGF0IHRoZSBmb2xsb3dpbmcgbWF5IG5vdCBjb3ZlclxuXHQvLyBhbGwgdGhlIHBvc3NpYmxlIGNhc2VzIHNpbmNlIHJlcXVpcmVkQ29udGVudCBzdXBwb3J0cyBhIHNpbmdsZVxuXHQvLyB0YWcgb25seS5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9XG5cdC8vIEByZXR1cm5zIHtPYmplY3R9XG5cdGZ1bmN0aW9uIGdldFdpZGdldEZlYXR1cmVzKGVkaXRvcikge1xuXHRcdGNvbnN0IGFsaWduQ2xhc3NlcyA9IGVkaXRvci5jb25maWcuaW1hZ2UyX2FsaWduQ2xhc3NlcztcblxuXHRcdGNvbnN0IGZlYXR1cmVzID0ge1xuXHRcdFx0YWxpZ246IHtcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OlxuXHRcdFx0XHRcdCdpbWcnICtcblx0XHRcdFx0XHQoYWxpZ25DbGFzc2VzID8gJygnICsgYWxpZ25DbGFzc2VzWzBdICsgJyknIDogJ3tmbG9hdH0nKSxcblx0XHRcdH0sXG5cdFx0XHRjYXB0aW9uOiB7XG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ2ZpZ2NhcHRpb24nLFxuXHRcdFx0fSxcblx0XHRcdGRpbWVuc2lvbjoge1xuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICdpbWdbd2lkdGgsaGVpZ2h0XScsXG5cdFx0XHR9LFxuXHRcdH07XG5cblx0XHRyZXR1cm4gZmVhdHVyZXM7XG5cdH1cblxuXHQvLyBSZXR1cm5zIGVsZW1lbnQgd2hpY2ggaXMgc3R5bGVkLCBjb25zaWRlcmluZyBjdXJyZW50XG5cdC8vIHN0YXRlIG9mIHRoZSB3aWRnZXQuXG5cdC8vXG5cdC8vIEBzZWUgQ0tFRElUT1IucGx1Z2lucy53aWRnZXQjYXBwbHlTdHlsZVxuXHQvLyBAcGFyYW0ge0NLRURJVE9SLnBsdWdpbnMud2lkZ2V0fSB3aWRnZXRcblx0Ly8gQHJldHVybnMge0NLRURJVE9SLmRvbS5lbGVtZW50fVxuXHRmdW5jdGlvbiBnZXRTdHlsZWFibGVFbGVtZW50KHdpZGdldCkge1xuXHRcdHJldHVybiB3aWRnZXQuZGF0YS5oYXNDYXB0aW9uID8gd2lkZ2V0LmVsZW1lbnQgOiB3aWRnZXQucGFydHMuaW1hZ2U7XG5cdH1cbn1cblxuQ0tFRElUT1IuY29uZmlnLmltYWdlMl9jYXB0aW9uZWRDbGFzcyA9ICdpbWFnZSc7XG4iLCIvKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE3LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cDovL2NrZWRpdG9yLmNvbS9saWNlbnNlXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuXHRpZiAoQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2RyYWdyZXNpemVfaWUxMScpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgdGVtcGxhdGUgPSAnPGltZyBhbHQ9XCJcIiBzcmM9XCJcIiAvPic7XG5cblx0Y29uc3QgdGVtcGxhdGVCbG9jayA9IG5ldyBDS0VESVRPUi50ZW1wbGF0ZShcblx0XHQnPGZpZ3VyZSBjbGFzcz1cIntjYXB0aW9uZWRDbGFzc31cIj4nICtcblx0XHRcdHRlbXBsYXRlICtcblx0XHRcdCc8ZmlnY2FwdGlvbj57Y2FwdGlvblBsYWNlaG9sZGVyfTwvZmlnY2FwdGlvbj4nICtcblx0XHRcdCc8L2ZpZ3VyZT4nXG5cdCk7XG5cblx0Y29uc3QgYWxpZ25tZW50c09iaiA9IHtsZWZ0OiAwLCBjZW50ZXI6IDEsIHJpZ2h0OiAyfTtcblxuXHRjb25zdCByZWdleFBlcmNlbnQgPSAvXlxccyooXFxkKyUpXFxzKiQvaTtcblxuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfZHJhZ3Jlc2l6ZV9pZTExJywge1xuXHRcdHJlcXVpcmVzOiAnd2lkZ2V0Jyxcblx0XHRvbkxvYWQoKSB7XG5cdFx0XHRDS0VESVRPUi5hZGRDc3MoXG5cdFx0XHRcdCcuY2tlX2ltYWdlX25vY2FwdGlvbnsnICtcblx0XHRcdFx0XHQvLyBUaGlzIGlzIHRvIHJlbW92ZSB1bndhbnRlZCBzcGFjZSBzbyByZXNpemVcblx0XHRcdFx0XHQvLyB3cmFwcGVyIGlzIGRpc3BsYXllZCBwcm9wZXJ0eS5cblx0XHRcdFx0XHQnbGluZS1oZWlnaHQ6MCcgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Jy5ja2VfZWRpdGFibGUuY2tlX2ltYWdlX25lLCAuY2tlX2VkaXRhYmxlLmNrZV9pbWFnZV9uZSAqe2N1cnNvcjpuZS1yZXNpemUgIWltcG9ydGFudH0nICtcblx0XHRcdFx0XHQnLmNrZV9lZGl0YWJsZS5ja2VfaW1hZ2VfbncsIC5ja2VfZWRpdGFibGUuY2tlX2ltYWdlX253ICp7Y3Vyc29yOm53LXJlc2l6ZSAhaW1wb3J0YW50fScgK1xuXHRcdFx0XHRcdCcuY2tlX2VkaXRhYmxlLmNrZV9pbWFnZV9zdywgLmNrZV9lZGl0YWJsZS5ja2VfaW1hZ2Vfc3cgKntjdXJzb3I6c3ctcmVzaXplICFpbXBvcnRhbnR9JyArXG5cdFx0XHRcdFx0Jy5ja2VfZWRpdGFibGUuY2tlX2ltYWdlX3NlLCAuY2tlX2VkaXRhYmxlLmNrZV9pbWFnZV9zZSAqe2N1cnNvcjpzZS1yZXNpemUgIWltcG9ydGFudH0nICtcblx0XHRcdFx0XHQnLmNrZV9pbWFnZV9yZXNpemVyeycgK1xuXHRcdFx0XHRcdCdkaXNwbGF5Om5vbmU7JyArXG5cdFx0XHRcdFx0J3Bvc2l0aW9uOmFic29sdXRlOycgK1xuXHRcdFx0XHRcdCd3aWR0aDoxMHB4OycgK1xuXHRcdFx0XHRcdCdoZWlnaHQ6MTBweDsnICtcblx0XHRcdFx0XHQnYmFja2dyb3VuZDojMDAwOycgK1xuXHRcdFx0XHRcdCdvdXRsaW5lOjFweCBzb2xpZCAjZmZmOycgK1xuXHRcdFx0XHRcdC8vIFByZXZlbnQgZHJhZyBoYW5kbGVyIGZyb20gYmVpbmcgbWlzcGxhY2VkICgjMTEyMDcpLlxuXHRcdFx0XHRcdCdsaW5lLWhlaWdodDowOycgK1xuXHRcdFx0XHRcdCdjdXJzb3I6c2UtcmVzaXplOycgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Jy5ja2VfaW1hZ2VfcmVzaXplcl93cmFwcGVyeycgK1xuXHRcdFx0XHRcdCdwb3NpdGlvbjpyZWxhdGl2ZTsnICtcblx0XHRcdFx0XHQnZGlzcGxheTppbmxpbmUtYmxvY2s7JyArXG5cdFx0XHRcdFx0J2xpbmUtaGVpZ2h0OjA7JyArXG5cdFx0XHRcdFx0J30nICtcblx0XHRcdFx0XHQvLyBUb3AtcmlnaHQgY29ybmVyIHN0eWxlIG9mIHRoZSByZXNpemVyLlxuXHRcdFx0XHRcdCcuY2tlX2ltYWdlX3Jlc2l6ZXIuY2tlX2ltYWdlX3Jlc2l6ZXJfbmV7JyArXG5cdFx0XHRcdFx0J2N1cnNvcjpuZS1yZXNpemU7JyArXG5cdFx0XHRcdFx0J2xlZnQ6YXV0bzsnICtcblx0XHRcdFx0XHQncmlnaHQ6LTVweDsnICtcblx0XHRcdFx0XHQndG9wOi01cHg7JyArXG5cdFx0XHRcdFx0J30nICtcblx0XHRcdFx0XHQvLyBUb3AtbGVmdCBjb3JuZXIgc3R5bGUgb2YgdGhlIHJlc2l6ZXIuXG5cdFx0XHRcdFx0Jy5ja2VfaW1hZ2VfcmVzaXplci5ja2VfaW1hZ2VfcmVzaXplcl9ud3snICtcblx0XHRcdFx0XHQnY3Vyc29yOm53LXJlc2l6ZTsnICtcblx0XHRcdFx0XHQnbGVmdDotNXB4OycgK1xuXHRcdFx0XHRcdCdyaWdodDphdXRvOycgK1xuXHRcdFx0XHRcdCd0b3A6LTVweDsnICtcblx0XHRcdFx0XHQnfScgK1xuXHRcdFx0XHRcdC8vIEJvdHRvbS1yaWdodCBjb3JuZXIgc3R5bGUgb2YgdGhlIHJlc2l6ZXIuXG5cdFx0XHRcdFx0Jy5ja2VfaW1hZ2VfcmVzaXplci5ja2VfaW1hZ2VfcmVzaXplcl9zZXsnICtcblx0XHRcdFx0XHQnYm90dG9tOi01cHg7JyArXG5cdFx0XHRcdFx0J2N1cnNvcjpzZS1yZXNpemU7JyArXG5cdFx0XHRcdFx0J2xlZnQ6YXV0bzsnICtcblx0XHRcdFx0XHQncmlnaHQ6LTVweDsnICtcblx0XHRcdFx0XHQnfScgK1xuXHRcdFx0XHRcdC8vIEJvdHRvbS1sZWZ0IGNvcm5lciBzdHlsZSBvZiB0aGUgcmVzaXplci5cblx0XHRcdFx0XHQnLmNrZV9pbWFnZV9yZXNpemVyLmNrZV9pbWFnZV9yZXNpemVyX3N3eycgK1xuXHRcdFx0XHRcdCdib3R0b206LTVweDsnICtcblx0XHRcdFx0XHQnY3Vyc29yOnN3LXJlc2l6ZTsnICtcblx0XHRcdFx0XHQnbGVmdDotNXB4OycgK1xuXHRcdFx0XHRcdCdyaWdodDphdXRvOycgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Jy5ja2Vfd2lkZ2V0X3dyYXBwZXI6aG92ZXIgLmNrZV9pbWFnZV9yZXNpemVyLCcgK1xuXHRcdFx0XHRcdCcuY2tlX2ltYWdlX3Jlc2l6aW5nPi5ja2VfaW1hZ2VfcmVzaXplcnsnICtcblx0XHRcdFx0XHQnZGlzcGxheTpibG9jaycgK1xuXHRcdFx0XHRcdCd9JyArXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIHdpZGdldCB3cmFwcGVyIHdoZW4gbGlua2VkIGlubGluZSBpbWFnZS5cblx0XHRcdFx0XHQnLmNrZV93aWRnZXRfd3JhcHBlcj5heycgK1xuXHRcdFx0XHRcdCdkaXNwbGF5OmlubGluZS1ibG9jaycgK1xuXHRcdFx0XHRcdCd9J1xuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0aW5pdChlZGl0b3IpIHtcblx0XHRcdC8vIEFkYXB0cyBjb25maWd1cmF0aW9uIGZyb20gb3JpZ2luYWwgaW1hZ2UgcGx1Z2luLiBTaG91bGQgYmUgcmVtb3ZlZFxuXHRcdFx0Ly8gd2hlbiB3ZSdsbCByZW5hbWUgYWVfZHJhZ3Jlc2l6ZV9pZTExIHRvIGltYWdlLlxuXG5cdFx0XHRjb25zdCBpbWFnZSA9IHdpZGdldERlZihlZGl0b3IpO1xuXG5cdFx0XHQvLyBSZWdpc3RlciB0aGUgd2lkZ2V0LlxuXHRcdFx0ZWRpdG9yLndpZGdldHMuYWRkKCdpbWFnZScsIGltYWdlKTtcblxuXHRcdFx0Ly8gQWRkIGEgbGlzdGVuZXIgdG8gaGFuZGxlIHNlbGVjdGlvbiBjaGFuZ2UgZXZlbnRzIGFuZCBwcm9wZXJseSBkZXRlY3QgZWRpdG9yXG5cdFx0XHQvLyBpbnRlcmFjdGlvbnMgb24gdGhlIHdpZGdldHMgd2l0aG91dCBtZXNzaW5nIHdpdGggd2lkZ2V0IG5hdGl2ZSBzZWxlY3Rpb25cblx0XHRcdGVkaXRvci5vbignc2VsZWN0aW9uQ2hhbmdlJywgZnVuY3Rpb24oX2V2ZW50KSB7XG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdFx0XHRpZiAoc2VsZWN0aW9uKSB7XG5cdFx0XHRcdFx0Y29uc3QgZWxlbWVudCA9IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuXHRcdFx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRjb25zdCB3aWRnZXRFbGVtZW50ID0gZWxlbWVudC5maW5kT25lKCdpbWcnKTtcblxuXHRcdFx0XHRcdFx0aWYgKHdpZGdldEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcmVnaW9uID0gZWxlbWVudC5nZXRDbGllbnRSZWN0KCk7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3Qgc2Nyb2xsUG9zaXRpb24gPSBuZXcgQ0tFRElUT1IuZG9tLndpbmRvdyhcblx0XHRcdFx0XHRcdFx0XHR3aW5kb3dcblx0XHRcdFx0XHRcdFx0KS5nZXRTY3JvbGxQb3NpdGlvbigpO1xuXHRcdFx0XHRcdFx0XHRyZWdpb24ubGVmdCAtPSBzY3JvbGxQb3NpdGlvbi54O1xuXHRcdFx0XHRcdFx0XHRyZWdpb24udG9wICs9IHNjcm9sbFBvc2l0aW9uLnk7XG5cblx0XHRcdFx0XHRcdFx0cmVnaW9uLmRpcmVjdGlvbiA9IENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QO1xuXG5cdFx0XHRcdFx0XHRcdGVkaXRvci5maXJlKCdlZGl0b3JJbnRlcmFjdGlvbicsIHtcblx0XHRcdFx0XHRcdFx0XHRuYXRpdmVFdmVudDoge30sXG5cdFx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uRGF0YToge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZWxlbWVudDogd2lkZ2V0RWxlbWVudCxcblx0XHRcdFx0XHRcdFx0XHRcdHJlZ2lvbixcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRhZnRlckluaXQoZWRpdG9yKSB7XG5cdFx0XHQvLyBJbnRlZ3JhdGUgd2l0aCBhbGlnbiBjb21tYW5kcyAoanVzdGlmeSBwbHVnaW4pLlxuXHRcdFx0Y29uc3QgYWxpZ24gPSB7bGVmdDogMSwgcmlnaHQ6IDEsIGNlbnRlcjogMSwgYmxvY2s6IDF9O1xuXG5cdFx0XHRjb25zdCBpbnRlZ3JhdGUgPSBhbGlnbkNvbW1hbmRJbnRlZ3JhdG9yKGVkaXRvcik7XG5cblx0XHRcdGZvciAoY29uc3QgdmFsdWUgaW4gYWxpZ24pIHtcblx0XHRcdFx0aWYgKGFsaWduLmhhc093blByb3BlcnR5KHZhbHVlKSkge1xuXHRcdFx0XHRcdGludGVncmF0ZSh2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHR9KTtcblxuXHQvLyBXaWRnZXQgc3RhdGVzIChmb3JtcykgZGVwZW5kaW5nIG9uIGFsaWdubWVudCBhbmQgY29uZmlndXJhdGlvbi5cblx0Ly9cblx0Ly8gTm9uLWNhcHRpb25lZCB3aWRnZXQgKGlubGluZSBzdHlsZXMpXG5cdC8vIFx0XHTilIzilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJBcblx0Ly8gXHRcdOKUgkFsaWduIOKUgkludGVybmFsIGZvcm0gICAgICAgICAgICAgICAgICDilIJEYXRhICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJub25lICDilII8d3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAg4pSCPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgmxlZnQgIOKUgjx3cmFwcGVyIHN0eWxlPeKAnWZsb2F0OmxlZnTigJ0+ICAg4pSCPGltZyBzdHlsZT3igJ1mbG9hdDpsZWZ04oCdIC8+ICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJjZW50ZXLilII8d3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAg4pSCPHAgc3R5bGU94oCddGV4dC1hbGlnbjpjZW50ZXLigJ0+4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPHAgc3R5bGU94oCddGV4dC1hbGlnbjpjZW50ZXLigJ0+IOKUgiAgPGltZyAvPiAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgICA8aW1nIC8+ICAgICAgICAgICAgICAgICAgICAg4pSCPC9wPiAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8L3A+ICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgnJpZ2h0IOKUgjx3cmFwcGVyIHN0eWxlPeKAnWZsb2F0OnJpZ2h04oCdPiAg4pSCPGltZyBzdHlsZT3igJ1mbG9hdDpyaWdodOKAnSAvPiAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSU4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS04pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSYXG5cdC8vXG5cdC8vIE5vbi1jYXB0aW9uZWQgd2lkZ2V0IChjb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2FsaWduQ2xhc3NlcyBkZWZpbmVkKVxuXHQvLyBcdFx04pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG5cdC8vIFx0XHTilIJBbGlnbiDilIJJbnRlcm5hbCBmb3JtICAgICAgICAgICAgICAgICAg4pSCRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCbm9uZSAg4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgIOKUgjxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJsZWZ0ICDilII8d3JhcHBlciBjbGFzcz3igJ1sZWZ04oCdPiAgICAgICAgIOKUgjxpbWcgY2xhc3M94oCdbGVmdOKAnSAvPiAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCY2VudGVy4pSCPHdyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgIOKUgjxwIGNsYXNzPeKAnWNlbnRlcuKAnT4gICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxwIGNsYXNzPeKAnWNlbnRlcuKAnT4gICAgICAgICAgICDilIIgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCICAgPGltZyAvPiAgICAgICAgICAgICAgICAgICAgIOKUgjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJyaWdodCDilII8d3JhcHBlciBjbGFzcz3igJ1yaWdodOKAnT4gICAgICAgIOKUgjxpbWcgY2xhc3M94oCdcmlnaHTigJ0gLz4gICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxpbWcgLz4gICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuXHQvL1xuXHQvLyBDYXB0aW9uZWQgd2lkZ2V0IChpbmxpbmUgc3R5bGVzKVxuXHQvLyBcdFx04pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG5cdC8vIFx0XHTilIJBbGlnbiDilIJJbnRlcm5hbCBmb3JtICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJub25lICDilII8d3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgmxlZnQgIOKUgjx3cmFwcGVyIHN0eWxlPeKAnWZsb2F0OmxlZnTigJ0+ICAgICAgICAgICAg4pSCPGZpZ3VyZSBzdHlsZT3igJ1mbG9hdDpsZWZ04oCdIC8+ICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJjZW50ZXLilII8d3JhcHBlciBzdHlsZT3igJ10ZXh0LWFsaWduOmNlbnRlcuKAnT4gICAgIOKUgjxkaXYgc3R5bGU94oCddGV4dC1hbGlnbjpjZW50ZXLigJ0+ICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGZpZ3VyZSBzdHlsZT3igJ1kaXNwbGF5OmlubGluZS1ibG9ja+KAnSAvPuKUgiA8ZmlndXJlIHN0eWxlPeKAnWRpc3BsYXk6aW5saW5lLWJsb2Nr4oCdIC8+4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCPC9wPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJyaWdodCDilII8d3JhcHBlciBzdHlsZT3igJ1mbG9hdDpyaWdodOKAnT4gICAgICAgICAgIOKUgjxmaWd1cmUgc3R5bGU94oCdZmxvYXQ6cmlnaHTigJ0gLz4gICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuXHQvL1xuXHQvLyBDYXB0aW9uZWQgd2lkZ2V0IChjb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2FsaWduQ2xhc3NlcyBkZWZpbmVkKVxuXHQvLyBcdFx04pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG5cdC8vIFx0XHTilIJBbGlnbiDilIJJbnRlcm5hbCBmb3JtICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJub25lICDilII8d3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJzilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcblx0Ly8gXHRcdOKUgmxlZnQgIOKUgjx3cmFwcGVyIGNsYXNzPeKAnWxlZnTigJ0+ICAgICAgICAgICAgICAgICAg4pSCPGZpZ3VyZSBjbGFzcz3igJ1sZWZ04oCdIC8+ICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgiA8ZmlndXJlIC8+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilII8L3dyYXBwZXI+ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSc4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG5cdC8vIFx0XHTilIJjZW50ZXLilII8d3JhcHBlciBjbGFzcz3igJ1jZW50ZXLigJ0+ICAgICAgICAgICAgICAgIOKUgjxkaXYgY2xhc3M94oCdY2VudGVy4oCdPiAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilIIgICAgICDilIIgPGZpZ3VyZSAvPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCPC93cmFwcGVyPiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgjwvcD4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUnOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUpFxuXHQvLyBcdFx04pSCcmlnaHQg4pSCPHdyYXBwZXIgY2xhc3M94oCdcmlnaHTigJ0+ICAgICAgICAgICAgICAgICDilII8ZmlndXJlIGNsYXNzPeKAnXJpZ2h04oCdIC8+ICAgICAgICAgICAgICAgIOKUglxuXHQvLyBcdFx04pSCICAgICAg4pSCIDxmaWd1cmUgLz4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKUgiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIJcblx0Ly8gXHRcdOKUgiAgICAgIOKUgjwvd3JhcHBlcj4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCXG5cdC8vIFx0XHTilJTilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9XG5cdC8vIEByZXR1cm5zIHtPYmplY3R9XG5cdGZ1bmN0aW9uIHdpZGdldERlZihlZGl0b3IpIHtcblx0XHRjb25zdCBhbGlnbkNsYXNzZXMgPSBlZGl0b3IuY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXM7XG5cblx0XHRjb25zdCBjYXB0aW9uZWRDbGFzcyA9IGVkaXRvci5jb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2NhcHRpb25lZENsYXNzO1xuXG5cdFx0ZnVuY3Rpb24gZGVmbGF0ZSgpIHtcblx0XHRcdGlmICh0aGlzLmRlZmxhdGVkKSByZXR1cm47XG5cblx0XHRcdC8vIFJlbWVtYmVyIHdoZXRoZXIgd2lkZ2V0IHdhcyBmb2N1c2VkIGJlZm9yZSBkZXN0cm95ZWQuXG5cdFx0XHRpZiAoZWRpdG9yLndpZGdldHMuZm9jdXNlZCA9PSB0aGlzLndpZGdldCkgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcblxuXHRcdFx0ZWRpdG9yLndpZGdldHMuZGVzdHJveSh0aGlzLndpZGdldCk7XG5cblx0XHRcdC8vIE1hcmsgd2lkZ2V0IHdhcyBkZXN0cm95ZWQuXG5cdFx0XHR0aGlzLmRlZmxhdGVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbmZsYXRlKCkge1xuXHRcdFx0Y29uc3QgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuXHRcdFx0Y29uc3QgZG9jID0gZWRpdG9yLmRvY3VtZW50O1xuXG5cdFx0XHQvLyBDcmVhdGUgYSBuZXcgd2lkZ2V0LiBUaGlzIHdpZGdldCB3aWxsIGJlIGVpdGhlciBjYXB0aW9uZWRcblx0XHRcdC8vIG5vbi1jYXB0aW9uZWQsIGJsb2NrIG9yIGlubGluZSBhY2NvcmRpbmcgdG8gd2hhdCBpcyB0aGVcblx0XHRcdC8vIG5ldyBzdGF0ZSBvZiB0aGUgd2lkZ2V0LlxuXHRcdFx0aWYgKHRoaXMuZGVmbGF0ZWQpIHtcblx0XHRcdFx0dGhpcy53aWRnZXQgPSBlZGl0b3Iud2lkZ2V0cy5pbml0T24oXG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50LFxuXHRcdFx0XHRcdCdpbWFnZScsXG5cdFx0XHRcdFx0dGhpcy53aWRnZXQuZGF0YVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIE9uY2Ugd2lkZ2V0IHdhcyByZS1jcmVhdGVkLCBpdCBtYXkgYmVjb21lIGFuIGlubGluZSBlbGVtZW50IHdpdGhvdXRcblx0XHRcdFx0Ly8gYmxvY2sgd3JhcHBlciAoaS5lLiB3aGVuIHVuYWxpZ25lZCwgZW5kIG5vdCBjYXB0aW9uZWQpLiBMZXQncyBkbyBzb21lXG5cdFx0XHRcdC8vIHNvcnQgb2YgYXV0b3BhcmFncmFwaGluZyBoZXJlICgjMTA4NTMpLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy53aWRnZXQuaW5saW5lICYmXG5cdFx0XHRcdFx0IW5ldyBDS0VESVRPUi5kb20uZWxlbWVudFBhdGgodGhpcy53aWRnZXQud3JhcHBlciwgZWRpdGFibGUpXG5cdFx0XHRcdFx0XHQuYmxvY2tcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Y29uc3QgYmxvY2sgPSBkb2MuY3JlYXRlRWxlbWVudChcblx0XHRcdFx0XHRcdGVkaXRvci5hY3RpdmVFbnRlck1vZGUgPT0gQ0tFRElUT1IuRU5URVJfUCA/ICdwJyA6ICdkaXYnXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRibG9jay5yZXBsYWNlKHRoaXMud2lkZ2V0LndyYXBwZXIpO1xuXHRcdFx0XHRcdHRoaXMud2lkZ2V0LndyYXBwZXIubW92ZShibG9jayk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGUgZm9jdXMgbXVzdCBiZSB0cmFuc2ZlcnJlZCBmcm9tIHRoZSBvbGQgb25lIChkZXN0cm95ZWQpXG5cdFx0XHRcdC8vIHRvIHRoZSBuZXcgb25lIChqdXN0IGNyZWF0ZWQpLlxuXHRcdFx0XHRpZiAodGhpcy5mb2N1c2VkKSB7XG5cdFx0XHRcdFx0dGhpcy53aWRnZXQuZm9jdXMoKTtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5mb2N1c2VkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZGVmbGF0ZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIG5vdyB3aWRnZXQgd2FzIGRlc3Ryb3llZCBqdXN0IHVwZGF0ZSB3cmFwcGVyJ3MgYWxpZ25tZW50LlxuXHRcdFx0Ly8gQWNjb3JkaW5nIHRvIHRoZSBuZXcgc3RhdGUuXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0c2V0V3JhcHBlckFsaWduKHRoaXMud2lkZ2V0LCBhbGlnbkNsYXNzZXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhbGxvd2VkQ29udGVudDogZ2V0V2lkZ2V0QWxsb3dlZENvbnRlbnQoZWRpdG9yKSxcblxuXHRcdFx0cmVxdWlyZWRDb250ZW50OiAnaW1nW3NyYyxhbHRdJyxcblxuXHRcdFx0ZmVhdHVyZXM6IGdldFdpZGdldEZlYXR1cmVzKGVkaXRvciksXG5cblx0XHRcdHN0eWxlYWJsZUVsZW1lbnRzOiAnaW1nIGZpZ3VyZScsXG5cblx0XHRcdC8vIFRoaXMgd2lkZ2V0IGNvbnZlcnRzIHN0eWxlLWRyaXZlbiBkaW1lbnNpb25zIHRvIGF0dHJpYnV0ZXMuXG5cdFx0XHRjb250ZW50VHJhbnNmb3JtYXRpb25zOiBbWydpbWdbd2lkdGhdOiBzaXplVG9BdHRyaWJ1dGUnXV0sXG5cblx0XHRcdC8vIFRoaXMgd2lkZ2V0IGhhcyBhbiBlZGl0YWJsZSBjYXB0aW9uLlxuXHRcdFx0ZWRpdGFibGVzOiB7XG5cdFx0XHRcdGNhcHRpb246IHtcblx0XHRcdFx0XHRzZWxlY3RvcjogJ2ZpZ2NhcHRpb24nLFxuXHRcdFx0XHRcdGFsbG93ZWRDb250ZW50OiAnYnIgZW0gc3Ryb25nIHN1YiBzdXAgdSBzOyBhWyFocmVmLHRhcmdldF0nLFxuXHRcdFx0XHR9LFxuXHRcdFx0fSxcblxuXHRcdFx0cGFydHM6IHtcblx0XHRcdFx0aW1hZ2U6ICdpbWcnLFxuXHRcdFx0XHRjYXB0aW9uOiAnZmlnY2FwdGlvbicsXG5cdFx0XHRcdC8vIHBhcnRzI2xpbmsgZGVmaW5lZCBpbiB3aWRnZXQjaW5pdFxuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVGVtcGxhdGUgb2YgdGhlIHdpZGdldDogcGxhaW4gaW1hZ2UuXG5cdFx0XHR0ZW1wbGF0ZSxcblxuXHRcdFx0ZGF0YSgpIHtcblx0XHRcdFx0Y29uc3QgZmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xuXG5cdFx0XHRcdC8vIEltYWdlIGNhbid0IGJlIGNhcHRpb25lZCB3aGVuIGZpZ2NhcHRpb24gaXMgZGlzYWxsb3dlZCAoIzExMDA0KS5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMuZGF0YS5oYXNDYXB0aW9uICYmXG5cdFx0XHRcdFx0IWVkaXRvci5maWx0ZXIuY2hlY2tGZWF0dXJlKGZlYXR1cmVzLmNhcHRpb24pXG5cdFx0XHRcdClcblx0XHRcdFx0XHR0aGlzLmRhdGEuaGFzQ2FwdGlvbiA9IGZhbHNlO1xuXG5cdFx0XHRcdC8vIEltYWdlIGNhbid0IGJlIGFsaWduZWQgd2hlbiBmbG9hdGluZyBpcyBkaXNhbGxvd2VkICgjMTEwMDQpLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy5kYXRhLmFsaWduICE9ICdub25lJyAmJlxuXHRcdFx0XHRcdCFlZGl0b3IuZmlsdGVyLmNoZWNrRmVhdHVyZShmZWF0dXJlcy5hbGlnbilcblx0XHRcdFx0KVxuXHRcdFx0XHRcdHRoaXMuZGF0YS5hbGlnbiA9ICdub25lJztcblxuXHRcdFx0XHQvLyBDb252ZXJ0IHRoZSBpbnRlcm5hbCBmb3JtIG9mIHRoZSB3aWRnZXQgZnJvbSB0aGUgb2xkIHN0YXRlIHRvIHRoZSBuZXcgb25lLlxuXHRcdFx0XHR0aGlzLnNoaWZ0U3RhdGUoe1xuXHRcdFx0XHRcdHdpZGdldDogdGhpcyxcblx0XHRcdFx0XHRlbGVtZW50OiB0aGlzLmVsZW1lbnQsXG5cdFx0XHRcdFx0b2xkRGF0YTogdGhpcy5vbGREYXRhLFxuXHRcdFx0XHRcdG5ld0RhdGE6IHRoaXMuZGF0YSxcblx0XHRcdFx0XHRkZWZsYXRlLFxuXHRcdFx0XHRcdGluZmxhdGUsXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSB3aWRnZXQucGFydHMubGluayBzaW5jZSBpdCB3aWxsIG5vdCBhdXRvLXVwZGF0ZSB1bmxlc3Mgd2lkZ2V0XG5cdFx0XHRcdC8vIGlzIGRlc3Ryb3llZCBhbmQgcmUtaW5pdGVkLlxuXHRcdFx0XHRpZiAoIXRoaXMuZGF0YS5saW5rKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMucGFydHMubGluaykgZGVsZXRlIHRoaXMucGFydHMubGluaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIXRoaXMucGFydHMubGluaylcblx0XHRcdFx0XHRcdHRoaXMucGFydHMubGluayA9IHRoaXMucGFydHMuaW1hZ2UuZ2V0UGFyZW50KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLnBhcnRzLmltYWdlLnNldEF0dHJpYnV0ZXMoe1xuXHRcdFx0XHRcdHNyYzogdGhpcy5kYXRhLnNyYyxcblxuXHRcdFx0XHRcdC8vIFRoaXMgaW50ZXJuYWwgaXMgcmVxdWlyZWQgYnkgdGhlIGVkaXRvci5cblx0XHRcdFx0XHQnZGF0YS1ja2Utc2F2ZWQtc3JjJzogdGhpcy5kYXRhLnNyYyxcblxuXHRcdFx0XHRcdGFsdDogdGhpcy5kYXRhLmFsdCxcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Ly8gSWYgc2hpZnRpbmcgbm9uLWNhcHRpb25lZCAtPiBjYXB0aW9uZWQsIHJlbW92ZSBjbGFzc2VzXG5cdFx0XHRcdC8vIHJlbGF0ZWQgdG8gc3R5bGVzIGZyb20gPGltZy8+LlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0dGhpcy5vbGREYXRhICYmXG5cdFx0XHRcdFx0IXRoaXMub2xkRGF0YS5oYXNDYXB0aW9uICYmXG5cdFx0XHRcdFx0dGhpcy5kYXRhLmhhc0NhcHRpb25cblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBjIGluIHRoaXMuZGF0YS5jbGFzc2VzKSB7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5kYXRhLmNsYXNzZXMuaGFzT3duUHJvcGVydHkoYykpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5wYXJ0cy5pbWFnZS5yZW1vdmVDbGFzcyhjKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgZGltZW5zaW9ucyBvZiB0aGUgaW1hZ2UgYWNjb3JkaW5nIHRvIGdhdGhlcmVkIGRhdGEuXG5cdFx0XHRcdC8vIERvIGl0IG9ubHkgd2hlbiB0aGUgYXR0cmlidXRlcyBhcmUgYWxsb3dlZCAoIzExMDA0KS5cblx0XHRcdFx0aWYgKGVkaXRvci5maWx0ZXIuY2hlY2tGZWF0dXJlKGZlYXR1cmVzLmRpbWVuc2lvbikpXG5cdFx0XHRcdFx0c2V0RGltZW5zaW9ucyh0aGlzKTtcblxuXHRcdFx0XHQvLyBDYWNoZSBjdXJyZW50IGRhdGEuXG5cdFx0XHRcdHRoaXMub2xkRGF0YSA9IENLRURJVE9SLnRvb2xzLmV4dGVuZCh7fSwgdGhpcy5kYXRhKTtcblx0XHRcdH0sXG5cblx0XHRcdGluaXQoKSB7XG5cdFx0XHRcdGNvbnN0IGhlbHBlcnMgPSBDS0VESVRPUi5wbHVnaW5zLmFlX2RyYWdyZXNpemVfaWUxMTtcblxuXHRcdFx0XHRjb25zdCBpbWFnZSA9IHRoaXMucGFydHMuaW1hZ2U7XG5cblx0XHRcdFx0Y29uc3QgZGF0YSA9IHtcblx0XHRcdFx0XHRoYXNDYXB0aW9uOiAhIXRoaXMucGFydHMuY2FwdGlvbixcblx0XHRcdFx0XHRzcmM6IGltYWdlLmdldEF0dHJpYnV0ZSgnc3JjJyksXG5cdFx0XHRcdFx0YWx0OiBpbWFnZS5nZXRBdHRyaWJ1dGUoJ2FsdCcpIHx8ICcnLFxuXHRcdFx0XHRcdHdpZHRoOiBpbWFnZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgJycsXG5cdFx0XHRcdFx0aGVpZ2h0OiBpbWFnZS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8ICcnLFxuXG5cdFx0XHRcdFx0Ly8gTG9jayByYXRpbyBpcyBvbiBieSBkZWZhdWx0ICgjMTA4MzMpLlxuXHRcdFx0XHRcdGxvY2s6IHRoaXMucmVhZHlcblx0XHRcdFx0XHRcdD8gaGVscGVycy5jaGVja0hhc05hdHVyYWxSYXRpbyhpbWFnZSlcblx0XHRcdFx0XHRcdDogdHJ1ZSxcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBJZiB3ZSB1c2VkICdhJyBpbiB3aWRnZXQjcGFydHMgZGVmaW5pdGlvbiwgaXQgY291bGQgaGFwcGVuIHRoYXRcblx0XHRcdFx0Ly8gc2VsZWN0ZWQgZWxlbWVudCBpcyBhIGNoaWxkIG9mIHdpZGdldC5wYXJ0cyNjYXB0aW9uLiBTaW5jZSB0aGVyZSdzIG5vIGNsZXZlclxuXHRcdFx0XHQvLyB3YXkgdG8gc29sdmUgaXQgd2l0aCBDU1Mgc2VsZWN0b3JzLCBpdCdzIGRvbmUgbGlrZSB0aGF0LiAoIzExNzgzKS5cblx0XHRcdFx0Y29uc3QgbGluayA9IGltYWdlLmdldEFzY2VuZGFudCgnYScpO1xuXG5cdFx0XHRcdGlmIChsaW5rICYmIHRoaXMud3JhcHBlci5jb250YWlucyhsaW5rKSkgdGhpcy5wYXJ0cy5saW5rID0gbGluaztcblxuXHRcdFx0XHQvLyBEZXBlbmRpbmcgb24gY29uZmlndXJhdGlvbiwgcmVhZCBzdHlsZS9jbGFzcyBmcm9tIGVsZW1lbnQgYW5kXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIGl0LiBSZW1vdmVkIHN0eWxlL2NsYXNzIHdpbGwgYmUgc2V0IG9uIHdyYXBwZXIgaW4gI2RhdGEgbGlzdGVuZXIuXG5cdFx0XHRcdC8vIE5vdGU6IENlbnRlciBhbGlnbm1lbnQgaXMgZGV0ZWN0ZWQgZHVyaW5nIHVwY2FzdCwgc28gb25seSBsZWZ0L3JpZ2h0IGNhc2VzXG5cdFx0XHRcdC8vIGFyZSBjaGVja2VkIGJlbG93LlxuXHRcdFx0XHRpZiAoIWRhdGEuYWxpZ24pIHtcblx0XHRcdFx0XHRjb25zdCBhbGlnbkVsZW1lbnQgPSBkYXRhLmhhc0NhcHRpb24gPyB0aGlzLmVsZW1lbnQgOiBpbWFnZTtcblxuXHRcdFx0XHRcdC8vIFJlYWQgdGhlIGluaXRpYWwgbGVmdC9yaWdodCBhbGlnbm1lbnQgZnJvbSB0aGUgY2xhc3Mgc2V0IG9uIGVsZW1lbnQuXG5cdFx0XHRcdFx0aWYgKGFsaWduQ2xhc3Nlcykge1xuXHRcdFx0XHRcdFx0aWYgKGFsaWduRWxlbWVudC5oYXNDbGFzcyhhbGlnbkNsYXNzZXNbMF0pKSB7XG5cdFx0XHRcdFx0XHRcdGRhdGEuYWxpZ24gPSAnbGVmdCc7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGFsaWduRWxlbWVudC5oYXNDbGFzcyhhbGlnbkNsYXNzZXNbMl0pKSB7XG5cdFx0XHRcdFx0XHRcdGRhdGEuYWxpZ24gPSAncmlnaHQnO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAoZGF0YS5hbGlnbikge1xuXHRcdFx0XHRcdFx0XHRhbGlnbkVsZW1lbnQucmVtb3ZlQ2xhc3MoXG5cdFx0XHRcdFx0XHRcdFx0YWxpZ25DbGFzc2VzW2FsaWdubWVudHNPYmpbZGF0YS5hbGlnbl1dXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkYXRhLmFsaWduID0gJ25vbmUnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBSZWFkIGluaXRpYWwgZmxvYXQgc3R5bGUgZnJvbSBmaWd1cmUvaW1hZ2UgYW5kIHRoZW4gcmVtb3ZlIGl0LlxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0ZGF0YS5hbGlnbiA9IGFsaWduRWxlbWVudC5nZXRTdHlsZSgnZmxvYXQnKSB8fCAnbm9uZSc7XG5cdFx0XHRcdFx0XHRhbGlnbkVsZW1lbnQucmVtb3ZlU3R5bGUoJ2Zsb2F0Jyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVXBkYXRlIGRhdGEubGluayBvYmplY3Qgd2l0aCBhdHRyaWJ1dGVzIGlmIHRoZSBsaW5rIGhhcyBiZWVuIGRpc2NvdmVyZWQuXG5cdFx0XHRcdGlmIChlZGl0b3IucGx1Z2lucy5saW5rICYmIHRoaXMucGFydHMubGluaykge1xuXHRcdFx0XHRcdGRhdGEubGluayA9IGhlbHBlcnMuZ2V0TGlua0F0dHJpYnV0ZXNQYXJzZXIoKShcblx0XHRcdFx0XHRcdGVkaXRvcixcblx0XHRcdFx0XHRcdHRoaXMucGFydHMubGlua1xuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBHZXQgcmlkIG9mIGNrZV93aWRnZXRfKiBjbGFzc2VzIGluIGRhdGEuIE90aGVyd2lzZVxuXHRcdFx0XHRcdC8vIHRoZXkgbWlnaHQgYXBwZWFyIGluIGxpbmsgZGlhbG9nLlxuXHRcdFx0XHRcdGNvbnN0IGFkdmFuY2VkID0gZGF0YS5saW5rLmFkdmFuY2VkO1xuXHRcdFx0XHRcdGlmIChhZHZhbmNlZCAmJiBhZHZhbmNlZC5hZHZDU1NDbGFzc2VzKSB7XG5cdFx0XHRcdFx0XHRhZHZhbmNlZC5hZHZDU1NDbGFzc2VzID0gQ0tFRElUT1IudG9vbHMudHJpbShcblx0XHRcdFx0XHRcdFx0YWR2YW5jZWQuYWR2Q1NTQ2xhc3Nlcy5yZXBsYWNlKC9ja2VfXFxTKy8sICcnKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgcmlkIG9mIGV4dHJhIHZlcnRpY2FsIHNwYWNlIHdoZW4gdGhlcmUncyBubyBjYXB0aW9uLlxuXHRcdFx0XHQvLyBJdCB3aWxsIGltcHJvdmUgdGhlIGxvb2sgb2YgdGhlIHJlc2l6ZXIuXG5cdFx0XHRcdHRoaXMud3JhcHBlclsoZGF0YS5oYXNDYXB0aW9uID8gJ3JlbW92ZScgOiAnYWRkJykgKyAnQ2xhc3MnXShcblx0XHRcdFx0XHQnY2tlX2ltYWdlX25vY2FwdGlvbidcblx0XHRcdFx0KTtcblxuXHRcdFx0XHR0aGlzLnNldERhdGEoZGF0YSk7XG5cblx0XHRcdFx0Ly8gU2V0dXAgZHluYW1pYyBpbWFnZSByZXNpemluZyB3aXRoIG1vdXNlLlxuXHRcdFx0XHQvLyBEb24ndCBpbml0aWFsaXplIHJlc2l6ZXIgd2hlbiBkaW1lbnNpb25zIGFyZSBkaXNhbGxvd2VkICgjMTEwMDQpLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0ZWRpdG9yLmZpbHRlci5jaGVja0ZlYXR1cmUodGhpcy5mZWF0dXJlcy5kaW1lbnNpb24pICYmXG5cdFx0XHRcdFx0ZWRpdG9yLmNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfZGlzYWJsZVJlc2l6ZXIgIT09IHRydWVcblx0XHRcdFx0KVxuXHRcdFx0XHRcdHNldHVwUmVzaXplcih0aGlzKTtcblxuXHRcdFx0XHRjb25zdCBkcmFnSGFuZGxlclN0eWxlID0gdGhpcy5kcmFnSGFuZGxlckNvbnRhaW5lci4kLnN0eWxlO1xuXHRcdFx0XHRkcmFnSGFuZGxlclN0eWxlLnNldEF0dHJpYnV0ZShcblx0XHRcdFx0XHQnYmFja2dyb3VuZENvbG9yJyxcblx0XHRcdFx0XHQncmdiYSgyNTUsIDI1NSwgMjU1LCAxJ1xuXHRcdFx0XHQpO1xuXHRcdFx0XHRkcmFnSGFuZGxlclN0eWxlLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsICcxJyk7XG5cblx0XHRcdFx0dGhpcy5zaGlmdFN0YXRlID0gaGVscGVycy5zdGF0ZVNoaWZ0ZXIodGhpcy5lZGl0b3IpO1xuXG5cdFx0XHRcdC8vIEFkZCB3aWRnZXQgZWRpdGluZyBvcHRpb24gdG8gaXRzIGNvbnRleHQgbWVudS5cblx0XHRcdFx0dGhpcy5vbignY29udGV4dE1lbnUnLCBmdW5jdGlvbihldnQpIHtcblx0XHRcdFx0XHRldnQuZGF0YS5pbWFnZSA9IENLRURJVE9SLlRSSVNUQVRFX09GRjtcblxuXHRcdFx0XHRcdC8vIEludGVncmF0ZSBjb250ZXh0IG1lbnUgaXRlbXMgZm9yIGxpbmsuXG5cdFx0XHRcdFx0Ly8gTm90ZSB0aGF0IHdpZGdldCBtYXkgYmUgd3JhcHBlZCBpbiBhIGxpbmssIHdoaWNoXG5cdFx0XHRcdFx0Ly8gZG9lcyBub3QgYmVsb25nIHRvIHRoYXQgd2lkZ2V0ICgjMTE4MTQpLlxuXHRcdFx0XHRcdGlmICh0aGlzLnBhcnRzLmxpbmsgfHwgdGhpcy53cmFwcGVyLmdldEFzY2VuZGFudCgnYScpKVxuXHRcdFx0XHRcdFx0ZXZ0LmRhdGEubGluayA9IGV2dC5kYXRhLnVubGluayA9IENLRURJVE9SLlRSSVNUQVRFX09GRjtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBPdmVycmlkZXMgZGVmYXVsdCBtZXRob2QgdG8gaGFuZGxlIGludGVybmFsIG11dGFiaWxpdHkgb2YgYWVfZHJhZ3Jlc2l6ZV9pZTExLlxuXHRcdFx0Ly8gQHNlZSBDS0VESVRPUi5wbHVnaW5zLndpZGdldCNhZGRDbGFzc1xuXHRcdFx0YWRkQ2xhc3MoY2xhc3NOYW1lKSB7XG5cdFx0XHRcdGdldFN0eWxlYWJsZUVsZW1lbnQodGhpcykuYWRkQ2xhc3MoY2xhc3NOYW1lKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIE92ZXJyaWRlcyBkZWZhdWx0IG1ldGhvZCB0byBoYW5kbGUgaW50ZXJuYWwgbXV0YWJpbGl0eSBvZiBhZV9kcmFncmVzaXplX2llMTEuXG5cdFx0XHQvLyBAc2VlIENLRURJVE9SLnBsdWdpbnMud2lkZ2V0I2hhc0NsYXNzXG5cdFx0XHRoYXNDbGFzcyhjbGFzc05hbWUpIHtcblx0XHRcdFx0cmV0dXJuIGdldFN0eWxlYWJsZUVsZW1lbnQodGhpcykuaGFzQ2xhc3MoY2xhc3NOYW1lKTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIE92ZXJyaWRlcyBkZWZhdWx0IG1ldGhvZCB0byBoYW5kbGUgaW50ZXJuYWwgbXV0YWJpbGl0eSBvZiBhZV9kcmFncmVzaXplX2llMTEuXG5cdFx0XHQvLyBAc2VlIENLRURJVE9SLnBsdWdpbnMud2lkZ2V0I3JlbW92ZUNsYXNzXG5cdFx0XHRyZW1vdmVDbGFzcyhjbGFzc05hbWUpIHtcblx0XHRcdFx0Z2V0U3R5bGVhYmxlRWxlbWVudCh0aGlzKS5yZW1vdmVDbGFzcyhjbGFzc05hbWUpO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gT3ZlcnJpZGVzIGRlZmF1bHQgbWV0aG9kIHRvIGhhbmRsZSBpbnRlcm5hbCBtdXRhYmlsaXR5IG9mIGFlX2RyYWdyZXNpemVfaWUxMS5cblx0XHRcdC8vIEBzZWUgQ0tFRElUT1IucGx1Z2lucy53aWRnZXQjZ2V0Q2xhc3Nlc1xuXHRcdFx0Z2V0Q2xhc3NlczogKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjb25zdCBjbGFzc1JlZ2V4ID0gbmV3IFJlZ0V4cChcblx0XHRcdFx0XHQnXignICtcblx0XHRcdFx0XHRcdFtdLmNvbmNhdChjYXB0aW9uZWRDbGFzcywgYWxpZ25DbGFzc2VzKS5qb2luKCd8JykgK1xuXHRcdFx0XHRcdFx0JykkJ1xuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRjb25zdCBjbGFzc2VzID0gdGhpcy5yZXBvc2l0b3J5LnBhcnNlRWxlbWVudENsYXNzZXMoXG5cdFx0XHRcdFx0XHRnZXRTdHlsZWFibGVFbGVtZW50KHRoaXMpLmdldEF0dHJpYnV0ZSgnY2xhc3MnKVxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBOZWl0aGVyIGNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfY2FwdGlvbmVkQ2xhc3Mgbm9yIGNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfYWxpZ25DbGFzc2VzXG5cdFx0XHRcdFx0Ly8gZG8gbm90IGJlbG9uZyB0byBzdHlsZSBjbGFzc2VzLlxuXHRcdFx0XHRcdGZvciAoY29uc3QgYyBpbiBjbGFzc2VzKSB7XG5cdFx0XHRcdFx0XHRpZiAoY2xhc3NSZWdleC50ZXN0KGMpKSBkZWxldGUgY2xhc3Nlc1tjXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gY2xhc3Nlcztcblx0XHRcdFx0fTtcblx0XHRcdH0pKCksXG5cblx0XHRcdHVwY2FzdDogdXBjYXN0V2lkZ2V0RWxlbWVudChlZGl0b3IpLFxuXHRcdFx0ZG93bmNhc3Q6IGRvd25jYXN0V2lkZ2V0RWxlbWVudChlZGl0b3IpLFxuXG5cdFx0XHRnZXRMYWJlbCgpIHtcblx0XHRcdFx0Y29uc3QgbGFiZWwgPSAodGhpcy5kYXRhLmFsdCB8fCAnJykgKyAnICcgKyB0aGlzLnBhdGhOYW1lO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLmVkaXRvci5sYW5nLndpZGdldC5sYWJlbC5yZXBsYWNlKC8lMS8sIGxhYmVsKTtcblx0XHRcdH0sXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNldCBvZiBFbmhhbmNlZCBJbWFnZSAoYWVfZHJhZ3Jlc2l6ZV9pZTExKSBwbHVnaW4gaGVscGVycy5cblx0ICpcblx0ICogQGNsYXNzXG5cdCAqIEBzaW5nbGV0b25cblx0ICovXG5cdENLRURJVE9SLnBsdWdpbnMuYWVfZHJhZ3Jlc2l6ZV9pZTExID0ge1xuXHRcdHN0YXRlU2hpZnRlcihlZGl0b3IpIHtcblx0XHRcdC8vIFRhZyBuYW1lIHVzZWQgZm9yIGNlbnRlcmluZyBub24tY2FwdGlvbmVkIHdpZGdldHMuXG5cdFx0XHRjb25zdCBkb2MgPSBlZGl0b3IuZG9jdW1lbnQ7XG5cblx0XHRcdGNvbnN0IGFsaWduQ2xhc3NlcyA9IGVkaXRvci5jb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2FsaWduQ2xhc3NlcztcblxuXHRcdFx0Y29uc3QgY2FwdGlvbmVkQ2xhc3MgPVxuXHRcdFx0XHRlZGl0b3IuY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9jYXB0aW9uZWRDbGFzcztcblxuXHRcdFx0Y29uc3QgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuXHRcdFx0Ly8gVGhlIG9yZGVyIHRoYXQgc3RhdGVBY3Rpb25zIGdldCBleGVjdXRlZC4gSXQgbWF0dGVycyFcblxuXHRcdFx0Y29uc3Qgc2hpZnRhYmxlcyA9IFsnaGFzQ2FwdGlvbicsICdhbGlnbicsICdsaW5rJ107XG5cblx0XHRcdC8vIEF0b21pYyBwcm9jZWR1cmVzLCBvbmUgcGVyIHN0YXRlIHZhcmlhYmxlLlxuXHRcdFx0Y29uc3Qgc3RhdGVBY3Rpb25zID0ge1xuXHRcdFx0XHRhbGlnbihzaGlmdCwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG5cdFx0XHRcdFx0Y29uc3QgZWwgPSBzaGlmdC5lbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gQWxpZ25tZW50IGNoYW5nZWQuXG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0c2hpZnQuY2hhbmdlZC5hbGlnbiB8fFxuXHRcdFx0XHRcdFx0KGVsLiQuc3R5bGUubWFyZ2luTGVmdCA9PT0gJ2F1dG8nICYmXG5cdFx0XHRcdFx0XHRcdGVsLiQuc3R5bGUubWFyZ2luUmlnaHQgPT09ICdhdXRvJylcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdC8vIE5vIGNhcHRpb24gaW4gdGhlIG5ldyBzdGF0ZS5cblx0XHRcdFx0XHRcdGlmICghc2hpZnQubmV3RGF0YS5oYXNDYXB0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdC8vIENoYW5nZWQgdG8gXCJjZW50ZXJcIiAobm9uLWNhcHRpb25lZCkuXG5cdFx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0XHRuZXdWYWx1ZSA9PSAnY2VudGVyJyB8fFxuXHRcdFx0XHRcdFx0XHRcdChlbC4kLnN0eWxlLm1hcmdpbkxlZnQgPT09ICdhdXRvJyAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0ZWwuJC5zdHlsZS5tYXJnaW5SaWdodCA9PT0gJ2F1dG8nKVxuXHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHRzaGlmdC5kZWZsYXRlKCk7XG5cdFx0XHRcdFx0XHRcdFx0c2hpZnQuZWxlbWVudCA9IHdyYXBJbkNlbnRlcmluZyhlZGl0b3IsIGVsKTtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIENoYW5nZWQgdG8gXCJub24tY2VudGVyXCIgZnJvbSBcImNlbnRlclwiIHdoaWxlIGNhcHRpb24gcmVtb3ZlZC5cblx0XHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRcdCFzaGlmdC5jaGFuZ2VkLmhhc0NhcHRpb24gJiZcblx0XHRcdFx0XHRcdFx0XHRvbGRWYWx1ZSA9PSAnY2VudGVyJyAmJlxuXHRcdFx0XHRcdFx0XHRcdG5ld1ZhbHVlICE9ICdjZW50ZXInXG5cdFx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRcdHNoaWZ0LmRlZmxhdGUoKTtcblx0XHRcdFx0XHRcdFx0XHRzaGlmdC5lbGVtZW50ID0gdW53cmFwRnJvbUNlbnRlcmluZyhlbCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBBbGlnbm1lbnQgcmVtYWlucyBhbmQgXCJjZW50ZXJcIiByZW1vdmVkIGNhcHRpb24uXG5cdFx0XHRcdFx0ZWxzZSBpZiAoXG5cdFx0XHRcdFx0XHRuZXdWYWx1ZSA9PSAnY2VudGVyJyAmJlxuXHRcdFx0XHRcdFx0c2hpZnQuY2hhbmdlZC5oYXNDYXB0aW9uICYmXG5cdFx0XHRcdFx0XHQhc2hpZnQubmV3RGF0YS5oYXNDYXB0aW9uXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRzaGlmdC5kZWZsYXRlKCk7XG5cdFx0XHRcdFx0XHRzaGlmdC5lbGVtZW50ID0gd3JhcEluQ2VudGVyaW5nKGVkaXRvciwgZWwpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZpbmFsbHkgc2V0IGRpc3BsYXkgZm9yIGZpZ3VyZS5cblx0XHRcdFx0XHRpZiAoIWFsaWduQ2xhc3NlcyAmJiBlbC5pcygnZmlndXJlJykpIHtcblx0XHRcdFx0XHRcdGlmIChuZXdWYWx1ZSA9PSAnY2VudGVyJylcblx0XHRcdFx0XHRcdFx0ZWwuc2V0U3R5bGUoJ2Rpc3BsYXknLCAnaW5saW5lLWJsb2NrJyk7XG5cdFx0XHRcdFx0XHRlbHNlIGVsLnJlbW92ZVN0eWxlKCdkaXNwbGF5Jyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGhhc0NhcHRpb24oc2hpZnQsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuXHRcdFx0XHRcdC8vIFRoaXMgYWN0aW9uIGlzIGZvciByZWFsIHN0YXRlIGNoYW5nZSBvbmx5LlxuXHRcdFx0XHRcdGlmICghc2hpZnQuY2hhbmdlZC5oYXNDYXB0aW9uKSByZXR1cm47XG5cblx0XHRcdFx0XHQvLyBHZXQgPGltZy8+IG9yIDxhPjxpbWcvPjwvYT4gZnJvbSB3aWRnZXQuIE5vdGUgdGhhdCB3aWRnZXQgZWxlbWVudCBtaWdodCBpdHNlbGZcblx0XHRcdFx0XHQvLyBiZSB3aGF0IHdlJ3JlIGxvb2tpbmcgZm9yLiBBbHNvIGVsZW1lbnQgY2FuIGJlIDxwIHN0eWxlPVwidGV4dC1hbGlnbjpjZW50ZXJcIj48YT4uLi48L2E+PC9wPi5cblx0XHRcdFx0XHRsZXQgaW1hZ2VPckxpbms7XG5cdFx0XHRcdFx0aWYgKHNoaWZ0LmVsZW1lbnQuaXMoe2ltZzogMSwgYTogMX0pKVxuXHRcdFx0XHRcdFx0aW1hZ2VPckxpbmsgPSBzaGlmdC5lbGVtZW50O1xuXHRcdFx0XHRcdGVsc2UgaW1hZ2VPckxpbmsgPSBzaGlmdC5lbGVtZW50LmZpbmRPbmUoJ2EsaW1nJyk7XG5cblx0XHRcdFx0XHQvLyBTd2l0Y2hpbmcgaGFzQ2FwdGlvbiBhbHdheXMgZGVzdHJveXMgdGhlIHdpZGdldC5cblx0XHRcdFx0XHRzaGlmdC5kZWZsYXRlKCk7XG5cblx0XHRcdFx0XHQvLyBUaGVyZSB3YXMgbm8gY2FwdGlvbiwgYnV0IHRoZSBjYXB0aW9uIGlzIHRvIGJlIGFkZGVkLlxuXHRcdFx0XHRcdGlmIChuZXdWYWx1ZSkge1xuXHRcdFx0XHRcdFx0Ly8gQ3JlYXRlIG5ldyA8ZmlndXJlPiBmcm9tIHdpZGdldCB0ZW1wbGF0ZS5cblx0XHRcdFx0XHRcdGNvbnN0IGZpZ3VyZSA9IENLRURJVE9SLmRvbS5lbGVtZW50LmNyZWF0ZUZyb21IdG1sKFxuXHRcdFx0XHRcdFx0XHR0ZW1wbGF0ZUJsb2NrLm91dHB1dCh7XG5cdFx0XHRcdFx0XHRcdFx0Y2FwdGlvbmVkQ2xhc3MsXG5cdFx0XHRcdFx0XHRcdFx0Y2FwdGlvblBsYWNlaG9sZGVyOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZWRpdG9yLmxhbmcuYWVfZHJhZ3Jlc2l6ZV9pZTExXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5jYXB0aW9uUGxhY2Vob2xkZXIsXG5cdFx0XHRcdFx0XHRcdH0pLFxuXHRcdFx0XHRcdFx0XHRkb2Ncblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIFJlcGxhY2UgZWxlbWVudCB3aXRoIDxmaWd1cmU+LlxuXHRcdFx0XHRcdFx0cmVwbGFjZVNhZmVseShmaWd1cmUsIHNoaWZ0LmVsZW1lbnQpO1xuXG5cdFx0XHRcdFx0XHQvLyBVc2Ugb2xkIDxpbWcvPiBvciA8YT48aW1nLz48L2E+IGluc3RlYWQgb2YgdGhlIG9uZSBmcm9tIHRoZSB0ZW1wbGF0ZSxcblx0XHRcdFx0XHRcdC8vIHNvIHdlIHdvbid0IGxvc2UgYWRkaXRpb25hbCBhdHRyaWJ1dGVzLlxuXHRcdFx0XHRcdFx0aW1hZ2VPckxpbmsucmVwbGFjZShmaWd1cmUuZmluZE9uZSgnaW1nJykpO1xuXG5cdFx0XHRcdFx0XHQvLyBVcGRhdGUgd2lkZ2V0J3MgZWxlbWVudC5cblx0XHRcdFx0XHRcdHNoaWZ0LmVsZW1lbnQgPSBmaWd1cmU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gVGhlIGNhcHRpb24gd2FzIHByZXNlbnQsIGJ1dCBub3cgaXQncyB0byBiZSByZW1vdmVkLlxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gVW53cmFwIDxpbWcvPiBvciA8YT48aW1nLz48L2E+IGZyb20gZmlndXJlLlxuXHRcdFx0XHRcdFx0aW1hZ2VPckxpbmsucmVwbGFjZShzaGlmdC5lbGVtZW50KTtcblxuXHRcdFx0XHRcdFx0Ly8gVXBkYXRlIHdpZGdldCdzIGVsZW1lbnQuXG5cdFx0XHRcdFx0XHRzaGlmdC5lbGVtZW50ID0gaW1hZ2VPckxpbms7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGxpbmsoc2hpZnQsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuXHRcdFx0XHRcdGlmIChzaGlmdC5jaGFuZ2VkLmxpbmspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGltZyA9IHNoaWZ0LmVsZW1lbnQuaXMoJ2ltZycpXG5cdFx0XHRcdFx0XHRcdD8gc2hpZnQuZWxlbWVudFxuXHRcdFx0XHRcdFx0XHQ6IHNoaWZ0LmVsZW1lbnQuZmluZE9uZSgnaW1nJyk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGxpbmsgPSBzaGlmdC5lbGVtZW50LmlzKCdhJylcblx0XHRcdFx0XHRcdFx0PyBzaGlmdC5lbGVtZW50XG5cdFx0XHRcdFx0XHRcdDogc2hpZnQuZWxlbWVudC5maW5kT25lKCdhJyk7XG5cblx0XHRcdFx0XHRcdC8vIFdoeSBkZWZsYXRlOlxuXHRcdFx0XHRcdFx0Ly8gSWYgZWxlbWVudCBpcyA8aW1nLz4sIGl0IHdpbGwgYmUgd3JhcHBlZCBpbnRvIDxhPixcblx0XHRcdFx0XHRcdC8vIHdoaWNoIGJlY29tZXMgYSBuZXcgd2lkZ2V0LmVsZW1lbnQuXG5cdFx0XHRcdFx0XHQvLyBJZiBlbGVtZW50IGlzIDxhPjxpbWcvPjwvYT4sIGl0IHdpbGwgYmUgdW5saW5rZWRcblx0XHRcdFx0XHRcdC8vIHNvIDxpbWcvPiBiZWNvbWVzIGEgbmV3IHdpZGdldC5lbGVtZW50LlxuXG5cdFx0XHRcdFx0XHRjb25zdCBuZWVkc0RlZmxhdGUgPVxuXHRcdFx0XHRcdFx0XHQoc2hpZnQuZWxlbWVudC5pcygnYScpICYmICFuZXdWYWx1ZSkgfHxcblx0XHRcdFx0XHRcdFx0KHNoaWZ0LmVsZW1lbnQuaXMoJ2ltZycpICYmIG5ld1ZhbHVlKTtcblxuXHRcdFx0XHRcdFx0bGV0IG5ld0VsO1xuXG5cdFx0XHRcdFx0XHRpZiAobmVlZHNEZWZsYXRlKSBzaGlmdC5kZWZsYXRlKCk7XG5cblx0XHRcdFx0XHRcdC8vIElmIHVubGlua2VkIHRoZSBpbWFnZSwgcmV0dXJuZWQgZWxlbWVudCBpcyA8aW1nPi5cblx0XHRcdFx0XHRcdGlmICghbmV3VmFsdWUpIG5ld0VsID0gdW53cmFwRnJvbUxpbmsobGluayk7XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gSWYgbGlua2VkIHRoZSBpbWFnZSwgcmV0dXJuZWQgZWxlbWVudCBpcyA8YT4uXG5cdFx0XHRcdFx0XHRcdGlmICghb2xkVmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0bmV3RWwgPSB3cmFwSW5MaW5rKGltZywgc2hpZnQubmV3RGF0YS5saW5rKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZXQgYW5kIHJlbW92ZSBhbGwgYXR0cmlidXRlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdGF0ZS5cblx0XHRcdFx0XHRcdFx0Y29uc3QgYXR0cmlidXRlcyA9IENLRURJVE9SLnBsdWdpbnMuYWVfZHJhZ3Jlc2l6ZV9pZTExLmdldExpbmtBdHRyaWJ1dGVzR2V0dGVyKCkoXG5cdFx0XHRcdFx0XHRcdFx0ZWRpdG9yLFxuXHRcdFx0XHRcdFx0XHRcdG5ld1ZhbHVlXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCFDS0VESVRPUi50b29scy5pc0VtcHR5KGF0dHJpYnV0ZXMuc2V0KSlcblx0XHRcdFx0XHRcdFx0XHQobmV3RWwgfHwgbGluaykuc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzLnNldCk7XG5cblx0XHRcdFx0XHRcdFx0aWYgKGF0dHJpYnV0ZXMucmVtb3ZlZC5sZW5ndGgpXG5cdFx0XHRcdFx0XHRcdFx0KG5ld0VsIHx8IGxpbmspLnJlbW92ZUF0dHJpYnV0ZXMoXG5cdFx0XHRcdFx0XHRcdFx0XHRhdHRyaWJ1dGVzLnJlbW92ZWRcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAobmVlZHNEZWZsYXRlKSBzaGlmdC5lbGVtZW50ID0gbmV3RWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0fTtcblxuXHRcdFx0ZnVuY3Rpb24gd3JhcEluQ2VudGVyaW5nKGVkaXRvciwgZWxlbWVudCkge1xuXHRcdFx0XHRjb25zdCBhdHRyaWJzQW5kU3R5bGVzID0ge307XG5cblx0XHRcdFx0aWYgKGFsaWduQ2xhc3Nlcylcblx0XHRcdFx0XHRhdHRyaWJzQW5kU3R5bGVzLmF0dHJpYnV0ZXMgPSB7Y2xhc3M6IGFsaWduQ2xhc3Nlc1sxXX07XG5cdFx0XHRcdGVsc2UgYXR0cmlic0FuZFN0eWxlcy5zdHlsZXMgPSB7J3RleHQtYWxpZ24nOiAnY2VudGVyJ307XG5cblx0XHRcdFx0Ly8gVGhlcmUncyBubyBnZW50bGUgd2F5IHRvIGNlbnRlciBpbmxpbmUgZWxlbWVudCB3aXRoIENTUywgc28gY3JlYXRlIHAvZGl2XG5cdFx0XHRcdC8vIHRoYXQgd3JhcHMgd2lkZ2V0IGNvbnRlbnRzIGFuZCBkb2VzIHRoZSB0cmljayBlaXRoZXIgd2l0aCBzdHlsZSBvciBjbGFzcy5cblx0XHRcdFx0Y29uc3QgY2VudGVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdFx0ZWRpdG9yLmFjdGl2ZUVudGVyTW9kZSA9PSBDS0VESVRPUi5FTlRFUl9QID8gJ3AnIDogJ2RpdicsXG5cdFx0XHRcdFx0YXR0cmlic0FuZFN0eWxlc1xuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIFJlcGxhY2UgZWxlbWVudCB3aXRoIGNlbnRlcmluZyB3cmFwcGVyLlxuXHRcdFx0XHRyZXBsYWNlU2FmZWx5KGNlbnRlciwgZWxlbWVudCk7XG5cdFx0XHRcdGVsZW1lbnQubW92ZShjZW50ZXIpO1xuXG5cdFx0XHRcdHJldHVybiBjZW50ZXI7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHVud3JhcEZyb21DZW50ZXJpbmcoZWxlbWVudCkge1xuXHRcdFx0XHRjb25zdCBpbWFnZU9yTGluayA9IGVsZW1lbnQuZmluZE9uZSgnYSxpbWcnKTtcblxuXHRcdFx0XHRpbWFnZU9yTGluay5yZXBsYWNlKGVsZW1lbnQpO1xuXG5cdFx0XHRcdHJldHVybiBpbWFnZU9yTGluaztcblx0XHRcdH1cblxuXHRcdFx0Ly8gV3JhcHMgPGltZy8+IC0+IDxhPjxpbWcvPjwvYT4uXG5cdFx0XHQvLyBSZXR1cm5zIHJlZmVyZW5jZSB0byA8YT4uXG5cdFx0XHQvL1xuXHRcdFx0Ly8gQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gaW1nXG5cdFx0XHQvLyBAcGFyYW0ge09iamVjdH0gbGlua0RhdGFcblx0XHRcdC8vIEByZXR1cm5zIHtDS0VESVRPUi5kb20uZWxlbWVudH1cblx0XHRcdGZ1bmN0aW9uIHdyYXBJbkxpbmsoaW1nLCBsaW5rRGF0YSkge1xuXHRcdFx0XHRjb25zdCBsaW5rID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2EnLCB7XG5cdFx0XHRcdFx0YXR0cmlidXRlczoge1xuXHRcdFx0XHRcdFx0aHJlZjogbGlua0RhdGEudXJsLFxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGxpbmsucmVwbGFjZShpbWcpO1xuXHRcdFx0XHRpbWcubW92ZShsaW5rKTtcblxuXHRcdFx0XHRyZXR1cm4gbGluaztcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGUtd3JhcHMgPGE+PGltZy8+PC9hPiAtPiA8aW1nLz4uXG5cdFx0XHQvLyBSZXR1cm5zIHRoZSByZWZlcmVuY2UgdG8gPGltZy8+XG5cdFx0XHQvL1xuXHRcdFx0Ly8gQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gbGlua1xuXHRcdFx0Ly8gQHJldHVybnMge0NLRURJVE9SLmRvbS5lbGVtZW50fVxuXHRcdFx0ZnVuY3Rpb24gdW53cmFwRnJvbUxpbmsobGluaykge1xuXHRcdFx0XHRjb25zdCBpbWcgPSBsaW5rLmZpbmRPbmUoJ2ltZycpO1xuXG5cdFx0XHRcdGltZy5yZXBsYWNlKGxpbmspO1xuXG5cdFx0XHRcdHJldHVybiBpbWc7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHJlcGxhY2VTYWZlbHkocmVwbGFjaW5nLCByZXBsYWNlZCkge1xuXHRcdFx0XHRpZiAocmVwbGFjZWQuZ2V0UGFyZW50KCkpIHtcblx0XHRcdFx0XHRjb25zdCByYW5nZSA9IGVkaXRvci5jcmVhdGVSYW5nZSgpO1xuXG5cdFx0XHRcdFx0cmFuZ2UubW92ZVRvUG9zaXRpb24oXG5cdFx0XHRcdFx0XHRyZXBsYWNlZCxcblx0XHRcdFx0XHRcdENLRURJVE9SLlBPU0lUSU9OX0JFRk9SRV9TVEFSVFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHQvLyBSZW1vdmUgb2xkIGVsZW1lbnQuIERvIGl0IGJlZm9yZSBpbnNlcnRpb24gdG8gYXZvaWQgYSBjYXNlIHdoZW5cblx0XHRcdFx0XHQvLyBlbGVtZW50IGlzIG1vdmVkIGZyb20gJ3JlcGxhY2VkJyBlbGVtZW50IGJlZm9yZSBpdCwgd2hhdCBjcmVhdGVzXG5cdFx0XHRcdFx0Ly8gYSB0cmlja3kgY2FzZSB3aGljaCBpbnNlcnRFbGVtZW50SW50b3JSYW5nZSBkb2VzIG5vdCBoYW5kbGUuXG5cdFx0XHRcdFx0cmVwbGFjZWQucmVtb3ZlKCk7XG5cblx0XHRcdFx0XHRlZGl0YWJsZS5pbnNlcnRFbGVtZW50SW50b1JhbmdlKHJlcGxhY2luZywgcmFuZ2UpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlcGxhY2luZy5yZXBsYWNlKHJlcGxhY2VkKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oc2hpZnQpIHtcblx0XHRcdFx0bGV0IG5hbWU7XG5cdFx0XHRcdGxldCBpO1xuXG5cdFx0XHRcdHNoaWZ0LmNoYW5nZWQgPSB7fTtcblxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc2hpZnRhYmxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG5hbWUgPSBzaGlmdGFibGVzW2ldO1xuXG5cdFx0XHRcdFx0c2hpZnQuY2hhbmdlZFtuYW1lXSA9IHNoaWZ0Lm9sZERhdGFcblx0XHRcdFx0XHRcdD8gc2hpZnQub2xkRGF0YVtuYW1lXSAhPT0gc2hpZnQubmV3RGF0YVtuYW1lXVxuXHRcdFx0XHRcdFx0OiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEl0ZXJhdGUgb3ZlciBwb3NzaWJsZSBzdGF0ZSB2YXJpYWJsZXMuXG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBzaGlmdGFibGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0bmFtZSA9IHNoaWZ0YWJsZXNbaV07XG5cblx0XHRcdFx0XHRzdGF0ZUFjdGlvbnNbbmFtZV0oXG5cdFx0XHRcdFx0XHRzaGlmdCxcblx0XHRcdFx0XHRcdHNoaWZ0Lm9sZERhdGEgPyBzaGlmdC5vbGREYXRhW25hbWVdIDogbnVsbCxcblx0XHRcdFx0XHRcdHNoaWZ0Lm5ld0RhdGFbbmFtZV1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0c2hpZnQuaW5mbGF0ZSgpO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2hlY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgaW1hZ2UgcmF0aW8gbWF0Y2hlcyB0aGUgbmF0dXJhbCBvbmVcblx0XHQgKiBieSBjb21wYXJpbmcgZGltZW5zaW9ucy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGltYWdlXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0XHQgKi9cblx0XHRjaGVja0hhc05hdHVyYWxSYXRpbyhpbWFnZSkge1xuXHRcdFx0Y29uc3QgJCA9IGltYWdlLiQ7XG5cblx0XHRcdGNvbnN0IG5hdHVyYWwgPSB0aGlzLmdldE5hdHVyYWwoaW1hZ2UpO1xuXG5cdFx0XHQvLyBUaGUgcmVhc29uIGZvciB0d28gYWx0ZXJuYXRpdmUgY29tcGFyaXNvbnMgaXMgdGhhdCB0aGUgcm91bmRpbmcgY2FuIGNvbWUgZnJvbVxuXHRcdFx0Ly8gYm90aCBkaW1lbnNpb25zLCBlLmcuIHRoZXJlIGFyZSB0d28gY2FzZXM6XG5cdFx0XHQvLyBcdDEuIGhlaWdodCBpcyBjb21wdXRlZCBhcyBhIHJvdW5kZWQgcmVsYXRpb24gb2YgdGhlIHJlYWwgaGVpZ2h0IGFuZCB0aGUgdmFsdWUgb2Ygd2lkdGgsXG5cdFx0XHQvL1x0Mi4gd2lkdGggaXMgY29tcHV0ZWQgYXMgYSByb3VuZGVkIHJlbGF0aW9uIG9mIHRoZSByZWFsIHdpZHRoIGFuZCB0aGUgdmFsdWUgb2YgaGVpZ2guXG5cdFx0XHRyZXR1cm4gKFxuXHRcdFx0XHRNYXRoLnJvdW5kKCgkLmNsaWVudFdpZHRoIC8gbmF0dXJhbC53aWR0aCkgKiBuYXR1cmFsLmhlaWdodCkgPT1cblx0XHRcdFx0XHQkLmNsaWVudEhlaWdodCB8fFxuXHRcdFx0XHRNYXRoLnJvdW5kKCgkLmNsaWVudEhlaWdodCAvIG5hdHVyYWwuaGVpZ2h0KSAqIG5hdHVyYWwud2lkdGgpID09XG5cdFx0XHRcdFx0JC5jbGllbnRXaWR0aFxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBuYXR1cmFsIGRpbWVuc2lvbnMgb2YgdGhlIGltYWdlLiBGb3IgbW9kZXJuIGJyb3dzZXJzXG5cdFx0ICogaXQgdXNlcyBuYXR1cmFsKFdpZHRofEhlaWdodCkuIEZvciBvbGQgb25lcyAoSUU4KSBpdCBjcmVhdGVzXG5cdFx0ICogYSBuZXcgaW1hZ2UgYW5kIHJlYWRzIHRoZSBkaW1lbnNpb25zLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gaW1hZ2Vcblx0XHQgKiBAcmV0dXJuIHtPYmplY3R9XG5cdFx0ICovXG5cdFx0Z2V0TmF0dXJhbChpbWFnZSkge1xuXHRcdFx0bGV0IGRpbWVuc2lvbnM7XG5cblx0XHRcdGlmIChpbWFnZS4kLm5hdHVyYWxXaWR0aCkge1xuXHRcdFx0XHRkaW1lbnNpb25zID0ge1xuXHRcdFx0XHRcdHdpZHRoOiBpbWFnZS4kLm5hdHVyYWxXaWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IGltYWdlLiQubmF0dXJhbEhlaWdodCxcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuXHRcdFx0XHRpbWcuc3JjID0gaW1hZ2UuZ2V0QXR0cmlidXRlKCdzcmMnKTtcblxuXHRcdFx0XHRkaW1lbnNpb25zID0ge1xuXHRcdFx0XHRcdHdpZHRoOiBpbWcud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0OiBpbWcuaGVpZ2h0LFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGltZW5zaW9ucztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhbiBhdHRyaWJ1dGUgZ2V0dGVyIGZ1bmN0aW9uLiBEZWZhdWx0IGdldHRlciBjb21lcyBmcm9tIHRoZSBMaW5rIHBsdWdpblxuXHRcdCAqIGFuZCBpcyBkb2N1bWVudGVkIGJ5IHtAbGluayBDS0VESVRPUi5wbHVnaW5zLmxpbmsjZ2V0TGlua0F0dHJpYnV0ZXN9LlxuXHRcdCAqXG5cdFx0ICogKipOb3RlOioqIEl0IGlzIHBvc3NpYmxlIHRvIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGFuZCB1c2UgYSBjdXN0b20gZ2V0dGVyIGUuZy5cblx0XHQgKiBpbiB0aGUgYWJzZW5jZSBvZiB0aGUgTGluayBwbHVnaW4uXG5cdFx0ICpcblx0XHQgKiAqKk5vdGU6KiogSWYgYSBjdXN0b20gZ2V0dGVyIGlzIHVzZWQsIGEgZGF0YSBtb2RlbCBmb3JtYXQgaXQgcHJvZHVjZXNcblx0XHQgKiBtdXN0IGJlIGNvbXBhdGlibGUgd2l0aCB7QGxpbmsgQ0tFRElUT1IucGx1Z2lucy5saW5rI2dldExpbmtBdHRyaWJ1dGVzfS5cblx0XHQgKlxuXHRcdCAqICoqTm90ZToqKiBBIGN1c3RvbSBnZXR0ZXIgbXVzdCB1bmRlcnN0YW5kIHRoZSBkYXRhIG1vZGVsIGZvcm1hdCBwcm9kdWNlZCBieVxuXHRcdCAqIHtAbGluayAjZ2V0TGlua0F0dHJpYnV0ZXNQYXJzZXJ9IHRvIHdvcmsgY29ycmVjdGx5LlxuXHRcdCAqXG5cdFx0ICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCBnZXRzIChjb21wb3NlcykgbGluayBhdHRyaWJ1dGVzLlxuXHRcdCAqIEBzaW5jZSA0LjUuNVxuXHRcdCAqL1xuXHRcdGdldExpbmtBdHRyaWJ1dGVzR2V0dGVyKCkge1xuXHRcdFx0Ly8gIzEzODg1XG5cdFx0XHRyZXR1cm4gQ0tFRElUT1IucGx1Z2lucy5saW5rLmdldExpbmtBdHRyaWJ1dGVzO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGFuIGF0dHJpYnV0ZSBwYXJzZXIgZnVuY3Rpb24uIERlZmF1bHQgcGFyc2VyIGNvbWVzIGZyb20gdGhlIExpbmsgcGx1Z2luXG5cdFx0ICogYW5kIGlzIGRvY3VtZW50ZWQgYnkge0BsaW5rIENLRURJVE9SLnBsdWdpbnMubGluayNwYXJzZUxpbmtBdHRyaWJ1dGVzfS5cblx0XHQgKlxuXHRcdCAqICoqTm90ZToqKiBJdCBpcyBwb3NzaWJsZSB0byBvdmVycmlkZSB0aGlzIG1ldGhvZCBhbmQgdXNlIGEgY3VzdG9tIHBhcnNlciBlLmcuXG5cdFx0ICogaW4gdGhlIGFic2VuY2Ugb2YgdGhlIExpbmsgcGx1Z2luLlxuXHRcdCAqXG5cdFx0ICogKipOb3RlOioqIElmIGEgY3VzdG9tIHBhcnNlciBpcyB1c2VkLCBhIGRhdGEgbW9kZWwgZm9ybWF0IHByb2R1Y2VkIGJ5IHRoZSBwYXJzZXJcblx0XHQgKiBtdXN0IGJlIGNvbXBhdGlibGUgd2l0aCB7QGxpbmsgI2dldExpbmtBdHRyaWJ1dGVzR2V0dGVyfS5cblx0XHQgKlxuXHRcdCAqICoqTm90ZToqKiBJZiBhIGN1c3RvbSBwYXJzZXIgaXMgdXNlZCwgaXQgc2hvdWxkIGJlIGNvbXBhdGlibGUgd2l0aCB0aGVcblx0XHQgKiB7QGxpbmsgQ0tFRElUT1IucGx1Z2lucy5saW5rI3BhcnNlTGlua0F0dHJpYnV0ZXN9IGRhdGEgbW9kZWwgZm9ybWF0LiBPdGhlcndpc2UgdGhlXG5cdFx0ICogTGluayBwbHVnaW4gZGlhbG9nIG1heSBub3QgYmUgcG9wdWxhdGVkIGNvcnJlY3RseSB3aXRoIHBhcnNlZCBkYXRhLiBIb3dldmVyXG5cdFx0ICogYXMgbG9uZyBhcyBFbmhhbmNlZCBJbWFnZSBpcyAqKm5vdCoqIHVzZWQgd2l0aCB0aGUgTGluayBwbHVnaW4gZGlhbG9nLCBhbnkgY3VzdG9tIGRhdGEgbW9kZWxcblx0XHQgKiB3aWxsIHdvcmssIGJlaW5nIHN0b3JlZCBhcyBhbiBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBFbmhhbmNlZCBJbWFnZSB3aWRnZXQncyBkYXRhIG9ubHkuXG5cdFx0ICpcblx0XHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHBhcnNlcyBhdHRyaWJ1dGVzLlxuXHRcdCAqIEBzaW5jZSA0LjUuNVxuXHRcdCAqL1xuXHRcdGdldExpbmtBdHRyaWJ1dGVzUGFyc2VyKCkge1xuXHRcdFx0Ly8gIzEzODg1XG5cdFx0XHRyZXR1cm4gQ0tFRElUT1IucGx1Z2lucy5saW5rLnBhcnNlTGlua0F0dHJpYnV0ZXM7XG5cdFx0fSxcblx0fTtcblxuXHRmdW5jdGlvbiBzZXRXcmFwcGVyQWxpZ24od2lkZ2V0LCBhbGlnbkNsYXNzZXMpIHtcblx0XHRjb25zdCB3cmFwcGVyID0gd2lkZ2V0LndyYXBwZXI7XG5cblx0XHRjb25zdCBhbGlnbiA9IHdpZGdldC5kYXRhLmFsaWduO1xuXG5cdFx0Y29uc3QgaGFzQ2FwdGlvbiA9IHdpZGdldC5kYXRhLmhhc0NhcHRpb247XG5cblx0XHRpZiAoYWxpZ25DbGFzc2VzKSB7XG5cdFx0XHQvLyBSZW1vdmUgYWxsIGFsaWduIGNsYXNzZXMgZmlyc3QuXG5cdFx0XHRmb3IgKGxldCBpID0gMzsgaS0tOyApIHdyYXBwZXIucmVtb3ZlQ2xhc3MoYWxpZ25DbGFzc2VzW2ldKTtcblxuXHRcdFx0aWYgKGFsaWduID09ICdjZW50ZXInKSB7XG5cdFx0XHRcdC8vIEF2b2lkIHRvdWNoaW5nIG5vbi1jYXB0aW9uZWQsIGNlbnRlcmVkIHdpZGdldHMgYmVjYXVzZVxuXHRcdFx0XHQvLyB0aGV5IGhhdmUgdGhlIGNsYXNzIHNldCBvbiB0aGUgZWxlbWVudCBpbnN0ZWFkIG9mIHdyYXBwZXI6XG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIFx0PGRpdiBjbGFzcz1cImNrZV93aWRnZXRfd3JhcHBlclwiPlxuXHRcdFx0XHQvLyBcdFx0PHAgY2xhc3M9XCJjZW50ZXItY2xhc3NcIj5cblx0XHRcdFx0Ly8gXHRcdFx0PGltZyAvPlxuXHRcdFx0XHQvLyBcdFx0PC9wPlxuXHRcdFx0XHQvLyBcdDwvZGl2PlxuXHRcdFx0XHRpZiAoaGFzQ2FwdGlvbikge1xuXHRcdFx0XHRcdHdyYXBwZXIuYWRkQ2xhc3MoYWxpZ25DbGFzc2VzWzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChhbGlnbiAhPSAnbm9uZScpIHtcblx0XHRcdFx0d3JhcHBlci5hZGRDbGFzcyhhbGlnbkNsYXNzZXNbYWxpZ25tZW50c09ialthbGlnbl1dKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKGFsaWduID09ICdjZW50ZXInKSB7XG5cdFx0XHRcdGlmIChoYXNDYXB0aW9uKSB3cmFwcGVyLnNldFN0eWxlKCd0ZXh0LWFsaWduJywgJ2NlbnRlcicpO1xuXHRcdFx0XHRlbHNlIHdyYXBwZXIucmVtb3ZlU3R5bGUoJ3RleHQtYWxpZ24nKTtcblxuXHRcdFx0XHR3cmFwcGVyLnJlbW92ZVN0eWxlKCdmbG9hdCcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGFsaWduID09ICdub25lJykgd3JhcHBlci5yZW1vdmVTdHlsZSgnZmxvYXQnKTtcblx0XHRcdFx0ZWxzZSB3cmFwcGVyLnNldFN0eWxlKCdmbG9hdCcsIGFsaWduKTtcblxuXHRcdFx0XHR3cmFwcGVyLnJlbW92ZVN0eWxlKCd0ZXh0LWFsaWduJyk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGltYWdlID0gd3JhcHBlci4kLnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuXG5cdFx0XHRjb25zdCBpbWFnZVN0eWxlcyA9IGltYWdlLmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuXHRcdFx0aWYgKGltYWdlU3R5bGVzKSB7XG5cdFx0XHRcdGNvbnN0IHdpZHRoU3R5bGVzID0gLyh3aWR0aDouKz87KS9nLmV4ZWMoaW1hZ2VTdHlsZXMpO1xuXHRcdFx0XHRjb25zdCB3aWR0aFN0eWxlID0gd2lkdGhTdHlsZXNbMF07XG5cblx0XHRcdFx0aW1hZ2Uuc2V0QXR0cmlidXRlKCdzdHlsZScsIHdpZHRoU3R5bGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgd2lkZ2V0cyBmcm9tIGFsbCA8aW1nPiBhbmRcblx0Ly8gPGZpZ3VyZSBjbGFzcz1cIntjb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2NhcHRpb25lZENsYXNzfVwiPiBlbGVtZW50cy5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9IGVkaXRvclxuXHQvLyBAcmV0dXJucyB7RnVuY3Rpb259XG5cdGZ1bmN0aW9uIHVwY2FzdFdpZGdldEVsZW1lbnQoZWRpdG9yKSB7XG5cdFx0Y29uc3QgaXNDZW50ZXJXcmFwcGVyID0gY2VudGVyV3JhcHBlckNoZWNrZXIoZWRpdG9yKTtcblxuXHRcdGNvbnN0IGNhcHRpb25lZENsYXNzID0gZWRpdG9yLmNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfY2FwdGlvbmVkQ2xhc3M7XG5cblx0XHQvLyBAcGFyYW0ge0NLRURJVE9SLmh0bWxQYXJzZXIuZWxlbWVudH0gZWxcblx0XHQvLyBAcGFyYW0ge09iamVjdH0gZGF0YVxuXHRcdHJldHVybiBmdW5jdGlvbihlbCwgZGF0YSkge1xuXHRcdFx0Y29uc3QgZGltZW5zaW9ucyA9IHt3aWR0aDogMSwgaGVpZ2h0OiAxfTtcblxuXHRcdFx0Y29uc3QgbmFtZSA9IGVsLm5hbWU7XG5cblx0XHRcdGxldCBpbWFnZTtcblxuXHRcdFx0Ly8gIzExMTEwIERvbid0IGluaXRpYWxpemUgb24gcGFzdGVkIGZha2Ugb2JqZWN0cy5cblx0XHRcdGlmIChlbC5hdHRyaWJ1dGVzWydkYXRhLWNrZS1yZWFsZWxlbWVudCddKSByZXR1cm47XG5cblx0XHRcdC8vIElmIGEgY2VudGVyIHdyYXBwZXIgaXMgZm91bmQsIHRoZXJlIGFyZSAzIHBvc3NpYmxlIGNhc2VzOlxuXHRcdFx0Ly9cblx0XHRcdC8vIDEuIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxmaWd1cmU+Li4uPC9maWd1cmU+PC9kaXY+LlxuXHRcdFx0Ly8gICAgSW4gdGhpcyBjYXNlIGNlbnRlcmluZyBpcyBkb25lIHdpdGggYSBjbGFzcyBzZXQgb24gd2lkZ2V0LndyYXBwZXIuXG5cdFx0XHQvLyAgICBTaW1wbHkgcmVwbGFjZSBjZW50ZXJpbmcgd3JhcHBlciB3aXRoIGZpZ3VyZSAoaXQncyBubyBsb25nZXIgbmVjZXNzYXJ5KS5cblx0XHRcdC8vXG5cdFx0XHQvLyAyLiA8cCBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZy8+PC9wPi5cblx0XHRcdC8vICAgIE5vdGhpbmcgdG8gZG8gaGVyZTogPHA+IHJlbWFpbnMgZm9yIHN0eWxpbmcgcHVycG9zZXMuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gMy4gPGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZy8+PC9kaXY+LlxuXHRcdFx0Ly8gICAgTm90aGluZyB0byBkbyBoZXJlICgyLikgYnV0IHRoYXQgY2FzZSBpcyBvbmx5IHBvc3NpYmxlIGluIGVudGVyTW9kZSBkaWZmZXJlbnRcblx0XHRcdC8vICAgIHRoYW4gRU5URVJfUC5cblx0XHRcdGlmIChpc0NlbnRlcldyYXBwZXIoZWwpKSB7XG5cdFx0XHRcdGlmIChuYW1lID09ICdkaXYnKSB7XG5cdFx0XHRcdFx0Y29uc3QgZmlndXJlID0gZWwuZ2V0Rmlyc3QoJ2ZpZ3VyZScpO1xuXG5cdFx0XHRcdFx0Ly8gQ2FzZSAjMS5cblx0XHRcdFx0XHRpZiAoZmlndXJlKSB7XG5cdFx0XHRcdFx0XHRlbC5yZXBsYWNlV2l0aChmaWd1cmUpO1xuXHRcdFx0XHRcdFx0ZWwgPSBmaWd1cmU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENhc2VzICMyIGFuZCAjMyAoaGFuZGxlZCB0cmFuc3BhcmVudGx5KVxuXG5cdFx0XHRcdC8vIElmIHRoZXJlJ3MgYSBjZW50ZXJpbmcgd3JhcHBlciwgc2F2ZSBpdCBpbiBkYXRhLlxuXHRcdFx0XHRkYXRhLmFsaWduID0gJ2NlbnRlcic7XG5cblx0XHRcdFx0Ly8gSW1hZ2UgY2FuIGJlIHdyYXBwZWQgaW4gbGluayA8YT48aW1nLz48L2E+LlxuXHRcdFx0XHRpbWFnZSA9IGVsLmdldEZpcnN0KCdpbWcnKSB8fCBlbC5nZXRGaXJzdCgnYScpLmdldEZpcnN0KCdpbWcnKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTm8gY2VudGVyIHdyYXBwZXIgaGFzIGJlZW4gZm91bmQuXG5cdFx0XHRlbHNlIGlmIChuYW1lID09ICdmaWd1cmUnICYmIGVsLmhhc0NsYXNzKGNhcHRpb25lZENsYXNzKSkge1xuXHRcdFx0XHRpbWFnZSA9IGVsLmdldEZpcnN0KCdpbWcnKSB8fCBlbC5nZXRGaXJzdCgnYScpLmdldEZpcnN0KCdpbWcnKTtcblxuXHRcdFx0XHQvLyBVcGNhc3QgbGlua2VkIGltYWdlIGxpa2UgPGE+PGltZy8+PC9hPi5cblx0XHRcdH0gZWxzZSBpZiAoaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZShlbCkpIHtcblx0XHRcdFx0aW1hZ2UgPSBlbC5uYW1lID09ICdhJyA/IGVsLmNoaWxkcmVuWzBdIDogZWw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghaW1hZ2UpIHJldHVybjtcblxuXHRcdFx0Ly8gSWYgdGhlcmUncyBhbiBpbWFnZSwgdGhlbiBjb29sLCB3ZSBnb3QgYSB3aWRnZXQuXG5cdFx0XHQvLyBOb3cganVzdCByZW1vdmUgZGltZW5zaW9uIGF0dHJpYnV0ZXMgZXhwcmVzc2VkIHdpdGggJS5cblx0XHRcdGZvciAoY29uc3QgZCBpbiBkaW1lbnNpb25zKSB7XG5cdFx0XHRcdGlmIChkaW1lbnNpb25zLmhhc093blByb3BlcnR5KGQpKSB7XG5cdFx0XHRcdFx0Y29uc3QgZGltZW5zaW9uID0gaW1hZ2UuYXR0cmlidXRlc1tkXTtcblx0XHRcdFx0XHRpZiAoZGltZW5zaW9uICYmIGRpbWVuc2lvbi5tYXRjaChyZWdleFBlcmNlbnQpKVxuXHRcdFx0XHRcdFx0ZGVsZXRlIGltYWdlLmF0dHJpYnV0ZXNbZF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsO1xuXHRcdH07XG5cdH1cblxuXHQvLyBSZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggdHJhbnNmb3JtcyB0aGUgd2lkZ2V0IHRvIHRoZSBleHRlcm5hbCBmb3JtYXRcblx0Ly8gYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGNvbmZpZ3VyYXRpb24uXG5cdC8vXG5cdC8vIEBwYXJhbSB7Q0tFRElUT1IuZWRpdG9yfVxuXHRmdW5jdGlvbiBkb3duY2FzdFdpZGdldEVsZW1lbnQoZWRpdG9yKSB7XG5cdFx0Y29uc3QgYWxpZ25DbGFzc2VzID0gZWRpdG9yLmNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfYWxpZ25DbGFzc2VzO1xuXG5cdFx0Ly8gQHBhcmFtIHtDS0VESVRPUi5odG1sUGFyc2VyLmVsZW1lbnR9IGVsXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHQvLyBJbiBjYXNlIG9mIDxhPjxpbWcvPjwvYT4sIDxpbWcvPiBpcyB0aGUgZWxlbWVudCB0byBob2xkXG5cdFx0XHQvLyBpbmxpbmUgc3R5bGVzIG9yIGNsYXNzZXMgKGFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXMpLlxuXHRcdFx0Y29uc3QgYXR0cnNIb2xkZXIgPSBlbC5uYW1lID09ICdhJyA/IGVsLmdldEZpcnN0KCkgOiBlbDtcblxuXHRcdFx0Y29uc3QgYXR0cnMgPSBhdHRyc0hvbGRlci5hdHRyaWJ1dGVzO1xuXG5cdFx0XHRjb25zdCBhbGlnbiA9IHRoaXMuZGF0YS5hbGlnbjtcblxuXHRcdFx0Ly8gRGUtd3JhcCB0aGUgaW1hZ2UgZnJvbSByZXNpemUgaGFuZGxlIHdyYXBwZXIuXG5cdFx0XHQvLyBPbmx5IGJsb2NrIHdpZGdldHMgaGF2ZSBvbmUuXG5cdFx0XHRpZiAoIXRoaXMuaW5saW5lKSB7XG5cdFx0XHRcdGNvbnN0IHJlc2l6ZVdyYXBwZXIgPSBlbC5nZXRGaXJzdCgnc3BhbicpO1xuXG5cdFx0XHRcdGlmIChyZXNpemVXcmFwcGVyKVxuXHRcdFx0XHRcdHJlc2l6ZVdyYXBwZXIucmVwbGFjZVdpdGgoXG5cdFx0XHRcdFx0XHRyZXNpemVXcmFwcGVyLmdldEZpcnN0KHtpbWc6IDEsIGE6IDF9KVxuXHRcdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChhbGlnbiAmJiBhbGlnbiAhPSAnbm9uZScpIHtcblx0XHRcdFx0Y29uc3Qgc3R5bGVzID0gQ0tFRElUT1IudG9vbHMucGFyc2VDc3NUZXh0KGF0dHJzLnN0eWxlIHx8ICcnKTtcblxuXHRcdFx0XHQvLyBXaGVuIHRoZSB3aWRnZXQgaXMgY2FwdGlvbmVkICg8ZmlndXJlPikgYW5kIGludGVybmFsbHkgY2VudGVyaW5nIGlzIGRvbmVcblx0XHRcdFx0Ly8gd2l0aCB3aWRnZXQncyB3cmFwcGVyIHN0eWxlL2NsYXNzLCBpbiB0aGUgZXh0ZXJuYWwgZGF0YSByZXByZXNlbnRhdGlvbixcblx0XHRcdFx0Ly8gPGZpZ3VyZT4gbXVzdCBiZSB3cmFwcGVkIHdpdGggYW4gZWxlbWVudCBob2xkaW5nIGFuIHN0eWxlL2NsYXNzOlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBcdDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPlxuXHRcdFx0XHQvLyBcdFx0PGZpZ3VyZSBjbGFzcz1cImltYWdlXCIgc3R5bGU9XCJkaXNwbGF5OmlubGluZS1ibG9ja1wiPi4uLjwvZmlndXJlPlxuXHRcdFx0XHQvLyBcdDwvZGl2PlxuXHRcdFx0XHQvLyBvclxuXHRcdFx0XHQvLyBcdDxkaXYgY2xhc3M9XCJzb21lLWNlbnRlci1jbGFzc1wiPlxuXHRcdFx0XHQvLyBcdFx0PGZpZ3VyZSBjbGFzcz1cImltYWdlXCI+Li4uPC9maWd1cmU+XG5cdFx0XHRcdC8vIFx0PC9kaXY+XG5cdFx0XHRcdC8vXG5cdFx0XHRcdGlmIChhbGlnbiA9PSAnY2VudGVyJyAmJiBlbC5uYW1lID09ICdmaWd1cmUnKSB7XG5cdFx0XHRcdFx0ZWwgPSBlbC53cmFwV2l0aChcblx0XHRcdFx0XHRcdG5ldyBDS0VESVRPUi5odG1sUGFyc2VyLmVsZW1lbnQoXG5cdFx0XHRcdFx0XHRcdCdkaXYnLFxuXHRcdFx0XHRcdFx0XHRhbGlnbkNsYXNzZXNcblx0XHRcdFx0XHRcdFx0XHQ/IHtjbGFzczogYWxpZ25DbGFzc2VzWzFdfVxuXHRcdFx0XHRcdFx0XHRcdDoge3N0eWxlOiAndGV4dC1hbGlnbjpjZW50ZXInfVxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiBsZWZ0L3JpZ2h0LCBhZGQgZmxvYXQgc3R5bGUgdG8gdGhlIGRvd25jYXN0ZWQgZWxlbWVudC5cblx0XHRcdFx0ZWxzZSBpZiAoYWxpZ24gaW4ge2xlZnQ6IDEsIHJpZ2h0OiAxfSkge1xuXHRcdFx0XHRcdGlmIChhbGlnbkNsYXNzZXMpXG5cdFx0XHRcdFx0XHRhdHRyc0hvbGRlci5hZGRDbGFzcyhcblx0XHRcdFx0XHRcdFx0YWxpZ25DbGFzc2VzW2FsaWdubWVudHNPYmpbYWxpZ25dXVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRlbHNlIHN0eWxlc1snZmxvYXQnXSA9IGFsaWduO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVXBkYXRlIGVsZW1lbnQgc3R5bGVzLlxuXHRcdFx0XHRpZiAoIWFsaWduQ2xhc3NlcyAmJiAhQ0tFRElUT1IudG9vbHMuaXNFbXB0eShzdHlsZXMpKVxuXHRcdFx0XHRcdGF0dHJzLnN0eWxlID0gQ0tFRElUT1IudG9vbHMud3JpdGVDc3NUZXh0KHN0eWxlcykgKyAnOyc7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbDtcblx0XHR9O1xuXHR9XG5cblx0Ly8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIGFuIGVsZW1lbnQgaXMgYSBjZW50ZXJpbmcgd3JhcHBlci5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9IGVkaXRvclxuXHQvLyBAcmV0dXJucyB7RnVuY3Rpb259XG5cdGZ1bmN0aW9uIGNlbnRlcldyYXBwZXJDaGVja2VyKGVkaXRvcikge1xuXHRcdGNvbnN0IGNhcHRpb25lZENsYXNzID0gZWRpdG9yLmNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfY2FwdGlvbmVkQ2xhc3M7XG5cblx0XHRjb25zdCBhbGlnbkNsYXNzZXMgPSBlZGl0b3IuY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXM7XG5cblx0XHRjb25zdCB2YWxpZENoaWxkcmVuID0ge2ZpZ3VyZTogMSwgYTogMSwgaW1nOiAxfTtcblxuXHRcdHJldHVybiBmdW5jdGlvbihlbCkge1xuXHRcdFx0Ly8gV3JhcHBlciBtdXN0IGJlIGVpdGhlciA8ZGl2PiBvciA8cD4uXG5cdFx0XHRpZiAoIShlbC5uYW1lIGluIHtkaXY6IDEsIHA6IDF9KSkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRjb25zdCBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuXG5cdFx0XHQvLyBDZW50ZXJpbmcgd3JhcHBlciBjYW4gaGF2ZSBvbmx5IG9uZSBjaGlsZC5cblx0XHRcdGlmIChjaGlsZHJlbi5sZW5ndGggIT09IDEpIHJldHVybiBmYWxzZTtcblxuXHRcdFx0Y29uc3QgY2hpbGQgPSBjaGlsZHJlblswXTtcblxuXHRcdFx0Ly8gT25seSA8ZmlndXJlPiBvciA8aW1nIC8+IGNhbiBiZSBmaXJzdCAob25seSkgY2hpbGQgb2YgY2VudGVyaW5nIHdyYXBwZXIsXG5cdFx0XHQvLyByZWdhcmRsZXNzIG9mIGl0cyB0eXBlLlxuXHRcdFx0aWYgKCEoY2hpbGQubmFtZSBpbiB2YWxpZENoaWxkcmVuKSkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHQvLyBJZiBjZW50ZXJpbmcgd3JhcHBlciBpcyA8cD4sIG9ubHkgPGltZyAvPiBjYW4gYmUgdGhlIGNoaWxkLlxuXHRcdFx0Ly8gICA8cCBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGltZyAvPjwvcD5cblx0XHRcdGlmIChlbC5uYW1lID09ICdwJykge1xuXHRcdFx0XHRpZiAoIWlzTGlua2VkT3JTdGFuZGFsb25lSW1hZ2UoY2hpbGQpKSByZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBDZW50ZXJpbmcgPGRpdj4gY2FuIGhvbGQgPGltZy8+IG9yIDxmaWd1cmU+LCBkZXBlbmRpbmcgb24gZW50ZXJNb2RlLlxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdC8vIElmIGEgPGZpZ3VyZT4gaXMgdGhlIGZpcnN0IChvbmx5KSBjaGlsZCwgaXQgbXVzdCBoYXZlIGEgY2xhc3MuXG5cdFx0XHRcdC8vICAgPGRpdiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyXCI+PGZpZ3VyZT4uLi48L2ZpZ3VyZT48ZGl2PlxuXHRcdFx0XHRpZiAoY2hpbGQubmFtZSA9PSAnZmlndXJlJykge1xuXHRcdFx0XHRcdGlmICghY2hpbGQuaGFzQ2xhc3MoY2FwdGlvbmVkQ2xhc3MpKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQ2VudGVyaW5nIDxkaXY+IGNhbiBob2xkIDxpbWcvPiBvciA8YT48aW1nLz48L2E+IG9ubHkgd2hlbiBlbnRlck1vZGVcblx0XHRcdFx0XHQvLyBpcyBFTlRFUl8oQlJ8RElWKS5cblx0XHRcdFx0XHQvLyAgIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxpbWcgLz48L2Rpdj5cblx0XHRcdFx0XHQvLyAgIDxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlclwiPjxhPjxpbWcgLz48L2E+PC9kaXY+XG5cdFx0XHRcdFx0aWYgKGVkaXRvci5lbnRlck1vZGUgPT0gQ0tFRElUT1IuRU5URVJfUCkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHRcdFx0Ly8gUmVnYXJkbGVzcyBvZiBlbnRlck1vZGUsIGEgY2hpbGQgd2hpY2ggaXMgbm90IDxmaWd1cmU+IG11c3QgYmVcblx0XHRcdFx0XHQvLyBlaXRoZXIgPGltZy8+IG9yIDxhPjxpbWcvPjwvYT4uXG5cdFx0XHRcdFx0aWYgKCFpc0xpbmtlZE9yU3RhbmRhbG9uZUltYWdlKGNoaWxkKSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENlbnRlcmluZyB3cmFwcGVyIGdvdCB0byBiZS4uLiBjZW50ZXJpbmcuIElmIGFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXMgYXJlIGRlZmluZWQsXG5cdFx0XHQvLyBjaGVjayBmb3IgY2VudGVyaW5nIGNsYXNzLiBPdGhlcndpc2UsIGNoZWNrIHRoZSBzdHlsZS5cblx0XHRcdGlmIChcblx0XHRcdFx0YWxpZ25DbGFzc2VzXG5cdFx0XHRcdFx0PyBlbC5oYXNDbGFzcyhhbGlnbkNsYXNzZXNbMV0pXG5cdFx0XHRcdFx0OiBDS0VESVRPUi50b29scy5wYXJzZUNzc1RleHQoXG5cdFx0XHRcdFx0XHRcdGVsLmF0dHJpYnV0ZXMuc3R5bGUgfHwgJycsXG5cdFx0XHRcdFx0XHRcdHRydWVcblx0XHRcdFx0XHQgIClbJ3RleHQtYWxpZ24nXSA9PSAnY2VudGVyJ1xuXHRcdFx0KVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cdH1cblxuXHQvLyBDaGVja3Mgd2hldGhlciBlbGVtZW50IGlzIDxpbWcvPiBvciA8YT48aW1nLz48L2E+LlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmh0bWxQYXJzZXIuZWxlbWVudH1cblx0ZnVuY3Rpb24gaXNMaW5rZWRPclN0YW5kYWxvbmVJbWFnZShlbCkge1xuXHRcdGlmIChlbC5uYW1lID09ICdpbWcnKSByZXR1cm4gdHJ1ZTtcblx0XHRlbHNlIGlmIChlbC5uYW1lID09ICdhJylcblx0XHRcdHJldHVybiBlbC5jaGlsZHJlbi5sZW5ndGggPT0gMSAmJiBlbC5nZXRGaXJzdCgnaW1nJyk7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBTZXRzIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHdpZGdldCBpbWFnZSBhY2NvcmRpbmcgdG8gY3VycmVudCB3aWRnZXQgZGF0YS5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5wbHVnaW5zLndpZGdldH0gd2lkZ2V0XG5cdGZ1bmN0aW9uIHNldERpbWVuc2lvbnMod2lkZ2V0KSB7XG5cdFx0Y29uc3QgZGF0YSA9IHdpZGdldC5kYXRhO1xuXG5cdFx0Y29uc3QgZGltZW5zaW9ucyA9IHt3aWR0aDogZGF0YS53aWR0aCwgaGVpZ2h0OiBkYXRhLmhlaWdodH07XG5cblx0XHRjb25zdCBpbWFnZSA9IHdpZGdldC5wYXJ0cy5pbWFnZTtcblxuXHRcdGZvciAoY29uc3QgZCBpbiBkaW1lbnNpb25zKSB7XG5cdFx0XHRpZiAoZGltZW5zaW9uc1tkXSkgaW1hZ2Uuc2V0QXR0cmlidXRlKGQsIGRpbWVuc2lvbnNbZF0pO1xuXHRcdFx0ZWxzZSBpbWFnZS5yZW1vdmVBdHRyaWJ1dGUoZCk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gRGVmaW5lcyBhbGwgZmVhdHVyZXMgcmVsYXRlZCB0byBkcmFnLWRyaXZlbiBpbWFnZSByZXNpemluZy5cblx0Ly9cblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5wbHVnaW5zLndpZGdldH0gd2lkZ2V0XG5cdGZ1bmN0aW9uIHNldHVwUmVzaXplcih3aWRnZXQpIHtcblx0XHRjb25zdCBlZGl0b3IgPSB3aWRnZXQuZWRpdG9yO1xuXG5cdFx0Y29uc3QgZWRpdGFibGUgPSBlZGl0b3IuZWRpdGFibGUoKTtcblxuXHRcdGNvbnN0IGRvYyA9IGVkaXRvci5kb2N1bWVudDtcblxuXHRcdC8vIFN0b3JlIHRoZSByZXNpemVyIGluIGEgd2lkZ2V0IGZvciB0ZXN0aW5nICgjMTEwMDQpLlxuXG5cdFx0Y29uc3QgcmVzaXplciA9ICh3aWRnZXQucmVzaXplciA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJykpO1xuXG5cdFx0Ly8gQ3JlYXRlIHJlc2l6ZXIgZm9yIGVhY2ggY29ybmVyIChORSwgTlcsIFNFLCBTVylcblxuXHRcdGNvbnN0IHJlc2l6ZXJORSA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cblx0XHRjb25zdCByZXNpemVyTlcgPSBkb2MuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXG5cdFx0Y29uc3QgcmVzaXplclNFID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblxuXHRcdGNvbnN0IHJlc2l6ZXJTVyA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cblx0XHRyZXNpemVyTkUuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyJyk7XG5cdFx0cmVzaXplck5FLmFkZENsYXNzKCdja2VfaW1hZ2VfcmVzaXplcl9uZScpO1xuXG5cdFx0cmVzaXplck5XLmFkZENsYXNzKCdja2VfaW1hZ2VfcmVzaXplcicpO1xuXHRcdHJlc2l6ZXJOVy5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXJfbncnKTtcblxuXHRcdHJlc2l6ZXJTRS5hZGRDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXInKTtcblx0XHRyZXNpemVyU0UuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyX3NlJyk7XG5cblx0XHRyZXNpemVyU1cuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyJyk7XG5cdFx0cmVzaXplclNXLmFkZENsYXNzKCdja2VfaW1hZ2VfcmVzaXplcl9zdycpO1xuXG5cdFx0Ly8gQWRkIGVhY2ggZGlyZWN0aW9uYWwgcmVzaXplciBhcyBhIGNoaWxkIG9mIHJlc2l6ZXJcblx0XHRyZXNpemVyLmFwcGVuZChyZXNpemVyTkUpO1xuXHRcdHJlc2l6ZXIuYXBwZW5kKHJlc2l6ZXJOVyk7XG5cdFx0cmVzaXplci5hcHBlbmQocmVzaXplclNFKTtcblx0XHRyZXNpemVyLmFwcGVuZChyZXNpemVyU1cpO1xuXG5cdFx0Ly8gcmVzaXplci5zZXRBdHRyaWJ1dGUoICd0aXRsZScsIGVkaXRvci5sYW5nLmFlX2RyYWdyZXNpemVfaWUxMS5yZXNpemVyICk7XG5cdFx0cmVzaXplci5hcHBlbmQobmV3IENLRURJVE9SLmRvbS50ZXh0KCdcXHUyMDBiJywgZG9jKSk7XG5cblx0XHQvLyBJbmxpbmUgd2lkZ2V0cyBkb24ndCBuZWVkIGEgcmVzaXplciB3cmFwcGVyIGFzIGFuIGltYWdlIHNwYW5zIHRoZSBlbnRpcmUgd2lkZ2V0LlxuXHRcdGlmICghd2lkZ2V0LmlubGluZSkge1xuXHRcdFx0Y29uc3QgaW1hZ2VPckxpbmsgPSB3aWRnZXQucGFydHMubGluayB8fCB3aWRnZXQucGFydHMuaW1hZ2U7XG5cblx0XHRcdGNvbnN0IG9sZFJlc2l6ZVdyYXBwZXIgPSBpbWFnZU9yTGluay5nZXRQYXJlbnQoKTtcblxuXHRcdFx0Y29uc3QgcmVzaXplV3JhcHBlciA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG5cblx0XHRcdHJlc2l6ZVdyYXBwZXIuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyX3dyYXBwZXInKTtcblx0XHRcdHJlc2l6ZVdyYXBwZXIuYXBwZW5kKGltYWdlT3JMaW5rKTtcblx0XHRcdHJlc2l6ZVdyYXBwZXIuYXBwZW5kKHJlc2l6ZXIpO1xuXHRcdFx0d2lkZ2V0LmVsZW1lbnQuYXBwZW5kKHJlc2l6ZVdyYXBwZXIsIHRydWUpO1xuXG5cdFx0XHQvLyBSZW1vdmUgdGhlIG9sZCB3cmFwcGVyIHdoaWNoIGNvdWxkIGNhbWUgZnJvbSBlLmcuIHBhc3RlZCBIVE1MXG5cdFx0XHQvLyBhbmQgd2hpY2ggY291bGQgYmUgY29ycnVwdGVkIChlLmcuIHJlc2l6ZXIgc3BhbiBoYXMgYmVlbiBsb3N0KS5cblx0XHRcdGlmIChvbGRSZXNpemVXcmFwcGVyLmlzKCdzcGFuJykpIG9sZFJlc2l6ZVdyYXBwZXIucmVtb3ZlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpZGdldC53cmFwcGVyLmFwcGVuZChyZXNpemVyKTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgdmFsdWVzIG9mIHNpemUgdmFyaWFibGVzIGFuZCBtb3VzZSBvZmZzZXRzLlxuXHRcdHJlc2l6ZXIub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uKGV2dCkge1xuXHRcdFx0Y29uc3QgaW1hZ2UgPSB3aWRnZXQucGFydHMuaW1hZ2U7XG5cblx0XHRcdC8vIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG1vdXNlIHJlbGF0aXZlIHRvIHRoZSBzY3JlZW5cblx0XHRcdC8vIHdoZW4gYnV0dG9uIGdldHMgcHJlc3NlZC5cblxuXHRcdFx0Y29uc3Qgc3RhcnRYID0gZXZ0LmRhdGEuJC5zY3JlZW5YO1xuXG5cdFx0XHRjb25zdCBzdGFydFkgPSBldnQuZGF0YS4kLnNjcmVlblk7XG5cblx0XHRcdC8vIFRoZSBpbml0aWFsIGRpbWVuc2lvbnMgYW5kIGFzcGVjdCByYXRpbyBvZiB0aGUgaW1hZ2UuXG5cblx0XHRcdGNvbnN0IHN0YXJ0V2lkdGggPSBpbWFnZS4kLmNsaWVudFdpZHRoO1xuXG5cdFx0XHRjb25zdCBzdGFydEhlaWdodCA9IGltYWdlLiQuY2xpZW50SGVpZ2h0O1xuXG5cdFx0XHRjb25zdCByYXRpbyA9IHN0YXJ0V2lkdGggLyBzdGFydEhlaWdodDtcblxuXHRcdFx0Y29uc3QgbGlzdGVuZXJzID0gW107XG5cblx0XHRcdGNvbnN0IHRhcmdldCA9IGV2dC5kYXRhLmdldFRhcmdldCgpO1xuXG5cdFx0XHRsZXQgZmFjdG9yWDtcblxuXHRcdFx0bGV0IGZhY3Rvclk7XG5cblx0XHRcdGxldCBtb3ZlRGlmZlg7XG5cblx0XHRcdGxldCBtb3ZlRGlmZlk7XG5cblx0XHRcdGxldCBuYXRpdmVFdnQ7XG5cblx0XHRcdGxldCBuZXdIZWlnaHQ7XG5cblx0XHRcdGxldCBuZXdXaWR0aDtcblxuXHRcdFx0bGV0IHVwZGF0ZURhdGE7XG5cblx0XHRcdC8vIFwiZmFjdG9yWFwiIGFuZCBcImZhY3RvcllcIiBjYW4gYmUgZWl0aGVyIDEgb3IgLTEuIEkuZS46IFdlIG5lZWQgdG9cblx0XHRcdC8vIGFkZC9zdWJ0cmFjdCB0aGUgZGlmZmVyZW5jZSB0byBnZXQgcHJvcGVyIHdpZHRoLCBldGMuIFdpdGhvdXQgXCJmYWN0b3JYXCJcblx0XHRcdC8vIGFuZCBcImZhY3RvcllcIiwgcmVzaXplciBzdGFydHMgd29ya2luZyB0aGUgb3Bwb3NpdGUgd2F5LlxuXHRcdFx0aWYgKHRhcmdldC5oYXNDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXJfbmUnKSkge1xuXHRcdFx0XHRmYWN0b3JYID0gMTtcblx0XHRcdFx0ZmFjdG9yWSA9IDE7XG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldC5oYXNDbGFzcygnY2tlX2ltYWdlX3Jlc2l6ZXJfbncnKSkge1xuXHRcdFx0XHRmYWN0b3JYID0gLTE7XG5cdFx0XHRcdGZhY3RvclkgPSAxO1xuXHRcdFx0fSBlbHNlIGlmICh0YXJnZXQuaGFzQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemVyX3NlJykpIHtcblx0XHRcdFx0ZmFjdG9yWCA9IDE7XG5cdFx0XHRcdGZhY3RvclkgPSAtMTtcblx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0Lmhhc0NsYXNzKCdja2VfaW1hZ2VfcmVzaXplcl9zdycpKSB7XG5cdFx0XHRcdGZhY3RvclggPSAtMTtcblx0XHRcdFx0ZmFjdG9yWSA9IC0xO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBIGNsYXNzIGFwcGxpZWQgdG8gZWRpdGFibGUgZHVyaW5nIHJlc2l6aW5nLlxuXHRcdFx0Y29uc3QgY3Vyc29yQ2xhc3MgPVxuXHRcdFx0XHQnY2tlX2ltYWdlXycgK1xuXHRcdFx0XHQoIX5mYWN0b3JZID8gJ3MnIDogJ24nKSArXG5cdFx0XHRcdCghfmZhY3RvclggPyAndycgOiAnZScpO1xuXG5cdFx0XHQvLyBTYXZlIHRoZSB1bmRvIHNuYXBzaG90IGZpcnN0OiBiZWZvcmUgcmVzaXppbmcuXG5cdFx0XHRlZGl0b3IuZmlyZSgnc2F2ZVNuYXBzaG90Jyk7XG5cblx0XHRcdC8vIE1vdXNlbW92ZSBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQgb24gbW91c2V1cC5cblx0XHRcdGF0dGFjaFRvRG9jdW1lbnRzKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSwgbGlzdGVuZXJzKTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgdGhlIG1vdXNlbW92ZSBsaXN0ZW5lci4gVXBkYXRlIHdpZGdldCBkYXRhIGlmIHZhbGlkLlxuXHRcdFx0YXR0YWNoVG9Eb2N1bWVudHMoJ21vdXNldXAnLCBvbk1vdXNlVXAsIGxpc3RlbmVycyk7XG5cblx0XHRcdC8vIFRoZSBlbnRpcmUgZWRpdGFibGUgd2lsbCBoYXZlIHRoZSBzcGVjaWFsIGN1cnNvciB3aGlsZSByZXNpemluZyBnb2VzIG9uLlxuXHRcdFx0ZWRpdGFibGUuYWRkQ2xhc3MoY3Vyc29yQ2xhc3MpO1xuXG5cdFx0XHQvLyBUaGlzIGlzIHRvIGFsd2F5cyBrZWVwIHRoZSByZXNpemVyIGVsZW1lbnQgdmlzaWJsZSB3aGlsZSByZXNpemluZy5cblx0XHRcdHJlc2l6ZXIuYWRkQ2xhc3MoJ2NrZV9pbWFnZV9yZXNpemluZycpO1xuXG5cdFx0XHQvLyBBdHRhY2hlcyBhbiBldmVudCB0byBhIGdsb2JhbCBkb2N1bWVudCBpZiBpbmxpbmUgZWRpdG9yLlxuXHRcdFx0Ly8gQWRkaXRpb25hbGx5LCBpZiBjbGFzc2ljIChgaWZyYW1lYC1iYXNlZCkgZWRpdG9yLCBhbHNvIGF0dGFjaGVzIHRoZSBzYW1lIGV2ZW50IHRvIGBpZnJhbWVgJ3MgZG9jdW1lbnQuXG5cdFx0XHRmdW5jdGlvbiBhdHRhY2hUb0RvY3VtZW50cyhuYW1lLCBjYWxsYmFjaywgY29sbGVjdGlvbikge1xuXHRcdFx0XHRjb25zdCBnbG9iYWxEb2MgPSBDS0VESVRPUi5kb2N1bWVudDtcblxuXHRcdFx0XHRjb25zdCBsaXN0ZW5lcnMgPSBbXTtcblxuXHRcdFx0XHRpZiAoIWRvYy5lcXVhbHMoZ2xvYmFsRG9jKSlcblx0XHRcdFx0XHRsaXN0ZW5lcnMucHVzaChnbG9iYWxEb2Mub24obmFtZSwgY2FsbGJhY2spKTtcblxuXHRcdFx0XHRsaXN0ZW5lcnMucHVzaChkb2Mub24obmFtZSwgY2FsbGJhY2spKTtcblxuXHRcdFx0XHRpZiAoY29sbGVjdGlvbikge1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpLS07IClcblx0XHRcdFx0XHRcdGNvbGxlY3Rpb24ucHVzaChsaXN0ZW5lcnMucG9wKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGN1bGF0ZSB3aWR0aCBmaXJzdCwgYW5kIHRoZW4gYWRqdXN0IGhlaWdodCwgcHJlc2VydmluZyByYXRpby5cblx0XHRcdGZ1bmN0aW9uIGFkanVzdFRvWCgpIHtcblx0XHRcdFx0bmV3V2lkdGggPSBzdGFydFdpZHRoICsgZmFjdG9yWCAqIG1vdmVEaWZmWDtcblx0XHRcdFx0bmV3SGVpZ2h0ID0gTWF0aC5yb3VuZChuZXdXaWR0aCAvIHJhdGlvKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGhlaWdodCBmaXJzdCwgYW5kIHRoZW4gYWRqdXN0IHdpZHRoLCBwcmVzZXJ2aW5nIHJhdGlvLlxuXHRcdFx0ZnVuY3Rpb24gYWRqdXN0VG9ZKCkge1xuXHRcdFx0XHRuZXdIZWlnaHQgPSBzdGFydEhlaWdodCArIGZhY3RvclkgKiBtb3ZlRGlmZlk7XG5cdFx0XHRcdG5ld1dpZHRoID0gTWF0aC5yb3VuZChuZXdIZWlnaHQgKiByYXRpbyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoaXMgaXMgaG93IHZhcmlhYmxlcyByZWZlciB0byB0aGUgZ2VvbWV0cnkuXG5cdFx0XHQvLyBOb3RlOiB4IGNvcnJlc3BvbmRzIHRvIG1vdmVPZmZzZXQsIHRoaXMgaXMgdGhlIHBvc2l0aW9uIG9mIG1vdXNlXG5cdFx0XHQvLyBOb3RlOiBvIGNvcnJlc3BvbmRzIHRvIFtzdGFydFgsIHN0YXJ0WV0uXG5cdFx0XHQvL1xuXHRcdFx0Ly8gXHQrLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rXG5cdFx0XHQvLyBcdHwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcblx0XHRcdC8vIFx0fCAgICAgIEkgICAgICAgfCAgICAgIElJICAgICAgfFxuXHRcdFx0Ly8gXHR8ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG5cdFx0XHQvLyBcdCstLS0tLS0tLS0tLS0tIG8gLS0tLS0tLS0tLS0tLSsgXyBfIF9cblx0XHRcdC8vIFx0fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgIF5cblx0XHRcdC8vIFx0fCAgICAgIFZJICAgICAgfCAgICAgSUlJICAgICAgfCAgICAgIHwgbW92ZURpZmZZXG5cdFx0XHQvLyBcdHwgICAgICAgICAgICAgIHwgICAgICAgICB4IF8gXyBfIF8gXyB2XG5cdFx0XHQvLyBcdCstLS0tLS0tLS0tLS0tLSstLS0tLS0tLS18LS0tLStcblx0XHRcdC8vIFx0ICAgICAgICAgICAgICAgfCAgICAgICAgIHxcblx0XHRcdC8vIFx0ICAgICAgICAgICAgICAgIDwtLS0tLS0tPlxuXHRcdFx0Ly8gXHQgICAgICAgICAgICAgICAgbW92ZURpZmZYXG5cdFx0XHRmdW5jdGlvbiBvbk1vdXNlTW92ZShldnQpIHtcblx0XHRcdFx0bmF0aXZlRXZ0ID0gZXZ0LmRhdGEuJDtcblxuXHRcdFx0XHQvLyBUaGlzIGlzIGhvdyBmYXIgdGhlIG1vdXNlIGlzIGZyb20gdGhlIHBvaW50IHRoZSBidXR0b24gd2FzIHByZXNzZWQuXG5cdFx0XHRcdG1vdmVEaWZmWCA9IG5hdGl2ZUV2dC5zY3JlZW5YIC0gc3RhcnRYO1xuXHRcdFx0XHRtb3ZlRGlmZlkgPSBzdGFydFkgLSBuYXRpdmVFdnQuc2NyZWVuWTtcblxuXHRcdFx0XHQvLyBSZXNpemUgd2l0aCBORSwgU0UgZHJhZyBoYW5kbGVzXG5cdFx0XHRcdGlmIChmYWN0b3JYID09IDEpIHtcblx0XHRcdFx0XHRpZiAobW92ZURpZmZYIDw9IDApIHtcblx0XHRcdFx0XHRcdGFkanVzdFRvWSgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRhZGp1c3RUb1goKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gUmVzaXplIHdpdGggTlcsIFNXIGRyYWcgaGFuZGxlc1xuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAobW92ZURpZmZYIDw9IDApIHtcblx0XHRcdFx0XHRcdGFkanVzdFRvWCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRhZGp1c3RUb1koKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEb24ndCB1cGRhdGUgYXR0cmlidXRlcyBpZiBsZXNzIHRoYW4gMTAuXG5cdFx0XHRcdC8vIFRoaXMgaXMgdG8gcHJldmVudCBpbWFnZXMgdG8gdmlzdWFsbHkgZGlzYXBwZWFyLlxuXHRcdFx0XHRpZiAobmV3V2lkdGggPj0gMTUgJiYgbmV3SGVpZ2h0ID49IDE1KSB7XG5cdFx0XHRcdFx0aW1hZ2UuJC5zdHlsZS53aWR0aCA9IG5ld1dpZHRoICsgJ3B4Jztcblx0XHRcdFx0XHRpbWFnZS4kLnN0eWxlLmhlaWdodCA9IG5ld0hlaWdodCArICdweCc7XG5cblx0XHRcdFx0XHR1cGRhdGVEYXRhID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR1cGRhdGVEYXRhID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gb25Nb3VzZVVwKCkge1xuXHRcdFx0XHRsZXQgbDtcblxuXHRcdFx0XHR3aGlsZSAoKGwgPSBsaXN0ZW5lcnMucG9wKCkpKSBsLnJlbW92ZUxpc3RlbmVyKCk7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSBkZWZhdWx0IGN1cnNvciBieSByZW1vdmluZyBzcGVjaWFsIGNsYXNzLlxuXHRcdFx0XHRlZGl0YWJsZS5yZW1vdmVDbGFzcyhjdXJzb3JDbGFzcyk7XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyB0byBicmluZyBiYWNrIHRoZSByZWd1bGFyIGJlaGF2aW91ciBvZiB0aGUgcmVzaXplci5cblx0XHRcdFx0cmVzaXplci5yZW1vdmVDbGFzcygnY2tlX2ltYWdlX3Jlc2l6aW5nJyk7XG5cblx0XHRcdFx0aWYgKHVwZGF0ZURhdGEpIHtcblx0XHRcdFx0XHR3aWRnZXQuc2V0RGF0YSh7XG5cdFx0XHRcdFx0XHRoZWlnaHQ6IG5ld0hlaWdodCxcblx0XHRcdFx0XHRcdHdpZHRoOiBuZXdXaWR0aCxcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdC8vIFNhdmUgYW5vdGhlciB1bmRvIHNuYXBzaG90OiBhZnRlciByZXNpemluZy5cblx0XHRcdFx0XHRlZGl0b3IuZmlyZSgnc2F2ZVNuYXBzaG90Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEb24ndCB1cGRhdGUgZGF0YSB0d2ljZSBvciBtb3JlLlxuXHRcdFx0XHR1cGRhdGVEYXRhID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgYWxpZ25tZW50IHZhbHVlIG9mIGFuIGltYWdlXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGltYWdlIFRoZSBpbWFnZSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbWFnZUFsaWdubWVudCBUaGUgaW1hZ2UgYWxpZ25tZW50IHZhbHVlIHRvIGJlIHJlbW92ZWRcblx0ICovXG5cdGNvbnN0IHJlbW92ZVdpZGdldEFsaWdubWVudCA9IGZ1bmN0aW9uKHdpZGdldCwgaW1hZ2VBbGlnbm1lbnQpIHtcblx0XHRpZiAoaW1hZ2VBbGlnbm1lbnQgPT09ICdsZWZ0JyB8fCBpbWFnZUFsaWdubWVudCA9PT0gJ3JpZ2h0Jykge1xuXHRcdFx0d2lkZ2V0LndyYXBwZXIucmVtb3ZlU3R5bGUoJ2Zsb2F0Jyk7XG5cdFx0fSBlbHNlIGlmIChpbWFnZUFsaWdubWVudCA9PT0gJ2NlbnRlcicpIHtcblx0XHRcdHdpZGdldC5lZGl0b3IuZXhlY0NvbW1hbmQoJ2p1c3RpZnlsZWZ0Jyk7XG5cdFx0XHR3aWRnZXQuZWRpdG9yLmV4ZWNDb21tYW5kKCdqdXN0aWZ5bGVmdCcpO1xuXHRcdH1cblx0fTtcblxuXHQvLyBJbnRlZ3JhdGVzIHdpZGdldCBhbGlnbm1lbnQgc2V0dGluZyB3aXRoIGp1c3RpZnlcblx0Ly8gcGx1Z2luJ3MgY29tbWFuZHMgKGV4ZWN1dGlvbiBhbmQgcmVmcmVzaG1lbnQpLlxuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn0gZWRpdG9yXG5cdC8vIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAnbGVmdCcsICdyaWdodCcsICdjZW50ZXInIG9yICdibG9jaydcblx0ZnVuY3Rpb24gYWxpZ25Db21tYW5kSW50ZWdyYXRvcihlZGl0b3IpIHtcblx0XHRjb25zdCBleGVjQ2FsbGJhY2tzID0gW107XG5cblx0XHRsZXQgZW5hYmxlZDtcblxuXHRcdHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0Y29uc3QgY29tbWFuZCA9IGVkaXRvci5nZXRDb21tYW5kKCdqdXN0aWZ5JyArIHZhbHVlKTtcblxuXHRcdFx0Ly8gTW9zdCBsaWtlbHksIHRoZSBqdXN0aWZ5IHBsdWdpbiBpc24ndCBsb2FkZWQuXG5cdFx0XHRpZiAoIWNvbW1hbmQpIHJldHVybjtcblxuXHRcdFx0Ly8gVGhpcyBjb21tYW5kIHdpbGwgYmUgbWFudWFsbHkgcmVmcmVzaGVkIGFsb25nIHdpdGhcblx0XHRcdC8vIG90aGVyIGNvbW1hbmRzIGFmdGVyIGV4ZWMuXG5cdFx0XHRleGVjQ2FsbGJhY2tzLnB1c2goZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNvbW1hbmQucmVmcmVzaChlZGl0b3IsIGVkaXRvci5lbGVtZW50UGF0aCgpKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAodmFsdWUgaW4ge3JpZ2h0OiAxLCBsZWZ0OiAxLCBjZW50ZXI6IDF9KSB7XG5cdFx0XHRcdGNvbW1hbmQub24oJ2V4ZWMnLCBmdW5jdGlvbihldnQpIHtcblx0XHRcdFx0XHRjb25zdCB3aWRnZXQgPSBnZXRGb2N1c2VkV2lkZ2V0KGVkaXRvcik7XG5cblx0XHRcdFx0XHRpZiAod2lkZ2V0KSB7XG5cdFx0XHRcdFx0XHRpZiAod2lkZ2V0LmRhdGEuYWxpZ24gPT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZVdpZGdldEFsaWdubWVudCh3aWRnZXQsIHZhbHVlKTtcblxuXHRcdFx0XHRcdFx0XHRkZWxldGUgd2lkZ2V0LmRhdGEuYWxpZ247XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR3aWRnZXQuc2V0RGF0YSgnYWxpZ24nLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIE9uY2UgdGhlIHdpZGdldCBjaGFuZ2VkIGl0cyBhbGlnbiwgYWxsIHRoZSBhbGlnbiBjb21tYW5kc1xuXHRcdFx0XHRcdFx0Ly8gbXVzdCBiZSByZWZyZXNoZWQ6IHRoZSBldmVudCBpcyB0byBiZSBjYW5jZWxsZWQuXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gZXhlY0NhbGxiYWNrcy5sZW5ndGg7IGktLTsgKVxuXHRcdFx0XHRcdFx0XHRleGVjQ2FsbGJhY2tzW2ldKCk7XG5cblx0XHRcdFx0XHRcdGV2dC5jYW5jZWwoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21tYW5kLm9uKCdyZWZyZXNoJywgZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHRcdGNvbnN0IHdpZGdldCA9IGdldEZvY3VzZWRXaWRnZXQoZWRpdG9yKTtcblxuXHRcdFx0XHRjb25zdCBhbGxvd2VkID0ge3JpZ2h0OiAxLCBsZWZ0OiAxLCBjZW50ZXI6IDF9O1xuXG5cdFx0XHRcdGlmICghd2lkZ2V0KSByZXR1cm47XG5cblx0XHRcdFx0Ly8gQ2FjaGUgXCJlbmFibGVkXCIgb24gZmlyc3QgdXNlLiBUaGlzIGlzIGJlY2F1c2UgZmlsdGVyI2NoZWNrRmVhdHVyZSBtYXlcblx0XHRcdFx0Ly8gbm90IGJlIGF2YWlsYWJsZSBkdXJpbmcgcGx1Z2luJ3MgYWZ0ZXJJbml0IGluIHRoZSBmdXR1cmUg4oCUIGEgbW9tZW50IHdoZW5cblx0XHRcdFx0Ly8gYWxpZ25Db21tYW5kSW50ZWdyYXRvciBpcyBjYWxsZWQuXG5cdFx0XHRcdGlmIChlbmFibGVkID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0ZW5hYmxlZCA9IGVkaXRvci5maWx0ZXIuY2hlY2tGZWF0dXJlKFxuXHRcdFx0XHRcdFx0ZWRpdG9yLndpZGdldHMucmVnaXN0ZXJlZC5pbWFnZS5mZWF0dXJlcy5hbGlnblxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYWxsb3cganVzdGlmeSBjb21tYW5kcyB3aGVuIHdpZGdldCBhbGlnbm1lbnQgaXMgZGlzYWJsZWQgKCMxMTAwNCkuXG5cdFx0XHRcdGlmICghZW5hYmxlZCkgdGhpcy5zZXRTdGF0ZShDS0VESVRPUi5UUklTVEFURV9ESVNBQkxFRCk7XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuc2V0U3RhdGUoXG5cdFx0XHRcdFx0XHR3aWRnZXQuZGF0YS5hbGlnbiA9PSB2YWx1ZVxuXHRcdFx0XHRcdFx0XHQ/IENLRURJVE9SLlRSSVNUQVRFX09OXG5cdFx0XHRcdFx0XHRcdDogdmFsdWUgaW4gYWxsb3dlZFxuXHRcdFx0XHRcdFx0XHQ/IENLRURJVE9SLlRSSVNUQVRFX09GRlxuXHRcdFx0XHRcdFx0XHQ6IENLRURJVE9SLlRSSVNUQVRFX0RJU0FCTEVEXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGV2dC5jYW5jZWwoKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdH1cblxuXHQvLyBSZXR1cm5zIHRoZSBmb2N1c2VkIHdpZGdldCwgaWYgb2YgdGhlIHR5cGUgc3BlY2lmaWMgZm9yIHRoaXMgcGx1Z2luLlxuXHQvLyBJZiBubyB3aWRnZXQgaXMgZm9jdXNlZCwgYG51bGxgIGlzIHJldHVybmVkLlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn1cblx0Ly8gQHJldHVybnMge0NLRURJVE9SLnBsdWdpbnMud2lkZ2V0fVxuXHRmdW5jdGlvbiBnZXRGb2N1c2VkV2lkZ2V0KGVkaXRvcikge1xuXHRcdGNvbnN0IHdpZGdldCA9IGVkaXRvci53aWRnZXRzLmZvY3VzZWQ7XG5cblx0XHRpZiAod2lkZ2V0ICYmIHdpZGdldC5uYW1lID09ICdpbWFnZScpIHJldHVybiB3aWRnZXQ7XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFJldHVybnMgYSBzZXQgb2Ygd2lkZ2V0IGFsbG93ZWRDb250ZW50IHJ1bGVzLCBkZXBlbmRpbmdcblx0Ly8gb24gY29uZmlndXJhdGlvbnMgbGlrZSBjb25maWcjYWVfZHJhZ3Jlc2l6ZV9pZTExX2FsaWduQ2xhc3NlcyBvclxuXHQvLyBjb25maWcjYWVfZHJhZ3Jlc2l6ZV9pZTExX2NhcHRpb25lZENsYXNzLlxuXHQvL1xuXHQvLyBAcGFyYW0ge0NLRURJVE9SLmVkaXRvcn1cblx0Ly8gQHJldHVybnMge09iamVjdH1cblx0ZnVuY3Rpb24gZ2V0V2lkZ2V0QWxsb3dlZENvbnRlbnQoZWRpdG9yKSB7XG5cdFx0Y29uc3QgYWxpZ25DbGFzc2VzID0gZWRpdG9yLmNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfYWxpZ25DbGFzc2VzO1xuXG5cdFx0Y29uc3QgcnVsZXMgPSB7XG5cdFx0XHQvLyBXaWRnZXQgbWF5IG5lZWQgPGRpdj4gb3IgPHA+IGNlbnRlcmluZyB3cmFwcGVyLlxuXHRcdFx0ZGl2OiB7XG5cdFx0XHRcdG1hdGNoOiBjZW50ZXJXcmFwcGVyQ2hlY2tlcihlZGl0b3IpLFxuXHRcdFx0fSxcblx0XHRcdHA6IHtcblx0XHRcdFx0bWF0Y2g6IGNlbnRlcldyYXBwZXJDaGVja2VyKGVkaXRvciksXG5cdFx0XHR9LFxuXHRcdFx0aW1nOiB7XG5cdFx0XHRcdGF0dHJpYnV0ZXM6ICchc3JjLGFsdCx3aWR0aCxoZWlnaHQnLFxuXHRcdFx0fSxcblx0XHRcdGZpZ3VyZToge1xuXHRcdFx0XHRjbGFzc2VzOiAnIScgKyBlZGl0b3IuY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9jYXB0aW9uZWRDbGFzcyxcblx0XHRcdH0sXG5cdFx0XHRmaWdjYXB0aW9uOiB0cnVlLFxuXHRcdH07XG5cblx0XHRpZiAoYWxpZ25DbGFzc2VzKSB7XG5cdFx0XHQvLyBDZW50ZXJpbmcgY2xhc3MgZnJvbSB0aGUgY29uZmlnLlxuXHRcdFx0cnVsZXMuZGl2LmNsYXNzZXMgPSBhbGlnbkNsYXNzZXNbMV07XG5cdFx0XHRydWxlcy5wLmNsYXNzZXMgPSBydWxlcy5kaXYuY2xhc3NlcztcblxuXHRcdFx0Ly8gTGVmdC9yaWdodCBjbGFzc2VzIGZyb20gdGhlIGNvbmZpZy5cblx0XHRcdHJ1bGVzLmltZy5jbGFzc2VzID0gYWxpZ25DbGFzc2VzWzBdICsgJywnICsgYWxpZ25DbGFzc2VzWzJdO1xuXHRcdFx0cnVsZXMuZmlndXJlLmNsYXNzZXMgKz0gJywnICsgcnVsZXMuaW1nLmNsYXNzZXM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIENlbnRlcmluZyB3aXRoIHRleHQtYWxpZ24uXG5cdFx0XHRydWxlcy5kaXYuc3R5bGVzID0gJ3RleHQtYWxpZ24nO1xuXHRcdFx0cnVsZXMucC5zdHlsZXMgPSAndGV4dC1hbGlnbic7XG5cblx0XHRcdHJ1bGVzLmltZy5zdHlsZXMgPSAnZmxvYXQnO1xuXHRcdFx0cnVsZXMuZmlndXJlLnN0eWxlcyA9ICdmbG9hdCxkaXNwbGF5Jztcblx0XHR9XG5cblx0XHRyZXR1cm4gcnVsZXM7XG5cdH1cblxuXHQvLyBSZXR1cm5zIGEgc2V0IG9mIHdpZGdldCBmZWF0dXJlIHJ1bGVzLCBkZXBlbmRpbmdcblx0Ly8gb24gZWRpdG9yIGNvbmZpZ3VyYXRpb24uIE5vdGUgdGhhdCB0aGUgZm9sbG93aW5nIG1heSBub3QgY292ZXJcblx0Ly8gYWxsIHRoZSBwb3NzaWJsZSBjYXNlcyBzaW5jZSByZXF1aXJlZENvbnRlbnQgc3VwcG9ydHMgYSBzaW5nbGVcblx0Ly8gdGFnIG9ubHkuXG5cdC8vXG5cdC8vIEBwYXJhbSB7Q0tFRElUT1IuZWRpdG9yfVxuXHQvLyBAcmV0dXJucyB7T2JqZWN0fVxuXHRmdW5jdGlvbiBnZXRXaWRnZXRGZWF0dXJlcyhlZGl0b3IpIHtcblx0XHRjb25zdCBhbGlnbkNsYXNzZXMgPSBlZGl0b3IuY29uZmlnLmFlX2RyYWdyZXNpemVfaWUxMV9hbGlnbkNsYXNzZXM7XG5cblx0XHRjb25zdCBmZWF0dXJlcyA9IHtcblx0XHRcdGRpbWVuc2lvbjoge1xuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICdpbWdbd2lkdGgsaGVpZ2h0XScsXG5cdFx0XHR9LFxuXHRcdFx0YWxpZ246IHtcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OlxuXHRcdFx0XHRcdCdpbWcnICtcblx0XHRcdFx0XHQoYWxpZ25DbGFzc2VzID8gJygnICsgYWxpZ25DbGFzc2VzWzBdICsgJyknIDogJ3tmbG9hdH0nKSxcblx0XHRcdH0sXG5cdFx0XHRjYXB0aW9uOiB7XG5cdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ2ZpZ2NhcHRpb24nLFxuXHRcdFx0fSxcblx0XHR9O1xuXG5cdFx0cmV0dXJuIGZlYXR1cmVzO1xuXHR9XG5cblx0Ly8gUmV0dXJucyBlbGVtZW50IHdoaWNoIGlzIHN0eWxlZCwgY29uc2lkZXJpbmcgY3VycmVudFxuXHQvLyBzdGF0ZSBvZiB0aGUgd2lkZ2V0LlxuXHQvL1xuXHQvLyBAc2VlIENLRURJVE9SLnBsdWdpbnMud2lkZ2V0I2FwcGx5U3R5bGVcblx0Ly8gQHBhcmFtIHtDS0VESVRPUi5wbHVnaW5zLndpZGdldH0gd2lkZ2V0XG5cdC8vIEByZXR1cm5zIHtDS0VESVRPUi5kb20uZWxlbWVudH1cblx0ZnVuY3Rpb24gZ2V0U3R5bGVhYmxlRWxlbWVudCh3aWRnZXQpIHtcblx0XHRyZXR1cm4gd2lkZ2V0LmRhdGEuaGFzQ2FwdGlvbiA/IHdpZGdldC5lbGVtZW50IDogd2lkZ2V0LnBhcnRzLmltYWdlO1xuXHR9XG59KSgpO1xuXG4vKipcbiAqIEEgQ1NTIGNsYXNzIGFwcGxpZWQgdG8gdGhlIGA8ZmlndXJlPmAgZWxlbWVudCBvZiBhIGNhcHRpb25lZCBpbWFnZS5cbiAqXG4gKiBSZWFkIG1vcmUgaW4gdGhlIFtkb2N1bWVudGF0aW9uXSgjIS9ndWlkZS9kZXZfY2FwdGlvbmVkaW1hZ2UpIGFuZCBzZWUgdGhlXG4gKiBbU0RLIHNhbXBsZV0oaHR0cDovL3Nkay5ja2VkaXRvci5jb20vc2FtcGxlcy9jYXB0aW9uZWRpbWFnZS5odG1sKS5cbiAqXG4gKlx0XHQvLyBDaGFuZ2VzIHRoZSBjbGFzcyB0byBcImNhcHRpb25lZEltYWdlXCIuXG4gKlx0XHRjb25maWcuYWVfZHJhZ3Jlc2l6ZV9pZTExX2NhcHRpb25lZENsYXNzID0gJ2NhcHRpb25lZEltYWdlJztcbiAqXG4gKiBAY2ZnIHtTdHJpbmd9IFthZV9kcmFncmVzaXplX2llMTFfY2FwdGlvbmVkQ2xhc3M9J2ltYWdlJ11cbiAqIEBtZW1iZXIgQ0tFRElUT1IuY29uZmlnXG4gKi9cbkNLRURJVE9SLmNvbmZpZy5hZV9kcmFncmVzaXplX2llMTFfY2FwdGlvbmVkQ2xhc3MgPSAnaW1hZ2UnO1xuIiwiaW1wb3J0IHtISUdIX1BSSU9SSVRZfSBmcm9tICcuL3ByaW9yaXRpZXMnO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX2VtYmVkJykpIHtcblx0Y29uc3QgUkVHRVhfSFRUUCA9IC9eaHR0cHM/LztcblxuXHRjb25zdCBSRUdFWF9ERUZBVUxUX0xJTksgPSAvPGEgaHJlZj0vO1xuXG5cdENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfVVJMX1RQTCA9XG5cdFx0J2h0dHA6Ly9hbGxveS5pZnJhbWUubHkvYXBpL29lbWJlZD91cmw9e3VybH0mY2FsbGJhY2s9e2NhbGxiYWNrfSc7XG5cdENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfV0lER0VUX1RQTCA9XG5cdFx0JzxkaXYgZGF0YS1hZS1lbWJlZC11cmw9XCJ7dXJsfVwiPjwvZGl2Pic7XG5cdENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfREVGQVVMVF9MSU5LX1RQTCA9ICc8YSBocmVmPVwie3VybH1cIj57dXJsfTwvYT4nO1xuXHQvKipcblx0ICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGFkZHMgdGhlIGluZnJhc3RydWN0dXJlIHRvIGVtYmVkIHVybHMgYXMgbWVkaWEgb2JqZWN0cyB1c2luZyBhbiBvZW1iZWRcblx0ICogc2VydmljZS4gQnkgZGVmYXVsdCwgYW5kIGZvciBkZW1vaW5nIHB1cnBvc2VzIG9ubHksIHRoZSBvZW1iZWQgc2VydmljZSBpcyBob3N0ZWQgaW4gaWZyYW1lLmx5XG5cdCAqIGF0IC8vYWxsb3kuaWZyYW1lLmx5L2FwaS9vZW1iZWQ/dXJsPXt1cmx9JmNhbGxiYWNrPXtjYWxsYmFja30uIE5vdGUgdGhpcyBzaG91bGQgYmUgY2hhbmdlZCB0b1xuXHQgKiBhIHNlbGYtaG9zdGVkIG9yIHBhaWQgc2VydmljZSBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50cy4gQWNjZXNzIHRvIHRoZSBhbGxveS5pZnJhbWUubHkgZW5kcG9pbnRcblx0ICogbWF5IGJlIHJlc3RyaWN0ZWQgcGVyIGRvbWFpbiBkdWUgdG8gc2lnbmlmaWNhbnQgdHJhZmZpYy5cblx0ICpcblx0ICogVGhpcyBwbHVnaW4gYWRkcyBhbiBgZW1iZWRVcmxgIGNvbW1hbmQgdGhhdCBjYW4gYmUgdXNlZCB0byBlYXNpbHkgZW1iZWQgYSBVUkwgYW5kIHRyYW5zZm9ybSBpdFxuXHQgKiB0byBhbiBlbWJlZGRlZCBjb250ZW50LlxuXHQgKlxuXHQgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9lbWJlZFxuXHQgKi9cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX2VtYmVkJywge1xuXHRcdHJlcXVpcmVzOiAnd2lkZ2V0Jyxcblx0XHRpbml0KGVkaXRvcikge1xuXHRcdFx0Y29uc3QgQUVfRU1CRURfVVJMX1RQTCA9IG5ldyBDS0VESVRPUi50ZW1wbGF0ZShcblx0XHRcdFx0ZWRpdG9yLmNvbmZpZy5lbWJlZFVybFRlbXBsYXRlIHx8XG5cdFx0XHRcdFx0Q0tFRElUT1IuREVGQVVMVF9BRV9FTUJFRF9VUkxfVFBMXG5cdFx0XHQpO1xuXHRcdFx0Y29uc3QgQUVfRU1CRURfV0lER0VUX1RQTCA9IG5ldyBDS0VESVRPUi50ZW1wbGF0ZShcblx0XHRcdFx0ZWRpdG9yLmNvbmZpZy5lbWJlZFdpZGdldFRwbCB8fFxuXHRcdFx0XHRcdENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfV0lER0VUX1RQTFxuXHRcdFx0KTtcblx0XHRcdGNvbnN0IEFFX0VNQkVEX0RFRkFVTFRfTElOS19UUEwgPSBuZXcgQ0tFRElUT1IudGVtcGxhdGUoXG5cdFx0XHRcdGVkaXRvci5jb25maWcuZW1iZWRMaW5rRGVmYXVsdFRwbCB8fFxuXHRcdFx0XHRcdENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfREVGQVVMVF9MSU5LX1RQTFxuXHRcdFx0KTtcblxuXHRcdFx0Ly8gRGVmYXVsdCBmdW5jdGlvbiB0byB1cGNhc3QgRE9NIGVsZW1lbnRzIHRvIGVtYmVkIHdpZGdldHMuXG5cdFx0XHQvLyBJdCBtYXRjaGVzIENLRURJVE9SLkRFRkFVTFRfQUVfRU1CRURfV0lER0VUX1RQTFxuXHRcdFx0Y29uc3QgZGVmYXVsdEVtYmVkV2lkZ2V0VXBjYXN0Rm4gPSBmdW5jdGlvbihlbGVtZW50LCBkYXRhKSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRlbGVtZW50Lm5hbWUgPT09ICdkaXYnICYmXG5cdFx0XHRcdFx0ZWxlbWVudC5hdHRyaWJ1dGVzWydkYXRhLWFlLWVtYmVkLXVybCddXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGRhdGEudXJsID0gZWxlbWVudC5hdHRyaWJ1dGVzWydkYXRhLWFlLWVtYmVkLXVybCddO1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdC8vIENyZWF0ZSBhIGVtYmVkVXJsIGNvbW1hbmQgdGhhdCBjYW4gYmUgaW52b2tlZCB0byBlYXNpbHkgZW1iZWQgbWVkaWEgVVJMc1xuXHRcdFx0ZWRpdG9yLmFkZENvbW1hbmQoJ2VtYmVkVXJsJywge1xuXHRcdFx0XHRleGVjKGVkaXRvciwgZGF0YSkge1xuXHRcdFx0XHRcdGVkaXRvci5pbnNlcnRIdG1sKFxuXHRcdFx0XHRcdFx0QUVfRU1CRURfV0lER0VUX1RQTC5vdXRwdXQoe1xuXHRcdFx0XHRcdFx0XHR1cmw6IGRhdGEudXJsLFxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cblx0XHRcdC8vIENyZWF0ZSBhIHdpZGdldCB0byBwcm9wZXJseSBoYW5kbGUgZW1iZWQgb3BlcmF0aW9uc1xuXHRcdFx0ZWRpdG9yLndpZGdldHMuYWRkKCdhZV9lbWJlZCcsIHtcblx0XHRcdFx0bWFzazogdHJ1ZSxcblx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAnZGl2W2RhdGEtYWUtZW1iZWQtdXJsXScsXG5cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIExpc3RlbmVyIHRvIGJlIGV4ZWN1dGVkIGV2ZXJ5IHRpbWUgdGhlIHdpZGdldCdzIGRhdGEgY2hhbmdlcy4gSXQgdGFrZXMgY2FyZSBvZlxuXHRcdFx0XHQgKiByZXF1ZXN0aW5nIHRoZSBlbWJlZCBvYmplY3QgdG8gdGhlIGNvbmZpZ3VyZWQgb2VtYmVkIHNlcnZpY2UgYW5kIHJlbmRlciBpdCBpblxuXHRcdFx0XHQgKiB0aGUgZWRpdG9yXG5cdFx0XHRcdCAqXG5cdFx0XHRcdCAqIEBtZXRob2QgZGF0YVxuXHRcdFx0XHQgKiBAcGFyYW0ge2V2ZW50fSBldmVudCBEYXRhIGNoYW5nZSBldmVudFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0ZGF0YShldmVudCkge1xuXHRcdFx0XHRcdGNvbnN0IHdpZGdldCA9IHRoaXM7XG5cblx0XHRcdFx0XHRjb25zdCB1cmwgPSBldmVudC5kYXRhLnVybDtcblxuXHRcdFx0XHRcdGlmICh1cmwpIHtcblx0XHRcdFx0XHRcdENLRURJVE9SLnRvb2xzLmpzb25wKFxuXHRcdFx0XHRcdFx0XHRBRV9FTUJFRF9VUkxfVFBMLFxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0dXJsOiBlbmNvZGVVUklDb21wb25lbnQodXJsKSxcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24ocmVzcG9uc2UpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAocmVzcG9uc2UuaHRtbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRSRUdFWF9ERUZBVUxUX0xJTksudGVzdChyZXNwb25zZS5odG1sKVxuXHRcdFx0XHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHdpZGdldC5jcmVhdGVBVGFnKHVybCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR3aWRnZXQuZWxlbWVudC5zZXRIdG1sKHJlc3BvbnNlLmh0bWwpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR3aWRnZXQuY3JlYXRlQVRhZyh1cmwpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oX21zZykge1xuXHRcdFx0XHRcdFx0XHRcdHdpZGdldC5jcmVhdGVBVGFnKHVybCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdGNyZWF0ZUFUYWcodXJsKSB7XG5cdFx0XHRcdFx0dGhpcy5lZGl0b3IuZXhlY0NvbW1hbmQoJ3VuZG8nKTtcblxuXHRcdFx0XHRcdGNvbnN0IGFUYWdIdG1sID0gQUVfRU1CRURfREVGQVVMVF9MSU5LX1RQTC5vdXRwdXQoe1xuXHRcdFx0XHRcdFx0dXJsLFxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0dGhpcy5lZGl0b3IuaW5zZXJ0SHRtbChhVGFnSHRtbCk7XG5cdFx0XHRcdFx0dGhpcy5lZGl0b3IuZmlyZSgnYWN0aW9uUGVyZm9ybWVkJywgdGhpcyk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0LyoqXG5cdFx0XHRcdCAqIEZ1bmN0aW9uIHVzZWQgdG8gdXBjYXN0IGFuIGVsZW1lbnQgdG8gYWVfZW1iZWQgd2lkZ2V0cy5cblx0XHRcdFx0ICpcblx0XHRcdFx0ICogQG1ldGhvZCB1cGNhc3Rcblx0XHRcdFx0ICogQHBhcmFtIHtDS0VESVRPUi5odG1sUGFyc2VyLmVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gYmUgY2hlY2tlZFxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHdpZGdldFxuXHRcdFx0XHQgKi9cblx0XHRcdFx0dXBjYXN0KGVsZW1lbnQsIGRhdGEpIHtcblx0XHRcdFx0XHRjb25zdCBlbWJlZFdpZGdldFVwY2FzdEZuID1cblx0XHRcdFx0XHRcdGVkaXRvci5jb25maWcuZW1iZWRXaWRnZXRVcGNhc3RGbiB8fFxuXHRcdFx0XHRcdFx0ZGVmYXVsdEVtYmVkV2lkZ2V0VXBjYXN0Rm47XG5cblx0XHRcdFx0XHRyZXR1cm4gZW1iZWRXaWRnZXRVcGNhc3RGbihlbGVtZW50LCBkYXRhKTtcblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBZGQgYSBsaXN0ZW5lciB0byBoYW5kbGUgcGFzdGUgZXZlbnRzIGFuZCB0dXJuIGxpbmtzIGludG8gZW1iZWQgb2JqZWN0c1xuXHRcdFx0ZWRpdG9yLm9uY2UoJ2NvbnRlbnREb20nLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZWRpdG9yLm9uKFxuXHRcdFx0XHRcdCdwYXN0ZScsXG5cdFx0XHRcdFx0ZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGxpbmsgPSBldmVudC5kYXRhLmRhdGFWYWx1ZTtcblxuXHRcdFx0XHRcdFx0aWYgKFJFR0VYX0hUVFAudGVzdChsaW5rKSkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wKCk7XG5cblx0XHRcdFx0XHRcdFx0ZWRpdG9yLmV4ZWNDb21tYW5kKCdlbWJlZFVybCcsIHtcblx0XHRcdFx0XHRcdFx0XHR1cmw6IGV2ZW50LmRhdGEuZGF0YVZhbHVlLFxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XHQvLyBNYWtlIHN1cmUgd2UgcnVuIGJlZm9yZSBhdXRvbGluaydzIHBhc3RlIGhhbmRsZXIsXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHRoZSBsaW5rIHdpbGwgYmUgdHVybmVkIGludG8gYW4gYW5jaG9yIGFuZCBvdXJcblx0XHRcdFx0XHQvLyBSRUdFWF9IVFRQIHRlc3Qgd2lsbCBmYWlsLlxuXHRcdFx0XHRcdEhJR0hfUFJJT1JJVFlcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBZGQgYSBsaXN0ZW5lciB0byBoYW5kbGUgc2VsZWN0aW9uIGNoYW5nZSBldmVudHMgYW5kIHByb3Blcmx5IGRldGVjdCBlZGl0b3Jcblx0XHRcdC8vIGludGVyYWN0aW9ucyBvbiB0aGUgd2lkZ2V0cyB3aXRob3V0IG1lc3Npbmcgd2l0aCB3aWRnZXQgbmF0aXZlIHNlbGVjdGlvblxuXHRcdFx0ZWRpdG9yLm9uKCdzZWxlY3Rpb25DaGFuZ2UnLCBmdW5jdGlvbihfZXZlbnQpIHtcblx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0XHRcdGlmIChzZWxlY3Rpb24pIHtcblx0XHRcdFx0XHRjb25zdCBlbGVtZW50ID0gc2VsZWN0aW9uLmdldFNlbGVjdGVkRWxlbWVudCgpO1xuXG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHdpZGdldEVsZW1lbnQgPSBlbGVtZW50LmZpbmRPbmUoXG5cdFx0XHRcdFx0XHRcdCdbZGF0YS13aWRnZXQ9XCJhZV9lbWJlZFwiXSdcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGlmICh3aWRnZXRFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJlZ2lvbiA9IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdCgpO1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHNjcm9sbFBvc2l0aW9uID0gbmV3IENLRURJVE9SLmRvbS53aW5kb3coXG5cdFx0XHRcdFx0XHRcdFx0d2luZG93XG5cdFx0XHRcdFx0XHRcdCkuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcblx0XHRcdFx0XHRcdFx0cmVnaW9uLmxlZnQgLT0gc2Nyb2xsUG9zaXRpb24ueDtcblx0XHRcdFx0XHRcdFx0cmVnaW9uLnRvcCArPSBzY3JvbGxQb3NpdGlvbi55O1xuXG5cdFx0XHRcdFx0XHRcdHJlZ2lvbi5kaXJlY3Rpb24gPSBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUDtcblxuXHRcdFx0XHRcdFx0XHRlZGl0b3IuZmlyZSgnZWRpdG9ySW50ZXJhY3Rpb24nLCB7XG5cdFx0XHRcdFx0XHRcdFx0bmF0aXZlRXZlbnQ6IHt9LFxuXHRcdFx0XHRcdFx0XHRcdHNlbGVjdGlvbkRhdGE6IHtcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQ6IHdpZGdldEVsZW1lbnQsXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWdpb24sXG5cdFx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQWRkIGEgZmlsdGVyIHRvIHNraXAgZmlsdGVyaW5nIHdpZGdldCBlbGVtZW50c1xuXHRcdFx0ZWRpdG9yLmZpbHRlci5hZGRFbGVtZW50Q2FsbGJhY2soZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0XHRpZiAoJ2RhdGEtYWUtZW1iZWQtdXJsJyBpbiBlbGVtZW50LmF0dHJpYnV0ZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gQ0tFRElUT1IuRklMVEVSX1NLSVBfVFJFRTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCJpbXBvcnQgUmVzaXplciBmcm9tICcuL1Jlc2l6ZXIuZXMnO1xuXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdlbWJlZHVybCcpKSB7XG5cdGNvbnN0IFJFR0VYX0hUVFAgPSAvXmh0dHBzPy87XG5cblx0Q0tFRElUT1IuREVGQVVMVF9MRlJfRU1CRURfV0lER0VUX1RQTCA9XG5cdFx0JzxkaXYgZGF0YS1lbWJlZC11cmw9XCJ7dXJsfVwiIGNsYXNzPVwiZW1iZWQtcmVzcG9uc2l2ZSBlbWJlZC1yZXNwb25zaXZlLTE2Ynk5XCI+e2NvbnRlbnR9PGRpdiBjbGFzcz1cImVtYmVkLWhlbHAtbWVzc2FnZVwiPntoZWxwTWVzc2FnZUljb259PHNwYW4+IHtoZWxwTWVzc2FnZX08L3NwYW4+PC9kaXY+PC9kaXY+PGJyPic7XG5cblx0LyoqXG5cdCAqIEVudW0gZm9yIHN1cHBvcnRlZCBlbWJlZCBhbGlnbm1lbnRzXG5cdCAqIEB0eXBlIHtPYmplY3R9XG5cdCAqL1xuXG5cdGNvbnN0IEVNQkVEX0FMSUdOTUVOVCA9IHtcblx0XHRDRU5URVI6ICdjZW50ZXInLFxuXHRcdExFRlQ6ICdsZWZ0Jyxcblx0XHRSSUdIVDogJ3JpZ2h0Jyxcblx0fTtcblxuXHQvKipcblx0ICogRW51bSB2YWx1ZXMgZm9yIHN1cHBvcnRlZCBlbWJlZCBhbGlnbm1lbnRzXG5cdCAqIEB0eXBlIHtBcnJheX1cblx0ICovXG5cblx0Y29uc3QgQUxJR05fVkFMVUVTID0gW1xuXHRcdEVNQkVEX0FMSUdOTUVOVC5DRU5URVIsXG5cdFx0RU1CRURfQUxJR05NRU5ULkxFRlQsXG5cdFx0RU1CRURfQUxJR05NRU5ULlJJR0hULFxuXHRdO1xuXG5cdC8qKlxuXHQgKiBOZWNlc3Nhcnkgc3R5bGVzIGZvciB0aGUgY2VudGVyIGFsaWdubWVudFxuXHQgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG5cdCAqL1xuXG5cdGNvbnN0IENFTlRFUkVEX0VNQkVEX1NUWUxFID0gW1xuXHRcdHtcblx0XHRcdG5hbWU6ICdkaXNwbGF5Jyxcblx0XHRcdHZhbHVlOiAnYmxvY2snLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bmFtZTogJ21hcmdpbi1sZWZ0Jyxcblx0XHRcdHZhbHVlOiAnYXV0bycsXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRuYW1lOiAnbWFyZ2luLXJpZ2h0Jyxcblx0XHRcdHZhbHVlOiAnYXV0bycsXG5cdFx0fSxcblx0XTtcblxuXHQvKipcblx0ICogUmV0cmlldmVzIHRoZSBhbGlnbm1lbnQgdmFsdWUgb2YgYW4gZW1iZWQgZWxlbWVudC5cblx0ICpcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gZW1iZWQgVGhlIGVtYmVkIGVsZW1lbnRcblx0ICogQHJldHVybiB7U3RyaW5nfSBUaGUgYWxpZ25tZW50IHZhbHVlXG5cdCAqL1xuXG5cdGNvbnN0IGdldEVtYmVkQWxpZ25tZW50ID0gZnVuY3Rpb24oZW1iZWQpIHtcblx0XHRsZXQgZW1iZWRBbGlnbm1lbnQgPSBlbWJlZC5nZXRTdHlsZSgnZmxvYXQnKTtcblxuXHRcdGlmIChcblx0XHRcdCFlbWJlZEFsaWdubWVudCB8fFxuXHRcdFx0ZW1iZWRBbGlnbm1lbnQgPT09ICdpbmhlcml0JyB8fFxuXHRcdFx0ZW1iZWRBbGlnbm1lbnQgPT09ICdub25lJ1xuXHRcdCkge1xuXHRcdFx0ZW1iZWRBbGlnbm1lbnQgPSBlbWJlZC5nZXRBdHRyaWJ1dGUoJ2FsaWduJyk7XG5cdFx0fVxuXG5cdFx0aWYgKCFlbWJlZEFsaWdubWVudCkge1xuXHRcdFx0Y29uc3QgY2VudGVyZWRFbWJlZCA9IENFTlRFUkVEX0VNQkVEX1NUWUxFLmV2ZXJ5KHN0eWxlID0+IHtcblx0XHRcdFx0bGV0IHN0eWxlQ2hlY2sgPSBlbWJlZC5nZXRTdHlsZShzdHlsZS5uYW1lKSA9PT0gc3R5bGUudmFsdWU7XG5cblx0XHRcdFx0aWYgKCFzdHlsZUNoZWNrICYmIHN0eWxlLnZlbmRvclByZWZpeGVzKSB7XG5cdFx0XHRcdFx0c3R5bGVDaGVjayA9IHN0eWxlLnZlbmRvclByZWZpeGVzLnNvbWUoXG5cdFx0XHRcdFx0XHR2ZW5kb3JQcmVmaXggPT5cblx0XHRcdFx0XHRcdFx0ZW1iZWQuZ2V0U3R5bGUodmVuZG9yUHJlZml4ICsgc3R5bGUubmFtZSkgPT09XG5cdFx0XHRcdFx0XHRcdHN0eWxlLnZhbHVlXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBzdHlsZUNoZWNrO1xuXHRcdFx0fSk7XG5cblx0XHRcdGVtYmVkQWxpZ25tZW50ID0gY2VudGVyZWRFbWJlZCA/IEVNQkVEX0FMSUdOTUVOVC5DRU5URVIgOiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiBlbWJlZEFsaWdubWVudDtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgYWxpZ25tZW50IHZhbHVlIG9mIGFuIGVtYmVkXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGVtYmVkIFRoZSBlbWJlZCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBlbWJlZEFsaWdubWVudCBUaGUgZW1iZWQgYWxpZ25tZW50IHZhbHVlIHRvIGJlIHJlbW92ZWRcblx0ICovXG5cblx0Y29uc3QgcmVtb3ZlRW1iZWRBbGlnbm1lbnQgPSBmdW5jdGlvbihlbWJlZCwgZW1iZWRBbGlnbm1lbnQpIHtcblx0XHRpZiAoXG5cdFx0XHRlbWJlZEFsaWdubWVudCA9PT0gRU1CRURfQUxJR05NRU5ULkxFRlQgfHxcblx0XHRcdGVtYmVkQWxpZ25tZW50ID09PSBFTUJFRF9BTElHTk1FTlQuUklHSFRcblx0XHQpIHtcblx0XHRcdGVtYmVkLnJlbW92ZVN0eWxlKCdmbG9hdCcpO1xuXG5cdFx0XHRpZiAoZW1iZWRBbGlnbm1lbnQgPT09IGdldEVtYmVkQWxpZ25tZW50KGVtYmVkKSkge1xuXHRcdFx0XHRlbWJlZC5yZW1vdmVBdHRyaWJ1dGUoJ2FsaWduJyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChlbWJlZEFsaWdubWVudCA9PT0gRU1CRURfQUxJR05NRU5ULkNFTlRFUikge1xuXHRcdFx0Q0VOVEVSRURfRU1CRURfU1RZTEUuZm9yRWFjaChzdHlsZSA9PiB7XG5cdFx0XHRcdGVtYmVkLnJlbW92ZVN0eWxlKHN0eWxlLm5hbWUpO1xuXG5cdFx0XHRcdGlmIChzdHlsZS52ZW5kb3JQcmVmaXhlcykge1xuXHRcdFx0XHRcdHN0eWxlLnZlbmRvclByZWZpeGVzLmZvckVhY2godmVuZG9yUHJlZml4ID0+XG5cdFx0XHRcdFx0XHRlbWJlZC5yZW1vdmVTdHlsZSh2ZW5kb3JQcmVmaXggKyBzdHlsZS5uYW1lKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgYWxpZ25tZW50IHZhbHVlIG9mIGFuIGVtYmVkXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGVtYmVkIFRoZSBlbWJlZCBlbGVtZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBlbWJlZEFsaWdubWVudCBUaGUgZW1iZWQgYWxpZ25tZW50IHZhbHVlIHRvIGJlIHNldFxuXHQgKi9cblxuXHRjb25zdCBzZXRFbWJlZEFsaWdubWVudCA9IGZ1bmN0aW9uKGVtYmVkLCBlbWJlZEFsaWdubWVudCkge1xuXHRcdHJlbW92ZUVtYmVkQWxpZ25tZW50KGVtYmVkLCBnZXRFbWJlZEFsaWdubWVudChlbWJlZCkpO1xuXG5cdFx0aWYgKFxuXHRcdFx0ZW1iZWRBbGlnbm1lbnQgPT09IEVNQkVEX0FMSUdOTUVOVC5MRUZUIHx8XG5cdFx0XHRlbWJlZEFsaWdubWVudCA9PT0gRU1CRURfQUxJR05NRU5ULlJJR0hUXG5cdFx0KSB7XG5cdFx0XHRlbWJlZC5zZXRTdHlsZSgnZmxvYXQnLCBlbWJlZEFsaWdubWVudCk7XG5cdFx0fSBlbHNlIGlmIChlbWJlZEFsaWdubWVudCA9PT0gRU1CRURfQUxJR05NRU5ULkNFTlRFUikge1xuXHRcdFx0Q0VOVEVSRURfRU1CRURfU1RZTEUuZm9yRWFjaChzdHlsZSA9PiB7XG5cdFx0XHRcdGVtYmVkLnNldFN0eWxlKHN0eWxlLm5hbWUsIHN0eWxlLnZhbHVlKTtcblxuXHRcdFx0XHRpZiAoc3R5bGUudmVuZG9yUHJlZml4ZXMpIHtcblx0XHRcdFx0XHRzdHlsZS52ZW5kb3JQcmVmaXhlcy5mb3JFYWNoKHZlbmRvclByZWZpeCA9PlxuXHRcdFx0XHRcdFx0ZW1iZWQuc2V0U3R5bGUodmVuZG9yUHJlZml4ICsgc3R5bGUubmFtZSwgc3R5bGUudmFsdWUpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IGdldFNlbGVjdGVkRWxlbWVudCA9IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdGNvbnN0IHJlc3VsdCA9IHtcblx0XHRcdGFsaWdubWVudDogbnVsbCxcblx0XHRcdGVsZW1lbnQ6IG51bGwsXG5cdFx0fTtcblxuXHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblxuXHRcdGlmIChzZWxlY3Rpb24pIHtcblx0XHRcdGNvbnN0IHNlbGVjdGVkRWxlbWVudCA9IHNlbGVjdGlvbi5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRzZWxlY3RlZEVsZW1lbnQgJiZcblx0XHRcdFx0c2VsZWN0ZWRFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1ja2Utd2lkZ2V0LXdyYXBwZXInKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJlc3VsdC5hbGlnbm1lbnQgPSBnZXRFbWJlZEFsaWdubWVudChzZWxlY3RlZEVsZW1lbnQpO1xuXHRcdFx0XHRyZXN1bHQuZWxlbWVudCA9IHNlbGVjdGVkRWxlbWVudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGNvbnN0IHJlc2l6ZUVsZW1lbnQgPSBmdW5jdGlvbihlbCwgd2lkdGgsIGhlaWdodCkge1xuXHRcdGNvbnN0IHdyYXBwZXJFbGVtZW50ID0gZWwucGFyZW50RWxlbWVudDtcblxuXHRcdGlmICh3cmFwcGVyRWxlbWVudCAmJiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xuXHRcdFx0Y29uc3QgcmVjdCA9IHdyYXBwZXJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0XHRjb25zdCBwd2lkdGggPVxuXHRcdFx0XHR3aWR0aCA+PSByZWN0LndpZHRoXG5cdFx0XHRcdFx0PyAxMDBcblx0XHRcdFx0XHQ6IE1hdGguZmxvb3IoKHdpZHRoIC8gcmVjdC53aWR0aCkgKiAxMDApO1xuXHRcdFx0Y29uc3Qgc3R5bGUgPSBgd2lkdGg6JHtwd2lkdGh9JTtgO1xuXG5cdFx0XHR3cmFwcGVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgc3R5bGUpO1xuXG5cdFx0XHRjb25zdCB3aWRnZXRFbGVtZW50ID0gd3JhcHBlckVsZW1lbnQucXVlcnlTZWxlY3Rvcihcblx0XHRcdFx0J1tkYXRhLXdpZGdldD1cImVtYmVkdXJsXCJdJ1xuXHRcdFx0KTtcblxuXHRcdFx0aWYgKHdpZGdldEVsZW1lbnQpIHtcblx0XHRcdFx0Y29uc3Qgc3R5bGVzID1cblx0XHRcdFx0XHRKU09OLnBhcnNlKHdpZGdldEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXN0eWxlcycpKSB8fCB7fTtcblxuXHRcdFx0XHRzdHlsZXMud2lkdGggPSBgJHt3aWR0aH1weGA7XG5cdFx0XHRcdHN0eWxlcy5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgO1xuXG5cdFx0XHRcdHdpZGdldEVsZW1lbnQuc2V0QXR0cmlidXRlKFxuXHRcdFx0XHRcdCdkYXRhLXN0eWxlcycsXG5cdFx0XHRcdFx0SlNPTi5zdHJpbmdpZnkoc3R5bGVzKVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdGNvbnN0IGlmcmFtZUVsZW1lbnQgPSB3aWRnZXRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lmcmFtZScpO1xuXG5cdFx0XHRcdGlmIChpZnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdFx0aWZyYW1lRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xuXHRcdFx0XHRcdGlmcmFtZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdGNvbnN0IHNlbGVjdFdpZGdldCA9IGZ1bmN0aW9uKGVkaXRvcikge1xuXHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXG5cdFx0XHRpZiAoc2VsZWN0aW9uKSB7XG5cdFx0XHRcdGNvbnN0IHdyYXBwZXJFbGVtZW50ID0gc2VsZWN0aW9uLnJvb3QuZmluZChcblx0XHRcdFx0XHQnW2RhdGEtY2tlLXdpZGdldC13cmFwcGVyXSdcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAod3JhcHBlckVsZW1lbnQpIHtcblx0XHRcdFx0XHRjb25zdCBlbGVtZW50TGlzdCA9IHdyYXBwZXJFbGVtZW50LiQ7XG5cdFx0XHRcdFx0aWYgKGVsZW1lbnRMaXN0Lmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdGNvbnN0IGxhc3RFbGVtZW50ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KFxuXHRcdFx0XHRcdFx0XHRlbGVtZW50TGlzdFtlbGVtZW50TGlzdC5sZW5ndGggLSAxXVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgaW1hZ2VFbGVtZW50ID0gbGFzdEVsZW1lbnQuZmluZE9uZSgnaW1nJyk7XG5cdFx0XHRcdFx0XHRjb25zdCB3aWRnZXRFbGVtZW50ID0gbGFzdEVsZW1lbnQuZmluZE9uZShcblx0XHRcdFx0XHRcdFx0J1tkYXRhLXdpZGdldD1cImVtYmVkdXJsXCJdJ1xuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0aWYgKGltYWdlRWxlbWVudCAmJiB3aWRnZXRFbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJhbmdlID0gZWRpdG9yLmNyZWF0ZVJhbmdlKCk7XG5cblx0XHRcdFx0XHRcdFx0cmFuZ2Uuc2V0U3RhcnQod2lkZ2V0RWxlbWVudCwgMCk7XG5cdFx0XHRcdFx0XHRcdHJhbmdlLnNldEVuZChpbWFnZUVsZW1lbnQsIDEpO1xuXG5cdFx0XHRcdFx0XHRcdHNlbGVjdGlvbi5zZWxlY3RSYW5nZXMoW3JhbmdlXSk7XG5cdFx0XHRcdFx0XHRcdHNlbGVjdGlvbi5zZWxlY3RFbGVtZW50KGxhc3RFbGVtZW50KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LCAwKTtcblx0fTtcblxuXHRsZXQgY3VycmVudEFsaWdubWVudCA9IG51bGw7XG5cdGxldCBjdXJyZW50RWxlbWVudCA9IG51bGw7XG5cdGxldCByZXNpemVyID0gbnVsbDtcblxuXHQvKipcblx0ICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGFkZHMgdGhlIGluZnJhc3RydWN0dXJlIHRvIGVtYmVkIHVybHMgYXMgbWVkaWEgb2JqZWN0c1xuXHQgKlxuXHQgKiBUaGlzIHBsdWdpbiBhZGRzIGFuIGBlbWJlZFVybGAgY29tbWFuZCB0aGF0IGNhbiBiZSB1c2VkIHRvIGVhc2lseSBlbWJlZCBhIFVSTCBhbmQgdHJhbnNmb3JtIGl0XG5cdCAqIHRvIGFuIGVtYmVkZGVkIGNvbnRlbnQuXG5cdCAqXG5cdCAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmVtYmVkdXJsXG5cdCAqL1xuXG5cdENLRURJVE9SLnBsdWdpbnMuYWRkKCdlbWJlZHVybCcsIHtcblx0XHRyZXF1aXJlczogJ3dpZGdldCcsXG5cblx0XHRpbml0OiBlZGl0b3IgPT4ge1xuXHRcdFx0Y29uc3QgTEZSX0VNQkVEX1dJREdFVF9UUEwgPSBuZXcgQ0tFRElUT1IudGVtcGxhdGUoXG5cdFx0XHRcdGVkaXRvci5jb25maWcuZW1iZWRXaWRnZXRUcGwgfHxcblx0XHRcdFx0XHRDS0VESVRPUi5ERUZBVUxUX0xGUl9FTUJFRF9XSURHRVRfVFBMXG5cdFx0XHQpO1xuXG5cdFx0XHRsZXQgcHJvdmlkZXJzID0gZWRpdG9yLmNvbmZpZy5lbWJlZFByb3ZpZGVycyB8fCBbXTtcblxuXHRcdFx0cHJvdmlkZXJzID0gcHJvdmlkZXJzLm1hcChwcm92aWRlciA9PiB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0aWQ6IHByb3ZpZGVyLmlkLFxuXHRcdFx0XHRcdHRwbDogbmV3IENLRURJVE9SLnRlbXBsYXRlKFxuXHRcdFx0XHRcdFx0YDxkaXYgZGF0YS1lbWJlZC1pZD1cIntlbWJlZElkfVwiPiR7cHJvdmlkZXIudHBsfTwvZGl2PmBcblx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdHR5cGU6IHByb3ZpZGVyLnR5cGUsXG5cdFx0XHRcdFx0dXJsU2NoZW1lczogcHJvdmlkZXIudXJsU2NoZW1lcy5tYXAoXG5cdFx0XHRcdFx0XHRzY2hlbWUgPT4gbmV3IFJlZ0V4cChzY2hlbWUpXG5cdFx0XHRcdFx0KSxcblx0XHRcdFx0fTtcblx0XHRcdH0pO1xuXG5cdFx0XHRjb25zdCBnZW5lcmF0ZUVtYmVkQ29udGVudCA9ICh1cmwsIGNvbnRlbnQpID0+IHtcblx0XHRcdFx0cmV0dXJuIExGUl9FTUJFRF9XSURHRVRfVFBMLm91dHB1dCh7XG5cdFx0XHRcdFx0Y29udGVudCxcblx0XHRcdFx0XHRoZWxwTWVzc2FnZTogQWxsb3lFZGl0b3IuU3RyaW5ncy52aWRlb1BsYXliYWNrRGlzYWJsZWQsXG5cdFx0XHRcdFx0aGVscE1lc3NhZ2VJY29uOiBMaWZlcmF5LlV0aWwuZ2V0TGV4aWNvbkljb25UcGwoXG5cdFx0XHRcdFx0XHQnaW5mby1jaXJjbGUnXG5cdFx0XHRcdFx0KSxcblx0XHRcdFx0XHR1cmwsXG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblxuXHRcdFx0Y29uc3QgZGVmYXVsdEVtYmVkV2lkZ2V0VXBjYXN0Rm4gPSAoZWxlbWVudCwgZGF0YSkgPT4ge1xuXHRcdFx0XHRsZXQgdXBjYXN0V2lkZ2V0ID0gZmFsc2U7XG5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdGVsZW1lbnQubmFtZSA9PT0gJ2RpdicgJiZcblx0XHRcdFx0XHRlbGVtZW50LmF0dHJpYnV0ZXNbJ2RhdGEtZW1iZWQtdXJsJ11cblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZGF0YS51cmwgPSBlbGVtZW50LmF0dHJpYnV0ZXNbJ2RhdGEtZW1iZWQtdXJsJ107XG5cblx0XHRcdFx0XHR1cGNhc3RXaWRnZXQgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdGVsZW1lbnQubmFtZSA9PT0gJ2RpdicgJiZcblx0XHRcdFx0XHRlbGVtZW50LmF0dHJpYnV0ZXNbJ2RhdGEtZW1iZWQtaWQnXVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjb25zdCBpZnJhbWUgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuXG5cdFx0XHRcdFx0ZGF0YS51cmwgPSBpZnJhbWUuYXR0cmlidXRlcy5zcmM7XG5cblx0XHRcdFx0XHRkZWxldGUgZWxlbWVudC5hdHRyaWJ1dGVzLnN0eWxlO1xuXG5cdFx0XHRcdFx0Y29uc3QgZW1iZWRDb250ZW50ID0gZ2VuZXJhdGVFbWJlZENvbnRlbnQoXG5cdFx0XHRcdFx0XHRkYXRhLnVybCxcblx0XHRcdFx0XHRcdGVsZW1lbnQuZ2V0T3V0ZXJIdG1sKClcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Y29uc3Qgd2lkZ2V0RnJhZ21lbnQgPSBuZXcgQ0tFRElUT1IuaHRtbFBhcnNlci5mcmFnbWVudC5mcm9tSHRtbChcblx0XHRcdFx0XHRcdGVtYmVkQ29udGVudFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHR1cGNhc3RXaWRnZXQgPSB3aWRnZXRGcmFnbWVudC5jaGlsZHJlblswXTtcblxuXHRcdFx0XHRcdHVwY2FzdFdpZGdldC5hdHRyaWJ1dGVzWydkYXRhLXN0eWxlcyddID1cblx0XHRcdFx0XHRcdGVsZW1lbnQuYXR0cmlidXRlc1snZGF0YS1zdHlsZXMnXTtcblx0XHRcdFx0XHR1cGNhc3RXaWRnZXQucmVtb3ZlQ2xhc3MoJ2VtYmVkLXJlc3BvbnNpdmUnKTtcblx0XHRcdFx0XHR1cGNhc3RXaWRnZXQucmVtb3ZlQ2xhc3MoJ2VtYmVkLXJlc3BvbnNpdmUtMTZieTknKTtcblxuXHRcdFx0XHRcdGVsZW1lbnQucmVwbGFjZVdpdGgodXBjYXN0V2lkZ2V0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB1cGNhc3RXaWRnZXQ7XG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCBzaG93RXJyb3IgPSBlcnJvck1zZyA9PiB7XG5cdFx0XHRcdGVkaXRvci5maXJlKCdlcnJvcicsIGVycm9yTXNnKTtcblxuXHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHRlZGl0b3IuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cblx0XHRcdFx0XHRlZGl0b3IuZm9jdXMoKTtcblxuXHRcdFx0XHRcdHJlc2l6ZXIuaGlkZSgpO1xuXHRcdFx0XHR9LCAwKTtcblx0XHRcdH07XG5cblx0XHRcdGVkaXRvci5hZGRDb21tYW5kKCdlbWJlZFVybCcsIHtcblx0XHRcdFx0ZXhlYzogKGVkaXRvciwgZGF0YSkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHR5cGUgPSBkYXRhLnR5cGU7XG5cdFx0XHRcdFx0Y29uc3QgdXJsID0gZGF0YS51cmw7XG5cdFx0XHRcdFx0bGV0IGNvbnRlbnQ7XG5cblx0XHRcdFx0XHRpZiAoUkVHRVhfSFRUUC50ZXN0KHVybCkpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHZhbGlkUHJvdmlkZXIgPSBwcm92aWRlcnNcblx0XHRcdFx0XHRcdFx0LmZpbHRlcihwcm92aWRlciA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHR5cGUgPyBwcm92aWRlci50eXBlID09PSB0eXBlIDogdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0LnNvbWUocHJvdmlkZXIgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHNjaGVtZSA9IHByb3ZpZGVyLnVybFNjaGVtZXMuZmluZChcblx0XHRcdFx0XHRcdFx0XHRcdHNjaGVtZSA9PiBzY2hlbWUudGVzdCh1cmwpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChzY2hlbWUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGVtYmVkSWQgPSBzY2hlbWUuZXhlYyh1cmwpWzFdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjb250ZW50ID0gcHJvdmlkZXIudHBsLm91dHB1dCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVtYmVkSWQsXG5cdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gc2NoZW1lO1xuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0aWYgKHZhbGlkUHJvdmlkZXIpIHtcblx0XHRcdFx0XHRcdFx0ZWRpdG9yLl9zZWxlY3RFbWJlZFdpZGdldCA9IHVybDtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBlbWJlZENvbnRlbnQgPSBnZW5lcmF0ZUVtYmVkQ29udGVudChcblx0XHRcdFx0XHRcdFx0XHR1cmwsXG5cdFx0XHRcdFx0XHRcdFx0Y29udGVudFxuXHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdGVkaXRvci5pbnNlcnRIdG1sKGVtYmVkQ29udGVudCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzaG93RXJyb3IoQWxsb3lFZGl0b3IuU3RyaW5ncy5wbGF0Zm9ybU5vdFN1cHBvcnRlZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNob3dFcnJvcihBbGxveUVkaXRvci5TdHJpbmdzLmVudGVyVmFsaWRVcmwpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdH0pO1xuXG5cdFx0XHRlZGl0b3Iud2lkZ2V0cy5hZGQoJ2VtYmVkdXJsJywge1xuXHRcdFx0XHRkcmFnZ2FibGU6IGZhbHNlLFxuXHRcdFx0XHRtYXNrOiB0cnVlLFxuXHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICdkaXZbZGF0YS1lbWJlZC11cmxdJyxcblxuXHRcdFx0XHRkYXRhKGV2ZW50KSB7XG5cdFx0XHRcdFx0Y29uc3QgaW5zdGFuY2UgPSB0aGlzO1xuXG5cdFx0XHRcdFx0Ly8gU3luYyBkaW1lbnNpb25zIGFuZCBhbGlnbm1lbnQgd2l0aCBlZGl0b3Igd3JhcHBlclxuXG5cdFx0XHRcdFx0Y29uc3Qgc3R5bGVzSlNPTiA9IGluc3RhbmNlLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFxuXHRcdFx0XHRcdFx0J2RhdGEtc3R5bGVzJ1xuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRsZXQgc3R5bGVzID0gc3R5bGVzSlNPTiA/IEpTT04ucGFyc2Uoc3R5bGVzSlNPTikgOiBudWxsO1xuXG5cdFx0XHRcdFx0aWYgKCFzdHlsZXMpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGlmcmFtZSA9IGluc3RhbmNlLndyYXBwZXIuZmluZE9uZSgnaWZyYW1lJyk7XG5cblx0XHRcdFx0XHRcdGNvbnN0IGJvdW5kcyA9IGluc3RhbmNlLndyYXBwZXIuJC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdFx0XHRcdGNvbnN0IHdpZHRoID0gaWZyYW1lLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgcHdpZHRoID1cblx0XHRcdFx0XHRcdFx0d2lkdGggPj0gYm91bmRzLndpZHRoXG5cdFx0XHRcdFx0XHRcdFx0PyAxMDBcblx0XHRcdFx0XHRcdFx0XHQ6IE1hdGgucm91bmQoKHdpZHRoIC8gYm91bmRzLndpZHRoKSAqIDEwMCk7XG5cblx0XHRcdFx0XHRcdHN0eWxlcyA9IHtcblx0XHRcdFx0XHRcdFx0d2lkdGg6IGAke3B3aWR0aH0lYCxcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aW5zdGFuY2Uud3JhcHBlci5zZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0XHQnc3R5bGUnLFxuXHRcdFx0XHRcdFx0Q0tFRElUT1IudG9vbHMud3JpdGVDc3NUZXh0KHN0eWxlcylcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0aWYgKGVkaXRvci5fc2VsZWN0RW1iZWRXaWRnZXQgPT09IGV2ZW50LmRhdGEudXJsKSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RXaWRnZXQoZWRpdG9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0ZG93bmNhc3Qod2lkZ2V0KSB7XG5cdFx0XHRcdFx0Y29uc3QgZW1iZWRDb250ZW50ID0gd2lkZ2V0LmNoaWxkcmVuWzBdO1xuXG5cdFx0XHRcdFx0ZW1iZWRDb250ZW50LmF0dHJpYnV0ZXMuY2xhc3MgPVxuXHRcdFx0XHRcdFx0J2VtYmVkLXJlc3BvbnNpdmUgZW1iZWQtcmVzcG9uc2l2ZS0xNmJ5OSc7XG5cblx0XHRcdFx0XHRlbWJlZENvbnRlbnQuYXR0cmlidXRlc1snZGF0YS1zdHlsZXMnXSA9IEpTT04uc3RyaW5naWZ5KFxuXHRcdFx0XHRcdFx0Q0tFRElUT1IudG9vbHMucGFyc2VDc3NUZXh0KFxuXHRcdFx0XHRcdFx0XHR3aWRnZXQucGFyZW50LmF0dHJpYnV0ZXMuc3R5bGVcblx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0ZW1iZWRDb250ZW50LmF0dHJpYnV0ZXMuc3R5bGUgPVxuXHRcdFx0XHRcdFx0d2lkZ2V0LnBhcmVudC5hdHRyaWJ1dGVzLnN0eWxlO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGVtYmVkQ29udGVudDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHR1cGNhc3QoZWxlbWVudCwgZGF0YSkge1xuXHRcdFx0XHRcdGNvbnN0IGVtYmVkV2lkZ2V0VXBjYXN0Rm4gPVxuXHRcdFx0XHRcdFx0ZWRpdG9yLmNvbmZpZy5lbWJlZFdpZGdldFVwY2FzdEZuIHx8XG5cdFx0XHRcdFx0XHRkZWZhdWx0RW1iZWRXaWRnZXRVcGNhc3RGbjtcblxuXHRcdFx0XHRcdHJldHVybiBlbWJlZFdpZGdldFVwY2FzdEZuKGVsZW1lbnQsIGRhdGEpO1xuXHRcdFx0XHR9LFxuXHRcdFx0fSk7XG5cblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuXHRcdFx0XHQncmVzaXplJyxcblx0XHRcdFx0KCkgPT4ge1xuXHRcdFx0XHRcdHJlc2l6ZXIuaGlkZSgpO1xuXHRcdFx0XHRcdHNlbGVjdFdpZGdldChlZGl0b3IpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmYWxzZVxuXHRcdFx0KTtcblxuXHRcdFx0ZWRpdG9yLm9uKCdzZWxlY3Rpb25DaGFuZ2UnLCBfZXZlbnQgPT4ge1xuXHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cblx0XHRcdFx0aWYgKHNlbGVjdGlvbikge1xuXHRcdFx0XHRcdGNvbnN0IGVsZW1lbnQgPSBzZWxlY3Rpb24uZ2V0U2VsZWN0ZWRFbGVtZW50KCk7XG5cblx0XHRcdFx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0XHRcdFx0Y29uc3Qgd2lkZ2V0RWxlbWVudCA9IGVsZW1lbnQuZmluZE9uZShcblx0XHRcdFx0XHRcdFx0J1tkYXRhLXdpZGdldD1cImVtYmVkdXJsXCJdJ1xuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0aWYgKHdpZGdldEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3Qgc2Nyb2xsUG9zaXRpb24gPSBuZXcgQ0tFRElUT1IuZG9tLndpbmRvdyhcblx0XHRcdFx0XHRcdFx0XHR3aW5kb3dcblx0XHRcdFx0XHRcdFx0KS5nZXRTY3JvbGxQb3NpdGlvbigpO1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJlZ2lvbiA9IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdCgpO1xuXG5cdFx0XHRcdFx0XHRcdHJlZ2lvbi5kaXJlY3Rpb24gPSBDS0VESVRPUi5TRUxFQ1RJT05fQk9UVE9NX1RPX1RPUDtcblx0XHRcdFx0XHRcdFx0cmVnaW9uLmxlZnQgLT0gc2Nyb2xsUG9zaXRpb24ueDtcblx0XHRcdFx0XHRcdFx0cmVnaW9uLnRvcCArPSBzY3JvbGxQb3NpdGlvbi55O1xuXG5cdFx0XHRcdFx0XHRcdGVkaXRvci5maXJlKCdlZGl0b3JJbnRlcmFjdGlvbicsIHtcblx0XHRcdFx0XHRcdFx0XHRuYXRpdmVFdmVudDoge30sXG5cdFx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uRGF0YToge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZWxlbWVudDogd2lkZ2V0RWxlbWVudCxcblx0XHRcdFx0XHRcdFx0XHRcdHJlZ2lvbixcblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Y29uc3QgaW1hZ2VFbGVtZW50ID0gZWxlbWVudC5maW5kT25lKFxuXHRcdFx0XHRcdFx0XHQnaW1nLmNrZV93aWRnZXRfbWFzaydcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdGlmIChpbWFnZUVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0cmVzaXplci5zaG93KGltYWdlRWxlbWVudC4kKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzaXplci5oaWRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0ZWRpdG9yLm9uKCdkZXN0cm95JywgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCByZXNpemVFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NraW1ncnN6Jyk7XG5cblx0XHRcdFx0aWYgKHJlc2l6ZUVsZW1lbnQpIHtcblx0XHRcdFx0XHRyZXNpemVFbGVtZW50LnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2VEb3duTGlzdGVuZXIpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGVkaXRvci5vbignYmx1cicsICgpID0+IHtcblx0XHRcdFx0cmVzaXplci5oaWRlKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0ZWRpdG9yLmZpbHRlci5hZGRFbGVtZW50Q2FsbGJhY2soZWxlbWVudCA9PiB7XG5cdFx0XHRcdGlmICgnZGF0YS1lbWJlZC11cmwnIGluIGVsZW1lbnQuYXR0cmlidXRlcykge1xuXHRcdFx0XHRcdHJldHVybiBDS0VESVRPUi5GSUxURVJfU0tJUF9UUkVFO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdFx0Y29uc3QgbW91c2VEb3duTGlzdGVuZXIgPSBldmVudCA9PiB7XG5cdFx0XHRcdGNvbnN0IHJlc3VsdCA9IGdldFNlbGVjdGVkRWxlbWVudChlZGl0b3IpO1xuXG5cdFx0XHRcdGN1cnJlbnRBbGlnbm1lbnQgPSByZXN1bHQuYWxpZ25tZW50O1xuXHRcdFx0XHRjdXJyZW50RWxlbWVudCA9IHJlc3VsdC5lbGVtZW50O1xuXG5cdFx0XHRcdGlmIChyZXNpemVyLmlzSGFuZGxlKGV2ZW50LnRhcmdldCkpIHtcblx0XHRcdFx0XHRyZXNpemVyLmluaXREcmFnKGV2ZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdFx0cmVzaXplciA9IG5ldyBSZXNpemVyKGVkaXRvciwge1xuXHRcdFx0XHRvbkNvbXBsZXRlKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQpIHtcblx0XHRcdFx0XHRyZXNpemVFbGVtZW50KGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQpO1xuXG5cdFx0XHRcdFx0aWYgKGN1cnJlbnRBbGlnbm1lbnQgJiYgY3VycmVudEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdHNldEVtYmVkQWxpZ25tZW50KGN1cnJlbnRFbGVtZW50LCBjdXJyZW50QWxpZ25tZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZWN0V2lkZ2V0KGVkaXRvcik7XG5cdFx0XHRcdH0sXG5cdFx0XHR9KTtcblxuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2VEb3duTGlzdGVuZXIsIGZhbHNlKTtcblx0XHR9LFxuXG5cdFx0YWZ0ZXJJbml0OiBlZGl0b3IgPT4ge1xuXHRcdFx0QUxJR05fVkFMVUVTLmZvckVhY2goYWxpZ25WYWx1ZSA9PiB7XG5cdFx0XHRcdGNvbnN0IGNvbW1hbmQgPSBlZGl0b3IuZ2V0Q29tbWFuZCgnanVzdGlmeScgKyBhbGlnblZhbHVlKTtcblxuXHRcdFx0XHRpZiAoY29tbWFuZCkge1xuXHRcdFx0XHRcdGNvbW1hbmQub24oJ2V4ZWMnLCBldmVudCA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBzZWxlY3RlZEVsZW1lbnQgPSBlZGl0b3Jcblx0XHRcdFx0XHRcdFx0LmdldFNlbGVjdGlvbigpXG5cdFx0XHRcdFx0XHRcdC5nZXRTZWxlY3RlZEVsZW1lbnQoKTtcblxuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRzZWxlY3RlZEVsZW1lbnQgJiZcblx0XHRcdFx0XHRcdFx0c2VsZWN0ZWRFbGVtZW50LmdldEF0dHJpYnV0ZShcblx0XHRcdFx0XHRcdFx0XHQnZGF0YS1ja2Utd2lkZ2V0LXdyYXBwZXInXG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBzZWxlY3RlZEVtYmVkID0gc2VsZWN0ZWRFbGVtZW50LmZpbmRPbmUoXG5cdFx0XHRcdFx0XHRcdFx0J1tkYXRhLXdpZGdldD1cImVtYmVkdXJsXCJdIFtkYXRhLWVtYmVkLWlkXSdcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoc2VsZWN0ZWRFbWJlZCkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGVtYmVkQWxpZ25tZW50ID0gZ2V0RW1iZWRBbGlnbm1lbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHRzZWxlY3RlZEVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGVtYmVkQWxpZ25tZW50ID09PSBhbGlnblZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZW1vdmVFbWJlZEFsaWdubWVudChcblx0XHRcdFx0XHRcdFx0XHRcdFx0c2VsZWN0ZWRFbGVtZW50LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhbGlnblZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZXRFbWJlZEFsaWdubWVudChcblx0XHRcdFx0XHRcdFx0XHRcdFx0c2VsZWN0ZWRFbGVtZW50LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRhbGlnblZhbHVlXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRFbGVtZW50ID0gc2VsZWN0ZWRFbGVtZW50O1xuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRBbGlnbm1lbnQgPSBnZXRFbWJlZEFsaWdubWVudChcblx0XHRcdFx0XHRcdFx0XHRcdHNlbGVjdGVkRWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCBpbWFnZUVsZW1lbnQgPSBzZWxlY3RlZEVsZW1lbnQuZmluZE9uZShcblx0XHRcdFx0XHRcdFx0XHRcdCdpbWcnXG5cdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmIChpbWFnZUVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlc2l6ZXIuc2hvdyhpbWFnZUVsZW1lbnQuJCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0ZXZlbnQuY2FuY2VsKCk7XG5cblx0XHRcdFx0XHRcdFx0XHRjb25zdCBlbGVtZW50UGF0aCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudFBhdGgoXG5cdFx0XHRcdFx0XHRcdFx0XHRzZWxlY3RlZEVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0QUxJR05fVkFMVUVTLmZvckVhY2goYWxpZ25WYWx1ZSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBjb21tYW5kID0gZWRpdG9yLmdldENvbW1hbmQoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCdqdXN0aWZ5JyArIGFsaWduVmFsdWVcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmIChjb21tYW5kKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbW1hbmQucmVmcmVzaChlZGl0b3IsIGVsZW1lbnRQYXRoKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Y29tbWFuZC5vbigncmVmcmVzaCcsIGV2ZW50ID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGxhc3RFbGVtZW50ID0gZXZlbnQuZGF0YS5wYXRoLmxhc3RFbGVtZW50O1xuXG5cdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdGxhc3RFbGVtZW50ICYmXG5cdFx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LmdldEF0dHJpYnV0ZShcblx0XHRcdFx0XHRcdFx0XHQnZGF0YS1ja2Utd2lkZ2V0LXdyYXBwZXInXG5cdFx0XHRcdFx0XHRcdCkgJiZcblx0XHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQuZmluZE9uZSgnW2RhdGEtd2lkZ2V0XSBbZGF0YS1lbWJlZC1pZF0nKVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGVtYmVkQWxpZ25tZW50ID0gZ2V0RW1iZWRBbGlnbm1lbnQoXG5cdFx0XHRcdFx0XHRcdFx0bGFzdEVsZW1lbnRcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRldmVudC5zZW5kZXIuc2V0U3RhdGUoXG5cdFx0XHRcdFx0XHRcdFx0ZW1iZWRBbGlnbm1lbnQgPT09IGFsaWduVmFsdWVcblx0XHRcdFx0XHRcdFx0XHRcdD8gQ0tFRElUT1IuVFJJU1RBVEVfT05cblx0XHRcdFx0XHRcdFx0XHRcdDogQ0tFRElUT1IuVFJJU1RBVEVfT0ZGXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0ZXZlbnQuY2FuY2VsKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cdH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBDS0VESVRPUi5wbHVnaW5zLmdldCgnZW1iZWR1cmwnKTtcbiIsImltcG9ydCBTZWxlY3Rpb25UZXN0IGZyb20gJy4uL3NlbGVjdGlvbnMvc2VsZWN0aW9uLXRlc3QnO1xuXG5pZiAoIUNLRURJVE9SLnBsdWdpbnMuZ2V0KCdhZV9pbWFnZWFsaWdubWVudCcpKSB7XG5cdC8qKlxuXHQgKiBFbnVtIGZvciBzdXBwb3J0ZWQgaW1hZ2UgYWxpZ25tZW50c1xuXHQgKiBAdHlwZSB7T2JqZWN0fVxuXHQgKi9cblx0Y29uc3QgSU1BR0VfQUxJR05NRU5UID0ge1xuXHRcdENFTlRFUjogJ2NlbnRlcicsXG5cdFx0TEVGVDogJ2xlZnQnLFxuXHRcdFJJR0hUOiAncmlnaHQnLFxuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbnVtIHZhbHVlcyBmb3Igc3VwcG9ydGVkIGltYWdlIGFsaWdubWVudHNcblx0ICogQHR5cGUge0FycmF5fVxuXHQgKi9cblx0Y29uc3QgQUxJR05fVkFMVUVTID0gW1xuXHRcdElNQUdFX0FMSUdOTUVOVC5MRUZULFxuXHRcdElNQUdFX0FMSUdOTUVOVC5SSUdIVCxcblx0XHRJTUFHRV9BTElHTk1FTlQuQ0VOVEVSLFxuXHRdO1xuXG5cdC8qKlxuXHQgKiBOZWNlc3Nhcnkgc3R5bGVzIGZvciB0aGUgY2VudGVyIGFsaWdubWVudFxuXHQgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG5cdCAqL1xuXHRjb25zdCBDRU5URVJFRF9JTUFHRV9TVFlMRSA9IFtcblx0XHR7XG5cdFx0XHRuYW1lOiAnZGlzcGxheScsXG5cdFx0XHR2YWx1ZTogJ2Jsb2NrJyxcblx0XHR9LFxuXHRcdHtcblx0XHRcdG5hbWU6ICdtYXJnaW4tbGVmdCcsXG5cdFx0XHR2YWx1ZTogJ2F1dG8nLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bmFtZTogJ21hcmdpbi1yaWdodCcsXG5cdFx0XHR2YWx1ZTogJ2F1dG8nLFxuXHRcdH0sXG5cdF07XG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgYWxpZ25tZW50IHZhbHVlIG9mIGFuIGltYWdlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge0NLRURJVE9SLmRvbS5lbGVtZW50fSBpbWFnZSBUaGUgaW1hZ2UgZWxlbWVudFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBhbGlnbm1lbnQgdmFsdWVcblx0ICovXG5cdGNvbnN0IGdldEltYWdlQWxpZ25tZW50ID0gZnVuY3Rpb24oaW1hZ2UpIHtcblx0XHRsZXQgaW1hZ2VBbGlnbm1lbnQgPSBpbWFnZS5nZXRTdHlsZSgnZmxvYXQnKTtcblxuXHRcdGlmIChcblx0XHRcdCFpbWFnZUFsaWdubWVudCB8fFxuXHRcdFx0aW1hZ2VBbGlnbm1lbnQgPT09ICdpbmhlcml0JyB8fFxuXHRcdFx0aW1hZ2VBbGlnbm1lbnQgPT09ICdub25lJ1xuXHRcdCkge1xuXHRcdFx0aW1hZ2VBbGlnbm1lbnQgPSBpbWFnZS5nZXRBdHRyaWJ1dGUoJ2FsaWduJyk7XG5cdFx0fVxuXG5cdFx0aWYgKCFpbWFnZUFsaWdubWVudCkge1xuXHRcdFx0bGV0IGNlbnRlcmVkSW1hZ2UgPSBDRU5URVJFRF9JTUFHRV9TVFlMRS5ldmVyeShmdW5jdGlvbihzdHlsZSkge1xuXHRcdFx0XHRsZXQgc3R5bGVDaGVjayA9IGltYWdlLmdldFN0eWxlKHN0eWxlLm5hbWUpID09PSBzdHlsZS52YWx1ZTtcblxuXHRcdFx0XHRpZiAoIXN0eWxlQ2hlY2sgJiYgc3R5bGUudmVuZG9yUHJlZml4ZXMpIHtcblx0XHRcdFx0XHRzdHlsZUNoZWNrID0gc3R5bGUudmVuZG9yUHJlZml4ZXMuc29tZShmdW5jdGlvbihcblx0XHRcdFx0XHRcdHZlbmRvclByZWZpeFxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIChcblx0XHRcdFx0XHRcdFx0aW1hZ2UuZ2V0U3R5bGUodmVuZG9yUHJlZml4ICsgc3R5bGUubmFtZSkgPT09XG5cdFx0XHRcdFx0XHRcdHN0eWxlLnZhbHVlXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHN0eWxlQ2hlY2s7XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKCFpbWFnZUFsaWdubWVudCkge1xuXHRcdFx0XHRjb25zdCBpbWFnZUNvbnRhaW5lciA9IGltYWdlLiQucGFyZW50Tm9kZTtcblxuXHRcdFx0XHRpZiAoaW1hZ2VDb250YWluZXIuc3R5bGUudGV4dEFsaWduID09IElNQUdFX0FMSUdOTUVOVC5DRU5URVIpIHtcblx0XHRcdFx0XHRDRU5URVJFRF9JTUFHRV9TVFlMRS5mb3JFYWNoKGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0XHRcdFx0XHRpbWFnZS5zZXRTdHlsZShzdHlsZS5uYW1lLCBzdHlsZS52YWx1ZSk7XG5cblx0XHRcdFx0XHRcdGlmIChzdHlsZS52ZW5kb3JQcmVmaXhlcykge1xuXHRcdFx0XHRcdFx0XHRzdHlsZS52ZW5kb3JQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uKFxuXHRcdFx0XHRcdFx0XHRcdHZlbmRvclByZWZpeFxuXHRcdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0XHRpbWFnZS5zZXRTdHlsZShcblx0XHRcdFx0XHRcdFx0XHRcdHZlbmRvclByZWZpeCArIHN0eWxlLm5hbWUsXG5cdFx0XHRcdFx0XHRcdFx0XHRzdHlsZS52YWx1ZVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGNlbnRlcmVkSW1hZ2UgPSB0cnVlO1xuXHRcdFx0XHRcdGltYWdlQ29udGFpbmVyLnN0eWxlLnRleHRBbGlnbiA9ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGltYWdlQWxpZ25tZW50ID0gY2VudGVyZWRJbWFnZSA/IElNQUdFX0FMSUdOTUVOVC5DRU5URVIgOiBudWxsO1xuXHRcdH1cblxuXHRcdGlmICghQ0tFRElUT1IuZW52LmVkZ2UgJiYgQ0tFRElUT1IuZW52LmllKSB7XG5cdFx0XHRjb25zdCBwID0gaW1hZ2UuZmluZE9uZSgncCcpO1xuXHRcdFx0aWYgKHApIHtcblx0XHRcdFx0aW1hZ2VBbGlnbm1lbnQgPSBwLmdldFN0eWxlKCd0ZXh0LWFsaWduJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGltYWdlQWxpZ25tZW50O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIHRoZSBhbGlnbm1lbnQgdmFsdWUgb2YgYW4gaW1hZ2Vcblx0ICpcblx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gaW1hZ2UgVGhlIGltYWdlIGVsZW1lbnRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGltYWdlQWxpZ25tZW50IFRoZSBpbWFnZSBhbGlnbm1lbnQgdmFsdWUgdG8gYmUgcmVtb3ZlZFxuXHQgKi9cblx0Y29uc3QgcmVtb3ZlSW1hZ2VBbGlnbm1lbnQgPSBmdW5jdGlvbihpbWFnZSwgaW1hZ2VBbGlnbm1lbnQpIHtcblx0XHRpZiAoXG5cdFx0XHRpbWFnZUFsaWdubWVudCA9PT0gSU1BR0VfQUxJR05NRU5ULkxFRlQgfHxcblx0XHRcdGltYWdlQWxpZ25tZW50ID09PSBJTUFHRV9BTElHTk1FTlQuUklHSFRcblx0XHQpIHtcblx0XHRcdGltYWdlLnJlbW92ZVN0eWxlKCdmbG9hdCcpO1xuXG5cdFx0XHRpZiAoaW1hZ2VBbGlnbm1lbnQgPT09IGdldEltYWdlQWxpZ25tZW50KGltYWdlKSkge1xuXHRcdFx0XHRpbWFnZS5yZW1vdmVBdHRyaWJ1dGUoJ2FsaWduJyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChpbWFnZUFsaWdubWVudCA9PT0gSU1BR0VfQUxJR05NRU5ULkNFTlRFUikge1xuXHRcdFx0Q0VOVEVSRURfSU1BR0VfU1RZTEUuZm9yRWFjaChmdW5jdGlvbihzdHlsZSkge1xuXHRcdFx0XHRpbWFnZS5yZW1vdmVTdHlsZShzdHlsZS5uYW1lKTtcblxuXHRcdFx0XHRpZiAoc3R5bGUudmVuZG9yUHJlZml4ZXMpIHtcblx0XHRcdFx0XHRzdHlsZS52ZW5kb3JQcmVmaXhlcy5mb3JFYWNoKGZ1bmN0aW9uKHZlbmRvclByZWZpeCkge1xuXHRcdFx0XHRcdFx0aW1hZ2UucmVtb3ZlU3R5bGUodmVuZG9yUHJlZml4ICsgc3R5bGUubmFtZSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRjb25zdCBpbWFnZUNvbnRhaW5lciA9IGltYWdlLiQucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKGltYWdlQ29udGFpbmVyLnN0eWxlLnRleHRBbGlnbiA9PSBJTUFHRV9BTElHTk1FTlQuQ0VOVEVSKSB7XG5cdFx0XHRcdGltYWdlQ29udGFpbmVyLnN0eWxlLnRleHRBbGlnbiA9ICcnO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgYWxpZ25tZW50IHZhbHVlIG9mIGFuIGltYWdlXG5cdCAqXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGltYWdlIFRoZSBpbWFnZSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbWFnZUFsaWdubWVudCBUaGUgaW1hZ2UgYWxpZ25tZW50IHZhbHVlIHRvIGJlIHNldFxuXHQgKi9cblx0Y29uc3Qgc2V0SW1hZ2VBbGlnbm1lbnQgPSBmdW5jdGlvbihpbWFnZSwgaW1hZ2VBbGlnbm1lbnQpIHtcblx0XHRyZW1vdmVJbWFnZUFsaWdubWVudChpbWFnZSwgZ2V0SW1hZ2VBbGlnbm1lbnQoaW1hZ2UpKTtcblxuXHRcdGlmIChcblx0XHRcdGltYWdlQWxpZ25tZW50ID09PSBJTUFHRV9BTElHTk1FTlQuTEVGVCB8fFxuXHRcdFx0aW1hZ2VBbGlnbm1lbnQgPT09IElNQUdFX0FMSUdOTUVOVC5SSUdIVFxuXHRcdCkge1xuXHRcdFx0aW1hZ2Uuc2V0U3R5bGUoJ2Zsb2F0JywgaW1hZ2VBbGlnbm1lbnQpO1xuXHRcdH0gZWxzZSBpZiAoaW1hZ2VBbGlnbm1lbnQgPT09IElNQUdFX0FMSUdOTUVOVC5DRU5URVIpIHtcblx0XHRcdENFTlRFUkVEX0lNQUdFX1NUWUxFLmZvckVhY2goZnVuY3Rpb24oc3R5bGUpIHtcblx0XHRcdFx0aW1hZ2Uuc2V0U3R5bGUoc3R5bGUubmFtZSwgc3R5bGUudmFsdWUpO1xuXG5cdFx0XHRcdGlmIChzdHlsZS52ZW5kb3JQcmVmaXhlcykge1xuXHRcdFx0XHRcdHN0eWxlLnZlbmRvclByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24odmVuZG9yUHJlZml4KSB7XG5cdFx0XHRcdFx0XHRpbWFnZS5zZXRTdHlsZSh2ZW5kb3JQcmVmaXggKyBzdHlsZS5uYW1lLCBzdHlsZS52YWx1ZSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIG1vZGlmaWVzIHRoZSBqdXN0aWZ5IGNvbW1hbmRzIHRvIHByb3Blcmx5IGFsaWduIGltYWdlcy4gVGhpc1xuXHQgKiBwbHVnaW4gaXMgYW4gZXhjZXJwdCBvZiBDS0VkaXRvcidzIG9yaWdpbmFsIGltYWdlIG9uZSB0aGF0IGNhbiBiZSBmb3VuZCBhdFxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vY2tlZGl0b3IvY2tlZGl0b3ItZGV2L2Jsb2IvbWFzdGVyL3BsdWdpbnMvaW1hZ2UvcGx1Z2luLmpzXG5cdCAqXG5cdCAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX2ltYWdlYWxpZ25tZW50XG5cdCAqL1xuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfaW1hZ2VhbGlnbm1lbnQnLCB7XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuXHRcdCAqIFRoZSBmdW5jdGlvbiByZWdpc3RlcnMgYSAncGFzdGUnIGV2ZW50IG9uIHRoZSBlZGl0aW5nIGFyZWEuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIGFmdGVySW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICovXG5cdFx0YWZ0ZXJJbml0KGVkaXRvcikge1xuXHRcdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cblx0XHRcdEFMSUdOX1ZBTFVFUy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGNvbnN0IGNvbW1hbmQgPSBlZGl0b3IuZ2V0Q29tbWFuZCgnanVzdGlmeScgKyB2YWx1ZSk7XG5cblx0XHRcdFx0aWYgKGNvbW1hbmQpIHtcblx0XHRcdFx0XHRjb21tYW5kLm9uKCdleGVjJywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uRGF0YSgpO1xuXG5cdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdHNlbGVjdGlvbkRhdGEgJiZcblx0XHRcdFx0XHRcdFx0U2VsZWN0aW9uVGVzdC5pbWFnZSh7XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YToge3NlbGVjdGlvbkRhdGF9LFxuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGltYWdlID0gc2VsZWN0aW9uRGF0YS5lbGVtZW50O1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGltYWdlQWxpZ25tZW50ID0gZ2V0SW1hZ2VBbGlnbm1lbnQoaW1hZ2UpO1xuXG5cdFx0XHRcdFx0XHRcdGlmIChpbWFnZUFsaWdubWVudCA9PT0gdmFsdWUpIHtcblx0XHRcdFx0XHRcdFx0XHRyZW1vdmVJbWFnZUFsaWdubWVudChpbWFnZSwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHNldEltYWdlQWxpZ25tZW50KGltYWdlLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRldmVudC5jYW5jZWwoKTtcblxuXHRcdFx0XHRcdFx0XHRzZWxmLnJlZnJlc2hDb21tYW5kcyhcblx0XHRcdFx0XHRcdFx0XHRlZGl0b3IsXG5cdFx0XHRcdFx0XHRcdFx0bmV3IENLRURJVE9SLmRvbS5lbGVtZW50UGF0aChpbWFnZSlcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdGNvbW1hbmQub24oJ3JlZnJlc2gnLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uRGF0YSA9IHtcblx0XHRcdFx0XHRcdFx0ZWxlbWVudDogZXZlbnQuZGF0YS5wYXRoLmxhc3RFbGVtZW50LFxuXHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0XHRTZWxlY3Rpb25UZXN0LmltYWdlKHtcblx0XHRcdFx0XHRcdFx0XHRkYXRhOiB7c2VsZWN0aW9uRGF0YX0sXG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgaW1hZ2VBbGlnbm1lbnQgPSBnZXRJbWFnZUFsaWdubWVudChcblx0XHRcdFx0XHRcdFx0XHRzZWxlY3Rpb25EYXRhLmVsZW1lbnRcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHR0aGlzLnNldFN0YXRlKFxuXHRcdFx0XHRcdFx0XHRcdGltYWdlQWxpZ25tZW50ID09PSB2YWx1ZVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBDS0VESVRPUi5UUklTVEFURV9PTlxuXHRcdFx0XHRcdFx0XHRcdFx0OiBDS0VESVRPUi5UUklTVEFURV9PRkZcblx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRldmVudC5jYW5jZWwoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZvcmNlcyBhIHJlZnJlc2ggb2YgdGhlIG1vZGlmaWVkIGp1c3RpZnkgY29tbWFuZHMuIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGFwcGxpZWQgY2hhbmdlc1xuXHRcdCAqIGRvIG5vdCBtb2RpZnkgdGhlIHNlbGVjdGlvbiwgc28gdGhlIHJlZnJlc2ggaXMgbmV2ZXIgdHJpZ2dlcmVkIGFuZCB0aGUgVUkgZG9lcyBub3QgdXBkYXRlXG5cdFx0ICogcHJvcGVybHkgdW50aWwgdGhlIG5leHQgc2VsZWN0aW9uQ2hhbmdlIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtDS0VESVRPUi5lZGl0b3J9IGVkaXRvciBUaGUgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudFBhdGh9IGVsZW1lbnRQYXRoIFRoZSBwYXRoIG9mIHRoZSBzZWxlY3RlZCBpbWFnZVxuXHRcdCAqL1xuXHRcdHJlZnJlc2hDb21tYW5kcyhlZGl0b3IsIGVsZW1lbnRQYXRoKSB7XG5cdFx0XHRBTElHTl9WQUxVRVMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRjb25zdCBjb21tYW5kID0gZWRpdG9yLmdldENvbW1hbmQoJ2p1c3RpZnknICsgdmFsdWUpO1xuXG5cdFx0XHRcdGlmIChjb21tYW5kKSB7XG5cdFx0XHRcdFx0Y29tbWFuZC5yZWZyZXNoKGVkaXRvciwgZWxlbWVudFBhdGgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9LFxuXHR9KTtcbn1cbiIsImltcG9ydCAnLi9hZGRpbWFnZXMnO1xuaW1wb3J0ICcuL2F1dG9saW5rJztcbmltcG9ydCAnLi9hdXRvbGlzdCc7XG5pbXBvcnQgJy4vZHJhZ3Jlc2l6ZSc7XG5pbXBvcnQgJy4vZHJhZ3Jlc2l6ZV9pZSc7XG5pbXBvcnQgJy4vZHJhZ3Jlc2l6ZV9pZTExJztcbmltcG9ydCAnLi9lbWJlZCc7XG5pbXBvcnQgZW1iZWR1cmwgZnJvbSAnLi9lbWJlZHVybCc7XG5pbXBvcnQgJy4vaW1hZ2VhbGlnbm1lbnQnO1xuaW1wb3J0ICcuL3Bhc3RlaW1hZ2VzJztcbmltcG9ydCAnLi9wbGFjZWhvbGRlcic7XG5pbXBvcnQgJy4vc2VsZWN0aW9ua2V5c3Ryb2tlcyc7XG5pbXBvcnQgJy4vdGFibGVyZXNpemUnO1xuaW1wb3J0ICcuL3RhYmxldG9vbHMnO1xuXG5leHBvcnQge2VtYmVkdXJsfTtcbiIsImlmICghQ0tFRElUT1IucGx1Z2lucy5nZXQoJ2FlX3Bhc3RlaW1hZ2VzJykpIHtcblx0LyoqXG5cdCAqIENLRWRpdG9yIHBsdWdpbiB3aGljaCBhbGxvd3MgcGFzdGluZyBpbWFnZXMgZGlyZWN0bHkgaW50byB0aGUgZWRpdGFibGUgYXJlYS4gVGhlIGltYWdlIHdpbGwgYmUgZW5jb2RlZFxuXHQgKiBhcyBEYXRhIFVSSS4gQW4gZXZlbnQgYGJlZm9yZUltYWdlQWRkYCB3aWxsIGJlIGZpcmVkIHdpdGggdGhlIGxpc3Qgb2YgcGFzdGVkIGltYWdlcy4gSWYgYW55IG9mIHRoZSBsaXN0ZW5lcnNcblx0ICogcmV0dXJucyBgZmFsc2VgIG9yIGNhbmNlbHMgdGhlIGV2ZW50LCB0aGUgaW1hZ2VzIHdvbid0IGJlIGFkZGVkIHRvIHRoZSBjb250ZW50LiBPdGhlcndpc2UsXG5cdCAqIGFuIGV2ZW50IGBpbWFnZUFkZGAgd2lsbCBiZSBmaXJlZCB3aXRoIHRoZSBpbnNlcnRlZCBlbGVtZW50IGludG8gdGhlIGVkaXRhYmxlIGFyZWEuXG5cdCAqXG5cdCAqIEBjbGFzcyBDS0VESVRPUi5wbHVnaW5zLmFlX3Bhc3RlaW1hZ2VzXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBGaXJlZCBiZWZvcmUgYWRkaW5nIGltYWdlcyB0byB0aGUgZWRpdG9yLlxuXHQgKiBAZXZlbnQgYmVmb3JlSW1hZ2VBZGRcblx0ICogQHBhcmFtIHtBcnJheX0gaW1hZ2VGaWxlcyBBcnJheSBvZiBpbWFnZSBmaWxlc1xuXHQgKi9cblxuXHQvKipcblx0ICogRmlyZWQgd2hlbiBhbiBpbWFnZSBpcyBiZWluZyBhZGRlZCB0byB0aGUgZWRpdG9yIHN1Y2Nlc3NmdWxseS5cblx0ICpcblx0ICogQGV2ZW50IGltYWdlQWRkXG5cdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmVsZW1lbnR9IGVsIFRoZSBjcmVhdGVkIGltYWdlIHdpdGggc3JjIGFzIERhdGEgVVJJXG5cdCAqIEBwYXJhbSB7RmlsZX0gZmlsZSBUaGUgaW1hZ2UgZmlsZVxuXHQgKi9cblxuXHRDS0VESVRPUi5wbHVnaW5zLmFkZCgnYWVfcGFzdGVpbWFnZXMnLCB7XG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuXHRcdCAqIFRoZSBmdW5jdGlvbiByZWdpc3RlcnMgYSAncGFzdGUnIGV2ZW50IG9uIHRoZSBlZGl0aW5nIGFyZWEuXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIGluaXRcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gZWRpdG9yIFRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuXHRcdCAqL1xuXHRcdGluaXQoZWRpdG9yKSB7XG5cdFx0XHRlZGl0b3Iub25jZShcblx0XHRcdFx0J2NvbnRlbnREb20nLFxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRjb25zdCBlZGl0YWJsZSA9IGVkaXRvci5lZGl0YWJsZSgpO1xuXG5cdFx0XHRcdFx0ZWRpdGFibGUuYXR0YWNoTGlzdGVuZXIoXG5cdFx0XHRcdFx0XHRlZGl0YWJsZSxcblx0XHRcdFx0XHRcdCdwYXN0ZScsXG5cdFx0XHRcdFx0XHR0aGlzLl9vblBhc3RlLFxuXHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0ZWRpdG9yLFxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0uYmluZCh0aGlzKVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhlIGZ1bmN0aW9uIGNyZWF0ZXMgYW4gaW1nIGVsZW1lbnQgd2l0aCBzcmMgdGhlIGltYWdlIGRhdGEgYXMgRGF0YSBVUkkuXG5cdFx0ICogVGhlbiwgaXQgZmlyZXMgYW4gJ2ltYWdlQWRkJyBldmVudCB2aWEgQ0tFZGl0b3IncyBldmVudCBzeXN0ZW0uIFRoZSBwYXNzZWRcblx0XHQgKiBwYXJhbXMgd2lsbCBiZTpcblx0XHQgKiAtIGBlbGAgLSB0aGUgY3JlYXRlZCBpbWcgZWxlbWVudFxuXHRcdCAqIC0gYGZpbGVgIC0gdGhlIG9yaWdpbmFsIHBhc3RlZCBkYXRhXG5cdFx0ICpcblx0XHQgKiBAbWV0aG9kIF9vblBhc3RlXG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmV2ZW50fSBldmVudCBBIGBwYXN0ZWAgZXZlbnQsIGFzIHJlY2VpdmVkIG5hdGl2ZWx5IGZyb20gQ0tFZGl0b3Jcblx0XHQgKi9cblx0XHRfb25QYXN0ZShldmVudCkge1xuXHRcdFx0aWYgKGV2ZW50LmRhdGEuJC5jbGlwYm9hcmREYXRhKSB7XG5cdFx0XHRcdGNvbnN0IHBhc3RlZERhdGEgPSBldmVudC5kYXRhLiQuY2xpcGJvYXJkRGF0YS5pdGVtc1swXTtcblx0XHRcdFx0Y29uc3QgZWRpdG9yID0gZXZlbnQubGlzdGVuZXJEYXRhLmVkaXRvcjtcblxuXHRcdFx0XHRpZiAocGFzdGVkRGF0YS50eXBlLmluZGV4T2YoJ2ltYWdlJykgPT09IDApIHtcblx0XHRcdFx0XHRjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0XHRcdGNvbnN0IGltYWdlRmlsZSA9IHBhc3RlZERhdGEuZ2V0QXNGaWxlKCk7XG5cblx0XHRcdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHJlc3VsdCA9IGVkaXRvci5maXJlKCdiZWZvcmVJbWFnZUFkZCcsIHtcblx0XHRcdFx0XHRcdFx0aW1hZ2VGaWxlczogaW1hZ2VGaWxlLFxuXHRcdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZWwgPSBDS0VESVRPUi5kb20uZWxlbWVudC5jcmVhdGVGcm9tSHRtbChcblx0XHRcdFx0XHRcdFx0XHQnPGltZyBzcmM9XCInICsgZXZlbnQudGFyZ2V0LnJlc3VsdCArICdcIj4nXG5cdFx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdFx0ZWRpdG9yLmluc2VydEVsZW1lbnQoZWwpO1xuXG5cdFx0XHRcdFx0XHRcdGNvbnN0IGltYWdlRGF0YSA9IHtcblx0XHRcdFx0XHRcdFx0XHRlbCxcblx0XHRcdFx0XHRcdFx0XHRmaWxlOiBpbWFnZUZpbGUsXG5cdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0ZWRpdG9yLmZpcmUoJ2ltYWdlQWRkJywgaW1hZ2VEYXRhKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0cmVhZGVyLnJlYWRBc0RhdGFVUkwoaW1hZ2VGaWxlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdH0pO1xufVxuIiwiaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfcGxhY2Vob2xkZXInKSkge1xuXHQvKipcblx0ICogQ0tFRElUT1IgZW50ZXJNb2RlIGNvbmZpZyBzZXQgdGhlIGJlaGF2aW9yIG9mIHBhcmFncmFwaHNcblx0ICogV2hlbiB0aGUgY29udGVudCBpcyBlbXB0eSBDS0VESVRPUiBrZWVwcyB0aGUgZW50ZXJNb2RlIHN0cmluZ1xuXHQgKiBpbnRvIHRoZSBjb250ZW50XG5cdCAqIEBwcm9wZXJ0eVxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0Y29uc3QgYnJGaWxsZXIgPSBDS0VESVRPUi5lbnYubmVlZHNCckZpbGxlciA/ICc8YnI+JyA6ICcnO1xuXG5cdGNvbnN0IGVudGVyTW9kZUVtcHR5VmFsdWUgPSB7XG5cdFx0MTogWyc8cD4nICsgYnJGaWxsZXIgKyAnPC9wPiddLFxuXHRcdDI6IFsnJywgJyAnLCBickZpbGxlcl0sXG5cdFx0MzogWyc8ZGl2PicgKyBickZpbGxlciArICc8L2Rpdj4nXSxcblx0fTtcblxuXHQvKipcblx0ICogQ0tFZGl0b3IgcGx1Z2luIHdoaWNoIGFsbG93cyBhZGRpbmcgYSBwbGFjZWhvbGRlciB0byB0aGUgZWRpdG9yLiBJbiB0aGlzIGNhc2UsIGlmIHRoZXJlXG5cdCAqIGlzIG5vIGNvbnRlbnQgdG8gdGhlIGVkaXRvciwgdGhlcmUgd2lsbCBiZSBoaW50IHRvIHRoZSB1c2VyLlxuXHQgKlxuXHQgKiBAY2xhc3MgQ0tFRElUT1IucGx1Z2lucy5hZV9wbGFjZWhvbGRlclxuXHQgKi9cblxuXHQvKipcblx0ICogU3BlY2lmaWVzIHRoZSBwbGFjZWhvbGRlciBjbGFzcyB3aGljaCBoYXZlIHRvIGJlIGFkZWQgdG8gZWRpdG9yIHdoZW4gZWRpdG9yIGlzIG5vdCBmb2N1c2VkLlxuXHQgKlxuXHQgKiBAYXR0cmlidXRlIHBsYWNlaG9sZGVyQ2xhc3Ncblx0ICogQGRlZmF1bHQgYWVfcGxhY2Vob2xkZXJcblx0ICogQHR5cGUgU3RyaW5nXG5cdCAqL1xuXG5cdENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV9wbGFjZWhvbGRlcicsIHtcblx0XHQvKipcblx0XHQgKiBJbml0aWFsaXphdGlvbiBvZiB0aGUgcGx1Z2luLCBwYXJ0IG9mIENLRWRpdG9yIHBsdWdpbiBsaWZlY3ljbGUuXG5cdFx0ICogVGhlIGZ1bmN0aW9uIHJlZ2lzdGVycyBhICdibHVyJyBhbmQgJ2NvbnRlbnREb20nIGV2ZW50IGxpc3RlbmVycy5cblx0XHQgKlxuXHRcdCAqIEBtZXRob2QgaW5pdFxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBlZGl0b3IgVGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlXG5cdFx0ICovXG5cdFx0aW5pdChlZGl0b3IpIHtcblx0XHRcdGVkaXRvci5vbignYmx1cicsIHRoaXMuX2NoZWNrRW1wdHlEYXRhLCB0aGlzKTtcblx0XHRcdGVkaXRvci5vbignY2hhbmdlJywgdGhpcy5fY2hlY2tFbXB0eURhdGEsIHRoaXMpO1xuXHRcdFx0ZWRpdG9yLm9uKCdmb2N1cycsIHRoaXMuX3JlbW92ZVBsYWNlaG9sZGVyQ2xhc3MsIHRoaXMpO1xuXHRcdFx0ZWRpdG9yLm9uY2UoJ2NvbnRlbnREb20nLCB0aGlzLl9jaGVja0VtcHR5RGF0YSwgdGhpcyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJlbW92ZXMgYW55IGRhdGEgZnJvbSB0aGUgY29udGVudCBhbmQgYWRkcyBhIGNsYXNzLFxuXHRcdCAqIHNwZWNpZmllZCBieSB0aGUgXCJwbGFjZWhvbGRlckNsYXNzXCIgY29uZmlnIGF0dHJpYnV0ZS5cblx0XHQgKlxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKiBAbWV0aG9kIF9jaGVja0VtcHR5RGF0YVxuXHRcdCAqIEBwYXJhbSB7Q0tFRElUT1IuZG9tLmV2ZW50fSBlZGl0b3IgZXZlbnQsIGZpcmVkIGZyb20gQ0tFZGl0b3Jcblx0XHQgKi9cblx0XHRfY2hlY2tFbXB0eURhdGEoZXZlbnQpIHtcblx0XHRcdGNvbnN0IGVkaXRvciA9IGV2ZW50LmVkaXRvcjtcblxuXHRcdFx0Y29uc3QgZWRpdGFibGVOb2RlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdGNvbnN0IGlubmVySHRtbCA9IGVkaXRhYmxlTm9kZS4kLmlubmVySFRNTC50cmltKCk7XG5cblx0XHRcdGNvbnN0IGlzRW1wdHkgPSBlbnRlck1vZGVFbXB0eVZhbHVlW2VkaXRvci5jb25maWcuZW50ZXJNb2RlXS5zb21lKFxuXHRcdFx0XHRmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdFx0cmV0dXJuIGlubmVySHRtbCA9PT0gZWxlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKGlzRW1wdHkpIHtcblx0XHRcdFx0ZWRpdGFibGVOb2RlLmFkZENsYXNzKGVkaXRvci5jb25maWcucGxhY2Vob2xkZXJDbGFzcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlZGl0YWJsZU5vZGUucmVtb3ZlQ2xhc3MoZWRpdG9yLmNvbmZpZy5wbGFjZWhvbGRlckNsYXNzKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG4gICAgICAgICAgICAgKiBSZW1vdmUgcGxhY2Vob2xkZXIgY2xhc3Mgd2hlbiBpbnB1dCBpcyBmb2N1c2VkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgICAgICogQG1ldGhvZCBfcmVtb3ZlUGxhY2Vob2xkZXJDbGFzc1xuICAgICAgICAgICAgICsgQHBhcmFtIHtDS0VESVRPUi5kb20uZXZlbnR9IGVkaXRvciBldmVudCwgZmlyZWQgZnJvbSBDS0VkaXRvclxuICAgICAgICAgICAgICovXG5cdFx0X3JlbW92ZVBsYWNlaG9sZGVyQ2xhc3MoZXZlbnQpIHtcblx0XHRcdGNvbnN0IGVkaXRvciA9IGV2ZW50LmVkaXRvcjtcblxuXHRcdFx0Y29uc3QgZWRpdG9yTm9kZSA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChlZGl0b3IuZWxlbWVudC4kKTtcblxuXHRcdFx0ZWRpdG9yTm9kZS5yZW1vdmVDbGFzcyhlZGl0b3IuY29uZmlnLnBsYWNlaG9sZGVyQ2xhc3MpO1xuXHRcdH0sXG5cdH0pO1xufVxuIiwiLyoqXG4gKiBQcmlvcml0aWVzIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29udHJvbCB0aGUgb3JkZXIgaW4gd2hpY2ggZXZlbnQgaGFuZGxlcnMgcnVuLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9ja2VkaXRvci5jb20vZG9jcy9ja2VkaXRvcjQvbGF0ZXN0L2FwaS9DS0VESVRPUl9ldmVudC5odG1sI21ldGhvZC1vblxuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9QUklPUklUWSA9IDEwO1xuZXhwb3J0IGNvbnN0IEhJR0hfUFJJT1JJVFkgPSA1O1xuIiwiaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfc2VsZWN0aW9ua2V5c3Ryb2tlcycpKSB7XG5cdC8qKlxuXHQgKiBDS0VkaXRvciBwbHVnaW4gdGhhdCBzaW11bGF0ZXMgZWRpdG9yIGludGVyYWN0aW9uIGV2ZW50cyBiYXNlZCBvbiBtYW51YWwga2V5c3Ryb2tlcy4gVGhpc1xuXHQgKiBjYW4gYmUgdXNlZCB0byB0cmlnZ2VyIGRpZmZlcmVudCByZWFjdGlvbnMgaW4gdGhlIGVkaXRvci5cblx0ICpcblx0ICogQGNsYXNzIENLRURJVE9SLnBsdWdpbnMuYWVfc2VsZWN0aW9ua2V5c3Ryb2tlc1xuXHQgKi9cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3NlbGVjdGlvbmtleXN0cm9rZXMnLCB7XG5cdFx0cmVxdWlyZXM6ICdhZV9zZWxlY3Rpb25yZWdpb24nLFxuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6YXRpb24gb2YgdGhlIHBsdWdpbiwgcGFydCBvZiBDS0VkaXRvciBwbHVnaW4gbGlmZWN5Y2xlLlxuXHRcdCAqIFRoZSBmdW5jdGlvbiBhZGRzIGEgY29tbWFuZCB0byB0aGUgZWRpdG9yIGZvciBldmVyeSBkZWZpbmVkIHNlbGVjdGlvbktleXN0cm9rZVxuXHRcdCAqIGluIHRoZSBjb25maWd1cmF0aW9uIGFuZCBtYXBzIGl0IHRvIHRoZSBzcGVjaWZpZWQga2V5c3Ryb2tlLlxuXHRcdCAqXG5cdFx0ICogQG1ldGhvZCBpbml0XG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGVkaXRvciBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2Vcblx0XHQgKi9cblx0XHRpbml0KGVkaXRvcikge1xuXHRcdFx0aWYgKGVkaXRvci5jb25maWcuc2VsZWN0aW9uS2V5c3Ryb2tlcykge1xuXHRcdFx0XHRlZGl0b3IuY29uZmlnLnNlbGVjdGlvbktleXN0cm9rZXMuZm9yRWFjaChmdW5jdGlvbihcblx0XHRcdFx0XHRzZWxlY3Rpb25LZXlzdHJva2Vcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Y29uc3QgY29tbWFuZCA9IG5ldyBDS0VESVRPUi5jb21tYW5kKGVkaXRvciwge1xuXHRcdFx0XHRcdFx0ZXhlYyhlZGl0b3IpIHtcblx0XHRcdFx0XHRcdFx0ZWRpdG9yLmZpcmUoJ2VkaXRvckludGVyYWN0aW9uJywge1xuXHRcdFx0XHRcdFx0XHRcdG1hbnVhbFNlbGVjdGlvbjogc2VsZWN0aW9uS2V5c3Ryb2tlLnNlbGVjdGlvbixcblx0XHRcdFx0XHRcdFx0XHRuYXRpdmVFdmVudDoge30sXG5cdFx0XHRcdFx0XHRcdFx0c2VsZWN0aW9uRGF0YTogZWRpdG9yLmdldFNlbGVjdGlvbkRhdGEoKSxcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0Y29uc3QgY29tbWFuZE5hbWUgPVxuXHRcdFx0XHRcdFx0J3NlbGVjdGlvbktleXN0cm9rZScgKyBzZWxlY3Rpb25LZXlzdHJva2Uuc2VsZWN0aW9uO1xuXG5cdFx0XHRcdFx0ZWRpdG9yLmFkZENvbW1hbmQoY29tbWFuZE5hbWUsIGNvbW1hbmQpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRLZXlzdHJva2Uoc2VsZWN0aW9uS2V5c3Ryb2tlLmtleXMsIGNvbW1hbmROYW1lKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE1LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cDovL2NrZWRpdG9yLmNvbS9saWNlbnNlXG4gKi9cblxuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfdGFibGVyZXNpemUnKSkge1xuXHRjb25zdCBweFVuaXQgPSBDS0VESVRPUi50b29scy5jc3NMZW5ndGg7XG5cblx0ZnVuY3Rpb24gZ2V0V2lkdGgoZWwpIHtcblx0XHRyZXR1cm4gQ0tFRElUT1IuZW52LmllXG5cdFx0XHQ/IGVsLiQuY2xpZW50V2lkdGhcblx0XHRcdDogcGFyc2VJbnQoZWwuZ2V0Q29tcHV0ZWRTdHlsZSgnd2lkdGgnKSwgMTApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Qm9yZGVyV2lkdGgoZWxlbWVudCwgc2lkZSkge1xuXHRcdGxldCBjb21wdXRlZCA9IGVsZW1lbnQuZ2V0Q29tcHV0ZWRTdHlsZSgnYm9yZGVyLScgKyBzaWRlICsgJy13aWR0aCcpO1xuXG5cdFx0Y29uc3QgYm9yZGVyTWFwID0ge1xuXHRcdFx0dGhpbjogJzBweCcsXG5cdFx0XHRtZWRpdW06ICcxcHgnLFxuXHRcdFx0dGhpY2s6ICcycHgnLFxuXHRcdH07XG5cblx0XHRpZiAoY29tcHV0ZWQuaW5kZXhPZigncHgnKSA8IDApIHtcblx0XHRcdC8vIGxvb2sgdXAga2V5d29yZHNcblx0XHRcdGlmIChcblx0XHRcdFx0Y29tcHV0ZWQgaW4gYm9yZGVyTWFwICYmXG5cdFx0XHRcdGVsZW1lbnQuZ2V0Q29tcHV0ZWRTdHlsZSgnYm9yZGVyLXN0eWxlJykgIT0gJ25vbmUnXG5cdFx0XHQpIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBib3JkZXJNYXBbY29tcHV0ZWRdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBwYXJzZUludChjb21wdXRlZCwgMTApO1xuXHR9XG5cblx0Ly8gR2V0cyB0aGUgdGFibGUgcm93IHRoYXQgY29udGFpbnMgdGhlIG1vc3QgY29sdW1ucy5cblx0ZnVuY3Rpb24gZ2V0TWFzdGVyUGlsbGFyUm93KHRhYmxlKSB7XG5cdFx0Y29uc3QgJHJvd3MgPSB0YWJsZS4kLnJvd3M7XG5cblx0XHRsZXQgbWF4Q2VsbHMgPSAwO1xuXG5cdFx0bGV0IGNlbGxzQ291bnQ7XG5cblx0XHRsZXQgJGVsZWN0ZWQ7XG5cblx0XHRsZXQgJHRyO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDAsIGxlbiA9ICRyb3dzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHQkdHIgPSAkcm93c1tpXTtcblx0XHRcdGNlbGxzQ291bnQgPSAkdHIuY2VsbHMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoY2VsbHNDb3VudCA+IG1heENlbGxzKSB7XG5cdFx0XHRcdG1heENlbGxzID0gY2VsbHNDb3VudDtcblx0XHRcdFx0JGVsZWN0ZWQgPSAkdHI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuICRlbGVjdGVkO1xuXHR9XG5cblx0ZnVuY3Rpb24gYnVpbGRUYWJsZUNvbHVtblBpbGxhcnModGFibGUpIHtcblx0XHRjb25zdCBwaWxsYXJzID0gW107XG5cblx0XHRsZXQgcGlsbGFySW5kZXggPSAtMTtcblxuXHRcdGNvbnN0IHJ0bCA9IHRhYmxlLmdldENvbXB1dGVkU3R5bGUoJ2RpcmVjdGlvbicpID09PSAncnRsJztcblxuXHRcdC8vIEdldCB0aGUgcmF3IHJvdyBlbGVtZW50IHRoYXQgY29pbnRhaW5zIHRoZSBtb3N0IGNvbHVtbnMuXG5cdFx0Y29uc3QgJHRyID0gZ2V0TWFzdGVyUGlsbGFyUm93KHRhYmxlKTtcblxuXHRcdC8vIEdldCB0aGUgdGJvZHkgZWxlbWVudCBhbmQgcG9zaXRpb24sIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBzZXQgdGhlXG5cdFx0Ly8gdG9wIGFuZCBib3R0b20gYm91bmRhcmllcy5cblx0XHRjb25zdCB0Ym9keSA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCh0YWJsZS4kLnRCb2RpZXNbMF0pO1xuXG5cdFx0Y29uc3QgdGJvZHlQb3NpdGlvbiA9IHRib2R5LmdldERvY3VtZW50UG9zaXRpb24oKTtcblxuXHRcdC8vIExvb3AgdGhvcnVnaCBhbGwgY2VsbHMsIGJ1aWxkaW5nIHBpbGxhcnMgYWZ0ZXIgZWFjaCBvbmUgb2YgdGhlbS5cblx0XHRmb3IgKGxldCBpID0gMCwgbGVuID0gJHRyLmNlbGxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHQvLyBCb3RoIHRoZSBjdXJyZW50IGNlbGwgYW5kIHRoZSBzdWNjZXNzaXZlIG9uZSB3aWxsIGJlIHVzZWQgaW4gdGhlXG5cdFx0XHQvLyBwaWxsYXIgc2l6ZSBjYWxjdWxhdGlvbi5cblx0XHRcdGNvbnN0IHRkID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCR0ci5jZWxsc1tpXSk7XG5cblx0XHRcdGNvbnN0IG5leHRUZCA9XG5cdFx0XHRcdCR0ci5jZWxsc1tpICsgMV0gJiYgbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KCR0ci5jZWxsc1tpICsgMV0pO1xuXG5cdFx0XHRwaWxsYXJJbmRleCArPSB0ZC4kLmNvbFNwYW4gfHwgMTtcblxuXHRcdFx0Ly8gQ2FsY3VsYXRlIHRoZSBwaWxsYXIgYm91bmRhcnkgcG9zaXRpb25zLlxuXHRcdFx0bGV0IHBpbGxhckxlZnQ7XG5cdFx0XHRsZXQgcGlsbGFyUmlnaHQ7XG5cblx0XHRcdGxldCB4ID0gdGQuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLng7XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbnMgYmFzZWQgb24gdGhlIGN1cnJlbnQgY2VsbC5cblx0XHRcdGlmIChydGwpIHtcblx0XHRcdFx0cGlsbGFyUmlnaHQgPSB4ICsgZ2V0Qm9yZGVyV2lkdGgodGQsICdsZWZ0Jyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwaWxsYXJMZWZ0ID0geCArIHRkLiQub2Zmc2V0V2lkdGggLSBnZXRCb3JkZXJXaWR0aCh0ZCwgJ3JpZ2h0Jyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbnMgYmFzZWQgb24gdGhlIG5leHQgY2VsbCwgaWYgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKG5leHRUZCkge1xuXHRcdFx0XHR4ID0gbmV4dFRkLmdldERvY3VtZW50UG9zaXRpb24oKS54O1xuXG5cdFx0XHRcdGlmIChydGwpIHtcblx0XHRcdFx0XHRwaWxsYXJMZWZ0ID1cblx0XHRcdFx0XHRcdHggK1xuXHRcdFx0XHRcdFx0bmV4dFRkLiQub2Zmc2V0V2lkdGggLVxuXHRcdFx0XHRcdFx0Z2V0Qm9yZGVyV2lkdGgobmV4dFRkLCAncmlnaHQnKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwaWxsYXJSaWdodCA9IHggKyBnZXRCb3JkZXJXaWR0aChuZXh0VGQsICdsZWZ0Jyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIE90aGVyd2lzZSBjYWxjdWxhdGUgcG9zaXRpb25zIGJhc2VkIG9uIHRoZSB0YWJsZSAoZm9yIGxhc3QgY2VsbCkuXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0eCA9IHRhYmxlLmdldERvY3VtZW50UG9zaXRpb24oKS54O1xuXG5cdFx0XHRcdGlmIChydGwpIHtcblx0XHRcdFx0XHRwaWxsYXJMZWZ0ID0geDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwaWxsYXJSaWdodCA9IHggKyB0YWJsZS4kLm9mZnNldFdpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHBpbGxhcldpZHRoID0gTWF0aC5tYXgocGlsbGFyUmlnaHQgLSBwaWxsYXJMZWZ0LCA0KTtcblxuXHRcdFx0Ly8gVGhlIHBpbGxhciBzaG91bGQgcmVmbGVjdHMgZXhhY3RseSB0aGUgc2hhcGUgb2YgdGhlIGhvdmVyZWRcblx0XHRcdC8vIGNvbHVtbiBib3JkZXIgbGluZS5cblx0XHRcdHBpbGxhcnMucHVzaCh7XG5cdFx0XHRcdHRhYmxlLFxuXHRcdFx0XHRpbmRleDogcGlsbGFySW5kZXgsXG5cdFx0XHRcdHg6IHBpbGxhckxlZnQsXG5cdFx0XHRcdHk6IHRib2R5UG9zaXRpb24ueSxcblx0XHRcdFx0d2lkdGg6IHBpbGxhcldpZHRoLFxuXHRcdFx0XHRoZWlnaHQ6IHRib2R5LiQub2Zmc2V0SGVpZ2h0LFxuXHRcdFx0XHRydGwsXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGlsbGFycztcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFBpbGxhckF0UG9zaXRpb24ocGlsbGFycywgcG9zaXRpb25YKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGxlbiA9IHBpbGxhcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGNvbnN0IHBpbGxhciA9IHBpbGxhcnNbaV07XG5cblx0XHRcdGlmIChwb3NpdGlvblggPj0gcGlsbGFyLnggJiYgcG9zaXRpb25YIDw9IHBpbGxhci54ICsgcGlsbGFyLndpZHRoKSB7XG5cdFx0XHRcdHJldHVybiBwaWxsYXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBjYW5jZWwoZXZ0KSB7XG5cdFx0KGV2dC5kYXRhIHx8IGV2dCkucHJldmVudERlZmF1bHQoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIENvbHVtblJlc2l6ZXIoZWRpdG9yLCBwaWxsYXIpIHtcblx0XHRsZXQgY3VycmVudFNoaWZ0O1xuXHRcdGxldCBsZWZ0U2hpZnRCb3VuZGFyeTtcblx0XHRsZXQgbGVmdFNpZGVDZWxscztcblx0XHRsZXQgcmVzaXppbmc7XG5cdFx0bGV0IHJpZ2h0U2hpZnRCb3VuZGFyeTtcblx0XHRsZXQgcmlnaHRTaWRlQ2VsbHM7XG5cdFx0bGV0IHN0YXJ0T2Zmc2V0O1xuXG5cdFx0Y29uc3QgZG9jdW1lbnQgPSBlZGl0b3IuZG9jdW1lbnQ7XG5cblx0XHRjb25zdCByZXNpemVyID0gQ0tFRElUT1IuZG9tLmVsZW1lbnQuY3JlYXRlRnJvbUh0bWwoXG5cdFx0XHQnPGRpdiBkYXRhLWNrZS10ZW1wPTEgY29udGVudGVkaXRhYmxlPWZhbHNlIHVuc2VsZWN0YWJsZT1vbiAnICtcblx0XHRcdFx0J3N0eWxlPVwicG9zaXRpb246YWJzb2x1dGU7Y3Vyc29yOmNvbC1yZXNpemU7ZmlsdGVyOmFscGhhKG9wYWNpdHk9MCk7b3BhY2l0eTowOycgK1xuXHRcdFx0XHQncGFkZGluZzowO2JhY2tncm91bmQtY29sb3I6IzAwNDtiYWNrZ3JvdW5kLWltYWdlOm5vbmU7Ym9yZGVyOjBweCBub25lO3otaW5kZXg6MTBcIj48L2Rpdj4nLFxuXHRcdFx0ZG9jdW1lbnRcblx0XHQpO1xuXG5cdFx0Y29uc3QgaXNSZXNpemluZyA9ICh0aGlzLmlzUmVzaXppbmcgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiByZXNpemluZztcblx0XHR9KTtcblxuXHRcdGNvbnN0IG1vdmUgPSAodGhpcy5tb3ZlID0gZnVuY3Rpb24ocG9zWCkge1xuXHRcdFx0bGV0IHJlc2l6ZXJOZXdQb3NpdGlvbiA9XG5cdFx0XHRcdHBvc1ggLSBNYXRoLnJvdW5kKHJlc2l6ZXIuJC5vZmZzZXRXaWR0aCAvIDIpO1xuXG5cdFx0XHRpZiAoaXNSZXNpemluZykge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmVzaXplck5ld1Bvc2l0aW9uID09PSBsZWZ0U2hpZnRCb3VuZGFyeSB8fFxuXHRcdFx0XHRcdHJlc2l6ZXJOZXdQb3NpdGlvbiA9PT0gcmlnaHRTaGlmdEJvdW5kYXJ5XG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc2l6ZXJOZXdQb3NpdGlvbiA9IE1hdGgubWF4KFxuXHRcdFx0XHRcdHJlc2l6ZXJOZXdQb3NpdGlvbixcblx0XHRcdFx0XHRsZWZ0U2hpZnRCb3VuZGFyeVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRyZXNpemVyTmV3UG9zaXRpb24gPSBNYXRoLm1pbihcblx0XHRcdFx0XHRyZXNpemVyTmV3UG9zaXRpb24sXG5cdFx0XHRcdFx0cmlnaHRTaGlmdEJvdW5kYXJ5XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Y3VycmVudFNoaWZ0ID0gcmVzaXplck5ld1Bvc2l0aW9uIC0gc3RhcnRPZmZzZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJlc2l6ZXIuc2V0U3R5bGUoJ2xlZnQnLCBweFVuaXQocmVzaXplck5ld1Bvc2l0aW9uKSk7XG5cdFx0fSk7XG5cblx0XHRmdW5jdGlvbiBkZXRhY2goKSB7XG5cdFx0XHRyZXNpemVyLnJlbW92ZUxpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcblx0XHRcdHJlc2l6ZXIucmVtb3ZlTGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcblx0XHRcdHJlc2l6ZXIucmVtb3ZlTGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXNpemVTdGFydCgpIHtcblx0XHRcdC8vIEJlZm9yZSBzdGFydGluZyB0byByZXNpemUsIGZpZ3VyZSBvdXQgd2hpY2ggY2VsbHMgdG8gY2hhbmdlXG5cdFx0XHQvLyBhbmQgdGhlIGJvdW5kYXJpZXMgb2YgdGhpcyByZXNpemluZyBzaGlmdC5cblxuXHRcdFx0Y29uc3QgY29sdW1uSW5kZXggPSBwaWxsYXIuaW5kZXg7XG5cblx0XHRcdGNvbnN0IG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAocGlsbGFyLnRhYmxlKTtcblxuXHRcdFx0Y29uc3QgbGVmdENvbHVtbkNlbGxzID0gW107XG5cblx0XHRcdGNvbnN0IHJpZ2h0Q29sdW1uQ2VsbHMgPSBbXTtcblxuXHRcdFx0bGV0IGxlZnRNaW5TaXplID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuXHRcdFx0bGV0IHJpZ2h0TWluU2l6ZSA9IGxlZnRNaW5TaXplO1xuXG5cdFx0XHRjb25zdCBydGwgPSBwaWxsYXIucnRsO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbGVuID0gbWFwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHJvdyA9IG1hcFtpXTtcblxuXHRcdFx0XHRsZXQgbGVmdENlbGwgPSByb3dbY29sdW1uSW5kZXggKyAocnRsID8gMSA6IDApXTtcblxuXHRcdFx0XHRsZXQgcmlnaHRDZWxsID0gcm93W2NvbHVtbkluZGV4ICsgKHJ0bCA/IDAgOiAxKV07XG5cblx0XHRcdFx0bGVmdENlbGwgPSBsZWZ0Q2VsbCAmJiBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQobGVmdENlbGwpO1xuXHRcdFx0XHRyaWdodENlbGwgPSByaWdodENlbGwgJiYgbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHJpZ2h0Q2VsbCk7XG5cblx0XHRcdFx0aWYgKCFsZWZ0Q2VsbCB8fCAhcmlnaHRDZWxsIHx8ICFsZWZ0Q2VsbC5lcXVhbHMocmlnaHRDZWxsKSkge1xuXHRcdFx0XHRcdGlmIChsZWZ0Q2VsbCkge1xuXHRcdFx0XHRcdFx0bGVmdE1pblNpemUgPSBNYXRoLm1pbihsZWZ0TWluU2l6ZSwgZ2V0V2lkdGgobGVmdENlbGwpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHJpZ2h0Q2VsbCkge1xuXHRcdFx0XHRcdFx0cmlnaHRNaW5TaXplID0gTWF0aC5taW4oXG5cdFx0XHRcdFx0XHRcdHJpZ2h0TWluU2l6ZSxcblx0XHRcdFx0XHRcdFx0Z2V0V2lkdGgocmlnaHRDZWxsKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsZWZ0Q29sdW1uQ2VsbHMucHVzaChsZWZ0Q2VsbCk7XG5cdFx0XHRcdFx0cmlnaHRDb2x1bW5DZWxscy5wdXNoKHJpZ2h0Q2VsbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FjaGUgdGhlIGxpc3Qgb2YgY2VsbHMgdG8gYmUgcmVzaXplZC5cblx0XHRcdGxlZnRTaWRlQ2VsbHMgPSBsZWZ0Q29sdW1uQ2VsbHM7XG5cdFx0XHRyaWdodFNpZGVDZWxscyA9IHJpZ2h0Q29sdW1uQ2VsbHM7XG5cblx0XHRcdC8vIENhY2hlIHRoZSByZXNpemUgbGltaXQgYm91bmRhcmllcy5cblx0XHRcdGxlZnRTaGlmdEJvdW5kYXJ5ID0gcGlsbGFyLnggLSBsZWZ0TWluU2l6ZTtcblx0XHRcdHJpZ2h0U2hpZnRCb3VuZGFyeSA9IHBpbGxhci54ICsgcmlnaHRNaW5TaXplO1xuXG5cdFx0XHRyZXNpemVyLnNldE9wYWNpdHkoMC41KTtcblx0XHRcdHN0YXJ0T2Zmc2V0ID0gcGFyc2VJbnQocmVzaXplci5nZXRTdHlsZSgnbGVmdCcpLCAxMCk7XG5cdFx0XHRjdXJyZW50U2hpZnQgPSAwO1xuXHRcdFx0cmVzaXppbmcgPSAxO1xuXG5cdFx0XHRyZXNpemVyLm9uKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG5cblx0XHRcdC8vIFByZXZlbnQgdGhlIG5hdGl2ZSBkcmFnIGJlaGF2aW9yIG90aGVyd2lzZSAnbW91c2Vtb3ZlJyB3b24ndCBmaXJlLlxuXHRcdFx0ZG9jdW1lbnQub24oJ2RyYWdzdGFydCcsIGNhbmNlbCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzaXplRW5kKCkge1xuXHRcdFx0cmVzaXppbmcgPSAwO1xuXG5cdFx0XHRyZXNpemVyLnNldE9wYWNpdHkoMCk7XG5cblx0XHRcdGlmIChjdXJyZW50U2hpZnQpIHtcblx0XHRcdFx0cmVzaXplQ29sdW1uKCk7XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHRhYmxlID0gcGlsbGFyLnRhYmxlO1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0dGFibGUucmVtb3ZlQ3VzdG9tRGF0YSgnX2NrZV90YWJsZV9waWxsYXJzJyk7XG5cdFx0XHR9LCAwKTtcblxuXHRcdFx0ZG9jdW1lbnQucmVtb3ZlTGlzdGVuZXIoJ2RyYWdzdGFydCcsIGNhbmNlbCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzaXplQ29sdW1uKCkge1xuXHRcdFx0Y29uc3QgcnRsID0gcGlsbGFyLnJ0bDtcblxuXHRcdFx0Y29uc3QgY2VsbHNDb3VudCA9IHJ0bFxuXHRcdFx0XHQ/IHJpZ2h0U2lkZUNlbGxzLmxlbmd0aFxuXHRcdFx0XHQ6IGxlZnRTaWRlQ2VsbHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBQZXJmb3JtIHRoZSBhY3R1YWwgcmVzaXplIHRvIHRhYmxlIGNlbGxzLCBvbmx5IGZvciB0aG9zZSBieSBzaWRlIG9mIHRoZSBwaWxsYXIuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxzQ291bnQ7IGkrKykge1xuXHRcdFx0XHRjb25zdCBsZWZ0Q2VsbCA9IGxlZnRTaWRlQ2VsbHNbaV07XG5cblx0XHRcdFx0Y29uc3QgcmlnaHRDZWxsID0gcmlnaHRTaWRlQ2VsbHNbaV07XG5cblx0XHRcdFx0Y29uc3QgdGFibGUgPSBwaWxsYXIudGFibGU7XG5cblx0XHRcdFx0Ly8gRGVmZXIgdGhlIHJlc2l6aW5nIHRvIGF2b2lkIGFueSBpbnRlcmZlcmVuY2UgYW1vbmcgY2VsbHMuXG5cdFx0XHRcdENLRURJVE9SLnRvb2xzLnNldFRpbWVvdXQoXG5cdFx0XHRcdFx0ZnVuY3Rpb24oXG5cdFx0XHRcdFx0XHRsZWZ0Q2VsbCxcblx0XHRcdFx0XHRcdGxlZnRPbGRXaWR0aCxcblx0XHRcdFx0XHRcdHJpZ2h0Q2VsbCxcblx0XHRcdFx0XHRcdHJpZ2h0T2xkV2lkdGgsXG5cdFx0XHRcdFx0XHR0YWJsZVdpZHRoLFxuXHRcdFx0XHRcdFx0c2l6ZVNoaWZ0XG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHQvLyAxcHggaXMgdGhlIG1pbmltdW0gdmFsaWQgd2lkdGggKCMxMTYyNikuXG5cdFx0XHRcdFx0XHRpZiAobGVmdENlbGwpIHtcblx0XHRcdFx0XHRcdFx0bGVmdENlbGwuc2V0U3R5bGUoXG5cdFx0XHRcdFx0XHRcdFx0J3dpZHRoJyxcblx0XHRcdFx0XHRcdFx0XHRweFVuaXQoTWF0aC5tYXgobGVmdE9sZFdpZHRoICsgc2l6ZVNoaWZ0LCAxKSlcblx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChyaWdodENlbGwpIHtcblx0XHRcdFx0XHRcdFx0cmlnaHRDZWxsLnNldFN0eWxlKFxuXHRcdFx0XHRcdFx0XHRcdCd3aWR0aCcsXG5cdFx0XHRcdFx0XHRcdFx0cHhVbml0KE1hdGgubWF4KHJpZ2h0T2xkV2lkdGggLSBzaXplU2hpZnQsIDEpKVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJZiB3ZSdyZSBpbiB0aGUgbGFzdCBjZWxsLCB3ZSBuZWVkIHRvIHJlc2l6ZSB0aGUgdGFibGUgYXMgd2VsbFxuXHRcdFx0XHRcdFx0aWYgKHRhYmxlV2lkdGgpIHtcblx0XHRcdFx0XHRcdFx0dGFibGUuc2V0U3R5bGUoXG5cdFx0XHRcdFx0XHRcdFx0J3dpZHRoJyxcblx0XHRcdFx0XHRcdFx0XHRweFVuaXQodGFibGVXaWR0aCArIHNpemVTaGlmdCAqIChydGwgPyAtMSA6IDEpKVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdFtcblx0XHRcdFx0XHRcdGxlZnRDZWxsLFxuXHRcdFx0XHRcdFx0bGVmdENlbGwgJiYgZ2V0V2lkdGgobGVmdENlbGwpLFxuXHRcdFx0XHRcdFx0cmlnaHRDZWxsLFxuXHRcdFx0XHRcdFx0cmlnaHRDZWxsICYmIGdldFdpZHRoKHJpZ2h0Q2VsbCksXG5cdFx0XHRcdFx0XHQoIWxlZnRDZWxsIHx8ICFyaWdodENlbGwpICYmXG5cdFx0XHRcdFx0XHRcdGdldFdpZHRoKHRhYmxlKSArXG5cdFx0XHRcdFx0XHRcdFx0Z2V0Qm9yZGVyV2lkdGgodGFibGUsICdsZWZ0JykgK1xuXHRcdFx0XHRcdFx0XHRcdGdldEJvcmRlcldpZHRoKHRhYmxlLCAncmlnaHQnKSxcblx0XHRcdFx0XHRcdGN1cnJlbnRTaGlmdCxcblx0XHRcdFx0XHRdXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Nb3VzZURvd24oZXZ0KSB7XG5cdFx0XHRjYW5jZWwoZXZ0KTtcblxuXHRcdFx0cmVzaXplU3RhcnQoKTtcblxuXHRcdFx0ZG9jdW1lbnQub24oJ21vdXNldXAnLCBvbk1vdXNlVXAsIHRoaXMpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uTW91c2VVcChldnQpIHtcblx0XHRcdGV2dC5yZW1vdmVMaXN0ZW5lcigpO1xuXG5cdFx0XHRyZXNpemVFbmQoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbk1vdXNlTW92ZShldnQpIHtcblx0XHRcdG1vdmUoZXZ0LmRhdGEuZ2V0UGFnZU9mZnNldCgpLngpO1xuXHRcdH1cblxuXHRcdC8vIENsZWFuIERPTSB3aGVuIGVkaXRvciBpcyBkZXN0cm95ZWQuXG5cdFx0ZWRpdG9yLm9uKCdkZXN0cm95JywgZnVuY3Rpb24oKSB7XG5cdFx0XHRkZXRhY2goKTtcblxuXHRcdFx0cmVzaXplci5yZW1vdmUoKTtcblx0XHR9KTtcblxuXHRcdC8vIFBsYWNlIHRoZSByZXNpemVyIGFmdGVyIGJvZHkgdG8gcHJldmVudCBpdFxuXHRcdC8vIGZyb20gYmVpbmcgZWRpdGFibGUuXG5cdFx0ZG9jdW1lbnQuZ2V0RG9jdW1lbnRFbGVtZW50KCkuYXBwZW5kKHJlc2l6ZXIpO1xuXG5cdFx0cmVzaXplci5zZXRTdHlsZXMoe1xuXHRcdFx0d2lkdGg6IHB4VW5pdChwaWxsYXIud2lkdGgpLFxuXHRcdFx0aGVpZ2h0OiBweFVuaXQocGlsbGFyLmhlaWdodCksXG5cdFx0XHRsZWZ0OiBweFVuaXQocGlsbGFyLngpLFxuXHRcdFx0dG9wOiBweFVuaXQocGlsbGFyLnkpLFxuXHRcdH0pO1xuXG5cdFx0cmVzaXplci5vbignbW91c2Vkb3duJywgb25Nb3VzZURvd24sIHRoaXMpO1xuXG5cdFx0ZG9jdW1lbnQuZ2V0Qm9keSgpLnNldFN0eWxlKCdjdXJzb3InLCAnY29sLXJlc2l6ZScpO1xuXG5cdFx0Ly8gRGlzcGxheSB0aGUgcmVzaXplciB0byByZWNlaXZlIGV2ZW50cyBidXQgZG9uJ3Qgc2hvdyBpdCxcblx0XHQvLyBvbmx5IGNoYW5nZSB0aGUgY3Vyc29yIHRvIHJlc2l6YWJsZSBzaGFwZS5cblx0XHRyZXNpemVyLnNob3coKTtcblxuXHRcdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGV0YWNoKCk7XG5cblx0XHRcdGRvY3VtZW50LmdldEJvZHkoKS5zZXRTdHlsZSgnY3Vyc29yJywgJ2F1dG8nKTtcblxuXHRcdFx0cmVzaXplci5yZW1vdmUoKTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2xlYXJQaWxsYXJzQ2FjaGUoZXZ0KSB7XG5cdFx0Y29uc3QgdGFyZ2V0ID0gZXZ0LmRhdGEuZ2V0VGFyZ2V0KCk7XG5cblx0XHRpZiAoZXZ0Lm5hbWUgPT09ICdtb3VzZW91dCcpIHtcblx0XHRcdC8vIEJ5cGFzcyBpbnRlcmFsIG1vdXNlIG1vdmUuXG5cdFx0XHRpZiAoIXRhcmdldC5pcygndGFibGUnKSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGxldCBkZXN0ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KFxuXHRcdFx0XHRldnQuZGF0YS4kLnJlbGF0ZWRUYXJnZXQgfHwgZXZ0LmRhdGEuJC50b0VsZW1lbnRcblx0XHRcdCk7XG5cdFx0XHR3aGlsZSAoZGVzdCAmJiBkZXN0LiQgJiYgIWRlc3QuZXF1YWxzKHRhcmdldCkgJiYgIWRlc3QuaXMoJ2JvZHknKSkge1xuXHRcdFx0XHRkZXN0ID0gZGVzdC5nZXRQYXJlbnQoKTtcblx0XHRcdH1cblx0XHRcdGlmICghZGVzdCB8fCBkZXN0LmVxdWFscyh0YXJnZXQpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0YXJnZXQuZ2V0QXNjZW5kYW50KCd0YWJsZScsIDEpLnJlbW92ZUN1c3RvbURhdGEoJ19ja2VfdGFibGVfcGlsbGFycycpO1xuXHRcdGV2dC5yZW1vdmVMaXN0ZW5lcigpO1xuXHR9XG5cblx0Q0tFRElUT1IucGx1Z2lucy5hZGQoJ2FlX3RhYmxlcmVzaXplJywge1xuXHRcdHJlcXVpcmVzOiAnYWVfdGFibGV0b29scycsXG5cblx0XHRpbml0KGVkaXRvcikge1xuXHRcdFx0ZWRpdG9yLm9uKCdjb250ZW50RG9tJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxldCByZXNpemVyO1xuXG5cdFx0XHRcdGNvbnN0IGVkaXRhYmxlID0gZWRpdG9yLmVkaXRhYmxlKCk7XG5cblx0XHRcdFx0Ly8gSW4gQ2xhc3NpYyBlZGl0b3IgaXQgaXMgYmV0dGVyIHRvIHVzZSBkb2N1bWVudFxuXHRcdFx0XHQvLyBpbnN0ZWFkIG9mIGVkaXRhYmxlIHNvIGV2ZW50IHdpbGwgd29yayBiZWxvdyBib2R5LlxuXHRcdFx0XHRlZGl0YWJsZS5hdHRhY2hMaXN0ZW5lcihcblx0XHRcdFx0XHRlZGl0YWJsZS5pc0lubGluZSgpID8gZWRpdGFibGUgOiBlZGl0b3IuZG9jdW1lbnQsXG5cdFx0XHRcdFx0J21vdXNlbW92ZScsXG5cdFx0XHRcdFx0ZnVuY3Rpb24oZXZ0KSB7XG5cdFx0XHRcdFx0XHRldnQgPSBldnQuZGF0YTtcblxuXHRcdFx0XHRcdFx0Y29uc3QgdGFyZ2V0ID0gZXZ0LmdldFRhcmdldCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBGRiBtYXkgcmV0dXJuIGRvY3VtZW50IGFuZCBJRTggc29tZSBVRk8gKG9iamVjdCB3aXRoIG5vIG5vZGVUeXBlIHByb3BlcnR5Li4uKVxuXHRcdFx0XHRcdFx0Ly8gaW5zdGVhZCBvZiBhbiBlbGVtZW50ICgjMTE4MjMpLlxuXHRcdFx0XHRcdFx0aWYgKHRhcmdldC50eXBlICE9PSBDS0VESVRPUi5OT0RFX0VMRU1FTlQpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb25zdCBwYWdlWCA9IGV2dC5nZXRQYWdlT2Zmc2V0KCkueDtcblxuXHRcdFx0XHRcdFx0Ly8gSWYgd2UncmUgYWxyZWFkeSBhdHRhY2hlZCB0byBhIHBpbGxhciwgc2ltcGx5IG1vdmUgdGhlXG5cdFx0XHRcdFx0XHQvLyByZXNpemVyLlxuXHRcdFx0XHRcdFx0aWYgKHJlc2l6ZXIpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHJlc2l6ZXIuaXNSZXNpemluZygpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzaXplci5tb3ZlKHBhZ2VYKTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhbmNlbChldnQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHJlc2l6ZXIuZGVzdHJveSgpO1xuXG5cdFx0XHRcdFx0XHRcdFx0cmVzaXplciA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gQ29uc2lkZXJpbmcgdGFibGUsIHRyLCB0ZCwgdGJvZHkgYnV0IG5vdGhpbmcgZWxzZS5cblx0XHRcdFx0XHRcdGxldCBwaWxsYXJzO1xuXG5cdFx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRcdCF0YXJnZXQuaXMoJ3RhYmxlJykgJiZcblx0XHRcdFx0XHRcdFx0IXRhcmdldC5nZXRBc2NlbmRhbnQoJ3Rib2R5JywgMSlcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IHRhYmxlID0gdGFyZ2V0LmdldEFzY2VuZGFudCgndGFibGUnLCAxKTtcblxuXHRcdFx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoZSB0YWJsZSB3ZSBmb3VuZCBpcyBpbnNpZGUgdGhlIGNvbnRhaW5lclxuXHRcdFx0XHRcdFx0Ly8gKGVnLiB3ZSBzaG91bGQgbm90IHVzZSB0YWJsZXMgdGhlIGVkaXRvciBpcyBlbWJlZGRlZCB3aXRoaW4pXG5cdFx0XHRcdFx0XHRpZiAoIWVkaXRvci5lZGl0YWJsZSgpLmNvbnRhaW5zKHRhYmxlKSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGlmIChcblx0XHRcdFx0XHRcdFx0IShwaWxsYXJzID0gdGFibGUuZ2V0Q3VzdG9tRGF0YShcblx0XHRcdFx0XHRcdFx0XHQnX2NrZV90YWJsZV9waWxsYXJzJ1xuXHRcdFx0XHRcdFx0XHQpKVxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRhYmxlIHBpbGxhcnMgY2FsY3VsYXRpb24gcmVzdWx0LlxuXHRcdFx0XHRcdFx0XHR0YWJsZS5zZXRDdXN0b21EYXRhKFxuXHRcdFx0XHRcdFx0XHRcdCdfY2tlX3RhYmxlX3BpbGxhcnMnLFxuXHRcdFx0XHRcdFx0XHRcdChwaWxsYXJzID0gYnVpbGRUYWJsZUNvbHVtblBpbGxhcnModGFibGUpKVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR0YWJsZS5vbignbW91c2VvdXQnLCBjbGVhclBpbGxhcnNDYWNoZSk7XG5cdFx0XHRcdFx0XHRcdHRhYmxlLm9uKCdtb3VzZWRvd24nLCBjbGVhclBpbGxhcnNDYWNoZSk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdGNvbnN0IHBpbGxhciA9IGdldFBpbGxhckF0UG9zaXRpb24ocGlsbGFycywgcGFnZVgpO1xuXG5cdFx0XHRcdFx0XHRpZiAocGlsbGFyKSB7XG5cdFx0XHRcdFx0XHRcdHJlc2l6ZXIgPSBuZXcgQ29sdW1uUmVzaXplcihlZGl0b3IsIHBpbGxhcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblx0fSk7XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAwMy0yMDE1LCBDS1NvdXJjZSAtIEZyZWRlcmljbyBLbmFiYmVuLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRm9yIGxpY2Vuc2luZywgc2VlIExJQ0VOU0UubWQgb3IgaHR0cDovL2NrZWRpdG9yLmNvbS9saWNlbnNlXG4gKi9cblxuaWYgKCFDS0VESVRPUi5wbHVnaW5zLmdldCgnYWVfdGFibGV0b29scycpKSB7XG5cdGNvbnN0IGNlbGxOb2RlUmVnZXggPSAvXig/OnRkfHRoKSQvO1xuXG5cdGZ1bmN0aW9uIGdldFNlbGVjdGVkQ2VsbHMoc2VsZWN0aW9uKSB7XG5cdFx0Y29uc3QgcmFuZ2VzID0gc2VsZWN0aW9uLmdldFJhbmdlcygpO1xuXHRcdGNvbnN0IHJldHZhbCA9IFtdO1xuXHRcdGNvbnN0IGRhdGFiYXNlID0ge307XG5cblx0XHRmdW5jdGlvbiBtb3ZlT3V0T2ZDZWxsR3VhcmQobm9kZSkge1xuXHRcdFx0Ly8gQXBwbHkgdG8gdGhlIGZpcnN0IGNlbGwgb25seS5cblx0XHRcdGlmIChyZXR2YWwubGVuZ3RoID4gMCkgcmV0dXJuO1xuXG5cdFx0XHQvLyBJZiB3ZSBhcmUgZXhpdGluZyBmcm9tIHRoZSBmaXJzdCA8L3RkPiwgdGhlbiB0aGUgdGQgc2hvdWxkIGRlZmluaXRlbHkgYmVcblx0XHRcdC8vIGluY2x1ZGVkLlxuXHRcdFx0aWYgKFxuXHRcdFx0XHRub2RlLnR5cGUgPT0gQ0tFRElUT1IuTk9ERV9FTEVNRU5UICYmXG5cdFx0XHRcdGNlbGxOb2RlUmVnZXgudGVzdChub2RlLmdldE5hbWUoKSkgJiZcblx0XHRcdFx0IW5vZGUuZ2V0Q3VzdG9tRGF0YSgnc2VsZWN0ZWRfY2VsbCcpXG5cdFx0XHQpIHtcblx0XHRcdFx0Q0tFRElUT1IuZG9tLmVsZW1lbnQuc2V0TWFya2VyKFxuXHRcdFx0XHRcdGRhdGFiYXNlLFxuXHRcdFx0XHRcdG5vZGUsXG5cdFx0XHRcdFx0J3NlbGVjdGVkX2NlbGwnLFxuXHRcdFx0XHRcdHRydWVcblx0XHRcdFx0KTtcblx0XHRcdFx0cmV0dmFsLnB1c2gobm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHJhbmdlID0gcmFuZ2VzW2ldO1xuXG5cdFx0XHRpZiAocmFuZ2UuY29sbGFwc2VkKSB7XG5cdFx0XHRcdC8vIFdhbGtlciBkb2VzIG5vdCBoYW5kbGUgY29sbGFwc2VkIHJhbmdlcyB5ZXQgLSBmYWxsIGJhY2sgdG8gb2xkIEFQSS5cblx0XHRcdFx0Y29uc3Qgc3RhcnROb2RlID0gcmFuZ2UuZ2V0Q29tbW9uQW5jZXN0b3IoKTtcblx0XHRcdFx0Y29uc3QgbmVhcmVzdENlbGwgPVxuXHRcdFx0XHRcdHN0YXJ0Tm9kZS5nZXRBc2NlbmRhbnQoJ3RkJywgdHJ1ZSkgfHxcblx0XHRcdFx0XHRzdGFydE5vZGUuZ2V0QXNjZW5kYW50KCd0aCcsIHRydWUpO1xuXHRcdFx0XHRpZiAobmVhcmVzdENlbGwpIHJldHZhbC5wdXNoKG5lYXJlc3RDZWxsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IHdhbGtlciA9IG5ldyBDS0VESVRPUi5kb20ud2Fsa2VyKHJhbmdlKTtcblx0XHRcdFx0bGV0IG5vZGU7XG5cdFx0XHRcdHdhbGtlci5ndWFyZCA9IG1vdmVPdXRPZkNlbGxHdWFyZDtcblxuXHRcdFx0XHR3aGlsZSAoKG5vZGUgPSB3YWxrZXIubmV4dCgpKSkge1xuXHRcdFx0XHRcdC8vIElmIG1heSBiZSBwb3NzaWJsZSBmb3IgdXMgdG8gaGF2ZSBhIHJhbmdlIGxpa2UgdGhpczpcblx0XHRcdFx0XHQvLyA8dGQ+XjE8L3RkPjx0ZD5eMjwvdGQ+XG5cdFx0XHRcdFx0Ly8gVGhlIDJuZCB0ZCBzaG91bGRuJ3QgYmUgaW5jbHVkZWQuXG5cdFx0XHRcdFx0Ly9cblx0XHRcdFx0XHQvLyBTbyB3ZSBoYXZlIHRvIHRha2UgY2FyZSB0byBpbmNsdWRlIGEgdGQgd2UndmUgZW50ZXJlZCBvbmx5IHdoZW4gd2UndmVcblx0XHRcdFx0XHQvLyB3YWxrZWQgaW50byBpdHMgY2hpbGRyZW4uXG5cblx0XHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0XHRub2RlLnR5cGUgIT0gQ0tFRElUT1IuTk9ERV9FTEVNRU5UIHx8XG5cdFx0XHRcdFx0XHQhbm9kZS5pcyhDS0VESVRPUi5kdGQudGFibGUpXG5cdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRjb25zdCBwYXJlbnQgPVxuXHRcdFx0XHRcdFx0XHRub2RlLmdldEFzY2VuZGFudCgndGQnLCB0cnVlKSB8fFxuXHRcdFx0XHRcdFx0XHRub2RlLmdldEFzY2VuZGFudCgndGgnLCB0cnVlKTtcblx0XHRcdFx0XHRcdGlmIChwYXJlbnQgJiYgIXBhcmVudC5nZXRDdXN0b21EYXRhKCdzZWxlY3RlZF9jZWxsJykpIHtcblx0XHRcdFx0XHRcdFx0Q0tFRElUT1IuZG9tLmVsZW1lbnQuc2V0TWFya2VyKFxuXHRcdFx0XHRcdFx0XHRcdGRhdGFiYXNlLFxuXHRcdFx0XHRcdFx0XHRcdHBhcmVudCxcblx0XHRcdFx0XHRcdFx0XHQnc2VsZWN0ZWRfY2VsbCcsXG5cdFx0XHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRyZXR2YWwucHVzaChwYXJlbnQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdENLRURJVE9SLmRvbS5lbGVtZW50LmNsZWFyQWxsTWFya2VycyhkYXRhYmFzZSk7XG5cblx0XHRyZXR1cm4gcmV0dmFsO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Rm9jdXNFbGVtZW50QWZ0ZXJEZWxDZWxscyhjZWxsc1RvRGVsZXRlKSB7XG5cdFx0bGV0IGkgPSAwO1xuXG5cdFx0Y29uc3QgbGFzdCA9IGNlbGxzVG9EZWxldGUubGVuZ3RoIC0gMTtcblxuXHRcdGNvbnN0IGRhdGFiYXNlID0ge307XG5cblx0XHRsZXQgY2VsbDtcblxuXHRcdGxldCBmb2N1c2VkQ2VsbDtcblxuXHRcdGxldCB0cjtcblxuXHRcdHdoaWxlICgoY2VsbCA9IGNlbGxzVG9EZWxldGVbaSsrXSkpXG5cdFx0XHRDS0VESVRPUi5kb20uZWxlbWVudC5zZXRNYXJrZXIoZGF0YWJhc2UsIGNlbGwsICdkZWxldGVfY2VsbCcsIHRydWUpO1xuXG5cdFx0Ly8gMS5maXJzdCB3ZSBjaGVjayBsZWZ0IG9yIHJpZ2h0IHNpZGUgZm9jdXNhYmxlIGNlbGwgcm93IGJ5IHJvdztcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoKGNlbGwgPSBjZWxsc1RvRGVsZXRlW2krK10pKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCgoZm9jdXNlZENlbGwgPSBjZWxsLmdldFByZXZpb3VzKCkpICYmXG5cdFx0XHRcdFx0IWZvY3VzZWRDZWxsLmdldEN1c3RvbURhdGEoJ2RlbGV0ZV9jZWxsJykpIHx8XG5cdFx0XHRcdCgoZm9jdXNlZENlbGwgPSBjZWxsLmdldE5leHQoKSkgJiZcblx0XHRcdFx0XHQhZm9jdXNlZENlbGwuZ2V0Q3VzdG9tRGF0YSgnZGVsZXRlX2NlbGwnKSlcblx0XHRcdCkge1xuXHRcdFx0XHRDS0VESVRPUi5kb20uZWxlbWVudC5jbGVhckFsbE1hcmtlcnMoZGF0YWJhc2UpO1xuXHRcdFx0XHRyZXR1cm4gZm9jdXNlZENlbGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Q0tFRElUT1IuZG9tLmVsZW1lbnQuY2xlYXJBbGxNYXJrZXJzKGRhdGFiYXNlKTtcblxuXHRcdC8vIDIuIHRoZW4gd2UgY2hlY2sgdGhlIHRvcHBlc3Qgcm93IChvdXRzaWRlIHRoZSBzZWxlY3Rpb24gYXJlYSBzcXVhcmUpIGZvY3VzYWJsZSBjZWxsXG5cdFx0dHIgPSBjZWxsc1RvRGVsZXRlWzBdLmdldFBhcmVudCgpO1xuXHRcdGlmICgodHIgPSB0ci5nZXRQcmV2aW91cygpKSkgcmV0dXJuIHRyLmdldExhc3QoKTtcblxuXHRcdC8vIDMuIGxhc3Qgd2UgY2hlY2sgdGhlIGxvd2VyZXN0ICByb3cgZm9jdXNhYmxlIGNlbGxcblx0XHR0ciA9IGNlbGxzVG9EZWxldGVbbGFzdF0uZ2V0UGFyZW50KCk7XG5cdFx0aWYgKCh0ciA9IHRyLmdldE5leHQoKSkpIHJldHVybiB0ci5nZXRDaGlsZCgwKTtcblxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zZXJ0Um93KHNlbGVjdGlvbiwgaW5zZXJ0QmVmb3JlKSB7XG5cdFx0Y29uc3QgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKHNlbGVjdGlvbik7XG5cblx0XHRjb25zdCBmaXJzdENlbGwgPSBjZWxsc1swXTtcblxuXHRcdGNvbnN0IHRhYmxlID0gZmlyc3RDZWxsLmdldEFzY2VuZGFudCgndGFibGUnKTtcblxuXHRcdGNvbnN0IGRvYyA9IGZpcnN0Q2VsbC5nZXREb2N1bWVudCgpO1xuXG5cdFx0Y29uc3Qgc3RhcnRSb3cgPSBjZWxsc1swXS5nZXRQYXJlbnQoKTtcblxuXHRcdGNvbnN0IHN0YXJ0Um93SW5kZXggPSBzdGFydFJvdy4kLnJvd0luZGV4O1xuXG5cdFx0Y29uc3QgbGFzdENlbGwgPSBjZWxsc1tjZWxscy5sZW5ndGggLSAxXTtcblxuXHRcdGNvbnN0IGVuZFJvd0luZGV4ID1cblx0XHRcdGxhc3RDZWxsLmdldFBhcmVudCgpLiQucm93SW5kZXggKyBsYXN0Q2VsbC4kLnJvd1NwYW4gLSAxO1xuXG5cdFx0Y29uc3QgZW5kUm93ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHRhYmxlLiQucm93c1tlbmRSb3dJbmRleF0pO1xuXG5cdFx0Y29uc3Qgcm93SW5kZXggPSBpbnNlcnRCZWZvcmUgPyBzdGFydFJvd0luZGV4IDogZW5kUm93SW5kZXg7XG5cblx0XHRjb25zdCByb3cgPSBpbnNlcnRCZWZvcmUgPyBzdGFydFJvdyA6IGVuZFJvdztcblxuXHRcdGNvbnN0IG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAodGFibGUpO1xuXG5cdFx0Y29uc3QgY2xvbmVSb3cgPSBtYXBbcm93SW5kZXhdO1xuXG5cdFx0Y29uc3QgbmV4dFJvdyA9IGluc2VydEJlZm9yZSA/IG1hcFtyb3dJbmRleCAtIDFdIDogbWFwW3Jvd0luZGV4ICsgMV07XG5cblx0XHRjb25zdCB3aWR0aCA9IG1hcFswXS5sZW5ndGg7XG5cblx0XHRjb25zdCBuZXdSb3cgPSBkb2MuY3JlYXRlRWxlbWVudCgndHInKTtcblx0XHRmb3IgKGxldCBpID0gMDsgY2xvbmVSb3dbaV0gJiYgaSA8IHdpZHRoOyBpKyspIHtcblx0XHRcdGxldCBjZWxsO1xuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciB0aGVyZSdzIGEgc3Bhbm5pbmcgcm93IGhlcmUsIGRvIG5vdCBicmVhayBpdC5cblx0XHRcdGlmIChcblx0XHRcdFx0Y2xvbmVSb3dbaV0ucm93U3BhbiA+IDEgJiZcblx0XHRcdFx0bmV4dFJvdyAmJlxuXHRcdFx0XHRjbG9uZVJvd1tpXSA9PSBuZXh0Um93W2ldXG5cdFx0XHQpIHtcblx0XHRcdFx0Y2VsbCA9IGNsb25lUm93W2ldO1xuXHRcdFx0XHRjZWxsLnJvd1NwYW4gKz0gMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNlbGwgPSBuZXcgQ0tFRElUT1IuZG9tLmVsZW1lbnQoY2xvbmVSb3dbaV0pLmNsb25lKCk7XG5cdFx0XHRcdGNlbGwucmVtb3ZlQXR0cmlidXRlKCdyb3dTcGFuJyk7XG5cdFx0XHRcdGNlbGwuYXBwZW5kQm9ndXMoKTtcblx0XHRcdFx0bmV3Um93LmFwcGVuZChjZWxsKTtcblx0XHRcdFx0Y2VsbCA9IGNlbGwuJDtcblx0XHRcdH1cblxuXHRcdFx0aSArPSBjZWxsLmNvbFNwYW4gLSAxO1xuXHRcdH1cblxuXHRcdGlmIChpbnNlcnRCZWZvcmUpIHtcblx0XHRcdG5ld1Jvdy5pbnNlcnRCZWZvcmUocm93KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3Um93Lmluc2VydEFmdGVyKHJvdyk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZGVsZXRlUm93cyhzZWxlY3Rpb25PclJvdykge1xuXHRcdGlmIChzZWxlY3Rpb25PclJvdyBpbnN0YW5jZW9mIENLRURJVE9SLmRvbS5zZWxlY3Rpb24pIHtcblx0XHRcdGNvbnN0IGNlbGxzID0gZ2V0U2VsZWN0ZWRDZWxscyhzZWxlY3Rpb25PclJvdyk7XG5cblx0XHRcdGNvbnN0IGZpcnN0Q2VsbCA9IGNlbGxzWzBdO1xuXG5cdFx0XHRjb25zdCB0YWJsZSA9IGZpcnN0Q2VsbC5nZXRBc2NlbmRhbnQoJ3RhYmxlJyk7XG5cblx0XHRcdGNvbnN0IG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAodGFibGUpO1xuXG5cdFx0XHRjb25zdCBzdGFydFJvdyA9IGNlbGxzWzBdLmdldFBhcmVudCgpO1xuXG5cdFx0XHRjb25zdCBzdGFydFJvd0luZGV4ID0gc3RhcnRSb3cuJC5yb3dJbmRleDtcblxuXHRcdFx0Y29uc3QgbGFzdENlbGwgPSBjZWxsc1tjZWxscy5sZW5ndGggLSAxXTtcblxuXHRcdFx0Y29uc3QgZW5kUm93SW5kZXggPVxuXHRcdFx0XHRsYXN0Q2VsbC5nZXRQYXJlbnQoKS4kLnJvd0luZGV4ICsgbGFzdENlbGwuJC5yb3dTcGFuIC0gMTtcblxuXHRcdFx0Y29uc3Qgcm93c1RvRGVsZXRlID0gW107XG5cblx0XHRcdC8vIERlbGV0ZSBjZWxsIG9yIHJlZHVjZSBjZWxsIHNwYW5zIGJ5IGNoZWNraW5nIHRocm91Z2ggdGhlIHRhYmxlIG1hcC5cblx0XHRcdGZvciAobGV0IGkgPSBzdGFydFJvd0luZGV4OyBpIDw9IGVuZFJvd0luZGV4OyBpKyspIHtcblx0XHRcdFx0Y29uc3QgbWFwUm93ID0gbWFwW2ldO1xuXG5cdFx0XHRcdGNvbnN0IHJvdyA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudCh0YWJsZS4kLnJvd3NbaV0pO1xuXG5cdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbWFwUm93Lmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0Y29uc3QgY2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChtYXBSb3dbal0pO1xuXG5cdFx0XHRcdFx0Y29uc3QgY2VsbFJvd0luZGV4ID0gY2VsbC5nZXRQYXJlbnQoKS4kLnJvd0luZGV4O1xuXG5cdFx0XHRcdFx0aWYgKGNlbGwuJC5yb3dTcGFuID09IDEpIGNlbGwucmVtb3ZlKCk7XG5cdFx0XHRcdFx0Ly8gUm93IHNwYW5uZWQgY2VsbC5cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFNwYW4gcm93IG9mIHRoZSBjZWxsLCByZWR1Y2Ugc3Bhbm5pbmcuXG5cdFx0XHRcdFx0XHRjZWxsLiQucm93U3BhbiAtPSAxO1xuXHRcdFx0XHRcdFx0Ly8gUm9vdCByb3cgb2YgdGhlIGNlbGwsIHJvb3QgY2VsbCB0byBuZXh0IHJvdy5cblx0XHRcdFx0XHRcdGlmIChjZWxsUm93SW5kZXggPT0gaSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBuZXh0TWFwUm93ID0gbWFwW2kgKyAxXTtcblx0XHRcdFx0XHRcdFx0aWYgKG5leHRNYXBSb3dbaiAtIDFdKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2VsbC5pbnNlcnRBZnRlcihcblx0XHRcdFx0XHRcdFx0XHRcdG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChuZXh0TWFwUm93W2ogLSAxXSlcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChcblx0XHRcdFx0XHRcdFx0XHRcdHRhYmxlLiQucm93c1tpICsgMV1cblx0XHRcdFx0XHRcdFx0XHQpLmFwcGVuZChjZWxsLCAxKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGogKz0gY2VsbC4kLmNvbFNwYW4gLSAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cm93c1RvRGVsZXRlLnB1c2gocm93KTtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgcm93cyA9IHRhYmxlLiQucm93cztcblxuXHRcdFx0Ly8gV2hlcmUgdG8gcHV0IHRoZSBjdXJzb3IgYWZ0ZXIgcm93cyBiZWVuIGRlbGV0ZWQ/XG5cdFx0XHQvLyAxLiBJbnRvIG5leHQgc2libGluZyByb3cgaWYgYW55O1xuXHRcdFx0Ly8gMi4gSW50byBwcmV2aW91cyBzaWJsaW5nIHJvdyBpZiBhbnk7XG5cdFx0XHQvLyAzLiBJbnRvIHRhYmxlJ3MgcGFyZW50IGVsZW1lbnQgaWYgaXQncyB0aGUgdmVyeSBsYXN0IHJvdy5cblx0XHRcdGNvbnN0IGN1cnNvclBvc2l0aW9uID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KFxuXHRcdFx0XHRyb3dzW2VuZFJvd0luZGV4ICsgMV0gfHxcblx0XHRcdFx0XHQoc3RhcnRSb3dJbmRleCA+IDAgPyByb3dzW3N0YXJ0Um93SW5kZXggLSAxXSA6IG51bGwpIHx8XG5cdFx0XHRcdFx0dGFibGUuJC5wYXJlbnROb2RlXG5cdFx0XHQpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gcm93c1RvRGVsZXRlLmxlbmd0aDsgaSA+PSAwOyBpLS0pXG5cdFx0XHRcdGRlbGV0ZVJvd3Mocm93c1RvRGVsZXRlW2ldKTtcblxuXHRcdFx0cmV0dXJuIGN1cnNvclBvc2l0aW9uO1xuXHRcdH0gZWxzZSBpZiAoc2VsZWN0aW9uT3JSb3cgaW5zdGFuY2VvZiBDS0VESVRPUi5kb20uZWxlbWVudCkge1xuXHRcdFx0Y29uc3QgdGFibGUgPSBzZWxlY3Rpb25PclJvdy5nZXRBc2NlbmRhbnQoJ3RhYmxlJyk7XG5cblx0XHRcdGlmICh0YWJsZS4kLnJvd3MubGVuZ3RoID09IDEpIHRhYmxlLnJlbW92ZSgpO1xuXHRcdFx0ZWxzZSBzZWxlY3Rpb25PclJvdy5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldENlbGxDb2xJbmRleChjZWxsLCBpc1N0YXJ0KSB7XG5cdFx0Y29uc3Qgcm93ID0gY2VsbC5nZXRQYXJlbnQoKTtcblxuXHRcdGNvbnN0IHJvd0NlbGxzID0gcm93LiQuY2VsbHM7XG5cblx0XHRsZXQgY29sSW5kZXggPSAwO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q2VsbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IG1hcENlbGwgPSByb3dDZWxsc1tpXTtcblx0XHRcdGNvbEluZGV4ICs9IGlzU3RhcnQgPyAxIDogbWFwQ2VsbC5jb2xTcGFuO1xuXHRcdFx0aWYgKG1hcENlbGwgPT0gY2VsbC4kKSBicmVhaztcblx0XHR9XG5cblx0XHRyZXR1cm4gY29sSW5kZXggLSAxO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q29sdW1uc0luZGljZXMoY2VsbHMsIGlzU3RhcnQpIHtcblx0XHRsZXQgcmV0dmFsID0gaXNTdGFydCA/IEluZmluaXR5IDogMDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBjb2xJbmRleCA9IGdldENlbGxDb2xJbmRleChjZWxsc1tpXSwgaXNTdGFydCk7XG5cdFx0XHRpZiAoaXNTdGFydCA/IGNvbEluZGV4IDwgcmV0dmFsIDogY29sSW5kZXggPiByZXR2YWwpXG5cdFx0XHRcdHJldHZhbCA9IGNvbEluZGV4O1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0dmFsO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zZXJ0Q29sdW1uKHNlbGVjdGlvbiwgaW5zZXJ0QmVmb3JlKSB7XG5cdFx0Y29uc3QgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKHNlbGVjdGlvbik7XG5cblx0XHRjb25zdCBmaXJzdENlbGwgPSBjZWxsc1swXTtcblxuXHRcdGNvbnN0IHRhYmxlID0gZmlyc3RDZWxsLmdldEFzY2VuZGFudCgndGFibGUnKTtcblxuXHRcdGNvbnN0IHN0YXJ0Q29sID0gZ2V0Q29sdW1uc0luZGljZXMoY2VsbHMsIDEpO1xuXG5cdFx0Y29uc3QgbGFzdENvbCA9IGdldENvbHVtbnNJbmRpY2VzKGNlbGxzKTtcblxuXHRcdGNvbnN0IGNvbEluZGV4ID0gaW5zZXJ0QmVmb3JlID8gc3RhcnRDb2wgOiBsYXN0Q29sO1xuXG5cdFx0Y29uc3QgbWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCh0YWJsZSk7XG5cblx0XHRjb25zdCBjbG9uZUNvbCA9IFtdO1xuXG5cdFx0Y29uc3QgbmV4dENvbCA9IFtdO1xuXG5cdFx0Y29uc3QgaGVpZ2h0ID0gbWFwLmxlbmd0aDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcblx0XHRcdGNsb25lQ29sLnB1c2gobWFwW2ldW2NvbEluZGV4XSk7XG5cdFx0XHRjb25zdCBuZXh0Q2VsbCA9IGluc2VydEJlZm9yZVxuXHRcdFx0XHQ/IG1hcFtpXVtjb2xJbmRleCAtIDFdXG5cdFx0XHRcdDogbWFwW2ldW2NvbEluZGV4ICsgMV07XG5cdFx0XHRuZXh0Q29sLnB1c2gobmV4dENlbGwpO1xuXHRcdH1cblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcblx0XHRcdGxldCBjZWxsO1xuXG5cdFx0XHRpZiAoIWNsb25lQ29sW2ldKSBjb250aW51ZTtcblxuXHRcdFx0Ly8gQ2hlY2sgd2hldGhlciB0aGVyZSdzIGEgc3Bhbm5pbmcgY29sdW1uIGhlcmUsIGRvIG5vdCBicmVhayBpdC5cblx0XHRcdGlmIChjbG9uZUNvbFtpXS5jb2xTcGFuID4gMSAmJiBuZXh0Q29sW2ldID09IGNsb25lQ29sW2ldKSB7XG5cdFx0XHRcdGNlbGwgPSBjbG9uZUNvbFtpXTtcblx0XHRcdFx0Y2VsbC5jb2xTcGFuICs9IDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjZWxsID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGNsb25lQ29sW2ldKS5jbG9uZSgpO1xuXHRcdFx0XHRjZWxsLnJlbW92ZUF0dHJpYnV0ZSgnY29sU3BhbicpO1xuXHRcdFx0XHRjZWxsLmFwcGVuZEJvZ3VzKCk7XG5cdFx0XHRcdGNlbGxbaW5zZXJ0QmVmb3JlID8gJ2luc2VydEJlZm9yZScgOiAnaW5zZXJ0QWZ0ZXInXS5jYWxsKFxuXHRcdFx0XHRcdGNlbGwsXG5cdFx0XHRcdFx0bmV3IENLRURJVE9SLmRvbS5lbGVtZW50KGNsb25lQ29sW2ldKVxuXHRcdFx0XHQpO1xuXHRcdFx0XHRjZWxsID0gY2VsbC4kO1xuXHRcdFx0fVxuXG5cdFx0XHRpICs9IGNlbGwucm93U3BhbiAtIDE7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZGVsZXRlQ29sdW1ucyhzZWxlY3Rpb25PckNlbGwpIHtcblx0XHRjb25zdCBjZWxscyA9IGdldFNlbGVjdGVkQ2VsbHMoc2VsZWN0aW9uT3JDZWxsKTtcblxuXHRcdGNvbnN0IGZpcnN0Q2VsbCA9IGNlbGxzWzBdO1xuXG5cdFx0Y29uc3QgbGFzdENlbGwgPSBjZWxsc1tjZWxscy5sZW5ndGggLSAxXTtcblxuXHRcdGNvbnN0IHRhYmxlID0gZmlyc3RDZWxsLmdldEFzY2VuZGFudCgndGFibGUnKTtcblxuXHRcdGNvbnN0IG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAodGFibGUpO1xuXG5cdFx0bGV0IHN0YXJ0Q29sSW5kZXg7XG5cblx0XHRsZXQgZW5kQ29sSW5kZXg7XG5cblx0XHRjb25zdCByb3dzVG9EZWxldGUgPSBbXTtcblxuXHRcdGxldCByb3dzO1xuXG5cdFx0Ly8gRmlndXJlIG91dCBzZWxlY3RlZCBjZWxscycgY29sdW1uIGluZGljZXMuXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHJvd3MgPSBtYXAubGVuZ3RoOyBpIDwgcm93czsgaSsrKSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc29ydC12YXJzXG5cdFx0XHRmb3IgKGxldCBqID0gMCwgY29scyA9IG1hcFtpXS5sZW5ndGg7IGogPCBjb2xzOyBqKyspIHtcblx0XHRcdFx0aWYgKG1hcFtpXVtqXSA9PSBmaXJzdENlbGwuJCkgc3RhcnRDb2xJbmRleCA9IGo7XG5cdFx0XHRcdGlmIChtYXBbaV1bal0gPT0gbGFzdENlbGwuJCkgZW5kQ29sSW5kZXggPSBqO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIERlbGV0ZSBjZWxsIG9yIHJlZHVjZSBjZWxsIHNwYW5zIGJ5IGNoZWNraW5nIHRocm91Z2ggdGhlIHRhYmxlIG1hcC5cblx0XHRmb3IgKGxldCBpID0gc3RhcnRDb2xJbmRleDsgaSA8PSBlbmRDb2xJbmRleDsgaSsrKSB7XG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IG1hcC5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRjb25zdCBtYXBSb3cgPSBtYXBbal07XG5cblx0XHRcdFx0Y29uc3Qgcm93ID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHRhYmxlLiQucm93c1tqXSk7XG5cblx0XHRcdFx0Y29uc3QgY2VsbCA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChtYXBSb3dbaV0pO1xuXG5cdFx0XHRcdGlmIChjZWxsLiQpIHtcblx0XHRcdFx0XHRpZiAoY2VsbC4kLmNvbFNwYW4gPT0gMSkgY2VsbC5yZW1vdmUoKTtcblx0XHRcdFx0XHQvLyBSZWR1Y2UgdGhlIGNvbCBzcGFucy5cblx0XHRcdFx0XHRlbHNlIGNlbGwuJC5jb2xTcGFuIC09IDE7XG5cblx0XHRcdFx0XHRqICs9IGNlbGwuJC5yb3dTcGFuIC0gMTtcblxuXHRcdFx0XHRcdGlmICghcm93LiQuY2VsbHMubGVuZ3RoKSByb3dzVG9EZWxldGUucHVzaChyb3cpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29uc3QgZmlyc3RSb3dDZWxscyA9IHRhYmxlLiQucm93c1swXSAmJiB0YWJsZS4kLnJvd3NbMF0uY2VsbHM7XG5cblx0XHQvLyBXaGVyZSB0byBwdXQgdGhlIGN1cnNvciBhZnRlciBjb2x1bW5zIGJlZW4gZGVsZXRlZD9cblx0XHQvLyAxLiBJbnRvIG5leHQgY2VsbCBvZiB0aGUgZmlyc3Qgcm93IGlmIGFueTtcblx0XHQvLyAyLiBJbnRvIHByZXZpb3VzIGNlbGwgb2YgdGhlIGZpcnN0IHJvdyBpZiBhbnk7XG5cdFx0Ly8gMy4gSW50byB0YWJsZSdzIHBhcmVudCBlbGVtZW50O1xuXHRcdGNvbnN0IGN1cnNvclBvc2l0aW9uID0gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KFxuXHRcdFx0Zmlyc3RSb3dDZWxsc1tzdGFydENvbEluZGV4XSB8fFxuXHRcdFx0XHQoc3RhcnRDb2xJbmRleFxuXHRcdFx0XHRcdD8gZmlyc3RSb3dDZWxsc1tzdGFydENvbEluZGV4IC0gMV1cblx0XHRcdFx0XHQ6IHRhYmxlLiQucGFyZW50Tm9kZSlcblx0XHQpO1xuXG5cdFx0Ly8gRGVsZXRlIHRhYmxlIHJvd3Mgb25seSBpZiBhbGwgY29sdW1ucyBhcmUgZ29uZSAoZG8gbm90IHJlbW92ZSBlbXB0eSByb3cpLlxuXHRcdGlmIChyb3dzVG9EZWxldGUubGVuZ3RoID09IHJvd3MpIHRhYmxlLnJlbW92ZSgpO1xuXG5cdFx0cmV0dXJuIGN1cnNvclBvc2l0aW9uO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW5zZXJ0Q2VsbChzZWxlY3Rpb24sIGluc2VydEJlZm9yZSkge1xuXHRcdGNvbnN0IHN0YXJ0RWxlbWVudCA9IHNlbGVjdGlvbi5nZXRTdGFydEVsZW1lbnQoKTtcblx0XHRjb25zdCBjZWxsID1cblx0XHRcdHN0YXJ0RWxlbWVudC5nZXRBc2NlbmRhbnQoJ3RkJywgMSkgfHxcblx0XHRcdHN0YXJ0RWxlbWVudC5nZXRBc2NlbmRhbnQoJ3RoJywgMSk7XG5cblx0XHRpZiAoIWNlbGwpIHJldHVybjtcblxuXHRcdC8vIENyZWF0ZSB0aGUgbmV3IGNlbGwgZWxlbWVudCB0byBiZSBhZGRlZC5cblx0XHRjb25zdCBuZXdDZWxsID0gY2VsbC5jbG9uZSgpO1xuXHRcdG5ld0NlbGwuYXBwZW5kQm9ndXMoKTtcblxuXHRcdGlmIChpbnNlcnRCZWZvcmUpIG5ld0NlbGwuaW5zZXJ0QmVmb3JlKGNlbGwpO1xuXHRcdGVsc2UgbmV3Q2VsbC5pbnNlcnRBZnRlcihjZWxsKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlbGV0ZUNlbGxzKHNlbGVjdGlvbk9yQ2VsbCkge1xuXHRcdGlmIChzZWxlY3Rpb25PckNlbGwgaW5zdGFuY2VvZiBDS0VESVRPUi5kb20uc2VsZWN0aW9uKSB7XG5cdFx0XHRjb25zdCBjZWxsc1RvRGVsZXRlID0gZ2V0U2VsZWN0ZWRDZWxscyhzZWxlY3Rpb25PckNlbGwpO1xuXHRcdFx0Y29uc3QgdGFibGUgPVxuXHRcdFx0XHRjZWxsc1RvRGVsZXRlWzBdICYmIGNlbGxzVG9EZWxldGVbMF0uZ2V0QXNjZW5kYW50KCd0YWJsZScpO1xuXHRcdFx0Y29uc3QgY2VsbFRvRm9jdXMgPSBnZXRGb2N1c0VsZW1lbnRBZnRlckRlbENlbGxzKGNlbGxzVG9EZWxldGUpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gY2VsbHNUb0RlbGV0ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdFx0ZGVsZXRlQ2VsbHMoY2VsbHNUb0RlbGV0ZVtpXSk7XG5cblx0XHRcdGlmIChjZWxsVG9Gb2N1cykgcGxhY2VDdXJzb3JJbkNlbGwoY2VsbFRvRm9jdXMsIHRydWUpO1xuXHRcdFx0ZWxzZSBpZiAodGFibGUpIHRhYmxlLnJlbW92ZSgpO1xuXHRcdH0gZWxzZSBpZiAoc2VsZWN0aW9uT3JDZWxsIGluc3RhbmNlb2YgQ0tFRElUT1IuZG9tLmVsZW1lbnQpIHtcblx0XHRcdGNvbnN0IHRyID0gc2VsZWN0aW9uT3JDZWxsLmdldFBhcmVudCgpO1xuXHRcdFx0aWYgKHRyLmdldENoaWxkQ291bnQoKSA9PSAxKSB0ci5yZW1vdmUoKTtcblx0XHRcdGVsc2Ugc2VsZWN0aW9uT3JDZWxsLnJlbW92ZSgpO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSBmaWxsZXIgYXQgZW5kIGFuZCBlbXB0eSBzcGFjZXMgYXJvdW5kIHRoZSBjZWxsIGNvbnRlbnQuXG5cdGZ1bmN0aW9uIHRyaW1DZWxsKGNlbGwpIHtcblx0XHRjb25zdCBib2d1cyA9IGNlbGwuZ2V0Qm9ndXMoKTtcblx0XHRpZiAoYm9ndXMpIHtcblx0XHRcdGJvZ3VzLnJlbW92ZSgpO1xuXHRcdH1cblx0XHRjZWxsLnRyaW0oKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBsYWNlQ3Vyc29ySW5DZWxsKGNlbGwsIHBsYWNlQXRFbmQpIHtcblx0XHRjb25zdCBkb2NJbm5lciA9IGNlbGwuZ2V0RG9jdW1lbnQoKTtcblxuXHRcdGNvbnN0IGRvY091dGVyID0gQ0tFRElUT1IuZG9jdW1lbnQ7XG5cblx0XHQvLyBGaXhpbmcgXCJVbnNwZWNpZmllZCBlcnJvclwiIHRocm93biBpbiBJRTEwIGJ5IHJlc2V0dGluZ1xuXHRcdC8vIHNlbGVjdGlvbiB0aGUgZGlydHkgYW5kIHNoYW1lZnVsIHdheSAoIzEwMzA4KS5cblx0XHQvLyBXZSBjYW4gbm90IGFwcGx5IHRoaXMgaGFjayB0byBJRTggYmVjYXVzZVxuXHRcdC8vIGl0IGNhdXNlcyBlcnJvciAoIzExMDU4KS5cblx0XHRpZiAoQ0tFRElUT1IuZW52LmllICYmIENLRURJVE9SLmVudi52ZXJzaW9uID09IDEwKSB7XG5cdFx0XHRkb2NPdXRlci5mb2N1cygpO1xuXHRcdFx0ZG9jSW5uZXIuZm9jdXMoKTtcblx0XHR9XG5cblx0XHRjb25zdCByYW5nZSA9IG5ldyBDS0VESVRPUi5kb20ucmFuZ2UoZG9jSW5uZXIpO1xuXHRcdGlmIChcblx0XHRcdCFyYW5nZVsnbW92ZVRvRWxlbWVudEVkaXQnICsgKHBsYWNlQXRFbmQgPyAnRW5kJyA6ICdTdGFydCcpXShjZWxsKVxuXHRcdCkge1xuXHRcdFx0cmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGNlbGwpO1xuXHRcdFx0cmFuZ2UuY29sbGFwc2UocGxhY2VBdEVuZCA/IGZhbHNlIDogdHJ1ZSk7XG5cdFx0fVxuXHRcdHJhbmdlLnNlbGVjdCh0cnVlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNlbGxJblJvdyh0YWJsZU1hcCwgcm93SW5kZXgsIGNlbGwpIHtcblx0XHRjb25zdCBvUm93ID0gdGFibGVNYXBbcm93SW5kZXhdO1xuXHRcdGlmICh0eXBlb2YgY2VsbCA9PSAndW5kZWZpbmVkJykgcmV0dXJuIG9Sb3c7XG5cblx0XHRmb3IgKGxldCBjID0gMDsgb1JvdyAmJiBjIDwgb1Jvdy5sZW5ndGg7IGMrKykge1xuXHRcdFx0aWYgKGNlbGwuaXMgJiYgb1Jvd1tjXSA9PSBjZWxsLiQpIHJldHVybiBjO1xuXHRcdFx0ZWxzZSBpZiAoYyA9PSBjZWxsKSByZXR1cm4gbmV3IENLRURJVE9SLmRvbS5lbGVtZW50KG9Sb3dbY10pO1xuXHRcdH1cblx0XHRyZXR1cm4gY2VsbC5pcyA/IC0xIDogbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNlbGxJbkNvbCh0YWJsZU1hcCwgY29sSW5kZXgpIHtcblx0XHRjb25zdCBvQ29sID0gW107XG5cdFx0Zm9yIChsZXQgciA9IDA7IHIgPCB0YWJsZU1hcC5sZW5ndGg7IHIrKykge1xuXHRcdFx0Y29uc3Qgcm93ID0gdGFibGVNYXBbcl07XG5cdFx0XHRvQ29sLnB1c2gocm93W2NvbEluZGV4XSk7XG5cblx0XHRcdC8vIEF2b2lkIGFkZGluZyBkdXBsaWNhdGUgY2VsbHMuXG5cdFx0XHRpZiAocm93W2NvbEluZGV4XS5yb3dTcGFuID4gMSkgciArPSByb3dbY29sSW5kZXhdLnJvd1NwYW4gLSAxO1xuXHRcdH1cblx0XHRyZXR1cm4gb0NvbDtcblx0fVxuXG5cdGZ1bmN0aW9uIG1lcmdlQ2VsbHMoc2VsZWN0aW9uLCBtZXJnZURpcmVjdGlvbiwgaXNEZXRlY3QpIHtcblx0XHRjb25zdCBjZWxscyA9IGdldFNlbGVjdGVkQ2VsbHMoc2VsZWN0aW9uKTtcblxuXHRcdC8vIEludmFsaWQgbWVyZ2UgcmVxdWVzdCBpZjpcblx0XHQvLyAxLiBJbiBiYXRjaCBtb2RlIGRlc3BpdGUgdGhhdCBsZXNzIHRoYW4gdHdvIHNlbGVjdGVkLlxuXHRcdC8vIDIuIEluIHNvbG8gbW9kZSB3aGlsZSBub3QgZXhhY3RseSBvbmx5IG9uZSBzZWxlY3RlZC5cblx0XHQvLyAzLiBDZWxscyBkaXN0cmlidXRlZCBpbiBkaWZmZXJlbnQgdGFibGUgZ3JvdXBzIChlLmcuIGZyb20gYm90aCB0aGVhZCBhbmQgdGJvZHkpLlxuXHRcdGxldCBjb21tb25BbmNlc3Rvcjtcblx0XHRpZiAoXG5cdFx0XHQobWVyZ2VEaXJlY3Rpb24gPyBjZWxscy5sZW5ndGggIT0gMSA6IGNlbGxzLmxlbmd0aCA8IDIpIHx8XG5cdFx0XHQoKGNvbW1vbkFuY2VzdG9yID0gc2VsZWN0aW9uLmdldENvbW1vbkFuY2VzdG9yKCkpICYmXG5cdFx0XHRcdGNvbW1vbkFuY2VzdG9yLnR5cGUgPT0gQ0tFRElUT1IuTk9ERV9FTEVNRU5UICYmXG5cdFx0XHRcdGNvbW1vbkFuY2VzdG9yLmlzKCd0YWJsZScpKVxuXHRcdClcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdGxldCBjZWxsO1xuXG5cdFx0Y29uc3QgZmlyc3RDZWxsID0gY2VsbHNbMF07XG5cblx0XHRjb25zdCB0YWJsZSA9IGZpcnN0Q2VsbC5nZXRBc2NlbmRhbnQoJ3RhYmxlJyk7XG5cblx0XHRjb25zdCBtYXAgPSBDS0VESVRPUi50b29scy5idWlsZFRhYmxlTWFwKHRhYmxlKTtcblxuXHRcdGNvbnN0IG1hcEhlaWdodCA9IG1hcC5sZW5ndGg7XG5cblx0XHRjb25zdCBtYXBXaWR0aCA9IG1hcFswXS5sZW5ndGg7XG5cblx0XHRjb25zdCBzdGFydFJvdyA9IGZpcnN0Q2VsbC5nZXRQYXJlbnQoKS4kLnJvd0luZGV4O1xuXG5cdFx0Y29uc3Qgc3RhcnRDb2x1bW4gPSBjZWxsSW5Sb3cobWFwLCBzdGFydFJvdywgZmlyc3RDZWxsKTtcblxuXHRcdGlmIChtZXJnZURpcmVjdGlvbikge1xuXHRcdFx0bGV0IHRhcmdldENlbGw7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb25zdCByb3dzcGFuID1cblx0XHRcdFx0XHRwYXJzZUludChmaXJzdENlbGwuZ2V0QXR0cmlidXRlKCdyb3dzcGFuJyksIDEwKSB8fCAxO1xuXHRcdFx0XHRjb25zdCBjb2xzcGFuID1cblx0XHRcdFx0XHRwYXJzZUludChmaXJzdENlbGwuZ2V0QXR0cmlidXRlKCdjb2xzcGFuJyksIDEwKSB8fCAxO1xuXG5cdFx0XHRcdHRhcmdldENlbGwgPVxuXHRcdFx0XHRcdG1hcFtcblx0XHRcdFx0XHRcdG1lcmdlRGlyZWN0aW9uID09ICd1cCdcblx0XHRcdFx0XHRcdFx0PyBzdGFydFJvdyAtIHJvd3NwYW5cblx0XHRcdFx0XHRcdFx0OiBtZXJnZURpcmVjdGlvbiA9PSAnZG93bidcblx0XHRcdFx0XHRcdFx0PyBzdGFydFJvdyArIHJvd3NwYW5cblx0XHRcdFx0XHRcdFx0OiBzdGFydFJvd1xuXHRcdFx0XHRcdF1bXG5cdFx0XHRcdFx0XHRtZXJnZURpcmVjdGlvbiA9PSAnbGVmdCdcblx0XHRcdFx0XHRcdFx0PyBzdGFydENvbHVtbiAtIGNvbHNwYW5cblx0XHRcdFx0XHRcdFx0OiBtZXJnZURpcmVjdGlvbiA9PSAncmlnaHQnXG5cdFx0XHRcdFx0XHRcdD8gc3RhcnRDb2x1bW4gKyBjb2xzcGFuXG5cdFx0XHRcdFx0XHRcdDogc3RhcnRDb2x1bW5cblx0XHRcdFx0XHRdO1xuXHRcdFx0fSBjYXRjaCAoZXIpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAxLiBObyBjZWxsIGNvdWxkIGJlIG1lcmdlZC5cblx0XHRcdC8vIDIuIFNhbWUgY2VsbCBhY3R1YWxseS5cblx0XHRcdGlmICghdGFyZ2V0Q2VsbCB8fCBmaXJzdENlbGwuJCA9PSB0YXJnZXRDZWxsKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdC8vIFNvcnQgaW4gbWFwIG9yZGVyIHJlZ2FyZGxlc3Mgb2YgdGhlIERPTSBzZXF1ZW5jZS5cblx0XHRcdGNlbGxzW1xuXHRcdFx0XHRtZXJnZURpcmVjdGlvbiA9PSAndXAnIHx8IG1lcmdlRGlyZWN0aW9uID09ICdsZWZ0J1xuXHRcdFx0XHRcdD8gJ3Vuc2hpZnQnXG5cdFx0XHRcdFx0OiAncHVzaCdcblx0XHRcdF0obmV3IENLRURJVE9SLmRvbS5lbGVtZW50KHRhcmdldENlbGwpKTtcblx0XHR9XG5cblx0XHQvLyBTdGFydCBmcm9tIGhlcmUgYXJlIG1lcmdpbmcgd2F5IGlnbm9yYW5jZSAobWVyZ2UgdXAvcmlnaHQsIGJhdGNoIG1lcmdlKS5cblx0XHRjb25zdCBkb2MgPSBmaXJzdENlbGwuZ2V0RG9jdW1lbnQoKTtcblxuXHRcdGxldCBsYXN0Um93SW5kZXggPSBzdGFydFJvdztcblxuXHRcdGxldCB0b3RhbFJvd1NwYW4gPSAwO1xuXG5cdFx0bGV0IHRvdGFsQ29sU3BhbiA9IDA7XG5cblx0XHQvLyBVc2UgYSBkb2N1bWVudEZyYWdtZW50IGFzIGJ1ZmZlciB3aGVuIGFwcGVuZGluZyBjZWxsIGNvbnRlbnRzLlxuXG5cdFx0Y29uc3QgZnJhZyA9ICFpc0RldGVjdCAmJiBuZXcgQ0tFRElUT1IuZG9tLmRvY3VtZW50RnJhZ21lbnQoZG9jKTtcblxuXHRcdGxldCBkaW1lbnNpb24gPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y2VsbCA9IGNlbGxzW2ldO1xuXG5cdFx0XHRjb25zdCB0ciA9IGNlbGwuZ2V0UGFyZW50KCk7XG5cblx0XHRcdGNvbnN0IGNlbGxGaXJzdENoaWxkID0gY2VsbC5nZXRGaXJzdCgpO1xuXG5cdFx0XHRjb25zdCBjb2xTcGFuID0gY2VsbC4kLmNvbFNwYW47XG5cblx0XHRcdGNvbnN0IHJvd1NwYW4gPSBjZWxsLiQucm93U3BhbjtcblxuXHRcdFx0Y29uc3Qgcm93SW5kZXggPSB0ci4kLnJvd0luZGV4O1xuXG5cdFx0XHRjb25zdCBjb2xJbmRleCA9IGNlbGxJblJvdyhtYXAsIHJvd0luZGV4LCBjZWxsKTtcblxuXHRcdFx0Ly8gQWNjdW11bGF0ZWQgdGhlIGFjdHVhbCBwbGFjZXMgdGFrZW4gYnkgYWxsIHNlbGVjdGVkIGNlbGxzLlxuXHRcdFx0ZGltZW5zaW9uICs9IGNvbFNwYW4gKiByb3dTcGFuO1xuXHRcdFx0Ly8gQWNjdW11bGF0ZWQgdGhlIG1heGltdW0gdmlydHVhbCBzcGFucyBmcm9tIGNvbHVtbiBhbmQgcm93LlxuXHRcdFx0dG90YWxDb2xTcGFuID0gTWF0aC5tYXgoXG5cdFx0XHRcdHRvdGFsQ29sU3Bhbixcblx0XHRcdFx0Y29sSW5kZXggLSBzdGFydENvbHVtbiArIGNvbFNwYW5cblx0XHRcdCk7XG5cdFx0XHR0b3RhbFJvd1NwYW4gPSBNYXRoLm1heChcblx0XHRcdFx0dG90YWxSb3dTcGFuLFxuXHRcdFx0XHRyb3dJbmRleCAtIHN0YXJ0Um93ICsgcm93U3BhblxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKCFpc0RldGVjdCkge1xuXHRcdFx0XHQvLyBUcmltIGFsbCBjZWxsIGZpbGxlcnMgYW5kIGNoZWNrIHRvIHJlbW92ZSBlbXB0eSBjZWxscy5cblx0XHRcdFx0aWYgKCh0cmltQ2VsbChjZWxsKSwgY2VsbC5nZXRDaGlsZHJlbigpLmNvdW50KCkpKSB7XG5cdFx0XHRcdFx0Ly8gTWVyZ2UgdmVydGljYWxseSBjZWxscyBhcyB0d28gc2VwYXJhdGVkIHBhcmFncmFwaHMuXG5cdFx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdFx0cm93SW5kZXggIT0gbGFzdFJvd0luZGV4ICYmXG5cdFx0XHRcdFx0XHRjZWxsRmlyc3RDaGlsZCAmJlxuXHRcdFx0XHRcdFx0IShcblx0XHRcdFx0XHRcdFx0Y2VsbEZpcnN0Q2hpbGQuaXNCbG9ja0JvdW5kYXJ5ICYmXG5cdFx0XHRcdFx0XHRcdGNlbGxGaXJzdENoaWxkLmlzQmxvY2tCb3VuZGFyeSh7YnI6IDF9KVxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0Y29uc3QgbGFzdCA9IGZyYWcuZ2V0TGFzdChcblx0XHRcdFx0XHRcdFx0Q0tFRElUT1IuZG9tLndhbGtlci53aGl0ZXNwYWNlcyh0cnVlKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdGlmIChsYXN0ICYmICEobGFzdC5pcyAmJiBsYXN0LmlzKCdicicpKSlcblx0XHRcdFx0XHRcdFx0ZnJhZy5hcHBlbmQoJ2JyJyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Y2VsbC5tb3ZlQ2hpbGRyZW4oZnJhZyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGkpIHtcblx0XHRcdFx0XHRjZWxsLnJlbW92ZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNlbGwuc2V0SHRtbCgnJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGxhc3RSb3dJbmRleCA9IHJvd0luZGV4O1xuXHRcdH1cblxuXHRcdGlmICghaXNEZXRlY3QpIHtcblx0XHRcdGZyYWcubW92ZUNoaWxkcmVuKGZpcnN0Q2VsbCk7XG5cblx0XHRcdGZpcnN0Q2VsbC5hcHBlbmRCb2d1cygpO1xuXG5cdFx0XHRpZiAodG90YWxDb2xTcGFuID49IG1hcFdpZHRoKSBmaXJzdENlbGwucmVtb3ZlQXR0cmlidXRlKCdyb3dTcGFuJyk7XG5cdFx0XHRlbHNlIGZpcnN0Q2VsbC4kLnJvd1NwYW4gPSB0b3RhbFJvd1NwYW47XG5cblx0XHRcdGlmICh0b3RhbFJvd1NwYW4gPj0gbWFwSGVpZ2h0KSBmaXJzdENlbGwucmVtb3ZlQXR0cmlidXRlKCdjb2xTcGFuJyk7XG5cdFx0XHRlbHNlIGZpcnN0Q2VsbC4kLmNvbFNwYW4gPSB0b3RhbENvbFNwYW47XG5cblx0XHRcdC8vIFN3aXAgZW1wdHkgPHRyPiBsZWZ0IGF0IHRoZSBlbmQgb2YgdGFibGUgZHVlIHRvIHRoZSBtZXJnaW5nLlxuXHRcdFx0Y29uc3QgdHJzID0gbmV3IENLRURJVE9SLmRvbS5ub2RlTGlzdCh0YWJsZS4kLnJvd3MpO1xuXG5cdFx0XHRsZXQgY291bnQgPSB0cnMuY291bnQoKTtcblxuXHRcdFx0Zm9yIChsZXQgaSA9IGNvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0Y29uc3QgdGFpbFRyID0gdHJzLmdldEl0ZW0oaSk7XG5cdFx0XHRcdGlmICghdGFpbFRyLiQuY2VsbHMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dGFpbFRyLnJlbW92ZSgpO1xuXHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZpcnN0Q2VsbDtcblx0XHR9XG5cdFx0Ly8gQmUgYWJsZSB0byBtZXJnZSBjZWxscyBvbmx5IGlmIGFjdHVhbCBkaW1lbnNpb24gb2Ygc2VsZWN0ZWRcblx0XHQvLyBjZWxscyBlcXVhbHMgdG8gdGhlIGNhY3VsYXRlZCByZWN0YW5nbGUuXG5cdFx0ZWxzZSB7XG5cdFx0XHRyZXR1cm4gdG90YWxSb3dTcGFuICogdG90YWxDb2xTcGFuID09IGRpbWVuc2lvbjtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiB2ZXJ0aWNhbFNwbGl0Q2VsbChzZWxlY3Rpb24sIGlzRGV0ZWN0KSB7XG5cdFx0Y29uc3QgY2VsbHMgPSBnZXRTZWxlY3RlZENlbGxzKHNlbGVjdGlvbik7XG5cdFx0aWYgKGNlbGxzLmxlbmd0aCA+IDEpIHJldHVybiBmYWxzZTtcblx0XHRlbHNlIGlmIChpc0RldGVjdCkgcmV0dXJuIHRydWU7XG5cblx0XHRjb25zdCBjZWxsID0gY2VsbHNbMF07XG5cblx0XHRjb25zdCB0ciA9IGNlbGwuZ2V0UGFyZW50KCk7XG5cblx0XHRjb25zdCB0YWJsZSA9IHRyLmdldEFzY2VuZGFudCgndGFibGUnKTtcblxuXHRcdGNvbnN0IG1hcCA9IENLRURJVE9SLnRvb2xzLmJ1aWxkVGFibGVNYXAodGFibGUpO1xuXG5cdFx0Y29uc3Qgcm93SW5kZXggPSB0ci4kLnJvd0luZGV4O1xuXG5cdFx0Y29uc3QgY29sSW5kZXggPSBjZWxsSW5Sb3cobWFwLCByb3dJbmRleCwgY2VsbCk7XG5cblx0XHRjb25zdCByb3dTcGFuID0gY2VsbC4kLnJvd1NwYW47XG5cblx0XHRsZXQgbmV3Q2VsbDtcblxuXHRcdGxldCBuZXdSb3dTcGFuO1xuXG5cdFx0bGV0IG5ld0NlbGxSb3dTcGFuO1xuXG5cdFx0bGV0IG5ld1Jvd0luZGV4O1xuXG5cdFx0aWYgKHJvd1NwYW4gPiAxKSB7XG5cdFx0XHRuZXdSb3dTcGFuID0gTWF0aC5jZWlsKHJvd1NwYW4gLyAyKTtcblx0XHRcdG5ld0NlbGxSb3dTcGFuID0gTWF0aC5mbG9vcihyb3dTcGFuIC8gMik7XG5cdFx0XHRuZXdSb3dJbmRleCA9IHJvd0luZGV4ICsgbmV3Um93U3Bhbjtcblx0XHRcdGNvbnN0IG5ld0NlbGxUciA9IG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChcblx0XHRcdFx0dGFibGUuJC5yb3dzW25ld1Jvd0luZGV4XVxuXHRcdFx0KTtcblxuXHRcdFx0Y29uc3QgbmV3Q2VsbFJvdyA9IGNlbGxJblJvdyhtYXAsIG5ld1Jvd0luZGV4KTtcblxuXHRcdFx0bGV0IGNhbmRpZGF0ZUNlbGw7XG5cblx0XHRcdG5ld0NlbGwgPSBjZWxsLmNsb25lKCk7XG5cblx0XHRcdC8vIEZpZ3VyZSBvdXQgd2hlcmUgdG8gaW5zZXJ0IHRoZSBuZXcgY2VsbCBieSBjaGVja2luZyB0aGUgdml0dWFsIHJvdy5cblx0XHRcdGZvciAobGV0IGMgPSAwOyBjIDwgbmV3Q2VsbFJvdy5sZW5ndGg7IGMrKykge1xuXHRcdFx0XHRjYW5kaWRhdGVDZWxsID0gbmV3Q2VsbFJvd1tjXTtcblx0XHRcdFx0Ly8gQ2F0Y2ggZmlyc3QgY2VsbCBhY3R1YWxseSBmb2xsb3dpbmcgdGhlIGNvbHVtbi5cblx0XHRcdFx0aWYgKGNhbmRpZGF0ZUNlbGwucGFyZW50Tm9kZSA9PSBuZXdDZWxsVHIuJCAmJiBjID4gY29sSW5kZXgpIHtcblx0XHRcdFx0XHRuZXdDZWxsLmluc2VydEJlZm9yZShcblx0XHRcdFx0XHRcdG5ldyBDS0VESVRPUi5kb20uZWxlbWVudChjYW5kaWRhdGVDZWxsKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2FuZGlkYXRlQ2VsbCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGRlc3RpbmF0aW9uIHJvdyBpcyBlbXB0eSwgYXBwZW5kIGF0IHdpbGwuXG5cdFx0XHRpZiAoIWNhbmRpZGF0ZUNlbGwpIG5ld0NlbGxUci5hcHBlbmQobmV3Q2VsbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld0NlbGxSb3dTcGFuID0gbmV3Um93U3BhbiA9IDE7XG5cblx0XHRcdGNvbnN0IG5ld0NlbGxUciA9IHRyLmNsb25lKCk7XG5cdFx0XHRuZXdDZWxsVHIuaW5zZXJ0QWZ0ZXIodHIpO1xuXHRcdFx0bmV3Q2VsbFRyLmFwcGVuZCgobmV3Q2VsbCA9IGNlbGwuY2xvbmUoKSkpO1xuXG5cdFx0XHRjb25zdCBjZWxsc0luU2FtZVJvdyA9IGNlbGxJblJvdyhtYXAsIHJvd0luZGV4KTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHNJblNhbWVSb3cubGVuZ3RoOyBpKyspXG5cdFx0XHRcdGNlbGxzSW5TYW1lUm93W2ldLnJvd1NwYW4rKztcblx0XHR9XG5cblx0XHRuZXdDZWxsLmFwcGVuZEJvZ3VzKCk7XG5cblx0XHRjZWxsLiQucm93U3BhbiA9IG5ld1Jvd1NwYW47XG5cdFx0bmV3Q2VsbC4kLnJvd1NwYW4gPSBuZXdDZWxsUm93U3Bhbjtcblx0XHRpZiAobmV3Um93U3BhbiA9PSAxKSBjZWxsLnJlbW92ZUF0dHJpYnV0ZSgncm93U3BhbicpO1xuXHRcdGlmIChuZXdDZWxsUm93U3BhbiA9PSAxKSBuZXdDZWxsLnJlbW92ZUF0dHJpYnV0ZSgncm93U3BhbicpO1xuXG5cdFx0cmV0dXJuIG5ld0NlbGw7XG5cdH1cblxuXHRmdW5jdGlvbiBob3Jpem9udGFsU3BsaXRDZWxsKHNlbGVjdGlvbiwgaXNEZXRlY3QpIHtcblx0XHRjb25zdCBjZWxscyA9IGdldFNlbGVjdGVkQ2VsbHMoc2VsZWN0aW9uKTtcblx0XHRpZiAoY2VsbHMubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlO1xuXHRcdGVsc2UgaWYgKGlzRGV0ZWN0KSByZXR1cm4gdHJ1ZTtcblxuXHRcdGNvbnN0IGNlbGwgPSBjZWxsc1swXTtcblxuXHRcdGNvbnN0IHRyID0gY2VsbC5nZXRQYXJlbnQoKTtcblxuXHRcdGNvbnN0IHRhYmxlID0gdHIuZ2V0QXNjZW5kYW50KCd0YWJsZScpO1xuXG5cdFx0Y29uc3QgbWFwID0gQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCh0YWJsZSk7XG5cblx0XHRjb25zdCByb3dJbmRleCA9IHRyLiQucm93SW5kZXg7XG5cblx0XHRjb25zdCBjb2xJbmRleCA9IGNlbGxJblJvdyhtYXAsIHJvd0luZGV4LCBjZWxsKTtcblxuXHRcdGNvbnN0IGNvbFNwYW4gPSBjZWxsLiQuY29sU3BhbjtcblxuXHRcdGxldCBuZXdDb2xTcGFuO1xuXG5cdFx0bGV0IG5ld0NlbGxDb2xTcGFuO1xuXG5cdFx0aWYgKGNvbFNwYW4gPiAxKSB7XG5cdFx0XHRuZXdDb2xTcGFuID0gTWF0aC5jZWlsKGNvbFNwYW4gLyAyKTtcblx0XHRcdG5ld0NlbGxDb2xTcGFuID0gTWF0aC5mbG9vcihjb2xTcGFuIC8gMik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld0NlbGxDb2xTcGFuID0gbmV3Q29sU3BhbiA9IDE7XG5cdFx0XHRjb25zdCBjZWxsc0luU2FtZUNvbCA9IGNlbGxJbkNvbChtYXAsIGNvbEluZGV4KTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHNJblNhbWVDb2wubGVuZ3RoOyBpKyspXG5cdFx0XHRcdGNlbGxzSW5TYW1lQ29sW2ldLmNvbFNwYW4rKztcblx0XHR9XG5cdFx0Y29uc3QgbmV3Q2VsbCA9IGNlbGwuY2xvbmUoKTtcblx0XHRuZXdDZWxsLmluc2VydEFmdGVyKGNlbGwpO1xuXHRcdG5ld0NlbGwuYXBwZW5kQm9ndXMoKTtcblxuXHRcdGNlbGwuJC5jb2xTcGFuID0gbmV3Q29sU3Bhbjtcblx0XHRuZXdDZWxsLiQuY29sU3BhbiA9IG5ld0NlbGxDb2xTcGFuO1xuXHRcdGlmIChuZXdDb2xTcGFuID09IDEpIGNlbGwucmVtb3ZlQXR0cmlidXRlKCdjb2xTcGFuJyk7XG5cdFx0aWYgKG5ld0NlbGxDb2xTcGFuID09IDEpIG5ld0NlbGwucmVtb3ZlQXR0cmlidXRlKCdjb2xTcGFuJyk7XG5cblx0XHRyZXR1cm4gbmV3Q2VsbDtcblx0fVxuXG5cdENLRURJVE9SLnBsdWdpbnMuYWRkKCdhZV90YWJsZXRvb2xzJywge1xuXHRcdGluaXQoZWRpdG9yKSB7XG5cdFx0XHRmdW5jdGlvbiBjcmVhdGVEZWYoZGVmKSB7XG5cdFx0XHRcdHJldHVybiBDS0VESVRPUi50b29scy5leHRlbmQoZGVmIHx8IHt9LCB7XG5cdFx0XHRcdFx0Y29udGV4dFNlbnNpdGl2ZTogMSxcblx0XHRcdFx0XHRyZWZyZXNoKGVkaXRvciwgcGF0aCkge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXRTdGF0ZShcblx0XHRcdFx0XHRcdFx0cGF0aC5jb250YWlucyh7dGQ6IDEsIHRoOiAxfSwgMSlcblx0XHRcdFx0XHRcdFx0XHQ/IENLRURJVE9SLlRSSVNUQVRFX09GRlxuXHRcdFx0XHRcdFx0XHRcdDogQ0tFRElUT1IuVFJJU1RBVEVfRElTQUJMRURcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRmdW5jdGlvbiBhZGRDbWQobmFtZSwgZGVmKSB7XG5cdFx0XHRcdGxldCBjbWQgPSBlZGl0b3IuZ2V0Q29tbWFuZChuYW1lKTtcblxuXHRcdFx0XHRpZiAoY21kKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y21kID0gZWRpdG9yLmFkZENvbW1hbmQobmFtZSwgZGVmKTtcblx0XHRcdFx0ZWRpdG9yLmFkZEZlYXR1cmUoY21kKTtcblx0XHRcdH1cblxuXHRcdFx0YWRkQ21kKFxuXHRcdFx0XHQncm93RGVsZXRlJyxcblx0XHRcdFx0Y3JlYXRlRGVmKHtcblx0XHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0YWJsZScsXG5cdFx0XHRcdFx0ZXhlYyhlZGl0b3IpIHtcblx0XHRcdFx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb24oKTtcblx0XHRcdFx0XHRcdHBsYWNlQ3Vyc29ySW5DZWxsKGRlbGV0ZVJvd3Moc2VsZWN0aW9uKSk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRcdGFkZENtZChcblx0XHRcdFx0J3Jvd0luc2VydEJlZm9yZScsXG5cdFx0XHRcdGNyZWF0ZURlZih7XG5cdFx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRcdGV4ZWMoZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0XHRpbnNlcnRSb3coc2VsZWN0aW9uLCB0cnVlKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdFx0YWRkQ21kKFxuXHRcdFx0XHQncm93SW5zZXJ0QWZ0ZXInLFxuXHRcdFx0XHRjcmVhdGVEZWYoe1xuXHRcdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0XHRleGVjKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdFx0aW5zZXJ0Um93KHNlbGVjdGlvbik7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRcdGFkZENtZChcblx0XHRcdFx0J2NvbHVtbkRlbGV0ZScsXG5cdFx0XHRcdGNyZWF0ZURlZih7XG5cdFx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRcdGV4ZWMoZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0XHRjb25zdCBlbGVtZW50ID0gZGVsZXRlQ29sdW1ucyhzZWxlY3Rpb24pO1xuXHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoZWxlbWVudCwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRcdGFkZENtZChcblx0XHRcdFx0J2NvbHVtbkluc2VydEJlZm9yZScsXG5cdFx0XHRcdGNyZWF0ZURlZih7XG5cdFx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRcdGV4ZWMoZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0XHRpbnNlcnRDb2x1bW4oc2VsZWN0aW9uLCB0cnVlKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdFx0YWRkQ21kKFxuXHRcdFx0XHQnY29sdW1uSW5zZXJ0QWZ0ZXInLFxuXHRcdFx0XHRjcmVhdGVEZWYoe1xuXHRcdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0XHRleGVjKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdFx0aW5zZXJ0Q29sdW1uKHNlbGVjdGlvbik7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRcdGFkZENtZChcblx0XHRcdFx0J2NlbGxEZWxldGUnLFxuXHRcdFx0XHRjcmVhdGVEZWYoe1xuXHRcdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RhYmxlJyxcblx0XHRcdFx0XHRleGVjKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuXHRcdFx0XHRcdFx0ZGVsZXRlQ2VsbHMoc2VsZWN0aW9uKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdFx0YWRkQ21kKFxuXHRcdFx0XHQnY2VsbE1lcmdlJyxcblx0XHRcdFx0Y3JlYXRlRGVmKHtcblx0XHRcdFx0XHRhbGxvd2VkQ29udGVudDogJ3RkW2NvbHNwYW4scm93c3Bhbl0nLFxuXHRcdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RkW2NvbHNwYW4scm93c3Bhbl0nLFxuXHRcdFx0XHRcdGV4ZWMoZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRwbGFjZUN1cnNvckluQ2VsbChcblx0XHRcdFx0XHRcdFx0bWVyZ2VDZWxscyhlZGl0b3IuZ2V0U2VsZWN0aW9uKCkpLFxuXHRcdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0XHRhZGRDbWQoXG5cdFx0XHRcdCdjZWxsTWVyZ2VSaWdodCcsXG5cdFx0XHRcdGNyZWF0ZURlZih7XG5cdFx0XHRcdFx0YWxsb3dlZENvbnRlbnQ6ICd0ZFtjb2xzcGFuXScsXG5cdFx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGRbY29sc3Bhbl0nLFxuXHRcdFx0XHRcdGV4ZWMoZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRwbGFjZUN1cnNvckluQ2VsbChcblx0XHRcdFx0XHRcdFx0bWVyZ2VDZWxscyhlZGl0b3IuZ2V0U2VsZWN0aW9uKCksICdyaWdodCcpLFxuXHRcdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdH0pXG5cdFx0XHQpO1xuXG5cdFx0XHRhZGRDbWQoXG5cdFx0XHRcdCdjZWxsTWVyZ2VEb3duJyxcblx0XHRcdFx0Y3JlYXRlRGVmKHtcblx0XHRcdFx0XHRhbGxvd2VkQ29udGVudDogJ3RkW3Jvd3NwYW5dJyxcblx0XHRcdFx0XHRyZXF1aXJlZENvbnRlbnQ6ICd0ZFtyb3dzcGFuXScsXG5cdFx0XHRcdFx0ZXhlYyhlZGl0b3IpIHtcblx0XHRcdFx0XHRcdHBsYWNlQ3Vyc29ySW5DZWxsKFxuXHRcdFx0XHRcdFx0XHRtZXJnZUNlbGxzKGVkaXRvci5nZXRTZWxlY3Rpb24oKSwgJ2Rvd24nKSxcblx0XHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdFx0YWRkQ21kKFxuXHRcdFx0XHQnY2VsbFZlcnRpY2FsU3BsaXQnLFxuXHRcdFx0XHRjcmVhdGVEZWYoe1xuXHRcdFx0XHRcdGFsbG93ZWRDb250ZW50OiAndGRbcm93c3Bhbl0nLFxuXHRcdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RkW3Jvd3NwYW5dJyxcblx0XHRcdFx0XHRleGVjKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoXG5cdFx0XHRcdFx0XHRcdHZlcnRpY2FsU3BsaXRDZWxsKGVkaXRvci5nZXRTZWxlY3Rpb24oKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRcdGFkZENtZChcblx0XHRcdFx0J2NlbGxIb3Jpem9udGFsU3BsaXQnLFxuXHRcdFx0XHRjcmVhdGVEZWYoe1xuXHRcdFx0XHRcdGFsbG93ZWRDb250ZW50OiAndGRbY29sc3Bhbl0nLFxuXHRcdFx0XHRcdHJlcXVpcmVkQ29udGVudDogJ3RkW2NvbHNwYW5dJyxcblx0XHRcdFx0XHRleGVjKGVkaXRvcikge1xuXHRcdFx0XHRcdFx0cGxhY2VDdXJzb3JJbkNlbGwoXG5cdFx0XHRcdFx0XHRcdGhvcml6b250YWxTcGxpdENlbGwoZWRpdG9yLmdldFNlbGVjdGlvbigpKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9KVxuXHRcdFx0KTtcblxuXHRcdFx0YWRkQ21kKFxuXHRcdFx0XHQnY2VsbEluc2VydEJlZm9yZScsXG5cdFx0XHRcdGNyZWF0ZURlZih7XG5cdFx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRcdGV4ZWMoZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0XHRpbnNlcnRDZWxsKHNlbGVjdGlvbiwgdHJ1ZSk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cblx0XHRcdGFkZENtZChcblx0XHRcdFx0J2NlbGxJbnNlcnRBZnRlcicsXG5cdFx0XHRcdGNyZWF0ZURlZih7XG5cdFx0XHRcdFx0cmVxdWlyZWRDb250ZW50OiAndGFibGUnLFxuXHRcdFx0XHRcdGV4ZWMoZWRpdG9yKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCk7XG5cdFx0XHRcdFx0XHRpbnNlcnRDZWxsKHNlbGVjdGlvbik7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0fSlcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdGdldFNlbGVjdGVkQ2VsbHMsXG5cdH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHR3by1kaW1lbnNpb24gYXJyYXkgdGhhdCByZWZsZWN0cyB0aGUgYWN0dWFsIGxheW91dCBvZiB0YWJsZSBjZWxscyxcbiAqIHdpdGggY2VsbCBzcGFucywgd2l0aCBtYXBwaW5ncyB0byB0aGUgb3JpZ2luYWwgdGQgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtDS0VESVRPUi5kb20uZWxlbWVudH0gdGFibGVcbiAqIEBtZW1iZXIgQ0tFRElUT1IudG9vbHNcbiAqL1xuQ0tFRElUT1IudG9vbHMuYnVpbGRUYWJsZU1hcCA9IGZ1bmN0aW9uKHRhYmxlKSB7XG5cdGNvbnN0IGFSb3dzID0gdGFibGUuJC5yb3dzO1xuXG5cdC8vIFJvdyBhbmQgQ29sdW1uIGNvdW50ZXJzLlxuXHRsZXQgciA9IC0xO1xuXG5cdGNvbnN0IGFNYXAgPSBbXTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGFSb3dzLmxlbmd0aDsgaSsrKSB7XG5cdFx0cisrO1xuXHRcdGlmICghYU1hcFtyXSkge1xuXHRcdFx0YU1hcFtyXSA9IFtdO1xuXHRcdH1cblxuXHRcdGxldCBjID0gLTE7XG5cblx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGFSb3dzW2ldLmNlbGxzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRjb25zdCBvQ2VsbCA9IGFSb3dzW2ldLmNlbGxzW2pdO1xuXG5cdFx0XHRjKys7XG5cdFx0XHR3aGlsZSAoYU1hcFtyXVtjXSkgYysrO1xuXG5cdFx0XHRjb25zdCBpQ29sU3BhbiA9IGlzTmFOKG9DZWxsLmNvbFNwYW4pID8gMSA6IG9DZWxsLmNvbFNwYW47XG5cdFx0XHRjb25zdCBpUm93U3BhbiA9IGlzTmFOKG9DZWxsLnJvd1NwYW4pID8gMSA6IG9DZWxsLnJvd1NwYW47XG5cblx0XHRcdGZvciAobGV0IHJzID0gMDsgcnMgPCBpUm93U3BhbjsgcnMrKykge1xuXHRcdFx0XHRpZiAoIWFNYXBbciArIHJzXSkgYU1hcFtyICsgcnNdID0gW107XG5cblx0XHRcdFx0Zm9yIChsZXQgY3MgPSAwOyBjcyA8IGlDb2xTcGFuOyBjcysrKSB7XG5cdFx0XHRcdFx0YU1hcFtyICsgcnNdW2MgKyBjc10gPSBhUm93c1tpXS5jZWxsc1tqXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjICs9IGlDb2xTcGFuIC0gMTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFNYXA7XG59O1xuIiwiY29uc3QgdGFibGVTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXMgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuICdhZS1hcnJvdy1ib3ggYWUtYXJyb3ctYm94LWJvdHRvbSc7XG59O1xuXG5jb25zdCBTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXMgPSB7XG5cdHRhYmxlOiB0YWJsZVNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3Nlcyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3NlcztcbiIsImltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vLyBEZWZhdWx0IGd1dHRlciB2YWx1ZSBmb3IgdG9vbGJhciBwb3NpdGlvbmluZ1xuY29uc3QgREVGQVVMVF9HVVRURVIgPSB7XG5cdGxlZnQ6IDAsXG5cdHRvcDogMCxcbn07XG5cbi8qKlxuICogQ2VudGVycyBhIFRvb2xiYXIgYWNjb3JkaW5nIHRvIGdpdmVuIHJlY3RhbmdsZVxuICpcbiAqIEBtZXRob2QgY2VudGVyVG9vbGJhclxuICogQHBhcmFtIHtPYmplY3R9IHRvb2xiYXIgVGhlIHRvb2xiYXIgdG8gYmUgY2VudGVyZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IFRoZSByZWN0YW5nbGUgYWNjb3JkaW5nIHRvIHdoaWNoIHRoZSBUb29sYmFyIHdpbGwgYmUgY2VudGVyZWRcbiAqL1xuY29uc3QgY2VudGVyVG9vbGJhciA9IGZ1bmN0aW9uKHRvb2xiYXIsIHJlY3QpIHtcblx0Y29uc3QgdG9vbGJhck5vZGUgPSBSZWFjdERPTS5maW5kRE9NTm9kZSh0b29sYmFyKTtcblxuXHRjb25zdCBuYXRpdmVFZGl0b3IgPSB0b29sYmFyLmNvbnRleHQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdGNvbnN0IHVpTm9kZSA9IG5hdGl2ZUVkaXRvci5jb25maWcudWlOb2RlIHx8IGRvY3VtZW50LmJvZHk7XG5cdGNvbnN0IHVpTm9kZVN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh1aU5vZGUpO1xuXHRjb25zdCB1aU5vZGVNYXJnaW5MZWZ0ID0gcGFyc2VJbnQoXG5cdFx0dWlOb2RlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnbWFyZ2luLWxlZnQnKSxcblx0XHQxMFxuXHQpO1xuXHRjb25zdCB1aU5vZGVNYXJnaW5SaWdodCA9IHBhcnNlSW50KFxuXHRcdHVpTm9kZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ21hcmdpbi1yaWdodCcpLFxuXHRcdDEwXG5cdCk7XG5cdGNvbnN0IHRvdGFsV2lkdGggPVxuXHRcdHVpTm9kZU1hcmdpbkxlZnQgKyB1aU5vZGUuY2xpZW50V2lkdGggKyB1aU5vZGVNYXJnaW5SaWdodDtcblxuXHRjb25zdCBoYWxmTm9kZVdpZHRoID0gdG9vbGJhck5vZGUub2Zmc2V0V2lkdGggLyAyO1xuXHRjb25zdCBzY3JvbGxQb3NpdGlvbiA9IG5ldyBDS0VESVRPUi5kb20ud2luZG93KHdpbmRvdykuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcblxuXHRjb25zdCBndXR0ZXIgPSB0b29sYmFyLnByb3BzLmd1dHRlciB8fCBERUZBVUxUX0dVVFRFUjtcblxuXHRjb25zdCB3aWRnZXRYWSA9IHRvb2xiYXIuZ2V0V2lkZ2V0WFlQb2ludChcblx0XHRyZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMiAtIHNjcm9sbFBvc2l0aW9uLngsXG5cdFx0cmVjdC50b3AgKyBzY3JvbGxQb3NpdGlvbi55LFxuXHRcdENLRURJVE9SLlNFTEVDVElPTl9CT1RUT01fVE9fVE9QXG5cdCk7XG5cblx0Y29uc3QgZW5kUG9zaXRpb24gPSBbXG5cdFx0cmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAvIDIgLSBoYWxmTm9kZVdpZHRoIC0gc2Nyb2xsUG9zaXRpb24ueCxcblx0XHRyZWN0LnRvcCAtIHRvb2xiYXJOb2RlLm9mZnNldEhlaWdodCArIHNjcm9sbFBvc2l0aW9uLnkgLSBndXR0ZXIudG9wLFxuXHRdO1xuXG5cdGlmIChlbmRQb3NpdGlvblswXSA8IDApIHtcblx0XHRlbmRQb3NpdGlvblswXSA9IDA7XG5cdH0gZWxzZSBpZiAoZW5kUG9zaXRpb25bMF0gPiB0b3RhbFdpZHRoIC0gdG9vbGJhck5vZGUub2Zmc2V0V2lkdGgpIHtcblx0XHRlbmRQb3NpdGlvblswXSA9IHRvdGFsV2lkdGggLSB0b29sYmFyTm9kZS5vZmZzZXRXaWR0aDtcblx0fVxuXG5cdHRvb2xiYXIubW92ZVRvUG9pbnQod2lkZ2V0WFksIGVuZFBvc2l0aW9uKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcG9zaXRpb24gb2YgYSB0b29sYmFyIGFjY29yZGluZyB0byB0aGUgcG9zaXRpb24gb2YgdGhlIHNlbGVjdGVkIGltYWdlXG4gKlxuICogQG1ldGhvZCBpbWFnZVNlbGVjdGlvblNldFBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcGF5bG9hZCBQYXlsb2FkLCBzaG91bGQgY29udGFpbiB0aGUgc2VsZWN0aW9uIGRhdGEgZm9yIHJldHJpZXZpbmcgdGhlXG4gKiBjbGllbnQgcmVjdGFuZ2xlIG9mIHRoZSBzZWxlY3RlZCBpbWFnZVxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSwgaW4gYWxsIGNhc2VzXG4gKi9cbmNvbnN0IGltYWdlU2VsZWN0aW9uU2V0UG9zaXRpb24gPSBmdW5jdGlvbihwYXlsb2FkKSB7XG5cdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBwYXlsb2FkLnNlbGVjdGlvbkRhdGFcblx0XHQ/IHBheWxvYWQuc2VsZWN0aW9uRGF0YVxuXHRcdDogcGF5bG9hZC5lZGl0b3JFdmVudFxuXHRcdD8gcGF5bG9hZC5lZGl0b3JFdmVudC5kYXRhLnNlbGVjdGlvbkRhdGFcblx0XHQ6IG51bGw7XG5cblx0aWYgKHNlbGVjdGlvbkRhdGEgJiYgc2VsZWN0aW9uRGF0YS5lbGVtZW50KSB7XG5cdFx0Y2VudGVyVG9vbGJhcih0aGlzLCBzZWxlY3Rpb25EYXRhLmVsZW1lbnQuZ2V0Q2xpZW50UmVjdCgpKTtcblxuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIGEgdG9vbGJhciBhY2NvcmRpbmcgdG8gdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWxlY3RlZCBpbWFnZVxuICpcbiAqIEBtZXRob2QgdGFibGVTZWxlY3Rpb25TZXRQb3NpdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgT2JqZWN0LCB3aGljaCBjb250YWlucyB0aGUgc2VsZWN0aW9uIGRhdGEgZm9yIHJldHJpZXZpbmcgdGhlXG4gKiBjbGllbnQgcmVjdGFuZ2xlIG9mIHRoZSBzZWxlY3RlZCB0YWJsZVxuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSwgaW4gYWxsIGNhc2VzXG4gKi9cbmNvbnN0IHRhYmxlU2VsZWN0aW9uU2V0UG9zaXRpb24gPSBmdW5jdGlvbihwYXlsb2FkKSB7XG5cdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHBheWxvYWQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdGNvbnN0IHVpTm9kZSA9IG5hdGl2ZUVkaXRvci5jb25maWcudWlOb2RlO1xuXG5cdGNvbnN0IHNjcm9sbFRvcCA9IHVpTm9kZSA/IHVpTm9kZS5zY3JvbGxUb3AgOiAwO1xuXG5cdGNvbnN0IHRhYmxlID0gbmV3IENLRURJVE9SLlRhYmxlKG5hdGl2ZUVkaXRvcikuZ2V0RnJvbVNlbGVjdGlvbigpO1xuXHRjb25zdCByZWN0ID0gdGFibGUuZ2V0Q2xpZW50UmVjdCgpO1xuXHRyZWN0LnRvcCArPSBzY3JvbGxUb3A7XG5cblx0Y2VudGVyVG9vbGJhcih0aGlzLCByZWN0KTtcblxuXHRyZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IFNlbGVjdGlvblNldFBvc2l0aW9uID0ge1xuXHRpbWFnZTogaW1hZ2VTZWxlY3Rpb25TZXRQb3NpdGlvbixcblx0dGFibGU6IHRhYmxlU2VsZWN0aW9uU2V0UG9zaXRpb24sXG59O1xuXG5leHBvcnQgZGVmYXVsdCBTZWxlY3Rpb25TZXRQb3NpdGlvbjtcbiIsImNvbnN0IF9pc1JhbmdlQXRFbGVtZW50RW5kID0gZnVuY3Rpb24ocmFuZ2UsIGVsZW1lbnQpIHtcblx0Ly8gRmluZGluZyBpZiBhIHJhbmdlIGlzIGF0IHRoZSBlbmQgb2YgYW4gZWxlbWVudCBpcyBzb21ld2hhdCB0cmlja3kgZHVlIHRvIGhvdyBDS0VkaXRvciBoYW5kbGVzXG5cdC8vIHJhbmdlcy4gSXQgbWlnaHQgZGVwZW5kIG9uIHdldGhlciBhIHNvdXJjZSBub2RlIGluc2lkZSB0aGUgZWxlbWVudCBpcyBzZWxlY3RlZCBvciBub3QuIEZvciBub3csXG5cdC8vIHdlIG5lZWQgdG8gY292ZXIgdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly9cblx0Ly8gLSBUaGUgdGV4dCBsZW5ndGggb2YgdGhlIGVsZW1lbnQgaXMgdGhlIHNhbWUgYXMgdGhlIGVuZE9mZnNldCBvZiB0aGUgcmFuZ2Vcblx0Ly8gLSBCb3RoIHN0YXJ0IGFuZCBlbmQgY29udGFpbmVycyBtYXRjaCB0aGUgZWxlbWVudCBhbmQgdGhlIHN0YXJ0IGFuZCBlbmQgb2Zmc2V0cyBhcmUgMVxuXG5cdHJldHVybiAoXG5cdFx0ZWxlbWVudC5nZXRUZXh0KCkubGVuZ3RoID09PSByYW5nZS5lbmRPZmZzZXQgfHxcblx0XHQoZWxlbWVudC5lcXVhbHMocmFuZ2Uuc3RhcnRDb250YWluZXIpICYmXG5cdFx0XHRlbGVtZW50LmVxdWFscyhyYW5nZS5lbmRDb250YWluZXIpICYmXG5cdFx0XHRyYW5nZS5zdGFydE9mZnNldCA9PT0gcmFuZ2UuZW5kT2Zmc2V0ICYmXG5cdFx0XHRyYW5nZS5lbmRPZmZzZXQgPT09IDEpXG5cdCk7XG59O1xuXG5jb25zdCBlbWJlZFNlbGVjdGlvblRlc3QgPSBmdW5jdGlvbihwYXlsb2FkKSB7XG5cdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBwYXlsb2FkLmRhdGEuc2VsZWN0aW9uRGF0YTtcblxuXHRyZXR1cm4gISEoXG5cdFx0c2VsZWN0aW9uRGF0YS5lbGVtZW50ICYmXG5cdFx0c2VsZWN0aW9uRGF0YS5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS13aWRnZXQnKSA9PT0gJ2FlX2VtYmVkJ1xuXHQpO1xufTtcblxuY29uc3QgZW1iZWRVcmxTZWxlY3Rpb25UZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuXHRjb25zdCBzZWxlY3Rpb25EYXRhID0gcGF5bG9hZC5kYXRhLnNlbGVjdGlvbkRhdGE7XG5cblx0cmV0dXJuICEhKFxuXHRcdHNlbGVjdGlvbkRhdGEuZWxlbWVudCAmJlxuXHRcdHNlbGVjdGlvbkRhdGEuZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtd2lkZ2V0JykgPT09ICdlbWJlZHVybCdcblx0KTtcbn07XG5cbmNvbnN0IGhlYWRpbmdUZXh0U2VsZWN0aW9uVGVzdCA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcblx0Y29uc3QgaGVhZGluZ3MgPSBbJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2J107XG5cdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHBheWxvYWQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBwYXlsb2FkLmRhdGEuc2VsZWN0aW9uRGF0YTtcblx0Y29uc3Qgc2VsZWN0aW9uRW1wdHkgPSBuYXRpdmVFZGl0b3IuaXNTZWxlY3Rpb25FbXB0eSgpO1xuXG5cdHJldHVybiAhIShcblx0XHQhc2VsZWN0aW9uRGF0YS5lbGVtZW50ICYmXG5cdFx0c2VsZWN0aW9uRGF0YS5yZWdpb24gJiZcblx0XHQhc2VsZWN0aW9uRW1wdHkgJiZcblx0XHQhbmF0aXZlRWRpdG9yXG5cdFx0XHQuZ2V0U2VsZWN0aW9uKClcblx0XHRcdC5nZXRDb21tb25BbmNlc3RvcigpXG5cdFx0XHQuaXNSZWFkT25seSgpICYmXG5cdFx0bmF0aXZlRWRpdG9yLmVsZW1lbnRQYXRoKCkuY29udGFpbnMoaGVhZGluZ3MpXG5cdCk7XG59O1xuXG5jb25zdCBsaW5rU2VsZWN0aW9uVGVzdCA9IGZ1bmN0aW9uKHBheWxvYWQpIHtcblx0Y29uc3QgbmF0aXZlRWRpdG9yID0gcGF5bG9hZC5lZGl0b3IuZ2V0KCduYXRpdmVFZGl0b3InKTtcblx0Y29uc3QgcmFuZ2UgPSBuYXRpdmVFZGl0b3IuZ2V0U2VsZWN0aW9uKCkuZ2V0UmFuZ2VzKClbMF07XG5cdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBwYXlsb2FkLmRhdGEuc2VsZWN0aW9uRGF0YTtcblxuXHRjb25zdCBlbGVtZW50ID0gbmV3IENLRURJVE9SLkxpbmsobmF0aXZlRWRpdG9yKS5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cdGNvbnN0IGlzU2VsZWN0aW9uRW1wdHkgPSBuYXRpdmVFZGl0b3IuaXNTZWxlY3Rpb25FbXB0eSgpO1xuXHRjb25zdCBlbGVtZW50SXNOb3RJbWFnZSA9IHNlbGVjdGlvbkRhdGEuZWxlbWVudFxuXHRcdD8gc2VsZWN0aW9uRGF0YS5lbGVtZW50LmdldE5hbWUoKSAhPT0gJ2ltZydcblx0XHQ6IHRydWU7XG5cblx0cmV0dXJuICEhKFxuXHRcdGlzU2VsZWN0aW9uRW1wdHkgJiZcblx0XHRlbGVtZW50SXNOb3RJbWFnZSAmJlxuXHRcdGVsZW1lbnQgJiZcblx0XHRlbGVtZW50LmdldFRleHQoKS5sZW5ndGggIT09IHJhbmdlLmVuZE9mZnNldCAmJlxuXHRcdGVsZW1lbnQgJiZcblx0XHQhZWxlbWVudC5pc1JlYWRPbmx5KCkgJiZcblx0XHQhX2lzUmFuZ2VBdEVsZW1lbnRFbmQocmFuZ2UsIGVsZW1lbnQpXG5cdCk7XG59O1xuXG5jb25zdCBpbWFnZVNlbGVjdGlvblRlc3QgPSBmdW5jdGlvbihwYXlsb2FkKSB7XG5cdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBwYXlsb2FkLmRhdGEuc2VsZWN0aW9uRGF0YTtcblx0Y29uc3QgZWxlbWVudCA9IHNlbGVjdGlvbkRhdGEuZWxlbWVudDtcblx0Y29uc3QgaGFzSW1hZ2UgPSAhIWVsZW1lbnQgJiYgISFlbGVtZW50LmZpbmRPbmUoJ2ltZycpO1xuXHRjb25zdCBpc0ltYWdlID0gISFlbGVtZW50ICYmIGVsZW1lbnQuZ2V0TmFtZSgpID09PSAnaW1nJztcblxuXHRyZXR1cm4gISEoZWxlbWVudCAmJiAoaGFzSW1hZ2UgfHwgaXNJbWFnZSkpO1xufTtcblxuY29uc3QgdGV4dFNlbGVjdGlvblRlc3QgPSBmdW5jdGlvbihwYXlsb2FkKSB7XG5cdGNvbnN0IG5hdGl2ZUVkaXRvciA9IHBheWxvYWQuZWRpdG9yLmdldCgnbmF0aXZlRWRpdG9yJyk7XG5cblx0Y29uc3Qgc2VsZWN0aW9uRW1wdHkgPSBuYXRpdmVFZGl0b3IuaXNTZWxlY3Rpb25FbXB0eSgpO1xuXG5cdGNvbnN0IHNlbGVjdGlvbkRhdGEgPSBwYXlsb2FkLmRhdGEuc2VsZWN0aW9uRGF0YTtcblxuXHRyZXR1cm4gISEoXG5cdFx0IXNlbGVjdGlvbkRhdGEuZWxlbWVudCAmJlxuXHRcdHNlbGVjdGlvbkRhdGEucmVnaW9uICYmXG5cdFx0IXNlbGVjdGlvbkVtcHR5ICYmXG5cdFx0IW5hdGl2ZUVkaXRvclxuXHRcdFx0LmdldFNlbGVjdGlvbigpXG5cdFx0XHQuZ2V0Q29tbW9uQW5jZXN0b3IoKVxuXHRcdFx0LmlzUmVhZE9ubHkoKVxuXHQpO1xufTtcblxuY29uc3QgdGFibGVTZWxlY3Rpb25UZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCkge1xuXHRjb25zdCBuYXRpdmVFZGl0b3IgPSBwYXlsb2FkLmVkaXRvci5nZXQoJ25hdGl2ZUVkaXRvcicpO1xuXG5cdGNvbnN0IHRhYmxlID0gbmV3IENLRURJVE9SLlRhYmxlKG5hdGl2ZUVkaXRvcik7XG5cdGNvbnN0IGVsZW1lbnQgPSB0YWJsZS5nZXRGcm9tU2VsZWN0aW9uKCk7XG5cblx0cmV0dXJuICEhKGVsZW1lbnQgJiYgdGFibGUuaXNFZGl0YWJsZShlbGVtZW50KSk7XG59O1xuXG5jb25zdCBTZWxlY3Rpb25UZXN0ID0ge1xuXHRlbWJlZDogZW1iZWRTZWxlY3Rpb25UZXN0LFxuXHRlbWJlZFVybDogZW1iZWRVcmxTZWxlY3Rpb25UZXN0LFxuXHRoZWFkZXI6IGhlYWRpbmdUZXh0U2VsZWN0aW9uVGVzdCxcblx0aW1hZ2U6IGltYWdlU2VsZWN0aW9uVGVzdCxcblx0bGluazogbGlua1NlbGVjdGlvblRlc3QsXG5cdHRhYmxlOiB0YWJsZVNlbGVjdGlvblRlc3QsXG5cdHRleHQ6IHRleHRTZWxlY3Rpb25UZXN0LFxufTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0aW9uVGVzdDtcbiIsImltcG9ydCBTZWxlY3Rpb25HZXRBcnJvd0JveENsYXNzZXMgZnJvbSAnLi9zZWxlY3Rpb24tYXJyb3dib3gnO1xuaW1wb3J0IFNlbGVjdGlvblNldFBvc2l0aW9uIGZyb20gJy4vc2VsZWN0aW9uLXBvc2l0aW9uJztcbmltcG9ydCBTZWxlY3Rpb25UZXN0IGZyb20gJy4vc2VsZWN0aW9uLXRlc3QnO1xuXG5jb25zdCBTZWxlY3Rpb25zID0gW1xuXHR7XG5cdFx0bmFtZTogJ2VtYmVkJyxcblx0XHRidXR0b25zOiBbJ2VtYmVkUmVtb3ZlJywgJ2VtYmVkRWRpdCddLFxuXHRcdHRlc3Q6IFNlbGVjdGlvblRlc3QuZW1iZWQsXG5cdH0sXG5cdHtcblx0XHRuYW1lOiAnZW1iZWRVcmwnLFxuXHRcdGJ1dHRvbnM6IFsnZW1iZWRWaWRlbycsICdlbWJlZFZpZGVvRWRpdCddLFxuXHRcdHRlc3Q6IFNlbGVjdGlvblRlc3QuZW1iZWRVcmwsXG5cdH0sXG5cdHtcblx0XHRuYW1lOiAnbGluaycsXG5cdFx0YnV0dG9uczogWydsaW5rRWRpdCddLFxuXHRcdHRlc3Q6IFNlbGVjdGlvblRlc3QubGluayxcblx0fSxcblx0e1xuXHRcdG5hbWU6ICdpbWFnZScsXG5cdFx0YnV0dG9uczogWydpbWFnZUxlZnQnLCAnaW1hZ2VDZW50ZXInLCAnaW1hZ2VSaWdodCcsICdyZW1vdmVJbWFnZSddLFxuXHRcdHNldFBvc2l0aW9uOiBTZWxlY3Rpb25TZXRQb3NpdGlvbi5pbWFnZSxcblx0XHR0ZXN0OiBTZWxlY3Rpb25UZXN0LmltYWdlLFxuXHR9LFxuXHR7XG5cdFx0bmFtZTogJ3RleHQnLFxuXHRcdGJ1dHRvbnM6IHtcblx0XHRcdGZ1bGw6IFtcblx0XHRcdFx0W1xuXHRcdFx0XHRcdCdGb250Jyxcblx0XHRcdFx0XHQnRm9udFNpemUnLFxuXHRcdFx0XHRcdCdzZXBhcmF0b3InLFxuXHRcdFx0XHRcdCdib2xkJyxcblx0XHRcdFx0XHQnaXRhbGljJyxcblx0XHRcdFx0XHQndW5kZXJsaW5lJyxcblx0XHRcdFx0XHQnc3RyaWtlJyxcblx0XHRcdFx0XHQnc2VwYXJhdG9yJyxcblx0XHRcdFx0XHQnbGluaycsXG5cdFx0XHRcdF0sXG5cdFx0XHRcdFtcblx0XHRcdFx0XHQncGFyYWdyYXBoQWxpZ24nLFxuXHRcdFx0XHRcdCdzZXBhcmF0b3InLFxuXHRcdFx0XHRcdCd1bCcsXG5cdFx0XHRcdFx0J29sJyxcblx0XHRcdFx0XHQnc2VwYXJhdG9yJyxcblx0XHRcdFx0XHQnaDEnLFxuXHRcdFx0XHRcdCdoMicsXG5cdFx0XHRcdFx0J3NlcGFyYXRvcicsXG5cdFx0XHRcdFx0J2luZGVudEJsb2NrJyxcblx0XHRcdFx0XHQnb3V0ZGVudEJsb2NrJyxcblx0XHRcdFx0XHQnc2VwYXJhdG9yJyxcblx0XHRcdFx0XHQnVGV4dENvbG9yJyxcblx0XHRcdFx0XHQnQkdDb2xvcicsXG5cdFx0XHRcdFx0J3NlcGFyYXRvcicsXG5cdFx0XHRcdFx0J2NvZGUnLFxuXHRcdFx0XHRcdCdxdW90ZScsXG5cdFx0XHRcdFx0J3NlcGFyYXRvcicsXG5cdFx0XHRcdFx0J3JlbW92ZUZvcm1hdCcsXG5cdFx0XHRcdF0sXG5cdFx0XHRdLFxuXG5cdFx0XHRzaW1wbGU6IFsnc3R5bGVzJywgJ2JvbGQnLCAnaXRhbGljJywgJ3VuZGVybGluZScsICdsaW5rJ10sXG5cdFx0fSxcblx0XHR0ZXN0OiBTZWxlY3Rpb25UZXN0LnRleHQsXG5cdH0sXG5cdHtcblx0XHRuYW1lOiAndGFibGUnLFxuXHRcdGJ1dHRvbnM6IFtcblx0XHRcdCd0YWJsZUhlYWRpbmcnLFxuXHRcdFx0J3RhYmxlUm93Jyxcblx0XHRcdCd0YWJsZUNvbHVtbicsXG5cdFx0XHQndGFibGVDZWxsJyxcblx0XHRcdCd0YWJsZVJlbW92ZScsXG5cdFx0XSxcblx0XHRnZXRBcnJvd0JveENsYXNzZXM6IFNlbGVjdGlvbkdldEFycm93Qm94Q2xhc3Nlcy50YWJsZSxcblx0XHRzZXRQb3NpdGlvbjogU2VsZWN0aW9uU2V0UG9zaXRpb24udGFibGUsXG5cdFx0dGVzdDogU2VsZWN0aW9uVGVzdC50YWJsZSxcblx0fSxcbl07XG5cbmV4cG9ydCBkZWZhdWx0IFNlbGVjdGlvbnM7XG4iLCIoZnVuY3Rpb24oKSB7IG1vZHVsZS5leHBvcnRzID0gd2luZG93W3VuZGVmaW5lZF07IH0oKSk7IiwiKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1t1bmRlZmluZWRdOyB9KCkpOyJdLCJzb3VyY2VSb290IjoiIn0=