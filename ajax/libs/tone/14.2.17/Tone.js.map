{"version":3,"sources":["webpack://Tone/webpack/universalModuleDefinition","webpack://Tone/webpack/bootstrap","webpack://Tone/./Tone/core/context/AudioContext.ts","webpack://Tone/./Tone/core/clock/Ticker.ts","webpack://Tone/./Tone/core/util/TypeCheck.ts","webpack://Tone/./Tone/core/util/AdvancedTypeCheck.ts","webpack://Tone/./Tone/core/util/Defaults.ts","webpack://Tone/./Tone/core/util/Debug.ts","webpack://Tone/./Tone/core/Tone.ts","webpack://Tone/./Tone/version.ts","webpack://Tone/./Tone/core/util/Emitter.ts","webpack://Tone/./Tone/core/util/Timeline.ts","webpack://Tone/./Tone/core/context/ContextInitialization.ts","webpack://Tone/./Tone/core/context/Context.ts","webpack://Tone/./Tone/core/Global.ts","webpack://Tone/./Tone/core/type/Conversions.ts","webpack://Tone/./Tone/core/type/TimeBase.ts","webpack://Tone/./Tone/core/type/Time.ts","webpack://Tone/./Tone/core/type/Frequency.ts","webpack://Tone/./Tone/core/type/TransportTime.ts","webpack://Tone/./Tone/core/context/ToneWithContext.ts","webpack://Tone/./Tone/core/context/Param.ts","webpack://Tone/./Tone/core/context/ToneAudioNode.ts","webpack://Tone/./Tone/core/util/Interface.ts","webpack://Tone/./Tone/core/context/Gain.ts","webpack://Tone/./Tone/core/context/OfflineContext.ts","webpack://Tone/./Tone/core/context/ToneAudioBuffer.ts","webpack://Tone/./Tone/core/context/Offline.ts","webpack://Tone/./Tone/core/context/ToneAudioBuffers.ts","webpack://Tone/./Tone/core/context/Delay.ts","webpack://Tone/./Tone/core/util/StateTimeline.ts","webpack://Tone/./Tone/core/clock/TickSignal.ts","webpack://Tone/./Tone/core/clock/TickSource.ts","webpack://Tone/./Tone/core/clock/Clock.ts","webpack://Tone/./Tone/core/type/Ticks.ts","webpack://Tone/./Tone/core/type/Midi.ts","webpack://Tone/./Tone/core/util/Draw.ts","webpack://Tone/./Tone/core/util/IntervalTimeline.ts","webpack://Tone/./Tone/component/channel/Volume.ts","webpack://Tone/./Tone/core/context/Destination.ts","webpack://Tone/./Tone/core/clock/TransportEvent.ts","webpack://Tone/./Tone/core/clock/TransportRepeatEvent.ts","webpack://Tone/./Tone/core/clock/Transport.ts","webpack://Tone/./Tone/source/Source.ts","webpack://Tone/./Tone/source/OneShotSource.ts","webpack://Tone/./Tone/source/buffer/BufferSource.ts","webpack://Tone/./Tone/source/Noise.ts","webpack://Tone/./Tone/signal/Signal.ts","webpack://Tone/./Tone/source/oscillator/OscillatorNode.ts","webpack://Tone/./Tone/source/oscillator/Oscillator.ts","webpack://Tone/./Tone/signal/SignalOperator.ts","webpack://Tone/./Tone/signal/WaveShaper.ts","webpack://Tone/./Tone/signal/AudioToGain.ts","webpack://Tone/./Tone/signal/Multiply.ts","webpack://Tone/./Tone/source/oscillator/AMOscillator.ts","webpack://Tone/./Tone/source/oscillator/FMOscillator.ts","webpack://Tone/./Tone/source/oscillator/PulseOscillator.ts","webpack://Tone/./Tone/source/oscillator/FatOscillator.ts","webpack://Tone/./Tone/source/oscillator/PWMOscillator.ts","webpack://Tone/./Tone/source/oscillator/OmniOscillator.ts","webpack://Tone/./Tone/source/buffer/Player.ts","webpack://Tone/./Tone/signal/Add.ts","webpack://Tone/./Tone/signal/Abs.ts","webpack://Tone/./Tone/signal/GainToAudio.ts","webpack://Tone/./Tone/signal/Negate.ts","webpack://Tone/./Tone/signal/Subtract.ts","webpack://Tone/./Tone/signal/Zero.ts","webpack://Tone/./Tone/component/envelope/Envelope.ts","webpack://Tone/./Tone/component/envelope/AmplitudeEnvelope.ts","webpack://Tone/./Tone/instrument/Instrument.ts","webpack://Tone/./Tone/instrument/Monophonic.ts","webpack://Tone/./Tone/instrument/Synth.ts","webpack://Tone/./Tone/instrument/Sampler.ts","webpack://Tone/./Tone/instrument/PolySynth.ts","webpack://Tone/./Tone/instrument/MembraneSynth.ts","webpack://Tone/./Tone/event/ToneEvent.ts","webpack://Tone/./Tone/event/Part.ts","webpack://Tone/./Tone/event/Sequence.ts","webpack://Tone/./Tone/component/channel/CrossFade.ts","webpack://Tone/./Tone/effect/Effect.ts","webpack://Tone/./Tone/effect/FeedbackEffect.ts","webpack://Tone/./Tone/effect/FeedbackDelay.ts","webpack://Tone/./Tone/effect/Convolver.ts","webpack://Tone/./Tone/component/channel/Merge.ts","webpack://Tone/./Tone/effect/Reverb.ts","webpack://Tone/./Tone/component/analysis/Analyser.ts","webpack://Tone/./Tone/component/filter/Filter.ts","webpack://Tone/./Tone/component/channel/MultibandSplit.ts","webpack://Tone/./Tone/component/filter/EQ3.ts","webpack://Tone/./Tone/component/dynamics/Compressor.ts","webpack://Tone/./Tone/index.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","globalContext","theWindow","hasAudioContext","getAudioContext","context","AudioContext","TONE_AUDIO_CONTEXT","Ticker","callback","type","updateInterval","_callback","_type","_updateInterval","_createClock","_createWorker","blob","Blob","toFixed","blobUrl","URL","createObjectURL","worker","Worker","onmessage","bind","_worker","_createTimeout","_this","_timeout","setTimeout","e","_disposeClock","clearTimeout","terminate","interval","Math","max","postMessage","dispose","isUndef","arg","isDefined","isFunction","isNumber","isObject","toString","constructor","isBoolean","isArray","Array","isString","isNote","test","isAudioParam","Reflect","has","setValueAtTime","isAudioNode","isAudioContext","isOfflineAudioContext","startRendering","close","resume","isAudioBuffer","load","noCopy","key","deepMerge","target","sources","_i","arguments","length","source","shift","assign","_a","_b","apply","concat","optionsFromArguments","defaults","argsArray","keys","objKey","opts","args","from","some","splice","indexOf","defaultArg","given","fallback","omitFromObject","obj","omit","forEach","prop","assert","statement","error","Error","Tone_Tone","Tone","debug","_wasDisposed","getDefaults","log","TONE_DEBUG_CLASS","unshift","console","version","Emitter_Emitter","_super","Emitter","__extends","on","event","split","eventName","_events","push","once","boundCallback","off","eventList","emit","slice","len","mixin","constr","getOwnPropertyDescriptor","undefined","Timeline_Timeline","Timeline","_timeline","options","memory","Timeline_extends","Infinity","add","time","valueOf","index","_search","diff","remove","param","peek","getAfter","getBefore","cancel","after","cancelBefore","previousEvent","beginning","end","midPoint","floor","event_1","nextEvent","_iterate","lowerBound","upperBound","forEachBefore","forEachAfter","forEachBetween","startTime","endTime","forEachFrom","forEachAtTime","notifyNewContext","onContextInit","cb","notifyCloseContext","onContextClose","Context_Context","Context","_constants","Map","_timeouts","_timeoutIds","_initialized","_context","_latencyHint","latencyHint","lookAhead","_ticker","clockSource","_timeoutLoop","addEventListener","state","Context_extends","initialize","ctx","createAnalyser","createOscillator","createBufferSource","createBiquadFilter","createBuffer","numberOfChannels","sampleRate","createChannelMerger","numberOfInputs","createChannelSplitter","numberOfOutputs","createConstantSource","createConvolver","createDelay","maxDelayTime","createDynamicsCompressor","createGain","createIIRFilter","feedforward","feedback","createPanner","createPeriodicWave","real","imag","constraints","createStereoPanner","createWaveShaper","decodeAudioData","audioData","currentTime","listener","_transport","t","_destination","hint","lookAheadValue","now","Promise","resolve","sent","getConstant","val","buffer","arr","getChannelData","constant","channelCount","channelCountMode","loop","start","set","map","disconnect","firstEvent","fn","timeout","id","dummyContext","destination","transport","Global_globalContext","getContext","setContext","Global_start","TONE_SILENCE_LOGGING","prefix","printString","dbToGain","db","pow","gainToDb","gain","LN10","intervalToFrequencyRatio","A4","ftom","frequency","round","log2","ftomf","mtof","midi","TimeBase_TimeBaseClass","TimeBaseClass","units","defaultUnits","_val","_units","_expressions","_getExpressions","TimeBase_extends","hz","method","_frequencyToUnits","parseFloat","regexp","_ticksToUnits","parseInt","_beatsToUnits","_getTimeSignature","dot","numericValue","scalar","number","_secondsToUnits","samples","tr","q","total","fromType","_noArg","trim","typeName","quantity","expr","matching","match","freq","beats","_getBpm","seconds","ticks","_getPPQ","_now","bpm","timeSignature","PPQ","toSeconds","toTicks","toFrequency","toMidi","toSamples","toMilliseconds","Time_TimeClass","TimeClass","Time_extends","capture","quantize","quantTo","nextSubdivision","subdiv","percent","subdivision","toNotation","testNotations","power","closest","closestSeconds","notation","notationSeconds","abs","toBarsBeatsSixteenths","quarterTime","quarters","measures","sixteenths","sixteenthString","join","Time","Frequency_FrequencyClass","FrequencyClass","Frequency_extends","setA4","note","pitch","octave","noteNumber","noteToScaleIndex","toLowerCase","transpose","harmonize","intervals","toNote","scaleIndexToNote","cbb","c#","cx","dbb","d#","dx","ebb","eb","e#","ex","fbb","fb","f","f#","fx","gbb","gb","g","g#","gx","abb","ab","a","a#","ax","bbb","bb","b","b#","bx","Frequency","TransportTimeClass","TransportTime_extends","TransportTime","ToneWithContext_ToneWithContext","ToneWithContext","defaultContext","ToneWithContext_extends","immediate","attribute","member","props","Param_Param","Param","overridden","_minOutput","_param","input","_initialValue","defaultValue","convert","_toType","Param_extends","getValueAtTime","_fromType","cancelScheduledValues","minValue","maxValue","_is","min","computedTime","isFinite","JSON","stringify","before","beforeValue","previous","_linearInterpolate","_exponentialInterpolate","previousVal","_exponentialApproach","setRampPoint","currentVal","cancelAndHoldAtTime","linearRampToValueAtTime","exponentialRampToValueAtTime","exponentialRampTo","rampTime","linearRampTo","targetRampTo","exponentialApproachValueAtTime","timeConstant","setTargetAtTime","setValueCurveAtTime","values","duration","scaling","startingValue","segTime","valueAtTime","sampleTime","rampTo","t0","v0","v1","exp","t1","ToneAudioNode_ToneAudioNode","ToneAudioNode","_internalChannels","ToneAudioNode_extends","output","_isAudioNode","node","_getInternalNodes","nodeList","_setChannelProperties","channelInterpretation","_getChannelProperties","connect","outputNum","inputNum","toDestination","toMaster","warn","chain","nodes","connectSeries","fan","first","reduce","prev","current","srcNode","dstNode","outputNumber","inputNumber","readOnly","str","writable","noOp","Gain_Gain","Gain","_gainNode","Gain_extends","OfflineContext_OfflineContext","OfflineContext","channels","OfflineAudioContext","_currentTime","_duration","OfflineContext_extends","render","ToneAudioBuffer_ToneAudioBuffer","ToneAudioBuffer","onload","reverse","url","catch","onerror","ToneAudioBuffer_extends","_buffer","loaded","_reversed","_reverse","promise","downloads","audioBuffer","e_1","fromArray","array","isMultidimensional","multiChannelArray","copyToChannel","toMono","chanNum","toArray","outputArray","Float32Array","numChannels_1","channel","channelArray","sample","ret","startSamples","endSamples","retBuffer","subarray","rev","fromUrl","matches","extensions","extension","extensions_1","ext","supportsType","replace","fetch","baseUrl","response","ok","arrayBuffer","document","createElement","canPlayType","Offline","originalContext","bufferPromise","ToneAudioBuffers_ToneAudioBuffers","ToneAudioBuffers","_buffers","_loadingCount","urls","_bufferLoaded","ToneAudioBuffers_extends","every","clear","Delay_Delay","Delay","maxDelayInSeconds","maxDelay","delayTime","_delayNode","Delay_extends","StateTimeline","initial","_initial","StateTimeline_extends","setStateAtTime","getLastState","getNextState","event_2","TickSignal_TickSignal","TickSignal","_sig","offset","_multiplier","multiplier","TickSignal_extends","computedValue","prevEvent","segments","rampVal","ticksUntilTime","_getTicksUntilEvent","computedVal","segmentDur","val0","val1","onTheLineEvent","getTicksAtTime","getDurationOfTicks","currentTick","getTimeOfTick","tick","delta","k","sqrt","sol1","ticksToTime","when","timeToTicks","computedDuration","startTicks","TickSource_TickSource","TickSource","_state","_tickOffset","setTicksAtTime","TickSource_extends","stop","pause","stopEvent","tmpEvent","lastState","elapsedTicks","periodStartTime","offsetEvent","getSecondsAtTime","elapsedSeconds","getStateAtTime","absoluteTicks","forEachTickBetween","computedStartTime","computedEndTime","lastStateEvent","maxStartTime","nextTickTime","Clock_Clock","Clock","_lastUpdate","_boundLoop","_loop","_tickSource","Clock_extends","ceil","TicksClass","Ticks_extends","Ticks","Midi_MidiClass","MidiClass","Midi_extends","Midi","Draw_Draw","Draw","expiration","anticipation","_boundDrawLoop","_drawLoop","_animationFrame","Draw_extends","schedule","requestAnimationFrame","cancelAnimationFrame","IntervalTimeline_IntervalTimeline","IntervalTimeline","_root","_length","IntervalTimeline_extends","IntervalNode","insert","updateHeight","updateMax","_rebalance","parent","results","search","results_1","_removeNode","_setRoot","_replaceNodeInParent","replacement","isLeftChild","left","right","temp","getBalance","_rotateLeft","pivotNode","_rotateRight","balance","low","allNodes_1","traverse","searchAfter","high","_left","_right","height","point","Volume_Volume","Volume","volume","_unmutedVolume","mute","Volume_extends","Destination_Destination","Destination","rawContext","Destination_extends","TransportEvent_TransportEvent","TransportEvent","_eventId","_once","invoke","TransportRepeatEvent_TransportRepeatEvent","TransportRepeatEvent","_currentId","_nextId","_nextTick","_boundRestart","_restart","_interval","TransportRepeatEvent_extends","_createEvents","scheduleOnce","Transport_Transport","Transport","_loopStart","_loopEnd","_scheduledEvents","_repeatedEvents","_syncedSignals","_swingAmount","_ppq","ppq","_clock","_processTick","_bindClockEvents","_timeSignature","_swingTicks","Transport_extends","loopEnd","loopStart","swing","swingSubdivision","tickTime","progress","amount","sin","PI","_addEvent","scheduleRepeat","eventId","item","timeline","computedAfter","offsetTicks","toggle","timeSig","startPosition","endPosition","setLoopPoints","remainingTicks","syncSignal","signal","ratio","computedFreq","ratioSignal","unsyncSignal","syncedSignal","Source_Source","Source","_synced","_scheduled","_syncedStart","_syncedStop","_volume","onstop","Source_extends","_clampToCurrentTime","restart","sched","_start","_stop","sync","stateEvent","startOffset","unsync","OneShotSource_OneShotSource","OneShotSource","onended","_startTime","_stopTime","_fadeIn","fadeIn","_fadeOut","fadeOut","_curve","curve","OneShotSource_extends","_startGain","fadeInTime","_stopGain","cancelStop","fadeOutTime","additionalTail","_stopSource","_onended","BufferSource_ToneBufferSource","ToneBufferSource","_source","_sourceStarted","_sourceStopped","playbackRate","BufferSource_extends","computedOffset","computedDur","Noise_Noise","Noise","_playbackRate","Noise_extends","_noiseBuffers","rate","random","_noiseCache","brown","pink","white","channelNum","lastOut","b0","b1","b2","b3","b4","b5","b6","Signal_Signal","Signal","override","_constantSource","Signal_extends","connectSignal","OscillatorNode_ToneOscillatorNode","ToneOscillatorNode","_oscillator","detune","OscillatorNode_extends","setPeriodicWave","periodicWave","Oscillator_Oscillator","Oscillator","_partials","partials","_partialCount","partialCount","baseType","phase","Oscillator_extends","oscillator","_wave","syncFrequency","unsyncFrequency","_getCachedPeriodicWave","oscProps","_periodicWaveCache","find","description","_phase","arrayA","arrayB","element","isBasicType","cache","_getRealImaginary","partial","exec","periodicWaveSize","fftSize","piFactor","TypeError","cos","_inverseFFT","sum","_getInitialValue","twoPi","SignalOperator_SignalOperator","SignalOperator","SignalOperator_extends","WaveShaper_WaveShaper","WaveShaper","_shaper","mapping","setMap","WaveShaper_extends","normalized","oversample","oversampling","isOverSampleType","includes","AudioToGain_AudioToGain","AudioToGain","_norm","x","AudioToGain_extends","Multiply_Multiply","Multiply","_mult","factor","Multiply_extends","AMOscillator_AMOscillator","AMOscillator","_modulationScale","_modulationNode","_carrier","_modulator","modulationType","harmonicity","AMOscillator_extends","FMOscillator_FMOscillator","FMOscillator","modulationIndex","FMOscillator_extends","PulseOscillator_PulseOscillator","PulseOscillator","_widthGate","_thresh","width","_sawtooth","PulseOscillator_extends","FatOscillator_FatOscillator","FatOscillator","_oscillators","_spread","spread","count","FatOscillator_extends","_forEach","osc","iterator","start_1","step_1","PWMOscillator_PWMOscillator","PWMOscillator","sourceType","_scale","_pulse","modulationFrequency","PWMOscillator_extends","OmniOscillatorSourceMap","am","fat","fm","pulse","pwm","OmniOscillator_OmniOscillator","OmniOscillator","OmniOscillator_extends","_sourceType","substr","_createNewOscillator","_getOscType","oscType","OscConstructor","oldOsc_1","blockTime","sType","mType","Player_Player","Player","_activeSources","Set","_onload","autostart","Player_extends","_onSourceEnd","delete","size","comptuedOffset","origDuration","implicitEnd","seek","Add_Add","Add","_sum","addend","Add_extends","Abs_Abs","Abs","_abs","Abs_extends","GainToAudio_GainToAudio","GainToAudio","GainToAudio_extends","Negate_Negate","Negate","_multiply","Negate_extends","Subtract_Subtract","Subtract","_neg","subtrahend","Subtract_extends","Zero_Zero","Zero","_gain","Zero_extends","Envelope_Envelope","Envelope","attack","decay","sustain","release","attackCurve","releaseCurve","decayCurve","Envelope_extends","_getCurve","direction","curveName","EnvelopeCurves","_setCurve","curveDef","_attackCurve","_releaseCurve","_decayCurve","triggerAttack","velocity","currentValue","decayValue","decayStart","triggerRelease","triggerAttackRelease","cosineCurve","rippleCurve","curveLen","sineWave","stairsCurve","sineCurve","bounceCurve","invertCurve","out","j","bounce","In","Out","cosine","exponential","linear","ripple","sine","step","AmplitudeEnvelope_AmplitudeEnvelope","AmplitudeEnvelope","AmplitudeEnvelope_extends","Instrument_Instrument","Instrument","_original_triggerAttack","_original_triggerRelease","Instrument_extends","_syncMethod","timePosition","originalMethod","Monophonic_Monophonic","Monophonic","portamento","onsilence","Monophonic_extends","_triggerEnvelopeAttack","setNote","_triggerEnvelopeRelease","getLevelAtTime","envelope","computedFrequency","portTime","Synth_Synth","Synth","Synth_extends","computedAttack","computedDecay","Sampler_Sampler","Sampler","urlMap","mid","Sampler_extends","_findClosest","notes","difference","closestNote","releaseAll","PolySynth_PolySynth","PolySynth","_availableVoices","_activeVoices","_voices","voice","polyphony","PolySynth_extends","_getActiveVoice","_makeVoiceAvailable","activeVoiceIndex","findIndex","_getNextAvailableVoice","_triggerAttack","midiNote","_triggerRelease","_scheduleEvent","disposed","durationSeconds","v","MembraneSynth_MembraneSynth","MembraneSynth","pitchDecay","octaves","MembraneSynth_extends","hertz","maxNote","ToneEvent_ToneEvent","ToneEvent","_startOffset","_probability","probability","_humanize","humanize","ToneEvent_extends","_rescheduleEvents","startTick","_getLoopDuration","_tick","prob","variation","reschedulTime","lastEvent","loopDuration","Part_Part","Part","events","Part_extends","computedOffset_1","_startNote","at","timeInTicks","result","next","done","_restartEvent","_setAll","attr","_testLoopBoundries","Sequence_Sequence","Sequence","_part","_seqCallback","_eventsArray","_subdivision","Sequence_extends","_createSequence","_eventsUpdated","_indexTime","Proxy","_rescheduleSequence","sequence","eventOffset","CrossFade_CrossFade","CrossFade","_panner","_split","_g2a","fade","pan","CrossFade_extends","Effect_Effect","Effect","_dryWet","wet","effectSend","effectReturn","Effect_extends","connectEffect","effect","FeedbackEffect_FeedbackEffect","FeedbackEffect","_feedbackGain","FeedbackEffect_extends","FeedbackDelay_FeedbackDelay","FeedbackDelay","FeedbackDelay_extends","Convolver_Convolver","Convolver","_convolver","normalize","Convolver_extends","buff","norm","Merge_Merge","Merge","_merger","Merge_extends","Reverb_Reverb","Reverb","preDelay","Reverb_extends","generate","noiseL","noiseR","merge","gainNode","Analyser_Analyser","Analyser","_analyser","Analyser_extends","smoothing","getValue","getFloatFrequencyData","getFloatTimeDomainData","frequencyBinCount","smoothingTimeConstant","Filter_Filter","Filter","_filters","Q","rolloff","Filter_extends","filter","_rolloff","rolloffNum","possibilities","cascadingCount","getFrequencyResponse","totalResponse","freqValues","magValues","phaseValues","filterClone","MultibandSplit_MultibandSplit","MultibandSplit","_lowMidFilter","lowFrequency","highFrequency","MultibandSplit_extends","EQ3_EQ3","EQ3","_multibandSplit","_lowGain","_midGain","_highGain","EQ3_extends","Compressor_Compressor","Compressor","_compressor","threshold","knee","Compressor_extends","reduction","Tone_now","Tone_Transport","Tone_Destination"],"mappings":"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","file":"Tone.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Tone\"] = factory();\n\telse\n\t\troot[\"Tone\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","// import { AudioContext as stdAudioContext,\n// \tOfflineAudioContext as stdOfflineAudioContext } from \"standardized-audio-context\";\n\n/**\n * Create a new AudioContext\n */\nfunction createAudioContext(): AudioContext {\n\t// return new stdAudioContext() as unknown as AudioContext;\n\treturn new AudioContext();\n}\n\n/**\n * Create a new OfflineAudioContext\n */\nexport function createOfflineAudioContext(channels: number, length: number, sampleRate: number): OfflineAudioContext {\n\treturn new OfflineAudioContext(channels, length, sampleRate);\n}\n\n/**\n * Either the online or offline audio context\n */\nexport type AnyAudioContext = AudioContext | OfflineAudioContext;\n\n/**\n * Interface for things that Tone.js adds to the window\n */\ninterface ToneWindow extends Window {\n\tTONE_AUDIO_CONTEXT?: AnyAudioContext;\n\tTONE_SILENCE_LOGGING?: boolean;\n\tTONE_DEBUG_CLASS?: string;\n}\n\n/**\n * A reference to the window object\n */\nexport const theWindow: ToneWindow | null = typeof self === \"object\" ? self : null;\n\n/**\n * If the browser has a window object which has an AudioContext\n */\nexport const hasAudioContext = theWindow &&\n\t(theWindow.hasOwnProperty(\"AudioContext\") || theWindow.hasOwnProperty(\"webkitAudioContext\"));\n\n/**\n * The global audio context which is getable and assignable through\n * getAudioContext and setAudioContext\n */\nlet globalContext: AnyAudioContext;\n\n// if it was created already, use that one\n// this enables multiple versions of Tone.js to run on the same page.\nif (theWindow && theWindow.TONE_AUDIO_CONTEXT) {\n\tglobalContext = theWindow.TONE_AUDIO_CONTEXT;\n}\n\n/**\n * Returns the default system-wide AudioContext\n */\nexport function getAudioContext(): AnyAudioContext {\n\tif (!globalContext && hasAudioContext) {\n\t\tsetAudioContext(createAudioContext());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n */\nexport function setAudioContext(context: AnyAudioContext): void {\n\tglobalContext = context;\n\tif (theWindow) {\n\t\ttheWindow.TONE_AUDIO_CONTEXT = globalContext;\n\t}\n}\n","import { Seconds } from \"../type/Units\";\n\nexport type TickerClockSource = \"worker\" | \"timeout\" | \"offline\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n\n\t/**\n\t * Either \"worker\" or \"timeout\" or \"offline\"\n\t */\n\tprivate _type: TickerClockSource;\n\n\t/**\n\t * The update interval of the worker\n\t */\n\tprivate _updateInterval: Seconds;\n\n\t/**\n\t * The callback to invoke at regular intervals\n\t */\n\tprivate _callback: () => void;\n\n\t/**\n\t * track the callback interval\n\t */\n\tprivate _timeout!: number;\n\n\t/**\n\t * private reference to the worker\n\t */\n\tprivate _worker!: Worker;\n\n\tconstructor(callback: () => void, type: TickerClockSource, updateInterval: Seconds) {\n\n\t\tthis._callback = callback;\n\t\tthis._type = type;\n\t\tthis._updateInterval = updateInterval;\n\n\t\t// create the clock source for the first time\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t *  Generate a web worker\n\t */\n\tprivate _createWorker(): void {\n\n\t\tconst blob = new Blob([\n\t\t\t// the initial timeout time\n\t\t\t`var timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();`,\n\t\t]);\n\t\tconst blobUrl = URL.createObjectURL(blob);\n\t\tconst worker = new Worker(blobUrl);\n\n\t\tworker.onmessage = this._callback.bind(this);\n\n\t\tthis._worker = worker;\n\t}\n\n\t/**\n\t * Create a timeout loop\n\t */\n\tprivate _createTimeout(): void {\n\t\tthis._timeout = setTimeout(()  => {\n\t\t\tthis._createTimeout();\n\t\t\tthis._callback();\n\t\t}, this._updateInterval * 1000);\n\t}\n\n\t/**\n\t * Create the clock source.\n\t */\n\tprivate _createClock(): void {\n\t\tif (this._type === \"worker\") {\n\t\t\ttry {\n\t\t\t\tthis._createWorker();\n\t\t\t} catch (e) {\n\t\t\t\t// workers not supported, fallback to timeout\n\t\t\t\tthis._type = \"timeout\";\n\t\t\t\tthis._createClock();\n\t\t\t}\n\t\t} else if (this._type === \"timeout\") {\n\t\t\tthis._createTimeout();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up the current clock source\n\t */\n\tprivate _disposeClock(): void {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t\tthis._timeout = 0;\n\t\t}\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\t\t\tthis._worker.onmessage = null;\n\t\t}\n\t}\n\n\t/**\n\t * The rate in seconds the ticker will update\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._updateInterval = Math.max(interval, 128 / 44100);\n\t\tif (this._type === \"worker\") {\n\t\t\tthis._worker.postMessage(Math.max(interval * 1000, 1));\n\t\t}\n\t}\n\n\t/**\n\t * The type of the ticker, either a worker or a timeout\n\t */\n\tget type(): TickerClockSource {\n\t\treturn this._type;\n\t}\n\tset type(type: TickerClockSource) {\n\t\tthis._disposeClock();\n\t\tthis._type = type;\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): void {\n\t\tthis._disposeClock();\n\t}\n}\n","import { Note } from \"../type/Units\";\n\n/**\n *  Test if the arg is undefined\n */\nexport function isUndef(arg: any): arg is undefined {\n\treturn typeof arg === \"undefined\";\n}\n\n/**\n *  Test if the arg is not undefined\n */\nexport function isDefined<T>(arg: T | undefined): arg is T {\n\treturn !isUndef(arg);\n}\n\n/**\n *  Test if the arg is a function\n */\nexport function isFunction(arg: any): arg is (a: any) => any {\n\treturn typeof arg === \"function\";\n}\n\n/**\n *  Test if the argument is a number.\n */\nexport function isNumber(arg: any): arg is number {\n\treturn (typeof arg === \"number\");\n}\n\n/**\n *  Test if the given argument is an object literal (i.e. `{}`);\n */\nexport function isObject(arg: any): arg is object {\n\treturn (Object.prototype.toString.call(arg) === \"[object Object]\" && arg.constructor === Object);\n}\n\n/**\n *  Test if the argument is a boolean.\n */\nexport function isBoolean(arg: any): arg is boolean {\n\treturn (typeof arg === \"boolean\");\n}\n\n/**\n *  Test if the argument is an Array\n */\nexport function isArray(arg: any): arg is any[] {\n\treturn (Array.isArray(arg));\n}\n\n/**\n *  Test if the argument is a string.\n */\nexport function isString(arg: any): arg is string {\n\treturn (typeof arg === \"string\");\n}\n\n/**\n *  Test if the argument is in the form of a note in scientific pitch notation.\n *  e.g. \"C4\"\n */\nexport function isNote(arg: any): arg is Note {\n\treturn isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}\n","import { isFunction } from \"./TypeCheck\";\n\n/**\n * Test if the given value is an instanceof AudioParam\n */\nexport function isAudioParam(arg: any): arg is AudioParam {\n\treturn arg instanceof Object &&  Reflect.has(arg, \"value\") &&\n\t\t!Reflect.has(arg, \"input\") &&\n\t\tisFunction(arg.setValueAtTime);\n}\n\n/**\n * Test if the given value is an instanceof AudioNode\n */\nexport function isAudioNode(arg: any): arg is AudioNode {\n\treturn arg instanceof Object && Reflect.has(arg, \"context\") &&\n\t\t!Reflect.has(arg, \"input\") &&\n\t\t(isAudioContext(arg.context) || isOfflineAudioContext(arg.context));\n}\n\n/**\n * Test if the arg is instanceof an OfflineAudioContext\n */\nexport function isOfflineAudioContext(arg: any): arg is OfflineAudioContext {\n\treturn arg instanceof Object &&  Reflect.has(arg, \"destination\") &&\n\t\tisFunction(arg.startRendering) && !Reflect.has(arg, \"rawContext\");\n}\n\n/**\n * Test if the arg is an instanceof AudioContext\n */\nexport function isAudioContext(arg: any): arg is AudioContext {\n\treturn arg instanceof Object &&  Reflect.has(arg, \"destination\") &&\n\t\tisFunction(arg.close) && isFunction(arg.resume) && !Reflect.has(arg, \"rawContext\");\n}\n\n/**\n * Test if the arg is instanceof an AudioBuffer\n */\nexport function isAudioBuffer(arg: any): arg is AudioBuffer {\n\treturn arg instanceof Object &&  Reflect.has(arg, \"sampleRate\")\n\t\t&& Reflect.has(arg, \"duration\") && !isFunction(arg.load);\n}\n","import { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n\ntype BaseToneOptions = import(\"../Tone\").BaseToneOptions;\n\n/**\n * Some objects should not be merged\n */\nfunction noCopy(key: string, arg: any): boolean {\n\treturn key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\n\n/**\n * Recursively merge an object\n * @param target the object to merge into\n * @param sources the source objects to merge\n */\nexport function deepMerge<T>(target: T): T;\nexport function deepMerge<T, U>(target: T, source1: U): T & U;\nexport function deepMerge<T, U, V>(target: T, source1: U, source2: V): T & U & V;\nexport function deepMerge<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function deepMerge(target: any, ...sources: any[]): any {\n\tif (!sources.length) { return target; }\n\tconst source = sources.shift();\n\n\tif (isObject(target) && isObject(source)) {\n\t\tfor (const key in source) {\n\t\t\tif (noCopy(key, source[key])) {\n\t\t\t\ttarget[key] = source[key];\n\t\t\t} else if (isObject(source[key])) {\n\t\t\t\tif (!target[key]) { Object.assign(target, { [key]: {} }); }\n\t\t\t\tdeepMerge(target[key], source[key] as any);\n\t\t\t} else {\n\t\t\t\tObject.assign(target, { [key]: source[key] as any });\n\t\t\t}\n\t\t}\n\t}\n\t// @ts-ignore\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\nexport function deepEquals(arrayA: number[] | string[], arrayB: number[] | string[]): boolean {\n\treturn arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);\n}\n\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments<T extends object>(\n\tdefaults: T,\n\targsArray: IArguments,\n\tkeys: string[] = [],\n\tobjKey?: string,\n): T {\n\tconst opts: any = {};\n\tconst args = Array.from(argsArray);\n\t// if the first argument is an object and has an object key\n\tif (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n\t\t// if it's not part of the defaults\n\t\tconst partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n\t\tif (!partOfDefaults) {\n\t\t\t// merge that key\n\t\t\tdeepMerge(opts, {[objKey] : args[0]});\n\t\t\t// remove the obj key from the keys\n\t\t\tkeys.splice(keys.indexOf(objKey), 1);\n\t\t\t// shift the first argument off\n\t\t\targs.shift();\n\t\t}\n\t}\n\tif (args.length === 1 && isObject(args[0])) {\n\t\tdeepMerge(opts, args[0]);\n\t} else {\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tif (isDefined(args[i])) {\n\t\t\t\topts[keys[i]] = args[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn deepMerge(defaults, opts);\n}\n\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance<T>(instance: T): BaseToneOptions {\n\ttype ToneClass = {\n\t\tconstructor: ToneClass;\n\t\tgetDefaults: () => BaseToneOptions;\n\t} & T;\n\n\treturn (instance as ToneClass).constructor.getDefaults();\n}\n\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg<T>(given: T, fallback: T): T {\n\tif (isUndef(given)) {\n\t\treturn fallback;\n\t} else {\n\t\treturn given;\n\t}\n}\n\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject<T extends object, O extends string[]>(obj: T, omit: O): Omit<T, keyof O> {\n\tomit.forEach(prop => {\n\t\tif (Reflect.has(obj, prop)) {\n\t\t\tdelete obj[prop];\n\t\t}\n\t});\n\treturn obj;\n}\n","/**\n *  Assert that the statement is true, otherwise invoke an error with the given message.\n */\nexport function assert(statement: boolean, error: string): void {\n\tif (!statement) {\n\t\tthrow new Error(error);\n\t}\n}\n\nexport function log(...args: any[]): void {\n\t// tslint:disable-next-line: no-console\n\tconsole.log(...args);\n}\n","/**\n *  Tone.js\n *  @author Yotam Mann\n *  @license http://opensource.org/licenses/MIT MIT License\n *  @copyright 2014-2019 Yotam Mann\n */\nimport { version } from \"../version\";\nimport { theWindow } from \"./context/AudioContext\";\nimport { assert, log } from \"./util/Debug\";\n\n///////////////////////////////////////////////////////////////////////////\n// \tTONE\n///////////////////////////////////////////////////////////////////////////\n\n// tslint:disable-next-line: no-empty-interface\nexport interface BaseToneOptions {}\n\n/**\n *  @class  Tone is the base class of all other classes.\n *  @constructor\n */\nexport abstract class Tone {\n\n\t/**\n\t * The version number semver\n\t */\n\tstatic version: string = version;\n\n\t/**\n\t * The name of the class\n\t */\n\tprotected abstract name: string;\n\n\t/**\n\t * Takes a partial options an returns the completed options by filling in the defaults\n\t */\n\tstatic getDefaults(): BaseToneOptions {\n\t\treturn {};\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tDEBUGGING\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Set this debug flag to log all events that happen in this class.\n\t */\n\tdebug: boolean = false;\n\n\t/**\n\t * Prints the outputs to the console log for debugging purposes.\n\t * Prints the contents only if either the object has a property\n\t * called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n\t * is set to the name of the class.\n\t * @example\n\t * //prints all logs originating from Tone.OscillatorNode\n\t * Tone.global.TONE_DEBUG_CLASS = \"OscillatorNode\"\n\t */\n\tprotected log(...args: any[]): void {\n\t\t// if the object is either set to debug = true\n\t\t// or if there is a string on the Tone.global.with the class name\n\t\tif (this.debug || (theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS)) {\n\t\t\targs.unshift(this.toString() + \":\");\n\t\t\tlog(...args);\n\t\t}\n\t}\n\n\t/**\n\t *  Assert that the statement is true, otherwise invoke the error.\n\t *  @param {Boolean} statement\n\t *  @param {String} error The message which is passed into an Error\n\t *  @private\n\t */\n\tprotected assert(statement: boolean, error: string): void {\n\t\tassert(statement, error);\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tDISPOSING\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Indicates if the instance was disposed\n\t */\n\tprivate _wasDisposed: boolean = false;\n\n\t/**\n\t *  disconnect and dispose.\n\t */\n\tdispose(): this {\n\t\tthis._wasDisposed = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Indicates if the instance was disposed. 'Disposing' an\n\t * instance means that all of the Web Audio nodes that were\n\t * created for the instance are disconnected and freed for garbage collection.\n\t */\n\tget disposed(): boolean {\n\t\treturn this._wasDisposed;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tDEFAULTS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  If the `given` parameter is undefined, use the `fallback`.\n\t *  If both `given` and `fallback` are object literals, it will\n\t *  return a deep copy which includes all of the parameters from both\n\t *  objects. If a parameter is undefined in given, it will return\n\t *  the fallback property.\n\t *  <br><br>\n\t *  WARNING: if object is self referential, it will go into an an\n\t *  infinite recursive loop.\n\t *  @memberOf Tone\n\t *  @param  {*} given\n\t *  @param  {*} fallback\n\t *  @return {*}\n\t */\n\t// static defaultArg(given, fallback) {\n\t\t// if (isObject(given) && isObject(fallback)) {\n\t\t// \tconst ret = {};\n\t\t// \t// make a deep copy of the given object\n\t\t// \tfor (const givenProp in given) {\n\t\t// \t\tret[givenProp] = Tone.defaultArg(fallback[givenProp], given[givenProp]);\n\t\t// \t}\n\t\t// \tfor (const fallbackProp in fallback) {\n\t\t// \t\tret[fallbackProp] = Tone.defaultArg(given[fallbackProp], fallback[fallbackProp]);\n\t\t// \t}\n\t\t// \treturn ret;\n\t\t// } else {\n\t\t// \treturn isUndef(given) ? fallback : given;\n\t\t// }\n\t// }\n\n\t// protected options(argsArray: IArguments, keys: string[]): object {\n\t// \tlet options: any = {};\n\t// \tconst args = Array.from(argsArray);\n\t// \tif (args[0] instanceof BaseAudioContext) {\n\t// \t\toptions.context = args.shift();\n\t// \t}\n\t// \tif (args.length === 1 && isObject(args[0])) {\n\t// \t\toptions = Object.assign(options, args[0]);\n\t// \t} else {\n\t// \t\tfor (let i = 0; i < keys.length; i++) {\n\t// \t\t\tif (isDefined(args[i])) {\n\t// \t\t\t\toptions[keys[i]] = args[i];\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \treturn deepMerge(this.getDefaults(), options);\n\t// }\n\n\t/**\n\t * Convert the class to a string\n\t * @example\n\t * const osc = new Oscillator()\n\t * osc.toString() // \"Oscillator\"\n\t */\n\ttoString(): string {\n\t\treturn this.name;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tSTATIC\n\t///////////////////////////////////////////////////////////////////////////\n\n\t// static get context(): import(\"./context/Context\").Context {\n\t// \treturn getContext();\n\t// }\n\n\t// static now(): Seconds {\n\t// \treturn Tone.context.now();\n\t// }\n}\n","export const version: string = \"14.2.17\";\n","import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n\nexport interface EmitterEventObject {\n\t[event: string]: Array<(...args: any[]) => void>;\n}\n\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n */\nexport class Emitter<EventType extends string = string> extends Tone {\n\n\tname = \"Emitter\";\n\n\t/**\n\t * Private container for the events\n\t */\n\tprivate _events?: EmitterEventObject;\n\n\t/**\n\t *  Bind a callback to a specific event.\n\t *  @param  event     The name of the event to listen for.\n\t *  @param  callback  The callback to invoke when the event is emitted\n\t */\n\ton(event: EventType, callback: (...args: any[]) => void): this {\n\t\t// split the event\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (!this._events.hasOwnProperty(eventName)) {\n\t\t\t\tthis._events[eventName] = [];\n\t\t\t}\n\t\t\tthis._events[eventName].push(callback);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Bind a callback which is only invoked once\n\t *  @param  event     The name of the event to listen for.\n\t *  @param  callback  The callback to invoke when the event is emitted\n\t */\n\tonce(event: EventType, callback: (...args: any[]) => void): this {\n\t\tconst boundCallback = (...args: any[])  => {\n\t\t\t// invoke the callback\n\t\t\tcallback(...args);\n\t\t\t// remove the event\n\t\t\tthis.off(event, boundCallback);\n\t\t};\n\t\tthis.on(event, boundCallback);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove the event listener.\n\t *  @param  event     The event to stop listening to.\n\t *  @param  callback  The callback which was bound to the event with Emitter.on.\n\t *                    If no callback is given, all callbacks events are removed.\n\t */\n\toff(event: EventType, callback?: (...args: any[]) => void): this {\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tif (isUndef(callback)) {\n\t\t\t\t\tthis._events[event] = [];\n\t\t\t\t} else {\n\t\t\t\t\tconst eventList = this._events[event];\n\t\t\t\t\tfor (let i = 0; i < eventList.length; i++) {\n\t\t\t\t\t\tif (eventList[i] === callback) {\n\t\t\t\t\t\t\teventList.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Invoke all of the callbacks bound to the event\n\t *  with any arguments passed in.\n\t *  @param  event  The name of the event.\n\t *  @param args The arguments to pass to the functions listening.\n\t */\n\temit(event, ...args: any[]): this {\n\t\tif (this._events) {\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tconst eventList = this._events[event].slice(0);\n\t\t\t\tfor (let i = 0, len = eventList.length; i < len; i++) {\n\t\t\t\t\teventList[i].apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Add Emitter functions (on/off/emit) to the object\n\t */\n\tstatic mixin(constr: any): void {\n\t\t// instance._events = {};\n\t\t[\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n\t\t\tconst property = Object.getOwnPropertyDescriptor(Emitter.prototype, name) as PropertyDescriptor;\n\t\t\tObject.defineProperty(constr.prototype, name, property);\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events = undefined;\n\t\treturn this;\n\t}\n}\n","import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"./Defaults\";\n\ntype TimelineSearchParam = \"ticks\" | \"time\";\n\n/**\n * The options object for Timeline\n */\ninterface TimelineOptions {\n\tmemory: number;\n}\n\n/**\n * An event must have a time number\n */\nexport interface TimelineEvent {\n\ttime: number;\n}\n\n/**\n *  @class A Timeline class for scheduling and maintaining state\n *         along a timeline. All events must have a \"time\" property.\n *         Internally, events are stored in time order for fast\n *         retrieval.\n *  @param memory The number of previous events that are retained.\n */\nexport class Timeline<GenericEvent extends TimelineEvent> extends Tone {\n\n\tname = \"Timeline\";\n\n\t/**\n\t *  The memory of the timeline, i.e.\n\t *  how many events in the past it will retain\n\t */\n\tmemory: number;\n\n\t/**\n\t * The array of scheduled timeline events\n\t */\n\tprotected _timeline: GenericEvent[] = [];\n\n\tconstructor(options?: Partial<TimelineOptions>);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(memory?: number);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n\n\t\tthis.memory = options.memory;\n\t}\n\n\tstatic getDefaults(): TimelineOptions {\n\t\treturn {\n\t\t\tmemory: Infinity,\n\t\t};\n\t}\n\n\t/**\n\t *  The number of items in the timeline.\n\t */\n\tget length(): number {\n\t\treturn this._timeline.length;\n\t}\n\n\t/**\n\t *  Insert an event object onto the timeline. Events must have a \"time\" attribute.\n\t *  @param event  The event object to insert into the timeline.\n\t */\n\tadd(event: GenericEvent): Timeline<GenericEvent> {\n\t\t// the event needs to have a time attribute\n\t\tthis.assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n\t\tevent.time = event.time.valueOf();\n\t\tconst index = this._search(event.time);\n\t\tthis._timeline.splice(index + 1, 0, event);\n\t\t// if the length is more than the memory, remove the previous ones\n\t\tif (this.length > this.memory) {\n\t\t\tconst diff = this.length - this.memory;\n\t\t\tthis._timeline.splice(0, diff);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove an event from the timeline.\n\t *  @param  {Object}  event  The event object to remove from the list.\n\t *  @returns {Timeline} this\n\t */\n\tremove(event: GenericEvent): Timeline<GenericEvent> {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index !== -1) {\n\t\t\tthis._timeline.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Get the nearest event whose time is less than or equal to the given time.\n\t *  @param  time  The time to query.\n\t */\n\tget(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index !== -1) {\n\t\t\treturn this._timeline[index];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Return the first event in the timeline without removing it\n\t *  @returns {Object} The first event object\n\t */\n\tpeek(): GenericEvent | undefined {\n\t\treturn this._timeline[0];\n\t}\n\n\t/**\n\t *  Return the first event in the timeline and remove it\n\t */\n\tshift(): GenericEvent | undefined {\n\t\treturn this._timeline.shift();\n\t}\n\n\t/**\n\t *  Get the event which is scheduled after the given time.\n\t *  @param  time  The time to query.\n\t */\n\tgetAfter(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index + 1 < this._timeline.length) {\n\t\t\treturn this._timeline[index + 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Get the event before the event at the given time.\n\t *  @param  time  The time to query.\n\t */\n\tgetBefore(time: number): GenericEvent | null {\n\t\tconst len = this._timeline.length;\n\t\t// if it's after the last item, return the last item\n\t\tif (len > 0 && this._timeline[len - 1].time < time) {\n\t\t\treturn this._timeline[len - 1];\n\t\t}\n\t\tconst index = this._search(time);\n\t\tif (index - 1 >= 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Cancel events at and after the given time\n\t *  @param  time  The time to query.\n\t */\n\tcancel(after: number): Timeline<GenericEvent> {\n\t\tif (this._timeline.length > 1) {\n\t\t\tlet index = this._search(after);\n\t\t\tif (index >= 0) {\n\t\t\t\tif (this._timeline[index].time === after) {\n\t\t\t\t\t// get the first item with that time\n\t\t\t\t\tfor (let i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (this._timeline[i].time === after) {\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index);\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t} else if (this._timeline.length === 1) {\n\t\t\t// the first item's time\n\t\t\tif (this._timeline[0].time >= after) {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel events before or equal to the given time.\n\t *  @param  {Number}  time  The time to cancel before.\n\t *  @returns {Timeline} this\n\t */\n\tcancelBefore(time): Timeline<GenericEvent> {\n\t\tconst index = this._search(time);\n\t\tif (index >= 0) {\n\t\t\tthis._timeline = this._timeline.slice(index + 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the previous event if there is one. null otherwise\n\t * @param  {Object} event The event to find the previous one of\n\t * @return {Object}       The event right before the given event\n\t */\n\tpreviousEvent(event): GenericEvent | null {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index > 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Does a binary search on the timeline array and returns the\n\t *  nearest event index whose time is after or equal to the given time.\n\t *  If a time is searched before the first index in the timeline, -1 is returned.\n\t *  If the time is after the end, the index of the last item is returned.\n\t *  @param  time\n\t */\n\tprotected _search(time: number, param: TimelineSearchParam = \"time\"): number {\n\t\tif (this._timeline.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet beginning = 0;\n\t\tconst len = this._timeline.length;\n\t\tlet end = len;\n\t\tif (len > 0 && this._timeline[len - 1][param] <= time) {\n\t\t\treturn len - 1;\n\t\t}\n\t\twhile (beginning < end) {\n\t\t\t// calculate the midpoint for roughly equal partition\n\t\t\tlet midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t\t\tconst event = this._timeline[midPoint];\n\t\t\tconst nextEvent = this._timeline[midPoint + 1];\n\t\t\tif (event[param] === time) {\n\t\t\t\t// choose the last one that has the same time\n\t\t\t\tfor (let i = midPoint; i < this._timeline.length; i++) {\n\t\t\t\t\tconst testEvent = this._timeline[i];\n\t\t\t\t\tif (testEvent[param] === time) {\n\t\t\t\t\t\tmidPoint = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn midPoint;\n\t\t\t} else if (event[param] < time && nextEvent[param] > time) {\n\t\t\t\treturn midPoint;\n\t\t\t} else if (event[param] > time) {\n\t\t\t\t// search lower\n\t\t\t\tend = midPoint;\n\t\t\t} else {\n\t\t\t\t// search upper\n\t\t\t\tbeginning = midPoint + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t *  Internal iterator. Applies extra safety checks for\n\t *  removing items from the array.\n\t */\n\tprivate _iterate(\n\t\tcallback: (event: GenericEvent) => void,\n\t\tlowerBound = 0, upperBound = this._timeline.length - 1,\n\t): void {\n\t\tthis._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n\t}\n\n\t/**\n\t *  Iterate over everything in the array\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\tthis._iterate(callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at or before the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachBefore(time, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array after the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachAfter(time, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst lowerBound = this._search(time);\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array between the startTime and endTime.\n\t *  The timerange is inclusive of the startTime, but exclusive of the endTime.\n\t *  range = [startTime, endTime).\n\t *  @param  startTime The time to check if items are before\n\t *  @param  endTime The end of the test interval.\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachBetween(startTime: number, endTime: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\tlet lowerBound = this._search(startTime);\n\t\tlet upperBound = this._search(endTime);\n\t\tif (lowerBound !== -1 && upperBound !== -1) {\n\t\t\tif (this._timeline[lowerBound].time !== startTime) {\n\t\t\t\tlowerBound += 1;\n\t\t\t}\n\t\t\t// exclusive of the end time\n\t\t\tif (this._timeline[upperBound].time === endTime) {\n\t\t\t\tupperBound -= 1;\n\t\t\t}\n\t\t\tthis._iterate(callback, lowerBound, upperBound);\n\t\t} else if (lowerBound === -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at or after the given time. Similar to\n\t *  forEachAfter, but includes the item(s) at the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tlet lowerBound = this._search(time);\n\t\t// work backwards until the event time is less than time\n\t\twhile (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n\t\t\tlowerBound--;\n\t\t}\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at the given time\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(event => {\n\t\t\t\tif (event.time === time) {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t}, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._timeline = [];\n\t\treturn this;\n\t}\n}\n","///////////////////////////////////////////////////////////////////////////\n// INITIALIZING NEW CONTEXT\n///////////////////////////////////////////////////////////////////////////\n\ntype Context = import(\"./Context\").Context;\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyNewContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to setup a new Context\n */\nexport function onContextInit(cb: (ctx: Context) => void): void {\n\tnotifyNewContext.push(cb);\n}\n\n/**\n * Invoke any classes which need to also be initialized when a new context is created.\n */\nexport function initializeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyNewContext.forEach(cb => cb(ctx));\n}\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyCloseContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to tear down a Context\n */\nexport function onContextClose(cb: (ctx: Context) => void): void {\n\tnotifyCloseContext.push(cb);\n}\n\nexport function closeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyCloseContext.forEach(cb => cb(ctx));\n}\n","import { Ticker, TickerClockSource } from \"../clock/Ticker\";\nimport { Seconds } from \"../type/Units\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { Omit } from \"../util/Interface\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isString } from \"../util/TypeCheck\";\nimport { AnyAudioContext, getAudioContext } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\ntype Destination = import(\"./Destination\").Destination;\n\nexport type ContextLatencyHint = AudioContextLatencyCategory | \"fastest\";\n\n// these are either not used in Tone.js or deprecated and not implemented.\nexport type ExcludedFromBaseAudioContext = \"onstatechange\" | \"addEventListener\" |\n\t\"removeEventListener\" | \"listener\" | \"dispatchEvent\" | \"audioWorklet\" | \"destination\" | \"createScriptProcessor\";\n\t// \"createMediaStreamSource\" | \"createMediaElementSource\" | \"createMediaStreamTrackSource\" |\n\t// \"baseLatency\" | \"suspend\" |\n\n// the subset of the BaseAudioContext which Tone.Context implements.\nexport type BaseAudioContextSubset = Omit<BaseAudioContext, ExcludedFromBaseAudioContext>;\n\nexport interface ContextOptions {\n\tclockSource: TickerClockSource;\n\tlatencyHint: ContextLatencyHint;\n\tlookAhead: Seconds;\n\tupdateInterval: Seconds;\n\tcontext: AnyAudioContext;\n}\n\nexport interface ContextTimeoutEvent {\n\tcallback: (...args: any[]) => void;\n\tid: number;\n\ttime: Seconds;\n}\n\n/**\n * Wrapper around the native AudioContext.\n */\nexport class Context extends Emitter<\"statechange\" | \"tick\"> implements BaseAudioContextSubset {\n\n\tname = \"Context\";\n\n\t/**\n\t * The amount of time into the future events are scheduled. Giving Web Audio\n\t * a short amount of time into the future to schedule events can reduce clicks and\n\t * improve performance. This value can be set to 0 to get the lowest latency.\n\t */\n\tlookAhead: Seconds;\n\n\t/**\n\t * private reference to the BaseAudioContext\n\t */\n\tprotected readonly _context: AnyAudioContext;\n\n\t/**\n\t * A reliable callback method\n\t */\n\tprivate readonly _ticker: Ticker;\n\n\t/**\n\t *  The default latency hint\n\t */\n\tprivate _latencyHint: ContextLatencyHint | Seconds;\n\n\t/**\n\t *  An object containing all of the constants AudioBufferSourceNodes\n\t */\n\tprivate _constants = new Map<number, AudioBufferSourceNode>();\n\n\t/**\n\t *  All of the setTimeout events.\n\t */\n\tprivate _timeouts: Timeline<ContextTimeoutEvent> = new Timeline();\n\n\t/**\n\t *  The timeout id counter\n\t */\n\tprivate _timeoutIds = 0;\n\n\t/**\n\t * A reference the Transport singleton belonging to this context\n\t */\n\tprivate _transport!: Transport;\n\n\t/**\n\t * A reference the Destination singleton belonging to this context\n\t */\n\tprivate _destination!: Destination;\n\n\t/**\n\t * Private indicator if the context has been initialized\n\t */\n\tprivate _initialized: boolean = false;\n\n\tconstructor(context?: AnyAudioContext);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<ContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n\n\t\tthis._context = options.context;\n\n\t\tthis._latencyHint = options.latencyHint;\n\t\tthis.lookAhead = options.lookAhead;\n\n\t\tthis._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n\t\tthis.on(\"tick\", this._timeoutLoop.bind(this));\n\n\t\t// fwd events from the context\n\t\tthis._context.addEventListener(\"statechange\", () => {\n\t\t\tthis.emit(\"statechange\", this.state);\n\t\t});\n\t}\n\n\tstatic getDefaults(): ContextOptions {\n\t\treturn {\n\t\t\tclockSource: \"worker\",\n\t\t\tcontext: getAudioContext(),\n\t\t\tlatencyHint: \"interactive\",\n\t\t\tlookAhead: 0.1,\n\t\t\tupdateInterval: 0.03,\n\t\t};\n\t}\n\n\t/**\n\t * Finish setting up the context. **You usually do not need to do this manually.**\n\t */\n\tinitialize(): this {\n\t\tif (!this._initialized) {\n\t\t\t// add any additional modules\n\t\t\tinitializeContext(this);\n\t\t\tthis._initialized = true;\n\t\t}\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// BASE AUDIO CONTEXT METHODS\n\t///////////////////////////////////////////////////////////////////////\n\n\tcreateAnalyser(): AnalyserNode {\n\t\treturn this._context.createAnalyser();\n\t}\n\tcreateOscillator(): OscillatorNode {\n\t\treturn this._context.createOscillator();\n\t}\n\tcreateBufferSource(): AudioBufferSourceNode {\n\t\treturn this._context.createBufferSource();\n\t}\n\tcreateBiquadFilter(): BiquadFilterNode {\n\t\treturn this._context.createBiquadFilter();\n\t}\n\tcreateBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer {\n\t\treturn this._context.createBuffer(numberOfChannels, length, sampleRate);\n\t}\n\tcreateChannelMerger(numberOfInputs?: number | undefined): ChannelMergerNode {\n\t\treturn this._context.createChannelMerger(numberOfInputs);\n\t}\n\tcreateChannelSplitter(numberOfOutputs?: number | undefined): ChannelSplitterNode {\n\t\treturn this._context.createChannelSplitter(numberOfOutputs);\n\t}\n\tcreateConstantSource(): ConstantSourceNode {\n\t\treturn this._context.createConstantSource();\n\t}\n\tcreateConvolver(): ConvolverNode {\n\t\treturn this._context.createConvolver();\n\t}\n\tcreateDelay(maxDelayTime?: number | undefined): DelayNode {\n\t\treturn this._context.createDelay(maxDelayTime);\n\t}\n\tcreateDynamicsCompressor(): DynamicsCompressorNode {\n\t\treturn this._context.createDynamicsCompressor();\n\t}\n\tcreateGain(): GainNode {\n\t\treturn this._context.createGain();\n\t}\n\tcreateIIRFilter(feedforward: number[], feedback: number[]): IIRFilterNode {\n\t\treturn this._context.createIIRFilter(feedforward, feedback);\n\t}\n\tcreatePanner(): PannerNode {\n\t\treturn this._context.createPanner();\n\t}\n\tcreatePeriodicWave(\n\t\treal: number[] | Float32Array,\n\t\timag: number[] | Float32Array,\n\t\tconstraints?: PeriodicWaveConstraints | undefined,\n\t): PeriodicWave {\n\t\treturn this._context.createPeriodicWave(real, imag, constraints);\n\t}\n\tcreateStereoPanner(): StereoPannerNode {\n\t\treturn this._context.createStereoPanner();\n\t}\n\tcreateWaveShaper(): WaveShaperNode {\n\t\treturn this._context.createWaveShaper();\n\t}\n\tdecodeAudioData(audioData: ArrayBuffer): Promise<AudioBuffer> {\n\t\treturn this._context.decodeAudioData(audioData);\n\t}\n\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._context.currentTime;\n\t}\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget state(): AudioContextState {\n\t\treturn this._context.state;\n\t}\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget sampleRate(): number {\n\t\treturn this._context.sampleRate;\n\t}\n\t/**\n\t *  The listener\n\t */\n\tget listener(): AudioListener {\n\t\treturn this._context.listener;\n\t}\n\n\t/**\n\t *  There is only one Transport per Context. It is created on initialization.\n\t */\n\tget transport(): Transport {\n\t\tthis.assert(this._initialized, \"The context must be initialized before being used by invoking context.initialize()\");\n\t\treturn this._transport;\n\t}\n\tset transport(t: Transport) {\n\t\tthis.assert(!this._initialized, \"The transport cannot be set after initialization.\");\n\t\tthis._transport = t;\n\t}\n\n\t/**\n\t *  A reference to the Context's destination node.\n\t */\n\tget destination(): Destination {\n\t\tthis.assert(this._initialized, \"The context must be initialized before being used by invoking context.initialize()\");\n\t\treturn this._destination;\n\t}\n\tset destination(d: Destination) {\n\t\tthis.assert(!this._initialized, \"The transport cannot be set after initialization.\");\n\t\tthis._destination = d;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// TICKER\n\t///////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  How often the interval callback is invoked.\n\t *  This number corresponds to how responsive the scheduling\n\t *  can be. context.updateInterval + context.lookAhead gives you the\n\t *  total latency between scheduling an event and hearing it.\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._ticker.updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._ticker.updateInterval = interval;\n\t}\n\n\t/**\n\t *  What the source of the clock is, either \"worker\" (default),\n\t *  \"timeout\", or \"offline\" (none).\n\t */\n\tget clockSource(): TickerClockSource {\n\t\treturn this._ticker.type;\n\t}\n\tset clockSource(type: TickerClockSource) {\n\t\tthis._ticker.type = type;\n\t}\n\n\t/**\n\t * The type of playback, which affects tradeoffs between audio\n\t * output latency and responsiveness.\n\t * In addition to setting the value in seconds, the latencyHint also\n\t * accepts the strings \"interactive\" (prioritizes low latency),\n\t * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n\t * latency and performance), and \"fastest\" (lowest latency, might glitch more often).\n\t * @example\n\t * //set the lookAhead to 0.3 seconds\n\t * Tone.context.latencyHint = 0.3;\n\t */\n\tget latencyHint(): ContextLatencyHint | Seconds {\n\t\treturn this._latencyHint;\n\t}\n\tset latencyHint(hint: ContextLatencyHint | Seconds) {\n\t\tlet lookAheadValue = 0;\n\t\tthis._latencyHint = hint;\n\t\tif (isString(hint)) {\n\t\t\tswitch (hint) {\n\t\t\t\tcase \"interactive\":\n\t\t\t\t\tlookAheadValue = 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"playback\":\n\t\t\t\t\tlookAheadValue = 0.8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"balanced\":\n\t\t\t\t\tlookAheadValue = 0.25;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"fastest\":\n\t\t\t\t\tlookAheadValue = 0.01;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.lookAhead = lookAheadValue;\n\t\tthis.updateInterval = lookAheadValue / 3;\n\t}\n\n\t/**\n\t *  The unwrapped AudioContext.\n\t */\n\tget rawContext(): AnyAudioContext {\n\t\treturn this._context;\n\t}\n\n\t/**\n\t * The current audio context time plus a short {@link lookAhead}.\n\t */\n\tnow(): Seconds {\n\t\treturn this._context.currentTime + this.lookAhead;\n\t}\n\n\t/**\n\t *  Starts the audio context from a suspended state. This is required\n\t *  to initially start the AudioContext.\n\t */\n\tresume(): Promise<void> {\n\t\tif (this._context.state === \"suspended\" && isAudioContext(this._context)) {\n\t\t\treturn this._context.resume();\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t *  Promise which is invoked when the context is running.\n\t *  Tries to resume the context if it's not started.\n\t */\n\tasync close(): Promise<void> {\n\t\tif (isAudioContext(this._context)) {\n\t\t\tawait this._context.close();\n\t\t}\n\t\tif (this._initialized) {\n\t\t\tcloseContext(this);\n\t\t}\n\t}\n\n\t/**\n\t *  Generate a looped buffer at some constant value.\n\t */\n\tgetConstant(val: number): AudioBufferSourceNode {\n\t\tif (this._constants.has(val)) {\n\t\t\treturn this._constants.get(val) as AudioBufferSourceNode;\n\t\t} else {\n\t\t\tconst buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\t\t\tconst arr = buffer.getChannelData(0);\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = val;\n\t\t\t}\n\t\t\tconst constant = this._context.createBufferSource();\n\t\t\tconstant.channelCount = 1;\n\t\t\tconstant.channelCountMode = \"explicit\";\n\t\t\tconstant.buffer = buffer;\n\t\t\tconstant.loop = true;\n\t\t\tconstant.start(0);\n\t\t\tthis._constants.set(val, constant);\n\t\t\treturn constant;\n\t\t}\n\t}\n\n\t/**\n\t *  Clean up. Also closes the audio context.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._ticker.dispose();\n\t\tthis._timeouts.dispose();\n\t\tObject.keys(this._constants).map(val => this._constants[val].disconnect());\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// TIMEOUTS\n\t///////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  The private loop which keeps track of the context scheduled timeouts\n\t *  Is invoked from the clock source\n\t */\n\tprivate _timeoutLoop(): void  {\n\t\tconst now = this.now();\n\t\tlet firstEvent = this._timeouts.peek();\n\t\twhile (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n\t\t\t// invoke the callback\n\t\t\tfirstEvent.callback();\n\t\t\t// shift the first event off\n\t\t\tthis._timeouts.shift();\n\t\t\t// get the next one\n\t\t\tfirstEvent = this._timeouts.peek();\n\t\t}\n\t}\n\n\t/**\n\t *  A setTimeout which is guarented by the clock source.\n\t *  Also runs in the offline context.\n\t *  @param  fn       The callback to invoke\n\t *  @param  timeout  The timeout in seconds\n\t *  @returns ID to use when invoking Context.clearTimeout\n\t */\n\tsetTimeout(fn: (...args: any[]) => void, timeout: Seconds): number {\n\t\tthis._timeoutIds++;\n\t\tconst now = this.now();\n\t\tthis._timeouts.add({\n\t\t\tcallback : fn,\n\t\t\tid : this._timeoutIds,\n\t\t\ttime : now + timeout,\n\t\t});\n\t\treturn this._timeoutIds;\n\t}\n\n\t/**\n\t *  Clears a previously scheduled timeout with Tone.context.setTimeout\n\t *  @param  id  The ID returned from setTimeout\n\t */\n\tclearTimeout(id: number): Context {\n\t\tthis._timeouts.forEach(event => {\n\t\t\tif (event.id === id) {\n\t\t\t\tthis._timeouts.remove(event);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n","import { version } from \"../version\";\nimport { hasAudioContext, theWindow } from \"./context/AudioContext\";\nimport { Context } from \"./context/Context\";\n\n/**\n * This dummy context is used to avoid throwing immediate errors when importing in Node.js\n */\nconst dummyContext: Context = {\n\tdestination: {},\n\ttransport: {},\n} as Context;\n\n/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext: Context = dummyContext;\n\n/**\n * Returns the default system-wide AudioContext\n */\nexport function getContext(): Context {\n\tif (globalContext === dummyContext && hasAudioContext) {\n\t\tsetContext(new Context());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n */\nexport function setContext(context: Context): void {\n\tglobalContext = context;\n\tcontext.initialize();\n}\n\n/**\n * Most browsers will not play _any_ audio until a user\n * clicks something (like a play button). Invoke this method\n * on a click or keypress event handler to start the audio context.\n * More about the Autoplay policy\n * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n * @example\n * document.querySelector('#playbutton').addEventListener('click', () => Tone.start())\n */\nexport function start(): Promise <void> {\n\treturn globalContext.resume();\n}\n\n/**\n * Log Tone.js + version in the console.\n */\nif (theWindow && !theWindow.TONE_SILENCE_LOGGING) {\n\tlet prefix = \"v\";\n\tif (version === \"dev\") {\n\t\tprefix = \"\";\n\t}\n\tconst printString = ` * Tone.js ${prefix}${version} * `;\n\t// tslint:disable-next-line: no-console\n\tconsole.log(`%c${printString}`, \"background: #000; color: #fff\");\n}\n","import { Decibels, GainFactor, Hertz, Interval, MidiNote, NormalRange } from \"./Units\";\n\n/**\n *  Equal power gain scale. Good for cross-fading.\n *  @param  percent (0-1)\n */\nexport function equalPowerScale(percent: NormalRange): number {\n\tconst piFactor = 0.5 * Math.PI;\n\treturn Math.sin(percent * piFactor);\n}\n\n/**\n *  Convert decibels into gain.\n */\nexport function dbToGain(db: Decibels): GainFactor {\n\treturn Math.pow(10, db / 20);\n}\n\n/**\n *  Convert gain to decibels.\n */\nexport function gainToDb(gain: GainFactor): Decibels {\n\treturn 20 * (Math.log(gain) / Math.LN10);\n}\n\n/**\n * Convert an interval (in semitones) to a frequency ratio.\n * @param interval the number of semitones above the base note\n * @example\n * tone.intervalToFrequencyRatio(0); // 1\n * tone.intervalToFrequencyRatio(12); // 2\n * tone.intervalToFrequencyRatio(-12); // 0.5\n */\nexport function intervalToFrequencyRatio(interval: Interval): number {\n\treturn Math.pow(2, (interval / 12));\n}\n\n/**\n * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n * to generate all the other pitch values from notes. A4's values in Hertz.\n */\nlet A4: Hertz = 440;\n\nexport function getA4(): Hertz {\n\treturn A4;\n}\n\nexport function setA4(freq: Hertz): void {\n\tA4 = freq;\n}\n\n/**\n * Convert a frequency value to a MIDI note.\n * @param frequency The value to frequency value to convert.\n * @example\n * ftom(440); // returns 69\n */\nexport function ftom(frequency: Hertz): MidiNote {\n\treturn Math.round(ftomf(frequency)) as MidiNote;\n}\n\n/**\n * Convert a frequency to a floating point midi value\n */\nexport function ftomf(frequency: Hertz): number {\n\treturn 69 + 12 * Math.log2(frequency / A4);\n}\n\n/**\n * Convert a MIDI note to frequency value.\n * @param  midi The midi number to convert.\n * @return The corresponding frequency value\n * @example\n */\nexport function mtof(midi: MidiNote): Hertz {\n\treturn A4 * Math.pow(2, (midi - 69) / 12);\n}\n","import { Context } from \"../context/Context\";\nimport { Tone } from \"../Tone\";\nimport { isDefined, isObject , isString, isUndef } from \"../util/TypeCheck\";\nimport { BPM, Hertz, MidiNote, Milliseconds, Samples, Seconds, Ticks, Time } from \"./Units\";\n\nexport type TimeValue = Time | TimeBaseClass<any, any>;\n\n/**\n * The units that the TimeBase can accept. extended by other classes\n */\nexport type TimeBaseUnit = \"s\" | \"n\" | \"t\" | \"m\" | \"i\" | \"hz\" | \"tr\" | \"samples\" | \"number\";\n\nexport interface TypeFunction {\n\tregexp: RegExp;\n\tmethod: (value: string, ...args: string[]) => number;\n}\n\nexport interface TimeExpression<Type extends number> {\n\t[key: string]: {\n\t\tregexp: RegExp;\n\t\tmethod: (value: string, ...args: string[]) => Type;\n\t};\n}\n\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n * @param  val    The time value as a number, string or object\n * @param  units  Unit values\n * @example\n * new TimeBase(4, \"n\")\n * new TimeBase(2, \"t\")\n * new TimeBase(\"2t\")\n * new TimeBase({\"2t\" : 2})\n * new TimeBase(\"2t\") + new TimeBase(\"4n\");\n */\nexport abstract class TimeBaseClass<Type extends number, Unit extends string> extends Tone {\n\n\treadonly context: Context;\n\n\t/**\n\t * The value of the units\n\t */\n\tprotected _val?: TimeValue;\n\n\t/**\n\t * The units of time\n\t */\n\tprotected _units?: Unit;\n\n\t/**\n\t * All of the conversion expressions\n\t */\n\tprotected _expressions: TimeExpression<Type>;\n\n\t/**\n\t * The default units\n\t */\n\treadonly defaultUnits: Unit = \"s\" as Unit;\n\n\tconstructor(context: Context, value?: TimeValue, units?: Unit) {\n\t\tsuper();\n\n\t\tthis._val = value;\n\t\tthis._units = units;\n\t\tthis.context = context;\n\t\tthis._expressions = this._getExpressions();\n\t}\n\n\t/**\n\t * All of the time encoding expressions\n\t */\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn {\n\t\t\thz: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._frequencyToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n\t\t\t},\n\t\t\ti: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._ticksToUnits(parseInt(value, 10));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)i$/i,\n\t\t\t},\n\t\t\tm: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)m$/i,\n\t\t\t},\n\t\t\tn: {\n\t\t\t\tmethod: (value, dot) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\tconst scalar = dot === \".\" ? 1.5 : 1;\n\t\t\t\t\tif (numericValue === 1) {\n\t\t\t\t\t\treturn this._beatsToUnits(this._getTimeSignature()) * scalar as Type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this._beatsToUnits(4 / numericValue) * scalar as Type;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)n(\\.?)$/i,\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._expressions[this.defaultUnits].method.call(this, value);\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)$/,\n\t\t\t},\n\t\t\ts: {\n\t\t\t\tmethod: (value): Type => {\n\t\t\t\t\treturn this._secondsToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)s$/,\n\t\t\t},\n\t\t\tsamples: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn parseInt(value, 10) / this.context.sampleRate as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)samples$/,\n\t\t\t},\n\t\t\tt: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\treturn this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)t$/i,\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tmethod: (m, q, s) => {\n\t\t\t\t\tlet total = 0;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n\t\t\t},\n\t\t};\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tVALUE OF\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Evaluate the time value. Returns the time in seconds.\n\t */\n\tvalueOf(): Type {\n\t\tif (this._val instanceof TimeBaseClass) {\n\t\t\tthis.fromType(this._val);\n\t\t}\n\t\tif (isUndef(this._val)) {\n\t\t\treturn this._noArg();\n\t\t} else if (isString(this._val) && isUndef(this._units)) {\n\t\t\tfor (const units in this._expressions) {\n\t\t\t\tif (this._expressions[units].regexp.test(this._val.trim())) {\n\t\t\t\t\tthis._units = units as Unit;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(this._val)) {\n\t\t\tlet total = 0;\n\t\t\tfor (const typeName in this._val) {\n\t\t\t\tif (isDefined(this._val[typeName])) {\n\t\t\t\t\tconst quantity = this._val[typeName];\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst time = (new this.constructor(this.context, typeName)).valueOf() * quantity;\n\t\t\t\t\ttotal += time;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn total as Type;\n\t\t}\n\t\tif (isDefined(this._units)) {\n\t\t\tconst expr = this._expressions[this._units];\n\t\t\tconst matching = this._val.toString().trim().match(expr.regexp);\n\t\t\tif (matching) {\n\t\t\t\treturn expr.method.apply(this, matching.slice(1));\n\t\t\t} else {\n\t\t\t\treturn expr.method.call(this, this._val);\n\t\t\t}\n\t\t} else if (isString(this._val)) {\n\t\t\treturn parseFloat(this._val) as Type;\n\t\t} else {\n\t\t\treturn this._val as Type;\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn 1 / freq as Type;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn (60 / this._getBpm()) * beats as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn seconds as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t *  @private\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn (ticks * (this._beatsToUnits(1)) / this._getPPQ()) as Type;\n\t}\n\n\t/**\n\t *  With no arguments, return 'now'\n\t */\n\tprotected _noArg(): Type {\n\t\treturn this._now();\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tTEMPO CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Return the bpm\n\t */\n\tprotected _getBpm(): BPM {\n\t\treturn this.context.transport.bpm.value;\n\t}\n\n\t/**\n\t * Return the timeSignature\n\t */\n\tprotected _getTimeSignature(): number {\n\t\treturn this.context.transport.timeSignature as number;\n\t}\n\n\t/**\n\t * Return the PPQ or 192 if Transport is not available\n\t */\n\tprotected _getPPQ(): number {\n\t\treturn this.context.transport.PPQ;\n\t}\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected abstract _now(): Type;\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tCONVERSION INTERFACE\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Coerce a time type into this units type.\n\t * @param type Any time type units\n\t */\n\tfromType(type: TimeBaseClass<any, any>): this {\n\t\tthis._units = undefined;\n\t\tswitch (this.defaultUnits) {\n\t\t\tcase \"s\":\n\t\t\t\tthis._val = type.toSeconds();\n\t\t\t\tbreak;\n\t\t\tcase \"i\":\n\t\t\t\tthis._val = type.toTicks();\n\t\t\t\tbreak;\n\t\t\tcase \"hz\":\n\t\t\t\tthis._val = type.toFrequency();\n\t\t\t\tbreak;\n\t\t\tcase \"midi\":\n\t\t\t\tthis._val = type.toMidi();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Return the value in seconds\n\t */\n\tabstract toSeconds(): Seconds;\n\n\t/**\n\t *  Return the value as a Midi note\n\t */\n\tabstract toMidi(): MidiNote;\n\n\t/**\n\t * Convert the value into ticks\n\t */\n\tabstract toTicks(): Ticks;\n\n\t/**\n\t *  Return the value in hertz\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn 1 / this.toSeconds();\n\t}\n\n\t/**\n\t *  Return the time in samples\n\t */\n\ttoSamples(): Samples {\n\t\treturn this.toSeconds() * this.context.sampleRate;\n\t}\n\n\t/**\n\t *  Return the time in milliseconds.\n\t */\n\ttoMilliseconds(): Milliseconds {\n\t\treturn this.toSeconds() * 1000;\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass, TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\nimport { BarsBeatsSixteenths, MidiNote, Seconds, Subdivision, Ticks, Time } from \"./Units\";\n\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * var t = Time(\"4n\");//a quarter note\n */\nexport class TimeClass<Type extends Seconds | Ticks = Seconds, Unit extends string = TimeBaseUnit>\nextends TimeBaseClass<Type, Unit> {\n\n\tname = \"Time\";\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign(super._getExpressions(), {\n\t\t\tnow: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\treturn this._now() + new (this.constructor as typeof TimeClass)(this.context, capture).valueOf() as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^\\+(.+)/,\n\t\t\t},\n\t\t\tquantize: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\tconst quantTo = new TimeClass(this.context, capture).valueOf();\n\t\t\t\t\treturn this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n\t\t\t\t},\n\t\t\t\tregexp: /^@(.+)/,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Quantize the time by the given subdivision. Optionally add a\n\t * percentage which will move the time value towards the ideal\n\t * quantized value by that percentage.\n\t * @param  val    The subdivision to quantize to\n\t * @param  percent  Move the time value towards the quantized value by a percentage.\n\t * @example\n\t * Time(21).quantize(2) //returns 22\n\t * Time(0.6).quantize(\"4n\", 0.5) //returns 0.55\n\t */\n\tquantize(subdiv: Time, percent = 1): Type {\n\t\tconst subdivision = new (this.constructor as typeof TimeClass)(this.context, subdiv).valueOf();\n\t\tconst value = this.valueOf();\n\t\tconst multiple = Math.round(value / subdivision);\n\t\tconst ideal = multiple * subdivision;\n\t\tconst diff = ideal - value;\n\t\treturn value + diff * percent as Type;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\t/**\n\t *  Convert a Time to Notation. The notation values are will be the\n\t *  closest representation between 1m to 128th note.\n\t *  @return {Notation}\n\t *  @example\n\t * //if the Transport is at 120bpm:\n\t * Time(2).toNotation();//returns \"1m\"\n\t */\n\ttoNotation(): Subdivision {\n\t\tconst time = this.toSeconds();\n\t\tconst testNotations: Subdivision[] = [\"1m\"];\n\t\tfor (let power = 1; power < 9; power++) {\n\t\t\tconst subdiv = Math.pow(2, power);\n\t\t\ttestNotations.push(subdiv + \"n.\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"n\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"t\" as Subdivision);\n\t\t}\n\t\ttestNotations.push(\"0\");\n\t\t// find the closets notation representation\n\t\tlet closest = testNotations[0];\n\t\tlet closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n\t\ttestNotations.forEach(notation => {\n\t\t\tconst notationSeconds = new TimeClass(this.context, notation).toSeconds();\n\t\t\tif (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n\t\t\t\tclosest = notation;\n\t\t\t\tclosestSeconds = notationSeconds;\n\t\t\t}\n\t\t});\n\t\treturn closest;\n\t}\n\n\t/**\n\t *  Return the time encoded as Bars:Beats:Sixteenths.\n\t */\n\ttoBarsBeatsSixteenths(): BarsBeatsSixteenths {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tlet quarters = this.valueOf() / quarterTime;\n\t\tquarters = parseFloat(quarters.toFixed(4));\n\t\tconst measures = Math.floor(quarters / this._getTimeSignature());\n\t\tlet sixteenths = (quarters % 1) * 4;\n\t\tquarters = Math.floor(quarters) % this._getTimeSignature();\n\t\tconst sixteenthString = sixteenths.toString();\n\t\tif (sixteenthString.length > 3) {\n\t\t\t// the additional parseFloat removes insignificant trailing zeroes\n\t\t\tsixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n\t\t}\n\t\tconst progress = [measures, quarters, sixteenths];\n\t\treturn progress.join(\":\");\n\t}\n\n\t/**\n\t *  Return the time in ticks.\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.round(quarters * this._getPPQ());\n\t}\n\n\t/**\n\t *  Return the time in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t *  Return the value as a midi note.\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.toFrequency());\n\t}\n\n\tprotected _now(): Type {\n\t\treturn this.context.now() as Type;\n\t}\n}\n\n/**\n * Create a TimeClass from a time string or number.\n * @param value A value which reprsents time\n * @param units The value's units if they can't be inferred by the value.\n */\nexport function Time(value?: TimeValue, units?: TimeBaseUnit): TimeClass<Seconds> {\n\treturn new TimeClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { intervalToFrequencyRatio, mtof } from \"./Conversions\";\nimport { ftom, getA4, setA4 } from \"./Conversions\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseClass, TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\nimport { Frequency, Hertz, Interval, MidiNote, Note, Seconds, Ticks } from \"./Units\";\n\nexport type FrequencyUnit = TimeBaseUnit | \"midi\";\n\n/**\n * Frequency is a primitive type for encoding Frequency values.\n * Eventually all time values are evaluated to hertz using the `eval` method.\n * @example\n * Frequency(\"C3\") // 261\n * Frequency(38, \"midi\") //\n * Frequency(\"C3\").transpose(4);\n */\nexport class FrequencyClass<Type extends number = Hertz> extends TimeClass<Type, FrequencyUnit> {\n\n\tname = \"Frequency\";\n\n\treadonly defaultUnits: FrequencyUnit = \"hz\";\n\n\t/**\n\t * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n\t * to generate all the other pitch values from notes. A4's values in Hertz.\n\t */\n\tstatic get A4(): Hertz {\n\t\treturn getA4();\n\t}\n\tstatic set A4(freq: Hertz) {\n\t\tsetA4(freq);\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tAUGMENT BASE EXPRESSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign({}, super._getExpressions(), {\n\t\t\tmidi : {\n\t\t\t\tregexp : /^(\\d+(?:\\.\\d+)?midi)/,\n\t\t\t\tmethod(value): number {\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\tnote : {\n\t\t\t\tregexp : /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n\t\t\t\tmethod(pitch, octave): number {\n\t\t\t\t\tconst index = noteToScaleIndex[pitch.toLowerCase()];\n\t\t\t\t\tconst noteNumber = index + (parseInt(octave, 10) + 1) * 12;\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn noteNumber;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(noteNumber);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\ttr : {\n\t\t\t\tregexp : /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\t\t\t\tmethod(m, q, s): number {\n\t\t\t\t\tlet total = 1;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total;\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tEXPRESSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Transposes the frequency by the given number of semitones.\n\t *  @return  A new transposed frequency\n\t *  @example\n\t * Frequency(\"A4\").transpose(3); //\"C5\"\n\t */\n\ttranspose(interval: Interval): FrequencyClass {\n\t\treturn new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));\n\t}\n\n\t/**\n\t *  Takes an array of semitone intervals and returns\n\t *  an array of frequencies transposed by those intervals.\n\t *  @return  Returns an array of Frequencies\n\t *  @example\n\t * Frequency(\"A4\").harmonize([0, 3, 7]); //[\"A4\", \"C5\", \"E5\"]\n\t */\n\tharmonize(intervals: Interval[]): FrequencyClass[] {\n\t\treturn intervals.map(interval => {\n\t\t\treturn this.transpose(interval);\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @example\n\t * Frequency(\"C4\").toMidi(); //60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.valueOf());\n\t}\n\n\t/**\n\t * Return the value of the frequency in Scientific Pitch Notation\n\t * @example\n\t * Frequency(69, \"midi\").toNote(); //\"A4\"\n\t */\n\ttoNote(): Note {\n\t\tconst freq = this.toFrequency();\n\t\tconst log = Math.log2(freq / FrequencyClass.A4);\n\t\tlet noteNumber = Math.round(12 * log) + 57;\n\t\tconst octave = Math.floor(noteNumber / 12);\n\t\tif (octave < 0) {\n\t\t\tnoteNumber += -12 * octave;\n\t\t}\n\t\tconst noteName = scaleIndexToNote[noteNumber % 12];\n\t\treturn noteName + octave.toString() as Note;\n\t}\n\n\t/**\n\t *  Return the duration of one cycle in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn 1 / super.toSeconds();\n\t}\n\n\t/**\n\t *  Return the duration of one cycle in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.floor(quarters * this._getPPQ());\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS HELPERS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  With no arguments, return 0\n\t */\n\tprotected _noArg(): Type {\n\t\treturn 0 as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn freq as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn 1 / ((ticks * 60) / (this._getBpm() * this._getPPQ())) as Type;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn 1 / super._beatsToUnits(beats) as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn 1 / seconds as Type;\n\t}\n\n\t/**\n\t * Convert a MIDI note to frequency value.\n\t * @param  midi The midi number to convert.\n\t * @return The corresponding frequency value\n\t * @example\n\t * FrequencyClass.mtof(69); // returns 440\n\t */\n\tstatic mtof(midi: MidiNote): Hertz {\n\t\treturn mtof(midi);\n\t}\n\n\t/**\n\t * Convert a frequency value to a MIDI note.\n\t * @param frequency The value to frequency value to convert.\n\t * @example\n\t * Frequency.ftom(440); // returns 69\n\t */\n\tstatic ftom(frequency: Hertz): MidiNote {\n\t\treturn ftom(frequency);\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tFREQUENCY CONVERSIONS\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Note to scale index\n *  @type  {Object}\n *  @private\n */\nconst noteToScaleIndex = {\n\t// tslint:disable-next-line\n\t\"cbb\" : -2, \"cb\" : -1, \"c\" : 0, \"c#\" : 1, \"cx\" : 2,\n\t\"dbb\" : 0, \"db\" : 1, \"d\" : 2, \"d#\" : 3, \"dx\" : 4,\n\t\"ebb\" : 2, \"eb\" : 3, \"e\" : 4, \"e#\" : 5, \"ex\" : 6,\n\t\"fbb\" : 3, \"fb\" : 4, \"f\" : 5, \"f#\" : 6, \"fx\" : 7,\n\t\"gbb\" : 5, \"gb\" : 6, \"g\" : 7, \"g#\" : 8, \"gx\" : 9,\n\t\"abb\" : 7, \"ab\" : 8, \"a\" : 9, \"a#\" : 10, \"ax\" : 11,\n\t\"bbb\" : 9, \"bb\" : 10, \"b\" : 11, \"b#\" : 12, \"bx\" : 13,\n};\n\n/**\n *  scale index to note (sharps)\n *  @type  {Array}\n *  @private\n */\nconst scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\n/**\n * Convert a value into a FrequencyClass object.\n */\nexport function Frequency(value?: TimeValue | Frequency, units?: FrequencyUnit): FrequencyClass {\n\treturn new FrequencyClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { Seconds, Ticks } from \"../type/Units\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n */\nexport class TransportTimeClass<Type extends Seconds | Ticks = Seconds> extends TimeClass<Type> {\n\n\tname = \"TransportTime\";\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected _now(): Type {\n\t\treturn this.context.transport.seconds as Type;\n\t}\n}\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n */\nexport function TransportTime(value?: TimeValue, units?: TimeBaseUnit): TransportTimeClass {\n\treturn new TransportTimeClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { FrequencyClass } from \"../type/Frequency\";\nimport { TimeClass } from \"../type/Time\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { getDefaultsFromInstance, omitFromObject, optionsFromArguments } from \"../util/Defaults\";\nimport { RecursivePartial } from \"../util/Interface\";\nimport { isArray, isBoolean, isDefined, isNumber, isString, isUndef } from \"../util/TypeCheck\";\nimport { Context } from \"./Context\";\n\n/**\n * A unit which process audio\n */\nexport interface ToneWithContextOptions {\n\tcontext: Context;\n}\n\n/**\n * The Base class for all nodes that have an AudioContext.\n */\nexport abstract class ToneWithContext<Options extends ToneWithContextOptions> extends Tone {\n\n\t/**\n\t * The context belonging to the node.\n\t */\n\treadonly context: Context;\n\n\t/**\n\t * The default context to use if no AudioContext is passed in to the constructor\n\t */\n\treadonly defaultContext?: Context;\n\n\tconstructor(context?: Context | Partial<ToneWithContextOptions>) {\n\t\tconst options = optionsFromArguments(ToneWithContext.getDefaults(), arguments, [\"context\"]);\n\t\tsuper();\n\t\tif (this.defaultContext) {\n\t\t\tthis.context = this.defaultContext;\n\t\t} else {\n\t\t\tthis.context = options.context;\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneWithContextOptions {\n\t\treturn {\n\t\t\tcontext: getContext(),\n\t\t};\n\t}\n\n\t/**\n\t * Return the current time of the Context clock plus the lookAhead.\n\t */\n\tnow(): Seconds {\n\t\treturn this.context.currentTime + this.context.lookAhead;\n\t}\n\n\t/**\n\t * Return the current time of the Context clock without any lookAhead.\n\t */\n\timmediate(): Seconds {\n\t\treturn this.context.currentTime;\n\t}\n\n\t/**\n\t * The duration in seconds of one sample.\n\t */\n\tget sampleTime(): Seconds {\n\t\treturn 1 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * The number of seconds of 1 processing block (128 samples)\n\t */\n\tget blockTime(): Seconds {\n\t\treturn 128 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * Convert the incoming time to seconds\n\t */\n\ttoSeconds(time?: Time): Seconds {\n\t\treturn new TimeClass(this.context, time).toSeconds();\n\t}\n\n\t/**\n\t * Convert the input to a frequency number\n\t */\n\ttoFrequency(freq: Frequency): Hertz {\n\t\treturn new FrequencyClass(this.context, freq).toFrequency();\n\t}\n\n\t/**\n\t * Convert the input time into ticks\n\t */\n\ttoTicks(time?: Time | TimeClass): Ticks {\n\t\treturn new TransportTimeClass(this.context, time).toTicks();\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tGET/SET\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Get the object's attributes.\n\t * @example\n\t * osc.get();\n\t * //returns {\"type\" : \"sine\", \"frequency\" : 440, ...etc}\n\t */\n\tget(): Options {\n\t\tconst defaults = getDefaultsFromInstance(this) as Options;\n\t\tObject.keys(defaults).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute)) {\n\t\t\t\tconst member = this[attribute];\n\t\t\t\tif (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {\n\t\t\t\t\tdefaults[attribute] = member.value;\n\t\t\t\t} else if (member instanceof ToneWithContext) {\n\t\t\t\t\tdefaults[attribute] = member.get();\n\t\t\t\t// otherwise make sure it's a serializable type\n\t\t\t\t} else if (isArray(member) || isNumber(member) || isString(member) || isBoolean(member)) {\n\t\t\t\t\tdefaults[attribute] = member;\n\t\t\t\t} else {\n\t\t\t\t\t// remove all undefined and unserializable attributes\n\t\t\t\t\tdelete defaults[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn defaults;\n\t}\n\n\t/**\n\t * Set the parameters at once. Either pass in an\n\t * object mapping parameters to values, or to set a\n\t * single parameter, by passing in a string and value.\n\t * The last argument is an optional ramp time which\n\t * will ramp any signal values to their destination value\n\t * over the duration of the rampTime.\n\t * @param  params\n\t * @example\n\t * //set values using an object\n\t * filter.set({\n\t * \t\"frequency\" : 300,\n\t * \t\"type\" : \"highpass\"\n\t * });\n\t */\n\tset(props: RecursivePartial<Options>): this {\n\t\tObject.keys(props).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute) && isDefined(this[attribute])) {\n\t\t\t\tif (this[attribute] && isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {\n\t\t\t\t\t// small optimization\n\t\t\t\t\tif (this[attribute].value !== props[attribute]) {\n\t\t\t\t\t\tthis[attribute].value = props[attribute];\n\t\t\t\t\t}\n\t\t\t\t} else if (this[attribute] instanceof ToneWithContext) {\n\t\t\t\t\tthis[attribute].set(props[attribute]);\n\t\t\t\t} else {\n\t\t\t\t\tthis[attribute] = props[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n","import { AbstractParam } from \"../context/AbstractParam\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { AudioRange, Decibels, Frequency, NormalRange, Positive, Time, Unit, UnitName } from \"../type/Units\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\n\nexport interface ParamOptions extends ToneWithContextOptions {\n\tunits: UnitName;\n\tvalue?: any;\n\tparam: AudioParam;\n\tconvert: boolean;\n}\n\n/**\n * the possible automation types\n */\ntype AutomationType = \"linear\" | \"exponential\" | \"setValue\" | \"setTarget\" | \"cancel\";\n\n/**\n * The events on the automation\n */\nexport interface AutomationEvent {\n\ttype: AutomationType;\n\ttime: number;\n\tvalue: number;\n\tconstant?: number;\n}\n\n/**\n *  Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n */\nexport class Param<Type extends Unit = number>\nextends ToneWithContext<ParamOptions>\nimplements AbstractParam<Type> {\n\n\tname = \"Param\";\n\n\tstatic getDefaults(): ParamOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t} as ParamOptions);\n\t}\n\n\t/**\n\t * The input connection\n\t */\n\treadonly input: AudioParam;\n\treadonly units: UnitName;\n\tconvert: boolean;\n\toverridden: boolean = false;\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<AutomationEvent>;\n\n\t/**\n\t *  The native parameter to control\n\t */\n\tprotected _param: AudioParam;\n\n\t/**\n\t *  The default value before anything is assigned\n\t */\n\tprotected _initialValue: number;\n\n\t/**\n\t *  The minimum output value\n\t */\n\tprivate _minOutput = 1e-7;\n\n\tconstructor(param: AudioParam, units?: Unit, convert?: boolean);\n\tconstructor(options: Partial<ParamOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n\n\t\tconst options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n\n\t\tthis.assert(isDefined(options.param) && isAudioParam(options.param), \"param must be an AudioParam\");\n\n\t\t// initialize\n\t\tthis._param = this.input = options.param;\n\t\tthis._events = new Timeline<AutomationEvent>(1000);\n\t\tthis._initialValue = this._param.defaultValue;\n\t\tthis.units = options.units;\n\t\tthis.convert = options.convert;\n\n\t\t// if the value is defined, set it immediately\n\t\tif (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n\t\t\tthis.setValueAtTime(options.value, 0);\n\t\t}\n\t}\n\n\tget value(): Type {\n\t\tconst now = this.now();\n\t\treturn this.getValueAtTime(now);\n\t}\n\tset value(value: Type) {\n\t\tthis._initialValue = this._fromType(value);\n\t\tthis.cancelScheduledValues(this.now());\n\t\tthis.setValueAtTime(value, this.now());\n\t}\n\n\tget minValue(): number {\n\t\tif (this.units === \"time\" || this.units === \"frequency\" ||\n\t\t\tthis.units === \"normalRange\" || this.units === \"positive\" ||\n\t\t\tthis.units === \"transportTime\" || this.units === \"ticks\" ||\n\t\t\tthis.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n\t\t\treturn 0;\n\t\t} else if (this.units === \"audioRange\") {\n\t\t\treturn -1;\n\t\t} else if (this.units === \"decibels\") {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn this._param.minValue;\n\t\t}\n\t}\n\n\tget maxValue(): number {\n\t\tif (this.units === \"normalRange\" ||\n\t\t\tthis.units === \"audioRange\") {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn this._param.maxValue;\n\t\t}\n\t}\n\n\t/**\n\t * Type guard based on the unit name\n\t */\n\tprivate _is<T>(arg: any, type: UnitName): arg is T {\n\t\treturn this.units === type;\n\t}\n\n\t/**\n\t *  Convert the given value from the type specified by Param.units\n\t *  into the destination value (such as Gain or Frequency).\n\t */\n\tprotected _fromType(val: Type): number {\n\t\tif (this.convert && !this.overridden) {\n\t\t\tif (this._is<Time>(val, \"time\")) {\n\t\t\t\treturn this.toSeconds(val);\n\t\t\t} else if (this._is<Decibels>(val, \"decibels\")) {\n\t\t\t\treturn dbToGain(val);\n\t\t\t} else if (this._is<Frequency>(val, \"frequency\")) {\n\t\t\t\treturn this.toFrequency(val);\n\t\t\t} else if (this._is<NormalRange>(val, \"normalRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, 0), 1);\n\t\t\t} else if (this._is<AudioRange>(val, \"audioRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, -1), 1);\n\t\t\t} else if (this._is<Positive>(val, \"positive\")) {\n\t\t\t\treturn Math.max(val, 0);\n\t\t\t} else if (this._is<number>(val, \"number\")) {\n\t\t\t\treturn val;\n\t\t\t} else {\n\t\t\t\treturn val as number;\n\t\t\t}\n\t\t} else {\n\t\t\treturn val as number;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the parameters value into the units specified by Param.units.\n\t */\n\tprotected _toType(val: number): Type {\n\t\tif (this.convert && this.units === \"decibels\") {\n\t\t\treturn gainToDb(val) as Type;\n\t\t} else {\n\t\t\treturn val as Type;\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// ABSTRACT PARAM INTERFACE\n\t// all docs are generated from ParamInterface.ts\n\t///////////////////////////////////////////////////////////////////////////\n\n\tsetValueAtTime(value: Type, time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst numericValue = this._fromType(value);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n\n\t\tthis.log(this.units, \"setValue\", value, computedTime);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValue\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis._param.setValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\tgetValueAtTime(time: Time): Type {\n\t\tconst computedTime = Math.max(this.toSeconds(time), 0);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tconst before = this._events.get(computedTime);\n\t\tlet value = this._initialValue;\n\t\t// if it was set by\n\t\tif (before === null) {\n\t\t\tvalue = this._initialValue;\n\t\t} else if (before.type === \"setTarget\" && (after === null || after.type === \"setValue\")) {\n\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\tlet previousVal;\n\t\t\tif (previous === null) {\n\t\t\t\tpreviousVal = this._initialValue;\n\t\t\t} else {\n\t\t\t\tpreviousVal = previous.value;\n\t\t\t}\n\t\t\tif (isDefined(before.constant)) {\n\t\t\t\tvalue = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n\t\t\t}\n\t\t} else if (after === null) {\n\t\t\tvalue = before.value;\n\t\t} else if (after.type === \"linear\" || after.type === \"exponential\") {\n\t\t\tlet beforeValue = before.value;\n\t\t\tif (before.type === \"setTarget\") {\n\t\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\t\tif (previous === null) {\n\t\t\t\t\tbeforeValue = this._initialValue;\n\t\t\t\t} else {\n\t\t\t\t\tbeforeValue = previous.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (after.type === \"linear\") {\n\t\t\t\tvalue = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t} else {\n\t\t\t\tvalue = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = before.value;\n\t\t}\n\t\treturn this._toType(value);\n\t}\n\n\tsetRampPoint(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tlet currentVal = this.getValueAtTime(time);\n\t\tthis.cancelAndHoldAtTime(time);\n\t\tif (this._fromType(currentVal) === 0) {\n\t\t\tcurrentVal = this._toType(this._minOutput);\n\t\t}\n\t\tthis.setValueAtTime(currentVal, time);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: Type, endTime: Time): this {\n\t\tconst numericValue = this._fromType(value);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"linear\",\n\t\t\tvalue : numericValue,\n\t\t});\n\t\tthis.log(this.units, \"linear\", value, computedTime);\n\t\tthis._param.linearRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: Type, endTime: Time): this {\n\t\tlet numericValue = this._fromType(value);\n\t\tnumericValue = Math.max(this._minOutput, numericValue);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\t// store the event\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"exponential\",\n\t\t\tvalue : numericValue,\n\t\t});\n\t\tthis.log(this.units, \"exponential\", value, computedTime);\n\t\tthis._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\tlinearRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialApproachValueAtTime(value, startTime, rampTime);\n\t\treturn this;\n\t}\n\n\texponentialApproachValueAtTime(value: Type, time: Time, rampTime: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\trampTime = this.toSeconds(rampTime);\n\t\tconst timeConstant = Math.log(rampTime + 1) / Math.log(200);\n\t\tthis.setTargetAtTime(value, time, timeConstant);\n\t\t// at 90% start a linear ramp to the final value\n\t\tthis.cancelAndHoldAtTime(time + rampTime * 0.9);\n\t\tthis.linearRampToValueAtTime(value, time + rampTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(value: Type, startTime: Time, timeConstant: Positive): this {\n\t\tconst numericValue = this._fromType(value);\n\t\t// The value will never be able to approach without timeConstant > 0.\n\t\tthis.assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n\t\tconst computedTime = this.toSeconds(startTime);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n\t\tthis._events.add({\n\t\t\tconstant: timeConstant,\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setTarget\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"setTarget\", value, computedTime, timeConstant);\n\t\tthis._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: Type[], startTime: Time, duration: Time, scaling: number = 1): this {\n\t\tduration = this.toSeconds(duration);\n\t\tstartTime = this.toSeconds(startTime);\n\t\tconst startingValue = this._fromType(values[0]) * scaling;\n\t\tthis.setValueAtTime(this._toType(startingValue), startTime);\n\t\tconst segTime = duration / (values.length - 1);\n\t\tfor (let i = 1; i < values.length; i++) {\n\t\t\tconst numericValue = this._fromType(values[i]) * scaling;\n\t\t\tthis.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n\t\tthis._events.cancel(computedTime);\n\t\tthis._param.cancelScheduledValues(computedTime);\n\t\tthis.log(this.units, \"cancel\", computedTime);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n\t\t// remove the schedule events\n\t\tthis.assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n\n\t\tthis.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n\n\t\tthis._param.cancelScheduledValues(computedTime);\n\n\t\t// if there is an event at the given computedTime\n\t\t// and that even is not a \"set\"\n\t\tconst before = this._events.get(computedTime);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tif (before && before.time === computedTime) {\n\t\t\t// remove everything after\n\t\t\tif (after) {\n\t\t\t\tthis._events.cancel(after.time);\n\t\t\t} else {\n\t\t\t\tthis._events.cancel(computedTime + this.sampleTime);\n\t\t\t}\n\t\t} else if (after) {\n\t\t\t// cancel the next event(s)\n\t\t\tthis._events.cancel(after.time);\n\t\t\tif (after.type === \"linear\") {\n\t\t\t\tthis.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t} else if (after.type === \"exponential\") {\n\t\t\t\tthis.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t}\n\t\t}\n\n\t\t// set the value at the given time\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValue\",\n\t\t\tvalue: valueAtTime,\n\t\t});\n\t\tthis._param.setValueAtTime(valueAtTime, computedTime);\n\t\treturn this;\n\t}\n\n\trampTo(value: Type, rampTime: Time = 0.1, startTime?: Time): this {\n\t\tif (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n\t\t\tthis.exponentialRampTo(value, rampTime, startTime);\n\t\t} else {\n\t\t\tthis.linearRampTo(value, rampTime, startTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tAUTOMATION CURVE CALCULATIONS\n\t// \tMIT License, copyright (c) 2014 Jordan Santell\n\t///////////////////////////////////////////////////////////////////////////\n\n\t// Calculates the the value along the curve produced by setTargetAtTime\n\tprotected _exponentialApproach(t0: number, v0: number, v1: number, timeConstant: number, t: number): number {\n\t\treturn v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t}\n\n\t// Calculates the the value along the curve produced by linearRampToValueAtTime\n\tprotected _linearInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t}\n\n\t// Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\tprotected _exponentialInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t}\n}\n","import { Unit } from \"../type/Units\";\nimport { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { assert } from \"../util/Debug\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\n\nexport type InputNode = ToneAudioNode | AudioNode |  Param<Unit> | AudioParam;\nexport type OutputNode = ToneAudioNode | AudioNode;\n\ninterface ChannelProperties {\n\tchannelCount: number;\n\tchannelCountMode: ChannelCountMode;\n\tchannelInterpretation: ChannelInterpretation;\n}\n\n/**\n * The possible options for this node\n */\nexport type ToneAudioNodeOptions = ToneWithContextOptions;\n\n/**\n *  ToneAudioNode is the base class for classes which process audio.\n */\nexport abstract class ToneAudioNode<Options extends ToneAudioNodeOptions = ToneAudioNodeOptions>\nextends ToneWithContext<Options> {\n\n\tabstract name = \"AudioNode\";\n\n\t/**\n\t * The input node or nodes. If the object is a source,\n\t * it does not have any input and this.input is undefined.\n\t */\n\tabstract input: InputNode | undefined;\n\n\t/**\n\t * The output nodes. If the object is a sink,\n\t * it does not have any output and this.output is undefined.\n\t */\n\tabstract output: OutputNode | undefined;\n\n\t/**\n\t *  The number of inputs feeding into the AudioNode.\n\t *  For source nodes, this will be 0.\n\t */\n\tget numberOfInputs(): number {\n\t\tif (isDefined(this.input)) {\n\t\t\tif (isAudioParam(this.input) || this.input instanceof Param) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn this.input.numberOfInputs;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t *  The number of outputs of the AudioNode.\n\t */\n\tget numberOfOutputs(): number {\n\t\tif (isDefined(this.output)) {\n\t\t\treturn this.output.numberOfOutputs;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * List all of the node that must be set to match the ChannelProperties\n\t */\n\tprotected _internalChannels: OutputNode[] = [];\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// AUDIO PROPERTIES\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Used to decide which nodes to get/set properties on\n\t */\n\tprivate _isAudioNode(node: any): node is AudioNode | ToneAudioNode {\n\t\treturn isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n\t}\n\n\t/**\n\t * Get all of the audio nodes (either internal or input/output) which together\n\t * make up how the class node responds to channel input/output\n\t */\n\tprivate _getInternalNodes(): OutputNode[] {\n\t\tconst nodeList = this._internalChannels.slice(0);\n\t\tif (this._isAudioNode(this.input)) {\n\t\t\tnodeList.push(this.input);\n\t\t}\n\t\tif (this._isAudioNode(this.output)) {\n\t\t\tif (this.input !== this.output) {\n\t\t\t\tnodeList.push(this.output);\n\t\t\t}\n\t\t}\n\t\treturn nodeList;\n\t}\n\n\t/**\n\t * Set the audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t * @param options\n\t */\n\tprivate _setChannelProperties(options: ChannelProperties): void {\n\t\tconst nodeList = this._getInternalNodes();\n\t\tnodeList.forEach(node => {\n\t\t\tnode.channelCount = options.channelCount;\n\t\t\tnode.channelCountMode = options.channelCountMode;\n\t\t\tnode.channelInterpretation = options.channelInterpretation;\n\t\t});\n\t}\n\n\t/**\n\t * Get the current audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t */\n\tprivate _getChannelProperties(): ChannelProperties {\n\t\tconst nodeList = this._getInternalNodes();\n\t\tthis.assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\");\n\t\t// use the first node to get properties\n\t\t// they should all be the same\n\t\tconst node = nodeList[0];\n\t\treturn {\n\t\t\tchannelCount: node.channelCount,\n\t\t\tchannelCountMode: node.channelCountMode,\n\t\t\tchannelInterpretation: node.channelInterpretation,\n\t\t};\n\t}\n\n\t/**\n\t *  channelCount is the number of channels used when up-mixing and down-mixing\n\t *  connections to any inputs to the node. The default value is 2 except for\n\t *  specific nodes where its value is specially determined.\n\t */\n\tget channelCount(): number {\n\t\treturn this._getChannelProperties().channelCount;\n\t}\n\tset channelCount(channelCount) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCount }));\n\t}\n\n\t/**\n\t *  channelCountMode determines how channels will be counted when up-mixing and\n\t *  down-mixing connections to any inputs to the node.\n\t *  The default value is \"max\". This attribute has no effect for nodes with no inputs.\n\t * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all\n\t * \t\tconnections to an input. In this mode channelCount is ignored.\n\t * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped\n\t * \t\tto a maximum value of the given channelCount.\n\t * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n\t */\n\tget channelCountMode(): ChannelCountMode {\n\t\treturn this._getChannelProperties().channelCountMode;\n\t}\n\tset channelCountMode(channelCountMode) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCountMode }));\n\t}\n\n\t/**\n\t *  channelInterpretation determines how individual channels will be treated\n\t *  when up-mixing and down-mixing connections to any inputs to the node.\n\t *  The default value is \"speakers\".\n\t */\n\tget channelInterpretation(): ChannelInterpretation {\n\t\treturn this._getChannelProperties().channelInterpretation;\n\t}\n\tset channelInterpretation(channelInterpretation) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelInterpretation }));\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// CONNECTIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n\t * @param unit The output to connect to\n\t * @param outputNum The output to connect from\n\t * @param inputNum The input to connect to\n\t */\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t */\n\ttoDestination(): this {\n\t\tthis.connect(this.context.destination);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t * alias for {@link toDestination}\n\t * @deprecated\n\t */\n\ttoMaster(): this {\n\t\tconsole.warn(\"toMaster() has been renamed toDestination()\");\n\t\treturn this.toDestination();\n\t}\n\n\t/**\n\t *  disconnect the output\n\t *  @param output Either the output index to disconnect if the output is an array, or the node to disconnect from.\n\t */\n\tdisconnect(destination?: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tdisconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Connect the output of this node to the rest of the nodes in series.\n\t *  @example\n\t *  //connect a node to an effect, panVol and then to the master output\n\t *  node.chain(effect, panVol, Tone.Destination);\n\t */\n\tchain(...nodes: InputNode[]): this {\n\t\tconnectSeries(this, ...nodes);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  connect the output of this node to the rest of the nodes in parallel.\n\t */\n\tfan(...nodes: InputNode[]): this {\n\t\tnodes.forEach(node => this.connect(node));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Dispose and disconnect\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (isDefined(this.input)) {\n\t\t\tif (this.input instanceof ToneAudioNode) {\n\t\t\t\tthis.input.dispose();\n\t\t\t} else if (isAudioNode(this.input)) {\n\t\t\t\tthis.input.disconnect();\n\t\t\t}\n\t\t}\n\t\tif (isDefined(this.output)) {\n\t\t\tif (this.output instanceof ToneAudioNode) {\n\t\t\t\tthis.output.dispose();\n\t\t\t} else if (isAudioNode(this.output)) {\n\t\t\t\tthis.output.disconnect();\n\t\t\t}\n\t\t}\n\t\tthis._internalChannels = [];\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// CONNECTIONS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n *  connect together all of the arguments in series\n *  @param nodes\n */\nexport function connectSeries(...nodes: InputNode[]): void {\n\tconst first = nodes.shift();\n\tnodes.reduce((prev, current) => {\n\t\tif (prev instanceof ToneAudioNode) {\n\t\t\tprev.connect(current);\n\t\t} else if (isAudioNode(prev)) {\n\t\t\tconnect(prev, current);\n\t\t}\n\t\treturn current;\n\t}, first);\n}\n\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(srcNode: OutputNode, dstNode: InputNode, outputNumber = 0, inputNumber = 0): void {\n\n\tassert(isDefined(srcNode), \"Cannot connect from undefined node\");\n\tassert(isDefined(dstNode), \"Cannot connect to undefined node\");\n\n\tif (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n\t\tassert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n\t}\n\tassert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\");\n\n\t// resolve the input of the dstNode\n\twhile (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {\n\t\tif (isDefined(dstNode.input)) {\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t}\n\n\twhile (srcNode instanceof ToneAudioNode) {\n\t\tif (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t}\n\n\t// make the connection\n\tif (isAudioParam(dstNode)) {\n\t\tsrcNode.connect(dstNode as AudioParam, outputNumber);\n\t} else {\n\t\tsrcNode.connect(dstNode, outputNumber, inputNumber);\n\t}\n}\n\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(\n\tsrcNode: OutputNode,\n\tdstNode?: InputNode,\n\toutputNumber = 0,\n\tinputNumber = 0,\n): void {\n\n\t// resolve the destination node\n\tif (isDefined(dstNode)) {\n\t\twhile (dstNode instanceof ToneAudioNode) {\n\t\t\tif (dstNode.input) {\n\t\t\t\tdstNode = dstNode.input;\n\t\t\t}\n\t\t}\n\t}\n\n\t// resolve the src node\n\twhile (!(isAudioNode(srcNode))) {\n\t\tif (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t}\n\n\tif (isAudioParam(dstNode)) {\n\t\tsrcNode.disconnect(dstNode as AudioParam, outputNumber);\n\t} else if (isAudioNode(dstNode)) {\n\t\tsrcNode.disconnect(dstNode, outputNumber, inputNumber);\n\t} else {\n\t\tsrcNode.disconnect();\n\t}\n}\n","import { isArray } from \"./TypeCheck\";\n\n// return an interface which excludes certain keys\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n/**\n *  Make the property not writable using `defineProperty`. Internal use only.\n */\nexport function readOnly(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => readOnly(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\tenumerable: true,\n\t\t\twritable: false,\n\t\t});\n\t}\n}\n\n/**\n *  Make an attribute writeable. Internal use only.\n */\nexport function writable(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => writable(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\twritable: true,\n\t\t});\n\t}\n}\n\nexport const noOp: (...args: any[]) => any = () => {\n\t// no op!\n};\n\n/**\n * Recursive Partial taken from here: https://stackoverflow.com/a/51365037\n */\nexport type RecursivePartial<T> = {\n\t[P in keyof T]?:\n\tT[P] extends Array<infer U> ? Array<RecursivePartial<U>> :\n\tT[P] extends object ? RecursivePartial<T[P]> :\n\tT[P];\n};\n","import { Param } from \"../context/Param\";\nimport { GainFactor, Unit, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface GainOptions extends ToneAudioNodeOptions {\n\tgain: number;\n\tunits: UnitName;\n\tconvert: boolean;\n}\n\n/**\n * A thin wrapper around the Native Web Audio GainNode.\n * The GainNode is a basic building block of the Web Audio\n * API and is useful for routing audio and adjusting gains.\n * @param  gain The initial gain of the GainNode\n * @param units The units of the gain parameter.\n */\nexport class Gain<Type extends Unit = GainFactor> extends ToneAudioNode<GainOptions> {\n\n\treadonly name = \"Gain\";\n\n\t/**\n\t *  The gain parameter of the gain node.\n\t */\n\treadonly gain: Param<Type>;\n\n\t/**\n\t * The wrapped GainNode.\n\t */\n\tprivate _gainNode: GainNode = this.context.createGain();\n\n\t// input = output\n\treadonly input: GainNode = this._gainNode;\n\treadonly output: GainNode = this._gainNode;\n\n\tconstructor(gain?: GainFactor, units?: Unit);\n\tconstructor(options?: Partial<GainOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]));\n\t\tconst options = optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]);\n\n\t\tthis.gain = new Param({\n\t\t\tcontext : this.context,\n\t\t\tconvert : options.convert,\n\t\t\tparam : this._gainNode.gain,\n\t\t\tunits : options.units,\n\t\t\tvalue : options.gain,\n\t\t});\n\t\treadOnly(this, \"gain\");\n\t}\n\n\tstatic getDefaults(): GainOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert : true,\n\t\t\tgain : 1,\n\t\t\tunits : \"gain\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","import { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { Seconds } from \"../type/Units\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\n\n/**\n *  Wrapper around the OfflineAudioContext\n *  @param  channels  The number of channels to render\n *  @param  duration  The duration to render in samples\n *  @param sampleRate the sample rate to render at\n */\nexport class OfflineContext extends Context {\n\n\tname = \"OfflineContext\";\n\n\t/**\n\t *  A private reference to the duration\n\t */\n\tprivate readonly _duration: Seconds;\n\n\t/**\n\t *  An artificial clock source\n\t */\n\tprivate _currentTime: Seconds = 0;\n\n\t/**\n\t * Private reference to the OfflineAudioContext.\n\t */\n\tprotected _context!: OfflineAudioContext;\n\n\tconstructor(context: OfflineAudioContext);\n\tconstructor(\n\t\tchannels: number,\n\t\tduration: Seconds, sampleRate: number,\n\t);\n\tconstructor() {\n\n\t\tsuper({\n\t\t\tclockSource: \"offline\",\n\t\t\tcontext: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\targuments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n\t\t\tlookAhead: 0,\n\t\t\tupdateInterval: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\t\t128 / arguments[0].sampleRate : 128 / arguments[2],\n\t\t});\n\n\t\tthis._duration = isOfflineAudioContext(arguments[0]) ?\n\t\t\targuments[0].length / arguments[0].sampleRate : arguments[1];\n\t}\n\n\t/**\n\t *  Override the now method to point to the internal clock time\n\t */\n\tnow(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Same as this.now()\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t *  Render the output of the OfflineContext\n\t */\n\trender(): Promise<AudioBuffer> {\n\t\twhile (this._duration - this._currentTime >= 0) {\n\t\t\t// invoke all the callbacks on that time\n\t\t\tthis.emit(\"tick\");\n\t\t\t// increment the clock in 5ms chunks\n\t\t\tthis._currentTime += 128 / this.sampleRate;\n\t\t}\n\n\t\treturn this._context.startRendering();\n\t}\n\n\t/**\n\t *  Close the context\n\t */\n\tclose(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { Samples, Seconds, Time } from \"../type/Units\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\n\ninterface ToneAudioBufferOptions {\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n\treverse: boolean;\n\tonload: (buffer?: ToneAudioBuffer) => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n *\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n *\n * @param url The url to load, or the audio buffer to set.\n * @param onload A callback which is invoked after the buffer is loaded.\n *                            It's recommended to use `ToneAudioBuffer.on('load', callback)` instead\n *                            since it will give you a callback when _all_ buffers are loaded.\n * @param onerror The callback to invoke if there is an error\n * @example\n * var buffer = new ToneAudioBuffer(\"path/to/sound.mp3\", function(){\n * \t//the buffer is now available.\n * \tvar buff = buffer.get();\n * });\n * @example\n * //can load provide fallback extension types if the first type is not supported.\n * var buffer = new ToneAudioBuffer(\"path/to/sound.[mp3|ogg|wav]\");\n */\nexport class ToneAudioBuffer extends Tone {\n\n\tname = \"ToneAudioBuffer\";\n\n\t/**\n\t *  stores the loaded AudioBuffer\n\t */\n\tprivate _buffer?: AudioBuffer;\n\n\t/**\n\t *  indicates if the buffer should be reversed or not\n\t */\n\tprivate _reversed!: boolean;\n\n\t/**\n\t * Callback when the buffer is loaded.\n\t */\n\tonload: (buffer: ToneAudioBuffer) => void = noOp;\n\n\tconstructor(options?: Partial<ToneAudioBufferOptions>);\n\tconstructor(\n\t\turl?: string | ToneAudioBuffer | AudioBuffer,\n\t\tonload?: (buffer: ToneAudioBuffer) => void,\n\t\tonerror?: (error: Error) => void,\n\t);\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tconst options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n\n\t\tthis.reverse = options.reverse;\n\t\tthis.onload = options.onload;\n\n\t\tif (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n\t\t\tthis.set(options.url);\n\t\t} else if (isString(options.url)) {\n\t\t\t// initiate the download\n\t\t\tthis.load(options.url).catch(options.onerror);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneAudioBufferOptions {\n\t\treturn {\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\treverse: false,\n\t\t};\n\t}\n\n\t/**\n\t * The sample rate of the AudioBuffer\n\t */\n\tget sampleRate(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.sampleRate;\n\t\t} else {\n\t\t\treturn getContext().sampleRate;\n\t\t}\n\t}\n\n\t/**\n\t *  Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n\t */\n\tset(buffer: AudioBuffer | ToneAudioBuffer): this {\n\t\tif (buffer instanceof ToneAudioBuffer) {\n\t\t\t// if it's loaded, set it\n\t\t\tif (buffer.loaded) {\n\t\t\t\tthis._buffer = buffer.get();\n\t\t\t} else {\n\t\t\t\t// otherwise when it's loaded, invoke it's callback\n\t\t\t\tbuffer.onload = () => {\n\t\t\t\t\tthis.set(buffer);\n\t\t\t\t\tthis.onload(this);\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tthis._buffer = buffer;\n\t\t}\n\t\t// reverse it initially\n\t\tif (this._reversed) {\n\t\t\tthis._reverse();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The audio buffer stored in the object.\n\t */\n\tget(): AudioBuffer | undefined {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t *  Makes an fetch request for the selected url then decodes the file as an audio buffer.\n\t * \tInvokes the callback once the audio buffer loads.\n\t *  @param url The url of the buffer to load. filetype support depends on the browser.\n\t *  @returns A Promise which resolves with this ToneAudioBuffer\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tconst promise = ToneAudioBuffer.load(url);\n\t\tToneAudioBuffer.downloads.push(promise);\n\t\ttry {\n\t\t\tconst audioBuffer = await promise;\n\t\t\tthis.set(audioBuffer);\n\t\t\t// invoke the onload method\n\t\t\tthis.onload(this);\n\t\t} catch (e) {\n\t\t\t// remove the failed file before throwing error\n\t\t\tconst index = ToneAudioBuffer.downloads.indexOf(promise);\n\t\t\tToneAudioBuffer.downloads.splice(index, 1);\n\t\t\tthrow e;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the audio buffer from the array.\n\t * To create a multichannel AudioBuffer, pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t */\n\tfromArray(array: Float32Array | Float32Array[]): this {\n\t\tconst isMultidimensional = isArray(array) && array[0].length > 0;\n\t\tconst channels = isMultidimensional ? array.length : 1;\n\t\tconst len = isMultidimensional ? (array[0] as Float32Array).length : array.length;\n\t\tconst context = getContext();\n\t\tconst buffer = context.createBuffer(channels, len, context.sampleRate);\n\t\tconst multiChannelArray: Float32Array[] = !isMultidimensional && channels === 1 ?\n\t\t\t[array as Float32Array] : array as Float32Array[];\n\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\tbuffer.copyToChannel(multiChannelArray[c], c);\n\t\t}\n\t\tthis._buffer = buffer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * \tSums multiple channels into 1 channel\n\t *  @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoMono(chanNum?: number): this {\n\t\tif (isNumber(chanNum)) {\n\t\t\tthis.fromArray(this.toArray(chanNum));\n\t\t} else {\n\t\t\tlet outputArray = new Float32Array(this.length as number);\n\t\t\tconst numChannels = this.numberOfChannels;\n\t\t\tfor (let channel = 0; channel < numChannels; channel++) {\n\t\t\t\tconst channelArray = this.toArray(channel) as Float32Array;\n\t\t\t\tfor (let i = 0; i < channelArray.length; i++) {\n\t\t\t\t\toutputArray[i] += channelArray[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// divide by the number of channels\n\t\t\toutputArray = outputArray.map(sample => sample / numChannels);\n\t\t\tthis.fromArray(outputArray);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * \tGet the buffer as an array. Single channel buffers will return a 1-dimensional\n\t * \tFloat32Array, and multichannel buffers will return multidimensional arrays.\n\t *  @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoArray(channel?: number): Float32Array | Float32Array[] {\n\t\tif (isNumber(channel)) {\n\t\t\treturn this.getChannelData(channel);\n\t\t} else if (this.numberOfChannels === 1) {\n\t\t\treturn this.toArray(0);\n\t\t} else {\n\t\t\tconst ret: Float32Array[] = [];\n\t\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\t\tret[c] = this.getChannelData(c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t *  Returns the Float32Array representing the PCM audio data for the specific channel.\n\t *  @param  channel  The channel number to return\n\t *  @return The audio as a TypedArray\n\t */\n\tgetChannelData(channel: number): Float32Array {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.getChannelData(channel);\n\t\t} else {\n\t\t\treturn new Float32Array(0);\n\t\t}\n\t}\n\n\t/**\n\t *  Cut a subsection of the array and return a buffer of the\n\t *  subsection. Does not modify the original buffer\n\t *  @param start The time to start the slice\n\t *  @param end The end time to slice. If none is given will default to the end of the buffer\n\t */\n\tslice(start: Seconds, end: Seconds = this.duration): ToneAudioBuffer {\n\t\tconst startSamples = Math.floor(start * this.sampleRate);\n\t\tconst endSamples = Math.floor(end * this.sampleRate);\n\t\tthis.assert(startSamples < endSamples, \"The start time must be less than the end time\");\n\t\tconst length = endSamples - startSamples;\n\t\tconst retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\t\tfor (let channel = 0; channel < this.numberOfChannels; channel++) {\n\t\t\tretBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n\t\t}\n\t\treturn new ToneAudioBuffer(retBuffer);\n\t}\n\n\t/**\n\t *  Reverse the buffer.\n\t */\n\tprivate _reverse(): this {\n\t\tif (this.loaded) {\n\t\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\t\tthis.getChannelData(i).reverse();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffer is loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this.length > 0;\n\t}\n\n\t/**\n\t * The duration of the buffer in seconds.\n\t */\n\tget duration(): Seconds {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.duration;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The length of the buffer in samples\n\t */\n\tget length(): Samples {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n\t */\n\tget numberOfChannels(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.numberOfChannels;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tget reverse(): boolean {\n\t\treturn this._reversed;\n\t}\n\tset reverse(rev: boolean) {\n\t\tif (this._reversed !== rev) {\n\t\t\tthis._reversed = rev;\n\t\t\tthis._reverse();\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// STATIC METHODS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  A path which is prefixed before every url.\n\t */\n\tstatic baseUrl = \"\";\n\n\t/**\n\t *  Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n\t *  pass in a multidimensional array.\n\t *  @param array The array to fill the audio buffer\n\t *  @return A ToneAudioBuffer created from the array\n\t */\n\tstatic fromArray(array: Float32Array | Float32Array[]): ToneAudioBuffer {\n\t\treturn (new ToneAudioBuffer()).fromArray(array);\n\t}\n\n\t/**\n\t * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n\t * @param  url The url to load.\n\t * @return A promise which resolves to a ToneAudioBuffer\n\t */\n\tstatic async fromUrl(url: string): Promise<ToneAudioBuffer> {\n\t\tconst buffer = new ToneAudioBuffer();\n\t\treturn await buffer.load(url);\n\t}\n\n\t/**\n\t * All of the downloads\n\t */\n\tstatic downloads: Array<Promise<AudioBuffer>> = [];\n\n\t/**\n\t *  Loads a url using fetch and returns the AudioBuffer.\n\t */\n\tstatic async load(url: string): Promise<AudioBuffer> {\n\n\t\t// test if the url contains multiple extensions\n\t\tconst matches = url.match(/\\[(.+\\|?)+\\]$/);\n\t\tif (matches) {\n\t\t\tconst extensions = matches[1].split(\"|\");\n\t\t\tlet extension = extensions[0];\n\t\t\tfor (const ext of extensions) {\n\t\t\t\tif (ToneAudioBuffer.supportsType(ext)) {\n\t\t\t\t\textension = ext;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\turl = url.replace(matches[0], extension);\n\t\t}\n\n\t\tconst response = await fetch(ToneAudioBuffer.baseUrl + url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`could not load url: ${url}`);\n\t\t}\n\t\tconst arrayBuffer = await response.arrayBuffer();\n\n\t\tconst audioBuffer = await getContext().decodeAudioData(arrayBuffer);\n\n\t\treturn audioBuffer;\n\t}\n\n\t/**\n\t *  Checks a url's extension to see if the current browser can play that file type.\n\t *  @param url The url/extension to test\n\t *  @return If the file extension can be played\n\t *  @static\n\t *  @example\n\t * ToneAudioBuffer.supportsType(\"wav\"); //returns true\n\t * ToneAudioBuffer.supportsType(\"path/to/file.wav\"); //returns true\n\t */\n\tstatic supportsType(url: string): boolean {\n\t\tconst extensions = url.split(\".\");\n\t\tconst extension = extensions[extensions.length - 1];\n\t\tconst response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n\t\treturn response !== \"\";\n\t}\n\n\t/**\n\t *  Returns a Promise which resolves when all of the buffers have loaded\n\t */\n\tstatic async loaded(): Promise<void> {\n\t\tfor (const promise of ToneAudioBuffer.downloads) {\n\t\t\tawait promise;\n\t\t}\n\t}\n}\n","import { getContext, setContext } from \"../Global\";\nimport { Seconds } from \"../type/Units\";\nimport { OfflineContext } from \"./OfflineContext\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of Tone.Transport which can be used\n * to schedule events along the Transport. **NOTE** OfflineAudioContext has the same restrictions\n * as the AudioContext in that on certain platforms (like iOS) it must be invoked by an explicit\n * user action like a click or tap.\n * @param  callback  All Tone.js nodes which are created and scheduled\n * \t\t\t\t\twithin this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the Tone.Buffer of the recorded output.\n * @example\n * //render 2 seconds of the oscillator\n * Tone.Offline(function(){\n * \t//only nodes created in this callback will be recorded\n * \tvar oscillator = new Tone.Oscillator().toDestination().start(0)\n * \t//schedule their events\n * }, 2).then(function(buffer){\n * \t//do something with the output buffer\n * })\n * @example\n * //can also schedule events along the Transport\n * //using the passed in Offline Transport\n * Tone.Offline(function(Transport){\n * \tvar osc = new Tone.Oscillator().toDestination()\n * \tTransport.schedule(function(time){\n * \t\tosc.start(time).stop(time + 0.1)\n * \t}, 1)\n * \tTransport.start(0.2)\n * }, 4).then(function(buffer){\n * \t//do something with the output buffer\n * })\n */\nexport async function Offline(\n\tcallback: (context: OfflineContext) => Promise<void> | void,\n\tduration: Seconds,\n\tchannels: number = 2,\n\tsampleRate: number = getContext().sampleRate,\n): Promise<ToneAudioBuffer> {\n\t// set the OfflineAudioContext based on the current context\n\tconst originalContext = getContext();\n\n\tconst context = new OfflineContext(channels, duration, sampleRate);\n\tsetContext(context);\n\n\t// invoke the callback/scheduling\n\tawait callback(context);\n\n\t// then render the audio\n\tconst bufferPromise = context.render();\n\n\t// return the original AudioContext\n\tsetContext(originalContext);\n\n\t// await the rendering\n\tconst buffer = await bufferPromise;\n\n\t// return the audio\n\treturn new ToneAudioBuffer(buffer);\n}\n","import { Tone } from \"../Tone\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isString } from \"../util/TypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\ninterface ToneAudioBuffersUrlMap {\n\t[name: string]: string | AudioBuffer | ToneAudioBuffer;\n\t[name: number]: string | AudioBuffer | ToneAudioBuffer;\n}\n\ninterface ToneAudioBuffersOptions {\n\turls: ToneAudioBuffersUrlMap;\n\tonload: () => void;\n\tonerror?: (error: Error) => void;\n\tbaseUrl: string;\n}\n\n/**\n * A data structure for holding multiple buffers in a Map-like datastructure.\n *\n * @param  urls      An object literal or array of urls to load.\n * @param onload  The callback to invoke when the buffers are loaded.\n * @example\n * //load a whole bank of piano samples\n * var pianoSamples = new ToneAudioBuffers({\n * \t\"C4\" : \"path/to/C4.mp3\"\n * \t\"C#4\" : \"path/to/C#4.mp3\"\n * \t\"D4\" : \"path/to/D4.mp3\"\n * \t\"D#4\" : \"path/to/D#4.mp3\"\n * }, function(){\n * \t//play one of the samples when they all load\n * \tplayer.buffer = pianoSamples.get(\"C4\");\n * \tplayer.start();\n * });\n * @example\n * //To pass in additional parameters in the second parameter\n * var buffers = new ToneAudioBuffers(urls, {\n * \t\"onload\" : callback,\n * \t\"baseUrl\" : \"../path/to/audio/\"\n * })\n */\nexport class ToneAudioBuffers extends Tone {\n\n\tname = \"ToneAudioBuffers\";\n\n\t/**\n\t *  All of the buffers\n\t */\n\tprivate _buffers: Map<string, ToneAudioBuffer> = new Map();\n\n\t/**\n\t *  A path which is prefixed before every url.\n\t */\n\tbaseUrl: string;\n\n\t/**\n\t * Keep track of the number of loaded buffers\n\t */\n\tprivate _loadingCount: number = 0;\n\n\tconstructor(\n\t\turls?: ToneAudioBuffersUrlMap,\n\t\tonload?: () => void,\n\t\tbaseUrl?: string,\n\t);\n\tconstructor(options?: Partial<ToneAudioBuffersOptions>);\n\tconstructor() {\n\n\t\tsuper();\n\t\tconst options = optionsFromArguments(\n\t\t\tToneAudioBuffers.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\",\n\t\t);\n\n\t\tthis.baseUrl = options.baseUrl;\n\t\tconst urlMap: ToneAudioBuffersUrlMap = {};\n\t\t// add each one\n\t\tObject.keys(options.urls).forEach(name => {\n\t\t\tthis._loadingCount++;\n\t\t\tconst url = options.urls[name];\n\t\t\tthis.add(name, url, this._bufferLoaded.bind(this, options.onload));\n\t\t});\n\n\t}\n\n\tstatic getDefaults(): ToneAudioBuffersOptions {\n\t\treturn {\n\t\t\tbaseUrl: \"\",\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\turls: {},\n\t\t};\n\t}\n\n\t/**\n\t *  True if the buffers object has a buffer by that name.\n\t *  @param  name  The key or index of the buffer.\n\t */\n\thas(name: string | number): boolean {\n\t\treturn this._buffers.has(name.toString());\n\t}\n\n\t/**\n\t *  Get a buffer by name. If an array was loaded,\n\t *  then use the array index.\n\t *  @param  name  The key or index of the buffer.\n\t */\n\tget(name: string | number): ToneAudioBuffer {\n\t\tthis.assert(this.has(name), `ToneAudioBuffers has no buffer named: ${name}`);\n\t\treturn this._buffers.get(name.toString()) as ToneAudioBuffer;\n\t}\n\n\t/**\n\t *  A buffer was loaded. decrement the counter.\n\t */\n\tprivate _bufferLoaded(callback: () => void): void {\n\t\tthis._loadingCount--;\n\t\tif (this._loadingCount === 0 && callback) {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn Array.from(this._buffers).every(([name, buffer]) => buffer.loaded);\n\t}\n\n\t/**\n\t *  Add a buffer by name and url to the Buffers\n\t *  @param  name      A unique name to give the buffer\n\t *  @param  url  Either the url of the bufer, or a buffer which will be added with the given name.\n\t *  @param  callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(\n\t\tname: string | number,\n\t\turl: string | AudioBuffer | ToneAudioBuffer,\n\t\tcallback: () => void = noOp,\n\t): this {\n\t\tif (url instanceof ToneAudioBuffer) {\n\t\t\tthis._buffers.set(name.toString(), url);\n\t\t\tcallback();\n\t\t} else if (isAudioBuffer(url)) {\n\t\t\tthis._buffers.set(name.toString(), new ToneAudioBuffer(url));\n\t\t\tcallback();\n\t\t} else if (isString(url)) {\n\t\t\tthis._buffers.set(name.toString(), new ToneAudioBuffer(this.baseUrl + url, callback));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.forEach(buffer => buffer.dispose());\n\t\tthis._buffers.clear();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../context/Param\";\nimport { Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\nexport interface DelayOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tmaxDelay: Time;\n}\n\n/**\n *  Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).\n *  @param delayTime The delay applied to the incoming signal.\n *  @param maxDelay The maximum delay time.\n */\nexport class Delay extends ToneAudioNode<DelayOptions> {\n\n\treadonly name = \"Delay\";\n\n\t/**\n\t * The maximum delay time. This cannot be changed after\n\t * the value is passed into the constructor.\n\t */\n\treadonly maxDelay: Time;\n\n\t/**\n\t *  The amount of time the incoming signal is delayed.\n\t */\n\treadonly delayTime: Param<Time>;\n\n\t/**\n\t * Private reference to the internal DelayNode\n\t */\n\tprivate _delayNode: DelayNode;\n\treadonly input: DelayNode;\n\treadonly output: DelayNode;\n\n\tconstructor(options?: Partial<DelayOptions>)\n\tconstructor(delayTime?: Time, maxDelay?: Time)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]));\n\n\t\tconst options = optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]);\n\n\t\tconst maxDelayInSeconds = this.toSeconds(options.maxDelay);\n\t\tthis.maxDelay = Math.max(maxDelayInSeconds, this.toSeconds(options.delayTime));\n\n\t\tthis._delayNode = this.input = this.output = this.context.createDelay(maxDelayInSeconds);\n\n\t\tthis.delayTime = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._delayNode.delayTime,\n\t\t\tunits : \"time\",\n\t\t\tvalue : options.delayTime,\n\t\t});\n\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): DelayOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime : 0,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.disconnect();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { Seconds } from \"../type/Units\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\n\nexport type BasicPlaybackState = \"started\" | \"stopped\";\nexport type PlaybackState = BasicPlaybackState | \"paused\";\n\nexport interface StateTimelineEvent extends TimelineEvent {\n\tstate: PlaybackState;\n}\n\n/**\n *  A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n *  @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\nexport class StateTimeline<AdditionalOptions extends {} = {}> extends Timeline<StateTimelineEvent & AdditionalOptions> {\n\n\t/**\n\t *  The initial state\n\t */\n\tprivate _initial: PlaybackState;\n\n\tconstructor(initial: PlaybackState = \"stopped\") {\n\t\tsuper();\n\t\tthis._initial = initial;\n\t}\n\n\t/**\n\t *  Returns the scheduled state scheduled before or at\n\t *  the given time.\n\t *  @param  time  The time to query.\n\t *  @return  The name of the state input in setStateAtTime.\n\t */\n\tgetValueAtTime(time: Seconds): PlaybackState {\n\t\tconst event = this.get(time);\n\t\tif (event !== null) {\n\t\t\treturn event.state;\n\t\t} else {\n\t\t\treturn this._initial;\n\t\t}\n\t}\n\n\t/**\n\t *  Add a state to the timeline.\n\t * @param  state The name of the state to set.\n\t * @param  time  The time to query.\n\t * @param options Any additional options that are needed in the timeline.\n\t */\n\tsetStateAtTime(state: PlaybackState, time: Seconds, options?: AdditionalOptions): this {\n\t\t// all state changes need to be >= the previous state time\n\t\t// TODO throw error if time < the previous event time\n\t\tthis.add(Object.assign({}, options, {\n\t\t\tstate,\n\t\t\ttime,\n\t\t}));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Return the event before the time with the given state\n\t *  @param  state The state to look for\n\t *  @param  time  When to check before\n\t *  @return  The event with the given state before the time\n\t */\n\tgetLastState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tfor (let i = index; i >= 0; i--) {\n\t\t\tconst event = this._timeline[i];\n\t\t\tif (event.state === state) {\n\t\t\t\treturn event;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Return the event after the time with the given state\n\t *  @param  state The state to look for\n\t *  @param  time  When to check from\n\t *  @return  The event with the given state after the time\n\t */\n\tgetNextState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tif (index !== -1) {\n\t\t\tfor (let i = index; i < this._timeline.length; i++) {\n\t\t\t\tconst event = this._timeline[i];\n\t\t\t\tif (event.state === state) {\n\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import { connect } from \"../Connect\";\nimport { AutomationEvent, Param, ParamOptions } from \"../context/Param\";\nimport { InputNode } from \"../context/ToneAudioNode\";\nimport { getContext } from \"../Global\";\nimport { BPM, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n\ninterface TickAutomationEvent extends AutomationEvent {\n\tticks: number;\n}\n\ninterface TickSignalOptions extends ParamOptions {\n\tvalue: Hertz | BPM;\n\tmultiplier: number;\n}\n\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n *\n * @param value The initial value of the signal\n */\nexport class TickSignal<Type extends Hertz | BPM> extends Param<Type> {\n\n\tname = \"TickSignal\";\n\n\tprotected _events: Timeline<TickAutomationEvent> = new Timeline(Infinity);\n\n\tprivate _sig: ConstantSourceNode = this.context.createConstantSource();\n\n\tprotected _param = this._sig.offset;\n\n\tprivate _multiplier: number = 1;\n\n\tconstructor(options: Partial<TickSignalOptions>);\n\tconstructor(value?: number);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis._sig = this.context.createConstantSource();\n\t\tthis._sig.start(0);\n\t\tthis._param = this._sig.offset;\n\n\t\t// set the multiplier\n\t\tthis._multiplier = options.multiplier;\n\n\t\t// clear the ticks from the beginning\n\t\tthis._events.cancel(0);\n\t\t// set an initial event\n\t\tthis._events.add({\n\t\t\tticks: 0,\n\t\t\ttime : 0,\n\t\t\ttype : \"setValue\",\n\t\t\tvalue: this._fromType(options.value as Type),\n\t\t});\n\t\tthis.setValueAtTime(options.value as Type, 0);\n\t}\n\n\tstatic getDefaults(): TickSignalOptions {\n\t\treturn Object.assign(Param.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tparam: getContext().createConstantSource().offset,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tsetTargetAtTime(value: Type, time: Time, constant: number): this {\n\t\t// approximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tthis.setRampPoint(time);\n\t\tconst computedValue = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\tconst segments = Math.round(Math.max(1 / constant, 1));\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = constant * i + time;\n\t\t\tconst rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsetValueAtTime(value: Type, time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.setValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: Type, time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.linearRampToValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: Type, time: Time): this {\n\t\t// aproximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tconst computedVal = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\t// approx 10 segments per second\n\t\tconst segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n\t\tconst segmentDur = ((time - prevEvent.time) / segments);\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = segmentDur * i + prevEvent.time;\n\t\t\tconst rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tprivate _getTicksUntilEvent(event: TickAutomationEvent | null, time: number): Ticks {\n\t\tif (event === null) {\n\t\t\tevent = {\n\t\t\t\tticks : 0,\n\t\t\t\ttime : 0,\n\t\t\t\ttype: \"setValue\",\n\t\t\t\tvalue: 0,\n\t\t\t};\n\t\t} else if (isUndef(event.ticks)) {\n\t\t\tconst previousEvent = this._events.previousEvent(event);\n\t\t\tevent.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n\t\t}\n\t\tconst val0 = this._fromType(this.getValueAtTime(event.time));\n\t\tlet val1 = this._fromType(this.getValueAtTime(time));\n\t\t// if it's right on the line, take the previous value\n\t\tconst onTheLineEvent = this._events.get(time);\n\t\tif (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValue\") {\n\t\t\tval1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n\t\t}\n\t\treturn 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst event = this._events.get(computedTime);\n\t\treturn Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n\t}\n\n\t/**\n\t * Return the elapsed time of the number of ticks from the given time\n\t * @param ticks The number of ticks to calculate\n\t * @param  time The time to get the next tick from\n\t * @return The duration of the number of ticks from the given time in seconds\n\t */\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst currentTick = this.getTicksAtTime(time);\n\t\treturn this.getTimeOfTick(currentTick + ticks) - computedTime;\n\t}\n\n\t/**\n\t * Given a tick, returns the time that tick occurs at.\n\t * @return The time that the tick occurs.\n\t */\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\tconst before = this._events.get(tick, \"ticks\");\n\t\tconst after = this._events.getAfter(tick, \"ticks\");\n\t\tif (before && before.ticks === tick) {\n\t\t\treturn before.time;\n\t\t} else if (before && after &&\n\t\t\tafter.type === \"linear\" &&\n\t\t\tbefore.value !== after.value) {\n\t\t\tconst val0 = this._fromType(this.getValueAtTime(before.time));\n\t\t\tconst val1 = this._fromType(this.getValueAtTime(after.time));\n\t\t\tconst delta = (val1 - val0) / (after.time - before.time);\n\t\t\tconst k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n\t\t\tconst sol1 = (-val0 + k) / delta;\n\t\t\tconst sol2 = (-val0 - k) / delta;\n\t\t\treturn (sol1 > 0 ? sol1 : sol2) + before.time;\n\t\t} else if (before) {\n\t\t\tif (before.value === 0) {\n\t\t\t\treturn Infinity;\n\t\t\t} else {\n\t\t\t\treturn before.time + (tick - before.ticks) / before.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn tick / this._initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Convert some number of ticks their the duration in seconds accounting\n\t * for any automation curves starting at the given time.\n\t * @param  ticks The number of ticks to convert to seconds.\n\t * @param  when  When along the automation timeline to convert the ticks.\n\t * @return The duration in seconds of the ticks.\n\t */\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this.getDurationOfTicks(ticks, when);\n\t}\n\n\t/**\n\t * The inverse of [ticksToTime](#tickstotime). Convert a duration in\n\t * seconds to the corresponding number of ticks accounting for any\n\t * automation curves starting at the given time.\n\t * @param  duration The time interval to convert to ticks.\n\t * @param  when When along the automation timeline to convert the ticks.\n\t * @return The duration in ticks.\n\t */\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tconst startTicks = this.getTicksAtTime(computedTime);\n\t\tconst endTicks = this.getTicksAtTime(computedTime + computedDuration);\n\t\treturn endTicks - startTicks;\n\t}\n\n\t/**\n\t * Convert from the type when the unit value is BPM\n\t */\n\tprotected _fromType(val: Type): number {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn 1 / (60 / val / this.multiplier);\n\t\t} else {\n\t\t\treturn super._fromType(val);\n\t\t}\n\t}\n\n\t/**\n\t * Special case of type conversion where the units === \"bpm\"\n\t */\n\tprotected _toType(val: number): Type {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn (val / this.multiplier) * 60 as Type;\n\t\t} else {\n\t\t\treturn super._toType(val);\n\t\t}\n\t}\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\t// get and reset the current value with the new multipler\n\t\t// might be necessary to clear all the previous values\n\t\tconst currentVal = this.value;\n\t\tthis._multiplier = m;\n\t\tthis.value = currentVal;\n\t}\n\n\t/**\n\t * Connect the output signal\n\t */\n\tconnect(dstNode: InputNode, outputNumber = 0, inputNumber = 0): this {\n\t\tconnect(this._sig, dstNode, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { BPM, Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: Frequency;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ninterface TickSourceOffsetEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n *  Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n *\n *  @param frequency The initial frequency that the signal ticks at\n */\nexport class TickSource<Type extends BPM | Hertz> extends ToneWithContext<TickSourceOptions> {\n\n\tname = \"TickSource\";\n\n\t/**\n\t *  The frequency the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<Type>;\n\n\t/**\n\t *  The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\tconstructor(frequency?: Frequency);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new TickSignal({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units,\n\t\t\tvalue: this.toFrequency(options.frequency),\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the inital state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign({\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\" as \"hertz\",\n\t\t}, ToneWithContext.getDefaults());\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t *  Start the clock at the given time. Optionally pass in an offset\n\t *  of where to start the tick counter from.\n\t *  @param  time    The time the clock should start\n\t *  @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Pause the clock. Pausing does not reset the tick counter.\n\t *  @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t *  @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", computedTime);\n\t\tif (!stopEvent) {\n\t\t\treturn 0;\n\t\t}\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time: computedTime};\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedTicks = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t *  The number of times the callback was invoked. Starts counting at 0\n\t *  and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t *  The time since ticks=0 that the TickSource has been running. Accounts\n\t *  for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t *  @param  time  When to get the elapsed seconds\n\t *  @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", time);\n\t\tif (!stopEvent) {\n\t\t\treturn 0;\n\t\t}\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state : \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedSeconds = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds : this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Returns the scheduled state at the given time.\n\t *  @param  time  The time to query.\n\t *  @example\n\t * source.start(\"+0.1\");\n\t * source.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  ticks The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t *  Invoke the callback event at all scheduled ticks between the\n\t *  start time and the end time\n\t *  @param  startTime  The beginning of the search range\n\t *  @param  endTime    The end of the search range\n\t *  @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(startTime: Time, endTime: Time, callback: (when: Seconds, ticks: Ticks) => void): this {\n\t\tconst computedStartTime = this.toSeconds(startTime);\n\t\tconst computedEndTime = this.toSeconds(endTime);\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(computedStartTime);\n\t\tthis._state.forEachBetween(computedStartTime, computedEndTime, event => {\n\t\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n\t\t\t\tthis.forEachTickBetween(Math.max(lastStateEvent.time, computedStartTime), event.time - this.sampleTime, callback);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && this._state) {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, computedStartTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = diff % 1;\n\t\t\tif (offset !== 0) {\n\t\t\t\toffset = 1 - offset;\n\t\t\t}\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\t\t\twhile (nextTickTime < computedEndTime && this._state) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this._state) {\n\t\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { BPM, Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter, EmitterEventObject } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline } from \"../util/StateTimeline\";\nimport { TickSignal } from \"./TickSignal\";\nimport { TickSource } from \"./TickSource\";\n\ntype ClockCallback = (time: Time, ticks?: Ticks) => void;\n\ninterface ClockOptions extends ToneWithContextOptions {\n\tfrequency: number;\n\tcallback: ClockCallback;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ntype ClockEvent = \"start\" | \"stop\" | \"pause\";\n\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n *\n * @param callback The callback to be invoked with the time of the audio event\n * @param frequency The rate of the callback\n * @example\n * //the callback will be invoked approximately once a second\n * //and will print the time exactly once a second apart.\n * const clock = new Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n */\nexport class Clock<Type extends BPM | Hertz = Hertz>\nextends ToneWithContext<ClockOptions> implements Emitter<ClockEvent> {\n\n\tname = \"Clock\";\n\n\t/**\n\t *  The callback function to invoke at the scheduled tick.\n\t */\n\tcallback: ClockCallback = noOp;\n\n\t/**\n\t *  The tick counter\n\t */\n\tprivate _tickSource: TickSource<Type>;\n\n\t/**\n\t *  The last time the loop callback was invoked\n\t */\n\tprivate _lastUpdate: number = 0;\n\n\t/**\n\t *  Keep track of the playback state\n\t */\n\tprivate _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t * Context bound reference to the _loop method\n\t * This is necessary to remove the event in the end.\n\t */\n\tprivate _boundLoop: () => void = this._loop.bind(this);\n\n\t/**\n\t *  The rate the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<Type>;\n\n\tconstructor(options: Partial<ClockOptions>);\n\tconstructor(callback?: ClockCallback, frequency?: Frequency);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n\t\tconst options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._tickSource = new TickSource({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._lastUpdate = 0;\n\t\tthis.frequency = this._tickSource.frequency;\n\t\treadOnly(this, \"frequency\");\n\n\t\t// add an initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\n\t\t// bind a callback to the worker thread\n\t\tthis.context.on(\"tick\", this._boundLoop);\n\t}\n\n\tstatic getDefaults(): ClockOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp as ClockCallback,\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}) as ClockOptions;\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t *  Start the clock at the given time. Optionally pass in an offset\n\t *  of where to start the tick counter from.\n\t *  @param  time    The time the clock should start\n\t *  @param offset  Where the tick counter starts counting from.\n\t */\n\tstart(time?: Time, offset?: Ticks): this {\n\t\t// make sure the context is started\n\t\tthis.context.resume();\n\t\t// start the loop\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis._tickSource.start(computedTime, offset);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"start\", computedTime, offset);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the clock. Stopping the clock resets the tick counter to 0.\n\t *  @param time The time when the clock should stop.\n\t *  @example\n\t * clock.stop();\n\t */\n\tstop(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis._tickSource.stop(computedTime);\n\t\tif (computedTime < this._lastUpdate) {\n\t\t\tthis.emit(\"stop\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Pause the clock. Pausing does not reset the tick counter.\n\t *  @param time The time when the clock should stop.\n\t */\n\tpause(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._tickSource.pause(computedTime);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"pause\", computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The number of times the callback was invoked. Starts counting at 0\n\t *  and increments after the callback was invoked.\n\t */\n\tget ticks(): Ticks {\n\t\treturn Math.ceil(this.getTicksAtTime(this.now()));\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis._tickSource.ticks = t;\n\t}\n\n\t/**\n\t *  The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._tickSource.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tthis._tickSource.seconds = s;\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t *  @param  time  When to get the elapsed seconds\n\t *  @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._tickSource.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\tthis._tickSource.setTicksAtTime(ticks, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn this._tickSource.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the next tick\n\t * @param  ticks The tick number.\n\t */\n\tnextTickTime(offset: Ticks, when: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst currentTick = this.getTicksAtTime(computedTime);\n\t\treturn this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n\t}\n\n\t/**\n\t *  The scheduling loop.\n\t */\n\tprivate _loop(): void {\n\n\t\tconst startTime = this._lastUpdate;\n\t\tconst endTime = this.now();\n\t\tthis._lastUpdate = endTime;\n\n\t\tif (startTime !== endTime) {\n\t\t\t// the state change events\n\t\t\tthis._state.forEachBetween(startTime, endTime, e => {\n\t\t\t\tswitch (e.state) {\n\t\t\t\t\tcase \"started\" :\n\t\t\t\t\t\tconst offset = this._tickSource.getTicksAtTime(e.time);\n\t\t\t\t\t\tthis.emit(\"start\", e.time, offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"stopped\" :\n\t\t\t\t\t\tif (e.time !== 0) {\n\t\t\t\t\t\t\tthis.emit(\"stop\", e.time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"paused\" :\n\t\t\t\t\t\tthis.emit(\"pause\", e.time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// the tick callbacks\n\t\t\tthis._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n\t\t\t\tthis.callback(time, ticks);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t * @example\n\t * clock.start(\"+0.1\");\n\t * clock.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(computedTime);\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.off(\"tick\", this._boundLoop);\n\t\tthis._tickSource.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t///////////////////////////////////////////////////////////////////////\n\n\ton!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\tonce!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\toff!: (event: ClockEvent, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Clock);\n","import { getContext } from \"../Global\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\nimport { TransportTimeClass } from \"./TransportTime\";\nimport { Seconds, Ticks } from \"./Units\";\n\n/**\n * Ticks is a primitive type for encoding Time values.\n * Ticks can be constructed with or without the `new` keyword. Ticks can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * const t = Ticks(\"4n\"); //a quarter note as ticks\n */\nexport class TicksClass extends TransportTimeClass<Ticks> {\n\n\tname = \"Ticks\";\n\n\treadonly defaultUnits: TimeBaseUnit = \"i\";\n\n\t/**\n\t * Get the current time in the given units\n\t */\n\tprotected _now(): Ticks {\n\t\treturn this.context.transport.ticks;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Ticks {\n\t\treturn this._getPPQ() * beats;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Ticks {\n\t\treturn Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Ticks {\n\t\treturn ticks;\n\t}\n\n\t/**\n\t *  Return the time in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\treturn this.valueOf() as Ticks;\n\t}\n\n\t/**\n\t *  Return the time in seconds\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn (this.valueOf() / this._getPPQ()) * (60 / this._getBpm());\n\t}\n}\n\nexport function Ticks(value?: TimeValue, units?: TimeBaseUnit): TicksClass {\n\treturn new TicksClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { ftom, mtof } from \"./Conversions\";\nimport { FrequencyClass, FrequencyUnit } from \"./Frequency\";\nimport { TimeValue } from \"./TimeBase\";\nimport { Hertz, Interval, MidiNote, Seconds, Ticks } from \"./Units\";\n\n/**\n *  @class Midi is a primitive type for encoding Time values.\n *         Midi can be constructed with or without the `new` keyword. Midi can be passed\n *         into the parameter of any method which takes time as an argument.\n *  @constructor\n *  @extends {Tone.Frequency}\n *  @param  {String|Number}  val    The time value.\n *  @param  {String=}  units  The units of the value.\n *  @example\n * var t = Midi(\"4n\");//a quarter note\n */\nexport class MidiClass extends FrequencyClass<MidiNote> {\n\n\tname = \"Midi\";\n\n\treadonly defaultUnits = \"midi\";\n\n\t/**\n\t *  Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): MidiNote {\n\t\treturn ftom(super._frequencyToUnits(freq));\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): MidiNote {\n\t\treturn ftom(super._ticksToUnits(ticks));\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): MidiNote {\n\t\treturn ftom(super._beatsToUnits(beats));\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): MidiNote {\n\t\treturn ftom(super._secondsToUnits(seconds));\n\t}\n\n\t/**\n\t *  Return the value of the frequency as a MIDI note\n\t *  @return  {MIDI}\n\t *  @example\n\t * Midi(60).toMidi(); //60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t *  Return the value of the frequency as a MIDI note\n\t *  @return  {MIDI}\n\t *  @example\n\t * Midi(60).toFrequency(); //261.6255653005986\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn mtof(this.toMidi());\n\t}\n\n\t/**\n\t *  Transposes the frequency by the given number of semitones.\n\t *  @return A new transposed MidiClass\n\t *  @example\n\t * Midi(\"A4\").transpose(3); //\"C5\"\n\t */\n\ttranspose(interval: Interval): MidiClass {\n\t\treturn new MidiClass(this.context, this.toMidi() + interval);\n\t}\n}\n\n/**\n * Convert a value into a FrequencyClass object.\n */\nexport function Midi(value?: TimeValue, units?: FrequencyUnit): MidiClass {\n\treturn new MidiClass(getContext(), value, units);\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Seconds, Time } from \"../type/Units\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\n\ninterface DrawEvent extends TimelineEvent {\n\tcallback: () => void;\n}\n\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule(function(time){\n * \t//use the time argument to schedule a callback with Draw\n * \tDraw.schedule(function(){\n * \t\t//do drawing or DOM manipulation here\n * \t}, time)\n * }, \"+0.5\")\n */\nexport class Draw extends ToneWithContext<ToneWithContextOptions> {\n\n\tname = \"Draw\";\n\n\t/**\n\t *  The duration after which events are not invoked.\n\t */\n\texpiration: Seconds = 0.25;\n\n\t/**\n\t *  The amount of time before the scheduled time\n\t *  that the callback can be invoked. Default is\n\t *  half the time of an animation frame (0.008 seconds).\n\t */\n\tanticipation: Seconds = 0.008;\n\n\t/**\n\t *  All of the events.\n\t */\n\tprivate _events: Timeline<DrawEvent> = new Timeline();\n\n\t/**\n\t *  The draw loop\n\t */\n\tprivate _boundDrawLoop = this._drawLoop.bind(this);\n\n\t/**\n\t * The animation frame id\n\t */\n\tprivate _animationFrame: number = -1;\n\n\t/**\n\t *  Schedule a function at the given time to be invoked\n\t *  on the nearest animation frame.\n\t *  @param  callback  Callback is invoked at the given time.\n\t *  @param  time      The time relative to the AudioContext time to invoke the callback.\n\t */\n\tschedule(callback: () => void, time: Time): this {\n\t\tthis._events.add({\n\t\t\tcallback,\n\t\t\ttime : this.toSeconds(time),\n\t\t});\n\t\t// start the draw loop on the first event\n\t\tif (this._events.length === 1) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel events scheduled after the given time\n\t *  @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._events.cancel(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The draw loop\n\t */\n\tprivate _drawLoop(): void {\n\t\tconst now = this.context.currentTime;\n\t\twhile (this._events.length && (this._events.peek() as DrawEvent).time - this.anticipation <= now) {\n\t\t\tconst event = this._events.shift();\n\t\t\tif (event && now - event.time <= this.expiration) {\n\t\t\t\tevent.callback();\n\t\t\t}\n\t\t}\n\t\tif (this._events.length > 0) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\tcancelAnimationFrame(this._animationFrame);\n\t\treturn this;\n\t}\n}\n","import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\n\n/**\n * An IntervalTimeline event must have a time and duration\n */\nexport interface IntervalTimelineEvent {\n\ttime: number;\n\tduration: number;\n\t[propName: string]: any;\n}\n\ntype IteratorCallback = (event: IntervalTimelineEvent) => void;\n\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport class IntervalTimeline extends Tone {\n\n\tname = \"IntervalTimeline\";\n\n\t/**\n\t *  The root node of the inteval tree\n\t */\n\tprivate _root: IntervalNode | null = null;\n\n\t/**\n\t *  Keep track of the length of the timeline.\n\t */\n\tprivate _length: number = 0;\n\n\t/**\n\t *  The event to add to the timeline. All events must\n\t *  have a time and duration value\n\t *  @param  event  The event to add to the timeline\n\t */\n\tadd(event: IntervalTimelineEvent): this {\n\t\tthis.assert(isDefined(event.time), \"Events must have a time property\");\n\t\tthis.assert(isDefined(event.duration), \"Events must have a duration parameter\");\n\n\t\tevent.time = event.time.valueOf();\n\t\tlet node: IntervalNode | null = new IntervalNode(event.time, event.time + event.duration, event);\n\t\tif (this._root === null) {\n\t\t\tthis._root = node;\n\t\t} else {\n\t\t\tthis._root.insert(node);\n\t\t}\n\t\tthis._length++;\n\t\t// Restructure tree to be balanced\n\t\twhile (node !== null) {\n\t\t\tnode.updateHeight();\n\t\t\tnode.updateMax();\n\t\t\tthis._rebalance(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove an event from the timeline.\n\t *  @param  event  The event to remove from the timeline\n\t */\n\tremove(event: IntervalTimelineEvent): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(event.time, results);\n\t\t\tfor (const node of results) {\n\t\t\t\tif (node.event === event) {\n\t\t\t\t\tthis._removeNode(node);\n\t\t\t\t\tthis._length--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The number of items in the timeline.\n\t *  @readOnly\n\t */\n\tget length(): number {\n\t\treturn this._length;\n\t}\n\n\t/**\n\t *  Remove events whose time time is after the given time\n\t *  @param  time  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tthis.forEachFrom(after, event => this.remove(event));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Set the root node as the given node\n\t */\n\tprivate _setRoot(node: IntervalNode | null): void {\n\t\tthis._root = node;\n\t\tif (this._root !== null) {\n\t\t\tthis._root.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t *  Replace the references to the node in the node's parent\n\t *  with the replacement node.\n\t */\n\tprivate _replaceNodeInParent(node: IntervalNode, replacement: IntervalNode | null): void {\n\t\tif (node.parent !== null) {\n\t\t\tif (node.isLeftChild()) {\n\t\t\t\tnode.parent.left = replacement;\n\t\t\t} else {\n\t\t\t\tnode.parent.right = replacement;\n\t\t\t}\n\t\t\tthis._rebalance(node.parent);\n\t\t} else {\n\t\t\tthis._setRoot(replacement);\n\t\t}\n\t}\n\n\t/**\n\t *  Remove the node from the tree and replace it with\n\t *  a successor which follows the schema.\n\t */\n\tprivate _removeNode(node: IntervalNode): void {\n\t\tif (node.left === null && node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, null);\n\t\t} else if (node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, node.left);\n\t\t} else if (node.left === null) {\n\t\t\tthis._replaceNodeInParent(node, node.right);\n\t\t} else {\n\t\t\tconst balance = node.getBalance();\n\t\t\tlet replacement: IntervalNode;\n\t\t\tlet temp: IntervalNode | null = null;\n\t\t\tif (balance > 0) {\n\t\t\t\tif (node.left.right === null) {\n\t\t\t\t\treplacement = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\ttemp = replacement;\n\t\t\t\t} else {\n\t\t\t\t\treplacement = node.left.right;\n\t\t\t\t\twhile (replacement.right !== null) {\n\t\t\t\t\t\treplacement = replacement.right;\n\t\t\t\t\t}\n\t\t\t\t\tif (replacement.parent) {\n\t\t\t\t\t\treplacement.parent.right = replacement.left;\n\t\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.right.left === null) {\n\t\t\t\treplacement = node.right;\n\t\t\t\treplacement.left = node.left;\n\t\t\t\ttemp = replacement;\n\t\t\t} else {\n\t\t\t\treplacement = node.right.left;\n\t\t\t\twhile (replacement.left !== null) {\n\t\t\t\t\treplacement = replacement.left;\n\t\t\t\t}\n\t\t\t\tif (replacement.parent) {\n\t\t\t\t\treplacement.parent.left = replacement.right;\n\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.parent !== null) {\n\t\t\t\tif (node.isLeftChild()) {\n\t\t\t\t\tnode.parent.left = replacement;\n\t\t\t\t} else {\n\t\t\t\t\tnode.parent.right = replacement;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setRoot(replacement);\n\t\t\t}\n\t\t\tif (temp) {\n\t\t\t\tthis._rebalance(temp);\n\t\t\t}\n\t\t}\n\t\tnode.dispose();\n\t}\n\n\t/**\n\t *  Rotate the tree to the left\n\t */\n\tprivate _rotateLeft(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.right the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.right;\n\t\tif (pivotNode) {\n\t\t\tnode.right = pivotNode.left;\n\t\t\tpivotNode.left = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t *  Rotate the tree to the right\n\t */\n\tprivate _rotateRight(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.left the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.left;\n\t\tif (pivotNode) {\n\t\t\tnode.left = pivotNode.right;\n\t\t\tpivotNode.right = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t *  Balance the BST\n\t */\n\tprivate _rebalance(node: IntervalNode): void {\n\t\tconst balance = node.getBalance();\n\t\tif (balance > 1 && node.left) {\n\t\t\tif (node.left.getBalance() < 0) {\n\t\t\t\tthis._rotateLeft(node.left);\n\t\t\t} else {\n\t\t\t\tthis._rotateRight(node);\n\t\t\t}\n\t\t} else if (balance < -1 && node.right) {\n\t\t\tif (node.right.getBalance() > 0) {\n\t\t\t\tthis._rotateRight(node.right);\n\t\t\t} else {\n\t\t\t\tthis._rotateLeft(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Get an event whose time and duration span the give time. Will\n\t *  return the match whose \"time\" value is closest to the given time.\n\t *  @return  The event which spans the desired time\n\t */\n\tget(time: number): IntervalTimelineEvent | null {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tif (results.length > 0) {\n\t\t\t\tlet max = results[0];\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tif (results[i].low > max.low) {\n\t\t\t\t\t\tmax = results[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max.event;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t *  Iterate over everything in the timeline.\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst allNodes: IntervalNode[] = [];\n\t\t\tthis._root.traverse(node => allNodes.push(node));\n\t\t\tallNodes.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array in which the given time\n\t *  overlaps with the time and duration time of the event.\n\t *  @param  time The time to check if items are overlapping\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array in which the time is greater\n\t *  than or equal to the given time.\n\t *  @param  time The time to check if items are before\n\t *  @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.searchAfter(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._root !== null) {\n\t\t\tthis._root.traverse(node => node.dispose());\n\t\t}\n\t\tthis._root = null;\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tINTERVAL NODE HELPER\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Represents a node in the binary search tree, with the addition\n *  of a \"high\" value which keeps track of the highest value of\n *  its children.\n *  References:\n *  https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n *  http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n *  @param low\n *  @param high\n */\n// tslint:disable-next-line: max-classes-per-file\nclass IntervalNode {\n\n\t// the event container\n\tevent: IntervalTimelineEvent | null;\n\t// the low value\n\tlow: number;\n\t// the high value\n\thigh: number;\n\t// the high value for this and all child nodes\n\tmax: number;\n\t// the nodes to the left\n\tprivate _left: IntervalNode | null = null;\n\t// the nodes to the right\n\tprivate _right: IntervalNode | null = null;\n\t// the parent node\n\tparent: IntervalNode | null = null;\n\t// the number of child nodes\n\theight: number = 0;\n\n\tconstructor(low: number, high: number, event: IntervalTimelineEvent) {\n\t\tthis.event = event;\n\t\t// the low value\n\t\tthis.low = low;\n\t\t// the high value\n\t\tthis.high = high;\n\t\t// the high value for this and all child nodes\n\t\tthis.max = this.high;\n\t}\n\n\t/**\n\t *  Insert a node into the correct spot in the tree\n\t */\n\tinsert(node: IntervalNode): void {\n\t\tif (node.low <= this.low) {\n\t\t\tif (this.left === null) {\n\t\t\t\tthis.left = node;\n\t\t\t} else {\n\t\t\t\tthis.left.insert(node);\n\t\t\t}\n\t\t} else if (this.right === null) {\n\t\t\tthis.right = node;\n\t\t} else {\n\t\t\tthis.right.insert(node);\n\t\t}\n\t}\n\n\t/**\n\t *  Search the tree for nodes which overlap\n\t *  with the given point\n\t *  @param  point  The point to query\n\t *  @param  results  The array to put the results\n\t */\n\tsearch(point: number, results: IntervalNode[]): void {\n\t\t// If p is to the right of the rightmost point of any interval\n\t\t// in this node and all children, there won't be any matches.\n\t\tif (point > this.max) {\n\t\t\treturn;\n\t\t}\n\t\t// Search left children\n\t\tif (this.left !== null) {\n\t\t\tthis.left.search(point, results);\n\t\t}\n\t\t// Check this node\n\t\tif (this.low <= point && this.high > point) {\n\t\t\tresults.push(this);\n\t\t}\n\t\t// If p is to the left of the time of this interval,\n\t\t// then it can't be in any child to the right.\n\t\tif (this.low > point) {\n\t\t\treturn;\n\t\t}\n\t\t// Search right children\n\t\tif (this.right !== null) {\n\t\t\tthis.right.search(point, results);\n\t\t}\n\t}\n\n\t/**\n\t *  Search the tree for nodes which are less\n\t *  than the given point\n\t *  @param  point  The point to query\n\t *  @param  results  The array to put the results\n\t */\n\tsearchAfter(point: number, results: IntervalNode[]): void {\n\t\t// Check this node\n\t\tif (this.low >= point) {\n\t\t\tresults.push(this);\n\t\t\tif (this.left !== null) {\n\t\t\t\tthis.left.searchAfter(point, results);\n\t\t\t}\n\t\t}\n\t\t// search the right side\n\t\tif (this.right !== null) {\n\t\t\tthis.right.searchAfter(point, results);\n\t\t}\n\t}\n\n\t/**\n\t *  Invoke the callback on this element and both it's branches\n\t *  @param  {Function}  callback\n\t */\n\ttraverse(callback: (self: IntervalNode) => void): void {\n\t\tcallback(this);\n\t\tif (this.left !== null) {\n\t\t\tthis.left.traverse(callback);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.right.traverse(callback);\n\t\t}\n\t}\n\n\t/**\n\t *  Update the height of the node\n\t */\n\tupdateHeight(): void {\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tthis.height = Math.max(this.left.height, this.right.height) + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tthis.height = this.right.height + 1;\n\t\t} else if (this.left !== null) {\n\t\t\tthis.height = this.left.height + 1;\n\t\t} else {\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\n\t/**\n\t *  Update the height of the node\n\t */\n\tupdateMax(): void {\n\t\tthis.max = this.high;\n\t\tif (this.left !== null) {\n\t\t\tthis.max = Math.max(this.max, this.left.max);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.max = Math.max(this.max, this.right.max);\n\t\t}\n\t}\n\n\t/**\n\t *  The balance is how the leafs are distributed on the node\n\t *  @return  Negative numbers are balanced to the right\n\t */\n\tgetBalance(): number {\n\t\tlet balance = 0;\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tbalance = this.left.height - this.right.height;\n\t\t} else if (this.left !== null) {\n\t\t\tbalance = this.left.height + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tbalance = -(this.right.height + 1);\n\t\t}\n\t\treturn balance;\n\t}\n\n\t/**\n\t *  @returns true if this node is the left child of its parent\n\t */\n\tisLeftChild(): boolean {\n\t\treturn this.parent !== null && this.parent.left === this;\n\t}\n\n\t/**\n\t *  get/set the left node\n\t */\n\tget left(): IntervalNode | null {\n\t\treturn this._left;\n\t}\n\n\tset left(node: IntervalNode | null) {\n\t\tthis._left = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t *  get/set the right node\n\t */\n\tget right(): IntervalNode | null {\n\t\treturn this._right;\n\t}\n\n\tset right(node: IntervalNode | null) {\n\t\tthis._right = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t *  null out references.\n\t */\n\tdispose(): void {\n\t\tthis.parent = null;\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis.event = null;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { InputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface VolumeOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n *  @class Volume is a simple volume node, useful for creating a volume fader.\n *\n *  @extends {Tone.AudioNode}\n *  @constructor\n *  @param {Decibels} [volume=0] the initial volume\n *  @example\n * var vol = new Volume(-12);\n * instrument.chain(vol, Tone.Master);\n */\nexport class Volume extends ToneAudioNode<VolumeOptions> {\n\n\treadonly name = \"Volume\";\n\n\t/**\n\t * the output node\n\t */\n\toutput: Gain<Decibels>;\n\n\t/**\n\t * Input and output are the same\n\t */\n\tinput: Gain;\n\n\t/**\n\t * The unmuted volume\n\t */\n\tprivate _unmutedVolume: Decibels;\n\n\t/**\n\t *  The volume control in decibels.\n\t */\n\tvolume: Param<Decibels>;\n\n\tconstructor(options?: Decibels | Partial<VolumeOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]);\n\n\t\tthis.input = this.output = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.volume,\n\t\t\tunits: \"decibels\",\n\t\t});\n\t\tthis.volume = this.output.gain;\n\t\treadOnly(this, \"volume\");\n\t\tthis._unmutedVolume = options.volume;\n\n\t\t// set the mute initially\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): VolumeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * volume.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.volume.value === -Infinity;\n\t}\n\tset mute(mute: boolean) {\n\t\tif (!this.mute && mute) {\n\t\t\tthis._unmutedVolume = this.volume.value;\n\t\t\t// maybe it should ramp here?\n\t\t\tthis.volume.value = -Infinity;\n\t\t} else if (this.mute && !mute) {\n\t\t\tthis.volume.value = this._unmutedVolume;\n\t\t}\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../../component/channel/Volume\";\nimport { connectSeries } from \"../Connect\";\nimport { Decibels } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\nimport { Gain } from \"./Gain\";\nimport { Param } from \"./Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface DestinationOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n *  A single master output which is connected to the\n *  AudioDestinationNode (aka your speakers).\n *  It provides useful conveniences such as the ability\n *  to set the volume and mute the entire application.\n *  It also gives you the ability to apply master effects to your application.\n *\n *  @example\n * //the audio will go from the oscillator to the speakers\n * oscillator.connect(Destination);\n * //a convenience for connecting to the master output is also provided:\n * oscillator.toDestination();\n * //the above two examples are equivalent.\n */\nexport class Destination extends ToneAudioNode<DestinationOptions> {\n\n\treadonly name = \"Destination\";\n\n\tinput: Volume = new Volume({ context: this.context });\n\toutput: Gain = new Gain({ context : this.context });\n\n\t/**\n\t * The volume of the master output.\n\t */\n\tvolume: Param<Decibels> = this.input.volume;\n\n\tconstructor(options: Partial<DestinationOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Destination.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Destination.getDefaults(), arguments);\n\n\t\tconnectSeries(this.input, this.output, this.context.rawContext.destination);\n\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): DestinationOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * Destination.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.input.mute;\n\t}\n\n\tset mute(mute: boolean) {\n\t\tthis.input.mute = mute;\n\t}\n\n\t/**\n\t *  Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n\t *  chained in the master effects chain.\n\t *  @param nodes All arguments will be connected in a row and the Master will be routed through it.\n\t *  @return  {Destination}  this\n\t *  @example\n\t * //some overall compression to keep the levels in check\n\t * var masterCompressor = new Tone.Compressor({\n\t * \t\"threshold\" : -6,\n\t * \t\"ratio\" : 3,\n\t * \t\"attack\" : 0.5,\n\t * \t\"release\" : 0.1\n\t * });\n\t * //give a little boost to the lows\n\t * var lowBump = new Tone.Filter(200, \"lowshelf\");\n\t * //route everything through the filter\n\t * //and compressor before going to the speakers\n\t * Destination.chain(lowBump, masterCompressor);\n\t */\n\tchain(...args: Array<AudioNode | ToneAudioNode>): this {\n\t\tthis.input.disconnect();\n\t\targs.unshift(this.input);\n\t\targs.push(this.output);\n\t\tconnectSeries(...args);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tINITIALIZATION\n///////////////////////////////////////////////////////////////////////////\n\nonContextInit(context => {\n\tcontext.destination = new Destination({ context });\n});\n\nonContextClose(context => {\n\tcontext.destination.dispose();\n});\n","import { Seconds, Ticks } from \"../type/Units\";\nimport { noOp } from \"../util/Interface\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\nexport interface TransportEventOptions {\n\tcallback: (time: number) => void;\n\tonce: boolean;\n\ttime: Ticks;\n}\n\n/**\n * TransportEvent is an internal class used by (Tone.Transport)[Transport]\n * to schedule events. Do no invoke this class directly, it is\n * handled from within Tone.Transport.\n * @param Transport The transport object which the event belongs to\n */\nexport class TransportEvent {\n\n\t/**\n\t * Reference to the Transport that created it\n\t */\n\tprotected transport: Transport;\n\n\t/**\n\t * The unique id of the event\n\t */\n\tid: number = TransportEvent._eventId++;\n\n\t/**\n\t * The time the event starts\n\t */\n\ttime: Ticks;\n\n\t/**\n\t * The callback to invoke\n\t */\n\tprivate callback?: (time: Seconds) => void;\n\n\t/**\n\t * If the event should be removed after being invoked.\n\t */\n\tprivate _once: boolean;\n\n\tconstructor(transport: Transport, opts: Partial<TransportEventOptions>) {\n\n\t\tconst options: TransportEventOptions = Object.assign(TransportEvent.getDefaults(), opts);\n\n\t\tthis.transport = transport;\n\t\tthis.callback = options.callback;\n\t\tthis._once = options.once;\n\t\tthis.time = options.time;\n\t}\n\n\tstatic getDefaults(): TransportEventOptions {\n\t\treturn {\n\t\t\tcallback: noOp,\n\t\t\tonce: false,\n\t\t\ttime: 0,\n\t\t};\n\t}\n\n\t/**\n\t * Current ID counter\n\t */\n\tprivate static _eventId: number = 0;\n\n\t/**\n\t * Invoke the event callback.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\tif (this.callback) {\n\t\t\tthis.callback(time);\n\t\t\tif (this._once) {\n\t\t\t\tthis.transport.clear(this.id);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tthis.callback = undefined;\n\t\treturn this;\n\t}\n}\n","import { Context } from \"../context/Context\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { TransportEvent, TransportEventOptions } from \"./TransportEvent\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\ninterface TransportRepeatEventOptions extends TransportEventOptions {\n\tinterval: Ticks;\n\tduration: Ticks;\n}\n\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n\n\t/**\n\t * When the event should stop repeating\n\t */\n\tprivate duration: Ticks;\n\n\t/**\n\t * The interval of the repeated event\n\t */\n\tprivate _interval: Ticks;\n\n\t/**\n\t * The ID of the current timeline event\n\t */\n\tprivate _currentId: number = -1;\n\n\t/**\n\t * The ID of the next timeline event\n\t */\n\tprivate _nextId: number = -1;\n\n\t/**\n\t * The time of the next event\n\t */\n\tprivate _nextTick = this.time;\n\n\t/**\n\t * a reference to the bound start method\n\t */\n\tprivate _boundRestart = this._restart.bind(this);\n\n\t/**\n\t * The audio context belonging to this event\n\t */\n\tprotected context: Context;\n\n\tconstructor(transport: Transport, opts: Partial<TransportRepeatEventOptions>) {\n\n\t\tsuper(transport, opts);\n\n\t\tconst options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n\n\t\tthis.duration =  new TicksClass(transport.context, options.duration).valueOf();\n\t\tthis._interval = new  TicksClass(transport.context, options.interval).valueOf();\n\t\tthis._nextTick = options.time;\n\t\tthis.transport.on(\"start\", this._boundRestart);\n\t\tthis.transport.on(\"loopStart\", this._boundRestart);\n\t\tthis.context = this.transport.context;\n\t\tthis._restart();\n\t}\n\n\tstatic getDefaults(): TransportRepeatEventOptions {\n\t\treturn Object.assign({}, TransportEvent.getDefaults(), {\n\t\t\tduration: Infinity,\n\t\t\tinterval: 1,\n\t\t\tonce: false,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke the callback. Returns the tick time which\n\t * the next event should be scheduled at.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\t// create more events if necessary\n\t\tthis._createEvents(time);\n\t\t// call the super class\n\t\tsuper.invoke(time);\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _createEvents(time: Seconds): void {\n\t\t// schedule the next event\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n\t\t\tthis._nextTick += this._interval;\n\t\t\tthis._currentId = this._nextId;\n\t\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _restart(time?: Time): void {\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis._nextTick = this.time;\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks > this.time) {\n\t\t\tthis._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n\t\t}\n\t\tthis._currentId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\tthis._nextTick += this._interval;\n\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis.transport.off(\"start\", this._boundRestart);\n\t\tthis.transport.off(\"loopStart\", this._boundRestart);\n\t\treturn this;\n\t}\n}\n","import { TimeClass } from \"../../core/type/Time\";\nimport { PlaybackState } from \"../../core/util/StateTimeline\";\nimport { Signal } from \"../../signal/Signal\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { Param } from \"../context/Param\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { BarsBeatsSixteenths, BPM, NormalRange, Seconds,\n\tSubdivision, Ticks, Time, TimeSignature, TransportTime } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n\ninterface TransportOptions extends ToneWithContextOptions {\n\tbpm: BPM;\n\tswing: NormalRange;\n\tswingSubdivision: Subdivision;\n\ttimeSignature: number;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tppq: number;\n}\n\ntype TransportEventNames = \"start\" | \"stop\" | \"pause\" | \"loop\" | \"loopEnd\" | \"loopStart\";\n\ninterface SyncedSignalEvent {\n\tsignal: Signal;\n\tinitial: number;\n\tratio: Gain;\n}\n\ntype TransportCallback = (time: Seconds) => void;\n\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * //repeated event every 8th note\n * Transport.scheduleRepeat(function(time){\n * \t//do something with the time\n * }, \"8n\");\n * @example\n * //schedule an event on the 16th measure\n * Transport.schedule(function(time){\n * \t//do something with the time\n * }, \"16:0:0\");\n */\nexport class Transport extends ToneWithContext<TransportOptions> implements Emitter<TransportEventNames> {\n\n\tname = \"Transport\";\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tLOOPING\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * \tIf the transport loops or not.\n\t */\n\tloop: boolean = false;\n\n\t/**\n\t * \tThe loop start position in ticks\n\t */\n\tprivate _loopStart: Ticks = 0;\n\n\t/**\n\t * \tThe loop end position in ticks\n\t */\n\tprivate _loopEnd: Ticks = 0;\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tCLOCK/TEMPO\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Pulses per quarter is the number of ticks per quarter note.\n\t */\n\tprivate _ppq: number;\n\n\t/**\n\t *  watches the main oscillator for timing ticks\n\t *  initially starts at 120bpm\n\t */\n\tprivate _clock: Clock<BPM>;\n\n\t/**\n\t * The Beats Per Minute of the Transport.\n\t * @example\n\t * Transport.bpm.value = 80;\n\t * //ramp the bpm to 120 over 10 seconds\n\t * Transport.bpm.rampTo(120, 10);\n\t */\n\tbpm: Param<BPM>;\n\n\t/**\n\t *  The time signature, or more accurately the numerator\n\t *  of the time signature over a denominator of 4.\n\t */\n\tprivate _timeSignature: number;\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tTIMELINE EVENTS\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  All the events in an object to keep track by ID\n\t */\n\tprivate _scheduledEvents = {};\n\n\t/**\n\t * \tThe scheduled events.\n\t */\n\tprivate _timeline: Timeline<TransportEvent> = new Timeline();\n\n\t/**\n\t *  Repeated events\n\t */\n\tprivate _repeatedEvents: IntervalTimeline = new IntervalTimeline();\n\n\t/**\n\t *  All of the synced Signals\n\t */\n\tprivate _syncedSignals: SyncedSignalEvent[] = [];\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tSWING\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  The subdivision of the swing\n\t */\n\tprivate _swingTicks: Ticks;\n\n\t/**\n\t *  The swing amount\n\t */\n\tprivate _swingAmount: NormalRange = 0;\n\n\tconstructor(options?: Partial<TransportOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Transport.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Transport.getDefaults(), arguments);\n\n\t\t// CLOCK/TEMPO\n\t\tthis._ppq = options.ppq;\n\t\tthis._clock = new Clock({\n\t\t\tcallback : this._processTick.bind(this),\n\t\t\tcontext: this.context,\n\t\t\tfrequency : 0,\n\t\t\tunits: \"bpm\",\n\t\t});\n\t\tthis._bindClockEvents();\n\t\tthis.bpm = this._clock.frequency;\n\t\tthis._clock.frequency.multiplier = options.ppq;\n\t\tthis.bpm.value = options.bpm;\n\t\treadOnly(this, \"bpm\");\n\t\tthis._timeSignature = options.timeSignature;\n\n\t\t// SWING\n\t\tthis._swingTicks = options.ppq / 2; // 8n\n\t}\n\n\tstatic getDefaults(): TransportOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tbpm: 120,\n\t\t\tloopEnd: \"4m\" as Subdivision,\n\t\t\tloopStart: 0,\n\t\t\tppq: 192,\n\t\t\tswing: 0,\n\t\t\tswingSubdivision: \"8n\" as Subdivision,\n\t\t\ttimeSignature: 4,\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tTICKS\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  called on every tick\n\t *  @param  tickTime clock relative tick time\n\t *  @private\n\t */\n\tprivate _processTick(tickTime: Seconds, ticks: Ticks): void {\n\t\t// handle swing\n\t\tif (this._swingAmount > 0 &&\n\t\t\tticks % this._ppq !== 0 && // not on a downbeat\n\t\t\tticks % (this._swingTicks * 2) !== 0) {\n\t\t\t// add some swing\n\t\t\tconst progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n\t\t\tconst amount = Math.sin((progress) * Math.PI) * this._swingAmount;\n\t\t\ttickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n\t\t}\n\t\t// do the loop test\n\t\tif (this.loop) {\n\t\t\tif (ticks >= this._loopEnd) {\n\t\t\t\tthis.emit(\"loopEnd\", tickTime);\n\t\t\t\tthis._clock.setTicksAtTime(this._loopStart, tickTime);\n\t\t\t\tticks = this._loopStart;\n\t\t\t\tthis.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n\t\t\t\tthis.emit(\"loop\", tickTime);\n\t\t\t}\n\t\t}\n\t\t// invoke the timeline events scheduled on this tick\n\t\tthis._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSCHEDULABLE EVENTS\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Schedule an event along the timeline.\n\t * @param callback The callback to be invoked at the time.\n\t * @param time The time to invoke the callback at.\n\t * @return The id of the event which can be used for canceling the event.\n\t * @example\n\t * //trigger the callback when the Transport reaches the desired time\n\t * Transport.schedule(function(time){\n\t * \tenvelope.triggerAttack(time);\n\t * }, \"128i\");\n\t */\n\tschedule(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\ttime : new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Schedule a repeated event along the timeline. The event will fire\n\t * at the `interval` starting at the `startTime` and for the specified\n\t * `duration`.\n\t * @param  callback   The callback to invoke.\n\t * @param  interval   The duration between successive callbacks. Must be a positive number.\n\t * @param  startTime  When along the timeline the events should start being invoked.\n\t * @param  duration How long the event should repeat.\n\t * @return  The ID of the scheduled event. Use this to cancel the event.\n\t * @example\n\t * //a callback invoked every eighth note after the first measure\n\t * Transport.scheduleRepeat(callback, \"8n\", \"1m\");\n\t */\n\tscheduleRepeat(\n\t\tcallback: TransportCallback,\n\t\tinterval: Time | TimeClass,\n\t\tstartTime?: TransportTime | TransportTimeClass,\n\t\tduration: Time = Infinity,\n\t): number {\n\t\tconst event = new TransportRepeatEvent(this, {\n\t\t\tcallback,\n\t\t\tduration : new TimeClass(this.context, duration).toTicks(),\n\t\t\tinterval: new TimeClass(this.context, interval).toTicks(),\n\t\t\ttime : new TransportTimeClass(this.context, startTime).toTicks(),\n\t\t});\n\t\t// kick it off if the Transport is started\n\t\t// @ts-ignore\n\t\treturn this._addEvent(event, this._repeatedEvents);\n\t}\n\n\t/**\n\t *  Schedule an event that will be removed after it is invoked.\n\t *  @param callback The callback to invoke once.\n\t *  @param time The time the callback should be invoked.\n\t *  @returns The ID of the scheduled event.\n\t */\n\tscheduleOnce(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\tonce : true,\n\t\t\ttime : new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Clear the passed in event id from the timeline\n\t * @param eventId The id of the event.\n\t */\n\tclear(eventId: number): this {\n\t\tif (this._scheduledEvents.hasOwnProperty(eventId)) {\n\t\t\tconst item = this._scheduledEvents[eventId.toString()];\n\t\t\titem.timeline.remove(item.event);\n\t\t\titem.event.dispose();\n\t\t\tdelete this._scheduledEvents[eventId.toString()];\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an event to the correct timeline. Keep track of the\n\t * timeline it was added to.\n\t * @returns the event id which was just added\n\t */\n\tprivate _addEvent(event: TransportEvent, timeline: Timeline<TransportEvent>): number {\n\t\tthis._scheduledEvents[event.id.toString()] = {\n\t\t\tevent,\n\t\t\ttimeline,\n\t\t};\n\t\ttimeline.add(event);\n\t\treturn event.id;\n\t}\n\n\t/**\n\t * Remove scheduled events from the timeline after\n\t * the given time. Repeated events will be removed\n\t * if their startTime is after the given time\n\t * @param after Clear all events after this time.\n\t */\n\tcancel(after: TransportTime = 0): this {\n\t\tconst computedAfter = this.toTicks(after);\n\t\tthis._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\tthis._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSTART/STOP/PAUSE\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Bind start/stop/pause events from the clock and emit them.\n\t */\n\tprivate _bindClockEvents(): void {\n\t\tthis._clock.on(\"start\", (time, offset) => {\n\t\t\toffset = new TicksClass(this.context, offset).toSeconds();\n\t\t\tthis.emit(\"start\", time, offset);\n\t\t});\n\n\t\tthis._clock.on(\"stop\", (time) => {\n\t\t\tthis.emit(\"stop\", time);\n\t\t});\n\n\t\tthis._clock.on(\"pause\", (time) => {\n\t\t\tthis.emit(\"pause\", time);\n\t\t});\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._clock.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the transport and all sources synced to the transport.\n\t * @param  time The time when the transport should start.\n\t * @param  offset The timeline offset to start the transport.\n\t * @example\n\t * //start the transport in one second starting at beginning of the 5th measure.\n\t * Transport.start(\"+1\", \"4:0:0\");\n\t */\n\tstart(time?: Time, offset?: TransportTime): this {\n\t\tlet offsetTicks;\n\t\tif (isDefined(offset)) {\n\t\t\toffsetTicks = this.toTicks(offset);\n\t\t}\n\t\t// start the clock\n\t\tthis._clock.start(time, offsetTicks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the transport and all sources synced to the transport.\n\t * @param time The time when the transport should stop.\n\t * @example\n\t * Transport.stop();\n\t */\n\tstop(time?: Time): this {\n\t\tthis._clock.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the transport and all sources synced to the transport.\n\t */\n\tpause(time?: Time): this {\n\t\tthis._clock.pause(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Toggle the current state of the transport. If it is\n\t * started, it will stop it, otherwise it will start the Transport.\n\t * @param  time The time of the event\n\t */\n\ttoggle(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._clock.getStateAtTime(time) !== \"started\") {\n\t\t\tthis.start(time);\n\t\t} else {\n\t\t\tthis.stop(time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSETTERS/GETTERS\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * The time signature as just the numerator over 4.\n\t * For example 4/4 would be just 4 and 6/8 would be 3.\n\t * @example\n\t * //common time\n\t * Transport.timeSignature = 4;\n\t * // 7/8\n\t * Transport.timeSignature = [7, 8];\n\t * //this will be reduced to a single number\n\t * Transport.timeSignature; //returns 3.5\n\t */\n\tget timeSignature(): TimeSignature {\n\t\treturn this._timeSignature;\n\t}\n\tset timeSignature(timeSig: TimeSignature) {\n\t\tif (isArray(timeSig)) {\n\t\t\ttimeSig = (timeSig[0] / timeSig[1]) * 4;\n\t\t}\n\t\tthis._timeSignature = timeSig;\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the starting position of the loop.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n\t}\n\tset loopStart(startPosition: Time) {\n\t\tthis._loopStart = this.toTicks(startPosition);\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the ending position of the loop.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n\t}\n\tset loopEnd(endPosition: Time) {\n\t\tthis._loopEnd = this.toTicks(endPosition);\n\t}\n\n\t/**\n\t * Set the loop start and stop at the same time.\n\t * @example\n\t * //loop over the first measure\n\t * Transport.setLoopPoints(0, \"1m\");\n\t * Transport.loop = true;\n\t */\n\tsetLoopPoints(startPosition: TransportTime, endPosition: TransportTime): this {\n\t\tthis.loopStart = startPosition;\n\t\tthis.loopEnd = endPosition;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n\t */\n\tget swing(): NormalRange {\n\t\treturn this._swingAmount;\n\t}\n\tset swing(amount: NormalRange) {\n\t\t// scale the values to a normal range\n\t\tthis._swingAmount = amount;\n\t}\n\n\t/**\n\t * Set the subdivision which the swing will be applied to.\n\t * The default value is an 8th note. Value must be less\n\t * than a quarter note.\n\t */\n\tget swingSubdivision(): Subdivision {\n\t\treturn new TicksClass(this.context, this._swingTicks).toNotation();\n\t}\n\tset swingSubdivision(subdivision: Subdivision) {\n\t\tthis._swingTicks = this.toTicks(subdivision);\n\t}\n\n\t/**\n\t *  The Transport's position in Bars:Beats:Sixteenths.\n\t *  Setting the value will jump to that position right away.\n\t */\n\tget position(): BarsBeatsSixteenths | Time {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\treturn new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n\t}\n\tset position(progress: Time) {\n\t\tconst ticks = this.toTicks(progress);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t *  The Transport's position in seconds\n\t *  Setting the value will jump to that position right away.\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._clock.seconds;\n\t}\n\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.frequency.timeToTicks(s, now);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t *  The Transport's loop position as a normalized value. Always\n\t *  returns 0 if the transport if loop is not true.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this.loop) {\n\t\t\tconst now = this.now();\n\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\treturn (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t *  The transports current tick position.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this._clock.ticks;\n\t}\n\tset ticks(t: Ticks) {\n\t\tif (this._clock.ticks !== t) {\n\t\t\tconst now = this.now();\n\t\t\t// stop everything synced to the transport\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis.emit(\"stop\", now);\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t\t// restart it with the new time\n\t\t\t\tthis.emit(\"start\", now, this.seconds);\n\t\t\t} else {\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn Math.round(this._clock.getTicksAtTime(time));\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t *  @param  time  When to get the elapsed seconds\n\t *  @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._clock.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t *  Pulses Per Quarter note. This is the smallest resolution\n\t *  the Transport timing supports. This should be set once\n\t *  on initialization and not set again. Changing this value\n\t *  after other objects have been created can cause problems.\n\t */\n\tget PPQ(): number {\n\t\treturn this._clock.frequency.multiplier;\n\t}\n\tset PPQ(ppq: number) {\n\t\tthis._clock.frequency.multiplier = ppq;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSYNCING\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Returns the time aligned to the next subdivision\n\t * of the Transport. If the Transport is not started,\n\t * it will return 0.\n\t * Note: this will not work precisely during tempo ramps.\n\t * @param  subdivision  The subdivision to quantize to\n\t * @return  The context time of the next subdivision.\n\t * @example\n\t * Transport.start(); //the transport must be started\n\t * Transport.nextSubdivision(\"4n\");\n\t */\n\tnextSubdivision(subdivision?: Time): Seconds {\n\t\tsubdivision = this.toTicks(subdivision);\n\t\tif (this.state !== \"started\") {\n\t\t\t// if the transport's not started, return 0\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tconst now = this.now();\n\t\t\t// the remainder of the current ticks and the subdivision\n\t\t\tconst transportPos = this.getTicksAtTime(now);\n\t\t\tconst remainingTicks = subdivision - transportPos % subdivision;\n\t\t\treturn this._clock.nextTickTime(remainingTicks, now);\n\t\t}\n\t}\n\n\t/**\n\t *  Attaches the signal to the tempo control signal so that\n\t *  any changes in the tempo will change the signal in the same\n\t *  ratio.\n\t *\n\t *  @param signal\n\t *  @param ratio Optionally pass in the ratio between the two signals.\n\t * \t\t\t\tOtherwise it will be computed based on their current values.\n\t */\n\tsyncSignal(signal: Signal<any>, ratio?: number): this {\n\t\tif (!ratio) {\n\t\t\t// get the sync ratio\n\t\t\tconst now = this.now();\n\t\t\tif (signal.getValueAtTime(now) !== 0) {\n\t\t\t\tconst bpm = this.bpm.getValueAtTime(now);\n\t\t\t\tconst computedFreq = 1 / (60 / bpm / this.PPQ);\n\t\t\t\tratio = signal.getValueAtTime(now) / computedFreq;\n\t\t\t} else {\n\t\t\t\tratio = 0;\n\t\t\t}\n\t\t}\n\t\tconst ratioSignal = new Gain(ratio);\n\t\t// @ts-ignore\n\t\tthis.bpm.connect(ratioSignal);\n\t\t// @ts-ignore\n\t\tratioSignal.connect(signal._param);\n\t\tthis._syncedSignals.push({\n\t\t\tinitial : signal.value,\n\t\t\tratio : ratioSignal,\n\t\t\tsignal,\n\t\t});\n\t\tsignal.value = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Unsyncs a previously synced signal from the transport's control.\n\t *  See Transport.syncSignal.\n\t */\n\tunsyncSignal(signal: Signal<any>): this {\n\t\tfor (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n\t\t\tconst syncedSignal = this._syncedSignals[i];\n\t\t\tif (syncedSignal.signal === signal) {\n\t\t\t\tsyncedSignal.ratio.dispose();\n\t\t\t\tsyncedSignal.signal.value = syncedSignal.initial;\n\t\t\t\tthis._syncedSignals.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._clock.dispose();\n\t\twritable(this, \"bpm\");\n\t\tthis._timeline.dispose();\n\t\tthis._repeatedEvents.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t///////////////////////////////////////////////////////////////////////\n\n\ton!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\tonce!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\toff!: (event: TransportEventNames, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Transport);\n\n///////////////////////////////////////////////////////////////////////////////\n// \tINITIALIZATION\n///////////////////////////////////////////////////////////////////////////////\n\nonContextInit(context => {\n\tcontext.transport = new Transport({ context });\n});\n\nonContextClose(context => {\n\tcontext.transport.dispose();\n});\n","import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels, Seconds, Time } from \"../core/type/Units\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline } from \"../core/util/StateTimeline\";\nimport { isUndef } from \"../core/util/TypeCheck\";\n\ntype onStopCallback = (source: Source<any>) => void;\n\nexport interface SourceOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n\tonstop: onStopCallback;\n}\n\n/**\n *  @class  Base class for sources. Sources have start/stop methods\n *          and the ability to be synced to the\n *          start/stop of this.context.transport.\n *\n *  @constructor\n *  @extends {Tone.AudioNode}\n *  @example\n * //Multiple state change events can be chained together,\n * //but must be set in the correct order and with ascending times\n *\n * // OK\n * state.start().stop(\"+0.2\");\n * // AND\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n *\n * // BAD\n * state.stop(\"+0.2\").start();\n * // OR\n * state.start(\"+0.3\").stop(\"+0.2\");\n *\n */\nexport abstract class Source<Options extends SourceOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t *  The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The output note\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * Sources have no inputs\n\t */\n\tinput = undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * source.volume.value = -6;\n\t */\n\tvolume: Param<Decibels>;\n\n\t/**\n\t * The callback to invoke when the source is stopped.\n\t */\n\tonstop: onStopCallback;\n\n\t/**\n\t * \tKeep track of the scheduled state.\n\t */\n\tprotected _state: StateTimeline<{\n\t\tduration?: Seconds;\n\t\toffset?: Seconds;\n\t\t/**\n\t\t * Either the buffer is explicitly scheduled to end using the stop method,\n\t\t * or it's implicitly ended when the buffer is over.\n\t\t */\n\t\timplicitEnd?: boolean;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t *  The synced `start` callback function from the transport\n\t *  @type {Function}\n\t *  @private\n\t */\n\tprotected _synced = false;\n\n\t/**\n\t *  Keep track of all of the scheduled event ids\n\t */\n\tprivate _scheduled: number[] = [];\n\n\t/**\n\t * Placeholder functions for syncing/unsyncing to transport\n\t */\n\tprivate _syncedStart: (time: Seconds, offset: Seconds) => void = noOp;\n\tprivate _syncedStop: (time: Seconds) => void = noOp;\n\n\tconstructor(options: SourceOptions) {\n\t\tsuper(options);\n\t\tthis._state.memory = 100;\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tmute: options.mute,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.onstop = options.onstop;\n\t}\n\n\tstatic getDefaults(): SourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tonstop: noOp,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\tif (this._synced) {\n\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\treturn this._state.getValueAtTime(this.context.transport.seconds) as BasicPlaybackState;\n\t\t\t} else {\n\t\t\t\treturn \"stopped\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._state.getValueAtTime(this.now()) as BasicPlaybackState;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * source.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t// overwrite these functions\n\tprotected abstract _start(time: Time, offset?: Time, duration?: Time): void;\n\tprotected abstract _stop(time: Time): void;\n\tabstract restart(time: Time, offset?: Time, duration?: Time): this;\n\n\t/**\n\t * Ensure that the scheduled time is not before the current time.\n\t * Should only be used when scheduled unsynced.\n\t */\n\tprivate _clampToCurrentTime(time: Seconds): Seconds {\n\t\tif (this._synced) {\n\t\t\treturn time;\n\t\t} else {\n\t\t\treturn Math.max(time, this.context.currentTime);\n\t\t}\n\t}\n\n\t/**\n\t *  Start the source at the specified time. If no time is given,\n\t *  start the source now.\n\t *  @param  time When the source should be started.\n\t *  @example\n\t * source.start(\"+0.5\"); //starts the source 0.5 seconds from now\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\tthis.log(\"start\", computedTime);\n\t\t// if it's started, stop it and restart it\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis.restart(computedTime, offset, duration);\n\t\t} else {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (this._synced) {\n\t\t\t\t// add the offset time to the event\n\t\t\t\tconst event = this._state.get(computedTime);\n\t\t\t\tif (event) {\n\t\t\t\t\tevent.offset = this.toSeconds(defaultArg(offset, 0));\n\t\t\t\t\tevent.duration = duration ? this.toSeconds(duration) : undefined;\n\t\t\t\t}\n\t\t\t\tconst sched = this.context.transport.schedule(t => {\n\t\t\t\t\tthis._start(t, offset, duration);\n\t\t\t\t}, computedTime);\n\t\t\t\tthis._scheduled.push(sched);\n\n\t\t\t\t// if it's already started\n\t\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\t\tthis._syncedStart(this.now(), this.context.transport.seconds);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._start(computedTime, offset, duration);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the source at the specified time. If no time is given,\n\t *  stop the source now.\n\t *  @param  time When the source should be stopped.\n\t *  @example\n\t * source.stop(); // stops the source immediately\n\t */\n\tstop(time?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\tthis.log(\"stop\", computedTime);\n\t\tif (!this._synced) {\n\t\t\tthis._stop(computedTime);\n\t\t} else {\n\t\t\tconst sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\t\t\tthis._scheduled.push(sched);\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Sync the source to the Transport so that all subsequent\n\t *  calls to `start` and `stop` are synced to the TransportTime\n\t *  instead of the AudioContext time.\n\t *\n\t * @example\n\t * //sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n\t * source.sync().start(0).stop(0.3);\n\t * //start the transport.\n\t * this.context.transport.start();\n\t *\n\t * @example\n\t * //start the transport with an offset and the sync'ed sources\n\t * //will start in the correct position\n\t * source.sync().start(0.1);\n\t * //the source will be invoked with an offset of 0.4 = (0.5 - 0.1)\n\t * this.context.transport.start(\"+0.5\", 0.5);\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncedStart = (time, offset) => {\n\t\t\t\tif (offset > 0) {\n\t\t\t\t\t// get the playback state at that time\n\t\t\t\t\tconst stateEvent = this._state.get(offset);\n\t\t\t\t\t// listen for start events which may occur in the middle of the sync'ed time\n\t\t\t\t\tif (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n\t\t\t\t\t\t// get the offset\n\t\t\t\t\t\tconst startOffset = offset - this.toSeconds(stateEvent.time);\n\t\t\t\t\t\tlet duration;\n\t\t\t\t\t\tif (stateEvent.duration) {\n\t\t\t\t\t\t\tduration = this.toSeconds(stateEvent.duration) - startOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._syncedStop = time => {\n\t\t\t\tconst seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\t\t\t\tif (this._state.getValueAtTime(seconds) === \"started\") {\n\t\t\t\t\tthis._stop(time);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.context.transport.on(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"loopStart\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedStop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Unsync the source to the Transport. See Source.sync\n\t */\n\tunsync(): this {\n\t\tif (this._synced) {\n\t\t\tthis.context.transport.off(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"loopEnd\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.off(\"loopStart\", this._syncedStart);\n\t\t}\n\t\tthis._synced = false;\n\t\t// clear all of the scheduled ids\n\t\tthis._scheduled.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduled = [];\n\t\tthis._state.cancel(0);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.onstop = noOp;\n\t\tthis.unsync();\n\t\tthis._volume.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { GainFactor, Seconds, Time } from \"../core/type/Units\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState } from \"../core/util/StateTimeline\";\n\nexport type OneShotSourceCurve = \"linear\" | \"exponential\";\n\ntype onEndedCallback = (source: OneShotSource<any>) => void;\n\nexport interface OneShotSourceOptions extends ToneAudioNodeOptions {\n\tonended: onEndedCallback;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tcurve: OneShotSourceCurve;\n}\n\nexport abstract class OneShotSource<Options extends ToneAudioNodeOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t *  The callback to invoke after the\n\t *  source is done playing.\n\t */\n\tonended: onEndedCallback = noOp;\n\n\t/**\n\t * Sources do not have input nodes\n\t */\n\tinput: undefined;\n\n\t/**\n\t *  The start time\n\t */\n\tprotected _startTime: number = -1;\n\n\t/**\n\t *  The stop time\n\t */\n\tprotected _stopTime: number = -1;\n\n\t/**\n\t * The id of the timeout\n\t */\n\tprivate _timeout: number = -1;\n\n\t/**\n\t * The public output node\n\t */\n\toutput: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain : 0,\n\t});\n\n\t/**\n\t *  The output gain node.\n\t */\n\tprotected _gainNode = this.output;\n\n\t/**\n\t *  The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t *  The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tprotected _curve: OneShotSourceCurve;\n\n\tconstructor(options: OneShotSourceOptions) {\n\t\tsuper(options);\n\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t\tthis._curve = options.curve;\n\t\tthis.onended = options.onended;\n\t}\n\n\tstatic getDefaults(): OneShotSourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tcurve: \"linear\" as OneShotSourceCurve,\n\t\t\tfadeIn : 0,\n\t\t\tfadeOut: 0,\n\t\t\tonended : noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Stop the source node\n\t */\n\tprotected abstract _stopSource(time: Seconds): void;\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the node\n\t */\n\tprotected abstract start(time?: Time): this;\n\t/**\n\t * Start the source at the given time\n\t * @param  time When to start the source\n\t */\n\tprotected _startGain(time: Seconds, gain: GainFactor = 1): this {\n\t\tthis.assert(this._startTime === -1, \"Source cannot be started more than once\");\n\t\t// apply a fade in envelope\n\t\tconst fadeInTime = this.toSeconds(this._fadeIn);\n\n\t\t// record the start time\n\t\tthis._startTime = time + fadeInTime;\n\t\tthis._startTime = Math.max(this._startTime, this.context.currentTime);\n\n\t\t// schedule the envelope\n\t\tif (fadeInTime > 0) {\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._gainNode.gain.setValueAtTime(gain, time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source node at the given time.\n\t * @param time When to stop the source\n\t */\n\tstop(time?: Time): this {\n\t\tthis.log(\"stop\", time);\n\t\tthis._stopGain(this.toSeconds(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the given time\n\t * @param  time When to stop the source\n\t */\n\tprotected _stopGain(time: Seconds): this {\n\t\tthis.assert(this._startTime !== -1, \"'start' must be called before 'stop'\");\n\t\t// cancel the previous stop\n\t\tthis.cancelStop();\n\n\t\t// the fadeOut time\n\t\tconst fadeOutTime = this.toSeconds(this._fadeOut);\n\n\t\t// schedule the stop callback\n\t\tthis._stopTime = this.toSeconds(time) + fadeOutTime;\n\t\tthis._stopTime = Math.max(this._stopTime, this.context.currentTime);\n\t\tif (fadeOutTime > 0) {\n\t\t\t// start the fade out curve at the given time\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// stop any ongoing ramps, and set the value to 0\n\t\t\tthis._gainNode.gain.cancelAndHoldAtTime(time);\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t}\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._timeout = this.context.setTimeout(() => {\n\t\t\t// allow additional time for the exponential curve to fully decay\n\t\t\tconst additionalTail = this._curve === \"exponential\" ? fadeOutTime * 2 : 0;\n\t\t\tthis._stopSource(this.now() + additionalTail);\n\t\t\tthis._onended();\n\t\t}, this._stopTime - this.context.now());\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the onended callback\n\t */\n\tprotected _onended(): void {\n\t\tif (this.onended !== noOp) {\n\t\t\tthis.onended(this);\n\t\t\t// overwrite onended to make sure it only is called once\n\t\t\tthis.onended = noOp;\n\t\t\t// dispose when it's ended to free up for garbage collection\n\t\t\tsetTimeout(() => this.dispose(), 1000);\n\t\t}\n\t}\n\n\t/**\n\t *  Get the playback state at the given time\n\t */\n\tgetStateAtTime = function(time: Time): BasicPlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._startTime !== -1 && computedTime >= this._startTime &&\n\t\t\t(this._stopTime === -1 || computedTime <= this._stopTime)) {\n\t\t\treturn \"started\";\n\t\t} else {\n\t\t\treturn \"stopped\";\n\t\t}\n\t};\n\n\t/**\n\t * Get the playback state at the current time\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t *  Cancel a scheduled stop event\n\t */\n\tcancelStop(): this {\n\t\tthis.log(\"cancelStop\");\n\t\tthis.assert(this._startTime !== -1, \"Source is not started\");\n\t\t// cancel the stop envelope\n\t\tthis._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._stopTime = -1;\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../../core/Connect\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { GainFactor, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { OneShotSource, OneShotSourceCurve, OneShotSourceOptions } from \"../OneShotSource\";\n\nexport type ToneBufferSourceCurve = OneShotSourceCurve;\n\ninterface ToneBufferSourceOptions extends OneShotSourceOptions {\n\tbuffer: ToneAudioBuffer;\n\tcurve: ToneBufferSourceCurve;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tloop: boolean;\n\tonload: () => void;\n}\n\n/**\n *  Wrapper around the native BufferSourceNode.\n *  @param  buffer   The buffer to play\n *  @param  onended  The callback to invoke when the buffer is done playing.\n */\nexport class ToneBufferSource extends OneShotSource<ToneBufferSourceOptions> {\n\n\tname = \"ToneBufferSource\";\n\n\t/**\n\t *  The oscillator\n\t */\n\tprivate _source = this.context.createBufferSource();\n\tprotected _internalChannels = [this._source];\n\n\t/**\n\t *  The frequency of the oscillator\n\t */\n\treadonly playbackRate: Param<Positive>;\n\n\t/**\n\t * The private instance of the buffer object\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * indicators if the source has started/stopped\n\t */\n\tprivate _sourceStarted: boolean = false;\n\tprivate _sourceStopped: boolean = false;\n\n\tconstructor(buffer?: ToneAudioBuffer | AudioBuffer | string, onload?: () => void);\n\tconstructor(options?: Partial<ToneBufferSourceOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]));\n\t\tconst options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\t\tthis._source.onended = () => this._stopSource();\n\n\t\t/**\n\t\t *  The playbackRate of the buffer\n\t\t */\n\t\tthis.playbackRate = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._source.playbackRate,\n\t\t\tunits : \"positive\",\n\t\t\tvalue : options.playbackRate,\n\t\t});\n\n\t\t// set some values initially\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis._buffer = new ToneAudioBuffer(options.buffer, options.onload);\n\n\t\tthis._internalChannels.push(this._source);\n\t}\n\n\tstatic getDefaults(): ToneBufferSourceOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tbuffer: new ToneAudioBuffer(),\n\t\t\tloop: false,\n\t\t\tloopEnd : 0,\n\t\t\tloopStart : 0,\n\t\t\tonload: noOp,\n\t\t\tplaybackRate : 1,\n\t\t});\n\t}\n\n\t/**\n\t *  The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(t: Time) {\n\t\tthis._fadeIn = t;\n\t}\n\n\t/**\n\t *  The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(t: Time) {\n\t\tthis._fadeOut = t;\n\t}\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tget curve(): ToneBufferSourceCurve {\n\t\treturn this._curve;\n\t}\n\tset curve(t) {\n\t\tthis._curve = t;\n\t}\n\n\t/**\n\t *  Start the buffer\n\t *  @param  time When the player should start.\n\t *  @param  offset The offset from the beginning of the sample to start at.\n\t *  @param  duration How long the sample should play. If no duration\n\t *                   is given, it will default to the full length\n\t *                   of the sample (minus any offset)\n\t *  @param  gain  The gain to play the buffer back at.\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time, gain: GainFactor = 1): this {\n\t\tthis.assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n\t\tconst computedTime = this.toSeconds(time);\n\n\t\t// apply the gain envelope\n\t\tthis._startGain(computedTime, gain);\n\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this.loop) {\n\t\t\toffset = defaultArg(offset, this.loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\t\t// make sure the offset is not less than 0\n\t\tlet computedOffset = Math.max(this.toSeconds(offset), 0);\n\n\t\t// start the buffer source\n\t\tif (this.loop) {\n\t\t\t// modify the offset if it's greater than the loop time\n\t\t\tconst loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\t\tconst loopStart = this.toSeconds(this.loopStart);\n\t\t\tconst loopDuration = loopEnd - loopStart;\n\t\t\t// move the offset back\n\t\t\tif (computedOffset >= loopEnd) {\n\t\t\t\tcomputedOffset = ((computedOffset - loopStart) % loopDuration) + loopStart;\n\t\t\t}\n\t\t}\n\n\t\t// this.buffer.loaded would have return false if the AudioBuffer was undefined\n\t\tthis._source.buffer = this.buffer.get() as AudioBuffer;\n\t\tthis._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\tif (computedOffset < this.buffer.duration) {\n\t\t\tthis._sourceStarted = true;\n\t\t\tthis._source.start(computedTime, computedOffset);\n\t\t}\n\n\t\t// if a duration is given, schedule a stop\n\t\tif (isDefined(duration)) {\n\t\t\tlet computedDur = this.toSeconds(duration);\n\t\t\t// make sure it's never negative\n\t\t\tcomputedDur = Math.max(computedDur, 0);\n\t\t\tthis.stop(computedTime + computedDur);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tif (!this._sourceStopped) {\n\t\t\tthis._sourceStopped = true;\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._onended();\n\t\t}\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._source.loopStart;\n\t}\n\tset loopStart(loopStart: Time) {\n\t\tthis._source.loopStart = this.toSeconds(loopStart);\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._source.loopEnd;\n\t}\n\tset loopEnd(loopEnd: Time) {\n\t\tthis._source.loopEnd = this.toSeconds(loopEnd);\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer: ToneAudioBuffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._source.loop;\n\t}\n\tset loop(loop: boolean) {\n\t\tthis._source.loop = loop;\n\t\tif (this._sourceStarted) {\n\t\t\tthis.cancelStop();\n\t\t}\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._source.onended = null;\n\t\tthis._source.disconnect();\n\t\tthis._buffer.dispose();\n\t\tthis.playbackRate.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { Positive, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Source, SourceOptions } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/BufferSource\";\n\ntype NoiseType = \"white\" | \"brown\" | \"pink\";\n\ninterface NoiseOptions extends SourceOptions {\n\ttype: NoiseType;\n\tplaybackRate: Positive;\n}\n\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @param type the noise type (white|pink|brown)\n * @example\n * //initialize the noise and start\n * var noise = new Noise(\"pink\").start();\n *\n * //make an autofilter to shape the noise\n * var autoFilter = new Tone.AutoFilter({\n * \t\"frequency\" : \"8m\",\n * \t\"min\" : 800,\n * \t\"max\" : 15000\n * }).connect(Tone.Master);\n *\n * //connect the noise\n * noise.connect(autoFilter);\n * //start the autofilter LFO\n * autoFilter.start()\n */\nexport class Noise extends Source<NoiseOptions> {\n\n\tname = \"Noise\";\n\n\t/**\n\t * Private reference to the source\n\t */\n\tprivate _source: ToneBufferSource | null = null;\n\n\t/**\n\t * private reference to the type\n\t */\n\tprivate _type!: NoiseType;\n\n\t/**\n\t *  The playback rate of the noise. Affects\n\t *  the \"frequency\" of the noise.\n\t */\n\tprivate _playbackRate: Positive;\n\n\tconstructor(options?: NoiseType | Partial<NoiseOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n\t\tconst options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.type = options.type;\n\t}\n\n\tstatic getDefaults(): NoiseOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tplaybackRate: 1,\n\t\t\ttype: \"white\" as NoiseType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n\t * @example\n\t * noise.type = \"white\";\n\t */\n\tget type(): NoiseType {\n\t\treturn this._type;\n\t}\n\tset type(type: NoiseType) {\n\t\tthis.assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\t\tif (this._type !== type) {\n\t\t\tthis._type = type;\n\t\t\t// if it's playing, stop and restart it\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst now = this.now();\n\t\t\t\tthis._stop(now);\n\t\t\t\tthis._start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  The playback rate of the noise. Affects\n\t *  the \"frequency\" of the noise.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate: Positive) {\n\t\tthis._playbackRate = rate;\n\t\tif (this._source) {\n\t\t\tthis._source.playbackRate.value = rate;\n\t\t}\n\t}\n\n\t/**\n\t *  internal start method\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst buffer = _noiseBuffers[this._type];\n\t\tthis._source = new ToneBufferSource({\n\t\t\tbuffer,\n\t\t\tcontext: this.context,\n\t\t\tloop: true,\n\t\t\tonended: () => this.onstop(this),\n\t\t\tplaybackRate: this._playbackRate,\n\t\t}).connect(this.output);\n\t\tthis._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n\t}\n\n\t/**\n\t *  internal stop method\n\t *\n\t *  @param {Time} time\n\t *  @private\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tif (this._source) {\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._source = null;\n\t\t}\n\t}\n\n\t/**\n\t * Restarts the noise.\n\t * @param  time When to restart the noise.\n\t */\n\trestart(time?: Time): this {\n\t\t// TODO could be optimized by cancelling the buffer source 'stop'\n\t\t// stop and restart\n\t\tthis._stop(time);\n\t\tthis._start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._source) {\n\t\t\tthis._source.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// THE NOISE BUFFERS\n///////////////////////////////////////////////////////////////////////////\n\n// Noise buffer stats\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n\n/**\n * The cached noise buffers\n */\ninterface NoiseCache {\n\t[key: string]: ToneAudioBuffer | null;\n}\n\n/**\n * Cache the noise buffers\n */\nconst _noiseCache: NoiseCache = {\n\tbrown: null,\n\tpink: null,\n\twhite: null,\n};\n\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nconst _noiseBuffers = {\n\tget brown(): ToneAudioBuffer {\n\t\tif (!_noiseCache.brown) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet lastOut = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tchannel[i] = (lastOut + (0.02 * white)) / 1.02;\n\t\t\t\t\tlastOut = channel[i];\n\t\t\t\t\tchannel[i] *= 3.5; // (roughly) compensate for gain\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.brown;\n\t},\n\n\tget pink(): ToneAudioBuffer {\n\t\tif (!_noiseCache.pink) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\t// tslint:disable-next-line: one-variable-per-declaration\n\t\t\t\tlet b0, b1, b2, b3, b4, b5, b6;\n\t\t\t\tb0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tb0 = 0.99886 * b0 + white * 0.0555179;\n\t\t\t\t\tb1 = 0.99332 * b1 + white * 0.0750759;\n\t\t\t\t\tb2 = 0.96900 * b2 + white * 0.1538520;\n\t\t\t\t\tb3 = 0.86650 * b3 + white * 0.3104856;\n\t\t\t\t\tb4 = 0.55000 * b4 + white * 0.5329522;\n\t\t\t\t\tb5 = -0.7616 * b5 - white * 0.0168980;\n\t\t\t\t\tchannel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n\t\t\t\t\tchannel[i] *= 0.11; // (roughly) compensate for gain\n\t\t\t\t\tb6 = white * 0.115926;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.pink;\n\t},\n\n\tget white(): ToneAudioBuffer {\n\t\tif (!_noiseCache.white) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tchannel[i] = Math.random() * 2 - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.white;\n\t},\n};\n","import { AbstractParam } from \"../core/context/AbstractParam\";\nimport { Param } from \"../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connect } from \"../core/context/ToneAudioNode\";\nimport { Time, Unit, UnitName } from \"../core/type/Units\";\nimport { isAudioParam } from \"../core/util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\n\nexport interface SignalOptions<Type> extends ToneAudioNodeOptions {\n\tvalue: Type;\n\tunits: UnitName;\n\tconvert: boolean;\n}\n\n/**\n * A signal is an audio-rate value. Tone.Signal is a core component of the library.\n * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n * has all of the methods available to native Web Audio\n * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n * as well as additional conveniences. Read more about working with signals\n * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n *  @param value Initial value of the signal\n *  @param units unit The units the signal is in.\n * @example\n * const signal = new Tone.Signal(10);\n */\nexport class Signal<Type extends Unit = number> extends ToneAudioNode<SignalOptions<any>>\nimplements AbstractParam<Type> {\n\n\treadonly name: string = \"Signal\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection.\n\t */\n\treadonly override: boolean = true;\n\n\t/**\n\t * The constant source node which generates the signal\n\t */\n\tprotected _constantSource: ConstantSourceNode = this.context.createConstantSource();\n\treadonly output: OutputNode = this._constantSource;\n\tprotected _param: Param<Type>;\n\treadonly input: InputNode;\n\n\tconstructor(value?: Type, units?: UnitName);\n\tconstructor(options?: Partial<SignalOptions<Type>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n\n\t\tconst options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]) as SignalOptions<Type>;\n\n\t\tthis._constantSource.start(0);\n\t\tthis.input = this._param = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tparam: this._constantSource.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.value,\n\t\t});\n\t}\n\n\tstatic getDefaults(): SignalOptions<any> {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannelCount: 1,\n\t\t\tchannelCountMode: \"explicit\",\n\t\t\tchannelInterpretation: \"discrete\",\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t\tvalue: 0,\n\t\t}) as SignalOptions<any>;\n\t}\n\n\tconnect(destination: InputNode, outputNum: number = 0, inputNum: number = 0): this {\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._param.dispose();\n\t\tthis._constantSource.stop(this.now());\n\t\tthis._constantSource.disconnect();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// ABSTRACT PARAM INTERFACE\n\t// just a proxy for the ConstantSourceNode's offset AudioParam\n\t// all docs are generated from AbstractParam.ts\n\t///////////////////////////////////////////////////////////////////////////\n\n\tsetValueAtTime(value: Type, time: Time): this {\n\t\tthis._param.setValueAtTime(value, time);\n\t\treturn this;\n\t}\n\tgetValueAtTime(time: Time): Type {\n\t\treturn this._param.getValueAtTime(time);\n\t}\n\tsetRampPoint(time: Time): this {\n\t\tthis._param.setRampPoint(time);\n\t\treturn this;\n\t}\n\tlinearRampToValueAtTime(value: Type, time: Time): this {\n\t\tthis._param.linearRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampToValueAtTime(value: Type, time: Time): this {\n\t\tthis._param.exponentialRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.exponentialRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\tlinearRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.linearRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\ttargetRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.targetRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\texponentialApproachValueAtTime(value: Type, time: Time, rampTime: Time): this {\n\t\tthis._param.exponentialApproachValueAtTime(value, time, rampTime);\n\t\treturn this;\n\t}\n\tsetTargetAtTime(value: Type, startTime: Time, timeConstant: number): this {\n\t\tthis._param.setTargetAtTime(value, startTime, timeConstant);\n\t\treturn this;\n\t}\n\tsetValueCurveAtTime(values: Type[], startTime: Time, duration: Time, scaling?: number): this {\n\t\tthis._param.setValueCurveAtTime(values, startTime, duration, scaling);\n\t\treturn this;\n\t}\n\tcancelScheduledValues(time: Time): this {\n\t\tthis._param.cancelScheduledValues(time);\n\t\treturn this;\n\t}\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tthis._param.cancelAndHoldAtTime(time);\n\t\treturn this;\n\t}\n\trampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.rampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\n\tget value(): Type {\n\t\treturn this._param.value;\n\t}\n\tset value(value: Type) {\n\t\tthis._param.value = value;\n\t}\n\n\tget convert(): boolean {\n\t\treturn this._param.convert;\n\t}\n\tset convert(convert: boolean) {\n\t\tthis._param.convert = convert;\n\t}\n\n\tget units(): UnitName {\n\t\treturn this._param.units;\n\t}\n\n\tget overridden(): boolean {\n\t\treturn this._param.overridden;\n\t}\n\tset overridden(overridden: boolean) {\n\t\tthis._param.overridden = overridden;\n\t}\n\n\tget maxValue(): number {\n\t\treturn this._param.maxValue;\n\t}\n\tget minValue(): number {\n\t\treturn this._param.minValue;\n\t}\n}\n\n/**\n * When connecting from a signal, it's necessary to zero out the node destination\n * node if that node is also a signal. If the destination is not 0, then the values\n * will be summed. This method insures that the output of the destination signal will\n * be the same as the source signal, making the destination signal a pass through node.\n * @param signal The output signal to connect from\n * @param destination the destination to connect to\n * @param outputNum the optional output number\n * @param inputNum the input number\n */\nexport function connectSignal(signal: OutputNode, destination: InputNode, outputNum?: number, inputNum?: number): void {\n\tif (destination instanceof Param || isAudioParam(destination) ||\n\t\t(destination instanceof Signal && destination.override)) {\n\t\t// cancel changes\n\t\tdestination.cancelScheduledValues(0);\n\t\t// reset the value\n\t\tdestination.setValueAtTime(0, 0);\n\t\t// mark the value as overridden\n\t\tif (destination instanceof Signal) {\n\t\t\tdestination.overridden = true;\n\t\t}\n\t}\n\tconnect(signal, destination, outputNum, inputNum);\n}\n","import { connect } from \"../../core/Connect\";\nimport { Param } from \"../../core/context/Param\";\nimport { Cents, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource, OneShotSourceOptions } from \"../OneShotSource\";\n\ninterface ToneOscillatorNodeOptions extends OneShotSourceOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\ttype: OscillatorType;\n}\n\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[Tone.Oscillator](Oscillator) is better for most use-cases***\n *  @extends {Tone.AudioNode}\n *  @param  {AudioBuffer|Tone.Buffer}  buffer   The buffer to play\n *  @param  {Function}  onload  The callback to invoke when the\n *                               buffer is done playing.\n */\nexport class ToneOscillatorNode extends OneShotSource<ToneOscillatorNodeOptions> {\n\n\treadonly name = \"ToneOscillatorNode\";\n\n\t/**\n\t *  The oscillator\n\t */\n\tprivate _oscillator = this.context.createOscillator();\n\tprotected _internalChannels = [this._oscillator];\n\n\t/**\n\t *  The frequency of the oscillator\n\t */\n\treadonly frequency: Param<Frequency>;\n\n\t/**\n\t *  The detune of the oscillator\n\t */\n\treadonly detune: Param<Cents>;\n\n\tconstructor(options?: Partial<ToneOscillatorNodeOptions>);\n\tconstructor(\n\t\tfrequency: Frequency,\n\t\ttype: OscillatorType,\n\t);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tconnect(this._oscillator, this._gainNode);\n\n\t\tthis.type = options.type;\n\n\t\tthis.frequency = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._oscillator.frequency,\n\t\t\tunits : \"frequency\",\n\t\t\tvalue : options.frequency,\n\t\t});\n\n\t\tthis.detune = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._oscillator.detune,\n\t\t\tunits : \"cents\",\n\t\t\tvalue : options.detune,\n\t\t});\n\t}\n\n\tstatic getDefaults(): ToneOscillatorNodeOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\ttype: \"sine\" as OscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * Start the oscillator node at the given time\n\t * @param  time When to start the oscillator\n\t */\n\tstart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tthis._startGain(computedTime);\n\t\tthis._oscillator.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\t/**\n\t * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n\t * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n\t */\n\tsetPeriodicWave(periodicWave: PeriodicWave): this {\n\t\tthis._oscillator.setPeriodicWave(periodicWave);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n\t */\n\tget type(): OscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type: OscillatorType) {\n\t\tthis._oscillator.type = type;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this.state === \"started\") {\n\t\t\tthis.stop();\n\t\t}\n\t\tthis._oscillator.disconnect();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioRange, Cents, Degrees, Frequency, Radians, Time } from \"../../core/type/Units\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { ToneOscillatorConstructorOptions, ToneOscillatorInterface,\n\tToneOscillatorOptions, ToneOscillatorType } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./OscillatorNode\";\n\n/**\n *  Oscillator supports a number of features including\n *  phase rotation, multiple oscillator types (see Oscillator.type),\n *  and Transport syncing (see Oscillator.syncFrequency).\n *\n *  @param frequency Starting frequency\n *  @param type The oscillator type. Read more about type below.\n *  @example\n * //make and start a 440hz sine tone\n * var osc = new Oscillator(440, \"sine\").toDestination().start();\n */\nexport class Oscillator extends Source<ToneOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"Oscillator\";\n\n\t/**\n\t *  the main oscillator\n\t */\n\tprivate _oscillator: ToneOscillatorNode | null = null;\n\n\t/**\n\t *  The frequency control.\n\t */\n\tfrequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune control signal.\n\t */\n\tdetune: Signal<Cents>;\n\n\t/**\n\t *  the periodic wave\n\t */\n\tprivate _wave?: PeriodicWave;\n\n\t/**\n\t *  The partials of the oscillator\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t *  The number of partials to limit or extend the periodic wave by\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t *  the phase of the oscillator between 0 - 360\n\t */\n\tprivate _phase!: Radians;\n\n\t/**\n\t *  the type of the oscillator\n\t *  @type {string}\n\t *  @private\n\t */\n\tprivate _type;\n\n\tconstructor(options?: Partial<ToneOscillatorConstructorOptions>)\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal<Frequency>({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\tthis.detune = new Signal<Cents>({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, \"detune\");\n\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\t\tthis._type = options.type;\n\n\t\tif (options.partialCount && options.type !== \"custom\") {\n\t\t\tthis._type = this.baseType + options.partialCount.toString();\n\t\t}\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): ToneOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tpartialCount: 0,\n\t\t\tpartials: [],\n\t\t\tphase: 0,\n\t\t\ttype: \"sine\",\n\t\t}) as ToneOscillatorOptions;\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// new oscillator with previous values\n\t\tconst oscillator = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\tonended: () => this.onstop(this),\n\t\t});\n\t\tthis._oscillator = oscillator;\n\t\tif (this._wave) {\n\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t} else {\n\t\t\tthis._oscillator.type = this._type;\n\t\t}\n\t\t// connect the control signal to the oscillator frequency & detune\n\t\tthis._oscillator.connect(this.output);\n\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\tthis.detune.connect(this._oscillator.detune);\n\n\t\t// start the oscillator\n\t\tthis._oscillator.start(computedTime);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.stop(computedTime);\n\t\t}\n\t}\n\n\t/**\n\t * Restart the oscillator. Does not stop the oscillator, but instead\n\t * just cancels any scheduled 'stop' from being invoked.\n\t */\n\trestart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"restart\", computedTime);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.cancelStop();\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n\t *  will also affect the oscillators frequency.\n\t *  @example\n\t * Tone.Transport.bpm.value = 120;\n\t * osc.frequency.value = 440;\n\t * //the ration between the bpm and the frequency will be maintained\n\t * osc.syncFrequency();\n\t * Tone.Transport.bpm.value = 240;\n\t * // the frequency of the oscillator is doubled to 880\n\t */\n\tsyncFrequency(): this {\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Unsync the oscillator's frequency from the Transport.\n\t *  See Oscillator.syncFrequency\n\t */\n\tunsyncFrequency(): this {\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cache the periodic waves to avoid having to redo computations\n\t */\n\tprivate static _periodicWaveCache: Array<{\n\t\tpartials: number[];\n\t\tphase: number;\n\t\ttype: string;\n\t\tpartialCount: number;\n\t\treal: Float32Array,\n\t\timag: Float32Array,\n\t}> = [];\n\n\t/**\n\t * Get a cached periodic wave. Avoids having to recompute\n\t * the oscillator values when they have already been computed\n\t * with the same values.\n\t */\n\tprivate _getCachedPeriodicWave(): [Float32Array, Float32Array] | undefined {\n\t\tif (this._type === \"custom\") {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn  description.phase === this._phase &&\n\t\t\t\t\tdeepEquals(description.partials, this._partials);\n\t\t\t});\n\t\t\treturn oscProps && [oscProps.real, oscProps.imag];\n\t\t} else {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn  description.type === this._type &&\n\t\t\t\t\tdescription.phase === this._phase;\n\t\t\t});\n\t\t\tthis._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n\t\t\treturn oscProps && [oscProps.real, oscProps.imag];\n\t\t}\n\t}\n\n\t/* tslint:disable */\n\t/**\n\t * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of\n\t * setting the first x number of partials of the oscillator. For example: \"sine4\" would\n\t * set be the first 4 partials of the sine wave and \"triangle8\" would set the first\n\t * 8 partials of the triangle wave.\n\t * <br><br>\n\t * Uses PeriodicWave internally even for native types so that it can set the phase.\n\t * PeriodicWave equations are from the\n\t * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).\n\t *\n\t * @memberOf Oscillator#\n\t * @type {string}\n\t * @name type\n\t * @example\n\t * //set it to a square wave\n\t * osc.type = \"square\";\n\t * @example\n\t * //set the first 6 partials of a sawtooth wave\n\t * osc.type = \"sawtooth6\";\n\t */\n\t/* tslint:enable */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._type = type;\n\t\tconst isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\t\tif (this._phase === 0 && isBasicType) {\n\t\t\tthis._wave = undefined;\n\t\t\tthis._partialCount = 0;\n\t\t\t// just go with the basic approach\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\t// already tested that it's a basic type\n\t\t\t\tthis._oscillator.type = type as OscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// first check if the value is cached\n\t\t\tconst cache = this._getCachedPeriodicWave();\n\t\t\tif (isDefined(cache)) {\n\t\t\t\tconst [real, imag] = cache;\n\t\t\t\tthis._wave = this.context.createPeriodicWave(real, imag);\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst [real, imag] = this._getRealImaginary(type, this._phase);\n\t\t\t\tconst periodicWave = this.context.createPeriodicWave(real, imag);\n\t\t\t\tthis._wave = periodicWave;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t\t// set the cache\n\t\t\t\tOscillator._periodicWaveCache.push({\n\t\t\t\t\timag,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tpartials: this._partials,\n\t\t\t\t\tphase: this._phase,\n\t\t\t\t\treal,\n\t\t\t\t\ttype: this._type,\n\t\t\t\t});\n\t\t\t\tif (Oscillator._periodicWaveCache.length > 100) {\n\t\t\t\t\tOscillator._periodicWaveCache.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._type.replace(this.partialCount, \"\");\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tif (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n\t\t\tthis.type = baseType + this.partialCount as ToneOscillatorType;\n\t\t} else {\n\t\t\tthis.type = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t * @example\n\t * osc.type = 'sine'\n\t * osc.partialCount = 3\n\t * //is equivalent to\n\t * osc.type = 'sine3'\n\t */\n\tget partialCount(): number {\n\t\treturn this._partialCount;\n\t}\n\tset partialCount(p: number) {\n\t\tlet type = this._type;\n\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\t\tif (partial) {\n\t\t\ttype = partial[1];\n\t\t}\n\t\tif (this._type !== \"custom\") {\n\t\t\tif (p === 0) {\n\t\t\t\tthis.type = type;\n\t\t\t} else {\n\t\t\t\tthis.type = type + p.toString() as ToneOscillatorType;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Get the object's attributes. Given no arguments get\n\t *  will return all available object properties and their corresponding\n\t *  values.\n\t */\n\tget(): ToneOscillatorOptions {\n\t\tconst values = super.get();\n\t\tif (values.type !== \"custom\") {\n\t\t\tdelete values.partials;\n\t\t}\n\t\treturn values;\n\t}\n\n\t/**\n\t *  Returns the real and imaginary components based\n\t *  on the oscillator type.\n\t *  @returns [real: Float32Array, imaginary: Float32Array]\n\t *  @private\n\t */\n\tprivate _getRealImaginary(type: ToneOscillatorType, phase: Radians): Float32Array[] {\n\t\tconst fftSize = 4096;\n\t\tlet periodicWaveSize = fftSize / 2;\n\n\t\tconst real = new Float32Array(periodicWaveSize);\n\t\tconst imag = new Float32Array(periodicWaveSize);\n\n\t\tlet partialCount = 1;\n\t\tif (type === \"custom\") {\n\t\t\tpartialCount = this._partials.length + 1;\n\t\t\tthis._partialCount = this._partials.length;\n\t\t\tperiodicWaveSize = partialCount;\n\t\t\t// if the partial count is 0, don't bother doing any computation\n\t\t\tif (this._partials.length === 0 ) {\n\t\t\t\treturn [real, imag];\n\t\t\t}\n\t\t} else {\n\t\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\t\t\tif (partial) {\n\t\t\t\tpartialCount = parseInt(partial[2], 10) + 1;\n\t\t\t\tthis._partialCount = parseInt(partial[2], 10);\n\t\t\t\ttype = partial[1] as ToneOscillatorType;\n\t\t\t\tpartialCount = Math.max(partialCount, 2);\n\t\t\t\tperiodicWaveSize = partialCount;\n\t\t\t} else {\n\t\t\t\tthis._partialCount = 0;\n\t\t\t}\n\t\t\tthis._partials = [];\n\t\t}\n\n\t\t// tslint:disable: no-bitwise\n\t\tfor (let n = 1; n < periodicWaveSize; ++n) {\n\t\t\tconst piFactor = 2 / (n * Math.PI);\n\t\t\tlet b;\n\t\t\tswitch (type) {\n\t\t\t\tcase \"sine\":\n\t\t\t\t\tb = (n <= partialCount) ? 1 : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"square\":\n\t\t\t\t\tb = (n & 1) ? 2 * piFactor : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sawtooth\":\n\t\t\t\t\tb = piFactor * ((n & 1) ? 1 : -1);\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"triangle\":\n\t\t\t\t\tif (n & 1) {\n\t\t\t\t\t\tb = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"custom\":\n\t\t\t\t\tb = this._partials[n - 1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new TypeError(\"Oscillator: invalid type: \" + type);\n\t\t\t}\n\t\t\tif (b !== 0) {\n\t\t\t\treal[n] = -b * Math.sin(phase * n);\n\t\t\t\timag[n] = b * Math.cos(phase * n);\n\t\t\t} else {\n\t\t\t\treal[n] = 0;\n\t\t\t\timag[n] = 0;\n\t\t\t}\n\t\t}\n\t\treturn [real, imag];\n\t}\n\n\t/**\n\t *  Compute the inverse FFT for a given phase.\n\t */\n\tprivate _inverseFFT(real: Float32Array, imag: Float32Array, phase: Radians): number {\n\t\tlet sum = 0;\n\t\tconst len = real.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tsum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n\t\t}\n\t\treturn sum;\n\t}\n\n\t/**\n\t *  Returns the initial value of the oscillator.\n\t */\n\tprotected _getInitialValue(): AudioRange {\n\t\tconst [real, imag] = this._getRealImaginary(this._type, 0);\n\t\tlet maxValue = 0;\n\t\tconst twoPi = Math.PI * 2;\n\t\t// check for peaks in 8 places\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tmaxValue = Math.max(this._inverseFFT(real, imag, (i / 8) * twoPi), maxValue);\n\t\t}\n\t\treturn -this._inverseFFT(real, imag, this._phase) / maxValue;\n\t}\n\n\t/**\n\t * The partials of the waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tif (partials.length) {\n\t\t\tthis.type = \"custom\";\n\t\t}\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t * @example\n\t * osc.phase = 180; //flips the phase of the oscillator\n\t */\n\tget phase(): Degrees {\n\t\treturn this._phase * (180 / Math.PI);\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase * Math.PI / 180;\n\t\t// reset the type\n\t\tthis.type = this._type;\n\t}\n\n\t/**\n\t *  Dispose and disconnect.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._oscillator !== null) {\n\t\t\tthis._oscillator.dispose();\n\t\t}\n\t\tthis._wave = undefined;\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { optionsFromArguments } from \"..//core/util/Defaults\";\nimport { InputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connectSignal } from \"./Signal\";\n/**\n * A signal operator has an input and output and modifies the signal.\n */\nexport abstract class SignalOperator<Options extends ToneAudioNodeOptions> extends ToneAudioNode<Options> {\n\n\tconstructor(options?: Partial<Options>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(SignalOperator.getDefaults(), arguments, [\"context\"])));\n\t}\n\n\tconnect(destination: InputNode, outputNum: number = 0, inputNum: number = 0): this {\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction, isUndef } from \"../core/util/TypeCheck\";\nimport { Signal, SignalOptions } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n\ntype WaveShaperMappingFn = (value: number, index?: number) => number;\n\ntype WaveShaperMapping =  WaveShaperMappingFn | number[] | Float32Array;\n\ninterface WaveShaperOptions extends ToneAudioNodeOptions {\n\tmapping?: WaveShaperMapping;\n\tlength: number;\n\tcurve?: number[] | Float32Array;\n}\n\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n *  @param mapping The function used to define the values.\n *                 The mapping function should take two arguments:\n *                 the first is the value at the current position\n *                 and the second is the array position.\n *                 If the argument is an array, that array will be\n *                 set as the wave shaping function. The input\n *                 signal is an AudioRange [-1, 1] value and the output\n *                 signal can take on any numerical values.\n *\n *  @param bufferLen The length of the WaveShaperNode buffer.\n *  @example\n * var timesTwo = new WaveShaper(function(val){\n * \treturn val * 2;\n * }, 2048);\n *  @example\n * //a waveshaper can also be constructed with an array of values\n * var invert = new WaveShaper([1, -1]);\n */\nexport class WaveShaper extends SignalOperator<WaveShaperOptions> {\n\n\tname = \"WaveShaper\";\n\n\t/**\n\t *  the waveshaper node\n\t */\n\tprivate _shaper: WaveShaperNode = this.context.createWaveShaper();\n\n\t/**\n\t * The input to the waveshaper node.\n\t */\n\tinput = this._shaper;\n\n\t/**\n\t * The output from the waveshaper node\n\t */\n\toutput = this._shaper;\n\n\tconstructor(options?: Partial<WaveShaperOptions>);\n\tconstructor(mapping?: WaveShaperMapping , length?: number);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n\t\tconst options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n\n\t\tif (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n\t\t\tthis.curve = Float32Array.from(options.mapping);\n\t\t} else if (isFunction(options.mapping)) {\n\t\t\tthis.setMap(options.mapping, options.length);\n\t\t}\n\t}\n\n\tstatic getDefaults(): WaveShaperOptions {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tlength: 1024,\n\t\t});\n\t}\n\n\t/**\n\t *  Uses a mapping function to set the value of the curve.\n\t *  @param mapping The function used to define the values.\n\t *                 The mapping function take two arguments:\n\t *                 the first is the value at the current position\n\t *                 which goes from -1 to 1 over the number of elements\n\t *                 in the curve array. The second argument is the array position.\n\t * @example\n\t * //map the input signal from [-1, 1] to [0, 10]\n\t * shaper.setMap(function(val, index){\n\t * \treturn (val + 1) * 5;\n\t * })\n\t */\n\tsetMap(mapping: WaveShaperMappingFn, length: number = 1024): this {\n\t\tconst array = new Float32Array(length);\n\t\tfor (let i = 0, len = length; i < len; i++) {\n\t\t\tconst normalized = (i / (len - 1)) * 2 - 1;\n\t\t\tarray[i] = mapping(normalized, i);\n\t\t}\n\t\tthis.curve = array;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The array to set as the waveshaper curve. For linear curves\n\t * array length does not make much difference, but for complex curves\n\t * longer arrays will provide smoother interpolation.\n\t */\n\tget curve(): Float32Array | null {\n\t\treturn this._shaper.curve;\n\t}\n\n\tset curve(mapping: Float32Array | null) {\n\t\tthis._shaper.curve = mapping;\n\t}\n\n\t/**\n\t * Specifies what type of oversampling (if any) should be used when\n\t * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\n\tset oversample(oversampling: OverSampleType) {\n\t\tconst isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n\t\tthis.assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.disconnect();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1].\n * See {@link GainToAudio}.\n *\n * @example\n * var a2g = new AudioToGain();\n */\nexport class AudioToGain extends SignalOperator<ToneAudioNodeOptions> {\n\n\tname = \"AudioToGain\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: x => (x + 1) / 2,\n\t});\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The GainRange output [0, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal, SignalOptions } from \"./Signal\";\n\n/**\n * Multiply two incoming signals. Or, if a number is given in the constructor,\n * multiplies the incoming signal by that value.\n *\n * @param {number=} value Constant value to multiple\n * @example\n * const mult = new Multiply();\n * const sigA = new Tone.Signal(3);\n * const sigB = new Tone.Signal(4);\n * sigA.connect(mult);\n * sigB.connect(mult.factor);\n * //output of mult is 12.\n *  @example\n * const mult = new Multiply(10);\n * const sig = new Tone.Signal(2).connect(mult);\n * //the output of mult is 20.\n */\nexport class Multiply extends Signal<number> {\n\n\tname = \"Multiply\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection\n\t */\n\treadonly override = false;\n\n\t/**\n\t * the input gain node\n\t */\n\tprivate _mult: Gain = new Gain({ context : this.context });\n\n\t/**\n\t * The multiplcant input.\n\t */\n\tinput = this._mult;\n\n\t/**\n\t * The product of the input and {@link factor}\n\t */\n\toutput = this._mult;\n\n\t/**\n\t * The multiplication factor. Can be set directly or a signal can be connected to it.\n\t */\n\tfactor: Param<number>;\n\n\tconstructor(options?: Partial<SignalOptions<number>>);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(value?: number);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"])));\n\t\tconst options = optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis.factor = this._param = this._mult.gain as unknown as Param<number>;\n\t\tthis.factor.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): SignalOptions<number> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._mult.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Cents, Degrees, Frequency, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { AMConstructorOptions, AMOscillatorOptions,\n\tNonCustomOscillatorType, ToneOscillatorInterface,\n\tToneOscillatorType } from \"./OscillatorInterface\";\n\n/**\n * An amplitude modulated oscillator node. It is implemented with\n * two oscillators, one which modulators the other's amplitude\n * through a gain node.\n * ```\n *    +-------------+       +----------+\n *    | Carrier Osc +>------> GainNode |\n *    +-------------+       |          +--->Output\n *                      +---> gain     |\n * +---------------+    |   +----------+\n * | Modulator Osc +>---+\n * +---------------+\n * ```\n *\n * @param frequency The starting frequency of the oscillator.\n * @param type The type of the carrier oscillator.\n * @param modulationType The type of the modulator oscillator.\n * @example\n * //a sine oscillator frequency-modulated by a square wave\n * var fmOsc = new AMOscillator(\"Ab3\", \"sine\", \"square\").toDestination().start();\n */\nexport class AMOscillator extends Source<AMOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"AMOscillator\";\n\n\t/**\n\t *  The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\t/**\n\t *  The oscillator's frequency\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune control signal.\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t *  The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t *  convert the -1,1 output to 0,1\n\t */\n\tprivate _modulationScale = new AudioToGain({ context: this.context });\n\n\t/**\n\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t *  A harmonicity of 1 gives both oscillators the same frequency.\n\t *  Harmonicity = 2 means a change of an octave.\n\t *  @example\n\t * //pitch the modulator an octave below carrier\n\t * synth.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<Positive>;\n\n\t/**\n\t *  the node where the modulation happens\n\t */\n\tprivate _modulationNode = new Gain({\n\t\tcontext: this.context,\n\t});\n\n\tconstructor(options?: Partial<AMConstructorOptions>);\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier  = new Oscillator({\n\t\t\tcontext : this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\t\tthis.frequency = this._carrier.frequency,\n\t\tthis.detune = this._carrier.detune;\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext : this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t\tthis._carrier.chain(this._modulationNode, this.output);\n\n\t\treadOnly(this, [\"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): AMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Seconds): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Seconds): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\t/**\n\t *  restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the carrier oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t */\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\t/**\n\t * The partials of the carrier waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis._modulationScale.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { AudioRange, Cents, Degrees, Frequency, Positive, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { FMConstructorOptions, FMOscillatorOptions,\n\tNonCustomOscillatorType, ToneOscillatorInterface, ToneOscillatorType } from \"./OscillatorInterface\";\n\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @param frequency The starting frequency of the oscillator.\n * @param type The type of the carrier oscillator.\n * @param modulationType The type of the modulator oscillator.\n * @example\n * //a sine oscillator frequency-modulated by a square wave\n * var fmOsc = new FMOscillator(\"Ab3\", \"sine\", \"square\").toDestination().start();\n */\nexport class FMOscillator extends Source<FMOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"FMOscillator\";\n\n\t/**\n\t *  The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\t/**\n\t *  The oscillator's frequency\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune control signal.\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t *  The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t *  A harmonicity of 1 gives both oscillators the same frequency.\n\t *  Harmonicity = 2 means a change of an octave.\n\t *  @example\n\t * //pitch the modulator an octave below carrier\n\t * synth.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<Positive>;\n\n\t/**\n\t *  The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t *  ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t *  modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Signal<Positive>;\n\n\t/**\n\t *  the node where the modulation happens\n\t */\n\tprivate _modulationNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\tconstructor(options?: Partial<FMConstructorOptions>);\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier = new Oscillator({\n\t\t\tcontext : this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: 0,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\n\t\tthis.detune = this._carrier.detune;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext : this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\tthis.modulationIndex = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.modulationIndex,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t\tthis.detune.connect(this._modulator.detune);\n\n\t\treadOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): FMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationIndex: 2,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\t/**\n\t *  stop and restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the carrier oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t */\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\t/**\n\t * The partials of the carrier waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { AudioRange, Cents, Degrees, Frequency, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { WaveShaper } from \"../../signal/WaveShaper\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { PulseOscillatorOptions, ToneOscillatorInterface } from \"./OscillatorInterface\";\n\n/**\n * PulseOscillator is an oscillator with control over pulse width,\n * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is\n * a square wave.\n * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n * ```\n *    width = -0.25        width = 0.0          width = 0.25\n *\n *   +-----+            +-------+       +    +-------+     +-+\n *   |     |            |       |       |            |     |\n *   |     |            |       |       |            |     |\n * +-+     +-------+    +       +-------+            +-----+\n *\n *\n *    width = -0.5                              width = 0.5\n *\n *     +---+                                 +-------+   +---+\n *     |   |                                         |   |\n *     |   |                                         |   |\n * +---+   +-------+                                 +---+\n *\n *\n *    width = -0.75                             width = 0.75\n *\n *       +-+                                 +-------+ +-----+\n *       | |                                         | |\n *       | |                                         | |\n * +-----+ +-------+                                 +-+\n * ```\n * @param frequency The frequency of the oscillator\n * @param width The width of the pulse\n * @example\n * var pulse = new PulseOscillator(\"E5\", 0.4).toDestination().start();\n */\nexport class PulseOscillator extends Source<PulseOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"PulseOscillator\";\n\n\t/**\n\t *  The width of the pulse.\n\t */\n\twidth: Signal<AudioRange>;\n\n\t/**\n\t *  gate the width amount\n\t */\n\tprivate _widthGate: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t *  the sawtooth oscillator\n\t */\n\tprivate _sawtooth: Oscillator;\n\n\t/**\n\t *  The frequency control.\n\t */\n\tfrequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune in cents.\n\t */\n\tdetune: Signal<Cents>;\n\n\t/**\n\t *  Threshold the signal to turn it into a square\n\t */\n\tprivate _thresh = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: val => val <= 0 ? -1 : 1,\n\t});\n\n\tconstructor(options?: Partial<PulseOscillatorOptions>);\n\tconstructor(frequency?: Frequency, width?: AudioRange);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]));\n\t\tconst options = optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]);\n\n\t\tthis.width = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"audioRange\",\n\t\t\tvalue: options.width,\n\t\t});\n\n\t\tthis._sawtooth = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype : \"sawtooth\",\n\t\t});\n\t\tthis.frequency = this._sawtooth.frequency;\n\t\tthis.detune = this._sawtooth.detune;\n\n\t\t// connections\n\t\tthis._sawtooth.chain(this._thresh, this.output);\n\t\tthis.width.chain(this._widthGate, this._thresh);\n\t\treadOnly(this, [\"width\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PulseOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tphase: 0,\n\t\t\ttype: \"pulse\" as \"pulse\",\n\t\t\twidth: 0.2,\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._sawtooth.start(time);\n\t\tthis._widthGate.gain.setValueAtTime(1, time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._sawtooth.stop(time);\n\t\t// the width is still connected to the output.\n\t\t// that needs to be stopped also\n\t\tthis._widthGate.gain.cancelScheduledValues(time);\n\t\tthis._widthGate.gain.setValueAtTime(0, time);\n\t}\n\n\t/**\n\t *  Restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._sawtooth.restart(computedTime);\n\t\tthis._widthGate.gain.cancelScheduledValues(computedTime);\n\t\tthis._widthGate.gain.setValueAtTime(1, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._sawtooth.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._sawtooth.phase = phase;\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pulse\".\n\t */\n\tget type(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pulse\".\n\t */\n\tget baseType(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t *  Clean up method.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sawtooth.dispose();\n\t\tthis.width.dispose();\n\t\tthis._widthGate.dispose();\n\t\tthis._thresh.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioRange, Cents, Degrees, Frequency, Positive, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { FatConstructorOptions, FatOscillatorOptions,\n\tToneOscillatorInterface, ToneOscillatorType } from \"./OscillatorInterface\";\n\n/**\n *  FatOscillator is an array of oscillators with detune spread between the oscillators\n *  @param frequency The oscillator's frequency.\n *  @param type The type of the oscillator.\n *  @param spread The detune spread between the oscillators.\n *  @example\n * var fatOsc = new FatOscillator(\"Ab3\", \"sine\", 40).toDestination().start();\n */\nexport class FatOscillator extends Source<FatOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"FatOscillator\";\n\n\t/**\n\t *  The oscillator's frequency\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune control signal.\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t *  The array of oscillators\n\t */\n\tprivate _oscillators: Oscillator[] = [];\n\n\t/**\n\t *  The total spread of the oscillators\n\t */\n\tprivate _spread: Cents;\n\n\t/**\n\t *  The type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t *  The phase of the oscillators\n\t */\n\tprivate _phase: Degrees;\n\n\t/**\n\t *  The partials array\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t *  The number of partials to use\n\t */\n\tprivate _partialCount: number;\n\n\tconstructor(options?: Partial<FatConstructorOptions>);\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n\t\tconst options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\tthis._spread = options.spread;\n\t\tthis._type = options.type;\n\t\tthis._phase = options.phase;\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\n\t\t// set the count initially\n\t\tthis.count = options.count;\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): FatOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tcount : 3,\n\t\t\tspread : 20,\n\t\t\ttype : \"sawtooth\",\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.start(time));\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.stop(time));\n\t}\n\n\t/**\n\t *  restart the oscillator\n\t */\n\trestart(time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.restart(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over all of the oscillators\n\t */\n\tprivate _forEach(iterator: (osc: Oscillator, index: number) => void): void {\n\t\tfor (let i = 0; i < this._oscillators.length; i++) {\n\t\t\titerator(this._oscillators[i], i);\n\t\t}\n\t}\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\n\tset type(type: ToneOscillatorType) {\n\t\tthis._type = type;\n\t\tthis._forEach(osc => osc.type = type);\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents.\n\t */\n\tget spread(): Cents {\n\t\treturn this._spread;\n\t}\n\n\tset spread(spread: Cents) {\n\t\tthis._spread = spread;\n\t\tif (this._oscillators.length > 1) {\n\t\t\tconst start = -spread / 2;\n\t\t\tconst step = spread / (this._oscillators.length - 1);\n\t\t\tthis._forEach((osc, i) => osc.detune.value = start + step * i);\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators. Should be an integer greater than 1.\n\t */\n\tget count(): number {\n\t\treturn this._oscillators.length;\n\t}\n\tset count(count: number) {\n\t\tcount = Math.max(count, 1);\n\t\tif (this._oscillators.length !== count) {\n\t\t\t// dispose the previous oscillators\n\t\t\tthis._forEach(osc => osc.dispose());\n\t\t\tthis._oscillators = [];\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst osc = new Oscillator({\n\t\t\t\t\tcontext : this.context,\n\t\t\t\t\tonstop: i === 0 ? () => this.onstop(this) : noOp,\n\t\t\t\t});\n\t\t\t\tif (this.type === \"custom\") {\n\t\t\t\t\tosc.partials = this._partials;\n\t\t\t\t} else {\n\t\t\t\t\tosc.type = this._type;\n\t\t\t\t}\n\t\t\t\tosc.partialCount = this._partialCount;\n\t\t\t\tosc.phase = this._phase + (i / count) * 360;\n\t\t\t\tosc.volume.value = -6 - count * 1.1;\n\t\t\t\tthis.frequency.connect(osc.frequency);\n\t\t\t\tthis.detune.connect(osc.detune);\n\t\t\t\tosc.connect(this.output);\n\t\t\t\tthis._oscillators[i] = osc;\n\t\t\t}\n\t\t\t// set the spread\n\t\t\tthis.spread = this._spread;\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._forEach(osc => osc.start());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase;\n\t\tthis._forEach(osc => osc.phase = phase);\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._oscillators[0].baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._forEach(osc => osc.baseType = baseType);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\t/**\n\t * The partials of the carrier waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @memberOf FatOscillator#\n\t * @type {Array}\n\t * @name partials\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillators[0].partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tif (partials.length) {\n\t\t\tthis._type = \"custom\";\n\t\t\tthis._forEach(osc => osc.partials = partials);\n\t\t}\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t * @memberOf FatOscillator#\n\t * @type {Number}\n\t * @name partialCount\n\t */\n\tget partialCount(): number {\n\t\treturn this._oscillators[0].partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._partialCount = partialCount;\n\t\tthis._forEach(osc => osc.partialCount = partialCount);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._forEach(osc => osc.dispose());\n\t\treturn this;\n\t}\n}\n","import { Cents, Degrees, Frequency, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { PWMOscillatorOptions, ToneOscillatorInterface } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\n\n/**\n * PWMOscillator modulates the width of a Tone.PulseOscillator\n * at the modulationFrequency. This has the effect of continuously\n * changing the timbre of the oscillator by altering the harmonics\n * generated.\n *\n * @param {Frequency} frequency The starting frequency of the oscillator.\n * @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse.\n * @example\n *  var pwm = new PWMOscillator(\"Ab3\", 0.3).toDestination().start();\n */\nexport class PWMOscillator extends Source<PWMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name = \"PWMOscillator\";\n\n\treadonly sourceType = \"pwm\";\n\n\t/**\n\t *  the pulse oscillator\n\t */\n\tprivate _pulse: PulseOscillator;\n\t/**\n\t *  the modulator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t *  Scale the oscillator so it doesn't go silent\n\t *  at the extreme values.\n\t */\n\tprivate _scale: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: 2,\n\t});\n\n\t/**\n\t *  The frequency control.\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune of the oscillator.\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t *  The modulation rate of the oscillator.\n\t */\n\treadonly modulationFrequency: Signal<Frequency>;\n\n\tconstructor(options?: Partial<PWMOscillatorOptions>);\n\tconstructor(frequency?: Frequency, modulationFrequency?: Frequency);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]));\n\t\tconst options = optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]);\n\n\t\tthis._pulse = new PulseOscillator({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.modulationFrequency,\n\t\t});\n\t\t// change the pulse oscillator type\n\t\t// @ts-ignore\n\t\tthis._pulse._sawtooth.type = \"sine\";\n\n\t\tthis.modulationFrequency  = this._pulse.frequency;\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t});\n\n\t\tthis.frequency = this._modulator.frequency;\n\t\tthis.detune = this._modulator.detune;\n\n\t\t// connections\n\t\tthis._modulator.chain(this._scale, this._pulse.width);\n\t\tthis._pulse.connect(this.output);\n\t\treadOnly(this, [\"modulationFrequency\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PWMOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tmodulationFrequency: 0.4,\n\t\t\tphase: 0,\n\t\t\ttype: \"pwm\" as \"pwm\",\n\t\t});\n\t}\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.start(time);\n\t\tthis._pulse.start(time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.stop(time);\n\t\tthis._pulse.stop(time);\n\t}\n\n\t/**\n\t *  restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._pulse.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pwm\".\n\t */\n\tget type(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pwm\".\n\t */\n\tget baseType(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._modulator.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._modulator.phase = phase;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._pulse.dispose();\n\t\tthis._scale.dispose();\n\t\tthis._modulator.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioRange, Cents, Degrees, Frequency, Positive, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments  } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport { OmniOscillatorConstructorOptions,\n\tOmniOscillatorOptions, OmniOscillatorType,\n\tToneOscillatorInterface, ToneOscillatorType } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\n\n/**\n * All of the oscillator types that OmniOscillator can take on\n */\ntype AnyOscillator = Oscillator | PWMOscillator | PulseOscillator | FatOscillator | AMOscillator | FMOscillator;\n\n/**\n * The constructor of each of the OmniOscillator types\n */\ntype TypeofAnyOscillator = typeof Oscillator | typeof PWMOscillator |\n\ttypeof PulseOscillator | typeof FatOscillator |\n\ttypeof AMOscillator | typeof FMOscillator;\n\n/**\n * All of the Oscillator constructor types mapped to their name.\n */\ninterface OmniOscillatorSource {\n\t\"fm\": FMOscillator;\n\t\"am\": AMOscillator;\n\t\"pwm\": PWMOscillator;\n\t\"pulse\": PulseOscillator;\n\t\"oscillator\": Oscillator;\n\t\"fat\": FatOscillator;\n}\n\n/**\n * The available oscillator types.\n */\nexport type OmniOscSourceType = keyof OmniOscillatorSource;\n\n// Conditional Types\ntype IsAmOrFmOscillator<Osc, Ret> = Osc extends AMOscillator ? Ret : Osc extends FMOscillator ? Ret : undefined;\ntype IsFatOscillator<Osc, Ret> = Osc extends FatOscillator ? Ret : undefined;\ntype IsPWMOscillator<Osc, Ret> = Osc extends PWMOscillator ? Ret : undefined;\ntype IsPulseOscillator<Osc, Ret> = Osc extends PulseOscillator ? Ret : undefined;\ntype IsFMOscillator<Osc, Ret> = Osc extends FMOscillator ? Ret : undefined;\n\ntype AnyOscillatorConstructor = new (...args: any[]) => AnyOscillator;\n\n// tslint:disable-next-line: variable-name\nconst OmniOscillatorSourceMap: {\n\t[key in OmniOscSourceType] : AnyOscillatorConstructor\n} = {\n\tam: AMOscillator,\n\tfat: FatOscillator,\n\tfm: FMOscillator,\n\toscillator: Oscillator,\n\tpulse: PulseOscillator,\n\tpwm: PWMOscillator,\n};\n\n/**\n * OmniOscillator aggregates Tone.Oscillator, Tone.PulseOscillator,\n * Tone.PWMOscillator, Tone.FMOscillator, Tone.AMOscillator, and Tone.FatOscillator\n * into one class. The oscillator class can be changed by setting the `type`.\n * `omniOsc.type = \"pwm\"` will set it to the Tone.PWMOscillator. Prefixing\n * any of the basic types (\"sine\", \"square4\", etc.) with \"fm\", \"am\", or \"fat\"\n * will use the FMOscillator, AMOscillator or FatOscillator respectively.\n * For example: `omniOsc.type = \"fatsawtooth\"` will create set the oscillator\n * to a FatOscillator of type \"sawtooth\".\n *\n * @param frequency The initial frequency of the oscillator.\n * @param type The type of the oscillator.\n * @example\n * var omniOsc = new OmniOscillator(\"C#4\", \"pwm\");\n */\nexport class OmniOscillator<OscType extends AnyOscillator>\nextends Source<OmniOscillatorConstructorOptions>\nimplements Omit<ToneOscillatorInterface, \"type\"> {\n\n\tname = \"OmniOscillator\";\n\n\t/**\n\t *  The frequency control.\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune control.\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t * The oscillator that can switch types\n\t */\n\tprivate _oscillator!: AnyOscillator;\n\n\t/**\n\t *  the type of the oscillator source\n\t */\n\tprivate _sourceType!: OmniOscSourceType;\n\n\tconstructor(options?: Partial<OmniOscillatorConstructorOptions>);\n\tconstructor(frequency?: Frequency, type?: OmniOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\n\t\t// set the options\n\t\tthis.set(options);\n\t}\n\n\tstatic getDefaults(): OmniOscillatorOptions {\n\t\treturn Object.assign(\n\t\t\tOscillator.getDefaults(),\n\t\t\tFMOscillator.getDefaults(),\n\t\t\tAMOscillator.getDefaults(),\n\t\t\tFatOscillator.getDefaults(),\n\t\t\tPulseOscillator.getDefaults(),\n\t\t\tPWMOscillator.getDefaults(),\n\t\t);\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._oscillator.start(time);\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\trestart(time?: Time): this {\n\t\tthis._oscillator.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n\t * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n\t * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n\t * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n\t * when it's not.\n\t * @example\n\t * omniOsc.type = \"pwm\";\n\t * //modulationFrequency is parameter which is available\n\t * //only when the type is \"pwm\".\n\t * omniOsc.modulationFrequency.value = 0.5;\n\t * @example\n\t * //an square wave frequency modulated by a sawtooth\n\t * omniOsc.type = \"fmsquare\";\n\t * omniOsc.modulationType = \"sawtooth\";\n\t */\n\tget type(): OmniOscillatorType {\n\t\tlet prefix = \"\";\n\t\tif ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n\t\t\tprefix = this._sourceType;\n\t\t}\n\t\treturn prefix + this._oscillator.type as OmniOscillatorType;\n\t}\n\tset type(type) {\n\t\tif (type.substr(0, 2) === \"fm\") {\n\t\t\tthis._createNewOscillator(\"fm\");\n\t\t\tthis._oscillator = this._oscillator as FMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 2) === \"am\") {\n\t\t\tthis._createNewOscillator(\"am\");\n\t\t\tthis._oscillator = this._oscillator as AMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2)  as ToneOscillatorType;\n\t\t} else if (type.substr(0, 3) === \"fat\") {\n\t\t\tthis._createNewOscillator(\"fat\");\n\t\t\tthis._oscillator = this._oscillator as FatOscillator;\n\t\t\tthis._oscillator.type = type.substr(3)  as ToneOscillatorType;\n\t\t} else if (type === \"pwm\") {\n\t\t\tthis._createNewOscillator(\"pwm\");\n\t\t\tthis._oscillator = this._oscillator as PWMOscillator;\n\t\t} else if (type === \"pulse\") {\n\t\t\tthis._createNewOscillator(\"pulse\");\n\t\t} else {\n\t\t\tthis._createNewOscillator(\"oscillator\");\n\t\t\tthis._oscillator = this._oscillator as Oscillator;\n\t\t\tthis._oscillator.type = (type as ToneOscillatorType);\n\t\t}\n\t}\n\n\t/**\n\t * The partials of the waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partials = partials;\n\t\t}\n\t}\n\n\t/**\n\t * The partial count of the oscillator. This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * @example\n\t * //set the maximum number of partials\n\t * osc.partialCount = 0;\n\t */\n\tget partialCount(): number {\n\t\treturn this._oscillator.partialCount;\n\t}\n\tset partialCount(partialCount) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partialCount = partialCount;\n\t\t}\n\t}\n\n\t/**\n\t * Set the parameters at once. Either pass in an\n\t * object mapping parameters to values, or to set a\n\t * single parameter, by passing in a string and value.\n\t * The last argument is an optional ramp time which\n\t * will ramp any signal values to their destination value\n\t * over the duration of the rampTime.\n\t * @param  params\n\t * @example\n\t * //set values using an object\n\t * filter.set({\n\t * \t\"frequency\" : 300,\n\t * \t\"type\" : \"highpass\"\n\t * });\n\t */\n\tset(props: Partial<OmniOscillatorConstructorOptions>): this {\n\t\t// make sure the type is set first\n\t\tif (Reflect.has(props, \"type\") && props.type) {\n\t\t\tthis.type = props.type;\n\t\t\t// delete props.type;\n\t\t}\n\t\t// then set the rest\n\t\tsuper.set(props);\n\t\treturn this;\n\t}\n\n\tget(): OmniOscillatorConstructorOptions {\n\t\tconst options = this._oscillator.get();\n\t\t// @ts-ignore\n\t\toptions.type = this.type;\n\t\treturn options as OmniOscillatorOptions;\n\t}\n\n\t/**\n\t *  connect the oscillator to the frequency and detune signals\n\t */\n\tprivate _createNewOscillator(oscType: OmniOscSourceType): void {\n\t\tif (oscType !== this._sourceType) {\n\t\t\tthis._sourceType = oscType;\n\t\t\t// tslint:disable-next-line: variable-name\n\t\t\tconst OscConstructor = OmniOscillatorSourceMap[oscType];\n\t\t\t// short delay to avoid clicks on the change\n\t\t\tconst now = this.now();\n\t\t\tif (this._oscillator) {\n\t\t\t\tconst oldOsc = this._oscillator;\n\t\t\t\toldOsc.stop(now);\n\t\t\t\t// dispose the old one\n\t\t\t\tthis.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n\t\t\t}\n\t\t\tthis._oscillator = new OscConstructor({\n\t\t\t\tcontext : this.context,\n\t\t\t});\n\t\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\t\tthis.detune.connect(this._oscillator.detune);\n\t\t\tthis._oscillator.connect(this.output);\n\t\t\tthis._oscillator.onstop = () => this.onstop(this);\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._oscillator.start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t}\n\n\t/**\n\t * The source type of the oscillator.\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"fmsquare\");\n\t * omniOsc.sourceType // 'fm'\n\t */\n\tget sourceType(): OmniOscSourceType {\n\t\treturn this._sourceType;\n\t}\n\tset sourceType(sType) {\n\t\t// the basetype defaults to sine\n\t\tlet baseType = \"sine\";\n\t\tif (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n\t\t\tbaseType = this._oscillator.type;\n\t\t}\n\n\t\t// set the type\n\t\tif (sType === \"fm\") {\n\t\t\tthis.type = \"fm\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"am\") {\n\t\t\tthis.type = \"am\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"fat\") {\n\t\t\tthis.type = \"fat\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"oscillator\") {\n\t\t\tthis.type = baseType as OmniOscillatorType;\n\t\t} else if (sType === \"pulse\") {\n\t\t\tthis.type = \"pulse\";\n\t\t} else if (sType === \"pwm\") {\n\t\t\tthis.type = \"pwm\";\n\t\t}\n\t}\n\n\tprivate _getOscType<SourceType extends OmniOscSourceType>(\n\t\tosc: AnyOscillator,\n\t\tsourceType: SourceType,\n\t): osc is OmniOscillatorSource[SourceType] {\n\t\treturn osc instanceof OmniOscillatorSourceMap[sourceType];\n\t}\n\n\t/**\n\t * The base type of the oscillator.\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"fmsquare4\");\n\t * omniOsc.sourceType // 'fm'\n\t * omniOsc.baseType //'square'\n\t * omniOsc.partialCount //4\n\t */\n\tget baseType(): OscillatorType | \"pwm\" | \"pulse\" {\n\t\treturn this._oscillator.baseType;\n\t}\n\tset baseType(baseType) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") &&\n\t\t\t!this._getOscType(this._oscillator, \"pwm\") &&\n\t\t\tbaseType !== \"pulse\" && baseType !== \"pwm\") {\n\t\t\tthis._oscillator.baseType = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * The width of the oscillator when sourceType === \"pulse\".\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"pulse\");\n\t * //can access the width attribute only if type === \"pulse\"\n\t * omniOsc.width.value = 0.2;\n\t */\n\tget width(): IsPulseOscillator<OscType, Signal<AudioRange>> {\n\t\tif (this._getOscType(this._oscillator, \"pulse\")) {\n\t\t\treturn this._oscillator.width as IsPulseOscillator<OscType, Signal<AudioRange>> ;\n\t\t} else {\n\t\t\treturn undefined as IsPulseOscillator<OscType, Signal<AudioRange>> ;\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators, when sourceType === \"fat\".\n\t */\n\tget count(): IsFatOscillator<OscType, number> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.count as IsFatOscillator<OscType, number>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, number>;\n\t\t}\n\t}\n\tset count(count) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n\t\t\tthis._oscillator.count = count;\n\t\t}\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents. See Tone.FatOscillator\n\t * for more info.\n\t */\n\tget spread(): IsFatOscillator<OscType, Cents> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.spread as IsFatOscillator<OscType, Cents>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, Cents>;\n\t\t}\n\t}\n\tset spread(spread) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n\t\t\tthis._oscillator.spread = spread;\n\t\t}\n\t}\n\n\t/**\n\t * The type of the modulator oscillator. Only if the oscillator\n\t * is set to \"am\" or \"fm\" types. see. Tone.AMOscillator or Tone.FMOscillator\n\t * for more info.\n\t */\n\tget modulationType(): IsAmOrFmOscillator<OscType, ToneOscillatorType> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.modulationType as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t}\n\t}\n\tset modulationType(mType) {\n\t\tif ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n\t\t\tthis._oscillator.modulationType = mType;\n\t\t}\n\t}\n\n\t/**\n\t * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t * See Tone.FMOscillator for more info.\n\t */\n\tget modulationIndex(): IsFMOscillator<OscType, Signal<Positive>> {\n\t\tif (this._getOscType(this._oscillator, \"fm\")) {\n\t\t\treturn this._oscillator.modulationIndex as IsFMOscillator<OscType, Signal<Positive>>;\n\t\t} else {\n\t\t\treturn undefined as IsFMOscillator<OscType, Signal<Positive>>;\n\t\t}\n\t}\n\n\t/**\n\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t *  A harmonicity of 1 gives both oscillators the same frequency.\n\t *  Harmonicity = 2 means a change of an octave. See Tone.AMOscillator or Tone.FMOscillator\n\t *  for more info.\n\t */\n\tget harmonicity(): IsAmOrFmOscillator<OscType, Signal<Positive>> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.harmonicity as IsAmOrFmOscillator<OscType, Signal<Positive>>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, Signal<Positive>>;\n\t\t}\n\t}\n\n\t/**\n\t * The modulationFrequency Signal of the oscillator\n\t * (only if the oscillator type is set to pwm). See\n\t * Tone.PWMOscillator for more info.\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"pwm\");\n\t * //can access the modulationFrequency attribute only if type === \"pwm\"\n\t * omniOsc.modulationFrequency.value = 0.2;\n\t */\n\tget modulationFrequency(): IsPWMOscillator<OscType, Signal<Frequency>> {\n\t\tif (this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\treturn this._oscillator.modulationFrequency as IsPWMOscillator<OscType, Signal<Frequency>>;\n\t\t} else {\n\t\t\treturn undefined as IsPWMOscillator<OscType, Signal<Frequency>>;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._oscillator.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { Positive, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isUndef } from \"../../core/util/TypeCheck\";\nimport { Source, SourceOptions } from \"../Source\";\nimport { ToneBufferSource } from \"./BufferSource\";\n\ninterface PlayerOptions extends SourceOptions {\n\tonload: () => void;\n\tplaybackRate: Positive;\n\tloop: boolean;\n\tautostart: boolean;\n\tloopStart: Time;\n\tloopEnd: Time;\n\treverse: boolean;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\turl?: ToneAudioBuffer | string | AudioBuffer;\n}\n\n/**\n * Player is an audio file player with start, loop, and stop functions.\n *\n * @param url Either the AudioBuffer or the url from which to load the AudioBuffer\n * @param onload The function to invoke when the buffer is loaded.\n *                            Recommended to use Tone.Buffer.on('load') instead.\n * @example\n * var player = new Player(\"./path/to/sample.mp3\").toDestination();\n * //play as soon as the buffer is loaded\n * player.autostart = true;\n */\nexport class Player extends Source<PlayerOptions> {\n\n\tname = \"Player\";\n\n\t/**\n\t * If the file should play as soon\n\t * as the buffer is loaded.\n\t * @example\n\t * //will play as soon as it's loaded\n\t * var player = new Player({\n\t * \t\"url\" : \"./path/to/sample.mp3\",\n\t * \t\"autostart\" : true,\n\t * }).toDestination();\n\t */\n\tautostart: boolean;\n\n\t/**\n\t *  The buffer\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t *  if the buffer should loop once it's over\n\t */\n\tprivate _loop: boolean;\n\n\t/**\n\t *  if 'loop' is true, the loop will start at this position\n\t */\n\tprivate _loopStart: Time;\n\n\t/**\n\t *  if 'loop' is true, the loop will end at this position\n\t */\n\tprivate _loopEnd: Time;\n\n\t/**\n\t *  the playback rate\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t *  All of the active buffer source nodes\n\t */\n\tprivate _activeSources: Set<ToneBufferSource> = new Set();\n\n\t/**\n\t *  The fadeIn time of the amplitude envelope.\n\t */\n\tfadeIn: Time;\n\n\t/**\n\t *  The fadeOut time of the amplitude envelope.\n\t */\n\tfadeOut: Time;\n\n\tconstructor(options?: Partial<PlayerOptions>);\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis._buffer = new ToneAudioBuffer({\n\t\t\tonload: this._onload.bind(this, options.onload),\n\t\t\treverse: options.reverse,\n\t\t\turl: options.url,\n\t\t});\n\t\tthis.autostart = options.autostart;\n\t\tthis._loop = options.loop;\n\t\tthis._loopStart = options.loopStart;\n\t\tthis._loopEnd = options.loopEnd;\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.fadeIn = options.fadeIn;\n\t\tthis.fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): PlayerOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tautostart : false,\n\t\t\tfadeIn : 0,\n\t\t\tfadeOut : 0,\n\t\t\tloop : false,\n\t\t\tloopEnd : 0,\n\t\t\tloopStart : 0,\n\t\t\tonload : noOp,\n\t\t\tplaybackRate : 1,\n\t\t\treverse : false,\n\t\t});\n\t}\n\n\t/**\n\t * Load the audio file as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * Note: this does not need to be called if a url\n\t * was passed in to the constructor. Only use this\n\t * if you want to manually load a new url.\n\t * @param url The url of the buffer to load. Filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tawait this._buffer.load(url);\n\t\tthis._onload();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal callback when the buffer is loaded.\n\t */\n\tprivate _onload(callback: () => void = noOp): void {\n\t\tcallback();\n\t\tif (this.autostart) {\n\t\t\tthis.start();\n\t\t}\n\t}\n\n\t/**\n\t * Internal callback when the buffer is done playing.\n\t */\n\tprivate _onSourceEnd(source: ToneBufferSource): void {\n\t\t// invoke the onstop function\n\t\tthis.onstop(this);\n\n\t\t// delete the source from the active sources\n\t\tthis._activeSources.delete(source);\n\t\tif (this._activeSources.size === 0 && !this._synced) {\n\t\t\tthis._state.setStateAtTime(\"stopped\", this.now());\n\t\t}\n\t}\n\n\t/**\n\t *  Play the buffer at the given startTime. Optionally add an offset\n\t *  and/or duration which will play the buffer from a position\n\t *  within the buffer for the given duration.\n\t *\n\t *  @param  time When the player should start.\n\t *  @param  offset The offset from the beginning of the sample\n\t *                                 to start at.\n\t *  @param  duration How long the sample should play. If no duration is given, it will default to the full length\n\t *                   of the sample (minus any offset)\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tsuper.start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Internal start method\n\t */\n\tprotected _start(startTime?: Time, offset?: Time, duration?: Time): void {\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this._loop) {\n\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\n\t\t// compute the values in seconds\n\t\tlet comptuedOffset = this.toSeconds(offset);\n\n\t\t// if it's synced, it should factor in the playback rate for computing the offset\n\t\tif (this._synced) {\n\t\t\tcomptuedOffset *= this._playbackRate;\n\t\t}\n\n\t\t// compute the duration which is either the passed in duration of the buffer.duration - offset\n\t\tconst origDuration = duration;\n\t\tduration = defaultArg(duration, Math.max(this._buffer.duration - comptuedOffset, 0));\n\t\tlet computedDuration = this.toSeconds(duration);\n\n\t\t// scale it by the playback rate\n\t\tcomputedDuration = computedDuration / this._playbackRate;\n\n\t\t// get the start time\n\t\tstartTime = this.toSeconds(startTime);\n\n\t\t// make the source\n\t\tconst source = new ToneBufferSource({\n\t\t\tbuffer : this._buffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn : this.fadeIn,\n\t\t\tfadeOut : this.fadeOut,\n\t\t\tloop : this._loop,\n\t\t\tloopEnd : this._loopEnd,\n\t\t\tloopStart : this._loopStart,\n\t\t\tonended : this._onSourceEnd.bind(this),\n\t\t\tplaybackRate : this._playbackRate,\n\t\t}).connect(this.output);\n\n\t\t// set the looping properties\n\t\tif (!this._loop && !this._synced) {\n\t\t\t// if it's not looping, set the state change at the end of the sample\n\t\t\tthis._state.setStateAtTime(\"stopped\", startTime + computedDuration, {\n\t\t\t\timplicitEnd: true,\n\t\t\t});\n\t\t}\n\n\t\t// add it to the array of active sources\n\t\tthis._activeSources.add(source);\n\n\t\t// start it\n\t\tif (this._loop && isUndef(origDuration)) {\n\t\t\tsource.start(startTime, comptuedOffset);\n\t\t} else {\n\t\t\t// subtract the fade out time\n\t\t\tsource.start(startTime, comptuedOffset, computedDuration - this.toSeconds(this.fadeOut));\n\t\t}\n\t}\n\n\t/**\n\t *  Stop playback.\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(source => source.stop(computedTime));\n\t}\n\n\t/**\n\t * Stop and then restart the player from the beginning (or offset)\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given,\n\t * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n\t */\n\trestart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tthis._stop(time);\n\t\tthis._start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Seek to a specific time in the player's buffer. If the\n\t *  source is no longer playing at that time, it will stop.\n\t *  If you seek to a time that\n\t *  @param {Time} offset The time to seek to.\n\t *  @param {Time=} time The time for the seek event to occur.\n\t *  @return {Player} this\n\t *  @example\n\t * source.start(0.2);\n\t * source.stop(0.4);\n\t */\n\tseek(offset: Time, when?: Time): this {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tconst comptuedOffset = this.toSeconds(offset);\n\t\t\t// if it's currently playing, stop it\n\t\t\tthis._stop(computedTime);\n\t\t\t// restart it at the given time\n\t\t\tthis._start(computedTime, comptuedOffset);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the loop start and end. Will only loop if loop is set to true.\n\t * @param loopStart The loop end time\n\t * @param loopEnd The loop end time\n\t * @example\n\t * //loop 0.1 seconds of the file.\n\t * player.setLoopPoints(0.2, 0.3);\n\t * player.loop = true;\n\t */\n\tsetLoopPoints(loopStart: Time, loopEnd: Time): this {\n\t\tthis.loopStart = loopStart;\n\t\tthis.loopEnd = loopEnd;\n\t\treturn this;\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = loopStart;\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopStart = loopStart;\n\t\t});\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = loopEnd;\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopEnd = loopEnd;\n\t\t});\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\t// if no change, do nothing\n\t\tif (this._loop === loop) {\n\t\t\treturn;\n\t\t}\n\t\tthis._loop = loop;\n\t\t// set the loop of all of the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loop = loop;\n\t\t});\n\t\tif (loop) {\n\t\t\t// remove the next stopEvent\n\t\t\tconst stopEvent = this._state.getNextState(\"stopped\", this.now());\n\t\t\tif (stopEvent) {\n\t\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The playback speed. 1 is normal speed. This is not a signal because\n\t * Safari and iOS currently don't support playbackRate as a signal.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tconst now = this.now();\n\n\t\t// cancel the stop event since it's at a different time now\n\t\tconst stopEvent = this._state.getNextState(\"stopped\", now);\n\t\tif (stopEvent && stopEvent.implicitEnd) {\n\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\tthis._activeSources.forEach(source => source.cancelStop());\n\t\t}\n\n\t\t// set all the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.playbackRate.setValueAtTime(rate, now);\n\t\t});\n\t}\n\n\t/**\n\t * The direction the buffer should play in\n\t */\n\tget reverse(): boolean {\n\t\treturn this._buffer.reverse;\n\t}\n\tset reverse(rev) {\n\t\tthis._buffer.reverse = rev;\n\t}\n\n\t/**\n\t * If the buffer is loaded\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffer.loaded;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\t// disconnect all of the players\n\t\tthis._activeSources.forEach(source => source.dispose());\n\t\tthis._activeSources.clear();\n\t\tthis._buffer.dispose();\n\t\treturn this;\n\t}\n}\n","import { connectSeries } from \"../core/Connect\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal, SignalOptions } from \"./Signal\";\n\n/**\n * Add a signal and a number or two signals. When no value is\n * passed into the constructor, Tone.Add will sum input and `addend`\n * If a value is passed into the constructor, the it will be added to the input.\n *\n * @param value If no value is provided, Tone.Add will sum the first  and second inputs.\n * @example\n * var signal = new Signal(2);\n * var add = new Add(2);\n * signal.connect(add);\n * //the output of add equals 4\n * @example\n * //if constructed with no arguments\n * //it will add the first and second inputs\n * var add = new Add();\n * var sig0 = new Signal(3).connect(add);\n * var sig1 = new Signal(4).connect(add.addend);\n * //the output of add equals 7.\n */\nexport class Add extends Signal {\n\n\toverride = false;\n\n\treadonly name = \"Add\";\n\n\t/**\n\t *  the summing node\n\t */\n\tprivate _sum: Gain = new Gain({ context: this.context });\n\treadonly input = this._sum;\n\treadonly output = this._sum;\n\n\t/**\n\t * The value which is added to the input signal\n\t */\n\treadonly addend: Param<number> = this._param;\n\n\tconstructor(options?: Partial<SignalOptions<number>>);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(value?: number);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Add.getDefaults(), arguments, [\"value\"])));\n\n\t\tconnectSeries(this._constantSource, this._sum);\n\t}\n\n\tstatic getDefaults(): SignalOptions<number> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sum.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n *  Return the absolute value of an incoming signal.\n *\n *  @example\n * var signal = new Tone.Signal(-1);\n * var abs = new Tone.Abs();\n * signal.connect(abs);\n * //the output of abs is 1.\n */\nexport class Abs extends SignalOperator<ToneAudioNodeOptions> {\n\n\tname = \"Abs\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _abs = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: val => {\n\t\t\tif (Math.abs(val) < 0.001) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn Math.abs(val);\n\t\t\t}\n\t\t},\n\t});\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._abs;\n\n\t/**\n\t * The output range [0, 1]\n\t */\n\toutput = this._abs;\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._abs.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * GainToAudio converts an input in NormalRange [0,1] to AudioRange [-1,1].\n * See {@link AudioToGain}.\n *\n * @example\n * var a2g = new GainToAudio();\n */\nexport class GainToAudio extends SignalOperator<ToneAudioNodeOptions> {\n\n\tname = \"GainToAudio\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: x => Math.abs(x) * 2 - 1,\n\t});\n\n\t/**\n\t * The NormalRange input [0, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The AudioRange output [-1, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Multiply } from \"./Multiply\";\nimport { SignalOperator } from \"./SignalOperator\";\n\n/**\n *  @class Negate the incoming signal. i.e. an input signal of 10 will output -10\n *\n *  @constructor\n *  @extends {Tone.SignalBase}\n *  @example\n * var neg = new Negate();\n * var sig = new Signal(-2).connect(neg);\n * //output of neg is positive 2.\n */\nexport class Negate extends SignalOperator<ToneAudioNodeOptions> {\n\n\tname = \"Negate\";\n\n\t/**\n\t *  negation is done by multiplying by -1\n\t */\n\tprivate _multiply: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: -1,\n\t});\n\n\t/**\n\t * The input and output are equal to the multiply node\n\t */\n\tinput = this._multiply;\n\toutput = this._multiply;\n\n\t/**\n\t *  clean up\n\t *  @returns {Negate} this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._multiply.dispose();\n\t\treturn this;\n\t}\n}\n","import { connectSeries } from \"../core/Connect\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Negate } from \"../signal/Negate\";\nimport { Signal, SignalOptions } from \"../signal/Signal\";\n\n/**\n * Subtract the signal connected to the input is subtracted from the signal connected\n * The subtrahend.\n *\n * @param value The value to subtract from the incoming signal. If the value\n *                         is omitted, it will subtract the second signal from the first.\n * @example\n * var sub = new Subtract(1);\n * var sig = new Tone.Signal(4).connect(sub);\n * //the output of sub is 3.\n * @example\n * var sub = new Subtract();\n * var sigA = new Tone.Signal(10);\n * var sigB = new Tone.Signal(2.5);\n * sigA.connect(sub);\n * sigB.connect(sub.subtrahend);\n * //output of sub is 7.5\n */\nexport class Subtract extends Signal {\n\n\toverride = false;\n\n\treadonly name = \"Subtract\";\n\n\t/**\n\t *  the summing node\n\t */\n\tprivate _sum: Gain = new Gain({ context: this.context });\n\tinput = this._sum;\n\toutput = this._sum;\n\n\t/**\n\t *  Negate the input of the second input before connecting it to the summing node.\n\t */\n\tprivate _neg: Negate = new Negate({ context : this.context });\n\n\t/**\n\t * The value which is subtracted from the main signal\n\t */\n\tsubtrahend: Param<number> = this._param;\n\n\tconstructor(options?: Partial<SignalOptions<number>>);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(value?: number);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Subtract.getDefaults(), arguments, [\"value\"])));\n\n\t\tconnectSeries(this._constantSource, this._neg, this._sum);\n\t}\n\n\tstatic getDefaults(): SignalOptions<number> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._neg.dispose();\n\t\tthis._sum.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { connect, disconnect, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { SignalOperator } from \"./SignalOperator\";\n\n/**\n *  Tone.Zero outputs 0's at audio-rate. The reason this has to be\n *  it's own class is that many browsers optimize out Tone.Signal\n *  with a value of 0 and will not process nodes further down the graph.\n */\nexport class Zero extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name = \"Zero\";\n\n\t/**\n\t * The gain node which connects the constant source to the output\n\t */\n\tprivate _gain = new Gain({ context : this.context });\n\n\t/**\n\t * Only outputs 0\n\t */\n\toutput = this._gain;\n\n\t/**\n\t * no input node\n\t */\n\tinput = undefined;\n\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Zero.getDefaults(), arguments)));\n\t\tconnect(this.context.getConstant(0), this._gain);\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tdisconnect(this.context.getConstant(0), this._gain);\n\t\treturn this;\n\t}\n}\n","import { InputNode, OutputNode } from \"../../core/context/ToneAudioNode\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\n\ntype BasicEnvelopeCurve = \"linear\" | \"exponential\";\ntype InternalEnvelopeCurve = BasicEnvelopeCurve | number[];\nexport type EnvelopeCurve = EnvelopeCurveName | number[];\n\nexport interface EnvelopeOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tdecay: Time;\n\tsustain: NormalRange;\n\trelease: Time;\n\tattackCurve: EnvelopeCurve;\n\treleaseCurve: EnvelopeCurve;\n\tdecayCurve: BasicEnvelopeCurve;\n}\n\n/**\n *  Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n *  envelope generator. Envelope outputs a signal which\n *  can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n *\n *  @param attack The amount of time it takes for the envelope to go from\n *                         0 to it's maximum value.\n *  @param decay\tThe period of time after the attack that it takes for the envelope\n *                       \tto fall to the sustain value. Value must be greater than 0.\n *  @param sustain\tThe percent of the maximum value that the envelope rests at until\n *                                \tthe release is triggered.\n *  @param release\tThe amount of time after the release is triggered it takes to reach 0.\n *                         \tValue must be greater than 0.\n *  @example\n * //an amplitude envelope\n * var gainNode = Tone.context.createGain();\n * var env = new Envelope({\n * \t\"attack\" : 0.1,\n * \t\"decay\" : 0.2,\n * \t\"sustain\" : 1,\n * \t\"release\" : 0.8,\n * });\n * env.connect(gainNode.gain);\n */\nexport class Envelope extends ToneAudioNode<EnvelopeOptions> {\n\n\treadonly name: string = \"Envelope\";\n\n\t/**\n\t * When triggerAttack is called, the attack time is the amount of\n\t * time it takes for the envelope to reach it's maximum value.\n\t * ```\n\t *           /\\\n\t *          /X \\\n\t *         /XX  \\\n\t *        /XXX   \\\n\t *       /XXXX    \\___________\n\t *      /XXXXX                \\\n\t *     /XXXXXX                 \\\n\t *    /XXXXXXX                  \\\n\t *   /XXXXXXXX                   \\\n\t * ```\n\t */\n\tattack: Time;\n\n\t/**\n\t * After the attack portion of the envelope, the value will fall\n\t * over the duration of the decay time to it's sustain value.\n\t * ```\n\t *           /\\\n\t *          / X\\\n\t *         /  XX\\\n\t *        /   XXX\\\n\t *       /    XXXX\\___________\n\t *      /     XXXXX           \\\n\t *     /      XXXXX            \\\n\t *    /       XXXXX             \\\n\t *   /        XXXXX              \\\n\t * ```\n\t */\n\tdecay: Time;\n\n\t/**\n\t * \tThe sustain value is the value\n\t * \twhich the envelope rests at after triggerAttack is\n\t * \tcalled, but before triggerRelease is invoked.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /          XXXXXXXXXXX\\\n\t *     /           XXXXXXXXXXX \\\n\t *    /            XXXXXXXXXXX  \\\n\t *   /             XXXXXXXXXXX   \\\n\t * ```\n\t */\n\tsustain: NormalRange;\n\n\t/**\n\t *  After triggerRelease is called, the envelope's\n\t *  value will fall to it's miminum value over the\n\t *  duration of the release time.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /                    X\\\n\t *     /                     XX\\\n\t *    /                      XXX\\\n\t *   /                       XXXX\\\n\t * ```\n\t */\n\trelease: Time;\n\n\t/**\n\t *  The automation curve type for the attack\n\t */\n\tprivate _attackCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t *  The automation curve type for the decay\n\t */\n\tprivate _decayCurve!: BasicEnvelopeCurve;\n\n\t/**\n\t *  The automation curve type for the release\n\t */\n\tprivate _releaseCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t *  the signal which is output.\n\t */\n\tprotected _sig: Signal<NormalRange> = new Signal({\n\t\tcontext: this.context,\n\t\tvalue: 0,\n\t});\n\n\t/**\n\t * The output signal of the envelope\n\t */\n\toutput: OutputNode = this._sig;\n\n\t/**\n\t * Envelope has no input\n\t */\n\tinput: InputNode | undefined = undefined;\n\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tconst options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n\n\t\tthis.attack = options.attack;\n\t\tthis.decay = options.decay;\n\t\tthis.sustain = options.sustain;\n\t\tthis.release = options.release;\n\t\tthis.attackCurve = options.attackCurve;\n\t\tthis.releaseCurve = options.releaseCurve;\n\t\tthis.decayCurve = options.decayCurve;\n\t}\n\n\tstatic getDefaults(): EnvelopeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack : 0.01,\n\t\t\tattackCurve : \"linear\" as EnvelopeCurveName,\n\t\t\tdecay : 0.1,\n\t\t\tdecayCurve : \"exponential\" as BasicEnvelopeCurve,\n\t\t\trelease : 1,\n\t\t\treleaseCurve : \"exponential\" as EnvelopeCurveName,\n\t\t\tsustain : 0.5,\n\t\t});\n\t}\n\n\t/**\n\t * Read the current value of the envelope. Useful for\n\t * syncronizing visual output to the envelope.\n\t */\n\tget value(): NormalRange {\n\t\treturn this.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t *  Get the curve\n\t *  @param  curve\n\t *  @param  direction  In/Out\n\t *  @return  {String}  The curve name\n\t *  @private\n\t */\n\tprivate _getCurve(curve: InternalEnvelopeCurve, direction: EnvelopeDirection): EnvelopeCurve {\n\t\tif (isString(curve)) {\n\t\t\treturn curve;\n\t\t} else {\n\t\t\t// look up the name in the curves array\n\t\t\tlet curveName: EnvelopeCurveName;\n\t\t\tfor (curveName in EnvelopeCurves) {\n\t\t\t\tif (EnvelopeCurves[curveName][direction] === curve) {\n\t\t\t\t\treturn curveName;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// return the custom curve\n\t\t\treturn curve;\n\t\t}\n\t}\n\n\t/**\n\t *  Assign a the curve to the given name using the direction\n\t *  @param  name\n\t *  @param  direction In/Out\n\t *  @param  curve\n\t */\n\tprivate _setCurve(\n\t\tname: \"_attackCurve\" | \"_decayCurve\" | \"_releaseCurve\",\n\t\tdirection: EnvelopeDirection,\n\t\tcurve: EnvelopeCurve,\n\t): void {\n\t\t// check if it's a valid type\n\t\tif (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n\t\t\tconst curveDef = EnvelopeCurves[curve];\n\t\t\tif (isObject(curveDef)) {\n\t\t\t\tif (name !== \"_decayCurve\") {\n\t\t\t\t\tthis[name] = curveDef[direction];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis[name] = curveDef;\n\t\t\t}\n\t\t} else if (isArray(curve) && name !== \"_decayCurve\") {\n\t\t\tthis[name] = curve;\n\t\t} else {\n\t\t\tthrow new Error(\"Envelope: invalid curve: \" + curve);\n\t\t}\n\t}\n\n\t/**\n\t * The shape of the attack.\n\t * Can be any of these strings:\n\t * * \"linear\"\n\t * * \"exponential\"\n\t * * \"sine\"\n\t * * \"cosine\"\n\t * * \"bounce\"\n\t * * \"ripple\"\n\t * * \"step\"\n\t *\n\t * Can also be an array which describes the curve. Values\n\t * in the array are evenly subdivided and linearly\n\t * interpolated over the duration of the attack.\n\t * @example\n\t * env.attackCurve = \"linear\";\n\t * @example\n\t * //can also be an array\n\t * env.attackCurve = [0, 0.2, 0.3, 0.4, 1]\n\t */\n\tget attackCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._attackCurve, \"In\");\n\t}\n\tset attackCurve(curve) {\n\t\tthis._setCurve(\"_attackCurve\", \"In\", curve);\n\t}\n\n\t/**\n\t * The shape of the release. See the attack curve types.\n\t * @example\n\t * env.releaseCurve = \"linear\";\n\t */\n\tget releaseCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._releaseCurve, \"Out\");\n\t}\n\tset releaseCurve(curve) {\n\t\tthis._setCurve(\"_releaseCurve\", \"Out\", curve);\n\t}\n\n\t/**\n\t * The shape of the decay either \"linear\" or \"exponential\"\n\t * @example\n\t * env.decayCurve = \"linear\";\n\t */\n\tget decayCurve(): BasicEnvelopeCurve {\n\t\treturn this._decayCurve;\n\t}\n\tset decayCurve(curve) {\n\t\tthis.assert([\"linear\", \"exponential\"].some(c => c === curve), `Invalid envelope curve: ${curve}`);\n\t\tthis._decayCurve = curve;\n\t}\n\n\t/**\n\t * Trigger the attack/decay portion of the ADSR envelope.\n\t * @param  time When the attack should start.\n\t * @param velocity The velocity of the envelope scales the vales.\n\t *                              number between 0-1\n\t * @example\n\t * //trigger the attack 0.5 seconds from now with a velocity of 0.2\n\t * env.triggerAttack(\"+0.5\", 0.2);\n\t */\n\ttriggerAttack(time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", time, velocity);\n\t\ttime = this.toSeconds(time);\n\t\tconst originalAttack = this.toSeconds(this.attack);\n\t\tlet attack = originalAttack;\n\t\tconst decay = this.toSeconds(this.decay);\n\t\t// check if it's not a complete attack\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\t// subtract the current value from the attack time\n\t\t\tconst attackRate = 1 / attack;\n\t\t\tconst remainingDistance = 1 - currentValue;\n\t\t\t// the attack is now the remaining time\n\t\t\tattack = remainingDistance / attackRate;\n\t\t}\n\t\t// attack\n\t\tif (attack === 0) {\n\t\t\t// case where the attack time is 0 should set instantly\n\t\t\tthis._sig.setValueAtTime(velocity, time);\n\t\t} else if (this._attackCurve === \"linear\") {\n\t\t\tthis._sig.linearRampTo(velocity, attack, time);\n\t\t} else if (this._attackCurve === \"exponential\") {\n\t\t\tthis._sig.targetRampTo(velocity, attack, time);\n\t\t} else {\n\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\tlet curve = this._attackCurve;\n\t\t\t// find the starting position in the curve\n\t\t\tfor (let i = 1; i < curve.length; i++) {\n\t\t\t\t// the starting index is between the two values\n\t\t\t\tif (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n\t\t\t\t\tcurve = this._attackCurve.slice(i);\n\t\t\t\t\t// the first index is the current value\n\t\t\t\t\tcurve[0] = currentValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._sig.setValueCurveAtTime(curve, time, attack, velocity);\n\t\t}\n\t\t// decay\n\t\tif (decay) {\n\t\t\tconst decayValue = velocity * this.sustain;\n\t\t\tconst decayStart = time + attack;\n\t\t\tthis.log(\"decay\", decayStart);\n\t\t\tif (this._decayCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampTo(decayValue, decay, decayStart + this.sampleTime);\n\t\t\t} else {\n\t\t\t\tthis.assert(this._decayCurve === \"exponential\",\n\t\t\t\t\t`decayCurve can only be \"linear\" or \"exponential\", got ${this._decayCurve}`);\n\t\t\t\tthis._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Triggers the release of the envelope.\n\t *  @param  time When the release portion of the envelope should start.\n\t *  @example\n\t *  //trigger release immediately\n\t *  env.triggerRelease();\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\ttime = this.toSeconds(time);\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\tconst release = this.toSeconds(this.release);\n\t\t\tif (this._releaseCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampTo(0, release, time);\n\t\t\t} else if (this._releaseCurve === \"exponential\") {\n\t\t\t\tthis._sig.targetRampTo(0, release, time);\n\t\t\t} else {\n\t\t\t\tthis.assert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n\t\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\t\tthis._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Get the scheduled value at the given time. This will\n\t *  return the unconverted (raw) value.\n\t */\n\tgetValueAtTime(time: Time): NormalRange {\n\t\treturn this._sig.getValueAtTime(time);\n\t}\n\n\t/**\n\t *  triggerAttackRelease is shorthand for triggerAttack, then waiting\n\t *  some duration, then triggerRelease.\n\t *  @param duration The duration of the sustain.\n\t *  @param time When the attack should be triggered.\n\t *  @param velocity The velocity of the envelope.\n\t *  @example\n\t * //trigger the attack and then the release after 0.6 seconds.\n\t * env.triggerAttackRelease(0.6);\n\t */\n\ttriggerAttackRelease(duration: Time, time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis.triggerAttack(time, velocity);\n\t\tthis.triggerRelease(time + this.toSeconds(duration));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancels all scheduled envelope changes after the given time.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._sig.cancelScheduledValues(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the envelope to a destination node.\n\t */\n\tconnect(destination: InputNode, outputNumber: number = 0, inputNumber: number = 0): this {\n\t\tconnectSignal(this, destination, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sig.dispose();\n\t\treturn this;\n\t}\n}\n\ninterface EnvelopeCurveObject {\n\tIn: number[];\n\tOut: number[];\n}\n\ntype EnvelopeDirection = keyof EnvelopeCurveObject;\n\ninterface EnvelopeCurveMap {\n\tlinear: \"linear\";\n\texponential: \"exponential\";\n\tbounce: EnvelopeCurveObject;\n\tcosine: EnvelopeCurveObject;\n\tsine: EnvelopeCurveObject;\n\tripple: EnvelopeCurveObject;\n\tstep: EnvelopeCurveObject;\n}\n\ntype EnvelopeCurveName =  keyof EnvelopeCurveMap;\n\n/**\n *  Generate some complex envelope curves.\n */\n// tslint:disable-next-line: variable-name\nconst EnvelopeCurves: EnvelopeCurveMap = (() => {\n\n\tconst curveLen = 128;\n\n\tlet i: number;\n\tlet k: number;\n\n\t// cosine curve\n\tconst cosineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tcosineCurve[i] = Math.sin((i / (curveLen - 1)) * (Math.PI / 2));\n\t}\n\n\t// ripple curve\n\tconst rippleCurve: number[] = [];\n\tconst rippleCurveFreq = 6.4;\n\tfor (i = 0; i < curveLen - 1; i++) {\n\t\tk = (i / (curveLen - 1));\n\t\tconst sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n\t\trippleCurve[i] = sineWave / 10 + k * 0.83;\n\t}\n\trippleCurve[curveLen - 1] = 1;\n\n\t// stairs curve\n\tconst stairsCurve: number[] = [];\n\tconst steps = 5;\n\tfor (i = 0; i < curveLen; i++) {\n\t\tstairsCurve[i] = Math.ceil((i / (curveLen - 1)) * steps) / steps;\n\t}\n\n\t// in-out easing curve\n\tconst sineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tsineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n\t}\n\n\t// a bounce curve\n\tconst bounceCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tconst freq = Math.pow(k, 3) * 4 + 0.2;\n\t\tconst val = Math.cos(freq * Math.PI * 2 * k);\n\t\tbounceCurve[i] = Math.abs(val * (1 - k));\n\t}\n\n\t/**\n\t *  Invert a value curve to make it work for the release\n\t */\n\tfunction invertCurve(curve: number[]): number[] {\n\t\tconst out = new Array(curve.length);\n\t\tfor (let j = 0; j < curve.length; j++) {\n\t\t\tout[j] = 1 - curve[j];\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t *  reverse the curve\n\t */\n\tfunction reverseCurve(curve: number[]): number[] {\n\t\treturn curve.slice(0).reverse();\n\t}\n\n\t/**\n\t *  attack and release curve arrays\n\t */\n\treturn {\n\t\tbounce : {\n\t\t\tIn : invertCurve(bounceCurve),\n\t\t\tOut : bounceCurve,\n\t\t},\n\t\tcosine : {\n\t\t\tIn : cosineCurve,\n\t\t\tOut : reverseCurve(cosineCurve),\n\t\t},\n\t\texponential : \"exponential\" as \"exponential\",\n\t\tlinear : \"linear\" as \"linear\",\n\t\tripple : {\n\t\t\tIn : rippleCurve,\n\t\t\tOut : invertCurve(rippleCurve),\n\t\t},\n\t\tsine : {\n\t\t\tIn : sineCurve,\n\t\t\tOut : invertCurve(sineCurve),\n\t\t},\n\t\tstep : {\n\t\t\tIn : stairsCurve,\n\t\t\tOut : invertCurve(stairsCurve),\n\t\t},\n\t};\n})();\n","import { Gain } from \"../../core/context/Gain\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Envelope, EnvelopeOptions } from \"./Envelope\";\n\n/**\n * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.\n * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts\n * an audio signal as the input and will apply the envelope to the amplitude\n * of the signal.\n * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n *\n * @param attack The amount of time it takes for the envelope to go from 0 to it's maximum value.\n * @param decay\tThe period of time after the attack that it takes for the envelope\n *                       \tto fall to the sustain value. Value must be greater than 0.\n * @param sustain\tThe percent of the maximum value that the envelope rests at until\n *                                \tthe release is triggered.\n * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n *                         \tValue must be greater than 0.\n *  @example\n * var ampEnv = new AmplitudeEnvelope({\n * \t\"attack\": 0.1,\n * \t\"decay\": 0.2,\n * \t\"sustain\": 1.0,\n * \t\"release\": 0.8\n * }).toDestination();\n * //create an oscillator and connect it\n * var osc = new Tone.Oscillator().connect(ampEnv).start();\n * //trigger the envelopes attack and release \"8t\" apart\n * ampEnv.triggerAttackRelease(\"8t\");\n */\nexport class AmplitudeEnvelope extends Envelope {\n\n\tname = \"AmplitudeEnvelope\";\n\n\tprivate _gainNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\toutput: Gain = this._gainNode;\n\tinput: Gain = this._gainNode;\n\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tthis._sig.connect(this._gainNode.gain);\n\t\tthis.output = this._gainNode;\n\t\tthis.input = this._gainNode;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.dispose();\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../component/channel/Volume\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels, Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface InstrumentOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n}\n\n/**\n *  Base-class for all instruments\n */\nexport abstract class Instrument<Options extends InstrumentOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t *  The output and volume triming node\n\t */\n\tprivate _volume: Volume;\n\toutput: OutputNode;\n\n\t/**\n\t * The instrument only has an output\n\t */\n\tinput: undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * source.volume.value = -6;\n\t */\n\tvolume: Param<Decibels>;\n\n\t/**\n\t * Keep track of all events scheduled to the transport\n\t * when the instrument is 'synced'\n\t */\n\tprivate _scheduledEvents: number[] = [];\n\n\t/**\n\t * If the instrument is currently synced\n\t */\n\tprivate _synced: boolean = false;\n\n\tconstructor(options?: Partial<InstrumentOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Instrument.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Instrument.getDefaults(), arguments);\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t}\n\n\tstatic getDefaults(): InstrumentOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Sync the instrument to the Transport. All subsequent calls of\n\t * [triggerAttack](#triggerattack) and [triggerRelease](#triggerrelease)\n\t * will be scheduled along the transport.\n\t * @example\n\t * instrument.sync()\n\t * //schedule 3 notes when the transport first starts\n\t * instrument.triggerAttackRelease('C4', '8n', 0)\n\t * instrument.triggerAttackRelease('E4', '8n', '8n')\n\t * instrument.triggerAttackRelease('G4', '8n', '4n')\n\t * //start the transport to hear the notes\n\t * Transport.start()\n\t * @returns {Instrument} this\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 0);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Wrap the given method so that it can be synchronized\n\t * @param method Which method to wrap and sync\n\t * @param  timePosition What position the time argument appears in\n\t */\n\tprotected _syncMethod(method: string, timePosition: number): void {\n\t\tconst originalMethod = this[\"_original_\" + method] = this[method];\n\t\tthis[method] = (...args: any[]) => {\n\t\t\tconst time = args[timePosition];\n\t\t\tconst id = this.context.transport.schedule((t) => {\n\t\t\t\targs[timePosition] = t;\n\t\t\t\toriginalMethod.apply(this, args);\n\t\t\t}, time);\n\t\t\tthis._scheduledEvents.push(id);\n\t\t};\n\t}\n\n\t/**\n\t * Unsync the instrument from the Transport\n\t */\n\tunsync(): this {\n\t\tthis._scheduledEvents.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduledEvents = [];\n\t\tif (this._synced) {\n\t\t\tthis._synced = false;\n\t\t\tthis.triggerAttack = this._original_triggerAttack;\n\t\t\tthis.triggerRelease = this._original_triggerRelease;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Trigger the attack and then the release after the duration.\n\t *  @param  note     The note to trigger.\n\t *  @param  duration How long the note should be held for before\n\t *                          triggering the release. This value must be greater than 0.\n\t *  @param time  When the note should be triggered.\n\t *  @param  velocity The velocity the note should be triggered at.\n\t *  @example\n\t * //trigger \"C4\" for the duration of an 8th note\n\t * synth.triggerAttackRelease(\"C4\", \"8n\");\n\t */\n\ttriggerAttackRelease(note: Frequency, duration: Time, time?: Time, velocity?: NormalRange): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tthis.triggerAttack(note, computedTime, velocity);\n\t\tthis.triggerRelease(computedTime + computedDuration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the instrument's note.\n\t * @param note the note to trigger\n\t * @param time the time to trigger the ntoe\n\t * @param velocity the velocity to trigger the note (betwee 0-1)\n\t */\n\tabstract triggerAttack(note: Frequency, time?: Time, velocity?: NormalRange): this;\n\t// tslint:disable-next-line: variable-name\n\tprivate _original_triggerAttack = this.triggerAttack;\n\n\t/**\n\t * Trigger the release phase of the current note.\n\t *  @param time when to trigger the release\n\t */\n\tabstract triggerRelease(...args: any[]): this;\n\t// tslint:disable-next-line: variable-name\n\tprivate _original_triggerRelease = this.triggerRelease;\n\n\t/**\n\t *  clean up\n\t *  @returns {Instrument} this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.unsync();\n\t\tthis._scheduledEvents = [];\n\t\treturn this;\n\t}\n}\n","import { Envelope } from \"../component/envelope/Envelope\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { Cents, Frequency, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { Signal } from \"../signal/Signal\";\n\ntype onSilenceCallback = (instrument: Monophonic<any>) => void;\n\nexport interface MonophonicOptions extends InstrumentOptions {\n\tportamento: Seconds;\n\tonsilence: onSilenceCallback;\n}\n\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport abstract class Monophonic<Options extends MonophonicOptions> extends Instrument<Options> {\n\n\t/**\n\t *  The glide time between notes.\n\t */\n\tportamento: Seconds;\n\n\t/**\n\t * Invoked when the release has finished and the output is silent.\n\t */\n\tonsilence: onSilenceCallback;\n\n\t/**\n\t * The instrument's envelope\n\t */\n\tabstract envelope: Envelope;\n\n\t/**\n\t * The instrument's frequency signal.\n\t */\n\tabstract readonly frequency: Signal<Frequency>;\n\n\t/**\n\t * The instrument's detune control signal.\n\t */\n\tabstract readonly detune: Signal<Cents>;\n\n\tconstructor(options?: Partial<MonophonicOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Monophonic.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n\n\t\tthis.portamento = options.portamento;\n\t\tthis.onsilence = options.onsilence;\n\t}\n\n\tstatic getDefaults(): MonophonicOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tonsilence: noOp,\n\t\t\tportamento: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack of the note optionally with a given velocity.\n\t * @param  note The note to trigger.\n\t * @param  time When the note should start.\n\t * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n\t * @example\n\t * synth.triggerAttack(\"C4\");\n\t * @example\n\t * //trigger the note a half second from now at half velocity\n\t * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n\t */\n\ttriggerAttack(note: Frequency | FrequencyClass, time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", note, time, velocity);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeAttack(seconds, velocity);\n\t\tthis.setNote(note, seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release portion of the envelope\n\t * @param  time If no time is given, the release happens immediatly\n\t * @example\n\t * synth.triggerRelease();\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeRelease(seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal method which starts the envelope attack\n\t */\n\tprotected abstract _triggerEnvelopeAttack(time: Seconds, velocity: NormalRange): void;\n\n\t/**\n\t * Internal method which starts the envelope release\n\t */\n\tprotected abstract _triggerEnvelopeRelease(time: Seconds): void;\n\n\t/**\n\t * Get the level of the output at the given time. Measures\n\t * the envelope(s) value at the time.\n\t * @param time The time to query the envelope value\n\t * @return The output level between 0-1\n\t */\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Set the note at the given time. If no time is given, the note\n\t * will set immediately.\n\t * @param note The note to change to.\n\t * @param  time The time when the note should be set.\n\t * @example\n\t * //change to F#6 in one quarter note from now.\n\t * synth.setNote(\"F#6\", \"+4n\");\n\t * @example\n\t * //change to Bb4 right now\n\t * synth.setNote(\"Bb4\");\n\t */\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n\t\tif (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n\t\t\tconst portTime = this.toSeconds(this.portamento);\n\t\t\tthis.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n\t\t} else {\n\t\t\tthis.frequency.setValueAtTime(computedFrequency, computedTime);\n\t\t}\n\t\treturn this;\n\t}\n}\n","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Cents, Frequency, Seconds } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { OmniOscillatorConstructorOptions, OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\nimport { Source, SourceOptions } from \"../source/Source\";\nimport { Monophonic, MonophonicOptions } from \"./Monophonic\";\n\nexport interface SynthOptions extends MonophonicOptions {\n\toscillator: OmniOscillatorSynthOptions;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Synth is composed simply of a {@link OmniOscillator} routed through an {@link AmplitudeEnvelope}.\n * ```\n * +----------------+   +-------------------+\n * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output\n * +----------------+   +-------------------+\n * ```\n * @param options the options available for the synth.\n * @example\n * var synth = new Synth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n */\nexport class Synth<Options extends SynthOptions = SynthOptions> extends Monophonic<Options> {\n\n\treadonly name: string = \"Synth\";\n\n\t/**\n\t *  The oscillator.\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The frequency signal\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t * The detune signal\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t * The envelope\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\tconstructor(options?: RecursivePartial<SynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Synth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Synth.getDefaults(), arguments);\n\n\t\tthis.oscillator = new OmniOscillator(Object.assign({\n\t\t\tcontext: this.context,\n\t\t\tonstop: () => this.onsilence(this),\n\t\t}, options.oscillator));\n\n\t\tthis.frequency = this.oscillator.frequency;\n\t\tthis.detune = this.oscillator.detune;\n\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.envelope));\n\n\t\t// connect the oscillators to the output\n\t\tthis.oscillator.chain(this.envelope, this.output);\n\t\treadOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): SynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack : 0.005,\n\t\t\t\t\tdecay : 0.1,\n\t\t\t\t\trelease : 1,\n\t\t\t\t\tsustain : 0.3,\n\t\t\t\t},\n\t\t\t),\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"triangle\",\n\t\t\t\t},\n\t\t\t),\n\t\t});\n\t}\n\n\t/**\n\t *  start the attack portion of the envelope\n\t *  @param time the time the attack should start\n\t *  @param velocity the velocity of the note (0-1)\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// the envelopes\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis.oscillator.start(time);\n\t\t// if there is no release portion, stop the oscillator\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tconst computedAttack = this.toSeconds(this.envelope.attack);\n\t\t\tconst computedDecay = this.toSeconds(this.envelope.decay);\n\t\t\tthis.oscillator.stop(time + computedAttack + computedDecay);\n\t\t}\n\t}\n\n\t/**\n\t *  start the release portion of the envelope\n\t *  @param time the time the release should start\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): void {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.oscillator.stop(time + this.toSeconds(this.envelope.release));\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.oscillator.dispose();\n\t\tthis.envelope.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { Frequency, Interval, MidiNote, NormalRange, Note, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber, isString } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { ToneBufferSource, ToneBufferSourceCurve } from \"../source/buffer/BufferSource\";\n\ninterface SamplesMap {\n\t[note: string]: ToneAudioBuffer | AudioBuffer | string;\n\t[midi: number]: ToneAudioBuffer | AudioBuffer | string;\n}\n\ninterface SamplerOptions extends InstrumentOptions {\n\tattack: Time;\n\trelease: Time;\n\tonload: () => void;\n\tbaseUrl: string;\n\tcurve: ToneBufferSourceCurve;\n\turls: SamplesMap;\n}\n\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use {@link Player}.\n * @param samples An object of samples mapping either Midi\n *                         Note Numbers or Scientific Pitch Notation\n *                         to the url of that sample.\n * @param onload The callback to invoke when all of the samples are loaded.\n * @param baseUrl The root URL of all of the samples, which is prepended to all the URLs.\n * @example\n * var sampler = new Sampler({\n * \t\"C3\" : \"path/to/C3.mp3\",\n * \t\"D#3\" : \"path/to/Dsharp3.mp3\",\n * \t\"F#3\" : \"path/to/Fsharp3.mp3\",\n * \t\"A3\" : \"path/to/A3.mp3\",\n * }, function(){\n * \t//sampler will repitch the closest sample\n * \tsampler.triggerAttack(\"D3\")\n * })\n */\nexport class Sampler extends Instrument<SamplerOptions> {\n\n\tname = \"Sampler\";\n\n\t/**\n\t * The stored and loaded buffers\n\t * @type {Tone.Buffers}\n\t * @private\n\t */\n\tprivate _buffers: ToneAudioBuffers;\n\n\t/**\n\t * The object of all currently playing BufferSources\n\t */\n\tprivate _activeSources: Map<MidiNote, ToneBufferSource[]> = new Map();\n\n\t/**\n\t * The envelope applied to the beginning of the sample.\n\t */\n\tattack: Time;\n\n\t/**\n\t * The envelope applied to the end of the envelope.\n\t */\n\trelease: Time;\n\n\t/**\n\t *  The shape of the attack/release curve.\n\t *  Either \"linear\" or \"exponential\"\n\t */\n\tcurve: ToneBufferSourceCurve;\n\n\tconstructor(options?: Partial<SamplerOptions>);\n\tconstructor(samples?: SamplesMap, options?: Partial<Omit<SamplerOptions, \"urls\">>);\n\tconstructor(samples?: SamplesMap, onload?: () => void, baseUrl?: string);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n\t\tconst options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n\n\t\tconst urlMap = {};\n\t\tObject.keys(options.urls).forEach((note) => {\n\t\t\tconst noteNumber = parseInt(note, 10);\n\t\t\tthis.assert(isNote(note)\n\t\t\t\t|| (isNumber(noteNumber) && isFinite(noteNumber)), `url key is neither a note or midi pitch: ${note}`);\n\t\t\tif (isNote(note)) {\n\t\t\t\t// convert the note name to MIDI\n\t\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\t\turlMap[mid] = options.urls[note];\n\t\t\t} else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n\t\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\t\turlMap[noteNumber] = options.urls[noteNumber];\n\t\t\t}\n\t\t});\n\n\t\tthis._buffers = new ToneAudioBuffers(urlMap, options.onload, options.baseUrl);\n\t\tthis.attack = options.attack;\n\t\tthis.release = options.release;\n\t\tthis.curve = options.curve;\n\t}\n\n\tstatic getDefaults(): SamplerOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tattack : 0,\n\t\t\tbaseUrl : \"\",\n\t\t\tcurve : \"exponential\" as \"exponential\",\n\t\t\tonload : noOp,\n\t\t\trelease : 0.1,\n\t\t\turls: {},\n\t\t});\n\t}\n\n\t/**\n\t * Returns the difference in steps between the given midi note at the closets sample.\n\t */\n\tprivate _findClosest(midi: MidiNote): Interval {\n\t\t// searches within 8 octaves of the given midi note\n\t\tconst MAX_INTERVAL = 96;\n\t\tlet interval = 0;\n\t\twhile (interval < MAX_INTERVAL) {\n\t\t\t// check above and below\n\t\t\tif (this._buffers.has(midi + interval)) {\n\t\t\t\treturn -interval;\n\t\t\t} else if (this._buffers.has(midi - interval)) {\n\t\t\t\treturn interval;\n\t\t\t}\n\t\t\tinterval++;\n\t\t}\n\t\tthrow new Error(`No available buffers for note: ${midi}`);\n\t}\n\n\t/**\n\t * @param  notes\tThe note to play, or an array of notes.\n\t * @param  time     When to play the note\n\t * @param  velocity The velocity to play the sample back.\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", notes, time, velocity);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midi = new FrequencyClass(this.context, note).toMidi();\n\t\t\t// find the closest note pitch\n\t\t\tconst difference = this._findClosest(midi);\n\t\t\tconst closestNote = midi - difference;\n\t\t\tconst buffer = this._buffers.get(closestNote);\n\t\t\tconst playbackRate = intervalToFrequencyRatio(difference);\n\t\t\t// play that note\n\t\t\tconst source = new ToneBufferSource({\n\t\t\t\tbuffer,\n\t\t\t\tcontext: this.context,\n\t\t\t\tcurve : this.curve,\n\t\t\t\tfadeIn : this.attack,\n\t\t\t\tfadeOut : this.release,\n\t\t\t\tplaybackRate,\n\t\t\t}).connect(this.output);\n\t\t\tsource.start(time, 0, buffer.duration / playbackRate, velocity);\n\t\t\t// add it to the active sources\n\t\t\tif (!isArray(this._activeSources.get(midi))) {\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t\t(this._activeSources.get(midi) as ToneBufferSource[]).push(source);\n\n\t\t\t// remove it when it's done\n\t\t\tsource.onended = () => {\n\t\t\t\tif (this._activeSources && this._activeSources.has(midi)) {\n\t\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\t\tconst index = sources.indexOf(source);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tsources.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param  notes\tThe note to release, or an array of notes.\n\t * @param  time     \tWhen to release the note.\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tthis.log(\"triggerRelease\", notes, time);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midi = new FrequencyClass(this.context, note).toMidi();\n\t\t\t// find the note\n\t\t\tif (this._activeSources.has(midi) && (this._activeSources.get(midi) as ToneBufferSource[]).length) {\n\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\ttime = this.toSeconds(time);\n\t\t\t\tsources.forEach(source => {\n\t\t\t\t\tsource.stop(time);\n\t\t\t\t});\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Release all currently active notes.\n\t * @param  time     \tWhen to release the notes.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(sources => {\n\t\t\twhile (sources.length) {\n\t\t\t\tconst source = sources.shift() as ToneBufferSource;\n\t\t\t\tsource.stop(computedTime);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the instrument to the Transport. All subsequent calls of\n\t * [triggerAttack](#triggerattack) and [triggerRelease](#triggerrelease)\n\t * will be scheduled along the transport.\n\t * @example\n\t * synth.sync()\n\t * //schedule 3 notes when the transport first starts\n\t * synth.triggerAttackRelease('8n', 0)\n\t * synth.triggerAttackRelease('8n', '8n')\n\t * synth.triggerAttackRelease('8n', '4n')\n\t * //start the transport to hear the notes\n\t * Transport.start()\n\t * @returns {Tone.Instrument} this\n\t */\n\tsync(): this {\n\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the attack phase, then after the duration, invoke the release.\n\t * @param  notes\tThe note to play and release, or an array of notes.\n\t * @param  duration The time the note should be held\n\t * @param  time     When to start the attack\n\t * @param  velocity The velocity of the attack\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency[] | Frequency,\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tthis.assert(isArray(notes), \"notes must be an array when duration is array\");\n\t\t\t(notes as Frequency[]).forEach((note, index) => {\n\t\t\t\tconst d = duration[Math.min(index, duration.length - 1)];\n\t\t\t\tthis.triggerRelease(note, computedTime + this.toSeconds(d));\n\t\t\t});\n\t\t} else {\n\t\t\tthis.triggerRelease(notes, computedTime + this.toSeconds(duration));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a note to the sampler.\n\t * @param  note      The buffer's pitch.\n\t * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(note: Note | MidiNote, url: string | ToneAudioBuffer | AudioBuffer, callback?: () => void): this {\n\t\tthis.assert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n\t\tif (isNote(note)) {\n\t\t\t// convert the note name to MIDI\n\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\tthis._buffers.add(mid, url, callback);\n\t\t} else {\n\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\tthis._buffers.add(note, url, callback);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffers.loaded;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.dispose();\n\t\tthis._activeSources.forEach(sources => {\n\t\t\tsources.forEach(source => source.dispose());\n\t\t});\n\t\tthis._activeSources.clear();\n\t\treturn this;\n\t}\n}\n","import { MidiClass } from \"../core/type/Midi\";\nimport { Frequency, MidiNote, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { isArray } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\nimport { MembraneSynth, MembraneSynthOptions } from \"./MembraneSynth\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth, SynthOptions } from \"./Synth\";\n\ntype VoiceConstructor<V> = {\n\tgetDefaults: () => VoiceOptions<V>,\n} & (new (...args: any[]) => V);\n\ntype OmitMonophonicOptions<T> = Omit<T, \"context\" | \"onsilence\">;\n\ntype VoiceOptions<T> =\n\tT extends MembraneSynth ? MembraneSynthOptions :\n\tT extends Synth ? SynthOptions :\n\tnever;\n\n/**\n * The settable synth options. excludes monophonic options.\n */\ntype PartialVoiceOptions<T> = RecursivePartial<\n\tOmitMonophonicOptions<\n\t\tVoiceOptions<T>\n\t>\n>;\n\ninterface PolySynthOptions<Voice> extends InstrumentOptions {\n\tpolyphony: number;\n\tvoice: VoiceConstructor<Voice>;\n\toptions: PartialVoiceOptions<Voice>;\n}\n\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n *  @param polyphony The maximum polyphony of the synth\n *  @param voice The constructor of the voices\n *  @param options\tThe options object to set the synth voice\n *  @example\n * //a polysynth composed of 6 Voices of Synth\n * var synth = new PolySynth(6, Tone.Synth, {\n *   oscillator : {\n * \t\ttype : \"square\"\n * \t}\n * }).toMaster();\n * //set the attributes using the set interface\n * synth.set(\"detune\", -1200);\n * //play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], \"4n\");\n */\nexport class PolySynth<Voice extends Monophonic<any> = Synth> extends Instrument<VoiceOptions<Voice>> {\n\n\treadonly name = \"PolySynth\";\n\n\t/**\n\t * The voices which are not currently in use\n\t */\n\tprivate _availableVoices: Voice[] = [];\n\n\t/**\n\t * The currently active voices\n\t */\n\tprivate _activeVoices: Array<{midi: MidiNote, voice: Voice}> = [];\n\n\t/**\n\t * All of the allocated voices for this synth.\n\t */\n\tprivate _voices: Voice[] = [];\n\n\t/**\n\t * The options that are set on the synth.\n\t */\n\tprivate options: VoiceOptions<Voice>;\n\n\t/**\n\t * The polyphony limit.\n\t */\n\tpolyphony: number;\n\n\tprivate readonly voice: VoiceConstructor<Voice>;\n\n\tconstructor(\n\t\tpolyphony?: number,\n\t\tvoice?: VoiceConstructor<Voice>,\n\t\toptions?: PartialVoiceOptions<Voice>,\n\t);\n\tconstructor(options?: Partial<PolySynthOptions<Voice>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PolySynth.getDefaults(), arguments, [\"polyphony\", \"voice\", \"options\"]));\n\t\tconst options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"polyphony\", \"voice\", \"options\"]);\n\n\t\tconst defaults = options.voice.getDefaults();\n\t\tthis.options = Object.assign(defaults, options.options) as VoiceOptions<Voice>;\n\t\tthis.voice = options.voice as unknown as VoiceConstructor<Voice>;\n\t\tthis.polyphony = options.polyphony;\n\t}\n\n\tstatic getDefaults(): PolySynthOptions<Synth> {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\toptions: {},\n\t\t\tpolyphony: 4,\n\t\t\tvoice: Synth,\n\t\t});\n\t}\n\n\t/**\n\t * The number of active voices.\n\t */\n\tget activeVoices(): number {\n\t\treturn this._activeVoices.length;\n\t}\n\n\t/**\n\t * If there is a voice active on that note, return it\n\t */\n\tprivate _getActiveVoice(note: MidiNote): Voice | undefined {\n\t\tconst event = this._activeVoices.find(({midi}) => midi === note);\n\t\tif (event) {\n\t\t\treturn event.voice;\n\t\t}\n\t}\n\n\t/**\n\t * Invoked when the source is done making sound, so that it can be\n\t * readded to the pool of available voices\n\t */\n\tprivate _makeVoiceAvailable(voice: Voice): void {\n\t\tthis._availableVoices.push(voice);\n\t\t// remove the midi note from 'active voices'\n\t\tconst activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);\n\t\tthis._activeVoices.splice(activeVoiceIndex, 1);\n\t}\n\n\t/**\n\t * Get an available voice from the pool of available voices.\n\t * If one is not available and the polyphony limit is reached,\n\t * steal a voice, otherwise return null.\n\t */\n\tprivate _getNextAvailableVoice(): Voice | undefined {\n\t\t// if there are available voices, return the first one\n\t\tif (this._availableVoices.length) {\n\t\t\treturn this._availableVoices.shift();\n\t\t} else if (this._voices.length < this.polyphony) {\n\t\t\t// otherwise if there is still more polyphony, make a new voice\n\t\t\tconst voice = new this.voice(Object.assign(this.options, {\n\t\t\t\tcontext: this.context,\n\t\t\t\tonsilence: this._makeVoiceAvailable.bind(this),\n\t\t\t}));\n\t\t\tvoice.connect(this.output);\n\t\t\tthis._voices.push(voice);\n\t\t\treturn voice;\n\t\t} else {\n\t\t\tconsole.warn(\"Max polyphony exceeded. Note dropped.\");\n\t\t}\n\t}\n\n\t/**\n\t * Internal method which triggers the attack\n\t */\n\tprivate _triggerAttack(notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\t// let voice: Voice | undefined;\n\t\t\t// if there's already a note at that voice, reuse it\n\t\t\tlet voice = this._getActiveVoice(midiNote);\n\t\t\t// if it has a note, and that note is still active\n\t\t\tif (voice && voice.getLevelAtTime(time) > 0) {\n\t\t\t\tconst activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);\n\t\t\t\tthis._activeVoices.splice(activeVoiceIndex, 1);\n\t\t\t} else {\n\t\t\t\t// otherwise get the next available voice\n\t\t\t\tvoice = this._getNextAvailableVoice();\n\t\t\t}\n\t\t\tif (voice) {\n\t\t\t\tvoice.triggerAttack(note, time, velocity);\n\t\t\t\tthis._activeVoices.unshift({\n\t\t\t\t\tmidi: midiNote, voice,\n\t\t\t\t});\n\t\t\t\tthis.log(\"triggerAttack\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Internal method which triggers the release\n\t */\n\tprivate _triggerRelease(notes: Frequency[], time: Seconds): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst voice = this._getActiveVoice(midiNote);\n\t\t\tif (voice) {\n\t\t\t\t// trigger release on that note\n\t\t\t\tvoice.triggerRelease(time);\n\t\t\t\tthis.log(\"triggerRelease\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n\t * to wait for just-in-time scheduling\n\t */\n\tprivate _scheduleEvent(type: \"attack\" | \"release\", notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tthis.assert(!this.disposed, \"Synth was already disposed\");\n\t\t// if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\t\tif (time <= this.now()) {\n\t\t\t// do it immediately\n\t\t\tif (type === \"attack\") {\n\t\t\t\tthis._triggerAttack(notes, time, velocity);\n\t\t\t} else {\n\t\t\t\tthis._triggerRelease(notes, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// schedule it to start in the future\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tthis._scheduleEvent(type, notes, time, velocity);\n\t\t\t}, time - this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  The start time of the note.\n\t * @param velocity The velocity of the note.\n\t * @example\n\t * //trigger a chord immediately with a velocity of 0.2\n\t * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"], undefined, 0.2);\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity?: NormalRange): this {\n\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release of the note. Unlike monophonic instruments,\n\t * a note (or array of notes) needs to be passed in as the first argument.\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  When the release will be triggered.\n\t * @example\n\t * poly.triggerRelease([\"Ab3\", \"C4\", \"F5\"], \"+2n\");\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"release\", notes, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and release after the specified duration\n\t * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n\t * @param  duration the duration of the note\n\t * @param  time  if no time is given, defaults to now\n\t * @param  velocity the velocity of the attack (0-1)\n\t * @example\n\t * //trigger a chord for a duration of a half note\n\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"C5\"], \"2n\");\n\t * @example\n\t * //can pass in an array of durations as well\n\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"C5\"], [\"2n\", \"4n\", \"4n\"]);\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency | Frequency[],\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity?: NormalRange,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tthis.assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n\t\t\tnotes = notes as Frequency[];\n\t\t\tfor (let i = 0; i < notes.length; i++) {\n\t\t\t\tconst d = duration[Math.min(i, duration.length - 1)];\n\t\t\t\tconst durationSeconds = this.toSeconds(d);\n\t\t\t\tthis.assert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\t\tthis.triggerRelease(notes[i], computedTime + durationSeconds);\n\t\t\t}\n\t\t} else {\n\t\t\tconst durationSeconds = this.toSeconds(duration);\n\t\t\tthis.assert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\tthis.triggerRelease(notes, computedTime + durationSeconds);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the instrument to the Transport. All subsequent calls of\n\t * {@link triggerAttack} and {@link triggerRelease} will be scheduled along the transport.\n\t * @example\n\t * synth.sync()\n\t * //schedule 3 notes when the transport first starts\n\t * synth.triggerAttackRelease('8n', 0)\n\t * synth.triggerAttackRelease('8n', '8n')\n\t * synth.triggerAttackRelease('8n', '4n')\n\t * //start the transport to hear the notes\n\t * Transport.start()\n\t */\n\tsync(): this {\n\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a member/attribute of the voices\n\t * @example\n\t * poly.set({\n\t * \t\"filter\" : {\n\t * \t\t\"type\" : \"highpass\"\n\t * \t},\n\t * \t\"envelope\" : {\n\t * \t\t\"attack\" : 0.25\n\t * \t}\n\t * });\n\t */\n\tset(options: RecursivePartial<VoiceOptions<Voice>>): this {\n\t\tthis.options = deepMerge(this.options, options);\n\t\tthis._voices.forEach(voice => voice.set(this.options));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Get the synth's attributes.\n\t */\n\tget(): VoiceOptions<Voice> {\n\t\treturn this.options;\n\t}\n\n\t/**\n\t * Trigger the release portion of all the currently active voices immediately.\n\t * Useful for silencing the synth.\n\t */\n\treleaseAll(): this {\n\t\tconst now = this.now();\n\t\tthis._activeVoices.forEach(({voice}) => {\n\t\t\tvoice.triggerRelease(now);\n\t\t});\n\t\tthis._activeVoices = [];\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._voices.forEach(v => v.dispose());\n\t\tthis._activeVoices = [];\n\t\tthis._availableVoices = [];\n\t\treturn this;\n\t}\n}\n","import { FrequencyClass } from \"../core/type/Frequency\";\nimport { Frequency, Positive, Time } from \"../core/type/Units\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth, SynthOptions } from \"./Synth\";\n\nexport interface MembraneSynthOptions extends SynthOptions {\n\tpitchDecay: Time;\n\toctaves: Positive;\n}\n\n/**\n * MembraneSynth makes kick and tom sounds using a single oscillator\n * with an amplitude envelope and frequency ramp. A Tone.OmniOscillator\n * is routed through a Tone.AmplitudeEnvelope to the output. The drum\n * quality of the sound comes from the frequency envelope applied\n * during MembraneSynth.triggerAttack(note). The frequency envelope\n * starts at <code>note * .octaves</code> and ramps to <code>note</code>\n * over the duration of <code>.pitchDecay</code>.\n * @param options the options available for the synth see defaults below\n * @example\n * var synth = new MembraneSynth().toMaster();\n * synth.triggerAttackRelease(\"C2\", \"8n\");\n */\nexport class MembraneSynth extends Synth<MembraneSynthOptions> {\n\n\treadonly name = \"MembraneSynth\";\n\n\t/**\n\t *  The number of octaves the pitch envelope ramps.\n\t */\n\toctaves: Positive;\n\n\t/**\n\t *  The amount of time the frequency envelope takes.\n\t */\n\tpitchDecay: Time;\n\n\t/**\n\t * Portamento is ignored in this synth. use pitch decay instead.\n\t */\n\treadonly portamento = 0;\n\n\tconstructor(options?: RecursivePartial<MembraneSynthOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(MembraneSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(MembraneSynth.getDefaults(), arguments);\n\n\t\tthis.pitchDecay = options.pitchDecay;\n\t\tthis.octaves = options.octaves;\n\t\treadOnly(this, [\"oscillator\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): MembraneSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {\n\t\t\tenvelope : {\n\t\t\t\tattack : 0.001,\n\t\t\t\tattackCurve : \"exponential\",\n\t\t\t\tdecay : 0.4,\n\t\t\t\trelease : 1.4,\n\t\t\t\tsustain : 0.01,\n\t\t\t},\n\t\t\toctaves: 10,\n\t\t\toscillator: {\n\t\t\t\ttype: \"sine\",\n\t\t\t},\n\t\t\tpitchDecay: 0.05,\n\t\t});\n\t}\n\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst seconds = this.toSeconds(time);\n\t\tconst hertz = this.toFrequency(note instanceof FrequencyClass ? note.toFrequency() : note);\n\t\tconst maxNote = hertz * this.octaves;\n\t\tthis.oscillator.frequency.setValueAtTime(maxNote, seconds);\n\t\tthis.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\treturn this;\n\t}\n}\n","import \"../core/clock/Transport\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../core/context/ToneWithContext\";\nimport { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline } from \"../core/util/StateTimeline\";\nimport { isBoolean, isNumber } from \"../core/util/TypeCheck\";\n\nexport type ToneEventCallback<T> = (time: Seconds, value: T) => void;\n\nexport interface ToneEventOptions<T> extends ToneWithContextOptions {\n\tcallback: ToneEventCallback<T>;\n\tloop: boolean | number;\n\tloopEnd: Time;\n\tloopStart: Time;\n\tplaybackRate: Positive;\n\tvalue?: T;\n\tprobability: NormalRange;\n\tmute: boolean;\n\thumanize: boolean | Time;\n}\n\n/**\n * ToneEvent abstracts away this.context.transport.schedule and provides a schedulable\n * callback for a single or repeatable events along the timeline.\n *\n * @param callback The callback to invoke at the time.\n * @param value The value or values which should be passed to the callback function on invocation.\n * @example\n * var chord = new ToneEvent(function(time, chord){\n * \t//the chord as well as the exact time of the event\n * \t//are passed in as arguments to the callback function\n * }, [\"D4\", \"E4\", \"F4\"]);\n * //start the chord at the beginning of the transport timeline\n * chord.start();\n * //loop it every measure for 8 measures\n * chord.loop = 8;\n * chord.loopEnd = \"1m\";\n */\nexport class ToneEvent<ValueType = any> extends ToneWithContext<ToneEventOptions<ValueType>> {\n\n\tname = \"ToneEvent\";\n\n\t/**\n\t *  Loop value\n\t */\n\tprotected _loop: boolean | number;\n\n\t/**\n\t *  The callback to invoke.\n\t */\n\tcallback: ToneEventCallback<ValueType>;\n\n\t/**\n\t *  The value which is passed to the\n\t *  callback function.\n\t */\n\tvalue: ValueType;\n\n\t/**\n\t *  When the note is scheduled to start.\n\t */\n\tprotected _loopStart: Ticks;\n\n\t/**\n\t *  When the note is scheduled to start.\n\t */\n\tprotected _loopEnd: Ticks;\n\n\t/**\n\t *  Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number,\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t *  The playback speed of the note. A speed of 1\n\t *  is no change.\n\t */\n\tprotected _playbackRate: Positive;\n\n\t/**\n\t *  A delay time from when the event is scheduled to start\n\t */\n\tprotected _startOffset: Ticks = 0;\n\n\t/**\n\t *  private holder of probability value\n\t */\n\tprotected _probability: NormalRange;\n\n\t/**\n\t *  the amount of variation from the given time.\n\t */\n\tprotected _humanize: boolean | Time;\n\n\t/**\n\t *  If mute is true, the callback won't be invoked.\n\t */\n\tmute: boolean;\n\n\tconstructor(callback?: ToneEventCallback<ValueType>, value?: ValueType);\n\tconstructor(options?: Partial<ToneEventOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]));\n\t\tconst options = optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]);\n\n\t\tthis._loop = options.loop;\n\t\tthis.callback = options.callback;\n\t\tthis.value = options.value;\n\t\tthis._loopStart = this.toTicks(options.loopStart);\n\t\tthis._loopEnd = this.toTicks(options.loopEnd);\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._probability = options.probability;\n\t\tthis._humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): ToneEventOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback : noOp,\n\t\t\thumanize : false,\n\t\t\tloop : false,\n\t\t\tloopEnd : \"1m\",\n\t\t\tloopStart : 0,\n\t\t\tmute : false,\n\t\t\tplaybackRate : 1,\n\t\t\tprobability : 1,\n\t\t\tvalue : null,\n\t\t});\n\t}\n\n\t/**\n\t *  Reschedule all of the events along the timeline\n\t *  with the updated values.\n\t *  @param after Only reschedules events after the given time.\n\t *  @private\n\t */\n\tprivate _rescheduleEvents(after: Ticks = -1): void {\n\t\t// if no argument is given, schedules all of the events\n\t\tthis._state.forEachFrom(after, event => {\n\t\t\tlet duration;\n\t\t\tif (event.state === \"started\") {\n\t\t\t\tif (event.id !== -1) {\n\t\t\t\t\tthis.context.transport.clear(event.id);\n\t\t\t\t}\n\t\t\t\tconst startTick = event.time + Math.round(this.startOffset / this._playbackRate);\n\t\t\t\tif (this._loop === true || isNumber(this._loop) && this._loop > 1) {\n\t\t\t\t\tduration = Infinity;\n\t\t\t\t\tif (isNumber(this._loop)) {\n\t\t\t\t\t\tduration = (this._loop) * this._getLoopDuration();\n\t\t\t\t\t}\n\t\t\t\t\tconst nextEvent = this._state.getAfter(startTick);\n\t\t\t\t\tif (nextEvent !== null) {\n\t\t\t\t\t\tduration = Math.min(duration, nextEvent.time - startTick);\n\t\t\t\t\t}\n\t\t\t\t\tif (duration !== Infinity) {\n\t\t\t\t\t\t// schedule a stop since it's finite duration\n\t\t\t\t\t\tthis._state.setStateAtTime(\"stopped\", startTick + duration + 1, { id : -1 });\n\t\t\t\t\t\tduration = new TicksClass(this.context, duration);\n\t\t\t\t\t}\n\t\t\t\t\tconst interval = new TicksClass(this.context, this._getLoopDuration());\n\t\t\t\t\tevent.id = this.context.transport.scheduleRepeat(\n\t\t\t\t\t\tthis._tick.bind(this), interval, new TicksClass(this.context, startTick), duration);\n\t\t\t\t} else {\n\t\t\t\t\tevent.id = this.context.transport.schedule(this._tick.bind(this), new TicksClass(this.context, startTick));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t *  Returns the playback state of the note, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._state.getValueAtTime(this.context.transport.ticks) as BasicPlaybackState;\n\t}\n\n\t/**\n\t * The start from the scheduled start time.\n\t */\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t}\n\n\t/**\n\t *  The probability of the notes being triggered.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t}\n\n\t/**\n\t *  If set to true, will apply small random variation\n\t *  to the callback time. If the value is given as a time, it will randomize\n\t *  by that amount.\n\t * @example\n\t * event.humanize = true;\n\t */\n\tget humanize(): Time | boolean {\n\t\treturn this._humanize;\n\t}\n\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t}\n\n\t/**\n\t *  Start the note at the given time.\n\t *  @param  time  When the event should start.\n\t */\n\tstart(time?: TransportTime | TransportTimeClass): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) === \"stopped\") {\n\t\t\tthis._state.add({\n\t\t\t\tid : -1,\n\t\t\t\tstate : \"started\",\n\t\t\t\ttime: ticks,\n\t\t\t});\n\t\t\tthis._rescheduleEvents(ticks);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the Event at the given time.\n\t *  @param  time  When the event should stop.\n\t */\n\tstop(time?: TransportTime | TransportTimeClass): this {\n\t\tthis.cancel(time);\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"stopped\", ticks, { id: -1 });\n\t\t\tconst previousEvent = this._state.getBefore(ticks);\n\t\t\tlet reschedulTime = ticks;\n\t\t\tif (previousEvent !== null) {\n\t\t\t\treschedulTime = previousEvent.time;\n\t\t\t}\n\t\t\tthis._rescheduleEvents(reschedulTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel all scheduled events greater than or equal to the given time\n\t *  @param  time  The time after which events will be cancel.\n\t */\n\tcancel(time?: TransportTime | TransportTimeClass): this {\n\t\ttime = defaultArg(time, -Infinity);\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.forEachFrom(ticks, event => {\n\t\t\tthis.context.transport.clear(event.id);\n\t\t});\n\t\tthis._state.cancel(ticks);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The callback function invoker. Also\n\t *  checks if the Event is done playing\n\t *  @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tconst ticks = this.context.transport.getTicksAtTime(time);\n\t\tif (!this.mute && this._state.getValueAtTime(ticks) === \"started\") {\n\t\t\tif (this.probability < 1 && Math.random() > this.probability) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.humanize) {\n\t\t\t\tlet variation = 0.02;\n\t\t\t\tif (!isBoolean(this.humanize)) {\n\t\t\t\t\tvariation = this.toSeconds(this.humanize);\n\t\t\t\t}\n\t\t\t\ttime += (Math.random() * 2 - 1) * variation;\n\t\t\t}\n\t\t\tthis.callback(time, this.value);\n\t\t}\n\t}\n\n\t/**\n\t *  Get the duration of the loop.\n\t */\n\tprotected _getLoopDuration(): Ticks {\n\t\treturn Math.round((this._loopEnd - this._loopStart) / this._playbackRate);\n\t}\n\n\t/**\n\t *  If the note should loop or not\n\t *  between ToneEvent.loopStart and\n\t *  ToneEvent.loopEnd. If set to true,\n\t *  the event will loop indefinitely,\n\t *  if set to a number greater than 1\n\t *  it will play a specific number of\n\t *  times, if set to false, 0 or 1, the\n\t *  part will only play once.\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t * \tThe playback rate of the note. Defaults to 1.\n\t *  @example\n\t * note.loop = true;\n\t * //repeat the note twice as fast\n\t * note.playbackRate = 2;\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t *  The loopEnd point is the time the event will loop\n\t *  if ToneEvent.loop is true.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t *  The time when the loop should start.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t *  The current progress of the loop interval.\n\t *  Returns 0 if the event is not started yet or\n\t *  it is not set to loop.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this._loop) {\n\t\t\tconst ticks = this.context.transport.ticks;\n\t\t\tconst lastEvent = this._state.get(ticks);\n\t\t\tif (lastEvent !== null && lastEvent.state === \"started\") {\n\t\t\t\tconst loopDuration = this._getLoopDuration();\n\t\t\t\tconst progress = (ticks - lastEvent.time) % loopDuration;\n\t\t\t\treturn progress / loopDuration;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.cancel();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n","import { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype CallbackType<T> =\n\tT extends {\n\t\ttime: Time;\n\t\t[key: string]: any,\n\t} ? T :\n\tT extends ArrayLike<any> ? T[1] :\n\tT extends Time ? null : never;\n\ninterface PartOptions<T> extends Omit<ToneEventOptions<CallbackType<T>>, \"value\"> {\n\tevents: T[];\n}\n\n/**\n *  Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n *  @param callback The callback to invoke on each event\n *  @param events the array of events\n *  @example\n * var part = new Part(function(time, note){\n * \t//the notes given as the second element in the array\n * \t//will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }, [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n *  @example\n * //use an array of objects as long as the object has a \"time\" attribute\n * var part = new Part(function(time, value){\n * \t//the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }, [{\"time\" : 0, \"note\" : \"C3\", \"velocity\": 0.9},\n * \t   {\"time\" : \"0:2\", \"note\" : \"C4\", \"velocity\": 0.5}\n * ]).start(0);\n */\nexport class Part<ValueType = any> extends ToneEvent<ValueType> {\n\n\tname = \"Part\";\n\n\t/**\n\t *  Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number,\n\t\toffset: number,\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The events that belong to this part\n\t */\n\tprivate _events: Set<ToneEvent> = new Set();\n\n\tconstructor(options?: Partial<PartOptions<ValueType>>);\n\tconstructor(callback?: ToneEventCallback<CallbackType<ValueType>>, value?: ValueType[]);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]));\n\t\tconst options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]);\n\n\t\t// add the events\n\t\toptions.events.forEach(event => {\n\t\t\tif (isArray(event)) {\n\t\t\t\tthis.add(event[0], event[1]);\n\t\t\t} else {\n\t\t\t\tthis.add(event);\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic getDefaults(): PartOptions<any> {\n\t\treturn Object.assign(ToneEvent.getDefaults(), {\n\t\t\tevents: [],\n\t\t});\n\t}\n\n\t/**\n\t *  Start the part at the given time.\n\t *  @param  time    When to start the part.\n\t *  @param  offset  The offset from the start of the part to begin playing at.\n\t */\n\tstart(time?: TransportTime, offset?: Time): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) !== \"started\") {\n\t\t\toffset = defaultArg(offset, this._loop ? this._loopStart : 0);\n\t\t\tif (this._loop) {\n\t\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t\t} else {\n\t\t\t\toffset = defaultArg(offset, 0);\n\t\t\t}\n\t\t\tconst computedOffset = this.toTicks(offset);\n\t\t\tthis._state.add({\n\t\t\t\tid : -1,\n\t\t\t\toffset: computedOffset,\n\t\t\t\tstate : \"started\",\n\t\t\t\ttime : ticks,\n\t\t\t});\n\t\t\tthis._forEach(event => {\n\t\t\t\tthis._startNote(event, ticks, computedOffset);\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Start the event in the given event at the correct time given\n\t *  the ticks and offset and looping.\n\t *  @param  event\n\t *  @param  ticks\n\t *  @param  offset\n\t */\n\tprivate _startNote(event: ToneEvent, ticks: Ticks, offset: Ticks): void {\n\t\tticks -= offset;\n\t\tif (this._loop) {\n\t\t\tif (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n\t\t\t\tif (event.startOffset < offset) {\n\t\t\t\t\t// start it on the next loop\n\t\t\t\t\tticks += this._getLoopDuration();\n\t\t\t\t}\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t} else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n\t\t\t\tevent.loop = false;\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t}\n\t\t} else if (event.startOffset >= offset) {\n\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t\tthis._forEach(event => {\n\t\t\tevent.startOffset += this._startOffset;\n\t\t});\n\t}\n\n\t/**\n\t *  Stop the part at the given time.\n\t *  @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.cancel(ticks);\n\t\tthis._state.setStateAtTime(\"stopped\", ticks);\n\t\tthis._forEach(event => {\n\t\t\tevent.stop(time);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get/Set an Event's value at the given time.\n\t * If a value is passed in and no event exists at\n\t * the given time, one will be created with that value.\n\t * If two events are at the same time, the first one will\n\t * be returned.\n\t * @example\n\t * part.at(\"1m\"); //returns the part at the first measure\n\t * part.at(\"2m\", \"C2\"); //set the value at \"2m\" to C2.\n\t * //if an event didn't exist at that time, it will be created.\n\t * @param time The time of the event to get or set.\n\t * @param value If a value is passed in, the value of the event at the given time will be set to it.\n\t */\n\tat(time: Time, value?: any): ToneEvent | null {\n\t\tconst timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n\t\tconst tickTime = new TicksClass(this.context, 1).toSeconds();\n\n\t\tconst iterator = this._events.values();\n\t\tlet result = iterator.next();\n\t\twhile (!result.done) {\n\t\t\tconst event = result.value;\n\t\t\tif (Math.abs(timeInTicks - event.startOffset) < tickTime) {\n\t\t\t\tif (isDefined(value)) {\n\t\t\t\t\tevent.value = value;\n\t\t\t\t}\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tresult = iterator.next();\n\t\t}\n\t\t// if there was no event at that time, create one\n\t\tif (isDefined(value)) {\n\t\t\tthis.add(time, value);\n\t\t\t// return the new event\n\t\t\treturn this.at(time);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Add a an event to the part.\n\t *  @param time The time the note should start. If an object is passed in, it should\n\t *  \t\t\thave a 'time' attribute and the rest of the object will be used as the 'value'.\n\t *  @param  value\n\t * @example\n\t * part.add(\"1m\", \"C#+11\");\n\t * @example\n\t * part.add({\n\t * \ttime: \"1m\",\n\t * \tnote: \"C#11\"\n\t * });\n\t */\n\tadd(obj: {\n\t\ttime: Time,\n\t\t[key: string]: any;\n\t}): this;\n\tadd(time: Time, value?: any): this;\n\tadd(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (time instanceof Object && Reflect.has(time, \"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\tconst ticks = this.toTicks(time);\n\t\tlet event: ToneEvent;\n\t\tif (value instanceof ToneEvent) {\n\t\t\tevent = value;\n\t\t\tevent.callback = this._tick.bind(this);\n\t\t} else {\n\t\t\tevent = new ToneEvent({\n\t\t\t\tcallback : this._tick.bind(this),\n\t\t\t\tcontext: this.context,\n\t\t\t\tvalue,\n\t\t\t});\n\t\t}\n\t\t// the start offset\n\t\tevent.startOffset = ticks;\n\n\t\t// initialize the values\n\t\tevent.set({\n\t\t\thumanize : this.humanize,\n\t\t\tloop : this.loop,\n\t\t\tloopEnd : this.loopEnd,\n\t\t\tloopStart : this.loopStart,\n\t\t\tplaybackRate : this.playbackRate,\n\t\t\tprobability : this.probability,\n\t\t});\n\n\t\tthis._events.add(event);\n\n\t\t// start the note if it should be played right now\n\t\tthis._restartEvent(event);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Restart the given event\n\t */\n\tprivate _restartEvent(event: ToneEvent): void {\n\t\tthis._state.forEach((stateEvent) => {\n\t\t\tif (stateEvent.state === \"started\") {\n\t\t\t\tthis._startNote(event, stateEvent.time, stateEvent.offset);\n\t\t\t} else {\n\t\t\t\t// stop the note\n\t\t\t\tevent.stop(new TicksClass(this.context, stateEvent.time));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t *  Remove an event from the part. If the event at that time is a Part,\n\t *  it will remove the entire part.\n\t *  @param time The time of the event\n\t *  @param value Optionally select only a specific event value\n\t */\n\tremove(obj: {\n\t\ttime: Time,\n\t\t[key: string]: any;\n\t}): this;\n\tremove(time: Time, value?: any): this;\n\tremove(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (isObject(time) && time.hasOwnProperty(\"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\ttime = this.toTicks(time);\n\t\tthis._events.forEach(event => {\n\t\t\tif (event.startOffset === time) {\n\t\t\t\tif (isUndef(value) || (isDefined(value) && event.value === value)) {\n\t\t\t\t\tthis._events.delete(event);\n\t\t\t\t\tevent.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove all of the notes from the group.\n\t */\n\tclear(): this {\n\t\tthis._forEach(event => event.dispose());\n\t\tthis._events.clear();\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n\t *  @param after The time after which to cancel the scheduled events.\n\t */\n\tcancel(after?: TransportTime | TransportTimeClass): this {\n\t\tthis._forEach(event => event.cancel(after));\n\t\tthis._state.cancel(this.toTicks(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over all of the events\n\t */\n\tprivate _forEach(callback: (event: ToneEvent) => void): this {\n\t\tif (this._events) {\n\t\t\tthis._events.forEach(event => {\n\t\t\t\tif (event instanceof Part) {\n\t\t\t\t\tevent._forEach(callback);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Set the attribute of all of the events\n\t *  @param  attr  the attribute to set\n\t *  @param  value      The value to set it to\n\t */\n\tprivate _setAll(attr: string, value: any): void {\n\t\tthis._forEach(event => {\n\t\t\tevent[attr] = value;\n\t\t});\n\t}\n\n\t/**\n\t *  Internal tick method\n\t *  @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds, value?: any): void {\n\t\tif (!this.mute) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t *  Determine if the event should be currently looping\n\t *  given the loop boundries of this Part.\n\t *  @param  event  The event to test\n\t */\n\tprivate _testLoopBoundries(event: ToneEvent): void {\n\t\tif (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n\t\t\tevent.cancel(0);\n\t\t} else if (event.state === \"stopped\") {\n\t\t\t// reschedule it if it's stopped\n\t\t\tthis._restartEvent(event);\n\t\t}\n\t}\n\n\t/**\n\t *  The probability of the notes being triggered.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t\tthis._setAll(\"probability\", prob);\n\t}\n\n\t/**\n\t * If set to true, will apply small random variation\n\t * to the callback time. If the value is given as a time, it will randomize\n\t * by that amount.\n\t * @example\n\t * event.humanize = true;\n\t */\n\tget humanize(): boolean | Time {\n\t\treturn this._humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t\tthis._setAll(\"humanize\", variation);\n\t}\n\n\t/**\n\t * If the part should loop or not\n\t * between Part.loopStart and\n\t * Part.loopEnd. If set to true,\n\t * the part will loop indefinitely,\n\t * if set to a number greater than 1\n\t * it will play a specific number of\n\t * times, if set to false, 0 or 1, the\n\t * part will only play once.\n\t * @example\n\t * //loop the part 8 times\n\t * part.loop = 8;\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._forEach(event => {\n\t\t\tevent.loopStart = this.loopStart;\n\t\t\tevent.loopEnd = this.loopEnd;\n\t\t\tevent.loop = loop;\n\t\t\tthis._testLoopBoundries(event);\n\t\t});\n\t}\n\n\t/**\n\t *  The loopEnd point determines when it will\n\t *  loop if Part.loop is true.\n\t *  @memberOf Part#\n\t *  @type {Time}\n\t *  @name loopEnd\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopEnd = loopEnd;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t *  The loopStart point determines when it will\n\t *  loop if Part.loop is true.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopStart = this.loopStart;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * \tThe playback rate of the part\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._setAll(\"playbackRate\", rate);\n\t}\n\n\t/**\n\t * \tThe number of scheduled notes in the part.\n\t */\n\tget length(): number {\n\t\treturn this._events.size;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.clear();\n\t\treturn this;\n\t}\n}\n","import { TicksClass } from \"../core/type/Ticks\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype SequenceEventDescription<T> = Array<T | T[]>;\n\ninterface SequenceOptions<T> extends Omit<ToneEventOptions<T>, \"value\"> {\n\tloopStart: number;\n\tloopEnd: number;\n\tsubdivision: Time;\n\tevents: SequenceEventDescription<T>;\n}\n\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @param  callback  The callback to invoke with every note\n * @param  sequence  The sequence\n * @param  subdivision  The subdivision between which events are placed.\n * @example\n * var seq = new Sequence(function(time, note){\n * \tconsole.log(note);\n * //straight quater notes\n * }, [\"C4\", \"E4\", \"G4\", \"A4\"], \"4n\");\n * @example\n * var seq = new Sequence(function(time, note){\n * \tconsole.log(note);\n * //subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]);\n */\nexport class Sequence<ValueType = any> extends ToneEvent<ValueType> {\n\n\tname = \"Sequence\";\n\n\t/**\n\t *  The subdivison of each note\n\t */\n\tprivate _subdivision: Ticks;\n\n\t/**\n\t * The object responsible for scheduling all of the events\n\t */\n\tprivate _part: Part = new Part({\n\t\tcallback: this._seqCallback.bind(this),\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * private reference to all of the sequence proxies\n\t */\n\tprivate _events: ValueType[] = [];\n\n\t/**\n\t * The proxied array\n\t */\n\tprivate _eventsArray: ValueType[] = [];\n\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tevents?: SequenceEventDescription<ValueType>,\n\t\tsubdivision?: Time,\n\t);\n\tconstructor(options?: Partial<SequenceOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n\t\tconst options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n\n\t\tthis._subdivision = this.toTicks(options.subdivision);\n\n\t\tthis.events = options.events;\n\n\t\t// set all of the values\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.probability = options.probability;\n\t\tthis.humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): SequenceOptions<any> {\n\t\treturn Object.assign( omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n\t\t\tevents: [],\n\t\t\tloop: true,\n\t\t\tloopEnd : 0,\n\t\t\tloopStart: 0,\n\t\t\tsubdivision: \"8n\",\n\t\t});\n\t}\n\n\t/**\n\t * The internal callback for when an event is invoked\n\t */\n\tprivate _seqCallback(time: Seconds, value: any): void {\n\t\tif (value !== null) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * The sequence\n\t */\n\tget events(): any[] {\n\t\treturn this._events;\n\t}\n\tset events(s) {\n\t\tthis.clear();\n\t\tthis._eventsArray = s;\n\t\tthis._events = this._createSequence(this._eventsArray);\n\t\tthis._eventsUpdated();\n\t}\n\n\t/**\n\t *  Start the part at the given time.\n\t *  @param  time    When to start the part.\n\t *  @param  offset  The offset index to start at\n\t */\n\tstart(time?: TransportTime, offset?: number): this {\n\t\tthis._part.start(time, offset ? this._indexTime(offset) : offset);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the part at the given time.\n\t *  @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._part.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The subdivision of the sequence. This can only be\n\t *  set in the constructor. The subdivision is the\n\t *  interval between successive steps.\n\t */\n\tget subdivision(): Seconds {\n\t\treturn new TicksClass(this.context, this._subdivision).toSeconds();\n\t}\n\n\t/**\n\t * Create a sequence proxy which can be monitored to create subsequences\n\t */\n\tprivate _createSequence(array: any[]): any[] {\n\t\treturn new Proxy(array, {\n\t\t\tget: (target: any[], property: PropertyKey): any => {\n\t\t\t\t// property is index in this case\n\t\t\t\treturn target[property];\n\t\t\t},\n\t\t\tset: (target: any[], property: PropertyKey, value: any): boolean => {\n\t\t\t\tif (isString(property) && isFinite(parseInt(property, 10))) {\n\t\t\t\t\tconst index = parseInt(property, 10);\n\t\t\t\t\tif (isArray(value)) {\n\t\t\t\t\t\ttarget[property] = this._createSequence(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttarget[property] = value;\n\t\t\t\t}\n\t\t\t\tthis._eventsUpdated();\n\t\t\t\t// return true to accept the changes\n\t\t\t\treturn true;\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * When the sequence has changed, all of the events need to be recreated\n\t */\n\tprivate _eventsUpdated(): void {\n\t\tthis._part.clear();\n\t\tthis._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);\n\t\t// update the loopEnd\n\t\tthis.loopEnd = this.loopEnd;\n\t}\n\n\t/**\n\t * reschedule all of the events that need to be rescheduled\n\t */\n\tprivate _rescheduleSequence(sequence: any[], subdivision: Ticks, startOffset: Ticks): void {\n\t\tsequence.forEach((value, index) => {\n\t\t\tconst eventOffset = index * (subdivision) + startOffset;\n\t\t\tif (isArray(value)) {\n\t\t\t\tthis._rescheduleSequence(value, subdivision / value.length, eventOffset);\n\t\t\t} else {\n\t\t\t\tconst startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n\t\t\t\tthis._part.add(startTime, value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t *  Get the time of the index given the Sequence's subdivision\n\t *  @param  index\n\t *  @return The time of that index\n\t *  @private\n\t */\n\tprivate _indexTime(index: number): Seconds {\n\t\treturn new TicksClass(this.context, index * (this._subdivision) + this.startOffset).toSeconds();\n\t}\n\n\t/**\n\t * Clear all of the events\n\t */\n\tclear(): this {\n\t\tthis._part.clear();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._part.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// PROXY CALLS\n\t///////////////////////////////////////////////////////////////////////////\n\n\tget loop(): boolean | number {\n\t\treturn this._part.loop;\n\t}\n\tset loop(l) {\n\t\tif (this._part) {\n\t\t\tthis._part.loop = l;\n\t\t}\n\t}\n\n\t/**\n\t * The index at which the sequence should start looping\n\t */\n\tget loopStart(): number {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(index) {\n\t\tthis._loopStart = index;\n\t\tif (this._part) {\n\t\t\tthis._part.loopStart = this._indexTime(index);\n\t\t}\n\t}\n\n\t/**\n\t * The index at which the sequence should end looping\n\t */\n\tget loopEnd(): number {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(index) {\n\t\tthis._loopEnd = index;\n\t\tif (this._part) {\n\t\t\tif (index === 0) {\n\t\t\t\tthis._part.loopEnd = this._indexTime(this._eventsArray.length);\n\t\t\t} else {\n\t\t\t\tthis._part.loopEnd = this._indexTime(index);\n\t\t\t}\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._part.startOffset;\n\t}\n\tset startOffset(start) {\n\t\tif (this._part) {\n\t\t\tthis._part.startOffset = start;\n\t\t}\n\t}\n\n\tget playbackRate(): Positive {\n\t\treturn this._part.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tif (this._part) {\n\t\t\tthis._part.playbackRate = rate;\n\t\t}\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._part.probability;\n\t}\n\tset probability(prob) {\n\t\tif (this._part) {\n\t\t\tthis._part.probability = prob;\n\t\t}\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._part.humanize;\n\t}\n\tset humanize(variation) {\n\t\tif (this._part) {\n\t\t\tthis._part.humanize = variation;\n\t\t}\n\t}\n\n\t/**\n\t * The number of scheduled events\n\t */\n\tget length(): number {\n\t\treturn this._part.length;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { connect, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { GainToAudio } from \"../../signal/GainToAudio\";\nimport { Signal } from \"../../signal/Signal\";\n\ninterface CrossFadeOptions extends ToneAudioNodeOptions {\n\tfade: NormalRange;\n}\n\n/**\n * Tone.Crossfade provides equal power fading between two inputs.\n * More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).\n * ```\n *                                             +---------+\n *                                            +> input a +>--+\n * +-----------+   +---------------------+     |         |   |\n * | 1s signal +>--> stereoPannerNode  L +>----> gain    |   |\n * +-----------+   |                     |     +---------+   |\n *               +-> pan               R +>-+                |   +--------+\n *               | +---------------------+  |                +---> output +>\n *  +------+     |                          |  +---------+   |   +--------+\n *  | fade +>----+                          | +> input b +>--+\n *  +------+                                |  |         |\n *                                          +--> gain    |\n *                                             +---------+\n * ```\n * @example\n * var crossFade = new CrossFade(0.5);\n * //connect effect A to crossfade from\n * //effect output 0 to crossfade input 0\n * effectA.connect(crossFade.a);\n * //connect effect B to crossfade from\n * //effect output 0 to crossfade input 1\n * effectB.connect(crossFade.b);\n * crossFade.fade.value = 0;\n * // ^ only effectA is output\n * crossFade.fade.value = 1;\n * // ^ only effectB is output\n * crossFade.fade.value = 0.5;\n * // ^ the two signals are mixed equally.\n */\nexport class CrossFade extends ToneAudioNode<CrossFadeOptions> {\n\n\treadonly name = \"CrossFade\";\n\n\t/**\n\t * The crossfading is done by a StereoPannerNode\n\t */\n\tprivate _panner: StereoPannerNode = this.context.createStereoPanner();\n\n\t/**\n\t * Split the output of the panner node into two values used to control the gains.\n\t */\n\tprivate _split: ChannelSplitterNode = this.context.createChannelSplitter(2);\n\n\t/**\n\t * Convert the fade value into an audio range value so it can be connected\n\t * to the panner.pan AudioParam\n\t */\n\tprivate _g2a: GainToAudio = new GainToAudio({ context : this.context });\n\n\t/**\n\t * The input which is at full level when fade = 0\n\t */\n\ta: Gain = new Gain({\n\t\tcontext : this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The input which is at full level when fade = 1\n\t */\n\tb: Gain = new Gain({\n\t\tcontext : this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The output is a mix between `a` and `b` at the ratio of `fade`\n\t */\n\toutput: Gain = new Gain({ context : this.context });\n\n\t/**\n\t * CrossFade has no input, you must choose either `a` or `b`\n\t */\n\tinput: undefined;\n\n\t/**\n\t * \tThe mix between the two inputs. A fade value of 0\n\t * \twill output 100% crossFade.a and\n\t * \ta value of 1 will output 100% crossFade.b.\n\t */\n\treadonly fade: Signal<NormalRange>;\n\n\tprotected _internalChannels = [this.a, this.b];\n\n\tconstructor(options?: Partial<CrossFadeOptions>);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(fade?: NormalRange);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"])));\n\t\tconst options = optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"]);\n\n\t\tthis.fade = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"normalRange\",\n\t\t\tvalue: options.fade,\n\t\t});\n\t\treadOnly(this, \"fade\");\n\n\t\tthis.context.getConstant(1).connect(this._panner);\n\t\tthis._panner.connect(this._split);\n\t\tconnect(this._split, this.a.gain, 0);\n\t\tconnect(this._split, this.b.gain, 1);\n\n\t\tthis.fade.chain(this._g2a, this._panner.pan);\n\n\t\tthis.a.connect(this.output);\n\t\tthis.b.connect(this.output);\n\t}\n\n\tstatic getDefaults(): CrossFadeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tfade: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.a.dispose();\n\t\tthis.b.dispose();\n\t\tthis.output.dispose();\n\t\tthis.fade.dispose();\n\t\tthis._g2a.dispose();\n\t\tthis._panner.disconnect();\n\t\tthis._split.disconnect();\n\t\treturn this;\n\t}\n}\n","import { CrossFade } from \"../component/channel/CrossFade\";\nimport { Gain } from \"../core/context/Gain\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\n\nexport interface EffectOptions extends ToneAudioNodeOptions {\n\twet: NormalRange;\n}\n/**\n * \t@class  Effect is the base class for effects. Connect the effect between\n * \t        the effectSend and effectReturn GainNodes, then control the amount of\n * \t        effect which goes to the output using the wet control.\n *\n *  @constructor\n *  @extends {Tone.AudioNode}\n *  @param {NormalRange|Object} [wet] The starting wet value.\n */\nexport abstract class Effect<Options extends EffectOptions>\nextends ToneAudioNode<Options> {\n\n\treadonly name: string = \"Effect\";\n\n\t/**\n\t *  the drywet knob to control the amount of effect\n\t */\n\tprivate _dryWet: CrossFade = new CrossFade({ context : this.context });\n\n\t/**\n\t *  The wet control is how much of the effected\n\t *  will pass through to the output. 1 = 100% effected\n\t *  signal, 0 = 100% dry signal.\n\t */\n\twet: Signal<NormalRange> = this._dryWet.fade;\n\n\t/**\n\t *  connect the effectSend to the input of hte effect\n\t */\n\tprotected effectSend: Gain = new Gain({ context : this.context });\n\n\t/**\n\t *  connect the output of the effect to the effectReturn\n\t */\n\tprotected effectReturn: Gain = new Gain({ context : this.context });\n\n\t/**\n\t * The effect input node\n\t */\n\tinput: Gain = new Gain({ context : this.context });\n\n\t/**\n\t * The effect output\n\t */\n\toutput = this._dryWet;\n\n\tconstructor(options: EffectOptions) {\n\t\tsuper(options);\n\n\t\t// connections\n\t\tthis.input.fan(this._dryWet.a, this.effectSend);\n\t\tthis.effectReturn.connect(this._dryWet.b);\n\t\tthis.wet.setValueAtTime(options.wet, 0);\n\t\tthis._internalChannels = [this.effectReturn, this.effectSend];\n\t\treadOnly(this, \"wet\");\n\t}\n\n\tstatic getDefaults(): EffectOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\twet : 1,\n\t\t});\n\t}\n\n\t/**\n\t *  chains the effect in between the effectSend and effectReturn\n\t */\n\tprotected connectEffect(effect: ToneAudioNode | AudioNode): this {\n\t\t// add it to the internal channels\n\t\tthis._internalChannels.push(effect);\n\t\tthis.effectSend.chain(effect, this.effectReturn);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dryWet.dispose();\n\t\tthis.effectSend.dispose();\n\t\tthis.effectReturn.dispose();\n\t\tthis.wet.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\nexport interface FeedbackEffectOptions extends EffectOptions {\n\t/**\n\t * The feedback from the output back to the input\n\t * ```\n\t * +---<--------<---+\n\t * |                |\n\t * |  +----------+  |\n\t * +--> feedback +>-+\n\t *    +----------+\n\t * ```\n\t */\n\tfeedback: NormalRange;\n}\n\n/**\n * FeedbackEffect provides a loop between an audio source and its own output.\n * This is a base-class for feedback effects.\n */\nexport abstract class FeedbackEffect<Options extends FeedbackEffectOptions> extends Effect<Options> {\n\n\tname = \"FeedbackEffect\";\n\n\t/**\n\t *  the gain which controls the feedback\n\t */\n\tprivate _feedbackGain: Gain<NormalRange>;\n\n\t/**\n\t *  The amount of signal which is fed back into the effect input.\n\t */\n\tfeedback: Param<NormalRange>;\n\n\tconstructor(options: FeedbackEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis._feedbackGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.feedback,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\n\t\tthis.feedback = this._feedbackGain.gain;\n\t\treadOnly(this, \"feedback\");\n\n\t\t// the feedback loop\n\t\tthis.effectReturn.chain(this._feedbackGain, this.effectSend);\n\t}\n\n\tstatic getDefaults(): FeedbackEffectOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfeedback: 0.125,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._feedbackGain.dispose();\n\t\tthis.feedback.dispose();\n\t\treturn this;\n\t}\n}\n","import { Delay } from \"../core/context/Delay\";\nimport { Param } from \"../core/context/Param\";\nimport { NormalRange, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { FeedbackEffect,  FeedbackEffectOptions } from \"./FeedbackEffect\";\n\ninterface FeedbackDelayOptions extends FeedbackEffectOptions {\n\tdelayTime: Time;\n\tmaxDelay: Time;\n}\n\n/**\n * FeedbackDelay is a DelayNode in which part of output signal is fed back into the delay.\n *\n * @param delayTime The delay applied to the incoming signal.\n * @param feedback The amount of the effected signal which is fed back through the delay.\n * @example\n * var feedbackDelay = new FeedbackDelay(\"8n\", 0.5).toDestination();\n * var tom = new Tone.MembraneSynth({\n * \t\"octaves\" : 4,\n * \t\"pitchDecay\" : 0.1\n * }).connect(feedbackDelay);\n * tom.triggerAttackRelease(\"A2\",\"32n\");\n */\nexport class FeedbackDelay extends FeedbackEffect<FeedbackDelayOptions> {\n\n\tname = \"FeedbackDelay\";\n\n\t/**\n\t *  the delay node\n\t */\n\tprivate _delayNode: Delay;\n\n\t/**\n\t *  The delayTime of the FeedbackDelay.\n\t */\n\treadonly delayTime: Param<Time>;\n\n\tconstructor(delayTime?: Time, feedback?: NormalRange);\n\tconstructor(options?: Partial<FeedbackDelayOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]));\n\t\tconst options = optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]);\n\n\t\tthis._delayNode = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: options.delayTime,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis.delayTime = this._delayNode.delayTime;\n\n\t\t// connect it up\n\t\tthis.connectEffect(this._delayNode);\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): FeedbackDelayOptions {\n\t\treturn Object.assign(FeedbackEffect.getDefaults(), {\n\t\t\tdelayTime: 0.25,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.dispose();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\ninterface ToneConvolverOptions extends EffectOptions {\n\tonload: () => void;\n\tnormalize: boolean;\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n}\n\n/**\n * Convolver is a wrapper around the Native Web Audio\n * [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).\n * Convolution is useful for reverb and filter emulation. Read more about convolution reverb on\n * [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).\n *\n * @param url The URL of the impulse response or the Tone.Buffer contianing the impulse response.\n * @param onload The callback to invoke when the url is loaded.\n * @example\n * //initializing the convolver with an impulse response\n * var convolver = new Convolver(\"./path/to/ir.wav\").toDestination();\n */\nexport class Convolver extends Effect<ToneConvolverOptions> {\n\n\tname = \"Convolver\";\n\n\t/**\n\t *  The native ConvolverNode\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t *  The Buffer belonging to the convolver\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<ToneConvolverOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Convolver.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(Convolver.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis._buffer = new ToneAudioBuffer(options.url, buffer => {\n\t\t\tthis.buffer = buffer;\n\t\t\toptions.onload();\n\t\t});\n\n\t\t// set if it's already loaded\n\t\tif (this._buffer.loaded) {\n\t\t\tthis.buffer = this._buffer;\n\t\t}\n\n\t\t// initially set normalization\n\t\tthis.normalize = options.normalize;\n\n\t\t// connect it up\n\t\tthis.connectEffect(this._convolver);\n\t}\n\n\tstatic getDefaults(): ToneConvolverOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tnormalize : true,\n\t\t\tonload : noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Load an impulse response url as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<void> {\n\t\tthis.buffer = await this._buffer.load(url);\n\t}\n\n\t/**\n\t *  The convolver's buffer\n\t */\n\tget buffer(): ToneAudioBuffer | null {\n\t\tif (this._buffer.length) {\n\t\t\treturn this._buffer;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tset buffer(buffer) {\n\t\tif (buffer) {\n\t\t\tthis._buffer.set(buffer);\n\t\t}\n\t\t// if it's already got a buffer, create a new one\n\t\tif (this._convolver.buffer) {\n\t\t\t// disconnect the old one\n\t\t\tthis.effectSend.disconnect();\n\t\t\tthis._convolver.disconnect();\n\t\t\t// create and connect a new one\n\t\t\tthis._convolver = this.context.createConvolver();\n\t\t\tthis.connectEffect(this._convolver);\n\t\t}\n\t\tconst buff = this._buffer.get();\n\t\tthis._convolver.buffer = buff ? buff : null;\n\t}\n\n\t/**\n\t * The normalize property of the ConvolverNode interface is a boolean that\n\t * controls whether the impulse response from the buffer will be scaled by\n\t * an equal-power normalization when the buffer attribute is set, or not.\n\t */\n\tget normalize(): boolean {\n\t\treturn this._convolver.normalize;\n\t}\n\tset normalize(norm) {\n\t\tthis._convolver.normalize = norm;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\ninterface MergeOptions extends ToneAudioNodeOptions {\n\tchannels: Positive;\n}\n\n/**\n * Merge brings multiple mono input channels into a single multichannel output channel.\n *\n * @param channels The number of channels to merge.\n * @example\n * var merge = new Merge().toDestination();\n * //routing a sine tone in the left channel\n * //and noise in the right channel\n * var osc = new Tone.Oscillator().connect(merge.left);\n * var noise = new Tone.Noise().connect(merge.right);\n * //starting our oscillators\n * noise.start();\n * osc.start();\n */\nexport class Merge extends ToneAudioNode<MergeOptions> {\n\n\treadonly name = \"Merge\";\n\n\t/**\n\t *  The merger node for the two channels.\n\t */\n\tprivate _merger: ChannelMergerNode;\n\n\t/**\n\t * The output is the input channels combined into a sigle (multichannel) output\n\t */\n\treadonly output: ChannelMergerNode;\n\n\t/**\n\t * Multiple input connections combine into a single output.\n\t */\n\treadonly input: ChannelMergerNode;\n\n\tconstructor(channels?: Positive);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<MergeOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]));\n\t\tconst options = optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]);\n\n\t\tthis._merger = this.output = this.input = this.context.createChannelMerger(options.channels);\n\t}\n\n\tstatic getDefaults(): MergeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannels: 2,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._merger.disconnect();\n\t\treturn this;\n\t}\n}\n","import { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Offline } from \"../core/context/Offline\";\nimport { Seconds } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\ninterface ReverbOptions extends EffectOptions {\n\tdecay: Seconds;\n\tpreDelay: Seconds;\n}\n\n/**\n *  Simple convolution created with decaying noise.\n *  Generates an Impulse Response Buffer\n * \twith Tone.Offline then feeds the IR into ConvolverNode.\n * \tNote: the Reverb will not make any sound until [generate](#generate)\n * \thas been invoked and resolved.\n *\n * \tInspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * \tCopyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n *  @param decay The amount of time it will reverberate for.\n */\nexport class Reverb extends Effect<ReverbOptions> {\n\n\treadonly name = \"Reverb\";\n\n\t/**\n\t *  Convolver node\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The duration of the reverb\n\t */\n\tdecay: Seconds;\n\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tpreDelay: Seconds;\n\n\tconstructor(decay?: Seconds);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<ReverbOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n\t\tconst options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n\n\t\tthis.decay = options.decay;\n\t\tthis.preDelay = options.preDelay;\n\n\t\tthis.connectEffect(this._convolver);\n\t}\n\n\tstatic getDefaults(): ReverbOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdecay : 1.5,\n\t\t\tpreDelay : 0.01,\n\t\t});\n\t}\n\n\t/**\n\t * Generate the Impulse Response. Returns a promise while the IR is being generated.\n\t * @return Promise which returns this object.\n\t */\n\tasync generate(): Promise<this> {\n\t\tconst buffer = await Offline((context) => {\n\t\t\t// create a noise burst which decays over the duration\n\t\t\tconst noiseL = new Noise({ context });\n\t\t\tconst noiseR = new Noise({ context });\n\t\t\tconst merge = new Merge({ context });\n\t\t\tnoiseL.connect(merge, 0, 0);\n\t\t\tnoiseR.connect(merge, 0, 1);\n\t\t\tconst gainNode = new Gain({ context }).toDestination();\n\t\t\tmerge.connect(gainNode);\n\t\t\tnoiseL.start(0);\n\t\t\tnoiseR.start(0);\n\t\t\t// predelay\n\t\t\tgainNode.gain.setValueAtTime(0, 0);\n\t\t\tgainNode.gain.setValueAtTime(1, this.preDelay);\n\t\t\t// decay\n\t\t\tgainNode.gain.exponentialApproachValueAtTime(0, this.preDelay, this.decay);\n\t\t}, this.decay + this.preDelay);\n\t\tthis._convolver.buffer = buffer.get() as AudioBuffer;\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, PowerOfTwo } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\ntype AnalyserType = \"fft\" | \"waveform\";\n\ninterface AnalyserOptions extends ToneAudioNodeOptions {\n\tsize: PowerOfTwo;\n\ttype: AnalyserType;\n\tsmoothing: NormalRange;\n}\n\n/**\n *  Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n *  Extracts FFT or Waveform data from the incoming signal.\n *  @param type The return type of the analysis, either \"fft\", or \"waveform\".\n *  @param size The size of the FFT. This must be a power of two in the range 16 to 16384.\n */\nexport class Analyser extends ToneAudioNode<AnalyserOptions> {\n\n\treadonly name = \"Analyser\";\n\n\tinput: AnalyserNode;\n\toutput: AnalyserNode;\n\n\t/**\n\t *  The analyser node.\n\t */\n\tprivate _analyser = this.context.createAnalyser();\n\n\t/**\n\t *  The analysis type\n\t */\n\tprivate _type!: AnalyserType;\n\n\t/**\n\t *  The buffer that the FFT data is written to\n\t */\n\tprivate _buffer!: Float32Array;\n\n\tconstructor(type?: AnalyserType, size?: number);\n\tconstructor(options?: Partial<AnalyserOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]));\n\t\tconst options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n\t\t// set the values initially\n\t\tthis.size = options.size;\n\t\tthis.type = options.type;\n\t\tthis.input = this.output = this._analyser;\n\t}\n\n\tstatic getDefaults(): AnalyserOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsize: 1024,\n\t\t\tsmoothing: 0.8,\n\t\t\ttype: \"fft\" as AnalyserType,\n\t\t});\n\t}\n\n\t/**\n\t *  Run the analysis given the current settings and return the\n\t */\n\tgetValue(): Float32Array {\n\t\tif (this._type === \"fft\") {\n\t\t\tthis._analyser.getFloatFrequencyData(this._buffer);\n\t\t} else if (this._type === \"waveform\") {\n\t\t\tthis._analyser.getFloatTimeDomainData(this._buffer);\n\t\t}\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t *  The size of analysis. This must be a power of two in the range 16 to 16384.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analyser.frequencyBinCount;\n\t}\n\tset size(size: PowerOfTwo) {\n\t\tthis._analyser.fftSize = size * 2;\n\t\tthis._buffer = new Float32Array(size);\n\t}\n\n\t/**\n\t *  The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n\t */\n\tget type(): AnalyserType {\n\t\treturn this._type;\n\t}\n\tset type(type: AnalyserType) {\n\t\tthis.assert(type === \"waveform\" || type === \"fft\", `Analyser: invalid type: ${type}`);\n\t\tthis._type = type;\n\t}\n\n\t/**\n\t *  0 represents no time averaging with the last analysis frame.\n\t */\n\tget smoothing(): NormalRange {\n\t\treturn this._analyser.smoothingTimeConstant;\n\t}\n\n\tset smoothing(val: NormalRange) {\n\t\tthis._analyser.smoothingTimeConstant = val;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analyser.disconnect();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Cents, Decibels, Frequency, GainFactor, Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { isNumber } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\n\ninterface FilterOptions extends ToneAudioNodeOptions {\n\ttype: BiquadFilterType;\n\tfrequency: Frequency;\n\trolloff: number;\n\tQ: Positive;\n\tdetune: Cents;\n\tgain: GainFactor;\n}\n\n/**\n *  @class  Tone.Filter is a filter which allows for all of the same native methods\n *          as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface).\n *          Tone.Filter has the added ability to set the filter rolloff at -12\n *          (default), -24 and -48.\n *\n *  @constructor\n *  @extends {Tone.AudioNode}\n *  @param frequency The cutoff frequency of the filter.\n *  @param type The type of filter.\n *  @param rolloff The drop in decibels per octave after the cutoff frequency\n *  @example\n *  var filter = new Filter(200, \"highpass\");\n */\nexport class Filter extends ToneAudioNode<FilterOptions> {\n\n\treadonly name = \"Filter\";\n\n\treadonly input = new Gain({ context: this.context });\n\treadonly output = new Gain({ context: this.context });\n\tprivate _filters: BiquadFilterNode[] = [];\n\n\t/**\n\t *  the rolloff value of the filter\n\t */\n\tprivate _rolloff!: number;\n\tprivate _type: BiquadFilterType;\n\n\t/**\n\t *  The Q or Quality of the filter\n\t */\n\treadonly Q: Signal<Positive>;\n\n\t/**\n\t *  The cutoff frequency of the filter.\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune parameter\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t *  The gain of the filter, only used in certain filter types\n\t */\n\treadonly gain: Signal<Decibels>;\n\n\tconstructor(frequency?: Frequency, type?: BiquadFilterType, rolloff?: number);\n\tconstructor(options?: Partial<FilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Filter.getDefaults(), arguments, [\"frequency\", \"type\", \"rolloff\"]));\n\t\tconst options = optionsFromArguments(Filter.getDefaults(), arguments, [\"frequency\", \"type\", \"rolloff\"]);\n\n\t\tthis._filters = [];\n\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.Q,\n\t\t});\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\tthis.gain = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"decibels\",\n\t\t\tvalue: options.gain,\n\t\t});\n\t\tthis._type = options.type;\n\t\tthis.rolloff = options.rolloff;\n\t\treadOnly(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): FilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\tdetune: 0,\n\t\t\tfrequency: 350,\n\t\t\tgain: 0,\n\t\t\trolloff: -12,\n\t\t\ttype: \"lowpass\" as BiquadFilterType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the filter. Types: \"lowpass\", \"highpass\",\n\t * \"bandpass\", \"lowshelf\", \"highshelf\", \"notch\", \"allpass\", or \"peaking\".\n\t */\n\tget type(): BiquadFilterType {\n\t\treturn this._type;\n\t}\n\tset type(type: BiquadFilterType) {\n\t\tconst types: BiquadFilterType[] = [\"lowpass\", \"highpass\", \"bandpass\",\n\t\t\t\"lowshelf\", \"highshelf\", \"notch\", \"allpass\", \"peaking\"];\n\t\tthis.assert(types.indexOf(type) !== -1, `Invalid filter type: ${type}`);\n\t\tthis._type = type;\n\t\tthis._filters.forEach(filter => filter.type = type);\n\t}\n\n\t/**\n\t * The rolloff of the filter which is the drop in db\n\t * per octave. Implemented internally by cascading filters.\n\t * Only accepts the values -12, -24, -48 and -96.\n\t */\n\tget rolloff(): number | string {\n\t\treturn this._rolloff;\n\t}\n\tset rolloff(rolloff: number | string) {\n\t\tconst rolloffNum = isNumber(rolloff) ? rolloff : parseInt(rolloff, 10);\n\t\tconst possibilities = [-12, -24, -48, -96];\n\t\tlet cascadingCount = possibilities.indexOf(rolloffNum);\n\t\t// check the rolloff is valid\n\t\tthis.assert(cascadingCount !== -1, `rolloff can only be ${possibilities.join(\", \")}`);\n\t\tcascadingCount += 1;\n\n\t\tthis._rolloff = rolloffNum;\n\t\tthis.input.disconnect();\n\t\tthis._filters.forEach(filter => filter.disconnect());\n\n\t\tthis._filters = new Array(cascadingCount);\n\t\tfor (let count = 0; count < cascadingCount; count++) {\n\t\t\tconst filter = this.context.createBiquadFilter();\n\t\t\tfilter.type = this._type;\n\t\t\tthis.frequency.connect(filter.frequency);\n\t\t\tthis.detune.connect(filter.detune);\n\t\t\tthis.Q.connect(filter.Q);\n\t\t\tthis.gain.connect(filter.gain);\n\t\t\tthis._filters[count] = filter;\n\t\t}\n\t\tthis._internalChannels = this._filters;\n\t\tconnectSeries(this.input, ...this._internalChannels, this.output);\n\t}\n\n\t/**\n\t * Get the frequency response curve. This curve represents how the filter\n\t * responses to frequencies between 20hz-20khz.\n\t * @param  len The number of values to return\n\t * @return The frequency response curve between 20-20kHz\n\t */\n\tgetFrequencyResponse(len: number = 128): Float32Array {\n\t\t// start with all 1s\n\t\tconst totalResponse = new Float32Array(len).map(() => 1);\n\t\tconst freqValues = new Float32Array(len);\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst norm = Math.pow(i / len, 2);\n\t\t\tconst freq = norm * (20000 - 20) + 20;\n\t\t\tfreqValues[i] = freq;\n\t\t}\n\t\tconst magValues = new Float32Array(len);\n\t\tconst phaseValues = new Float32Array(len);\n\t\tthis._filters.forEach(() => {\n\t\t\tconst filterClone = this.context.createBiquadFilter();\n\t\t\tfilterClone.type = this._type;\n\t\t\tfilterClone.Q.value = this.Q.value;\n\t\t\tfilterClone.frequency.value = this.frequency.value as number;\n\t\t\tfilterClone.gain.value = this.gain.value as number;\n\t\t\tfilterClone.getFrequencyResponse(freqValues, magValues, phaseValues);\n\t\t\tmagValues.forEach((val, i) => {\n\t\t\t\ttotalResponse[i] *= val;\n\t\t\t});\n\t\t});\n\t\treturn totalResponse;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._filters.forEach(filter => {\n\t\t\tfilter.disconnect();\n\t\t});\n\t\twritable(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n\t\tthis.frequency.dispose();\n\t\tthis.Q.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Frequency, Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Filter } from \"../filter/Filter\";\n\ninterface MultibandSplitOptions extends ToneAudioNodeOptions {\n\tQ: Positive;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\n/**\n *  Split the incoming signal into three bands (low, mid, high)\n *  with two crossover frequency controls.\n * ```\n *            +----------------------+\n *          +-> input < lowFrequency +------------------> low\n *          | +----------------------+\n *          |\n *          | +--------------------------------------+\n * input ---+-> lowFrequency < input < highFrequency +--> mid\n *          | +--------------------------------------+\n *          |\n *          | +-----------------------+\n *          +-> highFrequency < input +-----------------> high\n *            +-----------------------+\n * ```\n *\n *  @param lowFrequency the low/mid crossover frequency\n *  @param highFrequency the mid/high crossover frequency\n */\nexport class MultibandSplit extends ToneAudioNode<MultibandSplitOptions> {\n\n\treadonly name = \"MultibandSplit\";\n\n\t/**\n\t *  the input\n\t */\n\treadonly input = new Gain({ context: this.context });\n\n\t/**\n\t * no output node, use either low, mid or high outputs\n\t */\n\treadonly output = undefined;\n\n\t/**\n\t *  The low band.\n\t */\n\treadonly low = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"lowpass\",\n\t});\n\n\t/**\n\t *  the lower filter of the mid band\n\t */\n\tprivate _lowMidFilter = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"highpass\",\n\t});\n\n\t/**\n\t *  The mid band output.\n\t */\n\treadonly mid = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"lowpass\",\n\t});\n\n\t/**\n\t *  The high band output.\n\t */\n\treadonly high = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"highpass\",\n\t});\n\n\t/**\n\t *  The low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<Frequency>;\n\n\t/**\n\t *  The mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<Frequency>;\n\n\tprotected _internalChannels = [this.low, this.mid, this.high];\n\n\t/**\n\t *  The Q or Quality of the filter\n\t */\n\treadonly Q: Signal<Positive>;\n\n\tconstructor(lowFrequency?: Frequency, highFrequency?: Frequency);\n\tconstructor(options?: Partial<MultibandSplitOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MultibandSplit.getDefaults(), arguments, [\"lowFrequency\", \"highFrequency\"]));\n\t\tconst options = optionsFromArguments(MultibandSplit.getDefaults(), arguments, [\"lowFrequency\", \"highFrequency\"]);\n\n\t\tthis.lowFrequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.lowFrequency,\n\t\t});\n\n\t\tthis.highFrequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.highFrequency,\n\t\t});\n\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.Q,\n\t\t});\n\n\t\tthis.input.fan(this.low, this.high);\n\t\tthis.input.chain(this._lowMidFilter, this.mid);\n\t\t// the frequency control signal\n\t\tthis.lowFrequency.fan(this.low.frequency, this._lowMidFilter.frequency);\n\t\tthis.highFrequency.fan(this.mid.frequency, this.high.frequency);\n\t\t// the Q value\n\t\tthis.Q.connect(this.low.Q);\n\t\tthis.Q.connect(this._lowMidFilter.Q);\n\t\tthis.Q.connect(this.mid.Q);\n\t\tthis.Q.connect(this.high.Q);\n\n\t\treadOnly(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t}\n\n\tstatic getDefaults(): MultibandSplitOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\thighFrequency: 2500,\n\t\t\tlowFrequency: 400,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\twritable(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t\tthis.low.dispose();\n\t\tthis._lowMidFilter.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.lowFrequency.dispose();\n\t\tthis.highFrequency.dispose();\n\t\tthis.Q.dispose();\n\t\treturn this;\n\t}\n\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Cents, Decibels, Frequency, GainFactor, Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { MultibandSplit } from \"../channel/MultibandSplit\";\n\ninterface EQ3Options extends ToneAudioNodeOptions {\n\tlow: Decibels;\n\tmid: Decibels;\n\thigh: Decibels;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\nexport class EQ3 extends ToneAudioNode<EQ3Options> {\n\n\treadonly name = \"EQ3\";\n\n\t/**\n\t *  the input\n\t */\n\treadonly input: MultibandSplit;\n\n\t/**\n\t *  the output\n\t */\n\treadonly output = new Gain({ context: this.context });\n\n\tprivate _multibandSplit: MultibandSplit;\n\n\t/**\n\t *  The gain for the lower signals\n\t */\n\tprivate _lowGain: Gain<Decibels>;\n\n\t/**\n\t *  The gain for the mid signals\n\t */\n\tprivate _midGain: Gain<Decibels>;\n\n\t/**\n\t *  The gain for the high signals\n\t */\n\tprivate _highGain: Gain<Decibels>;\n\n\t/**\n\t * The gain in decibels of the low part\n\t */\n\treadonly low: Param<Decibels>;\n\n\t/**\n\t * The gain in decibels of the mid part\n\t */\n\treadonly mid: Param<Decibels>;\n\n\t/**\n\t * The gain in decibels of the high part\n\t */\n\treadonly high: Param<Decibels>;\n\n\t/**\n\t *  The Q value for all of the filters.\n\t */\n\treadonly Q: Signal<Positive>;\n\n\t/**\n\t *  The low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<Frequency>;\n\n\t/**\n\t *  The mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<Frequency>;\n\n\tprotected _internalChannels: ToneAudioNode[] = [];\n\n\tconstructor(lowLevel?: Decibels, midLevel?: Decibels, highLevel?: Decibels);\n\tconstructor(options: Partial<EQ3Options>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(EQ3.getDefaults(), arguments, [\"low\", \"mid\", \"high\"]));\n\t\tconst options = optionsFromArguments(EQ3.getDefaults(), arguments, [\"low\", \"mid\", \"high\"]);\n\n\t\tthis.input = this._multibandSplit = new MultibandSplit({\n\t\t\tcontext: this.context,\n\t\t\thighFrequency: options.highFrequency,\n\t\t\tlowFrequency: options.lowFrequency,\n\t\t});\n\n\t\tthis._lowGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.low,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis._midGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.mid,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis._highGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.high,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis.low = this._lowGain.gain;\n\t\tthis.mid = this._midGain.gain;\n\t\tthis.high = this._highGain.gain;\n\t\tthis.Q = this._multibandSplit.Q;\n\t\tthis.lowFrequency = this._multibandSplit.lowFrequency;\n\t\tthis.highFrequency\t= this._multibandSplit.highFrequency;\n\n\t\t// the frequency bands\n\t\tthis._multibandSplit.low.chain(this._lowGain, this.output);\n\t\tthis._multibandSplit.mid.chain(this._midGain, this.output);\n\t\tthis._multibandSplit.high.chain(this._highGain, this.output);\n\n\t\treadOnly(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n\t\tthis._internalChannels = [this._multibandSplit];\n\t}\n\n\tstatic getDefaults(): EQ3Options {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\thigh : 0,\n\t\t\thighFrequency : 2500,\n\t\t\tlow : 0,\n\t\t\tlowFrequency : 400,\n\t\t\tmid : 0,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\twritable(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n\t\tthis._multibandSplit.dispose();\n\t\tthis.lowFrequency.dispose();\n\t\tthis.highFrequency.dispose();\n\t\tthis._lowGain.dispose();\n\t\tthis._midGain.dispose();\n\t\tthis._highGain.dispose();\n\t\tthis.low.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.Q.dispose();\n\t\treturn this;\n\t}\n\n}\n","import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels, Positive, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface CompressorOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tknee: Decibels;\n\tratio: Positive;\n\trelease: Time;\n\tthreshold: Decibels;\n}\n\n/**\n * Compressor is a thin wrapper around the Web Audio\n * [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).\n * Compression reduces the volume of loud sounds or amplifies quiet sounds\n * by narrowing or \"compressing\" an audio signal's dynamic range.\n * Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).\n *\n * @param threshold The value above which the compression starts to be applied.\n * @param ratio The gain reduction ratio.\n * @example\n * var comp = new Compressor(-30, 3);\n */\nexport class Compressor extends ToneAudioNode<CompressorOptions> {\n\n\treadonly name = \"Compressor\";\n\n\t/**\n\t *  the compressor node\n\t */\n\tprivate _compressor: DynamicsCompressorNode = this.context.createDynamicsCompressor();\n\tinput = this._compressor;\n\toutput = this._compressor;\n\n\t/**\n\t *  The decibel value above which the compression will start taking effect.\n\t */\n\treadonly threshold: Param<Decibels>;\n\n\t/**\n\t *  The amount of time (in seconds) to reduce the gain by 10dB.\n\t */\n\treadonly attack: Param<Time>;\n\n\t/**\n\t * The amount of time (in seconds) to increase the gain by 10dB.\n\t */\n\treadonly release: Param<Time>;\n\n\t/**\n\t * A decibel value representing the range above the threshold where the\n\t * curve smoothly transitions to the \"ratio\" portion.\n\t */\n\treadonly knee: Param<Decibels>;\n\n\t/**\n\t * The amount of dB change in input for a 1 dB change in output.\n\t */\n\treadonly ratio: Param<Decibels>;\n\n\tconstructor(threshold?: Decibels, ratio?: Positive);\n\tconstructor(options?: Partial<CompressorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Compressor.getDefaults(), arguments, [\"treshold\", \"ratio\"]));\n\t\tconst options = optionsFromArguments(Compressor.getDefaults(), arguments, [\"treshold\", \"ratio\"]);\n\n\t\tthis.threshold = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert : false,\n\t\t\tparam : this._compressor.threshold,\n\t\t\tunits : \"decibels\",\n\t\t\tvalue: options.threshold,\n\t\t});\n\n\t\tthis.attack = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._compressor.attack,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.attack,\n\t\t});\n\n\t\tthis.release = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._compressor.release,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.release,\n\t\t});\n\n\t\tthis.knee = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert : false,\n\t\t\tparam : this._compressor.knee,\n\t\t\tunits : \"decibels\",\n\t\t\tvalue: options.knee,\n\t\t});\n\n\t\tthis.ratio = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert : false,\n\t\t\tparam : this._compressor.ratio,\n\t\t\tunits : \"positive\",\n\t\t\tvalue: options.ratio,\n\t\t});\n\n\t\t// set the defaults\n\t\treadOnly(this, [\"knee\", \"release\", \"attack\", \"ratio\", \"threshold\"]);\n\t}\n\n\tstatic getDefaults(): CompressorOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack : 0.003,\n\t\t\tknee : 30,\n\t\t\tratio : 12,\n\t\t\trelease : 0.25,\n\t\t\tthreshold : -24,\n\t\t});\n\t}\n\n\t/**\n\t * A read-only decibel value for metering purposes, representing the current amount of gain\n\t * reduction that the compressor is applying to the signal. If fed no signal the value will be 0 (no gain reduction).\n\t */\n\tget reduction(): number {\n\t\treturn this._compressor.reduction;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._compressor.disconnect();\n\t\tthis.attack.dispose();\n\t\tthis.release.dispose();\n\t\tthis.threshold.dispose();\n\t\tthis.ratio.dispose();\n\t\tthis.knee.dispose();\n\t\treturn this;\n\t}\n}\n","export { getContext, setContext } from \"./core/Global\";\nexport * from \"./core/index\";\nexport * from \"./source/index\";\nexport * from \"./signal/index\";\nexport * from \"./instrument/index\";\nexport * from \"./event/index\";\nexport * from \"./effect/index\";\nexport * from \"./component/index\";\nimport { Seconds } from \"./core/type/Units\";\n\nimport { getContext } from \"./core/Global\";\nexport { start } from \"./core/Global\";\n/**\n *  The current audio context time\n */\nexport function now(): Seconds {\n\treturn getContext().now();\n}\n\n/**\n * The Transport object belonging to the global Tone.js Context\n */\n// tslint:disable-next-line: variable-name\nexport const Transport = getContext().transport;\n\n/**\n * The Destination (output) belonging to the global Tone.js Context\n */\n// tslint:disable-next-line: variable-name\nexport const Destination = getContext().destination;\n"],"sourceRoot":""}