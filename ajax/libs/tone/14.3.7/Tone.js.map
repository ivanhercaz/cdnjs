{"version":3,"sources":["webpack://Tone/webpack/universalModuleDefinition","webpack://Tone/webpack/bootstrap","webpack://Tone/./node_modules/automation-events/build/es5/bundle.js","webpack://Tone/./Tone/version.ts","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/abort-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/globals.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/invalid-state-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-native-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-constructible.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/split-import-statements.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/add-audio-worklet-module.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/analyser-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-value-for-key.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-owned-by-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-audio-graph.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-audio-node-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-audio-node-renderer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/render-inputs-of-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-audio-buffer-copy-channel-methods-subarray-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/index-size-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-buffer-get-channel-data-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-buffer-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-event-listeners-of-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/set-internal-state.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-event-listener.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-buffer-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-native-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-audio-param-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/render-inputs-of-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/connect-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/render-automation.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-audio-param-renderer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-valid-latency-hint.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/event-target.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/audio-node-output-connection.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/audio-worklet-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/connect-native-audio-node-to-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/delete-event-listeners-of-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/disconnect-native-audio-node-from-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/insert-element-in-set.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-active-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-passive-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/pick-element-from-set.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/set-internal-state-to-passive-when-necessary.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-audio-node-disconnect-method-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-param-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/read-only-map.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-worklet-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/copy-from-channel.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/copy-to-channel.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/create-nested-arrays.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-worklet-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-audio-worklet-processor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/biquad-filter-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/channel-merger-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/channel-splitter-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/constant-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/convolver-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/delay-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/disconnect-multiple-outputs.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/dynamics-compressor-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/gain-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/invalid-access-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/iir-filter-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/filter-buffer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-promise-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/minimal-offline-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/assign-native-audio-node-option.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/assign-native-audio-node-options.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-analyser-node-get-float-time-domain-data-method-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-analyser-node-get-float-time-domain-data-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-buffer-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/assign-native-audio-node-audio-param-value.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/compute-buffer-size.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/create-audio-worklet-processor-promise.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/clone-audio-worklet-node-options.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/intercept-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-iir-filter-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/not-supported-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/offline-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/oscillator-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/panner-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/periodic-wave-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/stereo-panner-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/unknown-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wave-shaper-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/module.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/cache-test-result.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/window.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-offline-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-native-offline-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/get-backup-native-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-analyser-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/analyser-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-native-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-node-disconnect-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/detect-cycles.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/delay-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/none-audio-destination-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/convert-number-to-unsigned-long.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wrap-audio-buffer-copy-channel-methods.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wrap-audio-buffer-copy-channel-methods-subarray.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-buffer-constructor-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-scheduled-source-node-start-method-negative-parameters-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-buffer-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-buffer-source-node-start-method-consecutive-calls-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-buffer-source-node-start-method-duration-parameter-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-buffer-source-node-start-method-offset-clamping-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-buffer-source-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-param-renderer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/constants.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-destination-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-destination-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-destination-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-biquad-filter-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/biquad-filter-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wrap-channel-merger-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-channel-merger-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/channel-merger-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-channel-splitter-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-channel-splitter-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/channel-splitter-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-gain-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-constant-source-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-constant-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/constant-source-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-convolver-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/convolver-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-delay-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/delay-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-dynamics-compressor-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/dynamics-compressor-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/gain-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-script-processor-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/render-native-offline-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-offline-audio-context-current-time-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/iir-filter-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-iir-filter-node-get-frequency-response-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-iir-filter-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/minimal-base-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-listener-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-oscillator-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/oscillator-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-wave-shaper-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-wave-shaper-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-panner-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-panner-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/panner-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-periodic-wave-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-stereo-panner-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-stereo-panner-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/stereo-panner-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wave-shaper-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-secure-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/expose-current-frame-and-current-time.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/evaluate-source.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/fetch-source.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-native-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-native-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/base-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/decode-audio-data.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/detach-array-buffer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/data-clone-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/encoding-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/media-element-audio-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-media-element-audio-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/media-stream-audio-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-media-stream-audio-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/media-stream-track-audio-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-media-stream-track-audio-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/connect-multiple-outputs.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-worklet-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/create-audio-worklet-processor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-worklet-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-clonability-of-audio-worklet-node-options.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-worklet-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/minimal-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/create-native-offline-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/start-rendering.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-any-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-any-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-any-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-any-offline-audio-context.js","webpack://Tone/./Tone/core/context/AudioContext.ts","webpack://Tone/./Tone/core/clock/Ticker.ts","webpack://Tone/./Tone/core/util/AdvancedTypeCheck.ts","webpack://Tone/./Tone/core/util/TypeCheck.ts","webpack://Tone/./Tone/core/util/Defaults.ts","webpack://Tone/./Tone/core/util/Debug.ts","webpack://Tone/./Tone/core/Tone.ts","webpack://Tone/./Tone/core/util/Emitter.ts","webpack://Tone/./Tone/core/util/Timeline.ts","webpack://Tone/./Tone/core/context/ContextInitialization.ts","webpack://Tone/./Tone/core/context/Context.ts","webpack://Tone/./Tone/core/context/OfflineContext.ts","webpack://Tone/./Tone/core/Global.ts","webpack://Tone/./Tone/core/type/Conversions.ts","webpack://Tone/./Tone/core/type/TimeBase.ts","webpack://Tone/./Tone/core/type/Time.ts","webpack://Tone/./Tone/core/type/Frequency.ts","webpack://Tone/./Tone/core/type/TransportTime.ts","webpack://Tone/./Tone/core/context/ToneWithContext.ts","webpack://Tone/./Tone/core/context/Param.ts","webpack://Tone/./Tone/core/context/ToneAudioNode.ts","webpack://Tone/./Tone/core/util/Interface.ts","webpack://Tone/./Tone/core/context/Gain.ts","webpack://Tone/./Tone/core/context/ToneAudioBuffer.ts","webpack://Tone/./Tone/core/context/Offline.ts","webpack://Tone/./Tone/core/context/ToneAudioBuffers.ts","webpack://Tone/./Tone/core/context/Delay.ts","webpack://Tone/./Tone/core/util/StateTimeline.ts","webpack://Tone/./Tone/core/clock/TickSignal.ts","webpack://Tone/./Tone/core/clock/TickSource.ts","webpack://Tone/./Tone/core/clock/Clock.ts","webpack://Tone/./Tone/core/type/Ticks.ts","webpack://Tone/./Tone/core/type/Midi.ts","webpack://Tone/./Tone/core/util/Draw.ts","webpack://Tone/./Tone/core/util/IntervalTimeline.ts","webpack://Tone/./Tone/component/channel/Volume.ts","webpack://Tone/./Tone/core/context/Destination.ts","webpack://Tone/./Tone/core/clock/TransportEvent.ts","webpack://Tone/./Tone/core/clock/TransportRepeatEvent.ts","webpack://Tone/./Tone/core/clock/Transport.ts","webpack://Tone/./Tone/source/Source.ts","webpack://Tone/./Tone/source/OneShotSource.ts","webpack://Tone/./Tone/source/buffer/BufferSource.ts","webpack://Tone/./Tone/source/Noise.ts","webpack://Tone/./Tone/signal/Signal.ts","webpack://Tone/./Tone/source/oscillator/OscillatorNode.ts","webpack://Tone/./Tone/source/oscillator/Oscillator.ts","webpack://Tone/./Tone/signal/SignalOperator.ts","webpack://Tone/./Tone/signal/WaveShaper.ts","webpack://Tone/./Tone/signal/AudioToGain.ts","webpack://Tone/./Tone/signal/Multiply.ts","webpack://Tone/./Tone/source/oscillator/AMOscillator.ts","webpack://Tone/./Tone/source/oscillator/FMOscillator.ts","webpack://Tone/./Tone/source/oscillator/PulseOscillator.ts","webpack://Tone/./Tone/source/oscillator/FatOscillator.ts","webpack://Tone/./Tone/source/oscillator/PWMOscillator.ts","webpack://Tone/./Tone/source/oscillator/OmniOscillator.ts","webpack://Tone/./Tone/source/buffer/Player.ts","webpack://Tone/./Tone/signal/Add.ts","webpack://Tone/./Tone/signal/Abs.ts","webpack://Tone/./Tone/signal/GainToAudio.ts","webpack://Tone/./Tone/signal/Negate.ts","webpack://Tone/./Tone/signal/Subtract.ts","webpack://Tone/./Tone/signal/Zero.ts","webpack://Tone/./Tone/component/envelope/Envelope.ts","webpack://Tone/./Tone/component/envelope/AmplitudeEnvelope.ts","webpack://Tone/./Tone/instrument/Instrument.ts","webpack://Tone/./Tone/instrument/Monophonic.ts","webpack://Tone/./Tone/instrument/Synth.ts","webpack://Tone/./Tone/instrument/Sampler.ts","webpack://Tone/./Tone/instrument/PolySynth.ts","webpack://Tone/./Tone/instrument/MembraneSynth.ts","webpack://Tone/./Tone/event/ToneEvent.ts","webpack://Tone/./Tone/event/Part.ts","webpack://Tone/./Tone/event/Sequence.ts","webpack://Tone/./Tone/component/channel/CrossFade.ts","webpack://Tone/./Tone/effect/Effect.ts","webpack://Tone/./Tone/effect/FeedbackEffect.ts","webpack://Tone/./Tone/effect/FeedbackDelay.ts","webpack://Tone/./Tone/effect/Convolver.ts","webpack://Tone/./Tone/component/channel/Merge.ts","webpack://Tone/./Tone/effect/Reverb.ts","webpack://Tone/./Tone/component/analysis/Analyser.ts","webpack://Tone/./Tone/component/filter/Filter.ts","webpack://Tone/./Tone/component/channel/MultibandSplit.ts","webpack://Tone/./Tone/component/filter/EQ3.ts","webpack://Tone/./Tone/component/dynamics/Compressor.ts","webpack://Tone/./Tone/index.ts","webpack://Tone/./node_modules/@babel/runtime/helpers/createClass.js","webpack://Tone/./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://Tone/./node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack://Tone/./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack://Tone/./node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack://Tone/./node_modules/@babel/runtime/helpers/slicedToArray.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_slicedToArray","_classCallCheck","_createClass","createExtendedExponentialRampToValueAutomationEvent","endTime","insertTime","type","createExtendedLinearRampToValueAutomationEvent","createSetValueAutomationEvent","startTime","createSetValueCurveAutomationEvent","values","duration","getTargetValueAtTime","time","valueAtStartTime","_ref","target","timeConstant","Math","exp","isExponentialRampToValueAutomationEvent","automationEvent","isLinearRampToValueAutomationEvent","isAnyRampToValueAutomationEvent","isSetValueAutomationEvent","isSetValueCurveAutomationEvent","getValueOfAutomationEventAtIndexAtTime","automationEvents","index","defaultValue","undefined","length","getEndTimeAndValueOfPreviousAutomationEvent","currentAutomationEvent","nextAutomationEvent","isCancelAndHoldAutomationEvent","isCancelScheduledValuesAutomationEvent","getEventTime","cancelTime","getExponentialRampValueAtTime","pow","getLinearRampValueAtTime","getValueCurveValueAtTime","theoreticIndex","lowerIndex","floor","upperIndex","ceil","interpolateValue","isSetTargetAutomationEvent","AutomationEventList","this","_automationEvents","_currenTime","_defaultValue","key","Symbol","iterator","eventTime","findIndex","removedAutomationEvent","slice","lastAutomationEvent","Error","startValue","truncatedAutomationEvent","push","getValue","Float32Array","_index","previousAutomationEvent","persistentAutomationEvent","splice","remainingAutomationEvents","firstRemainingAutomationEvent","unshift","_getEndTimeAndValueOf","_getEndTimeAndValueOf2","_getEndTimeAndValueOf3","_getEndTimeAndValueOf4","_startTime","_value","createCancelAndHoldAutomationEvent","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent","abort_error_createAbortError","DOMException","err","code","ACTIVE_AUDIO_NODE_STORE","WeakSet","AUDIO_NODE_STORE","WeakMap","AUDIO_GRAPHS","AUDIO_PARAM_STORE","AUDIO_PARAM_AUDIO_NODE_STORE","AUXILIARY_GAIN_NODE_STORE","BACKUP_NATIVE_CONTEXT_STORE","CONTEXT_STORE","DETACHED_ARRAY_BUFFERS","EVENT_LISTENERS","NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","NODE_TO_PROCESSOR_MAPS","TEST_RESULTS","invalid_state_error_createInvalidStateError","getNativeContext","context","nativeContext","handler","construct","IMPORT_STATEMENT_REGEX","splitImportStatements","source","url","importStatements","sourceWithoutImportStatements","replace","result","match","unresolvedUrl","importStatementWithResolvedUrl","URL","toString","join","verifyParameterDescriptors","parameterDescriptors","Array","isArray","TypeError","verifyProcessorCtor","processorCtor","constructible","Proxy","_a","isConstructible","process","DEFAULT_OPTIONS","channelCount","channelCountMode","channelInterpretation","fftSize","maxDecibels","minDecibels","smoothingTimeConstant","get_value_for_key_getValueForKey","map","getNativeAudioNode","audioNode","isOwnedByContext","nativeAudioNode","getAudioGraph","get_audio_node_connections_getAudioNodeConnections","audioGraph","nodes","getAudioNodeRenderer","audioNodeConnections","renderer","renderInputsOfAudioNode","nativeOfflineAudioContext","Promise","all","activeInputs","connections","input","from","output","render","then","node","connect","reduce","allRenderingPromises","renderingPromises","test_audio_buffer_copy_channel_methods_out_of_bounds_support_testAudioBufferCopyChannelMethodsOutOfBoundsSupport","nativeAudioBuffer","copyToChannel","test_audio_buffer_copy_channel_methods_subarray_support_testAudioBufferCopyChannelMethodsSubarraySupport","copyFromChannel","index_size_error_createIndexSizeError","wrapAudioBufferGetChannelDataMethod","audioBuffer","getChannelData","channel","audio_buffer_constructor_DEFAULT_OPTIONS","numberOfChannels","getEventListenersOfAudioNode","setInternalState","internalState","has","add","delete","forEach","eventListener","wrapEventListener","event","descriptor","defineProperties","currentTarget","audio_buffer_source_node_constructor_DEFAULT_OPTIONS","buffer","loop","loopEnd","loopStart","playbackRate","getNativeAudioParam","audioParam","getAudioParamConnections","params","renderInputsOfAudioParam","nativeAudioParam","audioParamConnections","connectAudioParam","renderAutomation","getAudioParamRenderer","replay","isValidLatencyHint","latencyHint","event_target_EventTarget","[object Object]","_nativeEventTarget","_listeners","listener","options","wrappedEventListener","set","addEventListener","dispatchEvent","removeEventListener","isAudioNode","audioNodeOrAudioParam","isAudioNodeOutputConnection","outputConnection","isAudioWorkletNode","connectNativeAudioNodeToNativeAudioNode","nativeSourceAudioNode","nativeDestinationAudioNode","inputs","deleteEventListenerOfAudioNode","disconnectNativeAudioNodeFromNativeAudioNode","disconnect","insertElementInSet","element","predicate","ignoreDuplicates","lmnt","isActiveAudioNode","isPassiveAudioNode","pickElementFromSet","matchingElements","filter","matchingElement","setInternalStateToPassiveWhenNecessary","every","size","testAudioNodeDisconnectMethodSupport","nativeAudioContext","resolve","analyzer","createScriptProcessor","dummy","createGain","ones","createBuffer","channelData","createBufferSource","destination","onaudioprocess","chnnlDt","inputBuffer","some","sample","stop","start","native_audio_node_isNativeAudioNode","nativeAudioNodeOrAudioParam","addActiveInputConnectionToAudioNode","activeInputConnection","addActiveInputConnectionToAudioParam","addPassiveInputConnectionToAudioNode","passiveInputs","passiveInputConnections","Set","passiveInputConnection","addPassiveInputConnectionToAudioParam","deletePassiveInputConnectionToAudioNode","matchingConnection","deletePassiveInputConnectionToAudioParam","addConnectionToAudioNodeOfAudioContext","outputs","eventListeners","partialConnection","deleteActiveInputConnectionToAudioNode","addConnectionToAudioParamOfAudioContext","deleteActiveInputConnectionToAudioParam","deleteActiveInputConnection","activeInputConnections","deleteInputsOfAudioNode","deleteInputConnectionOfAudioNode","deleteInputsOfAudioParam","deleteInputConnectionOfAudioParam","audioParamRenderer","ReadOnlyMap","parameters","_map","Map","entries","callback","thisArg","keys","audio_worklet_node_constructor_DEFAULT_OPTIONS","numberOfInputs","numberOfOutputs","outputChannelCount","parameterData","processorOptions","parent","channelNumber","bufferOffset","byteLength","slicedInput","BYTES_PER_ELEMENT","createNestedArrays","x","y","arrays","array","j","processBuffer","async","proxy","renderedBuffer","processorConstructor","numberOfInputChannels","numberOfOutputChannels","sum","processedBuffer","sampleRate","audioWorkletProcessor","nodeToProcessorMap","nativeAudioWorkletNode","getAudioWorkletProcessor","prmtrs","k","potentiallyEmptyInputs","activeSourceFlag","outputChannelSplitterNodeOutput","error","ErrorEvent","biquad_filter_node_constructor_DEFAULT_OPTIONS","Q","detune","frequency","gain","channel_merger_node_constructor_DEFAULT_OPTIONS","channel_splitter_node_constructor_DEFAULT_OPTIONS","constant_source_node_constructor_DEFAULT_OPTIONS","offset","convolver_node_constructor_DEFAULT_OPTIONS","disableNormalization","delay_node_constructor_DEFAULT_OPTIONS","delayTime","maxDelayTime","getOutputAudioNodeAtIndex","createIndexSizeError","outputAudioNodes","outputAudioNode","dynamics_compressor_node_constructor_DEFAULT_OPTIONS","attack","knee","ratio","release","threshold","gain_node_constructor_DEFAULT_OPTIONS","invalid_access_error_createInvalidAccessError","iir_filter_node_constructor_DEFAULT_OPTIONS","filterBuffer","feedback","feedbackLength","feedforward","feedforwardLength","minLength","xBuffer","yBuffer","bufferIndex","bufferLength","inputLength","test_promise_support_testPromiseSupport","uint32Array","Uint32Array","promise","decodeAudioData","catch","minimal_offline_audio_context_constructor_DEFAULT_OPTIONS","assignNativeAudioNodeOption","option","assignNativeAudioNodeOptions","testAnalyserNodeGetFloatTimeDomainDataMethodSupport","nativeAnalyserNode","getFloatTimeDomainData","assignNativeAudioNodeAudioParamValue","wrapAudioScheduledSourceNodeStartMethodNegativeParameters","nativeAudioScheduledSourceNode","when","RangeError","wrapAudioScheduledSourceNodeStopMethodNegativeParameters","nativeAudioBufferSourceNode","computeBufferSize","baseLatency","max","min","round","log2","createAudioWorkletProcessorPromise","audioWorkletNodeOptions","reject","port1","port2","MessageChannel","onmessage","data","close","onmessageerror","postMessage","cloneAudioWorkletNodeOptions","interceptConnections","original","interceptor","apply","arguments","divide","a","b","denominator","evaluatePolynomial","coefficient","z","not_supported_error_createNotSupportedError","offline_audio_context_constructor_DEFAULT_OPTIONS","oscillator_node_constructor_DEFAULT_OPTIONS","panner_node_constructor_DEFAULT_OPTIONS","coneInnerAngle","coneOuterAngle","coneOuterGain","distanceModel","maxDistance","orientationX","orientationY","orientationZ","panningModel","positionX","positionY","positionZ","refDistance","rolloffFactor","periodic_wave_constructor_DEFAULT_OPTIONS","stereo_panner_node_constructor_DEFAULT_OPTIONS","pan","unknown_error_createUnknownError","wave_shaper_node_constructor_DEFAULT_OPTIONS","curve","oversample","module_cacheTestResult","ongoingTests","tester","test","cachedTestResult","ongoingTest","synchronousTestResult","finalTestResult","createCacheTestResult","module_window","createWindow","module_nativeOfflineAudioContextConstructor","OfflineAudioContext","webkitOfflineAudioContext","createNativeOfflineAudioContextConstructor","module_isNativeOfflineAudioContext","nativeOfflineAudioContextConstructor","anything","createIsNativeOfflineAudioContext","module_nativeAudioContextConstructor","AudioContext","webkitAudioContext","createNativeAudioContextConstructor","module_getBackupNativeContext","isNativeOfflineAudioContext","nativeAudioContextConstructor","state","backupNativeContext","bckpNtveCntxt","createGetBackupNativeContext","module_createNativeAudioNode","getBackupNativeContext","factoryFunction","createNativeAudioNodeFactory","module_createNativeAnalyserNode","cacheTestResult","createNativeAudioNode","ntvCntxt","createAnalyser","byteTimeDomainData","Uint8Array","getByteTimeDomainData","createNativeAnalyserNodeFactory","module_createAnalyserNodeRenderer","createNativeAnalyserNode","renderedNativeAnalyserNodes","renderedNativeAnalyserNode","createAnalyserNode","createAnalyserNodeRendererFactory","module_isNativeAudioNode","AudioNode","createIsNativeAudioNode","module_isNativeAudioParam","AudioParam","createIsNativeAudioParam","module_audioNodeConstructor","createInvalidAccessError","createNotSupportedError","detectCycles","isNativeAudioNode","isNativeAudioParam","audioNodeRenderer","super","_context","_nativeAudioNode","returnValue","connectionsToDestination","connection","bind","destinationOrOutput","clear","filteredConnections","wrapAudioNodeDisconnectMethod","audioNoderRender","addAudioNode","isOffline","auxiliaryGainNodes","nativeGainNode","addConnectionToAudioNodeOfOfflineAudioContext","addConnectionToAudioParamOfOfflineAudioContext","audioNodeConnectionsOfSource","deleteAnyConnection","deleteConnectionAtOutput","numberOfDeletedConnections","deleteConnectionToDestination","createAudioNodeConstructor","audioParamAudioNodeStore","getAudioNodeConnections","getValueForKey","audioNodeOfDestination","isDelayNode","createDetectCycles","module_noneAudioDestinationNodeConstructor","audioNodeConstructor","createNoneAudioDestinationNodeConstructor","analyserNodeConstructor","createAnalyserNodeRenderer","noneAudioDestinationNodeConstructor","mergedOptions","_nativeAnalyserNode","frequencyBinCount","getByteFrequencyData","getFloatFrequencyData","createAnalyserNodeConstructor","module_nativeAudioBufferConstructor","AudioBuffer","createNativeAudioBufferConstructor","convertNumberToUnsignedLong","unit32Array","createConvertNumberToUnsignedLong","module_wrapAudioBufferCopyChannelMethods","channelNumberAsNumber","bufferOffsetAsNumber","audioBufferLength","destinationLength","sourceLength","createWrapAudioBufferCopyChannelMethods","module_wrapAudioBufferCopyChannelMethodsOutOfBounds","createWrapAudioBufferCopyChannelMethodsOutOfBounds","module_wrapAudioBufferCopyChannelMethodsSubarray","subarray","createWrapAudioBufferCopyChannelMethodsSubarray","audioBufferConstructor","nativeAudioBufferConstructor","testNativeAudioBufferConstructorSupport","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","wrapAudioBufferCopyChannelMethodsSubarray","_1","_2","_3","_","createAudioBufferConstructor","createTestAudioBufferConstructorSupport","module_testAudioScheduledSourceNodeStartMethodNegativeParametersSupport","createOscillator","createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport","module_testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","module_testAudioScheduledSourceNodeStopMethodNegativeParametersSupport","createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport","module_wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","disconnectGainNode","isStopped","setValueAtTime","createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","module_createNativeAudioBufferSourceNode","testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","testAudioBufferSourceNodeStartMethodDurationParameterSupport","testAudioBufferSourceNodeStartMethodOffsetClampingSupport","testAudioScheduledSourceNodeStartMethodNegativeParametersSupport","testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","testAudioScheduledSourceNodeStopMethodNegativeParametersSupport","wrapAudioBufferSourceNodeStartMethodOffsetClampling","wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","isScheduled","Number","POSITIVE_INFINITY","stopTime","actualStartTime","currentTime","durationInBufferTime","wrapAudioBufferSourceNodeStartMethodDurationParameter","createNativeAudioBufferSourceNodeFactory","createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","offlineAudioContext","audioBufferSourceNode","oncomplete","startRendering","createTestAudioBufferSourceNodeStartMethodDurationParameterSupport","createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport","clampedOffset","module_createAudioBufferSourceNodeRenderer","createNativeAudioBufferSourceNode","renderedNativeAudioBufferSourceNodes","renderedNativeAudioBufferSourceNode","nativeAudioBufferSourceNodeIsOwnedByContext","createAudioBufferSourceNode","createAudioBufferSourceNodeRendererFactory","module_createAudioParam","createAudioParamRenderer","isAudioParamOfOfflineAudioContext","maxValue","minValue","automationEventList","bundle","cancelAndHoldAtTime","flush","previousLastEvent","pop","currentLastEvent","cancelScheduledValues","exponentialRampToValueAtTime","linearRampToValueAtTime","setValueCurveAtTime","setTargetAtTime","firstSample","lastSample","numberOfInterpolatedValues","interpolatedValues","timeOfLastSample","createAudioParamFactory","audioBufferSourceNodeConstructor","createAudioBufferSourceNodeRenderer","createAudioParam","createInvalidStateError","audioBufferSourceNodeRenderer","_audioBufferSourceNodeRenderer","_isBufferNullified","_isBufferSet","_nativeAudioBufferSourceNode","_onended","_playbackRate","fill","onended","wrappedListener","nativeOnEnded","setInternalStateToInactive","setTimeout","createAudioBufferSourceNodeConstructor","module_audioDestinationNodeConstructor","createAudioDestinationNodeRenderer","createNativeAudioDestinationNode","nativeAudioDestinationNode","audioDestinationNodeRenderer","audioWorkletGlobalScope","_isNodeOfNativeOfflineAudioContext","_nativeAudioDestinationNode","maxChannelCount","createAudioDestinationNodeConstructor","nativeAudioDestinationNodePromise","createAudioDestinationNode","isNodeOfNativeOfflineAudioContext","module_createNativeBiquadFilterNode","nativeBiquadFilterNode","createBiquadFilter","createNativeBiquadFilterNodeFactory","biquadFilterNodeConstructor","createBiquadFilterNodeRenderer","createNativeBiquadFilterNode","_Q","_detune","_frequency","_gain","_nativeBiquadFilterNode","frequencyHz","magResponse","phaseResponse","getFrequencyResponse","createBiquadFilterNodeConstructor","renderedNativeBiquadFilterNodes","renderedNativeBiquadFilterNode","nativeBiquadFilterNodeIsOwnedByContext","createBiquadFilterNode","createBiquadFilterNodeRendererFactory","module_wrapChannelMergerNode","channelMergerNode","createWrapChannelMergerNode","module_createNativeChannelMergerNode","wrapChannelMergerNode","nativeChannelMergerNode","createChannelMerger","createNativeChannelMergerNodeFactory","channelMergerNodeConstructor","createChannelMergerNodeRenderer","createNativeChannelMergerNode","createChannelMergerNodeConstructor","renderedNativeAudioNodes","renderedNativeAudioNode","createAudioNode","createChannelMergerNodeRendererFactory","module_createNativeChannelSplitterNode","nativeChannelSplitterNode","createChannelSplitter","channelSplitterNode","wrapChannelSplitterNode","createNativeChannelSplitterNodeFactory","channelSplitterNodeConstructor","createChannelSplitterNodeRenderer","createNativeChannelSplitterNode","channel_splitter_node_constructor_sanitizedOptions","createChannelSplitterNodeConstructor","createChannelSplitterNodeRendererFactory","module_createNativeGainNode","createNativeGainNodeFactory","module_createNativeConstantSourceNodeFaker","createNativeGainNode","audioNodeOptions","gainNode","bufferSize","args","createNativeConstantSourceNodeFakerFactory","module_createNativeConstantSourceNode","createNativeConstantSourceNodeFaker","createConstantSource","nativeConstantSourceNode","createNativeConstantSourceNodeFactory","constantSourceNodeConstructor","createConstantSourceNodeRendererFactory","createNativeConstantSourceNode","constantSourceNodeRenderer","_constantSourceNodeRenderer","_nativeConstantSourceNode","_offset","createConstantSourceNodeConstructor","renderedNativeConstantSourceNodes","renderedNativeConstantSourceNode","nativeConstantSourceNodeIsOwnedByContext","createConstantSourceNode","constant_source_node_renderer_factory_createConstantSourceNodeRendererFactory","module_createNativeConvolverNode","nativeConvolverNode","createConvolver","normalize","createNativeConvolverNodeFactory","convolverNodeConstructor","createConvolverNodeRenderer","createNativeConvolverNode","_nativeConvolverNode","createConvolverNodeConstructor","renderedNativeConvolverNodes","renderedNativeConvolverNode","createConvolverNode","createConvolverNodeRendererFactory","module_createNativeDelayNode","nativeDelayNode","createDelay","createNativeDelayNodeFactory","delayNodeConstructor","createDelayNodeRenderer","createNativeDelayNode","_delayTime","createDelayNodeConstructor","renderedNativeDelayNodes","renderedNativeDelayNode","nativeDelayNodeIsOwnedByContext","createDelayNode","createDelayNodeRendererFactory","module_createNativeDynamicsCompressorNode","nativeDynamicsCompressorNode","createDynamicsCompressor","createNativeDynamicsCompressorNodeFactory","dynamicsCompressorNodeConstructor","createDynamicsCompressorNodeRenderer","createNativeDynamicsCompressorNode","_attack","_knee","_nativeDynamicsCompressorNode","_ratio","_release","_threshold","previousChannelCount","reduction","createDynamicsCompressorNodeConstructor","renderedNativeDynamicsCompressorNodes","renderedNativeDynamicsCompressorNode","nativeDynamicsCompressorNodeIsOwnedByContext","createDynamicsCompressorNode","createDynamicsCompressorNodeRendererFactory","module_gainNodeConstructor","createGainNodeRenderer","createGainNodeConstructor","renderedNativeGainNodes","renderedNativeGainNode","nativeGainNodeIsOwnedByContext","createGainNode","createGainNodeRendererFactory","module_createNativeScriptProcessorNode","createNativeScriptProcessorNodeFactory","module_createNativeIIRFilterNodeFaker","createNativeScriptProcessorNode","scriptProcessorNode","bufferIndexes","xBuffers","yBuffers","outputBuffer","nyquist","omega","PI","cos","sin","response","sqrt","atan2","createNativeIIRFilterNodeFakerFactory","module_renderNativeOfflineAudioContext","testOfflineAudioContextCurrentTimeSupport","isOfflineAudioContextCurrentTimeSupported","createRenderNativeOfflineAudioContext","createTestOfflineAudioContextCurrentTimeSupport","module_createIIRFilterNodeRenderer","renderNativeOfflineAudioContext","nativeIIRFilterNode","nativeIIRFilterNodeIsOwnedByContext","createIIRFilter","partialOfflineAudioContext","filteredBuffer","filterFullBuffer","createIIRFilterNodeRendererFactory","iIRFilterNodeConstructor","createNativeIIRFilterNode","createIIRFilterNodeRenderer","wrapIIRFilterNodeGetFrequencyResponseMethod","_nativeIIRFilterNode","createIIRFilterNodeConstructor","createNativeIIRFilterNodeFaker","createNativeIIRFilterNodeFactory","module_minimalBaseAudioContextConstructor","audioDestinationNodeConstructor","createAudioListener","_nativeContext","_destination","_listener","_onstatechange","onstatechange","nativeOnStateChange","createMinimalBaseAudioContextConstructor","nativeListener","forwardX","forwardY","forwardZ","upX","upY","upZ","createFakeAudioParam","constantSourceNode","lastOrientation","lastPosition","orientation","setOrientation","positon","setPosition","createFakeAudioParams","createAudioListenerFactory","module_createNativeOscillatorNode","nativeOscillatorNode","periodicWave","setPeriodicWave","createNativeOscillatorNodeFactory","module_createOscillatorNodeRenderer","createNativeOscillatorNode","renderedNativeOscillatorNodes","renderedNativeOscillatorNode","nativeOscillatorNodeIsOwnedByContext","createOscillatorNode","createOscillatorNodeRendererFactory","oscillatorNodeConstructor","createOscillatorNodeRenderer","oscillatorNodeRenderer","_nativeOscillatorNode","_oscillatorNodeRenderer","createOscillatorNodeConstructor","module_createNativeWaveShaperNodeFaker","negativeWaveShaperNode","createWaveShaper","positiveWaveShaperNode","inputGainNode","invertGainNode","outputGainNode","revertGainNode","unmodifiedCurve","nativeWaveShaperNodeFaker","curveLength","negativeCurve","positiveCurve","centerIndex","createNativeWaveShaperNodeFakerFactory","module_createNativeWaveShaperNode","createNativeWaveShaperNodeFaker","nativeWaveShaperNode","createNativeWaveShaperNodeFactory","module_createNativePannerNodeFaker","createNativeWaveShaperNode","pannerNode","createPanner","SINGLE_CHANNEL_OPTIONS","orientationXGainNode","orientationYGainNode","orientationZGainNode","positionXGainNode","positionYGainNode","positionZGainNode","waveShaperNode","nativePannerNodeFaker","createNativePannerNodeFakerFactory","module_createNativePannerNode","createNativePannerNodeFaker","nativePannerNode","createNativePannerNodeFactory","pannerNodeConstructor","createNativePannerNode","createPannerNodeRenderer","_nativePannerNode","_orientationX","_orientationY","_orientationZ","_positionX","_positionY","_positionZ","createPannerNodeConstructor","renderedNativePannerNodes","renderedNativePannerNode","nativePannerNodeIsOwnedByContext","createPannerNode","createPannerNodeRendererFactory","periodicWaveConstructor","createNativePeriodicWave","createPeriodicWaveConstructor","imag","real","wrappedImag","wrappedReal","createPeriodicWave","createNativePeriodicWaveFactory","module_nativeStereoPannerNodeFakerFactory","DC_CURVE","HALF_PI","SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS","buildInternalGraph","panGainNode","leftWaveShaperCurve","rightWaveShaperCurve","leftGainNode","leftWaveShaperNode","panWaveShaperNode","rightGainNode","rightWaveShaperNode","buildInternalGraphForMono","leftInputForLeftOutputWaveShaperCurve","leftInputForRightOutputWaveShaperCurve","rightInputForLeftOutputWaveShaperCurve","rightInputForRightOutputWaveShaperCurve","CURVE_SIZE","leftInputForLeftOutputGainNode","leftInputForLeftOutputWaveShaperNode","leftInputForRightOutputGainNode","leftInputForRightOutputWaveShaperNode","rightInputForLeftOutputGainNode","rightInputForLeftOutputWaveShaperNode","rightInputForRightOutputGainNode","rightInputForRightOutputWaveShaperNode","buildInternalGraphForStereo","outputNodes","outputNode","createNativeStereoPannerNodeFakerFactory","module_createNativeStereoPannerNode","createNativeStereoPannerNodeFaker","createStereoPanner","nativeStereoPannerNode","createNativeStereoPannerNodeFactory","stereoPannerNodeConstructor","createNativeStereoPannerNode","createStereoPannerNodeRenderer","_pan","createStereoPannerNodeConstructor","renderedNativeStereoPannerNodes","renderedNativeStereoPannerNode","nativeStereoPannerNodeIsOwnedByContext","createStereoPannerNode","createStereoPannerNodeRendererFactory","module_createWaveShaperNodeRenderer","renderedNativeWaveShaperNodes","renderedNativeWaveShaperNode","createWaveShaperNode","createWaveShaperNodeRendererFactory","waveShaperNodeConstructor","createWaveShaperNodeRenderer","_isCurveNullified","_nativeWaveShaperNode","createWaveShaperNodeConstructor","isSecureContext","createIsSecureContext","module_exposeCurrentFrameAndCurrentTime","fn","currentFrame","createExposeCurrentFrameAndCurrentTime","addAudioWorkletModule","createAbortError","exposeCurrentFrameAndCurrentTime","fetchSource","ongoingRequests","resolvedRequests","moduleURL","credentials","absoluteUrl","location","href","audioWorklet","wrappedSource","blob","Blob","createObjectURL","addModule","revokeObjectURL","resolvedRequestsOfContext","ongoingRequestsOfContext","promiseOfOngoingRequest","head","document","SyntaxError","script","createElement","originalOnErrorHandler","onerror","removeErrorEventListenerAndRevokeUrl","message","src","lineno","colno","onload","appendChild","evaluateSource","evaluateAudioWorkletGlobalScope","_AWGS","trim","nodeNameToProcessorConstructorMap","rslvdRqstsFCntxt","ngngRqstsFCntxt","createAddAudioWorkletModule","fetch","ok","text","createFetchSource","isNativeAudioContext","createIsNativeAudioContext","module_isNativeContext","createIsNativeContext","module_baseAudioContextConstructor","gainNodeConstructor","minimalBaseAudioContextConstructor","_audioWorklet","constraints","audioData","successCallback","errorCallback","createBaseAudioContextConstructor","createDataCloneError","createEncodingError","isNativeContext","testAudioBufferCopyChannelMethodsOutOfBoundsSupport","testAudioBufferCopyChannelMethodsSubarraySupport","testPromiseSupport","anyContext","complete","arrayBuffer","detachArrayBuffer","fail","createDecodeAudioData","module_mediaElementAudioSourceNodeConstructor","createNativeMediaElementAudioSourceNode","nativeMediaElementAudioSourceNode","_mediaElement","mediaElement","_nativeMediaElementAudioSourceNode","createMediaElementAudioSourceNodeConstructor","ntvDCntxt","createMediaElementSource","createNativeMediaElementAudioSourceNodeFactory","module_mediaStreamAudioSourceNodeConstructor","createNativeMediaStreamAudioSourceNode","nativeMediaStreamAudioSourceNode","_nativeMediaStreamAudioSourceNode","mediaStream","createMediaStreamAudioSourceNodeConstructor","audioStreamTracks","getAudioTracks","filteredAudioStreamTracks","sort","id","createMediaStreamSource","MediaStream","createNativeMediaStreamAudioSourceNodeFactory","module_mediaStreamTrackAudioSourceNodeConstructor","createNativeMediaStreamTrackAudioSourceNode","createMediaStreamTrackAudioSourceNodeConstructor","mediaStreamTrack","createMediaStreamTrackSource","kind","createNativeMediaStreamTrackAudioSourceNodeFactory","audioContextConstructor","baseAudioContextConstructor","createUnknownError","mediaElementAudioSourceNodeConstructor","mediaStreamAudioSourceNodeConstructor","mediaStreamTrackAudioSourceNodeConstructor","_baseLatency","_nativeAudioContext","_state","revokeState","resolvePromise","resume","suspend","createAudioContextConstructor","module_connectMultipleOutputs","createConnectMultipleOutputs","module_disconnectMultipleOutputs","createDisconnectMultipleOutputs","module_createNativeAudioWorkletNodeFaker","connectMultipleOutputs","disconnectMultipleOutputs","numberOfParameters","messageChannel","gainNodes","inputChannelSplitterNodes","constantSourceNodes","inputChannelMergerNode","outputChannelSplitterNode","outputChannelMergerNodes","parameterMap","outputChannelMergerNode","onprocessorerror","nativeAudioWorkletNodeFaker","port","patchedEventListeners","unpatchedEventListener","handleEvent","patchedEventListener","audioWorkletProcessorPromise","createAudioWorkletProcessor","dWrkltPrcssr","isActive","createNativeAudioWorkletNodeFakerFactory","module_createNativeAudioWorkletNode","createNativeAudioWorkletNodeFaker","nativeAudioWorkletNodeConstructor","hasNoOutput","testClonabilityOfAudioWorkletNodeOptions","createNativeAudioWorkletNodeFactory","module_nativeAudioWorkletNodeConstructor","AudioWorkletNode","createNativeAudioWorkletNodeConstructor","module_createAudioWorkletNodeRenderer","renderedNativeAudioWorkletNodeOrOutputNodes","renderedNativeAudioWorkletNodeOrGainNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","nm","createAudioWorkletNodeRendererFactory","module_createNativeOfflineAudioContext","createAudioWorkletNodeRenderer","createNativeAudioWorkletNode","createChannelCount","sanitizedOptions","_nativeAudioWorkletNode","_numberOfOutputs","_onprocessorerror","_parameters","nativeOnProcessorError","createAudioWorkletNodeConstructor","createMinimalAudioContextConstructor","createCreateNativeOfflineAudioContext","module_startRendering","createStartRendering","offlineAudioContextConstructor","createNativeOfflineAudioContext","delayStateChangeEvent","stopImmediatePropagation","_waitForThePromiseToSettle","_length","_nativeOfflineAudioContext","createMinimalOfflineAudioContextConstructor","createOfflineAudioContextConstructor","isAnyAudioContext","contextStore","createIsAnyAudioContext","isAnyAudioNode","audioNodeStore","createIsAnyAudioNode","isAnyAudioParam","audioParamStore","createIsAnyAudioParam","isAnyOfflineAudioContext","createIsAnyOfflineAudioContext","globalContext","theWindow","self","hasAudioContext","getAudioContext","TONE_AUDIO_CONTEXT","Ticker","updateInterval","_callback","_type","_updateInterval","_createClock","_createWorker","toFixed","blobUrl","worker","Worker","_worker","_createTimeout","_this","_timeout","e","_disposeClock","clearTimeout","terminate","interval","dispose","isAudioParam","arg","AdvancedTypeCheck_isAudioNode","isOfflineAudioContext","isAudioContext","isAudioBuffer","isUndef","isDefined","isFunction","isNumber","isObject","constructor","isBoolean","isString","isNote","noCopy","deepMerge","sources","_i","shift","assign","_b","concat","optionsFromArguments","defaults","argsArray","objKey","opts","Reflect","indexOf","defaultArg","given","fallback","omitFromObject","obj","omit","prop","assert","statement","Tone_Tone","Tone","debug","_wasDisposed","getDefaults","log","TONE_DEBUG_CLASS","console","version","Emitter_Emitter","_super","Emitter","__extends","on","split","eventName","_events","once","boundCallback","off","eventList","emit","len","mixin","constr","getOwnPropertyDescriptor","Timeline_Timeline","Timeline","_timeline","memory","Timeline_extends","Infinity","valueOf","_search","diff","remove","param","peek","getAfter","getBefore","cancel","after","cancelBefore","previousEvent","beginning","end","midPoint","event_1","nextEvent","_iterate","lowerBound","upperBound","forEachBefore","forEachAfter","forEachBetween","forEachFrom","forEachAtTime","notifyNewContext","onContextInit","cb","notifyCloseContext","onContextClose","Context_Context","Context","_constants","_timeouts","_timeoutIds","_initialized","_latencyHint","lookAhead","_ticker","clockSource","_timeoutLoop","Context_extends","initialize","ctx","_transport","t","hint","lookAheadValue","now","sent","getConstant","val","arr","constant","firstEvent","timeout","OfflineContext_OfflineContext","OfflineContext","channels","_currentTime","_duration","OfflineContext_extends","dummyContext","transport","Global_globalContext","getContext","setContext","Global_start","TONE_SILENCE_LOGGING","prefix","printString","dbToGain","db","gainToDb","LN10","intervalToFrequencyRatio","A4","ftom","ftomf","mtof","midi","TimeBase_TimeBaseClass","TimeBaseClass","units","defaultUnits","_val","_units","_expressions","_getExpressions","TimeBase_extends","hz","method","_frequencyToUnits","parseFloat","regexp","_ticksToUnits","parseInt","_beatsToUnits","_getTimeSignature","dot","numericValue","scalar","number","_secondsToUnits","samples","tr","q","total","fromType","_noArg","typeName","quantity","expr","matching","freq","beats","_getBpm","seconds","ticks","_getPPQ","_now","bpm","timeSignature","PPQ","toSeconds","toTicks","toFrequency","toMidi","toSamples","toMilliseconds","Time_TimeClass","TimeClass","Time_extends","capture","quantize","quantTo","nextSubdivision","subdiv","percent","subdivision","toNotation","testNotations","power","closest","closestSeconds","notation","notationSeconds","abs","toBarsBeatsSixteenths","quarterTime","quarters","measures","sixteenths","sixteenthString","Time","Frequency_FrequencyClass","FrequencyClass","Frequency_extends","setA4","note","pitch","octave","noteNumber","noteToScaleIndex","toLowerCase","transpose","harmonize","intervals","toNote","scaleIndexToNote","cbb","c#","cx","dbb","d#","dx","ebb","eb","e#","ex","fbb","fb","f","f#","fx","gbb","gb","g","g#","gx","abb","ab","a#","ax","bbb","bb","b#","bx","Frequency","TransportTimeClass","TransportTime_extends","TransportTime","ToneWithContext_ToneWithContext","ToneWithContext","defaultContext","ToneWithContext_extends","immediate","attribute","member","props","Param_Param","Param","overridden","_minOutput","_param","_initialValue","convert","_toType","Param_extends","getValueAtTime","_fromType","_is","computedTime","isFinite","JSON","stringify","before","beforeValue","previous","_linearInterpolate","_exponentialInterpolate","previousVal","_exponentialApproach","setRampPoint","currentVal","exponentialRampTo","rampTime","linearRampTo","targetRampTo","exponentialApproachValueAtTime","scaling","startingValue","segTime","valueAtTime","sampleTime","rampTo","t0","v0","v1","t1","ToneAudioNode_ToneAudioNode","ToneAudioNode","_internalChannels","ToneAudioNode_extends","_isAudioNode","_getInternalNodes","nodeList","_setChannelProperties","_getChannelProperties","outputNum","inputNum","ToneAudioNode_connect","toDestination","toMaster","warn","ToneAudioNode_disconnect","chain","connectSeries","fan","first","prev","current","srcNode","dstNode","outputNumber","inputNumber","readOnly","str","writable","noOp","Gain_Gain","Gain","_gainNode","Gain_extends","ToneAudioBuffer_ToneAudioBuffer","ToneAudioBuffer","reverse","load","ToneAudioBuffer_extends","_buffer","loaded","_reversed","_reverse","downloads","e_1","fromArray","isMultidimensional","multiChannelArray","toMono","chanNum","toArray","outputArray","numChannels_1","channelArray","ret","startSamples","endSamples","retBuffer","rev","fromUrl","matches","extensions","extension","extensions_1","ext","supportsType","baseUrl","canPlayType","Offline","originalContext","bufferPromise","ToneAudioBuffers_ToneAudioBuffers","ToneAudioBuffers","_buffers","_loadingCount","urls","_bufferLoaded","ToneAudioBuffers_extends","Delay_Delay","Delay","maxDelayInSeconds","maxDelay","_delayNode","Delay_extends","StateTimeline","initial","_initial","StateTimeline_extends","setStateAtTime","getLastState","getNextState","event_2","TickSignal_TickSignal","TickSignal","_sig","_multiplier","multiplier","TickSignal_extends","computedValue","prevEvent","segments","rampVal","ticksUntilTime","_getTicksUntilEvent","computedVal","segmentDur","val0","val1","onTheLineEvent","getTicksAtTime","getDurationOfTicks","currentTick","getTimeOfTick","tick","delta","sol1","ticksToTime","timeToTicks","computedDuration","startTicks","TickSource_TickSource","TickSource","_tickOffset","setTicksAtTime","TickSource_extends","pause","stopEvent","tmpEvent","lastState","elapsedTicks","periodStartTime","offsetEvent","getSecondsAtTime","elapsedSeconds","getStateAtTime","absoluteTicks","forEachTickBetween","computedStartTime","computedEndTime","lastStateEvent","maxStartTime","nextTickTime","Clock_Clock","Clock","_lastUpdate","_boundLoop","_loop","_tickSource","Clock_extends","TicksClass","Ticks_extends","Ticks","Midi_MidiClass","MidiClass","Midi_extends","Midi","Draw_Draw","Draw","expiration","anticipation","_boundDrawLoop","_drawLoop","_animationFrame","Draw_extends","schedule","requestAnimationFrame","cancelAnimationFrame","IntervalTimeline_IntervalTimeline","IntervalTimeline","_root","IntervalTimeline_extends","IntervalNode","insert","updateHeight","updateMax","_rebalance","results","search","results_1","_removeNode","_setRoot","_replaceNodeInParent","replacement","isLeftChild","left","right","temp","getBalance","_rotateLeft","pivotNode","_rotateRight","balance","low","allNodes_1","traverse","searchAfter","high","_left","_right","height","point","Volume_Volume","Volume","volume","_unmutedVolume","mute","Volume_extends","Destination_Destination","Destination","rawContext","Destination_extends","TransportEvent_TransportEvent","TransportEvent","_eventId","_once","invoke","TransportRepeatEvent_TransportRepeatEvent","TransportRepeatEvent","_currentId","_nextId","_nextTick","_boundRestart","_restart","_interval","TransportRepeatEvent_extends","_createEvents","scheduleOnce","Transport_Transport","Transport","_loopStart","_loopEnd","_scheduledEvents","_repeatedEvents","_syncedSignals","_swingAmount","_ppq","ppq","_clock","_processTick","_bindClockEvents","_timeSignature","_swingTicks","Transport_extends","swing","swingSubdivision","tickTime","progress","amount","_addEvent","scheduleRepeat","eventId","item","timeline","computedAfter","offsetTicks","toggle","timeSig","startPosition","endPosition","setLoopPoints","remainingTicks","syncSignal","signal","computedFreq","ratioSignal","unsyncSignal","syncedSignal","Source_Source","Source","_synced","_scheduled","_syncedStart","_syncedStop","_volume","onstop","Source_extends","_clampToCurrentTime","restart","sched","_start","_stop","sync","stateEvent","startOffset","unsync","OneShotSource_OneShotSource","OneShotSource","_stopTime","_fadeIn","fadeIn","_fadeOut","fadeOut","_curve","OneShotSource_extends","_startGain","fadeInTime","_stopGain","cancelStop","fadeOutTime","additionalTail","_stopSource","BufferSource_ToneBufferSource","ToneBufferSource","_source","_sourceStarted","_sourceStopped","BufferSource_extends","computedOffset","computedDur","Noise_Noise","Noise","Noise_extends","_noiseBuffers","rate","random","_noiseCache","brown","pink","white","channelNum","lastOut","b0","b1","b2","b3","b4","b5","b6","Signal_Signal","Signal","override","_constantSource","Signal_extends","connectSignal","OscillatorNode_ToneOscillatorNode","ToneOscillatorNode","_oscillator","OscillatorNode_extends","Oscillator_Oscillator","Oscillator","_partials","partials","_partialCount","partialCount","baseType","phase","Oscillator_extends","oscillator","_wave","syncFrequency","unsyncFrequency","_getCachedPeriodicWave","oscProps","_periodicWaveCache","find","description","_phase","arrayA","arrayB","isBasicType","cache","_getRealImaginary","partial","exec","periodicWaveSize","piFactor","_inverseFFT","_getInitialValue","twoPi","SignalOperator_SignalOperator","SignalOperator","SignalOperator_extends","WaveShaper_WaveShaper","WaveShaper","_shaper","mapping","setMap","WaveShaper_extends","normalized","oversampling","isOverSampleType","includes","AudioToGain_AudioToGain","AudioToGain","_norm","AudioToGain_extends","Multiply_Multiply","Multiply","_mult","factor","Multiply_extends","AMOscillator_AMOscillator","AMOscillator","_modulationScale","_modulationNode","_carrier","_modulator","modulationType","harmonicity","AMOscillator_extends","FMOscillator_FMOscillator","FMOscillator","modulationIndex","FMOscillator_extends","PulseOscillator_PulseOscillator","PulseOscillator","_widthGate","_thresh","width","_sawtooth","PulseOscillator_extends","FatOscillator_FatOscillator","FatOscillator","_oscillators","_spread","spread","count","FatOscillator_extends","_forEach","osc","start_1","step_1","PWMOscillator_PWMOscillator","PWMOscillator","sourceType","_scale","_pulse","modulationFrequency","PWMOscillator_extends","OmniOscillatorSourceMap","am","fat","fm","pulse","pwm","OmniOscillator_OmniOscillator","OmniOscillator","OmniOscillator_extends","_sourceType","substr","_createNewOscillator","_getOscType","oscType","OscConstructor","oldOsc_1","blockTime","sType","mType","Player_Player","Player","_activeSources","_onload","autostart","Player_extends","_onSourceEnd","comptuedOffset","origDuration","implicitEnd","seek","Add_Add","Add","_sum","addend","Add_extends","Abs_Abs","Abs","_abs","Abs_extends","GainToAudio_GainToAudio","GainToAudio","GainToAudio_extends","Negate_Negate","Negate","_multiply","Negate_extends","Subtract_Subtract","Subtract","_neg","subtrahend","Subtract_extends","Zero_Zero","Zero","Zero_extends","Envelope_Envelope","Envelope","decay","sustain","attackCurve","releaseCurve","decayCurve","Envelope_extends","_getCurve","direction","curveName","EnvelopeCurves","_setCurve","curveDef","_attackCurve","_releaseCurve","_decayCurve","triggerAttack","velocity","currentValue","decayValue","decayStart","triggerRelease","triggerAttackRelease","cosineCurve","rippleCurve","curveLen","sineWave","stairsCurve","sineCurve","bounceCurve","invertCurve","out","bounce","In","Out","cosine","exponential","linear","ripple","sine","step","AmplitudeEnvelope_AmplitudeEnvelope","AmplitudeEnvelope","AmplitudeEnvelope_extends","Instrument_Instrument","Instrument","_original_triggerAttack","_original_triggerRelease","Instrument_extends","_syncMethod","timePosition","originalMethod","Monophonic_Monophonic","Monophonic","portamento","onsilence","Monophonic_extends","_triggerEnvelopeAttack","setNote","_triggerEnvelopeRelease","getLevelAtTime","envelope","computedFrequency","portTime","Synth_Synth","Synth","Synth_extends","computedAttack","computedDecay","Sampler_Sampler","Sampler","urlMap","mid","Sampler_extends","_findClosest","notes","difference","closestNote","releaseAll","PolySynth_PolySynth","PolySynth","_availableVoices","_activeVoices","_voices","_gcTimeout","_averageActiveVoices","voice","maxPolyphony","_collectGarbage","PolySynth_extends","_getActiveVoice","_makeVoiceAvailable","activeVoiceIndex","_getNextAvailableVoice","activeVoices","firstAvail","_triggerAttack","midiNote","_triggerRelease","_scheduleEvent","disposed","durationSeconds","v","MembraneSynth_MembraneSynth","MembraneSynth","pitchDecay","octaves","MembraneSynth_extends","hertz","maxNote","ToneEvent_ToneEvent","ToneEvent","_startOffset","_probability","probability","_humanize","humanize","ToneEvent_extends","_rescheduleEvents","startTick","_getLoopDuration","_tick","prob","variation","reschedulTime","lastEvent","loopDuration","Part_Part","Part","events","Part_extends","computedOffset_1","_startNote","at","timeInTicks","next","done","_restartEvent","_setAll","attr","_testLoopBoundries","Sequence_Sequence","Sequence","_part","_seqCallback","_eventsArray","_subdivision","Sequence_extends","_createSequence","_eventsUpdated","_indexTime","_rescheduleSequence","sequence","eventOffset","CrossFade_CrossFade","CrossFade","_panner","_split","_g2a","fade","CrossFade_extends","Effect_Effect","Effect","_dryWet","wet","effectSend","effectReturn","Effect_extends","connectEffect","effect","FeedbackEffect_FeedbackEffect","FeedbackEffect","_feedbackGain","FeedbackEffect_extends","FeedbackDelay_FeedbackDelay","FeedbackDelay","FeedbackDelay_extends","Convolver_Convolver","Convolver","_convolver","Convolver_extends","buff","norm","Merge_Merge","Merge","_merger","Merge_extends","Reverb_Reverb","Reverb","preDelay","Reverb_extends","generate","noiseL","noiseR","merge","Analyser_Analyser","Analyser","_analyser","Analyser_extends","smoothing","Filter_Filter","Filter","_filters","rolloff","Filter_extends","_rolloff","rolloffNum","possibilities","cascadingCount","totalResponse","freqValues","magValues","phaseValues","filterClone","MultibandSplit_MultibandSplit","MultibandSplit","_lowMidFilter","lowFrequency","highFrequency","MultibandSplit_extends","EQ3_EQ3","EQ3","_multibandSplit","_lowGain","_midGain","_highGain","EQ3_extends","Compressor_Compressor","Compressor","_compressor","Compressor_extends","Tone_now","Tone_Transport","Tone_Destination","_defineProperties","Constructor","protoProps","staticProps","instance","_arr","_n","_d","_e","_s","arrayWithHoles","iterableToArrayLimit","nonIterableRest"],"mappings":"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","file":"Tone.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Tone\"] = factory();\n\telse\n\t\troot[\"Tone\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) :\n    (global = global || self, factory(global.automationEvents = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n}(this, function (exports, _slicedToArray, _classCallCheck, _createClass) { 'use strict';\n\n    _slicedToArray = _slicedToArray && _slicedToArray.hasOwnProperty('default') ? _slicedToArray['default'] : _slicedToArray;\n    _classCallCheck = _classCallCheck && _classCallCheck.hasOwnProperty('default') ? _classCallCheck['default'] : _classCallCheck;\n    _createClass = _createClass && _createClass.hasOwnProperty('default') ? _createClass['default'] : _createClass;\n\n    var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {\n      return {\n        startTime: startTime,\n        type: 'setValue',\n        value: value\n      };\n    };\n\n    var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {\n      return {\n        duration: duration,\n        startTime: startTime,\n        type: 'setValueCurve',\n        values: values\n      };\n    };\n\n    var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {\n      var startTime = _ref.startTime,\n          target = _ref.target,\n          timeConstant = _ref.timeConstant;\n      return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n    };\n\n    var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'exponentialRampToValue';\n    };\n\n    var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'linearRampToValue';\n    };\n\n    var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {\n      return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n    };\n\n    var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValue';\n    };\n\n    var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValueCurve';\n    };\n\n    var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {\n      var automationEvent = automationEvents[index];\n      return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n    };\n\n    var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {\n      return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];\n    };\n\n    var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelAndHold';\n    };\n\n    var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelScheduledValues';\n    };\n\n    var getEventTime = function getEventTime(automationEvent) {\n      if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n        return automationEvent.cancelTime;\n      }\n\n      if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n        return automationEvent.endTime;\n      }\n\n      return automationEvent.startTime;\n    };\n\n    var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n          value = _ref.value;\n\n      if (valueAtStartTime === value) {\n        return value;\n      }\n\n      if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {\n        return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));\n      }\n\n      return 0;\n    };\n\n    var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n          value = _ref.value;\n      return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);\n    };\n\n    var interpolateValue = function interpolateValue(values, theoreticIndex) {\n      var lowerIndex = Math.floor(theoreticIndex);\n      var upperIndex = Math.ceil(theoreticIndex);\n\n      if (lowerIndex === upperIndex) {\n        return values[lowerIndex];\n      }\n\n      return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n    };\n\n    var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {\n      var duration = _ref.duration,\n          startTime = _ref.startTime,\n          values = _ref.values;\n      var theoreticIndex = (time - startTime) / duration * (values.length - 1);\n      return interpolateValue(values, theoreticIndex);\n    };\n\n    var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setTarget';\n    };\n\n    var AutomationEventList =\n    /*#__PURE__*/\n    function () {\n      function AutomationEventList(defaultValue) {\n        _classCallCheck(this, AutomationEventList);\n\n        this._automationEvents = [];\n        this._currenTime = 0;\n        this._defaultValue = defaultValue;\n      }\n\n      _createClass(AutomationEventList, [{\n        key: Symbol.iterator,\n        value: function value() {\n          return this._automationEvents[Symbol.iterator]();\n        }\n      }, {\n        key: \"add\",\n        value: function add(automationEvent) {\n          var eventTime = getEventTime(automationEvent);\n\n          if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n            var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) >= eventTime;\n            });\n\n            var removedAutomationEvent = this._automationEvents[index];\n\n            if (index !== -1) {\n              this._automationEvents = this._automationEvents.slice(0, index);\n            }\n\n            if (isCancelAndHoldAutomationEvent(automationEvent)) {\n              var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n              if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n                if (isSetTargetAutomationEvent(lastAutomationEvent)) {\n                  throw new Error('The internal list is malformed.');\n                }\n\n                var startTime = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n                var startValue = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n                var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n                var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n\n                this._automationEvents.push(truncatedAutomationEvent);\n              }\n\n              if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n              }\n\n              if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n                this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(new Float32Array([6, 7]), lastAutomationEvent.startTime, eventTime - lastAutomationEvent.startTime);\n              }\n            }\n          } else {\n            var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) > eventTime;\n            });\n\n            var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];\n\n            if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n              return false;\n            }\n\n            var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n\n            if (_index === -1) {\n              this._automationEvents.push(persistentAutomationEvent);\n            } else {\n              if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {\n                return false;\n              }\n\n              this._automationEvents.splice(_index, 0, persistentAutomationEvent);\n            }\n          }\n\n          return true;\n        }\n      }, {\n        key: \"flush\",\n        value: function flush(time) {\n          var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) > time;\n          });\n\n          if (index > 1) {\n            var remainingAutomationEvents = this._automationEvents.slice(index - 1);\n\n            var firstRemainingAutomationEvent = remainingAutomationEvents[0];\n\n            if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n              remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n            }\n\n            this._automationEvents = remainingAutomationEvents;\n          }\n        }\n      }, {\n        key: \"getValue\",\n        value: function getValue(time) {\n          if (this._automationEvents.length === 0) {\n            return this._defaultValue;\n          }\n\n          var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n          var index = this._automationEvents.findIndex(function (automationEvent) {\n            return getEventTime(automationEvent) > time;\n          });\n\n          var nextAutomationEvent = this._automationEvents[index];\n          var currentAutomationEvent = getEventTime(lastAutomationEvent) <= time ? lastAutomationEvent : this._automationEvents[index - 1];\n\n          if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n            return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n          }\n\n          if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n\n          if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n            if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n              return getValueCurveValueAtTime(time, currentAutomationEvent);\n            }\n\n            return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n          }\n\n          if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n\n          if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n                _getEndTimeAndValueOf2 = _slicedToArray(_getEndTimeAndValueOf, 2),\n                startTime = _getEndTimeAndValueOf2[0],\n                value = _getEndTimeAndValueOf2[1];\n\n            return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n          }\n\n          if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n                _getEndTimeAndValueOf4 = _slicedToArray(_getEndTimeAndValueOf3, 2),\n                _startTime = _getEndTimeAndValueOf4[0],\n                _value = _getEndTimeAndValueOf4[1];\n\n            return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);\n          }\n\n          return this._defaultValue;\n        }\n      }]);\n\n      return AutomationEventList;\n    }();\n\n    var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelAndHold'\n      };\n    };\n\n    var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelScheduledValues'\n      };\n    };\n\n    var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {\n      return {\n        startTime: startTime,\n        target: target,\n        timeConstant: timeConstant,\n        type: 'setTarget'\n      };\n    };\n\n    exports.AutomationEventList = AutomationEventList;\n    exports.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;\n    exports.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;\n    exports.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;\n    exports.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;\n    exports.createSetTargetAutomationEvent = createSetTargetAutomationEvent;\n    exports.createSetValueAutomationEvent = createSetValueAutomationEvent;\n    exports.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","export const version: string = \"14.3.7\";\n","export const createAbortError = () => {\n    try {\n        return new DOMException('', 'AbortError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 20;\n        err.name = 'AbortError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/abort-error.js.map","export const ACTIVE_AUDIO_NODE_STORE = new WeakSet();\nexport const AUDIO_NODE_STORE = new WeakMap();\nexport const AUDIO_GRAPHS = new WeakMap();\nexport const AUDIO_PARAM_STORE = new WeakMap();\nexport const AUDIO_PARAM_AUDIO_NODE_STORE = new WeakMap();\nexport const AUXILIARY_GAIN_NODE_STORE = new WeakMap();\nexport const BACKUP_NATIVE_CONTEXT_STORE = new WeakMap();\nexport const CONTEXT_STORE = new WeakMap();\nexport const DETACHED_ARRAY_BUFFERS = new WeakSet();\nexport const EVENT_LISTENERS = new WeakMap();\n// This clunky name is borrowed from the spec. :-)\nexport const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = new WeakMap();\nexport const NODE_TO_PROCESSOR_MAPS = new WeakMap();\nexport const TEST_RESULTS = new WeakMap();\n//# sourceMappingURL=/build/es2018/globals.js.map","export const createInvalidStateError = () => {\n    try {\n        return new DOMException('', 'InvalidStateError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 11;\n        err.name = 'InvalidStateError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/invalid-state-error.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nimport { CONTEXT_STORE } from '../globals';\nexport const getNativeContext = (context) => {\n    const nativeContext = CONTEXT_STORE.get(context);\n    if (nativeContext === undefined) {\n        throw createInvalidStateError();\n    }\n    return nativeContext;\n};\n//# sourceMappingURL=/build/es2018/helpers/get-native-context.js.map","const handler = {\n    construct() {\n        return handler;\n    }\n};\nexport const isConstructible = (constructible) => {\n    try {\n        const proxy = new Proxy(constructible, handler);\n        new proxy(); // tslint:disable-line:no-unused-expression\n    }\n    catch (_a) {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=/build/es2018/helpers/is-constructible.js.map","/*\n * This massive regex tries to cover all the following cases.\n *\n * import './path';\n * import defaultImport from './path';\n * import { namedImport } from './path';\n * import { namedImport as renamendImport } from './path';\n * import * as namespaceImport from './path';\n * import defaultImport, { namedImport } from './path';\n * import defaultImport, { namedImport as renamendImport } from './path';\n * import defaultImport, * as namespaceImport from './path';\n */\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\nexport const splitImportStatements = (source, url) => {\n    const importStatements = [];\n    let sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n    let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    while (result !== null) {\n        const unresolvedUrl = result[1].slice(1, -1);\n        const importStatementWithResolvedUrl = result[0]\n            .replace(/([\\s]+)?;?$/, '')\n            .replace(unresolvedUrl, (new URL(unresolvedUrl, url)).toString());\n        importStatements.push(importStatementWithResolvedUrl);\n        sourceWithoutImportStatements = sourceWithoutImportStatements\n            .slice(result[0].length)\n            .replace(/^[\\s]+/, '');\n        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    }\n    return [importStatements.join(';'), sourceWithoutImportStatements];\n};\n//# sourceMappingURL=/build/es2018/helpers/split-import-statements.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { evaluateSource } from '../helpers/evaluate-source';\nimport { getNativeContext } from '../helpers/get-native-context';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nconst verifyParameterDescriptors = (parameterDescriptors) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\nconst verifyProcessorCtor = (processorCtor) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n    if (typeof processorCtor.prototype.process !== 'function') {\n        throw new TypeError('The given value for processorCtor should have a callable process() function.');\n    }\n};\nexport const createAddAudioWorkletModule = (createAbortError, createNotSupportedError, exposeCurrentFrameAndCurrentTime, fetchSource, getBackupNativeContext, ongoingRequests, resolvedRequests) => {\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const nativeContext = getNativeContext(context);\n        const absoluteUrl = (new URL(moduleURL, location.href)).toString();\n        // Bug #59: Only Chrome & Opera do implement the audioWorklet property.\n        if (nativeContext.audioWorklet !== undefined) {\n            return fetchSource(moduleURL)\n                .then((source) => {\n                const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                /*\n                 * Bug #86: Chrome Canary does not invoke the process() function if the corresponding AudioWorkletNode has no output.\n                 *\n                 * This is the unminified version of the code used below:\n                 *\n                 * ```js\n                 * `${ importStatements };\n                 * ((registerProcessor) => {${ sourceWithoutImportStatements }\n                 * })((name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                 *\n                 *     constructor (options) {\n                 *         const { hasNoOutput, ...otherParameterData } = options.parameterData;\n                 *\n                 *         if (hasNoOutput === 1) {\n                 *             super({ ...options, numberOfOutputs: 0, outputChannelCount: [ ], parameterData: otherParameterData });\n                 *\n                 *             this._hasNoOutput = true;\n                 *         } else {\n                 *             super(options);\n                 *\n                 *             this._hasNoOutput = false;\n                 *         }\n                 *     }\n                 *\n                 *     process (inputs, outputs, parameters) {\n                 *         return super.process(inputs, (this._hasNoOutput) ? [ ] : outputs, parameters);\n                 *     }\n                 *\n                 * }))`\n                 * ```\n                 */\n                const wrappedSource = `${importStatements};(registerProcessor=>{${sourceWithoutImportStatements}\n})((n,p)=>registerProcessor(n,class extends p{constructor(o){const{hasNoOutput,...q}=o.parameterData;if(hasNoOutput===1){super({...o,numberOfOutputs:0,outputChannelCount:[],parameterData:q});this._h=true}else{super(o);this._h=false}}process(i,o,p){return super.process(i,(this._h)?[]:o,p)}}))`; // tslint:disable-line:max-line-length\n                const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                const url = URL.createObjectURL(blob);\n                const backupNativeContext = getBackupNativeContext(nativeContext);\n                const nativeContextOrBackupNativeContext = (backupNativeContext !== null) ? backupNativeContext : nativeContext;\n                return nativeContextOrBackupNativeContext.audioWorklet\n                    .addModule(url, options)\n                    .then(() => URL.revokeObjectURL(url))\n                    // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                    .catch((err) => {\n                    URL.revokeObjectURL(url);\n                    throw err; // tslint:disable-line:rxjs-throw-error\n                });\n            });\n        }\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n        const promise = fetchSource(moduleURL)\n            .then((source) => {\n            const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n            /*\n             * This is the unminified version of the code used below:\n             *\n             * ```js\n             * ${ importStatements };\n             * ((a, b) => {\n             *     (a[b] = a[b] || [ ]).push(\n             *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n             *             ${ sourceWithoutImportStatements }\n             *         }\n             *     );\n             * })(window, '_AWGS');\n             * ```\n             */\n            // tslint:disable-next-line:max-line-length\n            const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n            // @todo Evaluating the given source code is a possible security problem.\n            return evaluateSource(wrappedSource);\n        })\n            .then(() => {\n            const evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n            if (evaluateAudioWorkletGlobalScope === undefined) {\n                throw new SyntaxError();\n            }\n            exposeCurrentFrameAndCurrentTime(nativeContext, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {\n            }, undefined, (name, processorCtor) => {\n                if (name.trim() === '') {\n                    throw createNotSupportedError();\n                }\n                const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n                if (nodeNameToProcessorConstructorMap !== undefined) {\n                    if (nodeNameToProcessorConstructorMap.has(name)) {\n                        throw createNotSupportedError();\n                    }\n                    verifyProcessorCtor(processorCtor);\n                    verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                    nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                }\n                else {\n                    verifyProcessorCtor(processorCtor);\n                    verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                    NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                }\n            }, nativeContext.sampleRate, undefined, undefined));\n        })\n            .catch((err) => {\n            if (err.name === 'SyntaxError') {\n                throw createAbortError();\n            }\n            throw err; // tslint:disable-line:rxjs-throw-error\n        });\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        }\n        else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n        promise\n            .then(() => {\n            const rslvdRqstsFCntxt = resolvedRequests.get(context);\n            if (rslvdRqstsFCntxt === undefined) {\n                resolvedRequests.set(context, new Set([moduleURL]));\n            }\n            else {\n                rslvdRqstsFCntxt.add(moduleURL);\n            }\n        })\n            .catch(() => { }) // tslint:disable-line:no-empty\n            // @todo Use finally when it becomes available in all supported browsers.\n            .then(() => {\n            const ngngRqstsFCntxt = ongoingRequests.get(context);\n            if (ngngRqstsFCntxt !== undefined) {\n                ngngRqstsFCntxt.delete(moduleURL);\n            }\n        });\n        return promise;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/add-audio-worklet-module.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    fftSize: 2048,\n    maxDecibels: -30,\n    minDecibels: -100,\n    smoothingTimeConstant: 0.8\n};\nexport const createAnalyserNodeConstructor = (createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class AnalyserNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n            const analyserNodeRenderer = ((isNativeOfflineAudioContext(nativeContext))\n                ? createAnalyserNodeRenderer()\n                : null);\n            super(context, 'passive', nativeAnalyserNode, analyserNodeRenderer);\n            this._nativeAnalyserNode = nativeAnalyserNode;\n        }\n        get fftSize() {\n            return this._nativeAnalyserNode.fftSize;\n        }\n        set fftSize(value) {\n            this._nativeAnalyserNode.fftSize = value;\n        }\n        get frequencyBinCount() {\n            return this._nativeAnalyserNode.frequencyBinCount;\n        }\n        get maxDecibels() {\n            return this._nativeAnalyserNode.maxDecibels;\n        }\n        set maxDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const maxDecibels = this._nativeAnalyserNode.maxDecibels;\n            this._nativeAnalyserNode.maxDecibels = value;\n            if (!(value > this._nativeAnalyserNode.minDecibels)) {\n                this._nativeAnalyserNode.maxDecibels = maxDecibels;\n                throw createIndexSizeError();\n            }\n        }\n        get minDecibels() {\n            return this._nativeAnalyserNode.minDecibels;\n        }\n        set minDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const minDecibels = this._nativeAnalyserNode.minDecibels;\n            this._nativeAnalyserNode.minDecibels = value;\n            if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n                this._nativeAnalyserNode.minDecibels = minDecibels;\n                throw createIndexSizeError();\n            }\n        }\n        get smoothingTimeConstant() {\n            return this._nativeAnalyserNode.smoothingTimeConstant;\n        }\n        set smoothingTimeConstant(value) {\n            this._nativeAnalyserNode.smoothingTimeConstant = value;\n        }\n        getByteFrequencyData(array) {\n            this._nativeAnalyserNode.getByteFrequencyData(array);\n        }\n        getByteTimeDomainData(array) {\n            this._nativeAnalyserNode.getByteTimeDomainData(array);\n        }\n        getFloatFrequencyData(array) {\n            this._nativeAnalyserNode.getFloatFrequencyData(array);\n        }\n        getFloatTimeDomainData(array) {\n            this._nativeAnalyserNode.getFloatTimeDomainData(array);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/analyser-node-constructor.js.map","export const getValueForKey = (map, key) => {\n    const value = map.get(key);\n    if (value === undefined) {\n        throw new Error('A value with the given key could not be found.');\n    }\n    return value;\n};\n//# sourceMappingURL=/build/es2018/helpers/get-value-for-key.js.map","import { AUDIO_NODE_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioNode = (audioNode) => {\n    return getValueForKey(AUDIO_NODE_STORE, audioNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-native-audio-node.js.map","export const isOwnedByContext = (nativeAudioNode, nativeContext) => {\n    return nativeAudioNode.context === nativeContext;\n};\n//# sourceMappingURL=/build/es2018/helpers/is-owned-by-context.js.map","import { AUDIO_GRAPHS } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport function getAudioGraph(context) {\n    return getValueForKey(AUDIO_GRAPHS, context);\n}\n//# sourceMappingURL=/build/es2018/helpers/get-audio-graph.js.map","import { getAudioGraph } from './get-audio-graph';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioNodeConnections = (audioNode) => {\n    const audioGraph = getAudioGraph(audioNode.context);\n    return getValueForKey(audioGraph.nodes, audioNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-audio-node-connections.js.map","import { getAudioNodeConnections } from './get-audio-node-connections';\nexport const getAudioNodeRenderer = (audioNode) => {\n    const audioNodeConnections = getAudioNodeConnections(audioNode);\n    if (audioNodeConnections.renderer === null) {\n        throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n    }\n    return audioNodeConnections.renderer;\n};\n//# sourceMappingURL=/build/es2018/helpers/get-audio-node-renderer.js.map","import { getAudioNodeConnections } from './get-audio-node-connections';\nimport { getAudioNodeRenderer } from './get-audio-node-renderer';\nexport const renderInputsOfAudioNode = (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n    const audioNodeConnections = getAudioNodeConnections(audioNode);\n    return Promise\n        .all(audioNodeConnections.activeInputs\n        .map((connections, input) => Array\n        .from(connections)\n        .map(([source, output]) => {\n        return getAudioNodeRenderer(source)\n            .render(source, nativeOfflineAudioContext)\n            .then((node) => node.connect(nativeAudioNode, output, input));\n    }))\n        .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n};\n//# sourceMappingURL=/build/es2018/helpers/render-inputs-of-audio-node.js.map","export const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer) => {\n    try {\n        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n    }\n    catch (_a) {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=/build/es2018/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js.map","export const testAudioBufferCopyChannelMethodsSubarraySupport = (nativeAudioBuffer) => {\n    const source = new Float32Array(2);\n    try {\n        /*\n         * Firefox up to version 67 didn't fully support the copyFromChannel() and copyToChannel() methods. Therefore testing one of those\n         * methods is enough to know if the other one it supported as well.\n         */\n        nativeAudioBuffer.copyFromChannel(source, 0, nativeAudioBuffer.length - 1);\n    }\n    catch (_a) {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=/build/es2018/helpers/test-audio-buffer-copy-channel-methods-subarray-support.js.map","export const createIndexSizeError = () => {\n    try {\n        return new DOMException('', 'IndexSizeError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 1;\n        err.name = 'IndexSizeError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/index-size-error.js.map","import { createIndexSizeError } from '../factories/index-size-error';\nexport const wrapAudioBufferGetChannelDataMethod = (audioBuffer) => {\n    audioBuffer.getChannelData = ((getChannelData) => {\n        return (channel) => {\n            try {\n                return getChannelData.call(audioBuffer, channel);\n            }\n            catch (err) {\n                if (err.code === 12) {\n                    throw createIndexSizeError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            }\n        };\n    })(audioBuffer.getChannelData);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-buffer-get-channel-data-method.js.map","import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testAudioBufferCopyChannelMethodsSubarraySupport } from '../helpers/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createAudioBufferConstructor = (cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds, wrapAudioBufferCopyChannelMethodsSubarray) => {\n    let nativeOfflineAudioContext = null;\n    return class AudioBuffer {\n        constructor(options) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer = (nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)) ?\n                new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate }) :\n                nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().\n            }\n            else if (!cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, () => testAudioBufferCopyChannelMethodsSubarraySupport(audioBuffer))) {\n                wrapAudioBufferCopyChannelMethodsSubarray(audioBuffer);\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                // Bug #157: No browser does allow the bufferOffset to be out-of-bounds.\n            }\n            else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n        // This method needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        copyFromChannel(_1, _2, _3 = 0) { } // tslint:disable-line:no-empty\n        // This method needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        copyToChannel(_1, _2, _3 = 0) { } // tslint:disable-line:no-empty\n        // This method needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        getChannelData(_) {\n            return new Float32Array(0);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-buffer-constructor.js.map","import { EVENT_LISTENERS } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getEventListenersOfAudioNode = (audioNode) => {\n    return getValueForKey(EVENT_LISTENERS, audioNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-event-listeners-of-audio-node.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalState = (audioNode, internalState) => {\n    if (internalState === 'active') {\n        if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n            throw new Error('The AudioNode is already stored.');\n        }\n        ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n    }\n    else {\n        if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n            throw new Error('The AudioNode is not stored.');\n        }\n        ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n    }\n    getEventListenersOfAudioNode(audioNode)\n        .forEach((eventListener) => eventListener(internalState));\n};\n//# sourceMappingURL=/build/es2018/helpers/set-internal-state.js.map","export const wrapEventListener = (target, eventListener) => {\n    if (typeof eventListener === 'function') {\n        return (event) => {\n            const descriptor = { value: target };\n            Object.defineProperties(event, {\n                currentTarget: descriptor,\n                target: descriptor\n            });\n            return eventListener.call(target, event);\n        };\n    }\n    return eventListener;\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-event-listener.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { getNativeContext } from '../helpers/get-native-context';\nimport { setInternalState } from '../helpers/set-internal-state';\nimport { wrapEventListener } from '../helpers/wrap-event-listener';\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n};\nexport const createAudioBufferSourceNodeConstructor = (createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class AudioBufferSourceNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = ((isOffline)\n                ? createAudioBufferSourceNodeRenderer()\n                : null);\n            super(context, 'passive', nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = false;\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n        set buffer(value) {\n            // Bug #71: Edge does not allow to set the buffer to null.\n            try {\n                this._nativeAudioBufferSourceNode.buffer = value;\n            }\n            catch (err) {\n                if (value !== null || err.code !== 17) {\n                    throw err; // tslint:disable-line:rxjs-throw-error\n                }\n                // This will modify the buffer in place. Luckily that works in Edge and has the same effect as setting the buffer to null.\n                if (this._nativeAudioBufferSourceNode.buffer !== null) {\n                    const buffer = this._nativeAudioBufferSourceNode.buffer;\n                    const numberOfChannels = buffer.numberOfChannels;\n                    for (let i = 0; i < numberOfChannels; i += 1) {\n                        buffer\n                            .getChannelData(i)\n                            .fill(0);\n                    }\n                    this._isBufferNullified = true;\n                }\n            }\n            // Bug #72: Only Chrome, Edge & Opera do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n                this._isBufferSet = true;\n            }\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = wrapEventListener(this, value);\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n            this._onended = (nativeOnEnded === wrappedListener) ? value : nativeOnEnded;\n        }\n        get loop() {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n        get loopEnd() {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n        get loopStart() {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n        get playbackRate() {\n            return this._playbackRate;\n        }\n        start(when = 0, offset = 0, duration) {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = (duration === undefined) ? [when, offset] : [when, offset, duration];\n            }\n            else {\n                setInternalState(this, 'active');\n                const setInternalStateToInactive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', setInternalStateToInactive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalState(this, 'passive'), 1000);\n                };\n                this._nativeAudioBufferSourceNode.addEventListener('ended', setInternalStateToInactive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeAudioBufferSourceNode.stop(when);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-buffer-source-node-constructor.js.map","import { AUDIO_PARAM_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioParam = (audioParam) => {\n    return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-native-audio-param.js.map","import { getAudioGraph } from './get-audio-graph';\nimport { getValueForKey } from './get-value-for-key';\nexport function getAudioParamConnections(context, audioParam) {\n    const audioGraph = getAudioGraph(context);\n    return getValueForKey(audioGraph.params, audioParam);\n}\n//# sourceMappingURL=/build/es2018/helpers/get-audio-param-connections.js.map","import { getAudioNodeRenderer } from './get-audio-node-renderer';\nimport { getAudioParamConnections } from './get-audio-param-connections';\nexport const renderInputsOfAudioParam = (context, audioParam, nativeOfflineAudioContext, nativeAudioParam) => {\n    const audioParamConnections = getAudioParamConnections(context, audioParam);\n    return Promise\n        .all(Array\n        .from(audioParamConnections.activeInputs)\n        .map(([source, output]) => {\n        return getAudioNodeRenderer(source)\n            .render(source, nativeOfflineAudioContext)\n            .then((node) => node.connect(nativeAudioParam, output));\n    }));\n};\n//# sourceMappingURL=/build/es2018/helpers/render-inputs-of-audio-param.js.map","import { getNativeAudioParam } from './get-native-audio-param';\nimport { renderInputsOfAudioParam } from './render-inputs-of-audio-param';\nexport const connectAudioParam = (context, nativeOfflineAudioContext, audioParam, nativeAudioParam = getNativeAudioParam(audioParam)) => {\n    return renderInputsOfAudioParam(context, audioParam, nativeOfflineAudioContext, nativeAudioParam);\n};\n//# sourceMappingURL=/build/es2018/helpers/connect-audio-param.js.map","import { getAudioParamRenderer } from './get-audio-param-renderer';\nimport { renderInputsOfAudioParam } from './render-inputs-of-audio-param';\nexport const renderAutomation = (context, nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n    const audioParamRenderer = getAudioParamRenderer(context, audioParam);\n    audioParamRenderer.replay(nativeAudioParam);\n    return renderInputsOfAudioParam(context, audioParam, nativeOfflineAudioContext, nativeAudioParam);\n};\n//# sourceMappingURL=/build/es2018/helpers/render-automation.js.map","import { getAudioParamConnections } from './get-audio-param-connections';\nexport function getAudioParamRenderer(context, audioParam) {\n    const audioParamConnections = getAudioParamConnections(context, audioParam);\n    if (audioParamConnections.renderer === null) {\n        throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n    }\n    return audioParamConnections.renderer;\n}\n//# sourceMappingURL=/build/es2018/helpers/get-audio-param-renderer.js.map","export const isValidLatencyHint = (latencyHint) => {\n    return latencyHint === undefined ||\n        typeof latencyHint === 'number' ||\n        (typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback'));\n};\n//# sourceMappingURL=/build/es2018/helpers/is-valid-latency-hint.js.map","import { wrapEventListener } from './helpers/wrap-event-listener';\nexport class EventTarget {\n    constructor(_nativeEventTarget) {\n        this._nativeEventTarget = _nativeEventTarget;\n        this._listeners = new WeakMap();\n    }\n    addEventListener(type, listener, // @todo EventListenerOrEventListenerObject | null = null,\n    options) {\n        let wrappedEventListener = this._listeners.get(listener);\n        if (wrappedEventListener === undefined) {\n            wrappedEventListener = wrapEventListener(this, listener);\n            if (typeof listener === 'function') {\n                this._listeners.set(listener, wrappedEventListener);\n            }\n        }\n        return this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n    }\n    dispatchEvent(event) {\n        return this._nativeEventTarget.dispatchEvent(event);\n    }\n    removeEventListener(type, listener, // @todo EventListenerOrEventListenerObject | null = null,\n    options) {\n        const wrappedEventListener = this._listeners.get(listener);\n        return this._nativeEventTarget.removeEventListener(type, (wrappedEventListener === undefined) ? null : wrappedEventListener, options);\n    }\n}\n//# sourceMappingURL=/build/es2018/event-target.js.map","export const isAudioNode = (audioNodeOrAudioParam) => {\n    return 'context' in audioNodeOrAudioParam;\n};\n//# sourceMappingURL=/build/es2018/guards/audio-node.js.map","import { isAudioNode } from './audio-node';\nexport const isAudioNodeOutputConnection = (outputConnection) => {\n    return isAudioNode(outputConnection[0]);\n};\n//# sourceMappingURL=/build/es2018/guards/audio-node-output-connection.js.map","export const isAudioWorkletNode = (audioNode) => {\n    return 'port' in audioNode;\n};\n//# sourceMappingURL=/build/es2018/guards/audio-worklet-node.js.map","export const connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    const inputs = nativeDestinationAudioNode.inputs;\n    if (inputs !== undefined) {\n        nativeSourceAudioNode.connect(inputs[input], output, 0);\n        return [inputs[input], output, 0];\n    }\n    nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n    return [nativeDestinationAudioNode, output, input];\n};\n//# sourceMappingURL=/build/es2018/helpers/connect-native-audio-node-to-native-audio-node.js.map","import { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const deleteEventListenerOfAudioNode = (audioNode, eventListener) => {\n    const eventListeners = getEventListenersOfAudioNode(audioNode);\n    if (!eventListeners.delete(eventListener)) {\n        throw new Error('Missing the expected event listener');\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/delete-event-listeners-of-audio-node.js.map","export const disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    const inputs = nativeDestinationAudioNode.inputs;\n    if (input === undefined || output === undefined) {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode);\n    }\n    else if (inputs !== undefined) {\n        nativeSourceAudioNode.disconnect(inputs[input], output, 0);\n    }\n    else {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/disconnect-native-audio-node-from-native-audio-node.js.map","export const insertElementInSet = (set, element, predicate, ignoreDuplicates) => {\n    for (const lmnt of set) {\n        if (predicate(lmnt)) {\n            if (ignoreDuplicates) {\n                return false;\n            }\n            throw Error('The set contains at least one similar element.');\n        }\n    }\n    set.add(element);\n    return true;\n};\n//# sourceMappingURL=/build/es2018/helpers/insert-element-in-set.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isActiveAudioNode = (audioNode) => {\n    return ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/is-active-audio-node.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isPassiveAudioNode = (audioNode) => {\n    return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/is-passive-audio-node.js.map","export const pickElementFromSet = (set, predicate) => {\n    const matchingElements = Array\n        .from(set)\n        .filter(predicate);\n    if (matchingElements.length > 1) {\n        throw Error('More than one element was found.');\n    }\n    if (matchingElements.length === 0) {\n        throw Error('No element was found.');\n    }\n    const [matchingElement] = matchingElements;\n    set.delete(matchingElement);\n    return matchingElement;\n};\n//# sourceMappingURL=/build/es2018/helpers/pick-element-from-set.js.map","import { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { setInternalState } from './set-internal-state';\n// Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\nexport const setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {\n    if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => (connections.size === 0))) {\n        setInternalState(audioNode, 'passive');\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/set-internal-state-to-passive-when-necessary.js.map","export const testAudioNodeDisconnectMethodSupport = (nativeAudioContext) => {\n    return new Promise((resolve) => {\n        const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1);\n        const dummy = nativeAudioContext.createGain();\n        // Bug #95: Safari does not play one sample buffers.\n        const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n        const channelData = ones.getChannelData(0);\n        channelData[0] = 1;\n        channelData[1] = 1;\n        const source = nativeAudioContext.createBufferSource();\n        source.buffer = ones;\n        source.loop = true;\n        source.connect(analyzer);\n        analyzer.connect(nativeAudioContext.destination);\n        source.connect(dummy);\n        source.disconnect(dummy);\n        analyzer.onaudioprocess = (event) => {\n            const chnnlDt = event.inputBuffer.getChannelData(0);\n            if (Array.prototype.some.call(chnnlDt, (sample) => sample === 1)) {\n                resolve(true);\n            }\n            else {\n                resolve(false);\n            }\n            source.stop();\n            analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n            source.disconnect(analyzer);\n            analyzer.disconnect(nativeAudioContext.destination);\n        };\n        source.start();\n    });\n};\n//# sourceMappingURL=/build/es2018/helpers/test-audio-node-disconnect-method-support.js.map","export const isNativeAudioNode = (nativeAudioNodeOrAudioParam) => {\n    return 'context' in nativeAudioNodeOrAudioParam;\n};\n//# sourceMappingURL=/build/es2018/guards/native-audio-node.js.map","import { EventTarget } from '../event-target';\nimport { ACTIVE_AUDIO_NODE_STORE, AUDIO_NODE_STORE, AUXILIARY_GAIN_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioGraph } from '../helpers/get-audio-graph';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { getNativeContext } from '../helpers/get-native-context';\nimport { getValueForKey } from '../helpers/get-value-for-key';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { pickElementFromSet } from '../helpers/pick-element-from-set';\nimport { setInternalState } from '../helpers/set-internal-state';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nconst addAudioNode = (context, audioNode, audioNoderRender, nativeAudioNode) => {\n    const activeInputs = [];\n    for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n        activeInputs.push(new Set());\n    }\n    const { nodes } = getAudioGraph(context);\n    nodes.set(audioNode, {\n        activeInputs,\n        outputs: new Set(),\n        passiveInputs: new WeakMap(),\n        renderer: audioNoderRender\n    });\n};\nconst addActiveInputConnectionToAudioNode = (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n    insertElementInSet(activeInputs[input], [source, output, eventListener], (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output), ignoreDuplicates);\n};\nconst addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {\n    insertElementInSet(activeInputs, [source, output, eventListener], (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output), ignoreDuplicates);\n};\nconst deleteActiveInputConnectionToAudioNode = (activeInputs, source, output, input) => {\n    return pickElementFromSet(activeInputs[input], (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output));\n};\nconst deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {\n    return pickElementFromSet(activeInputs, (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output));\n};\nconst addPassiveInputConnectionToAudioNode = (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n    const passiveInputConnections = passiveInputs.get(source);\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, input, eventListener]]));\n    }\n    else {\n        insertElementInSet(passiveInputConnections, [output, input, eventListener], (passiveInputConnection) => (passiveInputConnection[0] === output && passiveInputConnection[1] === input), ignoreDuplicates);\n    }\n};\nconst addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {\n    const passiveInputConnections = passiveInputs.get(source);\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, eventListener]]));\n    }\n    else {\n        insertElementInSet(passiveInputConnections, [output, eventListener], (passiveInputConnection) => (passiveInputConnection[0] === output), ignoreDuplicates);\n    }\n};\nconst deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => (passiveInputConnection[0] === output && passiveInputConnection[1] === input));\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\nconst deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => (passiveInputConnection[0] === output));\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\nconst addConnectionToAudioNodeOfAudioContext = (source, destination, output, input) => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n    const eventListener = ((type) => {\n        const nativeDestinationAudioNode = getNativeAudioNode(destination);\n        const nativeSourceAudioNode = getNativeAudioNode(source);\n        if (type === 'active') {\n            const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n            addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n            connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n            if (isPassiveAudioNode(destination)) {\n                setInternalState(destination, 'active');\n            }\n        }\n        else if (type === 'passive') {\n            const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n            addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n            disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n            if (isActiveAudioNode(destination)) {\n                setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n            }\n        }\n    });\n    if (insertElementInSet(outputs, [destination, output, input], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input), true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n        }\n        else {\n            addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n        }\n    }\n};\nconst addConnectionToAudioNodeOfOfflineAudioContext = (source, destination, output, input) => {\n    const { activeInputs } = getAudioNodeConnections(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    if (insertElementInSet(outputs, [destination, output, input], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input), true)) {\n        addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, null], true);\n    }\n};\nconst addConnectionToAudioParamOfAudioContext = (source, destination, output) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(source.context, destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n    const eventListener = ((type) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n        if (type === 'active') {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n            nativeAudioNode.connect(nativeAudioParam, output);\n        }\n        else if (type === 'passive') {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n            nativeAudioNode.disconnect(nativeAudioParam, output);\n        }\n    });\n    if (insertElementInSet(outputs, [destination, output], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output), true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        }\n        else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n    }\n};\nconst addConnectionToAudioParamOfOfflineAudioContext = (source, destination, output) => {\n    const { activeInputs } = getAudioParamConnections(source.context, destination);\n    const { outputs } = getAudioNodeConnections(source);\n    if (insertElementInSet(outputs, [destination, output], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output), true)) {\n        addActiveInputConnectionToAudioParam(activeInputs, source, [output, null], true);\n    }\n};\nconst deleteActiveInputConnection = (activeInputConnections, source, output) => {\n    for (const activeInputConnection of activeInputConnections) {\n        if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n            activeInputConnections.delete(activeInputConnection);\n            return activeInputConnection;\n        }\n    }\n    return null;\n};\nconst deleteInputConnectionOfAudioNode = (source, destination, output, input) => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n        return [passiveInputConnection[2], 'passive'];\n    }\n    return [activeInputConnection[2], 'active'];\n};\nconst deleteInputConnectionOfAudioParam = (source, destination, output) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(source.context, destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n        return [passiveInputConnection[1], 'passive'];\n    }\n    return [activeInputConnection[2], 'active'];\n};\nconst deleteInputsOfAudioNode = (source, destination, output, input) => {\n    const [listener, internalState] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (internalState === 'active') {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\nconst deleteInputsOfAudioParam = (source, destination, output) => {\n    const [listener, internalState] = deleteInputConnectionOfAudioParam(source, destination, output);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (internalState === 'active') {\n            getNativeAudioNode(source)\n                .disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\nconst deleteAnyConnection = (source) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, ...outputConnection);\n        }\n    }\n    audioNodeConnectionsOfSource.outputs.clear();\n};\nconst deleteConnectionAtOutput = (source, output) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, ...outputConnection);\n            }\n            else {\n                deleteInputsOfAudioParam(source, ...outputConnection);\n            }\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n};\nconst deleteConnectionToDestination = (source, destination, output, input) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    return Array\n        .from(audioNodeConnectionsOfSource.outputs)\n        .filter((outputConnection) => (outputConnection[0] === destination\n        && (output === undefined || outputConnection[1] === output)\n        && (input === undefined || outputConnection[2] === input)))\n        .reduce((numberOfDeletedConnections, outputConnection) => {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, ...outputConnection);\n        }\n        audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        return numberOfDeletedConnections + 1;\n    }, 0);\n};\nexport const createAudioNodeConstructor = (cacheTestResult, createIndexSizeError, createInvalidAccessError, createNotSupportedError, detectCycles, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext) => {\n    return class AudioNode extends EventTarget {\n        constructor(context, internalState, nativeAudioNode, audioNodeRenderer) {\n            super(nativeAudioNode);\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n            const nativeContext = getNativeContext(context);\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            // @todo Make sure this is not used with an OfflineAudioContext.\n            if (!isNativeOfflineAudioContext(nativeContext) && true !== cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                return testAudioNodeDisconnectMethodSupport(nativeContext);\n            })) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n            if (internalState === 'active') {\n                ACTIVE_AUDIO_NODE_STORE.add(this);\n            }\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n            addAudioNode(context, this, audioNodeRenderer, nativeAudioNode);\n        }\n        get channelCount() {\n            return this._nativeAudioNode.channelCount;\n        }\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n        get channelInterpretation() {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n        get context() {\n            return this._context;\n        }\n        get numberOfInputs() {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n        get numberOfOutputs() {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n        connect(destination, output = 0, input = 0) {\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n                    if (isOffline || isPassiveAudioNode(this)) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n                    else if (isPassiveAudioNode(destination)) {\n                        setInternalState(destination, 'active');\n                    }\n                    // An AudioWorklet needs a connection because it otherwise may truncate the input array.\n                    // @todo Count the number of connections which depend on this auxiliary GainNode to know when it can be removed again.\n                    if (isAudioWorkletNode(destination)) {\n                        const auxiliaryGainNodes = AUXILIARY_GAIN_NODE_STORE.get(nativeDestinationAudioNode);\n                        if (auxiliaryGainNodes === undefined) {\n                            const nativeGainNode = nativeContext.createGain();\n                            nativeGainNode.connect(connection[0], 0, connection[2]);\n                            AUXILIARY_GAIN_NODE_STORE.set(nativeDestinationAudioNode, new Map([[input, nativeGainNode]]));\n                        }\n                        else if (auxiliaryGainNodes.get(input) === undefined) {\n                            const nativeGainNode = nativeContext.createGain();\n                            nativeGainNode.connect(connection[0], 0, connection[2]);\n                            auxiliaryGainNodes.set(input, nativeGainNode);\n                        }\n                    }\n                }\n                catch (err) {\n                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n                    throw err; // tslint:disable-line:rxjs-throw-error\n                }\n                detectCycles(this, destination);\n                if (isOffline) {\n                    addConnectionToAudioNodeOfOfflineAudioContext(this, destination, output, input);\n                }\n                else {\n                    addConnectionToAudioNodeOfAudioContext(this, destination, output, input);\n                }\n                return destination;\n            }\n            const nativeAudioParam = getNativeAudioParam(destination);\n            /*\n             * Bug #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari.\n             */\n            if (nativeAudioParam.name === 'playbackRate') {\n                throw createNotSupportedError();\n            }\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            }\n            catch (err) {\n                // Bug #58: Only Firefox does throw an InvalidStateError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            }\n            detectCycles(this, destination);\n            if (isOffline) {\n                addConnectionToAudioParamOfOfflineAudioContext(this, destination, output);\n            }\n            else {\n                addConnectionToAudioParamOfAudioContext(this, destination, output);\n            }\n        }\n        disconnect(destinationOrOutput, output, input) {\n            if (destinationOrOutput === undefined) {\n                deleteAnyConnection(this);\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n                deleteConnectionAtOutput(this, destinationOrOutput);\n            }\n            else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n                if (isAudioNode(destinationOrOutput)\n                    && input !== undefined\n                    && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n                if (deleteConnectionToDestination(this, destinationOrOutput, output, input) === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-node-constructor.js.map","import { AutomationEventList } from 'automation-events';\nimport { AUDIO_PARAM_AUDIO_NODE_STORE, AUDIO_PARAM_STORE } from '../globals';\nimport { getAudioGraph } from '../helpers/get-audio-graph';\nconst addAudioParam = (context, audioParam, audioParamRenderer) => {\n    const audioGraph = getAudioGraph(context);\n    audioGraph.params.set(audioParam, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: audioParamRenderer });\n};\nexport const createAudioParamFactory = (createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor) => {\n    return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n        const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n        const audioParamRenderer = (isAudioParamOfOfflineAudioContext) ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue() {\n                return nativeAudioParam.defaultValue;\n            },\n            get maxValue() {\n                return (maxValue === null) ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue() {\n                return (minValue === null) ? nativeAudioParam.minValue : minValue;\n            },\n            get value() {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n                // Bug #98: Edge, Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime) {\n                // Bug #28: Edge, Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                }\n                else {\n                    const previousLastEvent = Array\n                        .from(automationEventList)\n                        .pop();\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    const currentLastEvent = Array\n                        .from(automationEventList)\n                        .pop();\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        }\n                        else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n                        }\n                    }\n                }\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value, endTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            linearRampToValueAtTime(value, endTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            setTargetAtTime(target, startTime, timeConstant) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n                return audioParam;\n            },\n            setValueAtTime(value, startTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n                return audioParam;\n            },\n            setValueCurveAtTime(values, startTime, duration) {\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor((endTime) * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((values.length - 1) / duration) * (((firstSample + i) / sampleRate) - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        interpolatedValues[i] = (lowerIndex === upperIndex)\n                            ? values[lowerIndex]\n                            : ((1 - (theoreticIndex - lowerIndex)) * values[lowerIndex])\n                                + ((1 - (upperIndex - theoreticIndex)) * values[upperIndex]);\n                    }\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n                    const timeOfLastSample = lastSample / sampleRate;\n                    if (timeOfLastSample < endTime) {\n                        audioParam.setValueAtTime(interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n                    audioParam.setValueAtTime(values[values.length - 1], endTime);\n                }\n                else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(values, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(values, startTime, duration);\n                }\n                return audioParam;\n            }\n        };\n        AUDIO_PARAM_STORE.set(audioParam, nativeAudioParam);\n        AUDIO_PARAM_AUDIO_NODE_STORE.set(audioParam, audioNode);\n        addAudioParam(audioNode.context, audioParam, audioParamRenderer);\n        return audioParam;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-param-factory.js.map","export class ReadOnlyMap {\n    constructor(parameters) {\n        this._map = new Map(parameters);\n    }\n    get size() {\n        return this._map.size;\n    }\n    entries() {\n        return this._map.entries();\n    }\n    forEach(callback, thisArg = null) {\n        return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));\n    }\n    get(name) {\n        return this._map.get(name);\n    }\n    has(name) {\n        return this._map.has(name);\n    }\n    keys() {\n        return this._map.keys();\n    }\n    values() {\n        return this._map.values();\n    }\n}\n//# sourceMappingURL=/build/es2018/read-only-map.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { getNativeContext } from '../helpers/get-native-context';\nimport { wrapEventListener } from '../helpers/wrap-event-listener';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    outputChannelCount: undefined,\n    parameterData: {},\n    processorOptions: {}\n};\nconst createChannelCount = (length) => {\n    const channelCount = [];\n    for (let i = 0; i < length; i += 1) {\n        channelCount.push(1);\n    }\n    return channelCount;\n};\nconst sanitizedOptions = (options) => {\n    return {\n        ...options,\n        outputChannelCount: (options.outputChannelCount !== undefined) ?\n            options.outputChannelCount :\n            (options.numberOfInputs === 1 && options.numberOfOutputs === 1) ?\n                /*\n                 * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                 * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                 * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                 */\n                [options.channelCount] :\n                createChannelCount(options.numberOfOutputs)\n    };\n};\nexport const createAudioWorkletNodeConstructor = (createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, gainNodeConstructor, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, noneAudioDestinationNodeConstructor) => {\n    return class AudioWorkletNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, name, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = (nodeNameToProcessorConstructorMap === undefined) ?\n                undefined :\n                nodeNameToProcessorConstructorMap.get(name);\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n            const audioWorkletNodeRenderer = ((isOffline)\n                ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor)\n                : null);\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, 'active', nativeAudioWorkletNode, audioWorkletNodeRenderer);\n            const parameters = [];\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n                parameters.push([nm, audioParam]);\n            });\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            // Bug #86 & #87: Every browser but Firefox needs to get an unused output which should not be exposed.\n            this._numberOfOutputs = (options.numberOfOutputs === 0) ? 0 : this._nativeAudioWorkletNode.numberOfOutputs;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n            /*\n             * Bug #86 & #87: Every browser but Firefox needs an output to be connected.\n             *\n             * Bug #50: Only Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore this is currently faked by\n             * using another AudioContext. And that is the reason why this will fail in case of a closed AudioContext.\n             */\n            if (context.state !== 'closed') {\n                const gainNode = new gainNodeConstructor(context, { gain: 0 });\n                try {\n                    this\n                        .connect(gainNode)\n                        .connect(context.destination);\n                }\n                catch (err) {\n                    if (err.name !== 'IndexSizeError') {\n                        throw err; // tslint:disable-line:rxjs-throw-error\n                    }\n                }\n            }\n        }\n        get numberOfOutputs() {\n            return this._numberOfOutputs;\n        }\n        get onprocessorerror() {\n            return this._onprocessorerror;\n        }\n        set onprocessorerror(value) {\n            const wrappedListener = wrapEventListener(this, value);\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n            this._onprocessorerror = (nativeOnProcessorError === wrappedListener) ? value : nativeOnProcessorError;\n        }\n        get parameters() {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return this._nativeAudioWorkletNode.parameters;\n            }\n            return this._parameters;\n        }\n        get port() {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-worklet-node-constructor.js.map","export function copyFromChannel(audioBuffer, \n// @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\nparent, key, channelNumber, bufferOffset) {\n    if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = new Float32Array(128);\n        }\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n        // Bug #5: Safari does not support copyFromChannel().\n    }\n    else {\n        const channelData = audioBuffer.getChannelData(channelNumber);\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        }\n        else {\n            const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n            parent[key].set(slicedInput);\n        }\n    }\n}\n//# sourceMappingURL=/build/es2018/helpers/copy-from-channel.js.map","export const copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {\n    if (typeof audioBuffer.copyToChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n        }\n        // Bug #5: Safari does not support copyToChannel().\n    }\n    else {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer\n                .getChannelData(channelNumber)\n                .set(parent[key], bufferOffset);\n        }\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/copy-to-channel.js.map","export const createNestedArrays = (x, y) => {\n    const arrays = [];\n    for (let i = 0; i < x; i += 1) {\n        const array = [];\n        const length = (typeof y === 'number') ? y : y[i];\n        for (let j = 0; j < length; j += 1) {\n            array.push(new Float32Array(128));\n        }\n        arrays.push(array);\n    }\n    return arrays;\n};\n//# sourceMappingURL=/build/es2018/helpers/create-nested-arrays.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor) => {\n    const { length } = renderedBuffer;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = (numberOfOutputChannels === 0) ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, renderedBuffer.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n    const parameters = Array\n        .from(proxy.parameters.keys())\n        .reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.channelCount; k += 1) {\n                copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs\n                .map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [new Float32Array(0)];\n                }\n                return input;\n            });\n            const activeSourceFlag = audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters);\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', { error }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, disconnectMultipleOutputs, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: options.outputChannelCount[i]\n                    }));\n                }\n                // Bug #87: Expose at least one output to make this node connectable.\n                const outputAudioNodes = (options.numberOfOutputs === 0) ?\n                    [outputChannelSplitterNode] :\n                    outputChannelMergerNodes;\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputAudioNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputAudioNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, (nativeOutputNodes === null) ? nativeAudioWorkletNode : nativeOutputNodes);\n            if (nativeOutputNodes !== null) {\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processorConstructor === undefined) {\n                    throw new Error('Missing the processor constructor.');\n                }\n                if (nativeOfflineAudioContextConstructor === null) {\n                    throw new Error('Missing the native OfflineAudioContext constructor.');\n                }\n                // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                const numberOfParameters = (processorConstructor.parameterDescriptors === undefined)\n                    ? 0\n                    : processorConstructor.parameterDescriptors.length;\n                const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfInputChannels + numberOfParameters, \n                // Ceil the length to the next full render quantum.\n                // Bug #17: Safari does not yet expose the length.\n                Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                const gainNodes = [];\n                const inputChannelSplitterNodes = [];\n                for (let i = 0; i < options.numberOfInputs; i += 1) {\n                    gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                        channelCount: options.channelCount,\n                        channelCountMode: options.channelCountMode,\n                        channelInterpretation: options.channelInterpretation,\n                        gain: 1\n                    }));\n                    inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                        channelCount: options.channelCount,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'discrete',\n                        numberOfOutputs: options.channelCount\n                    }));\n                }\n                const constantSourceNodes = await Promise\n                    .all(Array\n                    .from(proxy.parameters.values())\n                    .map(async (audioParam) => {\n                    const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'discrete',\n                        offset: audioParam.value\n                    });\n                    await renderAutomation(proxy.context, partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n                    return constantSourceNode;\n                }));\n                const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'speakers',\n                    numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                });\n                for (let i = 0; i < options.numberOfInputs; i += 1) {\n                    gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                    for (let j = 0; j < options.channelCount; j += 1) {\n                        inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, (i * options.channelCount) + j);\n                    }\n                }\n                for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                    constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                    constantSourceNode.start(0);\n                }\n                inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                return Promise\n                    .all(gainNodes\n                    .map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode)))\n                    .then(() => renderNativeOfflineAudioContext(partialOfflineAudioContext))\n                    .then(async (renderedBuffer) => {\n                    const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n                    const processedBuffer = await processBuffer(proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor);\n                    if (processedBuffer !== null) {\n                        audioBufferSourceNode.buffer = processedBuffer;\n                        audioBufferSourceNode.start(0);\n                    }\n                    audioBufferSourceNode.connect(outputChannelSplitterNode);\n                    for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                        const outputChannelMergerNode = outputChannelMergerNodes[i];\n                        for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                        }\n                        outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n                    }\n                    return outputGainNode;\n                });\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(proxy.context, nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm));\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(proxy.context, nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm));\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAudioWorkletNodeOrOutputNodes = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrOutputNodes !== undefined) {\n                    const renderedNativeAudioWorkletNodeOrGainNode = Array.isArray(renderedNativeAudioWorkletNodeOrOutputNodes)\n                        ? renderedNativeAudioWorkletNodeOrOutputNodes[2]\n                        : renderedNativeAudioWorkletNodeOrOutputNodes;\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-worklet-node-renderer-factory.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { getNativeAudioNode } from './get-native-audio-node';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {\n    const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n    const nativeAudioWorkletNode = getNativeAudioNode(proxy);\n    return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-audio-worklet-processor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    Q: 1,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 350,\n    gain: 0,\n    type: 'lowpass'\n};\nexport const createBiquadFilterNodeConstructor = (createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class BiquadFilterNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const biquadFilterNodeRenderer = ((isOffline) ? createBiquadFilterNodeRenderer() : null);\n            super(context, 'passive', nativeBiquadFilterNode, biquadFilterNodeRenderer);\n            // Bug #80: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._Q = createAudioParam(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #78: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeBiquadFilterNode.detune, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #77: Chrome, Edge, Firefox, Opera & Safari do not export the correct values for maxValue and minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeBiquadFilterNode.frequency, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #79: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeBiquadFilterNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n        }\n        get Q() {\n            return this._Q;\n        }\n        get detune() {\n            return this._detune;\n        }\n        get frequency() {\n            return this._frequency;\n        }\n        get gain() {\n            return this._gain;\n        }\n        get type() {\n            return this._nativeBiquadFilterNode.type;\n        }\n        set type(value) {\n            this._nativeBiquadFilterNode.type = value;\n        }\n        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n            // Bug #68: Only Chrome & Opera do throw an error if the parameters differ in their length.\n            if ((frequencyHz.length !== magResponse.length) || (magResponse.length !== phaseResponse.length)) {\n                throw createInvalidAccessError();\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/biquad-filter-node-constructor.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 6\n};\nexport const createChannelMergerNodeConstructor = (createChannelMergerNodeRenderer, createNativeChannelMergerNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class ChannelMergerNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n            const channelMergerNodeRenderer = ((isNativeOfflineAudioContext(nativeContext))\n                ? createChannelMergerNodeRenderer()\n                : null);\n            super(context, 'passive', nativeChannelMergerNode, channelMergerNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/channel-merger-node-constructor.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 6,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete',\n    numberOfOutputs: 6\n};\nconst sanitizedOptions = (options) => {\n    return { ...options, channelCount: options.numberOfOutputs };\n};\nexport const createChannelSplitterNodeConstructor = (createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class ChannelSplitterNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n            const channelSplitterNodeRenderer = ((isNativeOfflineAudioContext(nativeContext))\n                ? createChannelSplitterNodeRenderer()\n                : null);\n            super(context, 'passive', nativeChannelSplitterNode, channelSplitterNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/channel-splitter-node-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { getNativeContext } from '../helpers/get-native-context';\nimport { setInternalState } from '../helpers/set-internal-state';\nimport { wrapEventListener } from '../helpers/wrap-event-listener';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    offset: 1\n};\nexport const createConstantSourceNodeConstructor = (createAudioParam, createConstantSourceNodeRendererFactory, createNativeConstantSourceNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class ConstantSourceNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const constantSourceNodeRenderer = ((isOffline)\n                ? createConstantSourceNodeRendererFactory()\n                : null);\n            super(context, 'passive', nativeConstantSourceNode, constantSourceNodeRenderer);\n            this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n            this._nativeConstantSourceNode = nativeConstantSourceNode;\n            /*\n             * Bug #62 & #74: Edge & Safari do not support ConstantSourceNodes and do not export the correct values for maxValue and\n             * minValue for GainNodes.\n             */\n            this._offset = createAudioParam(this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._onended = null;\n        }\n        get offset() {\n            return this._offset;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = wrapEventListener(this, value);\n            this._nativeConstantSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeConstantSourceNode.onended;\n            this._onended = (nativeOnEnded === wrappedListener) ? value : nativeOnEnded;\n        }\n        start(when = 0) {\n            this._nativeConstantSourceNode.start(when);\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.start = when;\n            }\n            else {\n                setInternalState(this, 'active');\n                const setInternalStateToInactive = () => {\n                    this._nativeConstantSourceNode.removeEventListener('ended', setInternalStateToInactive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalState(this, 'passive'), 1000);\n                };\n                this._nativeConstantSourceNode.addEventListener('ended', setInternalStateToInactive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeConstantSourceNode.stop(when);\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/constant-source-node-constructor.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    disableNormalization: false\n};\nexport const createConvolverNodeConstructor = (createConvolverNodeRenderer, createNativeConvolverNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class ConvolverNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const convolverNodeRenderer = ((isOffline) ? createConvolverNodeRenderer() : null);\n            super(context, 'passive', nativeConvolverNode, convolverNodeRenderer);\n            this._isBufferNullified = false;\n            this._nativeConvolverNode = nativeConvolverNode;\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeConvolverNode.buffer;\n        }\n        set buffer(value) {\n            this._nativeConvolverNode.buffer = value;\n            // Bug #115: Safari does not allow to set the buffer to null.\n            if (value === null && this._nativeConvolverNode.buffer !== null) {\n                const nativeContext = this._nativeConvolverNode.context;\n                this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n                this._isBufferNullified = true;\n            }\n            else {\n                this._isBufferNullified = false;\n            }\n        }\n        get normalize() {\n            return this._nativeConvolverNode.normalize;\n        }\n        set normalize(value) {\n            this._nativeConvolverNode.normalize = value;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/convolver-node-constructor.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    delayTime: 0,\n    maxDelayTime: 1\n};\nexport const createDelayNodeConstructor = (createAudioParam, createDelayNodeRenderer, createNativeDelayNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class DelayNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const delayNodeRenderer = ((isOffline)\n                ? createDelayNodeRenderer(mergedOptions.maxDelayTime)\n                : null);\n            super(context, 'passive', nativeDelayNode, delayNodeRenderer);\n            // @todo Edge does not export the correct values for maxValue and minValue.\n            this._delayTime = createAudioParam(this, isOffline, nativeDelayNode.delayTime, mergedOptions.maxDelayTime, 0);\n        }\n        get delayTime() {\n            return this._delayTime;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/delay-node-constructor.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nconst getOutputAudioNodeAtIndex = (createIndexSizeError, outputAudioNodes, output) => {\n    const outputAudioNode = outputAudioNodes[output];\n    if (outputAudioNode === undefined) {\n        throw createIndexSizeError();\n    }\n    return outputAudioNode;\n};\nexport const createDisconnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {\n        if (destinationOrOutput === undefined) {\n            return outputAudioNodes\n                .forEach((outputAudioNode) => outputAudioNode.disconnect());\n        }\n        if (typeof destinationOrOutput === 'number') {\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput)\n                .disconnect();\n        }\n        if (isNativeAudioNode(destinationOrOutput)) {\n            if (output === undefined) {\n                return outputAudioNodes\n                    .forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n            }\n            if (input === undefined) {\n                return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output)\n                    .disconnect(destinationOrOutput, 0);\n            }\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output)\n                .disconnect(destinationOrOutput, 0, input);\n        }\n        if (output === undefined) {\n            return outputAudioNodes\n                .forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n        }\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output)\n            .disconnect(destinationOrOutput, 0);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/disconnect-multiple-outputs.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    attack: 0.003,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    knee: 30,\n    ratio: 12,\n    release: 0.25,\n    threshold: -24\n};\nexport const createDynamicsCompressorNodeConstructor = (createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class DynamicsCompressorNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const dynamicsCompressorNodeRenderer = ((isOffline)\n                ? createDynamicsCompressorNodeRenderer()\n                : null);\n            super(context, 'passive', nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);\n            // Bug #110: Edge does not export the correct values for maxValue and minValue.\n            this._attack = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.attack, 1, 0);\n            this._knee = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.knee, 40, 0);\n            this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n            this._ratio = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.ratio, 20, 1);\n            this._release = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.release, 1, 0);\n            this._threshold = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.threshold, 0, -100);\n        }\n        get attack() {\n            return this._attack;\n        }\n        /*\n         * Bug #108: Only Chrome, Firefox and Opera disallow a channelCount of three and above yet which is why the getter and setter needs\n         * to be overwritten here.\n         */\n        get channelCount() {\n            return this._nativeDynamicsCompressorNode.channelCount;\n        }\n        set channelCount(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n            this._nativeDynamicsCompressorNode.channelCount = value;\n            if (value > 2) {\n                this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n                throw createNotSupportedError();\n            }\n        }\n        /*\n         * Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n         * overwritten here.\n         */\n        get channelCountMode() {\n            return this._nativeDynamicsCompressorNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n            this._nativeDynamicsCompressorNode.channelCountMode = value;\n            if (value === 'max') {\n                this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n                throw createNotSupportedError();\n            }\n        }\n        get knee() {\n            return this._knee;\n        }\n        get ratio() {\n            return this._ratio;\n        }\n        get reduction() {\n            // Bug #111: Safari returns an AudioParam instead of a number.\n            if (typeof this._nativeDynamicsCompressorNode.reduction.value === 'number') {\n                return this._nativeDynamicsCompressorNode.reduction.value;\n            }\n            return this._nativeDynamicsCompressorNode.reduction;\n        }\n        get release() {\n            return this._release;\n        }\n        get threshold() {\n            return this._threshold;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/dynamics-compressor-node-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    gain: 1\n};\nexport const createGainNodeConstructor = (createAudioParam, createGainNodeRenderer, createNativeGainNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class GainNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const gainNodeRenderer = ((isOffline) ? createGainNodeRenderer() : null);\n            super(context, 'passive', nativeGainNode, gainNodeRenderer);\n            // Bug #74: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get gain() {\n            return this._gain;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/gain-node-constructor.js.map","export const createInvalidAccessError = () => {\n    try {\n        return new DOMException('', 'InvalidAccessError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 15;\n        err.name = 'InvalidAccessError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/invalid-access-error.js.map","import { getNativeContext } from '../helpers/get-native-context';\nimport { wrapIIRFilterNodeGetFrequencyResponseMethod } from '../helpers/wrap-iir-filter-node-get-frequency-response-method';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers'\n};\nexport const createIIRFilterNodeConstructor = (createNativeIIRFilterNode, createIIRFilterNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class IIRFilterNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeIIRFilterNode = createNativeIIRFilterNode(nativeContext, isOffline ? null : context.baseLatency, mergedOptions);\n            const iirFilterNodeRenderer = ((isOffline)\n                ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward)\n                : null);\n            super(context, 'passive', nativeIIRFilterNode, iirFilterNodeRenderer);\n            // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n            // @todo Write a test which allows other browsers to remain unpatched.\n            wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n            this._nativeIIRFilterNode = nativeIIRFilterNode;\n        }\n        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/iir-filter-node-constructor.js.map","// This implementation as shamelessly inspired by source code of\n// tslint:disable-next-line:max-line-length\n// {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\nexport const filterBuffer = (feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input, output) => {\n    const inputLength = input.length;\n    let i = bufferIndex;\n    for (let j = 0; j < inputLength; j += 1) {\n        let y = feedforward[0] * input[j];\n        for (let k = 1; k < minLength; k += 1) {\n            const x = (i - k) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n            y += feedforward[k] * xBuffer[x];\n            y -= feedback[k] * yBuffer[x];\n        }\n        for (let k = minLength; k < feedforwardLength; k += 1) {\n            y += feedforward[k] * xBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n        for (let k = minLength; k < feedbackLength; k += 1) {\n            y -= feedback[k] * yBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n        xBuffer[i] = input[j];\n        yBuffer[i] = y;\n        i = (i + 1) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n        output[j] = y;\n    }\n    return i;\n};\n//# sourceMappingURL=/build/es2018/helpers/filter-buffer.js.map","export const testPromiseSupport = (nativeContext) => {\n    // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n    const uint32Array = new Uint32Array([\n        1179011410,\n        40,\n        1163280727,\n        544501094,\n        16,\n        131073,\n        44100,\n        176400,\n        1048580,\n        1635017060,\n        4,\n        0\n    ]);\n    try {\n        // Bug #1: Safari requires a successCallback.\n        const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {\n            // Ignore the success callback.\n        });\n        if (promise === undefined) {\n            return false;\n        }\n        promise.catch(() => {\n            // Ignore rejected errors.\n        });\n        return true;\n    }\n    catch (_a) {\n        // Ignore errors.\n    }\n    return false;\n};\n//# sourceMappingURL=/build/es2018/helpers/test-promise-support.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createMinimalOfflineAudioContextConstructor = (cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering) => {\n    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(options) {\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return (this._state === null) ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return startRendering(this.destination, this._nativeOfflineAudioContext)\n                .then((audioBuffer) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                return audioBuffer;\n            })\n                // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                .catch((err) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/minimal-offline-audio-context-constructor.js.map","export const assignNativeAudioNodeOption = (nativeAudioNode, options, option) => {\n    const value = options[option];\n    if (value !== undefined && value !== nativeAudioNode[option]) {\n        nativeAudioNode[option] = value;\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/assign-native-audio-node-option.js.map","import { assignNativeAudioNodeOption } from './assign-native-audio-node-option';\nexport const assignNativeAudioNodeOptions = (nativeAudioNode, options) => {\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n};\n//# sourceMappingURL=/build/es2018/helpers/assign-native-audio-node-options.js.map","export const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode) => {\n    return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n};\n//# sourceMappingURL=/build/es2018/helpers/test-analyser-node-get-float-time-domain-data-method-support.js.map","export const wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode) => {\n    nativeAnalyserNode.getFloatTimeDomainData = (array) => {\n        const byteTimeDomainData = new Uint8Array(array.length);\n        nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n        const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n        for (let i = 0; i < length; i += 1) {\n            array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n        }\n        return array;\n    };\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-analyser-node-get-float-time-domain-data-method.js.map","export const createNativeAudioBufferConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioBuffer')) {\n        return window.AudioBuffer;\n    }\n    return null;\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-buffer-constructor.js.map","export const assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options, audioParam) => {\n    const value = options[audioParam];\n    if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n        nativeAudioNode[audioParam].value = value;\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/assign-native-audio-node-audio-param-value.js.map","export const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            if ((typeof duration === 'number' && duration < 0) || offset < 0 || when < 0) {\n                throw new RangeError(\"The parameters can't be negative.\");\n            }\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            start.call(nativeAudioScheduledSourceNode, when, offset, duration);\n        };\n    })(nativeAudioScheduledSourceNode.start);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js.map","export const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            if (when < 0) {\n                throw new RangeError(\"The parameter can't be negative.\");\n            }\n            stop.call(nativeAudioScheduledSourceNode, when);\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        let isScheduled = false;\n        return (when = 0, offset = 0, duration) => {\n            if (isScheduled) {\n                throw createInvalidStateError();\n            }\n            start.call(nativeAudioBufferSourceNode, when, offset, duration);\n            isScheduled = true;\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js.map","export const createNativeAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioContext')) {\n        return window.AudioContext;\n    }\n    return (window.hasOwnProperty('webkitAudioContext')) ? window.webkitAudioContext : null;\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-context-constructor.js.map","export const computeBufferSize = (baseLatency, sampleRate) => {\n    if (baseLatency === null) {\n        return 512;\n    }\n    return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};\n//# sourceMappingURL=/build/es2018/helpers/compute-buffer-size.js.map","import { cloneAudioWorkletNodeOptions } from './clone-audio-worklet-node-options';\nexport const createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {\n    const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n    return new processorConstructor(clonedAudioWorkletNodeOptions);\n};\n//# sourceMappingURL=/build/es2018/helpers/create-audio-worklet-processor-promise.js.map","export const cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    return new Promise((resolve, reject) => {\n        const { port1, port2 } = new MessageChannel();\n        port1.onmessage = ({ data }) => {\n            port1.close();\n            port2.close();\n            resolve(data);\n        };\n        port1.onmessageerror = ({ data }) => {\n            port1.close();\n            port2.close();\n            reject(data);\n        };\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port2.postMessage(audioWorkletNodeOptions);\n    });\n};\n//# sourceMappingURL=/build/es2018/helpers/clone-audio-worklet-node-options.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const interceptConnections = (original, interceptor) => {\n    original.connect = ((destination, \n    // @todo TypeScript can't infer the type for the parameters output and input in this case.\n    output = 0, // tslint:disable-line:no-inferrable-types\n    input = 0 // tslint:disable-line:no-inferrable-types\n    ) => {\n        if (isNativeAudioNode(destination)) {\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            interceptor.connect.call(interceptor, destination, output, input);\n            // Bug #11: Safari does not support chaining yet.\n            return destination;\n        }\n        // @todo TypeScript does still assume that connect() returns void.\n        return interceptor.connect.call(interceptor, destination, output);\n    });\n    original.disconnect = function () {\n        // @todo TypeScript cannot infer all the signatures yet.\n        interceptor.disconnect.apply(interceptor, arguments);\n    };\n    return original;\n};\n//# sourceMappingURL=/build/es2018/helpers/intercept-connections.js.map","import { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { filterBuffer } from '../helpers/filter-buffer';\nimport { interceptConnections } from '../helpers/intercept-connections';\nfunction divide(a, b) {\n    const denominator = (b[0] * b[0]) + (b[1] * b[1]);\n    return [(((a[0] * b[0]) + (a[1] * b[1])) / denominator), (((a[1] * b[0]) - (a[0] * b[1])) / denominator)];\n}\nfunction multiply(a, b) {\n    return [((a[0] * b[0]) - (a[1] * b[1])), ((a[0] * b[1]) + (a[1] * b[0]))];\n}\nfunction evaluatePolynomial(coefficient, z) {\n    let result = [0, 0];\n    for (let i = coefficient.length - 1; i >= 0; i -= 1) {\n        result = multiply(result, z);\n        result[0] += coefficient[i];\n    }\n    return result;\n}\nexport const createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError) => {\n    return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const feedbackLength = feedback.length;\n        const feedforwardLength = feedforward.length;\n        const minLength = Math.min(feedbackLength, feedforwardLength);\n        if (feedback.length === 0 || feedback.length > 20) {\n            throw createNotSupportedError();\n        }\n        if (feedback[0] === 0) {\n            throw createInvalidStateError();\n        }\n        if (feedforward.length === 0 || feedforward.length > 20) {\n            throw createNotSupportedError();\n        }\n        if (feedforward[0] === 0) {\n            throw createInvalidStateError();\n        }\n        if (feedback[0] !== 1) {\n            for (let i = 0; i < feedforwardLength; i += 1) {\n                feedforward[i] /= feedback[0];\n            }\n            for (let i = 1; i < feedbackLength; i += 1) {\n                feedback[i] /= feedback[0];\n            }\n        }\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n        scriptProcessorNode.channelCount = channelCount;\n        scriptProcessorNode.channelCountMode = channelCountMode;\n        scriptProcessorNode.channelInterpretation = channelInterpretation;\n        const bufferLength = 32;\n        const bufferIndexes = [];\n        const xBuffers = [];\n        const yBuffers = [];\n        for (let i = 0; i < channelCount; i += 1) {\n            bufferIndexes.push(0);\n            const xBuffer = new Float32Array(bufferLength);\n            const yBuffer = new Float32Array(bufferLength);\n            // @todo Add a test which checks support for TypedArray.prototype.fill().\n            xBuffer.fill(0);\n            yBuffer.fill(0);\n            xBuffers.push(xBuffer);\n            yBuffers.push(yBuffer);\n        }\n        scriptProcessorNode.onaudioprocess = (event) => {\n            const inputBuffer = event.inputBuffer;\n            const outputBuffer = event.outputBuffer;\n            const numberOfChannels = inputBuffer.numberOfChannels;\n            for (let i = 0; i < numberOfChannels; i += 1) {\n                const input = inputBuffer.getChannelData(i);\n                const output = outputBuffer.getChannelData(i);\n                bufferIndexes[i] = filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffers[i], yBuffers[i], bufferIndexes[i], bufferLength, input, output);\n            }\n        };\n        const nyquist = nativeContext.sampleRate / 2;\n        const nativeIIRFilterNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return scriptProcessorNode.channelCount;\n            },\n            set channelCount(value) {\n                scriptProcessorNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return scriptProcessorNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                scriptProcessorNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return scriptProcessorNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                scriptProcessorNode.channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return [scriptProcessorNode];\n            },\n            get numberOfInputs() {\n                return scriptProcessorNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return scriptProcessorNode.numberOfOutputs;\n            },\n            addEventListener(...args) {\n                // @todo Dissallow adding an audioprocess listener.\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n                if ((frequencyHz.length !== magResponse.length) || (magResponse.length !== phaseResponse.length)) {\n                    throw createInvalidAccessError();\n                }\n                const length = frequencyHz.length;\n                for (let i = 0; i < length; i += 1) {\n                    const omega = -Math.PI * (frequencyHz[i] / nyquist);\n                    const z = [Math.cos(omega), Math.sin(omega)];\n                    const numerator = evaluatePolynomial(feedforward, z);\n                    const denominator = evaluatePolynomial(feedback, z);\n                    const response = divide(numerator, denominator);\n                    magResponse[i] = Math.sqrt((response[0] * response[0]) + (response[1] * response[1]));\n                    phaseResponse[i] = Math.atan2(response[1], response[0]);\n                }\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-iir-filter-node-faker-factory.js.map","export const createNotSupportedError = () => {\n    try {\n        return new DOMException('', 'NotSupportedError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 9;\n        err.name = 'NotSupportedError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/not-supported-error.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createOfflineAudioContextConstructor = (baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering) => {\n    return class OfflineAudioContext extends baseAudioContextConstructor {\n        constructor(a, b, c) {\n            let options;\n            if (typeof a === 'number' && b !== undefined && c !== undefined) {\n                options = { length: b, numberOfChannels: a, sampleRate: c };\n            }\n            else if (typeof a === 'object') {\n                options = a;\n            }\n            else {\n                throw new Error('The given parameters are not valid.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return (this._state === null) ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return startRendering(this.destination, this._nativeOfflineAudioContext)\n                .then((audioBuffer) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                return audioBuffer;\n            })\n                // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                .catch((err) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/offline-audio-context-constructor.js.map","import { getNativeContext } from '../helpers/get-native-context';\nimport { setInternalState } from '../helpers/set-internal-state';\nimport { wrapEventListener } from '../helpers/wrap-event-listener';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 440,\n    type: 'sine'\n};\nexport const createOscillatorNodeConstructor = (createAudioParam, createInvalidStateError, createNativeOscillatorNode, createOscillatorNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class OscillatorNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const oscillatorNodeRenderer = ((isOffline) ? createOscillatorNodeRenderer() : null);\n            const nyquist = context.sampleRate / 2;\n            super(context, 'passive', nativeOscillatorNode, oscillatorNodeRenderer);\n            // Bug #81: Edge, Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);\n            // Bug #76: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n            this._nativeOscillatorNode = nativeOscillatorNode;\n            this._onended = null;\n            this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n            if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n                this._oscillatorNodeRenderer.periodicWave =\n                    mergedOptions.periodicWave;\n            }\n        }\n        get detune() {\n            return this._detune;\n        }\n        get frequency() {\n            return this._frequency;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = wrapEventListener(this, value);\n            this._nativeOscillatorNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeOscillatorNode.onended;\n            this._onended = (nativeOnEnded === wrappedListener) ? value : nativeOnEnded;\n        }\n        get type() {\n            return this._nativeOscillatorNode.type;\n        }\n        set type(value) {\n            this._nativeOscillatorNode.type = value;\n            // Bug #57: Edge will not throw an error when assigning the type to 'custom'. But it still will change the value.\n            if (value === 'custom') {\n                throw createInvalidStateError();\n            }\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = null;\n            }\n        }\n        setPeriodicWave(periodicWave) {\n            this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = periodicWave;\n            }\n        }\n        start(when = 0) {\n            this._nativeOscillatorNode.start(when);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.start = when;\n            }\n            else {\n                setInternalState(this, 'active');\n                const setInternalStateToInactive = () => {\n                    this._nativeOscillatorNode.removeEventListener('ended', setInternalStateToInactive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalState(this, 'passive'), 1000);\n                };\n                this._nativeOscillatorNode.addEventListener('ended', setInternalStateToInactive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeOscillatorNode.stop(when);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/oscillator-node-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    coneInnerAngle: 360,\n    coneOuterAngle: 360,\n    coneOuterGain: 0,\n    distanceModel: 'inverse',\n    maxDistance: 10000,\n    orientationX: 1,\n    orientationY: 0,\n    orientationZ: 0,\n    panningModel: 'equalpower',\n    positionX: 0,\n    positionY: 0,\n    positionZ: 0,\n    refDistance: 1,\n    rolloffFactor: 1\n};\nexport const createPannerNodeConstructor = (createAudioParam, createNativePannerNode, createPannerNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class PannerNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const pannerNodeRenderer = ((isOffline) ? createPannerNodeRenderer() : null);\n            super(context, 'passive', nativePannerNode, pannerNodeRenderer);\n            this._nativePannerNode = nativePannerNode;\n            // Bug #74: Edge & Safari do not export the correct values for maxValue and minValue for GainNodes.\n            this._orientationX = createAudioParam(this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._orientationY = createAudioParam(this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._orientationZ = createAudioParam(this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionX = createAudioParam(this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionY = createAudioParam(this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionZ = createAudioParam(this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get coneInnerAngle() {\n            return this._nativePannerNode.coneInnerAngle;\n        }\n        set coneInnerAngle(value) {\n            this._nativePannerNode.coneInnerAngle = value;\n        }\n        get coneOuterAngle() {\n            return this._nativePannerNode.coneOuterAngle;\n        }\n        set coneOuterAngle(value) {\n            this._nativePannerNode.coneOuterAngle = value;\n        }\n        get coneOuterGain() {\n            return this._nativePannerNode.coneOuterGain;\n        }\n        set coneOuterGain(value) {\n            this._nativePannerNode.coneOuterGain = value;\n        }\n        get distanceModel() {\n            return this._nativePannerNode.distanceModel;\n        }\n        set distanceModel(value) {\n            this._nativePannerNode.distanceModel = value;\n        }\n        get maxDistance() {\n            return this._nativePannerNode.maxDistance;\n        }\n        set maxDistance(value) {\n            this._nativePannerNode.maxDistance = value;\n        }\n        get orientationX() {\n            return this._orientationX;\n        }\n        get orientationY() {\n            return this._orientationY;\n        }\n        get orientationZ() {\n            return this._orientationZ;\n        }\n        get panningModel() {\n            return this._nativePannerNode.panningModel;\n        }\n        set panningModel(value) {\n            this._nativePannerNode.panningModel = value;\n        }\n        get positionX() {\n            return this._positionX;\n        }\n        get positionY() {\n            return this._positionY;\n        }\n        get positionZ() {\n            return this._positionZ;\n        }\n        get refDistance() {\n            return this._nativePannerNode.refDistance;\n        }\n        set refDistance(value) {\n            this._nativePannerNode.refDistance = value;\n        }\n        get rolloffFactor() {\n            return this._nativePannerNode.rolloffFactor;\n        }\n        set rolloffFactor(value) {\n            this._nativePannerNode.rolloffFactor = value;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/panner-node-constructor.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    disableNormalization: false\n};\nexport const createPeriodicWaveConstructor = (createNativePeriodicWave) => {\n    return class PeriodicWave {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n            return createNativePeriodicWave(nativeContext, mergedOptions);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/periodic-wave-constructor.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    /*\n     * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n     * behavior.\n     */\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    pan: 0\n};\nexport const createStereoPannerNodeConstructor = (createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class StereoPannerNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const stereoPannerNodeRenderer = ((isOffline) ? createStereoPannerNodeRenderer() : null);\n            super(context, 'passive', nativeStereoPannerNode, stereoPannerNodeRenderer);\n            // Bug #106: Edge does not export a maxValue and minValue property.\n            this._pan = createAudioParam(this, isOffline, nativeStereoPannerNode.pan, 1, -1);\n        }\n        get pan() {\n            return this._pan;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/stereo-panner-node-constructor.js.map","export const createUnknownError = () => {\n    try {\n        return new DOMException('', 'UnknownError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.name = 'UnknownError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/unknown-error.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    curve: null,\n    oversample: 'none'\n};\nexport const createWaveShaperNodeConstructor = (createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class WaveShaperNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const waveShaperNodeRenderer = ((isOffline) ? createWaveShaperNodeRenderer() : null);\n            super(context, 'passive', nativeWaveShaperNode, waveShaperNodeRenderer);\n            this._isCurveNullified = false;\n            this._nativeWaveShaperNode = nativeWaveShaperNode;\n        }\n        get curve() {\n            if (this._isCurveNullified) {\n                return null;\n            }\n            return this._nativeWaveShaperNode.curve;\n        }\n        set curve(value) {\n            // Bug #103: Safari does not allow to set the curve to null.\n            if (value === null) {\n                this._isCurveNullified = true;\n                this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n            }\n            else {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n                if (value.length < 2) {\n                    throw createInvalidStateError();\n                }\n                this._isCurveNullified = false;\n                this._nativeWaveShaperNode.curve = value;\n            }\n        }\n        get oversample() {\n            return this._nativeWaveShaperNode.oversample;\n        }\n        set oversample(value) {\n            this._nativeWaveShaperNode.oversample = value;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wave-shaper-node-constructor.js.map","import { createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent } from 'automation-events';\nimport { createAbortError } from './factories/abort-error';\nimport { createAddAudioWorkletModule } from './factories/add-audio-worklet-module';\nimport { createAnalyserNodeConstructor } from './factories/analyser-node-constructor';\nimport { createAnalyserNodeRendererFactory } from './factories/analyser-node-renderer-factory';\nimport { createAudioBufferConstructor } from './factories/audio-buffer-constructor';\nimport { createAudioBufferSourceNodeConstructor } from './factories/audio-buffer-source-node-constructor';\nimport { createAudioBufferSourceNodeRendererFactory } from './factories/audio-buffer-source-node-renderer-factory';\nimport { createAudioContextConstructor } from './factories/audio-context-constructor';\nimport { createAudioDestinationNodeConstructor } from './factories/audio-destination-node-constructor';\nimport { createAudioDestinationNodeRenderer } from './factories/audio-destination-node-renderer-factory';\nimport { createAudioListenerFactory } from './factories/audio-listener-factory';\nimport { createAudioNodeConstructor } from './factories/audio-node-constructor';\nimport { createAudioParamFactory } from './factories/audio-param-factory';\nimport { createAudioParamRenderer } from './factories/audio-param-renderer';\nimport { createAudioWorkletNodeConstructor } from './factories/audio-worklet-node-constructor';\nimport { createAudioWorkletNodeRendererFactory } from './factories/audio-worklet-node-renderer-factory';\nimport { createBaseAudioContextConstructor } from './factories/base-audio-context-constructor';\nimport { createBiquadFilterNodeConstructor } from './factories/biquad-filter-node-constructor';\nimport { createBiquadFilterNodeRendererFactory } from './factories/biquad-filter-node-renderer-factory';\nimport { createCacheTestResult } from './factories/cache-test-result';\nimport { createChannelMergerNodeConstructor } from './factories/channel-merger-node-constructor';\nimport { createChannelMergerNodeRendererFactory } from './factories/channel-merger-node-renderer-factory';\nimport { createChannelSplitterNodeConstructor } from './factories/channel-splitter-node-constructor';\nimport { createChannelSplitterNodeRendererFactory } from './factories/channel-splitter-node-renderer-factory';\nimport { createConnectMultipleOutputs } from './factories/connect-multiple-outputs';\nimport { createConstantSourceNodeConstructor } from './factories/constant-source-node-constructor';\nimport { createConstantSourceNodeRendererFactory } from './factories/constant-source-node-renderer-factory';\nimport { createConvertNumberToUnsignedLong } from './factories/convert-number-to-unsigned-long';\nimport { createConvolverNodeConstructor } from './factories/convolver-node-constructor';\nimport { createConvolverNodeRendererFactory } from './factories/convolver-node-renderer-factory';\nimport { createCreateNativeOfflineAudioContext } from './factories/create-native-offline-audio-context';\nimport { createDataCloneError } from './factories/data-clone-error';\nimport { createDecodeAudioData } from './factories/decode-audio-data';\nimport { createDelayNodeConstructor } from './factories/delay-node-constructor';\nimport { createDelayNodeRendererFactory } from './factories/delay-node-renderer-factory';\nimport { createDetectCycles } from './factories/detect-cycles';\nimport { createDisconnectMultipleOutputs } from './factories/disconnect-multiple-outputs';\nimport { createDynamicsCompressorNodeConstructor } from './factories/dynamics-compressor-node-constructor';\nimport { createDynamicsCompressorNodeRendererFactory } from './factories/dynamics-compressor-node-renderer-factory';\nimport { createEncodingError } from './factories/encoding-error';\nimport { createExposeCurrentFrameAndCurrentTime } from './factories/expose-current-frame-and-current-time';\nimport { createFetchSource } from './factories/fetch-source';\nimport { createGainNodeConstructor } from './factories/gain-node-constructor';\nimport { createGainNodeRendererFactory } from './factories/gain-node-renderer-factory';\nimport { createGetBackupNativeContext } from './factories/get-backup-native-context';\nimport { createIIRFilterNodeConstructor } from './factories/iir-filter-node-constructor';\nimport { createIIRFilterNodeRendererFactory } from './factories/iir-filter-node-renderer-factory';\nimport { createIndexSizeError } from './factories/index-size-error';\nimport { createInvalidAccessError } from './factories/invalid-access-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsAnyAudioContext } from './factories/is-any-audio-context';\nimport { createIsAnyAudioNode } from './factories/is-any-audio-node';\nimport { createIsAnyAudioParam } from './factories/is-any-audio-param';\nimport { createIsAnyOfflineAudioContext } from './factories/is-any-offline-audio-context';\nimport { createIsNativeAudioContext } from './factories/is-native-audio-context';\nimport { createIsNativeAudioNode } from './factories/is-native-audio-node';\nimport { createIsNativeAudioParam } from './factories/is-native-audio-param';\nimport { createIsNativeContext } from './factories/is-native-context';\nimport { createIsNativeOfflineAudioContext } from './factories/is-native-offline-audio-context';\nimport { createIsSecureContext } from './factories/is-secure-context';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaElementAudioSourceNodeConstructor } from './factories/media-element-audio-source-node-constructor';\nimport { createMediaStreamAudioSourceNodeConstructor } from './factories/media-stream-audio-source-node-constructor';\nimport { createMediaStreamTrackAudioSourceNodeConstructor } from './factories/media-stream-track-audio-source-node-constructor';\nimport { createMinimalAudioContextConstructor } from './factories/minimal-audio-context-constructor';\nimport { createMinimalBaseAudioContextConstructor } from './factories/minimal-base-audio-context-constructor';\nimport { createMinimalOfflineAudioContextConstructor } from './factories/minimal-offline-audio-context-constructor';\nimport { createNativeAnalyserNodeFactory } from './factories/native-analyser-node-factory';\nimport { createNativeAudioBufferConstructor } from './factories/native-audio-buffer-constructor';\nimport { createNativeAudioBufferSourceNodeFactory } from './factories/native-audio-buffer-source-node-factory';\nimport { createNativeAudioContextConstructor } from './factories/native-audio-context-constructor';\nimport { createNativeAudioDestinationNode } from './factories/native-audio-destination-node';\nimport { createNativeAudioNodeFactory } from './factories/native-audio-node-factory';\nimport { createNativeAudioWorkletNodeConstructor } from './factories/native-audio-worklet-node-constructor';\nimport { createNativeAudioWorkletNodeFactory } from './factories/native-audio-worklet-node-factory';\nimport { createNativeAudioWorkletNodeFakerFactory } from './factories/native-audio-worklet-node-faker-factory';\nimport { createNativeBiquadFilterNodeFactory } from './factories/native-biquad-filter-node-factory';\nimport { createNativeChannelMergerNodeFactory } from './factories/native-channel-merger-node-factory';\nimport { createNativeChannelSplitterNodeFactory } from './factories/native-channel-splitter-node-factory';\nimport { createNativeConstantSourceNodeFactory } from './factories/native-constant-source-node-factory';\nimport { createNativeConstantSourceNodeFakerFactory } from './factories/native-constant-source-node-faker-factory';\nimport { createNativeConvolverNodeFactory } from './factories/native-convolver-node-factory';\nimport { createNativeDelayNodeFactory } from './factories/native-delay-node-factory';\nimport { createNativeDynamicsCompressorNodeFactory } from './factories/native-dynamics-compressor-node-factory';\nimport { createNativeGainNodeFactory } from './factories/native-gain-node-factory';\nimport { createNativeIIRFilterNodeFactory } from './factories/native-iir-filter-node-factory';\nimport { createNativeIIRFilterNodeFakerFactory } from './factories/native-iir-filter-node-faker-factory';\nimport { createNativeMediaElementAudioSourceNodeFactory } from './factories/native-media-element-audio-source-node-factory';\nimport { createNativeMediaStreamAudioSourceNodeFactory } from './factories/native-media-stream-audio-source-node-factory';\nimport { createNativeMediaStreamTrackAudioSourceNodeFactory } from './factories/native-media-stream-track-audio-source-node-factory';\nimport { createNativeOfflineAudioContextConstructor } from './factories/native-offline-audio-context-constructor';\nimport { createNativeOscillatorNodeFactory } from './factories/native-oscillator-node-factory';\nimport { createNativePannerNodeFactory } from './factories/native-panner-node-factory';\nimport { createNativePannerNodeFakerFactory } from './factories/native-panner-node-faker-factory';\nimport { createNativePeriodicWaveFactory } from './factories/native-periodic-wave-factory';\nimport { createNativeScriptProcessorNodeFactory } from './factories/native-script-processor-node-factory';\nimport { createNativeStereoPannerNodeFactory } from './factories/native-stereo-panner-node-factory';\nimport { createNativeStereoPannerNodeFakerFactory } from './factories/native-stereo-panner-node-faker-factory';\nimport { createNativeWaveShaperNodeFactory } from './factories/native-wave-shaper-node-factory';\nimport { createNativeWaveShaperNodeFakerFactory } from './factories/native-wave-shaper-node-faker-factory';\nimport { createNoneAudioDestinationNodeConstructor } from './factories/none-audio-destination-node-constructor';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createOfflineAudioContextConstructor } from './factories/offline-audio-context-constructor';\nimport { createOscillatorNodeConstructor } from './factories/oscillator-node-constructor';\nimport { createOscillatorNodeRendererFactory } from './factories/oscillator-node-renderer-factory';\nimport { createPannerNodeConstructor } from './factories/panner-node-constructor';\nimport { createPannerNodeRendererFactory } from './factories/panner-node-renderer-factory';\nimport { createPeriodicWaveConstructor } from './factories/periodic-wave-constructor';\nimport { createRenderNativeOfflineAudioContext } from './factories/render-native-offline-audio-context';\nimport { createStartRendering } from './factories/start-rendering';\nimport { createStereoPannerNodeConstructor } from './factories/stereo-panner-node-constructor';\nimport { createStereoPannerNodeRendererFactory } from './factories/stereo-panner-node-renderer-factory';\nimport { createTestAudioBufferConstructorSupport } from './factories/test-audio-buffer-constructor-support';\nimport { createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport } from './factories/test-audio-buffer-source-node-start-method-consecutive-calls-support';\nimport { createTestAudioBufferSourceNodeStartMethodDurationParameterSupport } from './factories/test-audio-buffer-source-node-start-method-duration-parameter-support';\nimport { createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport } from './factories/test-audio-buffer-source-node-start-method-offset-clamping-support';\nimport { createTestAudioContextCloseMethodSupport } from './factories/test-audio-context-close-method-support';\nimport { createTestAudioContextDecodeAudioDataMethodTypeErrorSupport } from './factories/test-audio-context-decode-audio-data-method-type-error-support';\nimport { createTestAudioContextOptionsSupport } from './factories/test-audio-context-options-support';\nimport { createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport } from './factories/test-audio-scheduled-source-node-start-method-negative-parameters-support';\nimport { createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport } from './factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support';\nimport { createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport } from './factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support';\nimport { createTestAudioWorkletProcessorNoOutputsSupport } from './factories/test-audio-worklet-processor-no-outputs-support';\nimport { createTestChannelSplitterNodeChannelCountSupport } from './factories/test-channel-splitter-node-channel-count-support';\nimport { createTestConstantSourceNodeAccurateSchedulingSupport } from './factories/test-constant-source-node-accurate-scheduling-support';\nimport { createTestConvolverNodeBufferReassignabilitySupport } from './factories/test-convolver-node-buffer-reassignability-support';\nimport { createTestIsSecureContextSupport } from './factories/test-is-secure-context-support';\nimport { createTestOfflineAudioContextCurrentTimeSupport } from './factories/test-offline-audio-context-current-time-support';\nimport { createTestStereoPannerNodeDefaultValueSupport } from './factories/test-stereo-panner-node-default-value-support';\nimport { createUnknownError } from './factories/unknown-error';\nimport { createWaveShaperNodeConstructor } from './factories/wave-shaper-node-constructor';\nimport { createWaveShaperNodeRendererFactory } from './factories/wave-shaper-node-renderer-factory';\nimport { createWindow } from './factories/window';\nimport { createWrapAudioBufferCopyChannelMethods } from './factories/wrap-audio-buffer-copy-channel-methods';\nimport { createWrapAudioBufferCopyChannelMethodsOutOfBounds } from './factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds';\nimport { createWrapAudioBufferCopyChannelMethodsSubarray } from './factories/wrap-audio-buffer-copy-channel-methods-subarray';\nimport { createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls } from './factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls';\nimport { createWrapChannelMergerNode } from './factories/wrap-channel-merger-node';\nimport { AUDIO_NODE_STORE, AUDIO_PARAM_AUDIO_NODE_STORE, AUDIO_PARAM_STORE, CONTEXT_STORE } from './globals';\nimport { getAudioNodeConnections } from './helpers/get-audio-node-connections';\nimport { getValueForKey } from './helpers/get-value-for-key';\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from './helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testAudioBufferCopyChannelMethodsSubarraySupport } from './helpers/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { testPromiseSupport } from './helpers/test-promise-support';\nimport { testTransferablesSupport } from './helpers/test-transferables-support';\nimport { wrapAudioBufferSourceNodeStartMethodOffsetClamping } from './helpers/wrap-audio-buffer-source-node-start-method-offset-clamping';\nconst cacheTestResult = createCacheTestResult(new Map());\nconst window = createWindow();\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window);\nconst getBackupNativeContext = createGetBackupNativeContext(isNativeOfflineAudioContext, nativeAudioContextConstructor, nativeOfflineAudioContextConstructor);\nconst createNativeAudioNode = createNativeAudioNodeFactory(getBackupNativeContext);\nconst createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError, createNativeAudioNode);\nconst createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode);\nconst isNativeAudioNode = createIsNativeAudioNode(window);\nconst isNativeAudioParam = createIsNativeAudioParam(window);\nconst audioNodeConstructor = createAudioNodeConstructor(cacheTestResult, createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDetectCycles(AUDIO_PARAM_AUDIO_NODE_STORE, createNotSupportedError, getAudioNodeConnections, getValueForKey), isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext);\nconst noneAudioDestinationNodeConstructor = createNoneAudioDestinationNodeConstructor(audioNodeConstructor);\nconst analyserNodeConstructor = createAnalyserNodeConstructor(createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nexport { analyserNodeConstructor as AnalyserNode };\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst wrapAudioBufferCopyChannelMethodsSubarray = createWrapAudioBufferCopyChannelMethodsSubarray(convertNumberToUnsignedLong, createIndexSizeError);\nconst audioBufferConstructor = createAudioBufferConstructor(cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds, wrapAudioBufferCopyChannelMethodsSubarray);\nexport { audioBufferConstructor as AudioBuffer };\nconst testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport(createNativeAudioNode);\nconst testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(createNativeAudioNode);\nconst testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport(createNativeAudioNode);\nconst wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(createNativeAudioNode);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(cacheTestResult, createNativeAudioNode, createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(createNativeAudioNode), createTestAudioBufferSourceNodeStartMethodDurationParameterSupport(nativeOfflineAudioContextConstructor), createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport(createNativeAudioNode), testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(createNativeAudioBufferSourceNode);\nconst createAudioParam = createAudioParamFactory(createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor);\nconst audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nexport { audioBufferSourceNodeConstructor as AudioBufferSourceNode };\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, isNativeOfflineAudioContext);\nconst createNativeBiquadFilterNode = createNativeBiquadFilterNodeFactory(createNativeAudioNode);\nconst createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(createNativeBiquadFilterNode);\nconst biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, createNativeAudioNode);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(createNativeAudioNode, wrapChannelMergerNode);\nconst createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode);\nconst channelMergerNodeConstructor = createChannelMergerNodeConstructor(createChannelMergerNodeRenderer, createNativeChannelMergerNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeChannelSplitterNode = createNativeChannelSplitterNodeFactory(createNativeAudioNode);\nconst createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode);\nconst channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeGainNode = createNativeGainNodeFactory(createNativeAudioNode);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(createNativeAudioBufferSourceNode, createNativeGainNode);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(cacheTestResult, createNativeAudioNode, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);\nconst createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(createNativeConstantSourceNode);\nconst constantSourceNodeConstructor = createConstantSourceNodeConstructor(createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeConvolverNode = createNativeConvolverNodeFactory(createNativeAudioNode, createNotSupportedError);\nconst createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode);\nconst convolverNodeConstructor = createConvolverNodeConstructor(createConvolverNodeRenderer, createNativeConvolverNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeDelayNode = createNativeDelayNodeFactory(createNativeAudioNode);\nconst createDelayNodeRenderer = createDelayNodeRendererFactory(createNativeDelayNode);\nconst delayNodeConstructor = createDelayNodeConstructor(createAudioParam, createDelayNodeRenderer, createNativeDelayNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNativeAudioNode, createNotSupportedError);\nconst createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(createNativeDynamicsCompressorNode);\nconst dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createGainNodeRenderer = createGainNodeRendererFactory(createNativeGainNode);\nconst gainNodeConstructor = createGainNodeConstructor(createAudioParam, createGainNodeRenderer, createNativeGainNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeScriptProcessorNode = createNativeScriptProcessorNodeFactory(createNativeAudioNode);\nconst createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));\nconst createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, createNativeAudioNode, nativeOfflineAudioContextConstructor, renderNativeOfflineAudioContext);\nconst createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeAudioNode, createNativeIIRFilterNodeFaker);\nconst iIRFilterNodeConstructor = createIIRFilterNodeConstructor(createNativeIIRFilterNode, createIIRFilterNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext);\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener);\nconst createNativeOscillatorNode = createNativeOscillatorNodeFactory(cacheTestResult, createNativeAudioNode, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(createNativeOscillatorNode);\nconst oscillatorNodeConstructor = createOscillatorNodeConstructor(createAudioParam, createInvalidStateError, createNativeOscillatorNode, createOscillatorNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createInvalidStateError, createNativeAudioNode, createNativeGainNode);\nconst createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker);\nconst createNativePannerNodeFaker = createNativePannerNodeFakerFactory(createInvalidStateError, createNativeAudioNode, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError);\nconst createNativePannerNode = createNativePannerNodeFactory(createNativeAudioNode, createNativePannerNodeFaker);\nconst createPannerNodeRenderer = createPannerNodeRendererFactory(createNativePannerNode);\nconst pannerNodeConstructor = createPannerNodeConstructor(createAudioParam, createNativePannerNode, createPannerNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativePeriodicWave = createNativePeriodicWaveFactory(getBackupNativeContext);\nconst periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave);\nconst nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError);\nconst createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(createNativeAudioNode, nativeStereoPannerNodeFakerFactory, createNotSupportedError);\nconst createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(createNativeStereoPannerNode);\nconst stereoPannerNodeConstructor = createStereoPannerNodeConstructor(createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode);\nconst waveShaperNodeConstructor = createWaveShaperNodeConstructor(createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst isSecureContext = createIsSecureContext(window);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window);\n// The addAudioWorkletModule() function is only available in a SecureContext.\nexport const addAudioWorkletModule = (isSecureContext) ?\n    createAddAudioWorkletModule(createAbortError, createNotSupportedError, exposeCurrentFrameAndCurrentTime, createFetchSource(createAbortError), getBackupNativeContext, new WeakMap(), new WeakMap()) :\n    undefined;\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\nexport const decodeAudioData = createDecodeAudioData(cacheTestResult, createDataCloneError, createEncodingError, nativeOfflineAudioContextConstructor, isNativeContext, isNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testAudioBufferCopyChannelMethodsSubarraySupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds, wrapAudioBufferCopyChannelMethodsSubarray);\nconst baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);\nconst createNativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNodeFactory(createNativeAudioNode);\nconst mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(createNativeMediaElementAudioSourceNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNodeFactory(createInvalidStateError, createNativeAudioNode);\nconst mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(createNativeMediaStreamAudioSourceNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, createNativeAudioNode);\nconst mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(createNativeMediaStreamTrackAudioSourceNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);\nexport { audioContextConstructor as AudioContext };\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNotSupportedError, isNativeOfflineAudioContext);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, disconnectMultipleOutputs, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderNativeOfflineAudioContext);\n// The AudioWorkletNode constructor is only available in a SecureContext.\nconst audioWorkletNodeConstructor = (isSecureContext) ?\n    createAudioWorkletNodeConstructor(createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, gainNodeConstructor, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, noneAudioDestinationNodeConstructor) :\n    undefined;\nexport { audioWorkletNodeConstructor as AudioWorkletNode };\nexport { biquadFilterNodeConstructor as BiquadFilterNode };\nexport { channelMergerNodeConstructor as ChannelMergerNode };\nexport { channelSplitterNodeConstructor as ChannelSplitterNode };\nexport { convolverNodeConstructor as ConvolverNode };\nexport { constantSourceNodeConstructor as ConstantSourceNode };\nexport { delayNodeConstructor as DelayNode };\nexport { dynamicsCompressorNodeConstructor as DynamicsCompressorNode };\nexport { gainNodeConstructor as GainNode };\nexport { iIRFilterNodeConstructor as IIRFilterNode };\nexport { mediaElementAudioSourceNodeConstructor as MediaElementAudioSourceNode };\nexport { mediaStreamAudioSourceNodeConstructor as MediaStreamAudioSourceNode };\nexport { mediaStreamTrackAudioSourceNodeConstructor as MediaStreamTrackAudioSourceNode };\nconst minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);\nexport { minimalAudioContextConstructor as MinimalAudioContext };\nconst createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);\nconst startRendering = createStartRendering(cacheTestResult, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testAudioBufferCopyChannelMethodsSubarraySupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds, wrapAudioBufferCopyChannelMethodsSubarray);\nconst minimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);\nexport { minimalOfflineAudioContextConstructor as MinimalOfflineAudioContext };\nconst offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);\nexport { offlineAudioContextConstructor as OfflineAudioContext };\nexport { oscillatorNodeConstructor as OscillatorNode };\nexport { pannerNodeConstructor as PannerNode };\nexport { periodicWaveConstructor as PeriodicWave };\nexport { stereoPannerNodeConstructor as StereoPannerNode };\nexport { waveShaperNodeConstructor as WaveShaperNode };\nexport const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\nexport const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\nexport const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\nexport const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\nexport const isSupported = () => createIsSupportedPromise(cacheTestResult, createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor), createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor), createTestAudioContextOptionsSupport(nativeAudioContextConstructor), createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), createTestChannelSplitterNodeChannelCountSupport(nativeOfflineAudioContextConstructor), createTestConstantSourceNodeAccurateSchedulingSupport(createNativeAudioNode, nativeOfflineAudioContextConstructor), createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor), createTestIsSecureContextSupport(window), createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor), testTransferablesSupport);\n//# sourceMappingURL=/build/es2018/module.js.map","import { TEST_RESULTS } from '../globals';\nexport const createCacheTestResult = (ongoingTests) => {\n    return (tester, test) => {\n        const cachedTestResult = TEST_RESULTS.get(tester);\n        if (cachedTestResult !== undefined) {\n            return cachedTestResult;\n        }\n        const ongoingTest = ongoingTests.get(tester);\n        if (ongoingTest !== undefined) {\n            return ongoingTest;\n        }\n        const synchronousTestResult = test();\n        if (synchronousTestResult instanceof Promise) {\n            ongoingTests.set(tester, synchronousTestResult);\n            return synchronousTestResult\n                .then((finalTestResult) => {\n                ongoingTests.delete(tester);\n                TEST_RESULTS.set(tester, finalTestResult);\n                return finalTestResult;\n            });\n        }\n        TEST_RESULTS.set(tester, synchronousTestResult);\n        return synchronousTestResult;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/cache-test-result.js.map","export const createWindow = () => (typeof window === 'undefined') ? null : window;\n//# sourceMappingURL=/build/es2018/factories/window.js.map","export const createNativeOfflineAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('OfflineAudioContext')) {\n        return window.OfflineAudioContext;\n    }\n    return (window.hasOwnProperty('webkitOfflineAudioContext')) ? window.webkitOfflineAudioContext : null;\n};\n//# sourceMappingURL=/build/es2018/factories/native-offline-audio-context-constructor.js.map","export const createIsNativeOfflineAudioContext = (nativeOfflineAudioContextConstructor) => {\n    return (anything) => {\n        return (nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-native-offline-audio-context.js.map","import { BACKUP_NATIVE_CONTEXT_STORE } from '../globals';\nexport const createGetBackupNativeContext = (isNativeOfflineAudioContext, nativeAudioContextConstructor, nativeOfflineAudioContextConstructor) => {\n    return (nativeContext) => {\n        /*\n         * Bug #50: Only Edge does currently not allow to create AudioNodes on a closed context yet which is why there needs to be no\n         * backupNativeContext in that case.\n         */\n        if (nativeContext.state === 'closed'\n            && nativeAudioContextConstructor !== null\n            && nativeAudioContextConstructor.name !== 'webkitAudioContext') {\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                const backupNativeContext = BACKUP_NATIVE_CONTEXT_STORE.get(nativeContext);\n                if (backupNativeContext !== undefined) {\n                    return backupNativeContext;\n                }\n                if (nativeOfflineAudioContextConstructor !== null) {\n                    // @todo Copy the attached AudioWorkletProcessors and other settings.\n                    const bckpNtveCntxt = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n                    BACKUP_NATIVE_CONTEXT_STORE.set(nativeContext, bckpNtveCntxt);\n                    return bckpNtveCntxt;\n                }\n            }\n            else {\n                const backupNativeContext = BACKUP_NATIVE_CONTEXT_STORE.get(nativeContext);\n                if (backupNativeContext !== undefined) {\n                    return backupNativeContext;\n                }\n                // @todo Copy the attached AudioWorkletProcessors and other settings.\n                const bckpNtveCntxt = new nativeAudioContextConstructor();\n                BACKUP_NATIVE_CONTEXT_STORE.set(nativeContext, bckpNtveCntxt);\n                return bckpNtveCntxt;\n            }\n        }\n        return null;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/get-backup-native-context.js.map","export const createNativeAudioNodeFactory = (getBackupNativeContext) => {\n    return (nativeContext, factoryFunction) => {\n        // Bug #50: Only Edge does currently not allow to create AudioNodes on a closed context yet.\n        const backupNativeContext = getBackupNativeContext(nativeContext);\n        if (backupNativeContext !== null) {\n            return factoryFunction(backupNativeContext);\n        }\n        return factoryFunction(nativeContext);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-node-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { testAnalyserNodeGetFloatTimeDomainDataMethodSupport } from '../helpers/test-analyser-node-get-float-time-domain-data-method-support';\nimport { wrapAnalyserNodeGetFloatTimeDomainDataMethod } from '../helpers/wrap-analyser-node-get-float-time-domain-data-method';\nexport const createNativeAnalyserNodeFactory = (cacheTestResult, createIndexSizeError, createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeAnalyserNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createAnalyser());\n        // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n        assignNativeAudioNodeOptions(nativeAnalyserNode, options);\n        // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n        if (!(options.maxDecibels > options.minDecibels)) {\n            throw createIndexSizeError();\n        }\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant');\n        // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n        if (!cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () => testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode))) {\n            wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n        }\n        return nativeAnalyserNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-analyser-node-factory.js.map","import { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createAnalyserNodeRendererFactory = (createNativeAnalyserNode) => {\n    return () => {\n        const renderedNativeAnalyserNodes = new WeakMap();\n        const createAnalyserNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAnalyserNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n            if (!nativeAnalyserNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAnalyserNode.channelCount,\n                    channelCountMode: nativeAnalyserNode.channelCountMode,\n                    channelInterpretation: nativeAnalyserNode.channelInterpretation,\n                    fftSize: nativeAnalyserNode.fftSize,\n                    maxDecibels: nativeAnalyserNode.maxDecibels,\n                    minDecibels: nativeAnalyserNode.minDecibels,\n                    smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n                };\n                nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode);\n            return nativeAnalyserNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAnalyserNode !== undefined) {\n                    return Promise.resolve(renderedNativeAnalyserNode);\n                }\n                return createAnalyserNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/analyser-node-renderer-factory.js.map","export const createIsNativeAudioNode = (window) => {\n    return (anything) => {\n        return (window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-native-audio-node.js.map","export const createIsNativeAudioParam = (window) => {\n    return (anything) => {\n        return (window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-native-audio-param.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {\n    const connections = new Map();\n    nativeAudioNode.connect = ((connect) => {\n        return (destination, output = 0, input = 0) => {\n            const returnValue = (isNativeAudioNode(destination))\n                ? connect(destination, output, input)\n                : connect(destination, output);\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            }\n            else {\n                if (connectionsToDestination.every((connection) => (connection.input !== input || connection.output !== output))) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput, output, input) => {\n            disconnect.apply(nativeAudioNode);\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination\n                        .filter((connection) => (connection.output !== destinationOrOutput));\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    }\n                    else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            }\n            else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                }\n                else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination\n                            .filter((connection) => (connection.output !== output && (connection.input !== input || input === undefined)));\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        }\n                        else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination\n                    .forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    }\n                    else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-node-disconnect-method.js.map","import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nexport const createDetectCycles = (audioParamAudioNodeStore, createNotSupportedError, getAudioNodeConnections, getValueForKey) => {\n    return function detectCycles(source, destination) {\n        const audioNodeOfDestination = (isAudioNode(destination))\n            ? destination\n            : getValueForKey(audioParamAudioNodeStore, destination);\n        if (isDelayNode(audioNodeOfDestination)) {\n            return true;\n        }\n        if (source === audioNodeOfDestination) {\n            throw createNotSupportedError();\n        }\n        const { outputs } = getAudioNodeConnections(audioNodeOfDestination);\n        for (const outputConnection of outputs) {\n            if (detectCycles(source, outputConnection[0])) {\n                return true;\n            }\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/detect-cycles.js.map","export const isDelayNode = (audioNode) => {\n    return 'delayTime' in audioNode;\n};\n//# sourceMappingURL=/build/es2018/guards/delay-node.js.map","export const createNoneAudioDestinationNodeConstructor = (audioNodeConstructor) => {\n    return class NoneAudioDestinationNode extends audioNodeConstructor {\n        constructor(context, internalState, nativeAudioNode, audioNodeRenderer) {\n            super(context, internalState, nativeAudioNode, audioNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/none-audio-destination-node-constructor.js.map","export const createConvertNumberToUnsignedLong = (unit32Array) => {\n    return (value) => {\n        unit32Array[0] = value;\n        return unit32Array[0];\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/convert-number-to-unsigned-long.js.map","export const createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong, createIndexSizeError) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const destinationLength = destination.length;\n            for (let i = (bufferOffset < 0) ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n                destination[i] = channelData[i + bufferOffset];\n            }\n        };\n        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const sourceLength = source.length;\n            for (let i = (bufferOffset < 0) ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n                channelData[i + bufferOffset] = source[i];\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-audio-buffer-copy-channel-methods.js.map","export const createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyFromChannel);\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js.map","export const createWrapAudioBufferCopyChannelMethodsSubarray = (convertNumberToUnsignedLong, createIndexSizeError) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (channelNumber >= audioBuffer.numberOfChannels) {\n                    throw createIndexSizeError();\n                }\n                if (bufferOffset < audioBuffer.length && audioBuffer.length - bufferOffset < destination.length) {\n                    return copyFromChannel.call(audioBuffer, destination.subarray(0, audioBuffer.length - bufferOffset), channelNumber, bufferOffset);\n                }\n                return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n            };\n        })(audioBuffer.copyFromChannel);\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (channelNumber >= audioBuffer.numberOfChannels) {\n                    throw createIndexSizeError();\n                }\n                if (bufferOffset < audioBuffer.length && audioBuffer.length - bufferOffset < source.length) {\n                    return copyToChannel.call(audioBuffer, source.subarray(0, audioBuffer.length - bufferOffset), channelNumber, bufferOffset);\n                }\n                return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-audio-buffer-copy-channel-methods-subarray.js.map","// Bug #33: Edge & Safari expose an AudioBuffer but it can't be used as a constructor.\nexport const createTestAudioBufferConstructorSupport = (nativeAudioBufferConstructor) => {\n    return () => {\n        if (nativeAudioBufferConstructor === null) {\n            return false;\n        }\n        try {\n            new nativeAudioBufferConstructor({ length: 1, sampleRate: 44100 }); // tslint:disable-line:no-unused-expression\n        }\n        catch (_a) {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-buffer-constructor-support.js.map","export const createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createOscillator());\n        try {\n            nativeAudioBufferSourceNode.start(-1);\n        }\n        catch (err) {\n            return (err instanceof RangeError);\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-scheduled-source-node-start-method-negative-parameters-support.js.map","export const createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.start();\n        nativeAudioBufferSourceNode.stop();\n        try {\n            nativeAudioBufferSourceNode.stop();\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js.map","export const createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createOscillator());\n        try {\n            nativeAudioBufferSourceNode.stop(-1);\n        }\n        catch (err) {\n            return (err instanceof RangeError);\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (createNativeAudioNode) => {\n    return (nativeAudioScheduledSourceNode, nativeContext) => {\n        const nativeGainNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createGain());\n        nativeAudioScheduledSourceNode.connect(nativeGainNode);\n        const disconnectGainNode = ((disconnect) => {\n            return () => {\n                // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n                nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n            };\n        })(nativeAudioScheduledSourceNode.disconnect);\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n        interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n        nativeAudioScheduledSourceNode.stop = ((stop) => {\n            let isStopped = false;\n            return (when = 0) => {\n                if (isStopped) {\n                    try {\n                        stop.call(nativeAudioScheduledSourceNode, when);\n                    }\n                    catch (_a) {\n                        nativeGainNode.gain.setValueAtTime(0, when);\n                    }\n                }\n                else {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                    isStopped = true;\n                }\n            };\n        })(nativeAudioScheduledSourceNode.stop);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioBufferSourceNodeStartMethodDurationParameter } from '../helpers/wrap-audio-buffer-source-node-start-method-duration-parameter';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeAudioBufferSourceNodeFactory = (cacheTestResult, createNativeAudioNode, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodDurationParameterSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options = {}) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n        // Bug #71: Edge does not allow to set the buffer to null.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n        // Bug #149: Safari does not yet support the detune AudioParam.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n        // Bug #92: Edge does not respect the duration parameter yet.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodDurationParameterSupport, testAudioBufferSourceNodeStartMethodDurationParameterSupport)) {\n            wrapAudioBufferSourceNodeStartMethodDurationParameter(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n        // Bug #44: Only Chrome, Firefox & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        return nativeAudioBufferSourceNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-buffer-source-node-factory.js.map","export const wrapAudioBufferSourceNodeStartMethodDurationParameter = (nativeAudioScheduledSourceNode, nativeContext) => {\n    let endTime = Number.POSITIVE_INFINITY;\n    let stopTime = Number.POSITIVE_INFINITY;\n    nativeAudioScheduledSourceNode.start = ((start, stop) => {\n        return (when = 0, offset = 0, duration = Number.POSITIVE_INFINITY) => {\n            start.call(nativeAudioScheduledSourceNode, when, offset);\n            if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {\n                const actualStartTime = Math.max(when, nativeContext.currentTime);\n                // @todo The playbackRate could of course also have been automated and is not always fixed.\n                const durationInBufferTime = (duration / nativeAudioScheduledSourceNode.playbackRate.value);\n                endTime = actualStartTime + durationInBufferTime;\n                stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n            }\n        };\n    })(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            stopTime = Math.max(when, nativeContext.currentTime);\n            stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js.map","export const createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        nativeAudioBufferSourceNode.start();\n        try {\n            nativeAudioBufferSourceNode.start();\n        }\n        catch (_a) {\n            return true;\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-buffer-source-node-start-method-consecutive-calls-support.js.map","// Bug #92: Edge does not respect the duration parameter yet.\nexport const createTestAudioBufferSourceNodeStartMethodDurationParameterSupport = (nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const audioBuffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n        const audioBufferSourceNode = offlineAudioContext.createBufferSource();\n        audioBuffer.getChannelData(0)[0] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.start(0, 0, 0);\n        audioBufferSourceNode.connect(offlineAudioContext.destination);\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            offlineAudioContext.oncomplete = ({ renderedBuffer }) => {\n                // Bug #5: Safari does not support copyFromChannel().\n                resolve(renderedBuffer.getChannelData(0)[0] === 0);\n            };\n            offlineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-buffer-source-node-start-method-duration-parameter-support.js.map","export const createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        try {\n            nativeAudioBufferSourceNode.start(0, 1);\n        }\n        catch (_a) {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-buffer-source-node-start-method-offset-clamping-support.js.map","export const wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            const buffer = nativeAudioBufferSourceNode.buffer;\n            // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n            const clampedOffset = (buffer === null) ? offset : Math.min(buffer.duration, offset);\n            // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n            if (buffer !== null && clampedOffset > buffer.duration - (0.5 / nativeAudioBufferSourceNode.context.sampleRate)) {\n                start.call(nativeAudioBufferSourceNode, when, 0, 0);\n            }\n            else {\n                start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n            }\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createAudioBufferSourceNodeRendererFactory = (createNativeAudioBufferSourceNode) => {\n    return () => {\n        const renderedNativeAudioBufferSourceNodes = new WeakMap();\n        let start = null;\n        let stop = null;\n        const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioBufferSourceNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeAudioBufferSourceNode.buffer,\n                    channelCount: nativeAudioBufferSourceNode.channelCount,\n                    channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n                    channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n                    // Bug #149: Safari does not yet support the detune AudioParam.\n                    loop: nativeAudioBufferSourceNode.loop,\n                    loopEnd: nativeAudioBufferSourceNode.loopEnd,\n                    loopStart: nativeAudioBufferSourceNode.loopStart,\n                    playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n                };\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeAudioBufferSourceNode.start(...start);\n                }\n                if (stop !== null) {\n                    nativeAudioBufferSourceNode.stop(stop);\n                }\n            }\n            renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            }\n            else {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.playbackRate);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n            return nativeAudioBufferSourceNode;\n        };\n        return {\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioBufferSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioBufferSourceNode);\n                }\n                return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-buffer-source-node-renderer-factory.js.map","export const createAudioParamRenderer = (automationEventList) => {\n    return {\n        replay(audioParam) {\n            for (const automationEvent of automationEventList) {\n                if (automationEvent.type === 'exponentialRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.exponentialRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'linearRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.linearRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'setTarget') {\n                    const { startTime, target, timeConstant } = automationEvent;\n                    audioParam.setTargetAtTime(target, startTime, timeConstant);\n                }\n                else if (automationEvent.type === 'setValue') {\n                    const { startTime, value } = automationEvent;\n                    audioParam.setValueAtTime(value, startTime);\n                }\n                else if (automationEvent.type === 'setValueCurve') {\n                    const { duration, startTime, values } = automationEvent;\n                    audioParam.setValueCurveAtTime(values, startTime, duration);\n                }\n                else {\n                    throw new Error(\"Can't apply an unknown automation.\");\n                }\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-param-renderer.js.map","export const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\nexport const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\n//# sourceMappingURL=/build/es2018/constants.js.map","import { AUDIO_GRAPHS } from '../globals';\nimport { getNativeContext } from '../helpers/get-native-context';\nexport const createAudioDestinationNodeConstructor = (audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, isNativeOfflineAudioContext) => {\n    return class AudioDestinationNode extends audioNodeConstructor {\n        constructor(context, channelCount) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n            const audioDestinationNodeRenderer = ((isOffline) ? createAudioDestinationNodeRenderer() : null);\n            const audioGraph = { audioWorkletGlobalScope: null, nodes: new WeakMap(), params: new WeakMap() };\n            AUDIO_GRAPHS.set(context, audioGraph);\n            super(context, 'passive', nativeAudioDestinationNode, audioDestinationNodeRenderer);\n            this._isNodeOfNativeOfflineAudioContext = isOffline;\n            this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n        }\n        get channelCount() {\n            return this._nativeAudioDestinationNode.channelCount;\n        }\n        set channelCount(value) {\n            // Bug #52: Chrome, Edge, Opera & Safari do not throw an exception at all.\n            // Bug #54: Firefox does throw an IndexSizeError.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            // Bug #47: The AudioDestinationNode in Edge and Safari do not initialize the maxChannelCount property correctly.\n            if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n                throw createIndexSizeError();\n            }\n            this._nativeAudioDestinationNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioDestinationNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            // Bug #53: No browser does throw an exception yet.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            this._nativeAudioDestinationNode.channelCountMode = value;\n        }\n        get maxChannelCount() {\n            return this._nativeAudioDestinationNode.maxChannelCount;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-destination-node-constructor.js.map","import { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createAudioDestinationNodeRenderer = () => {\n    let nativeAudioDestinationNodePromise = null;\n    const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);\n        return nativeAudioDestinationNode;\n    };\n    return {\n        render(proxy, nativeOfflineAudioContext) {\n            if (nativeAudioDestinationNodePromise === null) {\n                nativeAudioDestinationNodePromise = createAudioDestinationNode(proxy, nativeOfflineAudioContext);\n            }\n            return nativeAudioDestinationNodePromise;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-destination-node-renderer-factory.js.map","export const createNativeAudioDestinationNode = (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n    const nativeAudioDestinationNode = nativeContext.destination;\n    // Bug #132: Edge & Safari do not have the correct channelCount.\n    if (nativeAudioDestinationNode.channelCount !== channelCount) {\n        nativeAudioDestinationNode.channelCount = channelCount;\n    }\n    // Bug #83: Edge & Safari do not have the correct channelCountMode.\n    if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n        nativeAudioDestinationNode.channelCountMode = 'explicit';\n    }\n    // Bug #47: The AudioDestinationNode in Edge and Safari does not initialize the maxChannelCount property correctly.\n    if (nativeAudioDestinationNode.maxChannelCount === 0) {\n        Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n            get: () => nativeAudioDestinationNode.channelCount\n        });\n    }\n    return nativeAudioDestinationNode;\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-destination-node.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeBiquadFilterNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeBiquadFilterNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBiquadFilter());\n        assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n        assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n        return nativeBiquadFilterNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-biquad-filter-node-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createBiquadFilterNodeRendererFactory = (createNativeBiquadFilterNode) => {\n    return () => {\n        const renderedNativeBiquadFilterNodes = new WeakMap();\n        const createBiquadFilterNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeBiquadFilterNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                const options = {\n                    Q: nativeBiquadFilterNode.Q.value,\n                    channelCount: nativeBiquadFilterNode.channelCount,\n                    channelCountMode: nativeBiquadFilterNode.channelCountMode,\n                    channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n                    detune: nativeBiquadFilterNode.detune.value,\n                    frequency: nativeBiquadFilterNode.frequency.value,\n                    gain: nativeBiquadFilterNode.gain.value,\n                    type: nativeBiquadFilterNode.type\n                };\n                nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.Q);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.detune);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.frequency);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.gain);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);\n            return nativeBiquadFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeBiquadFilterNode !== undefined) {\n                    return Promise.resolve(renderedNativeBiquadFilterNode);\n                }\n                return createBiquadFilterNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/biquad-filter-node-renderer-factory.js.map","export const createWrapChannelMergerNode = (createInvalidStateError, createNativeAudioNode) => {\n    return (nativeContext, channelMergerNode) => {\n        const audioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        channelMergerNode.channelCount = 1;\n        channelMergerNode.channelCountMode = 'explicit';\n        // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n        const length = channelMergerNode.numberOfInputs;\n        for (let i = 0; i < length; i += 1) {\n            audioBufferSourceNode.connect(channelMergerNode, 0, i);\n        }\n        Object.defineProperty(channelMergerNode, 'channelCount', {\n            get: () => 1,\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n        Object.defineProperty(channelMergerNode, 'channelCountMode', {\n            get: () => 'explicit',\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-channel-merger-node.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeChannelMergerNodeFactory = (createNativeAudioNode, wrapChannelMergerNode) => {\n    return (nativeContext, options) => {\n        const nativeChannelMergerNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createChannelMerger(options.numberOfInputs);\n        });\n        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n        // Bug #15: Safari does not return the default properties.\n        if (nativeChannelMergerNode.channelCount !== 1 &&\n            nativeChannelMergerNode.channelCountMode !== 'explicit') {\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n        // Bug #16: Firefox does not throw an error when setting a different channelCount or channelCountMode.\n        try {\n            nativeChannelMergerNode.channelCount = (options.numberOfInputs === undefined) ? 6 : options.numberOfInputs;\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n        catch ( /* Ignore errors. */_a) { /* Ignore errors. */ } // tslint:disable-line:no-empty\n        return nativeChannelMergerNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-channel-merger-node-factory.js.map","import { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfInputs: nativeAudioNode.numberOfInputs\n                };\n                nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n            return nativeAudioNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/channel-merger-node-renderer-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapChannelSplitterNode } from '../helpers/wrap-channel-splitter-node';\nexport const createNativeChannelSplitterNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeChannelSplitterNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createChannelSplitter(options.numberOfOutputs);\n        });\n        // Bug #96: Safari does not have the correct channelCount.\n        // Bug #29: Edge & Safari do not have the correct channelCountMode.\n        // Bug #31: Edge & Safari do not have the correct channelInterpretation.\n        assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n        // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Firefox & Opera partially support the spec yet.\n        wrapChannelSplitterNode(nativeChannelSplitterNode);\n        return nativeChannelSplitterNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-channel-splitter-node-factory.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapChannelSplitterNode = (channelSplitterNode) => {\n    const channelCount = channelSplitterNode.numberOfOutputs;\n    // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n    Object.defineProperty(channelSplitterNode, 'channelCount', {\n        get: () => channelCount,\n        set: (value) => {\n            if (value !== channelCount) {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    /*\n     * Bug #30: Only Chrome, Firefox & Opera throw an error when attempting to change the channelCountMode to something other than\n     * explicit.\n     */\n    Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n        get: () => 'explicit',\n        set: (value) => {\n            if (value !== 'explicit') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    /*\n     * Bug #32: Only Chrome, Firefox & Opera throws an error when attempting to change the channelInterpretation to something other than\n     * discrete.\n     */\n    Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n        get: () => 'discrete',\n        set: (value) => {\n            if (value !== 'discrete') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-channel-splitter-node.js.map","import { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createChannelSplitterNodeRendererFactory = (createNativeChannelSplitterNode) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfOutputs: nativeAudioNode.numberOfOutputs\n                };\n                nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n            return nativeAudioNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/channel-splitter-node-renderer-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeGainNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeGainNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createGain());\n        assignNativeAudioNodeOptions(nativeGainNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n        return nativeGainNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-gain-node-factory.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConstantSourceNodeFakerFactory = (createNativeAudioBufferSourceNode, createNativeGainNode) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext);\n        /*\n         * @todo Edge will throw a NotSupportedError when calling createBuffer() on a closed context. That's why the audioBuffer is created\n         * after the audioBufferSourceNode in this case. If the context is closed createNativeAudioBufferSourceNode() will throw the\n         * expected error and createBuffer() never gets called.\n         */\n        const audioBuffer = nativeContext.createBuffer(1, 2, nativeContext.sampleRate);\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n        audioBufferSourceNode.connect(gainNode);\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context() {\n                return gainNode.context;\n            },\n            get inputs() {\n                return undefined;\n            },\n            get numberOfInputs() {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return gainNode.numberOfOutputs;\n            },\n            get offset() {\n                return gainNode.gain;\n            },\n            get onended() {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = value;\n            },\n            addEventListener(...args) {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0) {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0) {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n        return interceptConnections(nativeConstantSourceNodeFaker, gainNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-constant-source-node-faker-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeConstantSourceNodeFactory = (cacheTestResult, createNativeAudioNode, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport) => {\n    return (nativeContext, options) => {\n        // Bug #62: Edge & Safari do not support ConstantSourceNodes.\n        if (nativeContext.createConstantSource === undefined) {\n            return createNativeConstantSourceNodeFaker(nativeContext, options);\n        }\n        const nativeConstantSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createConstantSource();\n        });\n        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');\n        // Bug #44: Only Chrome, Firefox & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #44: Only Firefox does throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        return nativeConstantSourceNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-constant-source-node-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createConstantSourceNodeRendererFactory = (createNativeConstantSourceNode) => {\n    return () => {\n        const renderedNativeConstantSourceNodes = new WeakMap();\n        let start = null;\n        let stop = null;\n        const createConstantSourceNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeConstantSourceNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeConstantSourceNode.channelCount,\n                    channelCountMode: nativeConstantSourceNode.channelCountMode,\n                    channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n                    offset: nativeConstantSourceNode.offset.value\n                };\n                nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeConstantSourceNode.start(start);\n                }\n                if (stop !== null) {\n                    nativeConstantSourceNode.stop(stop);\n                }\n            }\n            renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.offset);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);\n            return nativeConstantSourceNode;\n        };\n        return {\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeConstantSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeConstantSourceNode);\n                }\n                return createConstantSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/constant-source-node-renderer-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeConvolverNodeFactory = (createNativeAudioNode, createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const nativeConvolverNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createConvolver());\n        assignNativeAudioNodeOptions(nativeConvolverNode, options);\n        // The normalize property needs to be set before setting the buffer.\n        if (options.disableNormalization === nativeConvolverNode.normalize) {\n            nativeConvolverNode.normalize = !options.disableNormalization;\n        }\n        assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer');\n        // Bug #113: Edge & Safari allow to change the channelCount\n        if (options.channelCount !== 2) {\n            throw createNotSupportedError();\n        }\n        Object.defineProperty(nativeConvolverNode, 'channelCount', {\n            get: () => options.channelCount,\n            set: (value) => {\n                if (value !== options.channelCount) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n        // Bug #114: Edge & Safari allow to change the channelCountMode\n        if (options.channelCountMode !== 'clamped-max') {\n            throw createNotSupportedError();\n        }\n        Object.defineProperty(nativeConvolverNode, 'channelCountMode', {\n            get: () => options.channelCountMode,\n            set: (value) => {\n                if (value !== options.channelCountMode) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n        return nativeConvolverNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-convolver-node-factory.js.map","import { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createConvolverNodeRendererFactory = (createNativeConvolverNode) => {\n    return () => {\n        const renderedNativeConvolverNodes = new WeakMap();\n        const createConvolverNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeConvolverNode = getNativeAudioNode(proxy);\n            // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n            if (!nativeConvolverNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeConvolverNode.buffer,\n                    channelCount: nativeConvolverNode.channelCount,\n                    channelCountMode: nativeConvolverNode.channelCountMode,\n                    channelInterpretation: nativeConvolverNode.channelInterpretation,\n                    disableNormalization: !nativeConvolverNode.normalize\n                };\n                nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode);\n            return nativeConvolverNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeConvolverNode !== undefined) {\n                    return Promise.resolve(renderedNativeConvolverNode);\n                }\n                return createConvolverNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/convolver-node-renderer-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDelayNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeDelayNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createDelay(options.maxDelayTime));\n        assignNativeAudioNodeOptions(nativeDelayNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n        return nativeDelayNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-delay-node-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createDelayNodeRendererFactory = (createNativeDelayNode) => {\n    return (maxDelayTime) => {\n        const renderedNativeDelayNodes = new WeakMap();\n        const createDelayNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeDelayNode = getNativeAudioNode(proxy);\n            // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n            if (!nativeDelayNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeDelayNode.channelCount,\n                    channelCountMode: nativeDelayNode.channelCountMode,\n                    channelInterpretation: nativeDelayNode.channelInterpretation,\n                    delayTime: nativeDelayNode.delayTime.value,\n                    maxDelayTime\n                };\n                nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n            if (!nativeDelayNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.delayTime);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode);\n            return nativeDelayNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeDelayNode !== undefined) {\n                    return Promise.resolve(renderedNativeDelayNode);\n                }\n                return createDelayNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/delay-node-renderer-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDynamicsCompressorNodeFactory = (createNativeAudioNode, createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const nativeDynamicsCompressorNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createDynamicsCompressor());\n        assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);\n        // Bug #108: Only Chrome, Firefox and Opera disallow a channelCount of three and above yet.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        // Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n        return nativeDynamicsCompressorNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-dynamics-compressor-node-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createDynamicsCompressorNodeRendererFactory = (createNativeDynamicsCompressorNode) => {\n    return () => {\n        const renderedNativeDynamicsCompressorNodes = new WeakMap();\n        const createDynamicsCompressorNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeDynamicsCompressorNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n             * created again.\n             */\n            const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                const options = {\n                    attack: nativeDynamicsCompressorNode.attack.value,\n                    channelCount: nativeDynamicsCompressorNode.channelCount,\n                    channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n                    channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n                    knee: nativeDynamicsCompressorNode.knee.value,\n                    ratio: nativeDynamicsCompressorNode.ratio.value,\n                    release: nativeDynamicsCompressorNode.release.value,\n                    threshold: nativeDynamicsCompressorNode.threshold.value\n                };\n                nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.attack);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.knee);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.ratio);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.release);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.threshold);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n            return nativeDynamicsCompressorNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeDynamicsCompressorNode !== undefined) {\n                    return Promise.resolve(renderedNativeDynamicsCompressorNode);\n                }\n                return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/dynamics-compressor-node-renderer-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createGainNodeRendererFactory = (createNativeGainNode) => {\n    return () => {\n        const renderedNativeGainNodes = new WeakMap();\n        const createGainNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeGainNode = getNativeAudioNode(proxy);\n            // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n            if (!nativeGainNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeGainNode.channelCount,\n                    channelCountMode: nativeGainNode.channelCountMode,\n                    channelInterpretation: nativeGainNode.channelInterpretation,\n                    gain: nativeGainNode.gain.value\n                };\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n            if (!nativeGainNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.gain);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode);\n            return nativeGainNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNode);\n                }\n                return createGainNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/gain-node-renderer-factory.js.map","export const createNativeScriptProcessorNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {\n        return createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-script-processor-node-factory.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nexport const createRenderNativeOfflineAudioContext = (cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, testOfflineAudioContextCurrentTimeSupport) => {\n    return (nativeOfflineAudioContext) => {\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n            // Bug #158: Edge does not advance currentTime if it is not accessed while rendering the audio.\n            return Promise\n                .resolve(cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport))\n                .then((isOfflineAudioContextCurrentTimeSupported) => {\n                if (!isOfflineAudioContextCurrentTimeSupported) {\n                    const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n                    nativeOfflineAudioContext.oncomplete = () => {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        scriptProcessorNode.disconnect();\n                    };\n                    scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation\n                    scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n                }\n                return nativeOfflineAudioContext.startRendering();\n            });\n        }\n        return new Promise((resolve) => {\n            // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n            const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                gain: 0\n            });\n            nativeOfflineAudioContext.oncomplete = (event) => {\n                gainNode.disconnect();\n                resolve(event.renderedBuffer);\n            };\n            gainNode.connect(nativeOfflineAudioContext.destination);\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/render-native-offline-audio-context.js.map","export const createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode, nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n        const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            nativeOfflineAudioContext.oncomplete = () => {\n                gainNode.disconnect();\n                resolve(nativeOfflineAudioContext.currentTime !== 0);\n            };\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-offline-audio-context-current-time-support.js.map","import { filterBuffer } from '../helpers/filter-buffer';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nconst filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {\n    const feedbackLength = feedback.length;\n    const feedforwardLength = feedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n    if (feedback[0] !== 1) {\n        for (let i = 0; i < feedbackLength; i += 1) {\n            feedforward[i] /= feedback[0];\n        }\n        for (let i = 1; i < feedforwardLength; i += 1) {\n            feedback[i] /= feedback[0];\n        }\n    }\n    const bufferLength = 32;\n    const xBuffer = new Float32Array(bufferLength);\n    const yBuffer = new Float32Array(bufferLength);\n    const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);\n    const numberOfChannels = renderedBuffer.numberOfChannels;\n    for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = renderedBuffer.getChannelData(i);\n        const output = filteredBuffer.getChannelData(i);\n        // @todo Add a test which checks support for TypedArray.prototype.fill().\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n        filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);\n    }\n    return filteredBuffer;\n};\nexport const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode, createNativeAudioNode, nativeOfflineAudioContextConstructor, renderNativeOfflineAudioContext) => {\n    return (feedback, feedforward) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeIIRFilterNode = getNativeAudioNode(proxy);\n            let nativeAudioBufferSourceNode = null;\n            // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);\n            // Bug #9: Safari does not support IIRFilterNodes.\n            if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n            }\n            else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                nativeIIRFilterNode = createNativeAudioNode(nativeOfflineAudioContext, (ntvCntxt) => {\n                    return ntvCntxt.createIIRFilter(feedforward, feedback);\n                });\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, (nativeAudioBufferSourceNode === null) ? nativeIIRFilterNode : nativeAudioBufferSourceNode);\n            if (nativeAudioBufferSourceNode !== null) {\n                if (nativeOfflineAudioContextConstructor === null) {\n                    throw new Error('Missing the native OfflineAudioContext constructor.');\n                }\n                const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                proxy.context.destination.channelCount, \n                // Bug #17: Safari does not yet expose the length.\n                proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);\n                const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                nativeAudioBufferSourceNode.buffer = filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n                nativeAudioBufferSourceNode.start(0);\n                return nativeAudioBufferSourceNode;\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);\n            return nativeIIRFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/iir-filter-node-renderer-factory.js.map","import { createInvalidAccessError } from '../factories/invalid-access-error';\nexport const wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode) => {\n    nativeIIRFilterNode.getFrequencyResponse = ((getFrequencyResponse) => {\n        return (frequencyHz, magResponse, phaseResponse) => {\n            if ((frequencyHz.length !== magResponse.length) || (magResponse.length !== phaseResponse.length)) {\n                throw createInvalidAccessError();\n            }\n            return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n        };\n    })(nativeIIRFilterNode.getFrequencyResponse);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-iir-filter-node-get-frequency-response-method.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeIIRFilterNodeFactory = (createNativeAudioNode, createNativeIIRFilterNodeFaker) => {\n    return (nativeContext, baseLatency, options) => {\n        // Bug #9: Safari does not support IIRFilterNodes.\n        if (nativeContext.createIIRFilter === undefined) {\n            return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n        }\n        const nativeIIRFilterNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createIIRFilter(options.feedforward, options.feedback);\n        });\n        assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n        return nativeIIRFilterNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-iir-filter-node-factory.js.map","import { EventTarget } from '../event-target';\nimport { CONTEXT_STORE } from '../globals';\nimport { wrapEventListener } from '../helpers/wrap-event-listener';\nexport const createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor, createAudioListener) => {\n    return class MinimalBaseAudioContext extends EventTarget {\n        constructor(_nativeContext, numberOfChannels) {\n            super(_nativeContext);\n            this._nativeContext = _nativeContext;\n            CONTEXT_STORE.set(this, _nativeContext);\n            // Bug #93: Edge will set the sampleRate of an AudioContext to zero when it is closed.\n            const sampleRate = _nativeContext.sampleRate;\n            Object.defineProperty(_nativeContext, 'sampleRate', {\n                get: () => sampleRate\n            });\n            this._destination = new audioDestinationNodeConstructor(this, numberOfChannels);\n            this._listener = createAudioListener(this, _nativeContext);\n            this._onstatechange = null;\n        }\n        get currentTime() {\n            return this._nativeContext.currentTime;\n        }\n        get destination() {\n            return this._destination;\n        }\n        get listener() {\n            return this._listener;\n        }\n        get onstatechange() {\n            return this._onstatechange;\n        }\n        set onstatechange(value) {\n            const wrappedListener = wrapEventListener(this, value);\n            this._nativeContext.onstatechange = wrappedListener;\n            const nativeOnStateChange = this._nativeContext.onstatechange;\n            this._onstatechange = (nativeOnStateChange === wrappedListener) ? value : nativeOnStateChange;\n        }\n        get sampleRate() {\n            return this._nativeContext.sampleRate;\n        }\n        get state() {\n            return this._nativeContext.state;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/minimal-base-audio-context-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nexport const createAudioListenerFactory = (createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext) => {\n    return (context, nativeContext) => {\n        const nativeListener = nativeContext.listener;\n        // Bug #117: Only Chrome & Opera support the new interface already.\n        const createFakeAudioParams = () => {\n            const channelMergerNode = createNativeChannelMergerNode(nativeContext, { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'speakers', numberOfInputs: 9 });\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n            const createFakeAudioParam = (input, value) => {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete', offset: value });\n                constantSourceNode.connect(channelMergerNode, 0, input);\n                // @todo This should be stopped when the context is closed.\n                constantSourceNode.start();\n                Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n                    get() {\n                        return value;\n                    }\n                });\n                /*\n                 * Bug #62 & #74: Edge & Safari do not support ConstantSourceNodes and do not export the correct values for maxValue and\n                 * minValue for GainNodes.\n                 */\n                return createAudioParam({ context }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            };\n            let lastOrientation = [0, 0, -1, 0, 1, 0];\n            let lastPosition = [0, 0, 0];\n            scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n                const orientation = [\n                    inputBuffer.getChannelData(0)[0],\n                    inputBuffer.getChannelData(1)[0],\n                    inputBuffer.getChannelData(2)[0],\n                    inputBuffer.getChannelData(3)[0],\n                    inputBuffer.getChannelData(4)[0],\n                    inputBuffer.getChannelData(5)[0]\n                ];\n                if (orientation.some((value, index) => (value !== lastOrientation[index]))) {\n                    nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n                    lastOrientation = orientation;\n                }\n                const positon = [\n                    inputBuffer.getChannelData(6)[0],\n                    inputBuffer.getChannelData(7)[0],\n                    inputBuffer.getChannelData(8)[0]\n                ];\n                if (positon.some((value, index) => (value !== lastPosition[index]))) {\n                    nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n                    lastPosition = positon;\n                }\n            };\n            channelMergerNode.connect(scriptProcessorNode);\n            return {\n                forwardX: createFakeAudioParam(0, 0),\n                forwardY: createFakeAudioParam(1, 0),\n                forwardZ: createFakeAudioParam(2, -1),\n                positionX: createFakeAudioParam(6, 0),\n                positionY: createFakeAudioParam(7, 0),\n                positionZ: createFakeAudioParam(8, 0),\n                upX: createFakeAudioParam(3, 0),\n                upY: createFakeAudioParam(4, 1),\n                upZ: createFakeAudioParam(5, 0)\n            };\n        };\n        const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } = (nativeListener.forwardX === undefined)\n            ? createFakeAudioParams()\n            : nativeListener;\n        return {\n            get forwardX() {\n                return forwardX;\n            },\n            get forwardY() {\n                return forwardY;\n            },\n            get forwardZ() {\n                return forwardZ;\n            },\n            get positionX() {\n                return positionX;\n            },\n            get positionY() {\n                return positionY;\n            },\n            get positionZ() {\n                return positionZ;\n            },\n            get upX() {\n                return upX;\n            },\n            get upY() {\n                return upY;\n            },\n            get upZ() {\n                return upZ;\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-listener-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeOscillatorNodeFactory = (cacheTestResult, createNativeAudioNode, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options) => {\n        const nativeOscillatorNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createOscillator());\n        assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n        if (options.periodicWave !== undefined) {\n            nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n        }\n        else {\n            assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n        }\n        // Bug #44: Only Chrome & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n        }\n        // Bug #44: No browser does throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n        }\n        return nativeOscillatorNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-oscillator-node-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createOscillatorNodeRendererFactory = (createNativeOscillatorNode) => {\n    return () => {\n        const renderedNativeOscillatorNodes = new WeakMap();\n        let periodicWave = null;\n        let start = null;\n        let stop = null;\n        const createOscillatorNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeOscillatorNode = getNativeAudioNode(proxy);\n            // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeOscillatorNode.channelCount,\n                    channelCountMode: nativeOscillatorNode.channelCountMode,\n                    channelInterpretation: nativeOscillatorNode.channelInterpretation,\n                    detune: nativeOscillatorNode.detune.value,\n                    frequency: nativeOscillatorNode.frequency.value,\n                    periodicWave: (periodicWave === null) ? undefined : periodicWave,\n                    type: nativeOscillatorNode.type\n                };\n                nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeOscillatorNode.start(start);\n                }\n                if (stop !== null) {\n                    nativeOscillatorNode.stop(stop);\n                }\n            }\n            renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.detune);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.frequency);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode);\n            return nativeOscillatorNode;\n        };\n        return {\n            set periodicWave(value) {\n                periodicWave = value;\n            },\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeOscillatorNode !== undefined) {\n                    return Promise.resolve(renderedNativeOscillatorNode);\n                }\n                return createOscillatorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/oscillator-node-renderer-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeWaveShaperNodeFakerFactory = (createInvalidStateError, createNativeAudioNode, createNativeGainNode) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        const positiveWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        inputGainNode.connect(negativeWaveShaperNode);\n        negativeWaveShaperNode.connect(outputGainNode);\n        inputGainNode.connect(invertGainNode);\n        invertGainNode.connect(positiveWaveShaperNode);\n        positiveWaveShaperNode.connect(revertGainNode);\n        revertGainNode.connect(outputGainNode);\n        let unmodifiedCurve = null;\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return negativeWaveShaperNode.context;\n            },\n            get curve() {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (curve !== null && curve.length < 2) {\n                    throw createInvalidStateError();\n                }\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                }\n                else {\n                    const curveLength = value.length;\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = ((curveLength + 1) / 2) - 1;\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        negativeCurve[i] = (lowerIndex === upperIndex)\n                            ? value[lowerIndex]\n                            : ((1 - (theoreticIndex - lowerIndex)) * value[lowerIndex])\n                                + ((1 - (upperIndex - theoreticIndex)) * value[upperIndex]);\n                        positiveCurve[i] = (lowerIndex === upperIndex)\n                            ? -value[curveLength - 1 - lowerIndex]\n                            : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex])\n                                - ((1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex]);\n                    }\n                    negativeCurve[length] = (curveLength % 2 === 1) ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n                unmodifiedCurve = value;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample() {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (curve !== nativeWaveShaperNodeFaker.curve) {\n            nativeWaveShaperNodeFaker.curve = curve;\n        }\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n        return interceptConnections(nativeWaveShaperNodeFaker, outputGainNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-wave-shaper-node-faker-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        try {\n            // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n            // Bug #119: Safari does not correctly map the values. Bug #102 is only used to detect Safari in this case.\n            nativeWaveShaperNode.curve = new Float32Array([1]);\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n        catch ( /* Ignore errors. */_a) { /* Ignore errors. */ }\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n        const curve = options.curve;\n        // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n        return nativeWaveShaperNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-wave-shaper-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativePannerNodeFakerFactory = (createInvalidStateError, createNativeAudioNode, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError) => {\n    return (nativeContext, { coneInnerAngle, coneOuterAngle, coneOuterGain, distanceModel, maxDistance, orientationX, orientationY, orientationZ, panningModel, positionX, positionY, positionZ, refDistance, rolloffFactor, ...audioNodeOptions }) => {\n        const pannerNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createPanner());\n        // Bug #125: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        // Bug #126: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n        const SINGLE_CHANNEL_OPTIONS = {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete'\n        };\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, channelInterpretation: 'speakers', numberOfInputs: 6 });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const orientationXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });\n        const orientationYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const orientationZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 0);\n        const waveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, curve: new Float32Array([1, 1]), oversample: 'none' });\n        let lastOrientation = [1, 0, 0];\n        let lastPosition = [0, 0, 0];\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n            const orientation = [\n                inputBuffer.getChannelData(0)[0],\n                inputBuffer.getChannelData(1)[0],\n                inputBuffer.getChannelData(2)[0]\n            ];\n            if (orientation.some((value, index) => (value !== lastOrientation[index]))) {\n                pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation\n                lastOrientation = orientation;\n            }\n            const positon = [\n                inputBuffer.getChannelData(6)[0],\n                inputBuffer.getChannelData(7)[0],\n                inputBuffer.getChannelData(8)[0]\n            ];\n            if (positon.some((value, index) => (value !== lastPosition[index]))) {\n                pannerNode.setPosition(...positon); // tslint:disable-line:deprecation\n                lastPosition = positon;\n            }\n        };\n        inputGainNode.connect(pannerNode);\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n        waveShaperNode.connect(orientationXGainNode);\n        waveShaperNode.connect(orientationYGainNode);\n        waveShaperNode.connect(orientationZGainNode);\n        waveShaperNode.connect(positionXGainNode);\n        waveShaperNode.connect(positionYGainNode);\n        waveShaperNode.connect(positionZGainNode);\n        orientationXGainNode.connect(channelMergerNode);\n        orientationYGainNode.connect(channelMergerNode);\n        orientationZGainNode.connect(channelMergerNode);\n        positionXGainNode.connect(channelMergerNode);\n        positionYGainNode.connect(channelMergerNode);\n        positionZGainNode.connect(channelMergerNode);\n        channelMergerNode.connect(scriptProcessorNode);\n        Object.defineProperty(orientationYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(orientationZGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionXGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionZGainNode.gain, 'defaultValue', { get: () => 0 });\n        const nativePannerNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return pannerNode.channelCount;\n            },\n            set channelCount(value) {\n                // Bug #125: Safari does not throw an error yet.\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCount = value;\n                pannerNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return pannerNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                // Bug #126: Safari does not throw an error yet.\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCountMode = value;\n                pannerNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return pannerNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                pannerNode.channelInterpretation = value;\n            },\n            get coneInnerAngle() {\n                return pannerNode.coneInnerAngle;\n            },\n            set coneInnerAngle(value) {\n                pannerNode.coneInnerAngle = value;\n            },\n            get coneOuterAngle() {\n                return pannerNode.coneOuterAngle;\n            },\n            set coneOuterAngle(value) {\n                pannerNode.coneOuterAngle = value;\n            },\n            get coneOuterGain() {\n                return pannerNode.coneOuterGain;\n            },\n            set coneOuterGain(value) {\n                // Bug #127: Edge & Safari do not throw an InvalidStateError yet.\n                if (value < 0 || value > 1) {\n                    throw createInvalidStateError();\n                }\n                pannerNode.coneOuterGain = value;\n            },\n            get context() {\n                return pannerNode.context;\n            },\n            get distanceModel() {\n                return pannerNode.distanceModel;\n            },\n            set distanceModel(value) {\n                pannerNode.distanceModel = value;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get maxDistance() {\n                return pannerNode.maxDistance;\n            },\n            set maxDistance(value) {\n                // Bug #128: Edge & Safari do not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.maxDistance = value;\n            },\n            get numberOfInputs() {\n                return pannerNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return pannerNode.numberOfOutputs;\n            },\n            get orientationX() {\n                return orientationXGainNode.gain;\n            },\n            get orientationY() {\n                return orientationYGainNode.gain;\n            },\n            get orientationZ() {\n                return orientationZGainNode.gain;\n            },\n            get panningModel() {\n                return pannerNode.panningModel;\n            },\n            set panningModel(value) {\n                pannerNode.panningModel = value;\n                // Bug #123: Edge does not support HRTF as panningModel.\n                if (pannerNode.panningModel !== value && value === 'HRTF') {\n                    throw createNotSupportedError();\n                }\n            },\n            get positionX() {\n                return positionXGainNode.gain;\n            },\n            get positionY() {\n                return positionYGainNode.gain;\n            },\n            get positionZ() {\n                return positionZGainNode.gain;\n            },\n            get refDistance() {\n                return pannerNode.refDistance;\n            },\n            set refDistance(value) {\n                // Bug #129: Edge & Safari do not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.refDistance = value;\n            },\n            get rolloffFactor() {\n                return pannerNode.rolloffFactor;\n            },\n            set rolloffFactor(value) {\n                // Bug #130: Edge & Safari do not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.rolloffFactor = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n            nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n        }\n        if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n            nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n        }\n        if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n            nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n        }\n        if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n            nativePannerNodeFaker.distanceModel = distanceModel;\n        }\n        if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n            nativePannerNodeFaker.maxDistance = maxDistance;\n        }\n        if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n            nativePannerNodeFaker.orientationX.value = orientationX;\n        }\n        if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n            nativePannerNodeFaker.orientationY.value = orientationY;\n        }\n        if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n            nativePannerNodeFaker.orientationZ.value = orientationZ;\n        }\n        if (panningModel !== nativePannerNodeFaker.panningModel) {\n            nativePannerNodeFaker.panningModel = panningModel;\n        }\n        if (positionX !== nativePannerNodeFaker.positionX.value) {\n            nativePannerNodeFaker.positionX.value = positionX;\n        }\n        if (positionY !== nativePannerNodeFaker.positionY.value) {\n            nativePannerNodeFaker.positionY.value = positionY;\n        }\n        if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n            nativePannerNodeFaker.positionZ.value = positionZ;\n        }\n        if (refDistance !== nativePannerNodeFaker.refDistance) {\n            nativePannerNodeFaker.refDistance = refDistance;\n        }\n        if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n            nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n        }\n        return interceptConnections(nativePannerNodeFaker, pannerNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-panner-node-faker-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativePannerNodeFactory = (createNativeAudioNode, createNativePannerNodeFaker) => {\n    return (nativeContext, options) => {\n        const nativePannerNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createPanner());\n        // Bug #124: Edge & Safari do not support modifying the orientation and the position with AudioParams.\n        if (nativePannerNode.orientationX === undefined) {\n            return createNativePannerNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativePannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n        return nativePannerNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-panner-node-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createPannerNodeRendererFactory = (createNativePannerNode) => {\n    return () => {\n        const renderedNativePannerNodes = new WeakMap();\n        const createPannerNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativePannerNode = getNativeAudioNode(proxy);\n            // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);\n            if (!nativePannerNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativePannerNode.channelCount,\n                    channelCountMode: nativePannerNode.channelCountMode,\n                    channelInterpretation: nativePannerNode.channelInterpretation,\n                    coneInnerAngle: nativePannerNode.coneInnerAngle,\n                    coneOuterAngle: nativePannerNode.coneOuterAngle,\n                    coneOuterGain: nativePannerNode.coneOuterGain,\n                    distanceModel: nativePannerNode.distanceModel,\n                    maxDistance: nativePannerNode.maxDistance,\n                    orientationX: nativePannerNode.orientationX.value,\n                    orientationY: nativePannerNode.orientationY.value,\n                    orientationZ: nativePannerNode.orientationZ.value,\n                    panningModel: nativePannerNode.panningModel,\n                    positionX: nativePannerNode.positionX.value,\n                    positionY: nativePannerNode.positionY.value,\n                    positionZ: nativePannerNode.positionZ.value,\n                    refDistance: nativePannerNode.refDistance,\n                    rolloffFactor: nativePannerNode.rolloffFactor\n                };\n                nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativePannerNodes.set(nativeOfflineAudioContext, nativePannerNode);\n            if (!nativePannerNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.orientationX);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.orientationY);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.orientationZ);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.positionX);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.positionY);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.positionZ);\n            }\n            if (nativePannerNode.inputs !== undefined) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode);\n            }\n            return nativePannerNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativePannerNode = renderedNativePannerNodes.get(nativeOfflineAudioContext);\n                if (renderedNativePannerNode !== undefined) {\n                    return Promise.resolve(renderedNativePannerNode);\n                }\n                return createPannerNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/panner-node-renderer-factory.js.map","export const createNativePeriodicWaveFactory = (getBackupNativeContext) => {\n    return (nativeContext, { disableNormalization, imag, real }) => {\n        // Bug #50: Only Edge does currently not allow to create AudioNodes (and other objects) on a closed context yet.\n        const backupNativeContext = getBackupNativeContext(nativeContext);\n        // @todo Edge, Firefox & Safari do only accept Float32Arrays.\n        const wrappedImag = new Float32Array(imag);\n        const wrappedReal = new Float32Array(real);\n        if (backupNativeContext !== null) {\n            return backupNativeContext.createPeriodicWave(wrappedReal, wrappedImag, { disableNormalization });\n        }\n        return nativeContext.createPeriodicWave(wrappedReal, wrappedImag, { disableNormalization });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-periodic-wave-factory.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError) => {\n    // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n    const CURVE_SIZE = 16385;\n    const DC_CURVE = new Float32Array([1, 1]);\n    const HALF_PI = Math.PI / 2;\n    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete' };\n    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: 'none' };\n    const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            const x = (i / (CURVE_SIZE - 1)) * HALF_PI;\n            leftWaveShaperCurve[i] = Math.cos(x);\n            rightWaveShaperCurve[i] = Math.sin(x);\n        }\n        const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });\n        const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve });\n        inputGainNode.connect(leftGainNode);\n        inputGainNode.connect(panWaveShaperNode.inputs[0]);\n        inputGainNode.connect(rightGainNode);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightWaveShaperNode.inputs[0]);\n        leftWaveShaperNode.connect(leftGainNode.gain);\n        rightWaveShaperNode.connect(rightGainNode.gain);\n        leftGainNode.connect(channelMergerNode, 0, 0);\n        rightGainNode.connect(channelMergerNode, 0, 1);\n        return [leftGainNode, rightGainNode];\n    };\n    const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const centerIndex = Math.floor(CURVE_SIZE / 2);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            if (i > centerIndex) {\n                const x = ((i - centerIndex) / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n                rightInputForLeftOutputWaveShaperCurve[i] = 0;\n                rightInputForRightOutputWaveShaperCurve[i] = 1;\n            }\n            else {\n                const x = (i / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = 1;\n                leftInputForRightOutputWaveShaperCurve[i] = 0;\n                rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            }\n        }\n        const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: 2,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: 2\n        });\n        const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftInputForLeftOutputWaveShaperCurve });\n        const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftInputForRightOutputWaveShaperCurve });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });\n        const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightInputForLeftOutputWaveShaperCurve });\n        const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightInputForRightOutputWaveShaperCurve });\n        inputGainNode.connect(channelSplitterNode);\n        inputGainNode.connect(panWaveShaperNode.inputs[0]);\n        channelSplitterNode.connect(leftInputForLeftOutputGainNode, 1);\n        channelSplitterNode.connect(leftInputForRightOutputGainNode, 1);\n        channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n        channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs[0]);\n        leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n        leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n        rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n        rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n        leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n        rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n        return [\n            leftInputForLeftOutputGainNode,\n            rightInputForLeftOutputGainNode,\n            leftInputForRightOutputGainNode,\n            rightInputForRightOutputGainNode\n        ];\n    };\n    const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {\n        if (channelCount === 1) {\n            return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        if (channelCount === 2) {\n            return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        throw createNotSupportedError();\n    };\n    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {\n        if (channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...audioNodeOptions,\n            channelCount: 1,\n            channelCountMode,\n            numberOfInputs: 2\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });\n        const panGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: pan\n        });\n        let outputNodes = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);\n        Object.defineProperty(panGainNode.gain, 'defaultValue', { get: () => 0 });\n        const nativeStereoPannerNodeFakerFactory = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return inputGainNode.channelCount;\n            },\n            set channelCount(value) {\n                if (inputGainNode.channelCount !== value) {\n                    inputGainNode.disconnect();\n                    outputNodes.forEach((outputNode) => outputNode.disconnect());\n                    outputNodes = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode);\n                }\n                inputGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return inputGainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                if (value === 'clamped-max' || value === 'max') {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return inputGainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return inputGainNode.context;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return inputGainNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return inputGainNode.numberOfOutputs;\n            },\n            get pan() {\n                return panGainNode.gain;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        return interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-stereo-panner-node-faker-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeStereoPannerNodeFactory = (createNativeAudioNode, createNativeStereoPannerNodeFaker, createNotSupportedError) => {\n    return (nativeContext, options) => createNativeAudioNode(nativeContext, (ntvCntxt) => {\n        const channelCountMode = options.channelCountMode;\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        if (channelCountMode === 'clamped-max') {\n            throw createNotSupportedError();\n        }\n        // Bug #105: Safari does not support the StereoPannerNode.\n        if (nativeContext.createStereoPanner === undefined) {\n            return createNativeStereoPannerNodeFaker(nativeContext, options);\n        }\n        const nativeStereoPannerNode = ntvCntxt.createStereoPanner();\n        assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n            get: () => channelCountMode,\n            set: (value) => {\n                if (value !== channelCountMode) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n        return nativeStereoPannerNode;\n    });\n};\n//# sourceMappingURL=/build/es2018/factories/native-stereo-panner-node-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createStereoPannerNodeRendererFactory = (createNativeStereoPannerNode) => {\n    return () => {\n        const renderedNativeStereoPannerNodes = new WeakMap();\n        const createStereoPannerNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeStereoPannerNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeStereoPannerNode.channelCount,\n                    channelCountMode: nativeStereoPannerNode.channelCountMode,\n                    channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n                    pan: nativeStereoPannerNode.pan.value\n                };\n                nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.pan);\n            }\n            if (nativeStereoPannerNode.inputs !== undefined) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);\n            }\n            return nativeStereoPannerNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeStereoPannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeStereoPannerNode);\n                }\n                return createStereoPannerNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/stereo-panner-node-renderer-factory.js.map","import { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode) => {\n    return () => {\n        const renderedNativeWaveShaperNodes = new WeakMap();\n        const createWaveShaperNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeWaveShaperNode = getNativeAudioNode(proxy);\n            // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n            if (!nativeWaveShaperNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeWaveShaperNode.channelCount,\n                    channelCountMode: nativeWaveShaperNode.channelCountMode,\n                    channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                    curve: nativeWaveShaperNode.curve,\n                    oversample: nativeWaveShaperNode.oversample\n                };\n                nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n            if (nativeWaveShaperNode.inputs !== undefined) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);\n            }\n            return nativeWaveShaperNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeWaveShaperNode !== undefined) {\n                    return Promise.resolve(renderedNativeWaveShaperNode);\n                }\n                return createWaveShaperNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wave-shaper-node-renderer-factory.js.map","export const createIsSecureContext = (window) => (window !== null && window.isSecureContext);\n//# sourceMappingURL=/build/es2018/factories/is-secure-context.js.map","export const createExposeCurrentFrameAndCurrentTime = (window) => {\n    return (nativeContext, fn) => {\n        Object.defineProperties(window, {\n            currentFrame: {\n                configurable: true,\n                get() {\n                    return Math.round(nativeContext.currentTime * nativeContext.sampleRate);\n                }\n            },\n            currentTime: {\n                configurable: true,\n                get() {\n                    return nativeContext.currentTime;\n                }\n            }\n        });\n        try {\n            return fn();\n        }\n        finally {\n            if (window !== null) {\n                delete window.currentFrame;\n                delete window.currentTime;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/expose-current-frame-and-current-time.js.map","export const evaluateSource = (source) => {\n    return new Promise((resolve, reject) => {\n        const head = document.head;\n        if (head === null) {\n            reject(new SyntaxError());\n        }\n        else {\n            const script = document.createElement('script');\n            // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n            const blob = new Blob([source], { type: 'application/javascript' });\n            const url = URL.createObjectURL(blob);\n            const originalOnErrorHandler = window.onerror;\n            const removeErrorEventListenerAndRevokeUrl = () => {\n                window.onerror = originalOnErrorHandler;\n                URL.revokeObjectURL(url);\n            };\n            window.onerror = (message, src, lineno, colno, error) => {\n                // @todo Edge thinks the source is the one of the html document.\n                if (src === url || (src === location.href && lineno === 1 && colno === 1)) {\n                    removeErrorEventListenerAndRevokeUrl();\n                    reject(error);\n                    return false;\n                }\n                if (originalOnErrorHandler !== null) {\n                    return originalOnErrorHandler(message, src, lineno, colno, error);\n                }\n            };\n            script.onerror = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                reject(new SyntaxError());\n            };\n            script.onload = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                resolve();\n            };\n            script.src = url;\n            script.type = 'module';\n            head.appendChild(script);\n        }\n    });\n};\n//# sourceMappingURL=/build/es2018/helpers/evaluate-source.js.map","export const createFetchSource = (createAbortError) => {\n    return async (url) => {\n        try {\n            const response = await fetch(url);\n            if (response.ok) {\n                return response.text();\n            }\n        }\n        catch ( /* Ignore errors. */_a) { /* Ignore errors. */ } // tslint:disable-line:no-empty\n        throw createAbortError();\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/fetch-source.js.map","export const createIsNativeAudioContext = (nativeAudioContextConstructor) => {\n    return (anything) => {\n        return (nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-native-audio-context.js.map","export const createIsNativeContext = (isNativeAudioContext, isNativeOfflineAudioContext) => {\n    return (anything) => {\n        return (isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything));\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-native-context.js.map","export const createBaseAudioContextConstructor = (addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor) => {\n    return class BaseAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(_nativeContext, numberOfChannels) {\n            super(_nativeContext, numberOfChannels);\n            this._nativeContext = _nativeContext;\n            this._audioWorklet = (addAudioWorkletModule === undefined) ?\n                undefined :\n                { addModule: (moduleURL, options) => addAudioWorkletModule(this, moduleURL, options) };\n        }\n        get audioWorklet() {\n            return this._audioWorklet;\n        }\n        createAnalyser() {\n            return new analyserNodeConstructor(this);\n        }\n        createBiquadFilter() {\n            return new biquadFilterNodeConstructor(this);\n        }\n        createBuffer(numberOfChannels, length, sampleRate) {\n            return new audioBufferConstructor({ length, numberOfChannels, sampleRate });\n        }\n        createBufferSource() {\n            return new audioBufferSourceNodeConstructor(this);\n        }\n        createChannelMerger(numberOfInputs = 6) {\n            return new channelMergerNodeConstructor(this, { numberOfInputs });\n        }\n        createChannelSplitter(numberOfOutputs = 6) {\n            return new channelSplitterNodeConstructor(this, { numberOfOutputs });\n        }\n        createConstantSource() {\n            return new constantSourceNodeConstructor(this);\n        }\n        createConvolver() {\n            return new convolverNodeConstructor(this);\n        }\n        createDelay(maxDelayTime = 1) {\n            return new delayNodeConstructor(this, { maxDelayTime });\n        }\n        createDynamicsCompressor() {\n            return new dynamicsCompressorNodeConstructor(this);\n        }\n        createGain() {\n            return new gainNodeConstructor(this);\n        }\n        createIIRFilter(feedforward, feedback) {\n            return new iIRFilterNodeConstructor(this, { feedback, feedforward });\n        }\n        createOscillator() {\n            return new oscillatorNodeConstructor(this);\n        }\n        createPanner() {\n            return new pannerNodeConstructor(this);\n        }\n        createPeriodicWave(real, imag, constraints = { disableNormalization: false }) {\n            return new periodicWaveConstructor(this, { ...constraints, imag, real });\n        }\n        createStereoPanner() {\n            return new stereoPannerNodeConstructor(this);\n        }\n        createWaveShaper() {\n            return new waveShaperNodeConstructor(this);\n        }\n        decodeAudioData(audioData, successCallback, errorCallback) {\n            return decodeAudioData(this._nativeContext, audioData)\n                .then((audioBuffer) => {\n                if (typeof successCallback === 'function') {\n                    successCallback(audioBuffer);\n                }\n                return audioBuffer;\n            })\n                .catch((err) => {\n                if (typeof errorCallback === 'function') {\n                    errorCallback(err);\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/base-audio-context-constructor.js.map","import { DETACHED_ARRAY_BUFFERS } from '../globals';\nimport { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { getNativeContext } from '../helpers/get-native-context';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createDecodeAudioData = (cacheTestResult, createDataCloneError, createEncodingError, nativeOfflineAudioContextConstructor, isNativeContext, isNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testAudioBufferCopyChannelMethodsSubarraySupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds, wrapAudioBufferCopyChannelMethodsSubarray) => {\n    return (anyContext, audioData) => {\n        const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n        // Bug #43: Only Chrome and Opera do throw a DataCloneError.\n        if (DETACHED_ARRAY_BUFFERS.has(audioData)) {\n            const err = createDataCloneError();\n            return Promise.reject(err);\n        }\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n            DETACHED_ARRAY_BUFFERS.add(audioData);\n        }\n        catch (_a) {\n            // Ignore errors.\n        }\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n            // Bug #101: Edge does not decode something on a closed OfflineAudioContext.\n            const nativeContextOrBackupNativeContext = (nativeContext.state === 'closed' &&\n                nativeOfflineAudioContextConstructor !== null &&\n                isNativeOfflineAudioContext(nativeContext)) ?\n                new nativeOfflineAudioContextConstructor(1, 1, nativeContext.sampleRate) :\n                nativeContext;\n            const promise = nativeContextOrBackupNativeContext\n                .decodeAudioData(audioData)\n                .catch((err) => {\n                // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.\n                if (err instanceof DOMException && err.name === 'NotSupportedError') {\n                    throw new TypeError();\n                }\n                throw err;\n            });\n            return promise\n                .then((audioBuffer) => {\n                // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().\n                if (!cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, () => testAudioBufferCopyChannelMethodsSubarraySupport(audioBuffer))) {\n                    wrapAudioBufferCopyChannelMethodsSubarray(audioBuffer);\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                    // Bug #157: No browser does allow the bufferOffset to be out-of-bounds.\n                }\n                else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n                return audioBuffer;\n            });\n        }\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise((resolve, reject) => {\n            const complete = () => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                try {\n                    detachArrayBuffer(audioData);\n                }\n                catch ( /* Ignore errors. */_a) { /* Ignore errors. */ }\n            };\n            const fail = (err) => {\n                reject(err);\n                complete();\n            };\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                // Bug #1: Safari requires a successCallback.\n                nativeContext.decodeAudioData(audioData, (audioBuffer) => {\n                    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                    // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                    if (typeof audioBuffer.copyFromChannel !== 'function') {\n                        wrapAudioBufferCopyChannelMethods(audioBuffer);\n                        wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                    }\n                    complete();\n                    resolve(audioBuffer);\n                }, (err) => {\n                    // Bug #4: Safari returns null instead of an error.\n                    if (err === null) {\n                        fail(createEncodingError());\n                    }\n                    else {\n                        fail(err);\n                    }\n                });\n            }\n            catch (err) {\n                fail(err);\n            }\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/decode-audio-data.js.map","export const detachArrayBuffer = (arrayBuffer) => {\n    const { port1 } = new MessageChannel();\n    port1.postMessage(arrayBuffer, [arrayBuffer]);\n};\n//# sourceMappingURL=/build/es2018/helpers/detach-array-buffer.js.map","export const createDataCloneError = () => {\n    try {\n        return new DOMException('', 'DataCloneError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 25;\n        err.name = 'DataCloneError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/data-clone-error.js.map","export const createEncodingError = () => {\n    try {\n        return new DOMException('', 'EncodingError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 0;\n        err.name = 'EncodingError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/encoding-error.js.map","import { getNativeContext } from '../helpers/get-native-context';\nexport const createMediaElementAudioSourceNodeConstructor = (createNativeMediaElementAudioSourceNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class MediaElementAudioSourceNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw createNotSupportedError();\n            }\n            const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options);\n            super(context, 'active', nativeMediaElementAudioSourceNode, null);\n            // Bug #63: Edge & Firefox do not expose the mediaElement yet.\n            this._mediaElement = options.mediaElement;\n            this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n        }\n        get mediaElement() {\n            return (this._nativeMediaElementAudioSourceNode.mediaElement === undefined) ?\n                this._mediaElement :\n                this._nativeMediaElementAudioSourceNode.mediaElement;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/media-element-audio-source-node-constructor.js.map","export const createNativeMediaElementAudioSourceNodeFactory = (createNativeAudioNode) => {\n    return (nativeAudioContext, options) => createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n        return ntvDCntxt.createMediaElementSource(options.mediaElement);\n    });\n};\n//# sourceMappingURL=/build/es2018/factories/native-media-element-audio-source-node-factory.js.map","import { getNativeContext } from '../helpers/get-native-context';\nexport const createMediaStreamAudioSourceNodeConstructor = (createNativeMediaStreamAudioSourceNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class MediaStreamAudioSourceNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw createNotSupportedError();\n            }\n            const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options);\n            super(context, 'active', nativeMediaStreamAudioSourceNode, null);\n            this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n        }\n        get mediaStream() {\n            return this._nativeMediaStreamAudioSourceNode.mediaStream;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/media-stream-audio-source-node-constructor.js.map","export const createNativeMediaStreamAudioSourceNodeFactory = (createInvalidStateError, createNativeAudioNode) => {\n    return (nativeAudioContext, { mediaStream }) => {\n        const audioStreamTracks = mediaStream.getAudioTracks();\n        const nativeMediaStreamAudioSourceNode = createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n            /*\n             * Bug #151: Firefox does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n             * Bug #159: Chrome and Firefox pick the first audio track if the MediaStream has more than one audio track.\n             */\n            const filteredAudioStreamTracks = audioStreamTracks\n                .sort((a, b) => ((a.id < b.id) ? -1 : (a.id > b.id) ? 1 : 0))\n                .slice(0, 1);\n            return ntvDCntxt.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n        });\n        // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n        if (audioStreamTracks.length === 0) {\n            throw createInvalidStateError();\n        }\n        // Bug #63: Edge & Firefox do not expose the mediaStream yet.\n        Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', { value: mediaStream });\n        return nativeMediaStreamAudioSourceNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-media-stream-audio-source-node-factory.js.map","import { getNativeContext } from '../helpers/get-native-context';\nexport const createMediaStreamTrackAudioSourceNodeConstructor = (createNativeMediaStreamTrackAudioSourceNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class MediaStreamTrackAudioSourceNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw createNotSupportedError();\n            }\n            const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n            super(context, 'active', nativeMediaStreamTrackAudioSourceNode, null);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/media-stream-track-audio-source-node-constructor.js.map","export const createNativeMediaStreamTrackAudioSourceNodeFactory = (createInvalidStateError, createNativeAudioNode) => {\n    return (nativeAudioContext, { mediaStreamTrack }) => {\n        if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n            return createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => ntvDCntxt.createMediaStreamTrackSource(mediaStreamTrack));\n        }\n        // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n        return createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n            const mediaStream = new MediaStream([mediaStreamTrack]);\n            const nativeMediaStreamAudioSourceNode = ntvDCntxt.createMediaStreamSource(mediaStream);\n            // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n            if (mediaStreamTrack.kind !== 'audio') {\n                throw createInvalidStateError();\n            }\n            return nativeMediaStreamAudioSourceNode;\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-media-stream-track-audio-source-node-factory.js.map","import { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createAudioContextConstructor = (baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor) => {\n    return class AudioContext extends baseAudioContextConstructor {\n        constructor(options = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n            const nativeAudioContext = new nativeAudioContextConstructor(options);\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n            // Bug #51 Only Chrome and Opera throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n            }\n            // Bug #150 Only Chrome, Firefox and Opera support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n            super(nativeAudioContext, nativeAudioContext.destination.channelCount);\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency = (typeof nativeAudioContext.baseLatency === 'number')\n                ? nativeAudioContext.baseLatency\n                : (latencyHint === 'balanced')\n                    ? (512 / sampleRate)\n                    : (latencyHint === 'interactive' || latencyHint === undefined)\n                        ? (256 / sampleRate)\n                        : (latencyHint === 'playback')\n                            ? (1024 / sampleRate)\n                            /*\n                             * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                             * ScriptProcessorNode.\n                             */\n                            : ((Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate);\n            this._nativeAudioContext = nativeAudioContext;\n            this._state = null;\n            /*\n             * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n        get baseLatency() {\n            return this._baseLatency;\n        }\n        get state() {\n            return (this._state !== null) ? this._state : this._nativeAudioContext.state;\n        }\n        close() {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext\n                    .close()\n                    .then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n            return this._nativeAudioContext.close();\n            /*\n             * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n             * ...then(() => deleteAudioGraph(this, this._nativeAudioContext));\n             */\n        }\n        createMediaElementSource(mediaElement) {\n            return new mediaElementAudioSourceNodeConstructor(this, { mediaElement });\n        }\n        createMediaStreamSource(mediaStream) {\n            return new mediaStreamAudioSourceNodeConstructor(this, { mediaStream });\n        }\n        createMediaStreamTrackSource(mediaStreamTrack) {\n            return new mediaStreamTrackAudioSourceNodeConstructor(this, { mediaStreamTrack });\n        }\n        resume() {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        }\n                        else {\n                            this\n                                .resume()\n                                .then(resolve, reject);\n                        }\n                    };\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n            return this._nativeAudioContext\n                .resume()\n                .catch((err) => {\n                // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n        suspend() {\n            return this._nativeAudioContext\n                .suspend()\n                .catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-context-constructor.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const createConnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destination, output = 0, input = 0) => {\n        const outputAudioNode = outputAudioNodes[output];\n        if (outputAudioNode === undefined) {\n            throw createIndexSizeError();\n        }\n        if (isNativeAudioNode(destination)) {\n            return outputAudioNode.connect(destination, 0, input);\n        }\n        return outputAudioNode.connect(destination, 0);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/connect-multiple-outputs.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { AUXILIARY_GAIN_NODE_STORE } from '../globals';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n        if (options.outputChannelCount !== undefined) {\n            if (options.outputChannelCount.length !== options.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n            // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n            if (options.outputChannelCount.some((channelCount) => (channelCount < 1))) {\n                throw createNotSupportedError();\n            }\n        }\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters = (processorConstructor.parameterDescriptors === undefined)\n            ? 0\n            : processorConstructor.parameterDescriptors.length;\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n        const messageChannel = new MessageChannel();\n        const gainNodes = [];\n        const inputChannelSplitterNodes = [];\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(createNativeGainNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n            }));\n            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n            }));\n        }\n        const constantSourceNodes = [];\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: (options.parameterData[name] !== undefined)\n                        ? options.parameterData[name]\n                        : (defaultValue === undefined)\n                            ? 0\n                            : defaultValue\n                });\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined) ? 0 : defaultValue\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined) ? MOST_POSITIVE_SINGLE_FLOAT : maxValue\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined) ? MOST_NEGATIVE_SINGLE_FLOAT : minValue\n                    }\n                });\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, \n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        Math.max(1, numberOfOutputChannels));\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: options.outputChannelCount[i]\n            }));\n        }\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, (i * options.channelCount) + j);\n            }\n        }\n        const parameterMap = new ReadOnlyMap((processorConstructor.parameterDescriptors === undefined)\n            ? []\n            : processorConstructor.parameterDescriptors\n                .map(({ name }, index) => {\n                const constantSourceNode = constantSourceNodes[index];\n                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                constantSourceNode.start(0);\n                return [name, constantSourceNode.offset];\n            }));\n        inputChannelMergerNode.connect(scriptProcessorNode);\n        if (options.numberOfOutputs > 0) {\n            scriptProcessorNode.connect(outputChannelSplitterNode);\n        }\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n            const outputChannelMergerNode = outputChannelMergerNodes[i];\n            for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n            }\n            outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n        }\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror = null;\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = (options.numberOfOutputs === 0) ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode() {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation() {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n                channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return gainNodes;\n            },\n            get numberOfInputs() {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror() {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n                onprocessorerror = (typeof value === 'function') ? value : null;\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters() {\n                return parameterMap;\n            },\n            get port() {\n                return messageChannel.port2;\n            },\n            addEventListener(...args) {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        const patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener = (typeof args[1] === 'function')\n                        ? args[1]\n                        : (typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function')\n                            ? args[1].handleEvent\n                            : null;\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n                        if (patchedEventListener !== undefined) {\n                            args[1] = patchedEventListener;\n                        }\n                        else {\n                            args[1] = (event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext, () => unpatchedEventListener(event));\n                            };\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n                        args[1] = patchedEventListener;\n                    }\n                }\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n        let onmessage = null;\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n                onmessage = (typeof value === 'function') ? value : null;\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n        processorConstructor.prototype.port = messageChannel.port1;\n        let audioWorkletProcessor = null;\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n        audioWorkletProcessorPromise\n            .then((dWrkltPrcssr) => audioWorkletProcessor = dWrkltPrcssr);\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n        const parameters = (processorConstructor.parameterDescriptors === undefined) ?\n            [] :\n            processorConstructor.parameterDescriptors\n                .reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n        let isActive = true;\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {\n            if (audioWorkletProcessor !== null) {\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n                    try {\n                        const potentiallyEmptyInputs = inputs\n                            .map((input, index) => {\n                            const auxiliaryGainNodes = AUXILIARY_GAIN_NODE_STORE.get(nativeAudioWorkletNodeFaker);\n                            if (auxiliaryGainNodes === undefined || auxiliaryGainNodes.get(index) === undefined) {\n                                return [new Float32Array(0)];\n                            }\n                            return input;\n                        });\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n                        isActive = activeSourceFlag;\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n                            outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                        }\n                    }\n                    catch (error) {\n                        isActive = false;\n                        nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', { error }));\n                    }\n                    if (!isActive) {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        break;\n                    }\n                }\n            }\n        };\n        return nativeAudioWorkletNodeFaker;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-worklet-node-faker-factory.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { createAudioWorkletProcessorPromise } from './create-audio-worklet-processor-promise';\nexport const createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {\n    let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n    if (nodeToProcessorMap === undefined) {\n        nodeToProcessorMap = new WeakMap();\n        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n    }\n    const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n    nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n    return audioWorkletProcessorPromise;\n};\n//# sourceMappingURL=/build/es2018/helpers/create-audio-worklet-processor.js.map","import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nexport const createNativeAudioWorkletNodeFactory = (createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNotSupportedError, isNativeOfflineAudioContext) => {\n    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            try {\n                // Bug #86: Chrome Canary does not invoke the process() function if the corresponding AudioWorkletNode has no output.\n                const nativeAudioWorkletNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n                    return (isNativeOfflineAudioContext(ntvCntxt) && options.numberOfInputs !== 0 && options.numberOfOutputs === 0) ?\n                        new nativeAudioWorkletNodeConstructor(ntvCntxt, name, {\n                            ...options,\n                            numberOfOutputs: 1,\n                            outputChannelCount: [1],\n                            parameterData: { ...options.parameterData, hasNoOutput: 1 }\n                        }) :\n                        new nativeAudioWorkletNodeConstructor(ntvCntxt, name, options);\n                });\n                const patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n                let onprocessorerror = null;\n                Object.defineProperties(nativeAudioWorkletNode, {\n                    /*\n                     * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n                     * browsers have no native implementation to achieve a consistent behavior.\n                     */\n                    channelCount: {\n                        get: () => options.channelCount,\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    channelCountMode: {\n                        get: () => 'explicit',\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    // Bug #156: Chrome does not yet fire an ErrorEvent.\n                    onprocessorerror: {\n                        get: () => onprocessorerror,\n                        set: (value) => {\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                            }\n                            onprocessorerror = (typeof value === 'function') ? value : null;\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                            }\n                        }\n                    }\n                });\n                nativeAudioWorkletNode.addEventListener = ((addEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const unpatchedEventListener = (typeof args[1] === 'function')\n                                ? args[1]\n                                : (typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function')\n                                    ? args[1].handleEvent\n                                    : null;\n                            if (unpatchedEventListener !== null) {\n                                const patchedEventListener = patchedEventListeners.get(args[1]);\n                                if (patchedEventListener !== undefined) {\n                                    args[1] = patchedEventListener;\n                                }\n                                else {\n                                    args[1] = (event) => {\n                                        unpatchedEventListener(new ErrorEvent(args[0], { ...event, error: new Error( /* @todo */) }));\n                                    };\n                                    patchedEventListeners.set(unpatchedEventListener, args[1]);\n                                }\n                            }\n                        }\n                        return addEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.addEventListener);\n                nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const patchedEventListener = patchedEventListeners.get(args[1]);\n                            if (patchedEventListener !== undefined) {\n                                patchedEventListeners.delete(args[1]);\n                                args[1] = patchedEventListener;\n                            }\n                        }\n                        return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.removeEventListener);\n                return nativeAudioWorkletNode;\n            }\n            catch (err) {\n                // Bug #60: Chrome Canary throws an InvalidStateError instead of a NotSupportedError.\n                if (err.code === 11) {\n                    throw createNotSupportedError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            }\n        }\n        // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n            throw createNotSupportedError();\n        }\n        testClonabilityOfAudioWorkletNodeOptions(options);\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-worklet-node-factory.js.map","export const testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    const { port1 } = new MessageChannel();\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    }\n    finally {\n        port1.close();\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/test-clonability-of-audio-worklet-node-options.js.map","export const createNativeAudioWorkletNodeConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    return (window.hasOwnProperty('AudioWorkletNode')) ? window.AudioWorkletNode : null;\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-worklet-node-constructor.js.map","import { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createMinimalAudioContextConstructor = (createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor) => {\n    return class MinimalAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(options = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n            const nativeAudioContext = new nativeAudioContextConstructor(options);\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n            // Bug #51 Only Chrome and Opera throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n            }\n            // Bug #150 Only Chrome, Firefox and Opera support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n            super(nativeAudioContext, nativeAudioContext.destination.channelCount);\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency = (typeof nativeAudioContext.baseLatency === 'number')\n                ? nativeAudioContext.baseLatency\n                : (latencyHint === 'balanced')\n                    ? (512 / sampleRate)\n                    : (latencyHint === 'interactive' || latencyHint === undefined)\n                        ? (256 / sampleRate)\n                        : (latencyHint === 'playback')\n                            ? (1024 / sampleRate)\n                            /*\n                             * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                             * ScriptProcessorNode.\n                             */\n                            : ((Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate);\n            this._nativeAudioContext = nativeAudioContext;\n            this._state = null;\n            /*\n             * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually\n             * changes to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n        get baseLatency() {\n            return this._baseLatency;\n        }\n        get state() {\n            return (this._state !== null) ? this._state : this._nativeAudioContext.state;\n        }\n        close() {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext\n                    .close()\n                    .then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n            return this._nativeAudioContext.close();\n            /*\n             * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n             * ...then(() => deleteAudioGraph(this, this._nativeAudioContext));\n             */\n        }\n        resume() {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        }\n                        else {\n                            this\n                                .resume()\n                                .then(resolve, reject);\n                        }\n                    };\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n            return this._nativeAudioContext\n                .resume()\n                .catch((err) => {\n                // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n        suspend() {\n            return this._nativeAudioContext\n                .suspend()\n                .catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/minimal-audio-context-constructor.js.map","export const createCreateNativeOfflineAudioContext = (createNotSupportedError, nativeOfflineAudioContextConstructor) => {\n    return (numberOfChannels, length, sampleRate) => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n        try {\n            return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n        }\n        catch (err) {\n            // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n            // Bug #143: Edge throws a SyntaxError when numberOfChannels or length are invalid.\n            // Bug #145: Edge throws an IndexSizeError when sampleRate is zero.\n            if (err.name === 'IndexSizeError' || err.name === 'SyntaxError') {\n                throw createNotSupportedError();\n            }\n            throw err; // tslint:disable-line:rxjs-throw-error\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/create-native-offline-audio-context.js.map","import { getAudioNodeRenderer } from '../helpers/get-audio-node-renderer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createStartRendering = (cacheTestResult, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testAudioBufferCopyChannelMethodsSubarraySupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds, wrapAudioBufferCopyChannelMethodsSubarray) => {\n    return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer(destination)\n        .render(destination, nativeOfflineAudioContext)\n        .then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext))\n        .then((audioBuffer) => {\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n        if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n            // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().\n        }\n        else if (!cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, () => testAudioBufferCopyChannelMethodsSubarraySupport(audioBuffer))) {\n            wrapAudioBufferCopyChannelMethodsSubarray(audioBuffer);\n            wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            // Bug #157: No browser does allow the bufferOffset to be out-of-bounds.\n        }\n        else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n            wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n        }\n        return audioBuffer;\n    });\n};\n//# sourceMappingURL=/build/es2018/factories/start-rendering.js.map","export const createIsAnyAudioContext = (contextStore, isNativeAudioContext) => {\n    return (anything) => {\n        const nativeContext = contextStore.get(anything);\n        return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-any-audio-context.js.map","export const createIsAnyAudioNode = (audioNodeStore, isNativeAudioNode) => {\n    return (anything) => audioNodeStore.has(anything) || isNativeAudioNode(anything);\n};\n//# sourceMappingURL=/build/es2018/factories/is-any-audio-node.js.map","export const createIsAnyAudioParam = (audioParamStore, isNativeAudioParam) => {\n    return (anything) => audioParamStore.has(anything) || isNativeAudioParam(anything);\n};\n//# sourceMappingURL=/build/es2018/factories/is-any-audio-param.js.map","export const createIsAnyOfflineAudioContext = (contextStore, isNativeOfflineAudioContext) => {\n    return (anything) => {\n        const nativeContext = contextStore.get(anything);\n        return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-any-offline-audio-context.js.map","import {\n\tAudioContext as stdAudioContext,\n\tOfflineAudioContext as stdOfflineAudioContext,\n} from \"standardized-audio-context\";\n\n/**\n * Create a new AudioContext\n */\nfunction createAudioContext(): AudioContext {\n\treturn new stdAudioContext() as unknown as AudioContext;\n}\n\n/**\n * Create a new OfflineAudioContext\n */\nexport function createOfflineAudioContext(channels: number, length: number, sampleRate: number): OfflineAudioContext {\n\treturn new stdOfflineAudioContext(channels, length, sampleRate)  as unknown as OfflineAudioContext;\n}\n\n/**\n * Either the online or offline audio context\n */\nexport type AnyAudioContext = AudioContext | OfflineAudioContext;\n\n/**\n * Interface for things that Tone.js adds to the window\n */\ninterface ToneWindow extends Window {\n\tTONE_AUDIO_CONTEXT?: AnyAudioContext;\n\tTONE_SILENCE_LOGGING?: boolean;\n\tTONE_DEBUG_CLASS?: string;\n}\n\n/**\n * A reference to the window object\n * @hidden\n */\nexport const theWindow: ToneWindow | null = typeof self === \"object\" ? self : null;\n\n/**\n * If the browser has a window object which has an AudioContext\n * @hidden\n */\nexport const hasAudioContext = theWindow &&\n\t(theWindow.hasOwnProperty(\"AudioContext\") || theWindow.hasOwnProperty(\"webkitAudioContext\"));\n\n/**\n * The global audio context which is getable and assignable through\n * getAudioContext and setAudioContext\n */\nlet globalContext: AnyAudioContext;\n\n// if it was created already, use that one\n// this enables multiple versions of Tone.js to run on the same page.\nif (theWindow && theWindow.TONE_AUDIO_CONTEXT) {\n\tglobalContext = theWindow.TONE_AUDIO_CONTEXT;\n}\n\n/**\n * Returns the default system-wide AudioContext\n */\nexport function getAudioContext(): AnyAudioContext {\n\tif (!globalContext && hasAudioContext) {\n\t\tsetAudioContext(createAudioContext());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n */\nexport function setAudioContext(context: AnyAudioContext): void {\n\tglobalContext = context;\n\tif (theWindow) {\n\t\ttheWindow.TONE_AUDIO_CONTEXT = globalContext;\n\t}\n}\n","import { Seconds } from \"../type/Units\";\n\nexport type TickerClockSource = \"worker\" | \"timeout\" | \"offline\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n * @category Core\n */\nexport class Ticker {\n\n\t/**\n\t * Either \"worker\" or \"timeout\" or \"offline\"\n\t */\n\tprivate _type: TickerClockSource;\n\n\t/**\n\t * The update interval of the worker\n\t */\n\tprivate _updateInterval: Seconds;\n\n\t/**\n\t * The callback to invoke at regular intervals\n\t */\n\tprivate _callback: () => void;\n\n\t/**\n\t * track the callback interval\n\t */\n\tprivate _timeout!: number;\n\n\t/**\n\t * private reference to the worker\n\t */\n\tprivate _worker!: Worker;\n\n\tconstructor(callback: () => void, type: TickerClockSource, updateInterval: Seconds) {\n\n\t\tthis._callback = callback;\n\t\tthis._type = type;\n\t\tthis._updateInterval = updateInterval;\n\n\t\t// create the clock source for the first time\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t *  Generate a web worker\n\t */\n\tprivate _createWorker(): void {\n\n\t\tconst blob = new Blob([\n\t\t\t// the initial timeout time\n\t\t\t`var timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();`,\n\t\t]);\n\t\tconst blobUrl = URL.createObjectURL(blob);\n\t\tconst worker = new Worker(blobUrl);\n\n\t\tworker.onmessage = this._callback.bind(this);\n\n\t\tthis._worker = worker;\n\t}\n\n\t/**\n\t * Create a timeout loop\n\t */\n\tprivate _createTimeout(): void {\n\t\tthis._timeout = setTimeout(()  => {\n\t\t\tthis._createTimeout();\n\t\t\tthis._callback();\n\t\t}, this._updateInterval * 1000);\n\t}\n\n\t/**\n\t * Create the clock source.\n\t */\n\tprivate _createClock(): void {\n\t\tif (this._type === \"worker\") {\n\t\t\ttry {\n\t\t\t\tthis._createWorker();\n\t\t\t} catch (e) {\n\t\t\t\t// workers not supported, fallback to timeout\n\t\t\t\tthis._type = \"timeout\";\n\t\t\t\tthis._createClock();\n\t\t\t}\n\t\t} else if (this._type === \"timeout\") {\n\t\t\tthis._createTimeout();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up the current clock source\n\t */\n\tprivate _disposeClock(): void {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t\tthis._timeout = 0;\n\t\t}\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\t\t\tthis._worker.onmessage = null;\n\t\t}\n\t}\n\n\t/**\n\t * The rate in seconds the ticker will update\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._updateInterval = Math.max(interval, 128 / 44100);\n\t\tif (this._type === \"worker\") {\n\t\t\tthis._worker.postMessage(Math.max(interval * 1000, 1));\n\t\t}\n\t}\n\n\t/**\n\t * The type of the ticker, either a worker or a timeout\n\t */\n\tget type(): TickerClockSource {\n\t\treturn this._type;\n\t}\n\tset type(type: TickerClockSource) {\n\t\tthis._disposeClock();\n\t\tthis._type = type;\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): void {\n\t\tthis._disposeClock();\n\t}\n}\n","import {\n\tisAnyAudioContext, isAnyAudioNode,\n\tisAnyAudioParam, isAnyOfflineAudioContext,\n} from \"standardized-audio-context\";\n\n/**\n * Test if the given value is an instanceof AudioParam\n */\nexport function isAudioParam(arg: any): arg is AudioParam {\n\treturn isAnyAudioParam(arg);\n}\n\n/**\n * Test if the given value is an instanceof AudioNode\n */\nexport function isAudioNode(arg: any): arg is AudioNode {\n\treturn isAnyAudioNode(arg);\n}\n\n/**\n * Test if the arg is instanceof an OfflineAudioContext\n */\nexport function isOfflineAudioContext(arg: any): arg is OfflineAudioContext {\n\treturn isAnyOfflineAudioContext(arg);\n}\n\n/**\n * Test if the arg is an instanceof AudioContext\n */\nexport function isAudioContext(arg: any): arg is AudioContext {\n\treturn isAnyAudioContext(arg);\n}\n\n/**\n * Test if the arg is instanceof an AudioBuffer\n */\nexport function isAudioBuffer(arg: any): arg is AudioBuffer {\n\treturn arg instanceof AudioBuffer;\n}\n","import { Note } from \"../type/Units\";\n\n/**\n *  Test if the arg is undefined\n */\nexport function isUndef(arg: any): arg is undefined {\n\treturn typeof arg === \"undefined\";\n}\n\n/**\n *  Test if the arg is not undefined\n */\nexport function isDefined<T>(arg: T | undefined): arg is T {\n\treturn !isUndef(arg);\n}\n\n/**\n *  Test if the arg is a function\n */\nexport function isFunction(arg: any): arg is (a: any) => any {\n\treturn typeof arg === \"function\";\n}\n\n/**\n *  Test if the argument is a number.\n */\nexport function isNumber(arg: any): arg is number {\n\treturn (typeof arg === \"number\");\n}\n\n/**\n *  Test if the given argument is an object literal (i.e. `{}`);\n */\nexport function isObject(arg: any): arg is object {\n\treturn (Object.prototype.toString.call(arg) === \"[object Object]\" && arg.constructor === Object);\n}\n\n/**\n *  Test if the argument is a boolean.\n */\nexport function isBoolean(arg: any): arg is boolean {\n\treturn (typeof arg === \"boolean\");\n}\n\n/**\n *  Test if the argument is an Array\n */\nexport function isArray(arg: any): arg is any[] {\n\treturn (Array.isArray(arg));\n}\n\n/**\n *  Test if the argument is a string.\n */\nexport function isString(arg: any): arg is string {\n\treturn (typeof arg === \"string\");\n}\n\n/**\n *  Test if the argument is in the form of a note in scientific pitch notation.\n *  e.g. \"C4\"\n */\nexport function isNote(arg: any): arg is Note {\n\treturn isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}\n","import { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n\ntype BaseToneOptions = import(\"../Tone\").BaseToneOptions;\n\n/**\n * Some objects should not be merged\n */\nfunction noCopy(key: string, arg: any): boolean {\n\treturn key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\n\n/**\n * Recursively merge an object\n * @param target the object to merge into\n * @param sources the source objects to merge\n */\nexport function deepMerge<T>(target: T): T;\nexport function deepMerge<T, U>(target: T, source1: U): T & U;\nexport function deepMerge<T, U, V>(target: T, source1: U, source2: V): T & U & V;\nexport function deepMerge<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function deepMerge(target: any, ...sources: any[]): any {\n\tif (!sources.length) { return target; }\n\tconst source = sources.shift();\n\n\tif (isObject(target) && isObject(source)) {\n\t\tfor (const key in source) {\n\t\t\tif (noCopy(key, source[key])) {\n\t\t\t\ttarget[key] = source[key];\n\t\t\t} else if (isObject(source[key])) {\n\t\t\t\tif (!target[key]) { Object.assign(target, { [key]: {} }); }\n\t\t\t\tdeepMerge(target[key], source[key] as any);\n\t\t\t} else {\n\t\t\t\tObject.assign(target, { [key]: source[key] as any });\n\t\t\t}\n\t\t}\n\t}\n\t// @ts-ignore\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\nexport function deepEquals(arrayA: number[] | string[], arrayB: number[] | string[]): boolean {\n\treturn arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);\n}\n\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments<T extends object>(\n\tdefaults: T,\n\targsArray: IArguments,\n\tkeys: string[] = [],\n\tobjKey?: string,\n): T {\n\tconst opts: any = {};\n\tconst args = Array.from(argsArray);\n\t// if the first argument is an object and has an object key\n\tif (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n\t\t// if it's not part of the defaults\n\t\tconst partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n\t\tif (!partOfDefaults) {\n\t\t\t// merge that key\n\t\t\tdeepMerge(opts, {[objKey] : args[0]});\n\t\t\t// remove the obj key from the keys\n\t\t\tkeys.splice(keys.indexOf(objKey), 1);\n\t\t\t// shift the first argument off\n\t\t\targs.shift();\n\t\t}\n\t}\n\tif (args.length === 1 && isObject(args[0])) {\n\t\tdeepMerge(opts, args[0]);\n\t} else {\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tif (isDefined(args[i])) {\n\t\t\t\topts[keys[i]] = args[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn deepMerge(defaults, opts);\n}\n\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance<T>(instance: T): BaseToneOptions {\n\ttype ToneClass = {\n\t\tconstructor: ToneClass;\n\t\tgetDefaults: () => BaseToneOptions;\n\t} & T;\n\n\treturn (instance as ToneClass).constructor.getDefaults();\n}\n\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg<T>(given: T, fallback: T): T {\n\tif (isUndef(given)) {\n\t\treturn fallback;\n\t} else {\n\t\treturn given;\n\t}\n}\n\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject<T extends object, O extends string[]>(obj: T, omit: O): Omit<T, keyof O> {\n\tomit.forEach(prop => {\n\t\tif (Reflect.has(obj, prop)) {\n\t\t\tdelete obj[prop];\n\t\t}\n\t});\n\treturn obj;\n}\n","/**\n *  Assert that the statement is true, otherwise invoke an error with the given message.\n */\nexport function assert(statement: boolean, error: string): void {\n\tif (!statement) {\n\t\tthrow new Error(error);\n\t}\n}\n\nexport function log(...args: any[]): void {\n\t// tslint:disable-next-line: no-console\n\tconsole.log(...args);\n}\n","/**\n *  Tone.js\n * @author Yotam Mann\n * @license http://opensource.org/licenses/MIT MIT License\n * @copyright 2014-2019 Yotam Mann\n */\nimport { version } from \"../version\";\nimport { theWindow } from \"./context/AudioContext\";\nimport { assert, log } from \"./util/Debug\";\n\n///////////////////////////////////////////////////////////////////////////\n// \tTONE\n///////////////////////////////////////////////////////////////////////////\n\n// tslint:disable-next-line: no-empty-interface\nexport interface BaseToneOptions {}\n\n/**\n * @class  Tone is the base class of all other classes.\n * @constructor\n */\nexport abstract class Tone {\n\n\t/**\n\t * The version number semver\n\t */\n\tstatic version: string = version;\n\n\t/**\n\t * The name of the class\n\t */\n\tprotected abstract name: string;\n\n\t/**\n\t * Takes a partial options an returns the completed options by filling in the defaults\n\t */\n\tstatic getDefaults(): BaseToneOptions {\n\t\treturn {};\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tDEBUGGING\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Set this debug flag to log all events that happen in this class.\n\t */\n\tdebug: boolean = false;\n\n\t/**\n\t * Prints the outputs to the console log for debugging purposes.\n\t * Prints the contents only if either the object has a property\n\t * called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n\t * is set to the name of the class.\n\t * @example\n\t * //prints all logs originating from Tone.OscillatorNode\n\t * Tone.global.TONE_DEBUG_CLASS = \"OscillatorNode\"\n\t */\n\tprotected log(...args: any[]): void {\n\t\t// if the object is either set to debug = true\n\t\t// or if there is a string on the Tone.global.with the class name\n\t\tif (this.debug || (theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS)) {\n\t\t\targs.unshift(this.toString() + \":\");\n\t\t\tlog(...args);\n\t\t}\n\t}\n\n\t/**\n\t *  Assert that the statement is true, otherwise invoke the error.\n\t * @param statement\n\t * @param error The message which is passed into an Error\n\t */\n\tprotected assert(statement: boolean, error: string): void {\n\t\tassert(statement, error);\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tDISPOSING\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Indicates if the instance was disposed\n\t */\n\tprivate _wasDisposed: boolean = false;\n\n\t/**\n\t *  disconnect and dispose.\n\t */\n\tdispose(): this {\n\t\tthis._wasDisposed = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Indicates if the instance was disposed. 'Disposing' an\n\t * instance means that all of the Web Audio nodes that were\n\t * created for the instance are disconnected and freed for garbage collection.\n\t */\n\tget disposed(): boolean {\n\t\treturn this._wasDisposed;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tDEFAULTS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  If the `given` parameter is undefined, use the `fallback`.\n\t *  If both `given` and `fallback` are object literals, it will\n\t *  return a deep copy which includes all of the parameters from both\n\t *  objects. If a parameter is undefined in given, it will return\n\t *  the fallback property.\n\t *  <br><br>\n\t *  WARNING: if object is self referential, it will go into an an\n\t *  infinite recursive loop.\n\t * @memberOf Tone\n\t * @param  {*} given\n\t * @param  {*} fallback\n\t * @return {*}\n\t */\n\t// static defaultArg(given, fallback) {\n\t\t// if (isObject(given) && isObject(fallback)) {\n\t\t// \tconst ret = {};\n\t\t// \t// make a deep copy of the given object\n\t\t// \tfor (const givenProp in given) {\n\t\t// \t\tret[givenProp] = Tone.defaultArg(fallback[givenProp], given[givenProp]);\n\t\t// \t}\n\t\t// \tfor (const fallbackProp in fallback) {\n\t\t// \t\tret[fallbackProp] = Tone.defaultArg(given[fallbackProp], fallback[fallbackProp]);\n\t\t// \t}\n\t\t// \treturn ret;\n\t\t// } else {\n\t\t// \treturn isUndef(given) ? fallback : given;\n\t\t// }\n\t// }\n\n\t// protected options(argsArray: IArguments, keys: string[]): object {\n\t// \tlet options: any = {};\n\t// \tconst args = Array.from(argsArray);\n\t// \tif (args[0] instanceof BaseAudioContext) {\n\t// \t\toptions.context = args.shift();\n\t// \t}\n\t// \tif (args.length === 1 && isObject(args[0])) {\n\t// \t\toptions = Object.assign(options, args[0]);\n\t// \t} else {\n\t// \t\tfor (let i = 0; i < keys.length; i++) {\n\t// \t\t\tif (isDefined(args[i])) {\n\t// \t\t\t\toptions[keys[i]] = args[i];\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// \treturn deepMerge(this.getDefaults(), options);\n\t// }\n\n\t/**\n\t * Convert the class to a string\n\t * @example\n\t * const osc = new Oscillator()\n\t * osc.toString() // \"Oscillator\"\n\t */\n\ttoString(): string {\n\t\treturn this.name;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tSTATIC\n\t///////////////////////////////////////////////////////////////////////////\n\n\t// static get context(): import(\"./context/Context\").Context {\n\t// \treturn getContext();\n\t// }\n\n\t// static now(): Seconds {\n\t// \treturn Tone.context.now();\n\t// }\n}\n","import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n\nexport interface EmitterEventObject {\n\t[event: string]: Array<(...args: any[]) => void>;\n}\n\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n * @category Core\n */\nexport class Emitter<EventType extends string = string> extends Tone {\n\n\tname = \"Emitter\";\n\n\t/**\n\t * Private container for the events\n\t */\n\tprivate _events?: EmitterEventObject;\n\n\t/**\n\t *  Bind a callback to a specific event.\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\ton(event: EventType, callback: (...args: any[]) => void): this {\n\t\t// split the event\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (!this._events.hasOwnProperty(eventName)) {\n\t\t\t\tthis._events[eventName] = [];\n\t\t\t}\n\t\t\tthis._events[eventName].push(callback);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Bind a callback which is only invoked once\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\tonce(event: EventType, callback: (...args: any[]) => void): this {\n\t\tconst boundCallback = (...args: any[])  => {\n\t\t\t// invoke the callback\n\t\t\tcallback(...args);\n\t\t\t// remove the event\n\t\t\tthis.off(event, boundCallback);\n\t\t};\n\t\tthis.on(event, boundCallback);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove the event listener.\n\t * @param  event     The event to stop listening to.\n\t * @param  callback  The callback which was bound to the event with Emitter.on.\n\t *                    If no callback is given, all callbacks events are removed.\n\t */\n\toff(event: EventType, callback?: (...args: any[]) => void): this {\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tif (isUndef(callback)) {\n\t\t\t\t\tthis._events[event] = [];\n\t\t\t\t} else {\n\t\t\t\t\tconst eventList = this._events[event];\n\t\t\t\t\tfor (let i = 0; i < eventList.length; i++) {\n\t\t\t\t\t\tif (eventList[i] === callback) {\n\t\t\t\t\t\t\teventList.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Invoke all of the callbacks bound to the event\n\t *  with any arguments passed in.\n\t * @param  event  The name of the event.\n\t * @param args The arguments to pass to the functions listening.\n\t */\n\temit(event, ...args: any[]): this {\n\t\tif (this._events) {\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tconst eventList = this._events[event].slice(0);\n\t\t\t\tfor (let i = 0, len = eventList.length; i < len; i++) {\n\t\t\t\t\teventList[i].apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Add Emitter functions (on/off/emit) to the object\n\t */\n\tstatic mixin(constr: any): void {\n\t\t// instance._events = {};\n\t\t[\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n\t\t\tconst property = Object.getOwnPropertyDescriptor(Emitter.prototype, name) as PropertyDescriptor;\n\t\t\tObject.defineProperty(constr.prototype, name, property);\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events = undefined;\n\t\treturn this;\n\t}\n}\n","import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"./Defaults\";\n\ntype TimelineSearchParam = \"ticks\" | \"time\";\n\n/**\n * The options object for Timeline\n */\ninterface TimelineOptions {\n\tmemory: number;\n}\n\n/**\n * An event must have a time number\n */\nexport interface TimelineEvent {\n\ttime: number;\n}\n\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n * @category Core\n */\nexport class Timeline<GenericEvent extends TimelineEvent> extends Tone {\n\n\treadonly name: string = \"Timeline\";\n\n\t/**\n\t *  The memory of the timeline, i.e.\n\t *  how many events in the past it will retain\n\t */\n\tmemory: number;\n\n\t/**\n\t * The array of scheduled timeline events\n\t */\n\tprotected _timeline: GenericEvent[] = [];\n\n\t/**\n\t * @param memory The number of previous events that are retained.\n\t */\n\tconstructor(memory?: number);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<TimelineOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n\n\t\tthis.memory = options.memory;\n\t}\n\n\tstatic getDefaults(): TimelineOptions {\n\t\treturn {\n\t\t\tmemory: Infinity,\n\t\t};\n\t}\n\n\t/**\n\t *  The number of items in the timeline.\n\t */\n\tget length(): number {\n\t\treturn this._timeline.length;\n\t}\n\n\t/**\n\t *  Insert an event object onto the timeline. Events must have a \"time\" attribute.\n\t * @param event  The event object to insert into the timeline.\n\t */\n\tadd(event: GenericEvent): Timeline<GenericEvent> {\n\t\t// the event needs to have a time attribute\n\t\tthis.assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n\t\tevent.time = event.time.valueOf();\n\t\tconst index = this._search(event.time);\n\t\tthis._timeline.splice(index + 1, 0, event);\n\t\t// if the length is more than the memory, remove the previous ones\n\t\tif (this.length > this.memory) {\n\t\t\tconst diff = this.length - this.memory;\n\t\t\tthis._timeline.splice(0, diff);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove an event from the timeline.\n\t * @param  {Object}  event  The event object to remove from the list.\n\t * @returns {Timeline} this\n\t */\n\tremove(event: GenericEvent): Timeline<GenericEvent> {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index !== -1) {\n\t\t\tthis._timeline.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Get the nearest event whose time is less than or equal to the given time.\n\t * @param  time  The time to query.\n\t */\n\tget(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index !== -1) {\n\t\t\treturn this._timeline[index];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Return the first event in the timeline without removing it\n\t * @returns {Object} The first event object\n\t */\n\tpeek(): GenericEvent | undefined {\n\t\treturn this._timeline[0];\n\t}\n\n\t/**\n\t *  Return the first event in the timeline and remove it\n\t */\n\tshift(): GenericEvent | undefined {\n\t\treturn this._timeline.shift();\n\t}\n\n\t/**\n\t *  Get the event which is scheduled after the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetAfter(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index + 1 < this._timeline.length) {\n\t\t\treturn this._timeline[index + 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Get the event before the event at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetBefore(time: number): GenericEvent | null {\n\t\tconst len = this._timeline.length;\n\t\t// if it's after the last item, return the last item\n\t\tif (len > 0 && this._timeline[len - 1].time < time) {\n\t\t\treturn this._timeline[len - 1];\n\t\t}\n\t\tconst index = this._search(time);\n\t\tif (index - 1 >= 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Cancel events at and after the given time\n\t * @param  time  The time to query.\n\t */\n\tcancel(after: number): Timeline<GenericEvent> {\n\t\tif (this._timeline.length > 1) {\n\t\t\tlet index = this._search(after);\n\t\t\tif (index >= 0) {\n\t\t\t\tif (this._timeline[index].time === after) {\n\t\t\t\t\t// get the first item with that time\n\t\t\t\t\tfor (let i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (this._timeline[i].time === after) {\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index);\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t} else if (this._timeline.length === 1) {\n\t\t\t// the first item's time\n\t\t\tif (this._timeline[0].time >= after) {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel events before or equal to the given time.\n\t * @param  {Number}  time  The time to cancel before.\n\t * @returns {Timeline} this\n\t */\n\tcancelBefore(time): Timeline<GenericEvent> {\n\t\tconst index = this._search(time);\n\t\tif (index >= 0) {\n\t\t\tthis._timeline = this._timeline.slice(index + 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the previous event if there is one. null otherwise\n\t * @param  {Object} event The event to find the previous one of\n\t * @return {Object}       The event right before the given event\n\t */\n\tpreviousEvent(event): GenericEvent | null {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index > 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Does a binary search on the timeline array and returns the\n\t *  nearest event index whose time is after or equal to the given time.\n\t *  If a time is searched before the first index in the timeline, -1 is returned.\n\t *  If the time is after the end, the index of the last item is returned.\n\t * @param  time\n\t */\n\tprotected _search(time: number, param: TimelineSearchParam = \"time\"): number {\n\t\tif (this._timeline.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet beginning = 0;\n\t\tconst len = this._timeline.length;\n\t\tlet end = len;\n\t\tif (len > 0 && this._timeline[len - 1][param] <= time) {\n\t\t\treturn len - 1;\n\t\t}\n\t\twhile (beginning < end) {\n\t\t\t// calculate the midpoint for roughly equal partition\n\t\t\tlet midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t\t\tconst event = this._timeline[midPoint];\n\t\t\tconst nextEvent = this._timeline[midPoint + 1];\n\t\t\tif (event[param] === time) {\n\t\t\t\t// choose the last one that has the same time\n\t\t\t\tfor (let i = midPoint; i < this._timeline.length; i++) {\n\t\t\t\t\tconst testEvent = this._timeline[i];\n\t\t\t\t\tif (testEvent[param] === time) {\n\t\t\t\t\t\tmidPoint = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn midPoint;\n\t\t\t} else if (event[param] < time && nextEvent[param] > time) {\n\t\t\t\treturn midPoint;\n\t\t\t} else if (event[param] > time) {\n\t\t\t\t// search lower\n\t\t\t\tend = midPoint;\n\t\t\t} else {\n\t\t\t\t// search upper\n\t\t\t\tbeginning = midPoint + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t *  Internal iterator. Applies extra safety checks for\n\t *  removing items from the array.\n\t */\n\tprivate _iterate(\n\t\tcallback: (event: GenericEvent) => void,\n\t\tlowerBound = 0, upperBound = this._timeline.length - 1,\n\t): void {\n\t\tthis._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n\t}\n\n\t/**\n\t *  Iterate over everything in the array\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\tthis._iterate(callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at or before the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBefore(time, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array after the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAfter(time, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst lowerBound = this._search(time);\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array between the startTime and endTime.\n\t *  The timerange is inclusive of the startTime, but exclusive of the endTime.\n\t *  range = [startTime, endTime).\n\t * @param  startTime The time to check if items are before\n\t * @param  endTime The end of the test interval.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBetween(startTime: number, endTime: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\tlet lowerBound = this._search(startTime);\n\t\tlet upperBound = this._search(endTime);\n\t\tif (lowerBound !== -1 && upperBound !== -1) {\n\t\t\tif (this._timeline[lowerBound].time !== startTime) {\n\t\t\t\tlowerBound += 1;\n\t\t\t}\n\t\t\t// exclusive of the end time\n\t\t\tif (this._timeline[upperBound].time === endTime) {\n\t\t\t\tupperBound -= 1;\n\t\t\t}\n\t\t\tthis._iterate(callback, lowerBound, upperBound);\n\t\t} else if (lowerBound === -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at or after the given time. Similar to\n\t *  forEachAfter, but includes the item(s) at the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tlet lowerBound = this._search(time);\n\t\t// work backwards until the event time is less than time\n\t\twhile (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n\t\t\tlowerBound--;\n\t\t}\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array at the given time\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: GenericEvent) => void): Timeline<GenericEvent> {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(event => {\n\t\t\t\tif (event.time === time) {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t}, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._timeline = [];\n\t\treturn this;\n\t}\n}\n","///////////////////////////////////////////////////////////////////////////\n// INITIALIZING NEW CONTEXT\n///////////////////////////////////////////////////////////////////////////\n\ntype Context = import(\"./Context\").Context;\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyNewContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to setup a new Context\n */\nexport function onContextInit(cb: (ctx: Context) => void): void {\n\tnotifyNewContext.push(cb);\n}\n\n/**\n * Invoke any classes which need to also be initialized when a new context is created.\n */\nexport function initializeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyNewContext.forEach(cb => cb(ctx));\n}\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyCloseContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to tear down a Context\n */\nexport function onContextClose(cb: (ctx: Context) => void): void {\n\tnotifyCloseContext.push(cb);\n}\n\nexport function closeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyCloseContext.forEach(cb => cb(ctx));\n}\n","import { Ticker, TickerClockSource } from \"../clock/Ticker\";\nimport { Seconds } from \"../type/Units\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { Omit } from \"../util/Interface\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isString } from \"../util/TypeCheck\";\nimport { AnyAudioContext, getAudioContext } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\ntype Destination = import(\"./Destination\").Destination;\n\nexport type ContextLatencyHint = AudioContextLatencyCategory | \"fastest\";\n\n// these are either not used in Tone.js or deprecated and not implemented.\nexport type ExcludedFromBaseAudioContext = \"onstatechange\" | \"addEventListener\" |\n\t\"removeEventListener\" | \"listener\" | \"dispatchEvent\" | \"audioWorklet\" | \"destination\" | \"createScriptProcessor\";\n\t// \"createMediaStreamSource\" | \"createMediaElementSource\" | \"createMediaStreamTrackSource\" |\n\t// \"baseLatency\" | \"suspend\" |\n\n// the subset of the BaseAudioContext which Tone.Context implements.\nexport type BaseAudioContextSubset = Omit<BaseAudioContext, ExcludedFromBaseAudioContext>;\n\nexport interface ContextOptions {\n\tclockSource: TickerClockSource;\n\tlatencyHint: ContextLatencyHint;\n\tlookAhead: Seconds;\n\tupdateInterval: Seconds;\n\tcontext: AnyAudioContext;\n}\n\nexport interface ContextTimeoutEvent {\n\tcallback: (...args: any[]) => void;\n\tid: number;\n\ttime: Seconds;\n}\n\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\nexport class Context extends Emitter<\"statechange\" | \"tick\"> implements BaseAudioContextSubset {\n\n\tname = \"Context\";\n\n\t/**\n\t * The amount of time into the future events are scheduled. Giving Web Audio\n\t * a short amount of time into the future to schedule events can reduce clicks and\n\t * improve performance. This value can be set to 0 to get the lowest latency.\n\t */\n\tlookAhead: Seconds;\n\n\t/**\n\t * private reference to the BaseAudioContext\n\t */\n\tprotected readonly _context: AnyAudioContext;\n\n\t/**\n\t * A reliable callback method\n\t */\n\tprivate readonly _ticker: Ticker;\n\n\t/**\n\t *  The default latency hint\n\t */\n\tprivate _latencyHint: ContextLatencyHint | Seconds;\n\n\t/**\n\t *  An object containing all of the constants AudioBufferSourceNodes\n\t */\n\tprivate _constants = new Map<number, AudioBufferSourceNode>();\n\n\t/**\n\t *  All of the setTimeout events.\n\t */\n\tprivate _timeouts: Timeline<ContextTimeoutEvent> = new Timeline();\n\n\t/**\n\t *  The timeout id counter\n\t */\n\tprivate _timeoutIds = 0;\n\n\t/**\n\t * A reference the Transport singleton belonging to this context\n\t */\n\tprivate _transport!: Transport;\n\n\t/**\n\t * A reference the Destination singleton belonging to this context\n\t */\n\tprivate _destination!: Destination;\n\n\t/**\n\t * Private indicator if the context has been initialized\n\t */\n\tprivate _initialized: boolean = false;\n\n\tconstructor(context?: AnyAudioContext);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<ContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n\n\t\tthis._context = options.context;\n\n\t\tthis._latencyHint = options.latencyHint;\n\t\tthis.lookAhead = options.lookAhead;\n\n\t\tthis._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n\t\tthis.on(\"tick\", this._timeoutLoop.bind(this));\n\n\t\t// fwd events from the context\n\t\tthis._context.addEventListener(\"statechange\", () => {\n\t\t\tthis.emit(\"statechange\", this.state);\n\t\t});\n\t}\n\n\tstatic getDefaults(): ContextOptions {\n\t\treturn {\n\t\t\tclockSource: \"worker\",\n\t\t\tcontext: getAudioContext(),\n\t\t\tlatencyHint: \"interactive\",\n\t\t\tlookAhead: 0.1,\n\t\t\tupdateInterval: 0.03,\n\t\t};\n\t}\n\n\t/**\n\t * Finish setting up the context. **You usually do not need to do this manually.**\n\t */\n\tinitialize(): this {\n\t\tif (!this._initialized) {\n\t\t\t// add any additional modules\n\t\t\tinitializeContext(this);\n\t\t\tthis._initialized = true;\n\t\t}\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// BASE AUDIO CONTEXT METHODS\n\t///////////////////////////////////////////////////////////////////////\n\n\tcreateAnalyser(): AnalyserNode {\n\t\treturn this._context.createAnalyser();\n\t}\n\tcreateOscillator(): OscillatorNode {\n\t\treturn this._context.createOscillator();\n\t}\n\tcreateBufferSource(): AudioBufferSourceNode {\n\t\treturn this._context.createBufferSource();\n\t}\n\tcreateBiquadFilter(): BiquadFilterNode {\n\t\treturn this._context.createBiquadFilter();\n\t}\n\tcreateBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer {\n\t\treturn this._context.createBuffer(numberOfChannels, length, sampleRate);\n\t}\n\tcreateChannelMerger(numberOfInputs?: number | undefined): ChannelMergerNode {\n\t\treturn this._context.createChannelMerger(numberOfInputs);\n\t}\n\tcreateChannelSplitter(numberOfOutputs?: number | undefined): ChannelSplitterNode {\n\t\treturn this._context.createChannelSplitter(numberOfOutputs);\n\t}\n\tcreateConstantSource(): ConstantSourceNode {\n\t\treturn this._context.createConstantSource();\n\t}\n\tcreateConvolver(): ConvolverNode {\n\t\treturn this._context.createConvolver();\n\t}\n\tcreateDelay(maxDelayTime?: number | undefined): DelayNode {\n\t\treturn this._context.createDelay(maxDelayTime);\n\t}\n\tcreateDynamicsCompressor(): DynamicsCompressorNode {\n\t\treturn this._context.createDynamicsCompressor();\n\t}\n\tcreateGain(): GainNode {\n\t\treturn this._context.createGain();\n\t}\n\tcreateIIRFilter(feedforward: number[], feedback: number[]): IIRFilterNode {\n\t\treturn this._context.createIIRFilter(feedforward, feedback);\n\t}\n\tcreatePanner(): PannerNode {\n\t\treturn this._context.createPanner();\n\t}\n\tcreatePeriodicWave(\n\t\treal: number[] | Float32Array,\n\t\timag: number[] | Float32Array,\n\t\tconstraints?: PeriodicWaveConstraints | undefined,\n\t): PeriodicWave {\n\t\treturn this._context.createPeriodicWave(real, imag, constraints);\n\t}\n\tcreateStereoPanner(): StereoPannerNode {\n\t\treturn this._context.createStereoPanner();\n\t}\n\tcreateWaveShaper(): WaveShaperNode {\n\t\treturn this._context.createWaveShaper();\n\t}\n\tdecodeAudioData(audioData: ArrayBuffer): Promise<AudioBuffer> {\n\t\treturn this._context.decodeAudioData(audioData);\n\t}\n\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._context.currentTime;\n\t}\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget state(): AudioContextState {\n\t\treturn this._context.state;\n\t}\n\t/**\n\t *  The current time in seconds of the AudioContext.\n\t */\n\tget sampleRate(): number {\n\t\treturn this._context.sampleRate;\n\t}\n\t/**\n\t *  The listener\n\t */\n\tget listener(): AudioListener {\n\t\treturn this._context.listener;\n\t}\n\n\t/**\n\t *  There is only one Transport per Context. It is created on initialization.\n\t */\n\tget transport(): Transport {\n\t\tthis.assert(this._initialized, \"The context must be initialized before being used by invoking context.initialize()\");\n\t\treturn this._transport;\n\t}\n\tset transport(t: Transport) {\n\t\tthis.assert(!this._initialized, \"The transport cannot be set after initialization.\");\n\t\tthis._transport = t;\n\t}\n\n\t/**\n\t *  A reference to the Context's destination node.\n\t */\n\tget destination(): Destination {\n\t\tthis.assert(this._initialized, \"The context must be initialized before being used by invoking context.initialize()\");\n\t\treturn this._destination;\n\t}\n\tset destination(d: Destination) {\n\t\tthis.assert(!this._initialized, \"The transport cannot be set after initialization.\");\n\t\tthis._destination = d;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// TICKER\n\t///////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  How often the interval callback is invoked.\n\t *  This number corresponds to how responsive the scheduling\n\t *  can be. context.updateInterval + context.lookAhead gives you the\n\t *  total latency between scheduling an event and hearing it.\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._ticker.updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._ticker.updateInterval = interval;\n\t}\n\n\t/**\n\t *  What the source of the clock is, either \"worker\" (default),\n\t *  \"timeout\", or \"offline\" (none).\n\t */\n\tget clockSource(): TickerClockSource {\n\t\treturn this._ticker.type;\n\t}\n\tset clockSource(type: TickerClockSource) {\n\t\tthis._ticker.type = type;\n\t}\n\n\t/**\n\t * The type of playback, which affects tradeoffs between audio\n\t * output latency and responsiveness.\n\t * In addition to setting the value in seconds, the latencyHint also\n\t * accepts the strings \"interactive\" (prioritizes low latency),\n\t * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n\t * latency and performance), and \"fastest\" (lowest latency, might glitch more often).\n\t * @example\n\t * //set the lookAhead to 0.3 seconds\n\t * Tone.context.latencyHint = 0.3;\n\t */\n\tget latencyHint(): ContextLatencyHint | Seconds {\n\t\treturn this._latencyHint;\n\t}\n\tset latencyHint(hint: ContextLatencyHint | Seconds) {\n\t\tlet lookAheadValue = 0;\n\t\tthis._latencyHint = hint;\n\t\tif (isString(hint)) {\n\t\t\tswitch (hint) {\n\t\t\t\tcase \"interactive\":\n\t\t\t\t\tlookAheadValue = 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"playback\":\n\t\t\t\t\tlookAheadValue = 0.8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"balanced\":\n\t\t\t\t\tlookAheadValue = 0.25;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"fastest\":\n\t\t\t\t\tlookAheadValue = 0.01;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.lookAhead = lookAheadValue;\n\t\tthis.updateInterval = lookAheadValue / 3;\n\t}\n\n\t/**\n\t *  The unwrapped AudioContext.\n\t */\n\tget rawContext(): AnyAudioContext {\n\t\treturn this._context;\n\t}\n\n\t/**\n\t * The current audio context time plus a short {@link lookAhead}.\n\t */\n\tnow(): Seconds {\n\t\treturn this._context.currentTime + this.lookAhead;\n\t}\n\n\t/**\n\t *  Starts the audio context from a suspended state. This is required\n\t *  to initially start the AudioContext.\n\t */\n\tresume(): Promise<void> {\n\t\tif (this._context.state === \"suspended\" && isAudioContext(this._context)) {\n\t\t\treturn this._context.resume();\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t *  Promise which is invoked when the context is running.\n\t *  Tries to resume the context if it's not started.\n\t */\n\tasync close(): Promise<void> {\n\t\tif (isAudioContext(this._context)) {\n\t\t\tawait this._context.close();\n\t\t}\n\t\tif (this._initialized) {\n\t\t\tcloseContext(this);\n\t\t}\n\t}\n\n\t/**\n\t *  Generate a looped buffer at some constant value.\n\t */\n\tgetConstant(val: number): AudioBufferSourceNode {\n\t\tif (this._constants.has(val)) {\n\t\t\treturn this._constants.get(val) as AudioBufferSourceNode;\n\t\t} else {\n\t\t\tconst buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\t\t\tconst arr = buffer.getChannelData(0);\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = val;\n\t\t\t}\n\t\t\tconst constant = this._context.createBufferSource();\n\t\t\tconstant.channelCount = 1;\n\t\t\tconstant.channelCountMode = \"explicit\";\n\t\t\tconstant.buffer = buffer;\n\t\t\tconstant.loop = true;\n\t\t\tconstant.start(0);\n\t\t\tthis._constants.set(val, constant);\n\t\t\treturn constant;\n\t\t}\n\t}\n\n\t/**\n\t *  Clean up. Also closes the audio context.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._ticker.dispose();\n\t\tthis._timeouts.dispose();\n\t\tObject.keys(this._constants).map(val => this._constants[val].disconnect());\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// TIMEOUTS\n\t///////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  The private loop which keeps track of the context scheduled timeouts\n\t *  Is invoked from the clock source\n\t */\n\tprivate _timeoutLoop(): void  {\n\t\tconst now = this.now();\n\t\tlet firstEvent = this._timeouts.peek();\n\t\twhile (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n\t\t\t// invoke the callback\n\t\t\tfirstEvent.callback();\n\t\t\t// shift the first event off\n\t\t\tthis._timeouts.shift();\n\t\t\t// get the next one\n\t\t\tfirstEvent = this._timeouts.peek();\n\t\t}\n\t}\n\n\t/**\n\t *  A setTimeout which is guarented by the clock source.\n\t *  Also runs in the offline context.\n\t * @param  fn       The callback to invoke\n\t * @param  timeout  The timeout in seconds\n\t * @returns ID to use when invoking Context.clearTimeout\n\t */\n\tsetTimeout(fn: (...args: any[]) => void, timeout: Seconds): number {\n\t\tthis._timeoutIds++;\n\t\tconst now = this.now();\n\t\tthis._timeouts.add({\n\t\t\tcallback : fn,\n\t\t\tid : this._timeoutIds,\n\t\t\ttime : now + timeout,\n\t\t});\n\t\treturn this._timeoutIds;\n\t}\n\n\t/**\n\t *  Clears a previously scheduled timeout with Tone.context.setTimeout\n\t * @param  id  The ID returned from setTimeout\n\t */\n\tclearTimeout(id: number): Context {\n\t\tthis._timeouts.forEach(event => {\n\t\t\tif (event.id === id) {\n\t\t\t\tthis._timeouts.remove(event);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n","import { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { Seconds } from \"../type/Units\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\n\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n */\nexport class OfflineContext extends Context {\n\n\tname = \"OfflineContext\";\n\n\t/**\n\t *  A private reference to the duration\n\t */\n\tprivate readonly _duration: Seconds;\n\n\t/**\n\t *  An artificial clock source\n\t */\n\tprivate _currentTime: Seconds = 0;\n\n\t/**\n\t * Private reference to the OfflineAudioContext.\n\t */\n\tprotected _context!: OfflineAudioContext;\n\n\t/**\n\t * @param  channels  The number of channels to render\n\t * @param  duration  The duration to render in seconds\n\t * @param sampleRate the sample rate to render at\n\t */\n\tconstructor(\n\t\tchannels: number,\n\t\tduration: Seconds, sampleRate: number,\n\t);\n\tconstructor(context: OfflineAudioContext);\n\tconstructor() {\n\n\t\tsuper({\n\t\t\tclockSource: \"offline\",\n\t\t\tcontext: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\targuments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n\t\t\tlookAhead: 0,\n\t\t\tupdateInterval: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\t\t128 / arguments[0].sampleRate : 128 / arguments[2],\n\t\t});\n\n\t\tthis._duration = isOfflineAudioContext(arguments[0]) ?\n\t\t\targuments[0].length / arguments[0].sampleRate : arguments[1];\n\t}\n\n\t/**\n\t *  Override the now method to point to the internal clock time\n\t */\n\tnow(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Same as this.now()\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t *  Render the output of the OfflineContext\n\t */\n\trender(): Promise<AudioBuffer> {\n\t\twhile (this._duration - this._currentTime >= 0) {\n\t\t\t// invoke all the callbacks on that time\n\t\t\tthis.emit(\"tick\");\n\t\t\t// increment the clock in 5ms chunks\n\t\t\tthis._currentTime += 128 / this.sampleRate;\n\t\t}\n\n\t\treturn this._context.startRendering();\n\t}\n\n\t/**\n\t *  Close the context\n\t */\n\tclose(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n}\n","import { version } from \"../version\";\nimport { hasAudioContext, theWindow } from \"./context/AudioContext\";\nimport { Context } from \"./context/Context\";\nimport { OfflineContext } from \"./context/OfflineContext\";\nimport { isAudioContext, isOfflineAudioContext } from \"./util/AdvancedTypeCheck\";\n\n/**\n * This dummy context is used to avoid throwing immediate errors when importing in Node.js\n */\nconst dummyContext: Context = {\n\tdestination: {},\n\ttransport: {},\n} as Context;\n\n/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext: Context = dummyContext;\n\n/**\n * Returns the default system-wide AudioContext\n */\nexport function getContext(): Context {\n\tif (globalContext === dummyContext && hasAudioContext) {\n\t\tsetContext(new Context());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n */\nexport function setContext(context: Context | AudioContext | OfflineAudioContext): void {\n\tif (isAudioContext(context)) {\n\t\tglobalContext = new Context(context);\n\t} else if (isOfflineAudioContext(context)) {\n\t\tglobalContext = new OfflineContext(context);\n\t} else {\n\t\tglobalContext = context;\n\t}\n\tglobalContext.initialize();\n}\n\n/**\n * Most browsers will not play _any_ audio until a user\n * clicks something (like a play button). Invoke this method\n * on a click or keypress event handler to start the audio context.\n * More about the Autoplay policy\n * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n * @example\n * document.querySelector('#playbutton').addEventListener('click', () => Tone.start())\n */\nexport function start(): Promise <void> {\n\treturn globalContext.resume();\n}\n\n/**\n * Log Tone.js + version in the console.\n */\nif (theWindow && !theWindow.TONE_SILENCE_LOGGING) {\n\tlet prefix = \"v\";\n\tif (version === \"dev\") {\n\t\tprefix = \"\";\n\t}\n\tconst printString = ` * Tone.js ${prefix}${version} * `;\n\t// tslint:disable-next-line: no-console\n\tconsole.log(`%c${printString}`, \"background: #000; color: #fff\");\n}\n","import { Decibels, GainFactor, Hertz, Interval, MidiNote, NormalRange } from \"./Units\";\n\n/**\n *  Equal power gain scale. Good for cross-fading.\n * @param  percent (0-1)\n */\nexport function equalPowerScale(percent: NormalRange): number {\n\tconst piFactor = 0.5 * Math.PI;\n\treturn Math.sin(percent * piFactor);\n}\n\n/**\n *  Convert decibels into gain.\n */\nexport function dbToGain(db: Decibels): GainFactor {\n\treturn Math.pow(10, db / 20);\n}\n\n/**\n *  Convert gain to decibels.\n */\nexport function gainToDb(gain: GainFactor): Decibels {\n\treturn 20 * (Math.log(gain) / Math.LN10);\n}\n\n/**\n * Convert an interval (in semitones) to a frequency ratio.\n * @param interval the number of semitones above the base note\n * @example\n * tone.intervalToFrequencyRatio(0); // 1\n * tone.intervalToFrequencyRatio(12); // 2\n * tone.intervalToFrequencyRatio(-12); // 0.5\n */\nexport function intervalToFrequencyRatio(interval: Interval): number {\n\treturn Math.pow(2, (interval / 12));\n}\n\n/**\n * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n * to generate all the other pitch values from notes. A4's values in Hertz.\n */\nlet A4: Hertz = 440;\n\nexport function getA4(): Hertz {\n\treturn A4;\n}\n\nexport function setA4(freq: Hertz): void {\n\tA4 = freq;\n}\n\n/**\n * Convert a frequency value to a MIDI note.\n * @param frequency The value to frequency value to convert.\n * @example\n * ftom(440); // returns 69\n */\nexport function ftom(frequency: Hertz): MidiNote {\n\treturn Math.round(ftomf(frequency)) as MidiNote;\n}\n\n/**\n * Convert a frequency to a floating point midi value\n */\nexport function ftomf(frequency: Hertz): number {\n\treturn 69 + 12 * Math.log2(frequency / A4);\n}\n\n/**\n * Convert a MIDI note to frequency value.\n * @param  midi The midi number to convert.\n * @return The corresponding frequency value\n * @example\n */\nexport function mtof(midi: MidiNote): Hertz {\n\treturn A4 * Math.pow(2, (midi - 69) / 12);\n}\n","import { Context } from \"../context/Context\";\nimport { Tone } from \"../Tone\";\nimport { isDefined, isObject , isString, isUndef } from \"../util/TypeCheck\";\nimport { BPM, Hertz, MidiNote, Milliseconds, Samples, Seconds, Ticks, Time } from \"./Units\";\n\nexport type TimeValue = Time | TimeBaseClass<any, any>;\n\n/**\n * The units that the TimeBase can accept. extended by other classes\n */\nexport type TimeBaseUnit = \"s\" | \"n\" | \"t\" | \"m\" | \"i\" | \"hz\" | \"tr\" | \"samples\" | \"number\";\n\nexport interface TypeFunction {\n\tregexp: RegExp;\n\tmethod: (value: string, ...args: string[]) => number;\n}\n\nexport interface TimeExpression<Type extends number> {\n\t[key: string]: {\n\t\tregexp: RegExp;\n\t\tmethod: (value: string, ...args: string[]) => Type;\n\t};\n}\n\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n * @example\n * new TimeBase(4, \"n\")\n * new TimeBase(2, \"t\")\n * new TimeBase(\"2t\")\n * new TimeBase({\"2t\" : 2})\n * new TimeBase(\"2t\") + new TimeBase(\"4n\");\n * @category Unit\n */\nexport abstract class TimeBaseClass<Type extends number, Unit extends string> extends Tone {\n\n\treadonly context: Context;\n\n\t/**\n\t * The value of the units\n\t */\n\tprotected _val?: TimeValue;\n\n\t/**\n\t * The units of time\n\t */\n\tprotected _units?: Unit;\n\n\t/**\n\t * All of the conversion expressions\n\t */\n\tprotected _expressions: TimeExpression<Type>;\n\n\t/**\n\t * The default units\n\t */\n\treadonly defaultUnits: Unit = \"s\" as Unit;\n\n\t/**\n\t * @param context The context associated with the time value. Used to compute\n\t * Transport and context-relative timing.\n\t * @param  value  The time value as a number, string or object\n\t * @param  units  Unit values\n\t */\n\tconstructor(context: Context, value?: TimeValue, units?: Unit) {\n\t\tsuper();\n\n\t\tthis._val = value;\n\t\tthis._units = units;\n\t\tthis.context = context;\n\t\tthis._expressions = this._getExpressions();\n\t}\n\n\t/**\n\t * All of the time encoding expressions\n\t */\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn {\n\t\t\thz: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._frequencyToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n\t\t\t},\n\t\t\ti: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._ticksToUnits(parseInt(value, 10));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)i$/i,\n\t\t\t},\n\t\t\tm: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)m$/i,\n\t\t\t},\n\t\t\tn: {\n\t\t\t\tmethod: (value, dot) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\tconst scalar = dot === \".\" ? 1.5 : 1;\n\t\t\t\t\tif (numericValue === 1) {\n\t\t\t\t\t\treturn this._beatsToUnits(this._getTimeSignature()) * scalar as Type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this._beatsToUnits(4 / numericValue) * scalar as Type;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)n(\\.?)$/i,\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._expressions[this.defaultUnits].method.call(this, value);\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)$/,\n\t\t\t},\n\t\t\ts: {\n\t\t\t\tmethod: (value): Type => {\n\t\t\t\t\treturn this._secondsToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)s$/,\n\t\t\t},\n\t\t\tsamples: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn parseInt(value, 10) / this.context.sampleRate as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)samples$/,\n\t\t\t},\n\t\t\tt: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\treturn this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)t$/i,\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tmethod: (m, q, s) => {\n\t\t\t\t\tlet total = 0;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n\t\t\t},\n\t\t};\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tVALUE OF\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Evaluate the time value. Returns the time in seconds.\n\t */\n\tvalueOf(): Type {\n\t\tif (this._val instanceof TimeBaseClass) {\n\t\t\tthis.fromType(this._val);\n\t\t}\n\t\tif (isUndef(this._val)) {\n\t\t\treturn this._noArg();\n\t\t} else if (isString(this._val) && isUndef(this._units)) {\n\t\t\tfor (const units in this._expressions) {\n\t\t\t\tif (this._expressions[units].regexp.test(this._val.trim())) {\n\t\t\t\t\tthis._units = units as Unit;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(this._val)) {\n\t\t\tlet total = 0;\n\t\t\tfor (const typeName in this._val) {\n\t\t\t\tif (isDefined(this._val[typeName])) {\n\t\t\t\t\tconst quantity = this._val[typeName];\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst time = (new this.constructor(this.context, typeName)).valueOf() * quantity;\n\t\t\t\t\ttotal += time;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn total as Type;\n\t\t}\n\t\tif (isDefined(this._units)) {\n\t\t\tconst expr = this._expressions[this._units];\n\t\t\tconst matching = this._val.toString().trim().match(expr.regexp);\n\t\t\tif (matching) {\n\t\t\t\treturn expr.method.apply(this, matching.slice(1));\n\t\t\t} else {\n\t\t\t\treturn expr.method.call(this, this._val);\n\t\t\t}\n\t\t} else if (isString(this._val)) {\n\t\t\treturn parseFloat(this._val) as Type;\n\t\t} else {\n\t\t\treturn this._val as Type;\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn 1 / freq as Type;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn (60 / this._getBpm()) * beats as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn seconds as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn (ticks * (this._beatsToUnits(1)) / this._getPPQ()) as Type;\n\t}\n\n\t/**\n\t *  With no arguments, return 'now'\n\t */\n\tprotected _noArg(): Type {\n\t\treturn this._now();\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tTEMPO CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Return the bpm\n\t */\n\tprotected _getBpm(): BPM {\n\t\treturn this.context.transport.bpm.value;\n\t}\n\n\t/**\n\t * Return the timeSignature\n\t */\n\tprotected _getTimeSignature(): number {\n\t\treturn this.context.transport.timeSignature as number;\n\t}\n\n\t/**\n\t * Return the PPQ or 192 if Transport is not available\n\t */\n\tprotected _getPPQ(): number {\n\t\treturn this.context.transport.PPQ;\n\t}\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected abstract _now(): Type;\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tCONVERSION INTERFACE\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Coerce a time type into this units type.\n\t * @param type Any time type units\n\t */\n\tfromType(type: TimeBaseClass<any, any>): this {\n\t\tthis._units = undefined;\n\t\tswitch (this.defaultUnits) {\n\t\t\tcase \"s\":\n\t\t\t\tthis._val = type.toSeconds();\n\t\t\t\tbreak;\n\t\t\tcase \"i\":\n\t\t\t\tthis._val = type.toTicks();\n\t\t\t\tbreak;\n\t\t\tcase \"hz\":\n\t\t\t\tthis._val = type.toFrequency();\n\t\t\t\tbreak;\n\t\t\tcase \"midi\":\n\t\t\t\tthis._val = type.toMidi();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Return the value in seconds\n\t */\n\tabstract toSeconds(): Seconds;\n\n\t/**\n\t *  Return the value as a Midi note\n\t */\n\tabstract toMidi(): MidiNote;\n\n\t/**\n\t * Convert the value into ticks\n\t */\n\tabstract toTicks(): Ticks;\n\n\t/**\n\t *  Return the value in hertz\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn 1 / this.toSeconds();\n\t}\n\n\t/**\n\t *  Return the time in samples\n\t */\n\ttoSamples(): Samples {\n\t\treturn this.toSeconds() * this.context.sampleRate;\n\t}\n\n\t/**\n\t *  Return the time in milliseconds.\n\t */\n\ttoMilliseconds(): Milliseconds {\n\t\treturn this.toSeconds() * 1000;\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass, TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\nimport { BarsBeatsSixteenths, MidiNote, Seconds, Subdivision, Ticks, Time } from \"./Units\";\n\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * var t = Time(\"4n\");//a quarter note\n * @category Unit\n */\nexport class TimeClass<Type extends Seconds | Ticks = Seconds, Unit extends string = TimeBaseUnit>\nextends TimeBaseClass<Type, Unit> {\n\n\tname = \"Time\";\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign(super._getExpressions(), {\n\t\t\tnow: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\treturn this._now() + new (this.constructor as typeof TimeClass)(this.context, capture).valueOf() as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^\\+(.+)/,\n\t\t\t},\n\t\t\tquantize: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\tconst quantTo = new TimeClass(this.context, capture).valueOf();\n\t\t\t\t\treturn this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n\t\t\t\t},\n\t\t\t\tregexp: /^@(.+)/,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Quantize the time by the given subdivision. Optionally add a\n\t * percentage which will move the time value towards the ideal\n\t * quantized value by that percentage.\n\t * @param  val    The subdivision to quantize to\n\t * @param  percent  Move the time value towards the quantized value by a percentage.\n\t * @example\n\t * Time(21).quantize(2) //returns 22\n\t * Time(0.6).quantize(\"4n\", 0.5) //returns 0.55\n\t */\n\tquantize(subdiv: Time, percent = 1): Type {\n\t\tconst subdivision = new (this.constructor as typeof TimeClass)(this.context, subdiv).valueOf();\n\t\tconst value = this.valueOf();\n\t\tconst multiple = Math.round(value / subdivision);\n\t\tconst ideal = multiple * subdivision;\n\t\tconst diff = ideal - value;\n\t\treturn value + diff * percent as Type;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\t/**\n\t *  Convert a Time to Notation. The notation values are will be the\n\t *  closest representation between 1m to 128th note.\n\t * @return {Notation}\n\t * @example\n\t * //if the Transport is at 120bpm:\n\t * Time(2).toNotation();//returns \"1m\"\n\t */\n\ttoNotation(): Subdivision {\n\t\tconst time = this.toSeconds();\n\t\tconst testNotations: Subdivision[] = [\"1m\"];\n\t\tfor (let power = 1; power < 9; power++) {\n\t\t\tconst subdiv = Math.pow(2, power);\n\t\t\ttestNotations.push(subdiv + \"n.\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"n\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"t\" as Subdivision);\n\t\t}\n\t\ttestNotations.push(\"0\");\n\t\t// find the closets notation representation\n\t\tlet closest = testNotations[0];\n\t\tlet closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n\t\ttestNotations.forEach(notation => {\n\t\t\tconst notationSeconds = new TimeClass(this.context, notation).toSeconds();\n\t\t\tif (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n\t\t\t\tclosest = notation;\n\t\t\t\tclosestSeconds = notationSeconds;\n\t\t\t}\n\t\t});\n\t\treturn closest;\n\t}\n\n\t/**\n\t *  Return the time encoded as Bars:Beats:Sixteenths.\n\t */\n\ttoBarsBeatsSixteenths(): BarsBeatsSixteenths {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tlet quarters = this.valueOf() / quarterTime;\n\t\tquarters = parseFloat(quarters.toFixed(4));\n\t\tconst measures = Math.floor(quarters / this._getTimeSignature());\n\t\tlet sixteenths = (quarters % 1) * 4;\n\t\tquarters = Math.floor(quarters) % this._getTimeSignature();\n\t\tconst sixteenthString = sixteenths.toString();\n\t\tif (sixteenthString.length > 3) {\n\t\t\t// the additional parseFloat removes insignificant trailing zeroes\n\t\t\tsixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n\t\t}\n\t\tconst progress = [measures, quarters, sixteenths];\n\t\treturn progress.join(\":\");\n\t}\n\n\t/**\n\t *  Return the time in ticks.\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.round(quarters * this._getPPQ());\n\t}\n\n\t/**\n\t *  Return the time in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t *  Return the value as a midi note.\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.toFrequency());\n\t}\n\n\tprotected _now(): Type {\n\t\treturn this.context.now() as Type;\n\t}\n}\n\n/**\n * Create a TimeClass from a time string or number.\n * @param value A value which reprsents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n */\nexport function Time(value?: TimeValue, units?: TimeBaseUnit): TimeClass<Seconds> {\n\treturn new TimeClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { intervalToFrequencyRatio, mtof } from \"./Conversions\";\nimport { ftom, getA4, setA4 } from \"./Conversions\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseClass, TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\nimport { Frequency, Hertz, Interval, MidiNote, Note, Seconds, Ticks } from \"./Units\";\n\nexport type FrequencyUnit = TimeBaseUnit | \"midi\";\n\n/**\n * Frequency is a primitive type for encoding Frequency values.\n * Eventually all time values are evaluated to hertz using the `eval` method.\n * @example\n * Frequency(\"C3\") // 261\n * Frequency(38, \"midi\") //\n * Frequency(\"C3\").transpose(4);\n * @category Unit\n */\nexport class FrequencyClass<Type extends number = Hertz> extends TimeClass<Type, FrequencyUnit> {\n\n\tname = \"Frequency\";\n\n\treadonly defaultUnits: FrequencyUnit = \"hz\";\n\n\t/**\n\t * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n\t * to generate all the other pitch values from notes. A4's values in Hertz.\n\t */\n\tstatic get A4(): Hertz {\n\t\treturn getA4();\n\t}\n\tstatic set A4(freq: Hertz) {\n\t\tsetA4(freq);\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tAUGMENT BASE EXPRESSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign({}, super._getExpressions(), {\n\t\t\tmidi : {\n\t\t\t\tregexp : /^(\\d+(?:\\.\\d+)?midi)/,\n\t\t\t\tmethod(value): number {\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\tnote : {\n\t\t\t\tregexp : /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n\t\t\t\tmethod(pitch, octave): number {\n\t\t\t\t\tconst index = noteToScaleIndex[pitch.toLowerCase()];\n\t\t\t\t\tconst noteNumber = index + (parseInt(octave, 10) + 1) * 12;\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn noteNumber;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(noteNumber);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\ttr : {\n\t\t\t\tregexp : /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\t\t\t\tmethod(m, q, s): number {\n\t\t\t\t\tlet total = 1;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total;\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tEXPRESSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Transposes the frequency by the given number of semitones.\n\t * @return  A new transposed frequency\n\t * @example\n\t * Frequency(\"A4\").transpose(3); //\"C5\"\n\t */\n\ttranspose(interval: Interval): FrequencyClass {\n\t\treturn new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));\n\t}\n\n\t/**\n\t * Takes an array of semitone intervals and returns\n\t * an array of frequencies transposed by those intervals.\n\t * @return  Returns an array of Frequencies\n\t * @example\n\t * Frequency(\"A4\").harmonize([0, 3, 7]); //[\"A4\", \"C5\", \"E5\"]\n\t */\n\tharmonize(intervals: Interval[]): FrequencyClass[] {\n\t\treturn intervals.map(interval => {\n\t\t\treturn this.transpose(interval);\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @example\n\t * Frequency(\"C4\").toMidi(); //60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.valueOf());\n\t}\n\n\t/**\n\t * Return the value of the frequency in Scientific Pitch Notation\n\t * @example\n\t * Frequency(69, \"midi\").toNote(); //\"A4\"\n\t */\n\ttoNote(): Note {\n\t\tconst freq = this.toFrequency();\n\t\tconst log = Math.log2(freq / FrequencyClass.A4);\n\t\tlet noteNumber = Math.round(12 * log) + 57;\n\t\tconst octave = Math.floor(noteNumber / 12);\n\t\tif (octave < 0) {\n\t\t\tnoteNumber += -12 * octave;\n\t\t}\n\t\tconst noteName = scaleIndexToNote[noteNumber % 12];\n\t\treturn noteName + octave.toString() as Note;\n\t}\n\n\t/**\n\t *  Return the duration of one cycle in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn 1 / super.toSeconds();\n\t}\n\n\t/**\n\t *  Return the duration of one cycle in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.floor(quarters * this._getPPQ());\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tUNIT CONVERSIONS HELPERS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  With no arguments, return 0\n\t */\n\tprotected _noArg(): Type {\n\t\treturn 0 as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn freq as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn 1 / ((ticks * 60) / (this._getBpm() * this._getPPQ())) as Type;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn 1 / super._beatsToUnits(beats) as Type;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn 1 / seconds as Type;\n\t}\n\n\t/**\n\t * Convert a MIDI note to frequency value.\n\t * @param  midi The midi number to convert.\n\t * @return The corresponding frequency value\n\t * @example\n\t * FrequencyClass.mtof(69); // returns 440\n\t */\n\tstatic mtof(midi: MidiNote): Hertz {\n\t\treturn mtof(midi);\n\t}\n\n\t/**\n\t * Convert a frequency value to a MIDI note.\n\t * @param frequency The value to frequency value to convert.\n\t * @example\n\t * Frequency.ftom(440); // returns 69\n\t */\n\tstatic ftom(frequency: Hertz): MidiNote {\n\t\treturn ftom(frequency);\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tFREQUENCY CONVERSIONS\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Note to scale index\n */\nconst noteToScaleIndex = {\n\t// tslint:disable-next-line\n\t\"cbb\" : -2, \"cb\" : -1, \"c\" : 0, \"c#\" : 1, \"cx\" : 2,\n\t\"dbb\" : 0, \"db\" : 1, \"d\" : 2, \"d#\" : 3, \"dx\" : 4,\n\t\"ebb\" : 2, \"eb\" : 3, \"e\" : 4, \"e#\" : 5, \"ex\" : 6,\n\t\"fbb\" : 3, \"fb\" : 4, \"f\" : 5, \"f#\" : 6, \"fx\" : 7,\n\t\"gbb\" : 5, \"gb\" : 6, \"g\" : 7, \"g#\" : 8, \"gx\" : 9,\n\t\"abb\" : 7, \"ab\" : 8, \"a\" : 9, \"a#\" : 10, \"ax\" : 11,\n\t\"bbb\" : 9, \"bb\" : 10, \"b\" : 11, \"b#\" : 12, \"bx\" : 13,\n};\n\n/**\n *  scale index to note (sharps)\n */\nconst scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n */\nexport function Frequency(value?: TimeValue | Frequency, units?: FrequencyUnit): FrequencyClass {\n\treturn new FrequencyClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { Seconds, Ticks } from \"../type/Units\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport class TransportTimeClass<Type extends Seconds | Ticks = Seconds> extends TimeClass<Type> {\n\n\tname = \"TransportTime\";\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected _now(): Type {\n\t\treturn this.context.transport.seconds as Type;\n\t}\n}\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to [[Time]], but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport function TransportTime(value?: TimeValue, units?: TimeBaseUnit): TransportTimeClass {\n\treturn new TransportTimeClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { FrequencyClass } from \"../type/Frequency\";\nimport { TimeClass } from \"../type/Time\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { getDefaultsFromInstance, omitFromObject, optionsFromArguments } from \"../util/Defaults\";\nimport { RecursivePartial } from \"../util/Interface\";\nimport { isArray, isBoolean, isDefined, isNumber, isString, isUndef } from \"../util/TypeCheck\";\nimport { Context } from \"./Context\";\n\n/**\n * A unit which process audio\n */\nexport interface ToneWithContextOptions {\n\tcontext: Context;\n}\n\n/**\n * The Base class for all nodes that have an AudioContext.\n * @category Core\n */\nexport abstract class ToneWithContext<Options extends ToneWithContextOptions> extends Tone {\n\n\t/**\n\t * The context belonging to the node.\n\t */\n\treadonly context: Context;\n\n\t/**\n\t * The default context to use if no AudioContext is passed in to the constructor.\n\t * Probably should not be set manually. Used internally.\n\t * @hidden\n\t */\n\treadonly defaultContext?: Context;\n\n\tconstructor(context?: Context | Partial<ToneWithContextOptions>) {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(ToneWithContext.getDefaults(), arguments, [\"context\"]);\n\t\tif (this.defaultContext) {\n\t\t\tthis.context = this.defaultContext;\n\t\t} else {\n\t\t\tthis.context = options.context;\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneWithContextOptions {\n\t\treturn {\n\t\t\tcontext: getContext(),\n\t\t};\n\t}\n\n\t/**\n\t * Return the current time of the Context clock plus the lookAhead.\n\t */\n\tnow(): Seconds {\n\t\treturn this.context.currentTime + this.context.lookAhead;\n\t}\n\n\t/**\n\t * Return the current time of the Context clock without any lookAhead.\n\t */\n\timmediate(): Seconds {\n\t\treturn this.context.currentTime;\n\t}\n\n\t/**\n\t * The duration in seconds of one sample.\n\t */\n\tget sampleTime(): Seconds {\n\t\treturn 1 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * The number of seconds of 1 processing block (128 samples)\n\t */\n\tget blockTime(): Seconds {\n\t\treturn 128 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * Convert the incoming time to seconds\n\t */\n\ttoSeconds(time?: Time): Seconds {\n\t\treturn new TimeClass(this.context, time).toSeconds();\n\t}\n\n\t/**\n\t * Convert the input to a frequency number\n\t */\n\ttoFrequency(freq: Frequency): Hertz {\n\t\treturn new FrequencyClass(this.context, freq).toFrequency();\n\t}\n\n\t/**\n\t * Convert the input time into ticks\n\t */\n\ttoTicks(time?: Time | TimeClass): Ticks {\n\t\treturn new TransportTimeClass(this.context, time).toTicks();\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tGET/SET\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Get the object's attributes.\n\t * @example\n\t * osc.get();\n\t * //returns {\"type\" : \"sine\", \"frequency\" : 440, ...etc}\n\t */\n\tget(): Options {\n\t\tconst defaults = getDefaultsFromInstance(this) as Options;\n\t\tObject.keys(defaults).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute)) {\n\t\t\t\tconst member = this[attribute];\n\t\t\t\tif (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {\n\t\t\t\t\tdefaults[attribute] = member.value;\n\t\t\t\t} else if (member instanceof ToneWithContext) {\n\t\t\t\t\tdefaults[attribute] = member.get();\n\t\t\t\t// otherwise make sure it's a serializable type\n\t\t\t\t} else if (isArray(member) || isNumber(member) || isString(member) || isBoolean(member)) {\n\t\t\t\t\tdefaults[attribute] = member;\n\t\t\t\t} else {\n\t\t\t\t\t// remove all undefined and unserializable attributes\n\t\t\t\t\tdelete defaults[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn defaults;\n\t}\n\n\t/**\n\t * Set the parameters at once. Either pass in an\n\t * object mapping parameters to values, or to set a\n\t * single parameter, by passing in a string and value.\n\t * The last argument is an optional ramp time which\n\t * will ramp any signal values to their destination value\n\t * over the duration of the rampTime.\n\t * @param  params\n\t * @example\n\t * //set values using an object\n\t * filter.set({\n\t * \t\"frequency\" : 300,\n\t * \t\"type\" : \"highpass\"\n\t * });\n\t */\n\tset(props: RecursivePartial<Options>): this {\n\t\tObject.keys(props).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute) && isDefined(this[attribute])) {\n\t\t\t\tif (this[attribute] && isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {\n\t\t\t\t\t// small optimization\n\t\t\t\t\tif (this[attribute].value !== props[attribute]) {\n\t\t\t\t\t\tthis[attribute].value = props[attribute];\n\t\t\t\t\t}\n\t\t\t\t} else if (this[attribute] instanceof ToneWithContext) {\n\t\t\t\t\tthis[attribute].set(props[attribute]);\n\t\t\t\t} else {\n\t\t\t\t\tthis[attribute] = props[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n","import { AbstractParam } from \"../context/AbstractParam\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { AudioRange, Decibels, Frequency, NormalRange, Positive, Time, Unit, UnitName } from \"../type/Units\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\n\nexport interface ParamOptions extends ToneWithContextOptions {\n\tunits: UnitName;\n\tvalue?: any;\n\tparam: AudioParam;\n\tconvert: boolean;\n}\n\n/**\n * the possible automation types\n */\ntype AutomationType = \"linear\" | \"exponential\" | \"setValue\" | \"setTarget\" | \"cancel\";\n\n/**\n * The events on the automation\n */\nexport interface AutomationEvent {\n\ttype: AutomationType;\n\ttime: number;\n\tvalue: number;\n\tconstant?: number;\n}\n\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\nexport class Param<Type extends Unit = number>\nextends ToneWithContext<ParamOptions>\nimplements AbstractParam<Type> {\n\n\treadonly name: string = \"Param\";\n\n\tstatic getDefaults(): ParamOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t} as ParamOptions);\n\t}\n\n\t/**\n\t * The input connection\n\t */\n\treadonly input: AudioParam;\n\treadonly units: UnitName;\n\tconvert: boolean;\n\toverridden: boolean = false;\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<AutomationEvent>;\n\n\t/**\n\t *  The native parameter to control\n\t */\n\tprotected _param: AudioParam;\n\n\t/**\n\t *  The default value before anything is assigned\n\t */\n\tprotected _initialValue: number;\n\n\t/**\n\t *  The minimum output value\n\t */\n\tprivate _minOutput = 1e-7;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\tconstructor(param: AudioParam, units?: Unit, convert?: boolean);\n\tconstructor(options: Partial<ParamOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n\n\t\tconst options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n\n\t\tthis.assert(isDefined(options.param) && isAudioParam(options.param), \"param must be an AudioParam\");\n\n\t\t// initialize\n\t\tthis._param = this.input = options.param;\n\t\tthis._events = new Timeline<AutomationEvent>(1000);\n\t\tthis._initialValue = this._param.defaultValue;\n\t\tthis.units = options.units;\n\t\tthis.convert = options.convert;\n\n\t\t// if the value is defined, set it immediately\n\t\tif (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n\t\t\tthis.setValueAtTime(options.value, 0);\n\t\t}\n\t}\n\n\tget value(): Type {\n\t\tconst now = this.now();\n\t\treturn this.getValueAtTime(now);\n\t}\n\tset value(value: Type) {\n\t\tthis._initialValue = this._fromType(value);\n\t\tthis.cancelScheduledValues(this.now());\n\t\tthis.setValueAtTime(value, this.now());\n\t}\n\n\tget minValue(): number {\n\t\tif (this.units === \"time\" || this.units === \"frequency\" ||\n\t\t\tthis.units === \"normalRange\" || this.units === \"positive\" ||\n\t\t\tthis.units === \"transportTime\" || this.units === \"ticks\" ||\n\t\t\tthis.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n\t\t\treturn 0;\n\t\t} else if (this.units === \"audioRange\") {\n\t\t\treturn -1;\n\t\t} else if (this.units === \"decibels\") {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn this._param.minValue;\n\t\t}\n\t}\n\n\tget maxValue(): number {\n\t\tif (this.units === \"normalRange\" ||\n\t\t\tthis.units === \"audioRange\") {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn this._param.maxValue;\n\t\t}\n\t}\n\n\t/**\n\t * Type guard based on the unit name\n\t */\n\tprivate _is<T>(arg: any, type: UnitName): arg is T {\n\t\treturn this.units === type;\n\t}\n\n\t/**\n\t *  Convert the given value from the type specified by Param.units\n\t *  into the destination value (such as Gain or Frequency).\n\t */\n\tprotected _fromType(val: Type): number {\n\t\tif (this.convert && !this.overridden) {\n\t\t\tif (this._is<Time>(val, \"time\")) {\n\t\t\t\treturn this.toSeconds(val);\n\t\t\t} else if (this._is<Decibels>(val, \"decibels\")) {\n\t\t\t\treturn dbToGain(val);\n\t\t\t} else if (this._is<Frequency>(val, \"frequency\")) {\n\t\t\t\treturn this.toFrequency(val);\n\t\t\t} else if (this._is<NormalRange>(val, \"normalRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, 0), 1);\n\t\t\t} else if (this._is<AudioRange>(val, \"audioRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, -1), 1);\n\t\t\t} else if (this._is<Positive>(val, \"positive\")) {\n\t\t\t\treturn Math.max(val, 0);\n\t\t\t} else if (this._is<number>(val, \"number\")) {\n\t\t\t\treturn val;\n\t\t\t} else {\n\t\t\t\treturn val as number;\n\t\t\t}\n\t\t} else {\n\t\t\treturn val as number;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the parameters value into the units specified by Param.units.\n\t */\n\tprotected _toType(val: number): Type {\n\t\tif (this.convert && this.units === \"decibels\") {\n\t\t\treturn gainToDb(val) as Type;\n\t\t} else {\n\t\t\treturn val as Type;\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// ABSTRACT PARAM INTERFACE\n\t// all docs are generated from ParamInterface.ts\n\t///////////////////////////////////////////////////////////////////////////\n\n\tsetValueAtTime(value: Type, time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst numericValue = this._fromType(value);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n\n\t\tthis.log(this.units, \"setValue\", value, computedTime);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValue\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis._param.setValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\tgetValueAtTime(time: Time): Type {\n\t\tconst computedTime = Math.max(this.toSeconds(time), 0);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tconst before = this._events.get(computedTime);\n\t\tlet value = this._initialValue;\n\t\t// if it was set by\n\t\tif (before === null) {\n\t\t\tvalue = this._initialValue;\n\t\t} else if (before.type === \"setTarget\" && (after === null || after.type === \"setValue\")) {\n\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\tlet previousVal;\n\t\t\tif (previous === null) {\n\t\t\t\tpreviousVal = this._initialValue;\n\t\t\t} else {\n\t\t\t\tpreviousVal = previous.value;\n\t\t\t}\n\t\t\tif (isDefined(before.constant)) {\n\t\t\t\tvalue = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n\t\t\t}\n\t\t} else if (after === null) {\n\t\t\tvalue = before.value;\n\t\t} else if (after.type === \"linear\" || after.type === \"exponential\") {\n\t\t\tlet beforeValue = before.value;\n\t\t\tif (before.type === \"setTarget\") {\n\t\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\t\tif (previous === null) {\n\t\t\t\t\tbeforeValue = this._initialValue;\n\t\t\t\t} else {\n\t\t\t\t\tbeforeValue = previous.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (after.type === \"linear\") {\n\t\t\t\tvalue = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t} else {\n\t\t\t\tvalue = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = before.value;\n\t\t}\n\t\treturn this._toType(value);\n\t}\n\n\tsetRampPoint(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tlet currentVal = this.getValueAtTime(time);\n\t\tthis.cancelAndHoldAtTime(time);\n\t\tif (this._fromType(currentVal) === 0) {\n\t\t\tcurrentVal = this._toType(this._minOutput);\n\t\t}\n\t\tthis.setValueAtTime(currentVal, time);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: Type, endTime: Time): this {\n\t\tconst numericValue = this._fromType(value);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"linear\",\n\t\t\tvalue : numericValue,\n\t\t});\n\t\tthis.log(this.units, \"linear\", value, computedTime);\n\t\tthis._param.linearRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: Type, endTime: Time): this {\n\t\tlet numericValue = this._fromType(value);\n\t\tnumericValue = Math.max(this._minOutput, numericValue);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\t// store the event\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"exponential\",\n\t\t\tvalue : numericValue,\n\t\t});\n\t\tthis.log(this.units, \"exponential\", value, computedTime);\n\t\tthis._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\tlinearRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialApproachValueAtTime(value, startTime, rampTime);\n\t\treturn this;\n\t}\n\n\texponentialApproachValueAtTime(value: Type, time: Time, rampTime: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\trampTime = this.toSeconds(rampTime);\n\t\tconst timeConstant = Math.log(rampTime + 1) / Math.log(200);\n\t\tthis.setTargetAtTime(value, time, timeConstant);\n\t\t// at 90% start a linear ramp to the final value\n\t\tthis.cancelAndHoldAtTime(time + rampTime * 0.9);\n\t\tthis.linearRampToValueAtTime(value, time + rampTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(value: Type, startTime: Time, timeConstant: Positive): this {\n\t\tconst numericValue = this._fromType(value);\n\t\t// The value will never be able to approach without timeConstant > 0.\n\t\tthis.assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n\t\tconst computedTime = this.toSeconds(startTime);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n\t\tthis._events.add({\n\t\t\tconstant: timeConstant,\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setTarget\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"setTarget\", value, computedTime, timeConstant);\n\t\tthis._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: Type[], startTime: Time, duration: Time, scaling: number = 1): this {\n\t\tduration = this.toSeconds(duration);\n\t\tstartTime = this.toSeconds(startTime);\n\t\tconst startingValue = this._fromType(values[0]) * scaling;\n\t\tthis.setValueAtTime(this._toType(startingValue), startTime);\n\t\tconst segTime = duration / (values.length - 1);\n\t\tfor (let i = 1; i < values.length; i++) {\n\t\t\tconst numericValue = this._fromType(values[i]) * scaling;\n\t\t\tthis.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n\t\tthis._events.cancel(computedTime);\n\t\tthis._param.cancelScheduledValues(computedTime);\n\t\tthis.log(this.units, \"cancel\", computedTime);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n\t\t// remove the schedule events\n\t\tthis.assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n\n\t\tthis.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n\n\t\tthis._param.cancelScheduledValues(computedTime);\n\n\t\t// if there is an event at the given computedTime\n\t\t// and that even is not a \"set\"\n\t\tconst before = this._events.get(computedTime);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tif (before && before.time === computedTime) {\n\t\t\t// remove everything after\n\t\t\tif (after) {\n\t\t\t\tthis._events.cancel(after.time);\n\t\t\t} else {\n\t\t\t\tthis._events.cancel(computedTime + this.sampleTime);\n\t\t\t}\n\t\t} else if (after) {\n\t\t\t// cancel the next event(s)\n\t\t\tthis._events.cancel(after.time);\n\t\t\tif (after.type === \"linear\") {\n\t\t\t\tthis.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t} else if (after.type === \"exponential\") {\n\t\t\t\tthis.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t}\n\t\t}\n\n\t\t// set the value at the given time\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValue\",\n\t\t\tvalue: valueAtTime,\n\t\t});\n\t\tthis._param.setValueAtTime(valueAtTime, computedTime);\n\t\treturn this;\n\t}\n\n\trampTo(value: Type, rampTime: Time = 0.1, startTime?: Time): this {\n\t\tif (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n\t\t\tthis.exponentialRampTo(value, rampTime, startTime);\n\t\t} else {\n\t\t\tthis.linearRampTo(value, rampTime, startTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// \tAUTOMATION CURVE CALCULATIONS\n\t// \tMIT License, copyright (c) 2014 Jordan Santell\n\t///////////////////////////////////////////////////////////////////////////\n\n\t// Calculates the the value along the curve produced by setTargetAtTime\n\tprotected _exponentialApproach(t0: number, v0: number, v1: number, timeConstant: number, t: number): number {\n\t\treturn v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t}\n\n\t// Calculates the the value along the curve produced by linearRampToValueAtTime\n\tprotected _linearInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t}\n\n\t// Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\tprotected _exponentialInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t}\n}\n","import { Unit } from \"../type/Units\";\nimport { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { assert } from \"../util/Debug\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\n\nexport type InputNode = ToneAudioNode | AudioNode |  Param<Unit> | AudioParam;\nexport type OutputNode = ToneAudioNode | AudioNode;\n\ninterface ChannelProperties {\n\tchannelCount: number;\n\tchannelCountMode: ChannelCountMode;\n\tchannelInterpretation: ChannelInterpretation;\n}\n\n/**\n * The possible options for this node\n */\nexport type ToneAudioNodeOptions = ToneWithContextOptions;\n\n/**\n * ToneAudioNode is the base class for classes which process audio.\n * @category Core\n */\nexport abstract class ToneAudioNode<Options extends ToneAudioNodeOptions = ToneAudioNodeOptions>\nextends ToneWithContext<Options> {\n\n\tabstract name = \"AudioNode\";\n\n\t/**\n\t * The input node or nodes. If the object is a source,\n\t * it does not have any input and this.input is undefined.\n\t */\n\tabstract input: InputNode | undefined;\n\n\t/**\n\t * The output nodes. If the object is a sink,\n\t * it does not have any output and this.output is undefined.\n\t */\n\tabstract output: OutputNode | undefined;\n\n\t/**\n\t *  The number of inputs feeding into the AudioNode.\n\t *  For source nodes, this will be 0.\n\t */\n\tget numberOfInputs(): number {\n\t\tif (isDefined(this.input)) {\n\t\t\tif (isAudioParam(this.input) || this.input instanceof Param) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn this.input.numberOfInputs;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t *  The number of outputs of the AudioNode.\n\t */\n\tget numberOfOutputs(): number {\n\t\tif (isDefined(this.output)) {\n\t\t\treturn this.output.numberOfOutputs;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * List all of the node that must be set to match the ChannelProperties\n\t */\n\tprotected _internalChannels: OutputNode[] = [];\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// AUDIO PROPERTIES\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Used to decide which nodes to get/set properties on\n\t */\n\tprivate _isAudioNode(node: any): node is AudioNode | ToneAudioNode {\n\t\treturn isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n\t}\n\n\t/**\n\t * Get all of the audio nodes (either internal or input/output) which together\n\t * make up how the class node responds to channel input/output\n\t */\n\tprivate _getInternalNodes(): OutputNode[] {\n\t\tconst nodeList = this._internalChannels.slice(0);\n\t\tif (this._isAudioNode(this.input)) {\n\t\t\tnodeList.push(this.input);\n\t\t}\n\t\tif (this._isAudioNode(this.output)) {\n\t\t\tif (this.input !== this.output) {\n\t\t\t\tnodeList.push(this.output);\n\t\t\t}\n\t\t}\n\t\treturn nodeList;\n\t}\n\n\t/**\n\t * Set the audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t * @param options\n\t */\n\tprivate _setChannelProperties(options: ChannelProperties): void {\n\t\tconst nodeList = this._getInternalNodes();\n\t\tnodeList.forEach(node => {\n\t\t\tnode.channelCount = options.channelCount;\n\t\t\tnode.channelCountMode = options.channelCountMode;\n\t\t\tnode.channelInterpretation = options.channelInterpretation;\n\t\t});\n\t}\n\n\t/**\n\t * Get the current audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t */\n\tprivate _getChannelProperties(): ChannelProperties {\n\t\tconst nodeList = this._getInternalNodes();\n\t\tthis.assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\");\n\t\t// use the first node to get properties\n\t\t// they should all be the same\n\t\tconst node = nodeList[0];\n\t\treturn {\n\t\t\tchannelCount: node.channelCount,\n\t\t\tchannelCountMode: node.channelCountMode,\n\t\t\tchannelInterpretation: node.channelInterpretation,\n\t\t};\n\t}\n\n\t/**\n\t *  channelCount is the number of channels used when up-mixing and down-mixing\n\t *  connections to any inputs to the node. The default value is 2 except for\n\t *  specific nodes where its value is specially determined.\n\t */\n\tget channelCount(): number {\n\t\treturn this._getChannelProperties().channelCount;\n\t}\n\tset channelCount(channelCount) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCount }));\n\t}\n\n\t// tslint:disable: max-line-length\n\t/**\n\t *  channelCountMode determines how channels will be counted when up-mixing and\n\t *  down-mixing connections to any inputs to the node.\n\t *  The default value is \"max\". This attribute has no effect for nodes with no inputs.\n\t * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n\t * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n\t * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n\t */\n\t// tslint:enable: max-line-length\n\tget channelCountMode(): ChannelCountMode {\n\t\treturn this._getChannelProperties().channelCountMode;\n\t}\n\tset channelCountMode(channelCountMode) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCountMode }));\n\t}\n\n\t/**\n\t *  channelInterpretation determines how individual channels will be treated\n\t *  when up-mixing and down-mixing connections to any inputs to the node.\n\t *  The default value is \"speakers\".\n\t */\n\tget channelInterpretation(): ChannelInterpretation {\n\t\treturn this._getChannelProperties().channelInterpretation;\n\t}\n\tset channelInterpretation(channelInterpretation) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelInterpretation }));\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// CONNECTIONS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n\t * @param unit The output to connect to\n\t * @param outputNum The output to connect from\n\t * @param inputNum The input to connect to\n\t */\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t */\n\ttoDestination(): this {\n\t\tthis.connect(this.context.destination);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t * alias for {@link toDestination}\n\t * @deprecated\n\t */\n\ttoMaster(): this {\n\t\tconsole.warn(\"toMaster() has been renamed toDestination()\");\n\t\treturn this.toDestination();\n\t}\n\n\t/**\n\t *  disconnect the output\n\t * @param output Either the output index to disconnect if the output is an array, or the node to disconnect from.\n\t */\n\tdisconnect(destination?: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tdisconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Connect the output of this node to the rest of the nodes in series.\n\t * @example\n\t *  //connect a node to an effect, panVol and then to the master output\n\t *  node.chain(effect, panVol, Tone.Destination);\n\t */\n\tchain(...nodes: InputNode[]): this {\n\t\tconnectSeries(this, ...nodes);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  connect the output of this node to the rest of the nodes in parallel.\n\t */\n\tfan(...nodes: InputNode[]): this {\n\t\tnodes.forEach(node => this.connect(node));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Dispose and disconnect\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (isDefined(this.input)) {\n\t\t\tif (this.input instanceof ToneAudioNode) {\n\t\t\t\tthis.input.dispose();\n\t\t\t} else if (isAudioNode(this.input)) {\n\t\t\t\tthis.input.disconnect();\n\t\t\t}\n\t\t}\n\t\tif (isDefined(this.output)) {\n\t\t\tif (this.output instanceof ToneAudioNode) {\n\t\t\t\tthis.output.dispose();\n\t\t\t} else if (isAudioNode(this.output)) {\n\t\t\t\tthis.output.disconnect();\n\t\t\t}\n\t\t}\n\t\tthis._internalChannels = [];\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// CONNECTIONS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n *  connect together all of the arguments in series\n * @param nodes\n */\nexport function connectSeries(...nodes: InputNode[]): void {\n\tconst first = nodes.shift();\n\tnodes.reduce((prev, current) => {\n\t\tif (prev instanceof ToneAudioNode) {\n\t\t\tprev.connect(current);\n\t\t} else if (isAudioNode(prev)) {\n\t\t\tconnect(prev, current);\n\t\t}\n\t\treturn current;\n\t}, first);\n}\n\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(srcNode: OutputNode, dstNode: InputNode, outputNumber = 0, inputNumber = 0): void {\n\n\tassert(isDefined(srcNode), \"Cannot connect from undefined node\");\n\tassert(isDefined(dstNode), \"Cannot connect to undefined node\");\n\n\tif (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n\t\tassert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n\t}\n\tassert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\");\n\n\t// resolve the input of the dstNode\n\twhile (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {\n\t\tif (isDefined(dstNode.input)) {\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t}\n\n\twhile (srcNode instanceof ToneAudioNode) {\n\t\tif (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t}\n\n\t// make the connection\n\tif (isAudioParam(dstNode)) {\n\t\tsrcNode.connect(dstNode as AudioParam, outputNumber);\n\t} else {\n\t\tsrcNode.connect(dstNode, outputNumber, inputNumber);\n\t}\n}\n\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(\n\tsrcNode: OutputNode,\n\tdstNode?: InputNode,\n\toutputNumber = 0,\n\tinputNumber = 0,\n): void {\n\n\t// resolve the destination node\n\tif (isDefined(dstNode)) {\n\t\twhile (dstNode instanceof ToneAudioNode) {\n\t\t\tif (dstNode.input) {\n\t\t\t\tdstNode = dstNode.input;\n\t\t\t}\n\t\t}\n\t}\n\n\t// resolve the src node\n\twhile (!(isAudioNode(srcNode))) {\n\t\tif (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t}\n\n\tif (isAudioParam(dstNode)) {\n\t\tsrcNode.disconnect(dstNode as AudioParam, outputNumber);\n\t} else if (isAudioNode(dstNode)) {\n\t\tsrcNode.disconnect(dstNode, outputNumber, inputNumber);\n\t} else {\n\t\tsrcNode.disconnect();\n\t}\n}\n","import { isArray } from \"./TypeCheck\";\n\n// return an interface which excludes certain keys\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n/**\n *  Make the property not writable using `defineProperty`. Internal use only.\n */\nexport function readOnly(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => readOnly(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\tenumerable: true,\n\t\t\twritable: false,\n\t\t});\n\t}\n}\n\n/**\n *  Make an attribute writeable. Internal use only.\n */\nexport function writable(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => writable(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\twritable: true,\n\t\t});\n\t}\n}\n\nexport const noOp: (...args: any[]) => any = () => {\n\t// no op!\n};\n\n/**\n * Recursive Partial taken from here: https://stackoverflow.com/a/51365037\n */\nexport type RecursivePartial<T> = {\n\t[P in keyof T]?:\n\tT[P] extends Array<infer U> ? Array<RecursivePartial<U>> :\n\tT[P] extends object ? RecursivePartial<T[P]> :\n\tT[P];\n};\n","import { Param } from \"../context/Param\";\nimport { GainFactor, Unit, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface GainOptions extends ToneAudioNodeOptions {\n\tgain: number;\n\tunits: UnitName;\n\tconvert: boolean;\n}\n\n/**\n * A thin wrapper around the Native Web Audio GainNode.\n * The GainNode is a basic building block of the Web Audio\n * API and is useful for routing audio and adjusting gains.\n * @category Core\n */\nexport class Gain<Type extends Unit = GainFactor> extends ToneAudioNode<GainOptions> {\n\n\treadonly name = \"Gain\";\n\n\t/**\n\t *  The gain parameter of the gain node.\n\t */\n\treadonly gain: Param<Type>;\n\n\t/**\n\t * The wrapped GainNode.\n\t */\n\tprivate _gainNode: GainNode = this.context.createGain();\n\n\t// input = output\n\treadonly input: GainNode = this._gainNode;\n\treadonly output: GainNode = this._gainNode;\n\n\t/**\n\t * @param  gain The initial gain of the GainNode\n\t * @param units The units of the gain parameter.\n\t */\n\tconstructor(gain?: GainFactor, units?: Unit);\n\tconstructor(options?: Partial<GainOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]));\n\t\tconst options = optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]);\n\n\t\tthis.gain = new Param({\n\t\t\tcontext : this.context,\n\t\t\tconvert : options.convert,\n\t\t\tparam : this._gainNode.gain,\n\t\t\tunits : options.units,\n\t\t\tvalue : options.gain,\n\t\t});\n\t\treadOnly(this, \"gain\");\n\t}\n\n\tstatic getDefaults(): GainOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert : true,\n\t\t\tgain : 1,\n\t\t\tunits : \"gain\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { Samples, Seconds, Time } from \"../type/Units\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\n\ninterface ToneAudioBufferOptions {\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n\treverse: boolean;\n\tonload: (buffer?: ToneAudioBuffer) => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n *\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n * @example\n * var buffer = new ToneAudioBuffer(\"path/to/sound.mp3\", function(){\n * \t//the buffer is now available.\n * \tvar buff = buffer.get();\n * });\n * @example\n * //can load provide fallback extension types if the first type is not supported.\n * var buffer = new ToneAudioBuffer(\"path/to/sound.[mp3|ogg|wav]\");\n * @category Core\n */\nexport class ToneAudioBuffer extends Tone {\n\n\tname = \"ToneAudioBuffer\";\n\n\t/**\n\t *  stores the loaded AudioBuffer\n\t */\n\tprivate _buffer?: AudioBuffer;\n\n\t/**\n\t *  indicates if the buffer should be reversed or not\n\t */\n\tprivate _reversed!: boolean;\n\n\t/**\n\t * Callback when the buffer is loaded.\n\t */\n\tonload: (buffer: ToneAudioBuffer) => void = noOp;\n\n\t/**\n\t *\n\t * @param url The url to load, or the audio buffer to set.\n\t * @param onload A callback which is invoked after the buffer is loaded.\n\t *                            It's recommended to use `ToneAudioBuffer.on('load', callback)` instead\n\t *                            since it will give you a callback when _all_ buffers are loaded.\n\t * @param onerror The callback to invoke if there is an error\n\t */\n\tconstructor(\n\t\turl?: string | ToneAudioBuffer | AudioBuffer,\n\t\tonload?: (buffer: ToneAudioBuffer) => void,\n\t\tonerror?: (error: Error) => void,\n\t);\n\tconstructor(options?: Partial<ToneAudioBufferOptions>);\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tconst options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n\n\t\tthis.reverse = options.reverse;\n\t\tthis.onload = options.onload;\n\n\t\tif (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n\t\t\tthis.set(options.url);\n\t\t} else if (isString(options.url)) {\n\t\t\t// initiate the download\n\t\t\tthis.load(options.url).catch(options.onerror);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneAudioBufferOptions {\n\t\treturn {\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\treverse: false,\n\t\t};\n\t}\n\n\t/**\n\t * The sample rate of the AudioBuffer\n\t */\n\tget sampleRate(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.sampleRate;\n\t\t} else {\n\t\t\treturn getContext().sampleRate;\n\t\t}\n\t}\n\n\t/**\n\t *  Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n\t */\n\tset(buffer: AudioBuffer | ToneAudioBuffer): this {\n\t\tif (buffer instanceof ToneAudioBuffer) {\n\t\t\t// if it's loaded, set it\n\t\t\tif (buffer.loaded) {\n\t\t\t\tthis._buffer = buffer.get();\n\t\t\t} else {\n\t\t\t\t// otherwise when it's loaded, invoke it's callback\n\t\t\t\tbuffer.onload = () => {\n\t\t\t\t\tthis.set(buffer);\n\t\t\t\t\tthis.onload(this);\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tthis._buffer = buffer;\n\t\t}\n\t\t// reverse it initially\n\t\tif (this._reversed) {\n\t\t\tthis._reverse();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The audio buffer stored in the object.\n\t */\n\tget(): AudioBuffer | undefined {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t *  Makes an fetch request for the selected url then decodes the file as an audio buffer.\n\t * \tInvokes the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t * @returns A Promise which resolves with this ToneAudioBuffer\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tconst promise = ToneAudioBuffer.load(url);\n\t\tToneAudioBuffer.downloads.push(promise);\n\t\ttry {\n\t\t\tconst audioBuffer = await promise;\n\t\t\tthis.set(audioBuffer);\n\t\t\t// invoke the onload method\n\t\t\tthis.onload(this);\n\t\t} catch (e) {\n\t\t\t// remove the failed file before throwing error\n\t\t\tconst index = ToneAudioBuffer.downloads.indexOf(promise);\n\t\t\tToneAudioBuffer.downloads.splice(index, 1);\n\t\t\tthrow e;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the audio buffer from the array.\n\t * To create a multichannel AudioBuffer, pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t */\n\tfromArray(array: Float32Array | Float32Array[]): this {\n\t\tconst isMultidimensional = isArray(array) && array[0].length > 0;\n\t\tconst channels = isMultidimensional ? array.length : 1;\n\t\tconst len = isMultidimensional ? (array[0] as Float32Array).length : array.length;\n\t\tconst context = getContext();\n\t\tconst buffer = context.createBuffer(channels, len, context.sampleRate);\n\t\tconst multiChannelArray: Float32Array[] = !isMultidimensional && channels === 1 ?\n\t\t\t[array as Float32Array] : array as Float32Array[];\n\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\tbuffer.copyToChannel(multiChannelArray[c], c);\n\t\t}\n\t\tthis._buffer = buffer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * \tSums multiple channels into 1 channel\n\t * @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoMono(chanNum?: number): this {\n\t\tif (isNumber(chanNum)) {\n\t\t\tthis.fromArray(this.toArray(chanNum));\n\t\t} else {\n\t\t\tlet outputArray = new Float32Array(this.length as number);\n\t\t\tconst numChannels = this.numberOfChannels;\n\t\t\tfor (let channel = 0; channel < numChannels; channel++) {\n\t\t\t\tconst channelArray = this.toArray(channel) as Float32Array;\n\t\t\t\tfor (let i = 0; i < channelArray.length; i++) {\n\t\t\t\t\toutputArray[i] += channelArray[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// divide by the number of channels\n\t\t\toutputArray = outputArray.map(sample => sample / numChannels);\n\t\t\tthis.fromArray(outputArray);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * \tGet the buffer as an array. Single channel buffers will return a 1-dimensional\n\t * \tFloat32Array, and multichannel buffers will return multidimensional arrays.\n\t * @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoArray(channel?: number): Float32Array | Float32Array[] {\n\t\tif (isNumber(channel)) {\n\t\t\treturn this.getChannelData(channel);\n\t\t} else if (this.numberOfChannels === 1) {\n\t\t\treturn this.toArray(0);\n\t\t} else {\n\t\t\tconst ret: Float32Array[] = [];\n\t\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\t\tret[c] = this.getChannelData(c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t *  Returns the Float32Array representing the PCM audio data for the specific channel.\n\t * @param  channel  The channel number to return\n\t * @return The audio as a TypedArray\n\t */\n\tgetChannelData(channel: number): Float32Array {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.getChannelData(channel);\n\t\t} else {\n\t\t\treturn new Float32Array(0);\n\t\t}\n\t}\n\n\t/**\n\t *  Cut a subsection of the array and return a buffer of the\n\t *  subsection. Does not modify the original buffer\n\t * @param start The time to start the slice\n\t * @param end The end time to slice. If none is given will default to the end of the buffer\n\t */\n\tslice(start: Seconds, end: Seconds = this.duration): ToneAudioBuffer {\n\t\tconst startSamples = Math.floor(start * this.sampleRate);\n\t\tconst endSamples = Math.floor(end * this.sampleRate);\n\t\tthis.assert(startSamples < endSamples, \"The start time must be less than the end time\");\n\t\tconst length = endSamples - startSamples;\n\t\tconst retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\t\tfor (let channel = 0; channel < this.numberOfChannels; channel++) {\n\t\t\tretBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n\t\t}\n\t\treturn new ToneAudioBuffer(retBuffer);\n\t}\n\n\t/**\n\t *  Reverse the buffer.\n\t */\n\tprivate _reverse(): this {\n\t\tif (this.loaded) {\n\t\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\t\tthis.getChannelData(i).reverse();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffer is loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this.length > 0;\n\t}\n\n\t/**\n\t * The duration of the buffer in seconds.\n\t */\n\tget duration(): Seconds {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.duration;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The length of the buffer in samples\n\t */\n\tget length(): Samples {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n\t */\n\tget numberOfChannels(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.numberOfChannels;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tget reverse(): boolean {\n\t\treturn this._reversed;\n\t}\n\tset reverse(rev: boolean) {\n\t\tif (this._reversed !== rev) {\n\t\t\tthis._reversed = rev;\n\t\t\tthis._reverse();\n\t\t}\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// STATIC METHODS\n\t///////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  A path which is prefixed before every url.\n\t */\n\tstatic baseUrl = \"\";\n\n\t/**\n\t *  Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n\t *  pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t * @return A ToneAudioBuffer created from the array\n\t */\n\tstatic fromArray(array: Float32Array | Float32Array[]): ToneAudioBuffer {\n\t\treturn (new ToneAudioBuffer()).fromArray(array);\n\t}\n\n\t/**\n\t * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n\t * @param  url The url to load.\n\t * @return A promise which resolves to a ToneAudioBuffer\n\t */\n\tstatic async fromUrl(url: string): Promise<ToneAudioBuffer> {\n\t\tconst buffer = new ToneAudioBuffer();\n\t\treturn await buffer.load(url);\n\t}\n\n\t/**\n\t * All of the downloads\n\t */\n\tstatic downloads: Array<Promise<AudioBuffer>> = [];\n\n\t/**\n\t *  Loads a url using fetch and returns the AudioBuffer.\n\t */\n\tstatic async load(url: string): Promise<AudioBuffer> {\n\n\t\t// test if the url contains multiple extensions\n\t\tconst matches = url.match(/\\[(.+\\|?)+\\]$/);\n\t\tif (matches) {\n\t\t\tconst extensions = matches[1].split(\"|\");\n\t\t\tlet extension = extensions[0];\n\t\t\tfor (const ext of extensions) {\n\t\t\t\tif (ToneAudioBuffer.supportsType(ext)) {\n\t\t\t\t\textension = ext;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\turl = url.replace(matches[0], extension);\n\t\t}\n\n\t\tconst response = await fetch(ToneAudioBuffer.baseUrl + url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`could not load url: ${url}`);\n\t\t}\n\t\tconst arrayBuffer = await response.arrayBuffer();\n\n\t\tconst audioBuffer = await getContext().decodeAudioData(arrayBuffer);\n\n\t\treturn audioBuffer;\n\t}\n\n\t/**\n\t *  Checks a url's extension to see if the current browser can play that file type.\n\t * @param url The url/extension to test\n\t * @return If the file extension can be played\n\t * @static\n\t * @example\n\t * ToneAudioBuffer.supportsType(\"wav\"); //returns true\n\t * ToneAudioBuffer.supportsType(\"path/to/file.wav\"); //returns true\n\t */\n\tstatic supportsType(url: string): boolean {\n\t\tconst extensions = url.split(\".\");\n\t\tconst extension = extensions[extensions.length - 1];\n\t\tconst response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n\t\treturn response !== \"\";\n\t}\n\n\t/**\n\t *  Returns a Promise which resolves when all of the buffers have loaded\n\t */\n\tstatic async loaded(): Promise<void> {\n\t\tfor (const promise of ToneAudioBuffer.downloads) {\n\t\t\tawait promise;\n\t\t}\n\t}\n}\n","import { getContext, setContext } from \"../Global\";\nimport { Seconds } from \"../type/Units\";\nimport { OfflineContext } from \"./OfflineContext\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of Tone.Transport which can be used\n * to schedule events along the Transport. **NOTE** OfflineAudioContext has the same restrictions\n * as the AudioContext in that on certain platforms (like iOS) it must be invoked by an explicit\n * user action like a click or tap.\n * @param  callback  All Tone.js nodes which are created and scheduled\n * \t\t\t\t\twithin this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the Tone.Buffer of the recorded output.\n * @example\n * //render 2 seconds of the oscillator\n * Tone.Offline(function(){\n * \t//only nodes created in this callback will be recorded\n * \tvar oscillator = new Tone.Oscillator().toDestination().start(0)\n * \t//schedule their events\n * }, 2).then(function(buffer){\n * \t//do something with the output buffer\n * })\n * @example\n * //can also schedule events along the Transport\n * //using the passed in Offline Transport\n * Tone.Offline(function(Transport){\n * \tvar osc = new Tone.Oscillator().toDestination()\n * \tTransport.schedule(function(time){\n * \t\tosc.start(time).stop(time + 0.1)\n * \t}, 1)\n * \tTransport.start(0.2)\n * }, 4).then(function(buffer){\n * \t//do something with the output buffer\n * })\n * @category Core\n */\nexport async function Offline(\n\tcallback: (context: OfflineContext) => Promise<void> | void,\n\tduration: Seconds,\n\tchannels: number = 2,\n\tsampleRate: number = getContext().sampleRate,\n): Promise<ToneAudioBuffer> {\n\t// set the OfflineAudioContext based on the current context\n\tconst originalContext = getContext();\n\n\tconst context = new OfflineContext(channels, duration, sampleRate);\n\tsetContext(context);\n\n\t// invoke the callback/scheduling\n\tawait callback(context);\n\n\t// then render the audio\n\tconst bufferPromise = context.render();\n\n\t// return the original AudioContext\n\tsetContext(originalContext);\n\n\t// await the rendering\n\tconst buffer = await bufferPromise;\n\n\t// return the audio\n\treturn new ToneAudioBuffer(buffer);\n}\n","import { Tone } from \"../Tone\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isString } from \"../util/TypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\ninterface ToneAudioBuffersUrlMap {\n\t[name: string]: string | AudioBuffer | ToneAudioBuffer;\n\t[name: number]: string | AudioBuffer | ToneAudioBuffer;\n}\n\ninterface ToneAudioBuffersOptions {\n\turls: ToneAudioBuffersUrlMap;\n\tonload: () => void;\n\tonerror?: (error: Error) => void;\n\tbaseUrl: string;\n}\n\n/**\n * A data structure for holding multiple buffers in a Map-like datastructure.\n *\n * @example\n * //load a whole bank of piano samples\n * var pianoSamples = new ToneAudioBuffers({\n * \t\"C4\" : \"path/to/C4.mp3\"\n * \t\"C#4\" : \"path/to/C#4.mp3\"\n * \t\"D4\" : \"path/to/D4.mp3\"\n * \t\"D#4\" : \"path/to/D#4.mp3\"\n * }, function(){\n * \t//play one of the samples when they all load\n * \tplayer.buffer = pianoSamples.get(\"C4\");\n * \tplayer.start();\n * });\n * @example\n * //To pass in additional parameters in the second parameter\n * var buffers = new ToneAudioBuffers(urls, {\n * \t\"onload\" : callback,\n * \t\"baseUrl\" : \"../path/to/audio/\"\n * })\n * @category Core\n */\nexport class ToneAudioBuffers extends Tone {\n\n\tname = \"ToneAudioBuffers\";\n\n\t/**\n\t *  All of the buffers\n\t */\n\tprivate _buffers: Map<string, ToneAudioBuffer> = new Map();\n\n\t/**\n\t *  A path which is prefixed before every url.\n\t */\n\tbaseUrl: string;\n\n\t/**\n\t * Keep track of the number of loaded buffers\n\t */\n\tprivate _loadingCount: number = 0;\n\n\t/**\n\t * @param  urls  An object literal or array of urls to load.\n\t * @param onload  The callback to invoke when the buffers are loaded.\n\t * @param baseUrl A prefix url to add before all the urls\n\t */\n\tconstructor(\n\t\turls?: ToneAudioBuffersUrlMap,\n\t\tonload?: () => void,\n\t\tbaseUrl?: string,\n\t);\n\tconstructor(options?: Partial<ToneAudioBuffersOptions>);\n\tconstructor() {\n\n\t\tsuper();\n\t\tconst options = optionsFromArguments(\n\t\t\tToneAudioBuffers.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\",\n\t\t);\n\n\t\tthis.baseUrl = options.baseUrl;\n\t\tconst urlMap: ToneAudioBuffersUrlMap = {};\n\t\t// add each one\n\t\tObject.keys(options.urls).forEach(name => {\n\t\t\tthis._loadingCount++;\n\t\t\tconst url = options.urls[name];\n\t\t\tthis.add(name, url, this._bufferLoaded.bind(this, options.onload));\n\t\t});\n\n\t}\n\n\tstatic getDefaults(): ToneAudioBuffersOptions {\n\t\treturn {\n\t\t\tbaseUrl: \"\",\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\turls: {},\n\t\t};\n\t}\n\n\t/**\n\t *  True if the buffers object has a buffer by that name.\n\t * @param  name  The key or index of the buffer.\n\t */\n\thas(name: string | number): boolean {\n\t\treturn this._buffers.has(name.toString());\n\t}\n\n\t/**\n\t *  Get a buffer by name. If an array was loaded,\n\t *  then use the array index.\n\t * @param  name  The key or index of the buffer.\n\t */\n\tget(name: string | number): ToneAudioBuffer {\n\t\tthis.assert(this.has(name), `ToneAudioBuffers has no buffer named: ${name}`);\n\t\treturn this._buffers.get(name.toString()) as ToneAudioBuffer;\n\t}\n\n\t/**\n\t *  A buffer was loaded. decrement the counter.\n\t */\n\tprivate _bufferLoaded(callback: () => void): void {\n\t\tthis._loadingCount--;\n\t\tif (this._loadingCount === 0 && callback) {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn Array.from(this._buffers).every(([name, buffer]) => buffer.loaded);\n\t}\n\n\t/**\n\t *  Add a buffer by name and url to the Buffers\n\t * @param  name      A unique name to give the buffer\n\t * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(\n\t\tname: string | number,\n\t\turl: string | AudioBuffer | ToneAudioBuffer,\n\t\tcallback: () => void = noOp,\n\t): this {\n\t\tif (url instanceof ToneAudioBuffer) {\n\t\t\tthis._buffers.set(name.toString(), url);\n\t\t\tcallback();\n\t\t} else if (isAudioBuffer(url)) {\n\t\t\tthis._buffers.set(name.toString(), new ToneAudioBuffer(url));\n\t\t\tcallback();\n\t\t} else if (isString(url)) {\n\t\t\tthis._buffers.set(name.toString(), new ToneAudioBuffer(this.baseUrl + url, callback));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.forEach(buffer => buffer.dispose());\n\t\tthis._buffers.clear();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../context/Param\";\nimport { Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\nexport interface DelayOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tmaxDelay: Time;\n}\n\n/**\n * Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).\n * @category Core\n */\nexport class Delay extends ToneAudioNode<DelayOptions> {\n\n\treadonly name = \"Delay\";\n\n\t/**\n\t * The maximum delay time. This cannot be changed after\n\t * the value is passed into the constructor.\n\t */\n\treadonly maxDelay: Time;\n\n\t/**\n\t *  The amount of time the incoming signal is delayed.\n\t */\n\treadonly delayTime: Param<Time>;\n\n\t/**\n\t * Private reference to the internal DelayNode\n\t */\n\tprivate _delayNode: DelayNode;\n\treadonly input: DelayNode;\n\treadonly output: DelayNode;\n\n\t/**\n\t * @param delayTime The delay applied to the incoming signal.\n\t * @param maxDelay The maximum delay time.\n\t */\n\tconstructor(delayTime?: Time, maxDelay?: Time);\n\tconstructor(options?: Partial<DelayOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]));\n\n\t\tconst options = optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]);\n\n\t\tconst maxDelayInSeconds = this.toSeconds(options.maxDelay);\n\t\tthis.maxDelay = Math.max(maxDelayInSeconds, this.toSeconds(options.delayTime));\n\n\t\tthis._delayNode = this.input = this.output = this.context.createDelay(maxDelayInSeconds);\n\n\t\tthis.delayTime = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._delayNode.delayTime,\n\t\t\tunits : \"time\",\n\t\t\tvalue : options.delayTime,\n\t\t});\n\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): DelayOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime : 0,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.disconnect();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { Seconds } from \"../type/Units\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\n\nexport type BasicPlaybackState = \"started\" | \"stopped\";\nexport type PlaybackState = BasicPlaybackState | \"paused\";\n\nexport interface StateTimelineEvent extends TimelineEvent {\n\tstate: PlaybackState;\n}\n\n/**\n *  A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n * @category Core\n */\nexport class StateTimeline<AdditionalOptions extends {} = {}> extends Timeline<StateTimelineEvent & AdditionalOptions> {\n\n\treadonly name = \"StateTimeline\";\n\n\t/**\n\t *  The initial state\n\t */\n\tprivate _initial: PlaybackState;\n\n\tconstructor(initial: PlaybackState = \"stopped\") {\n\t\tsuper();\n\t\tthis._initial = initial;\n\t}\n\n\t/**\n\t *  Returns the scheduled state scheduled before or at\n\t *  the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t */\n\tgetValueAtTime(time: Seconds): PlaybackState {\n\t\tconst event = this.get(time);\n\t\tif (event !== null) {\n\t\t\treturn event.state;\n\t\t} else {\n\t\t\treturn this._initial;\n\t\t}\n\t}\n\n\t/**\n\t *  Add a state to the timeline.\n\t * @param  state The name of the state to set.\n\t * @param  time  The time to query.\n\t * @param options Any additional options that are needed in the timeline.\n\t */\n\tsetStateAtTime(state: PlaybackState, time: Seconds, options?: AdditionalOptions): this {\n\t\t// all state changes need to be >= the previous state time\n\t\t// TODO throw error if time < the previous event time\n\t\tthis.add(Object.assign({}, options, {\n\t\t\tstate,\n\t\t\ttime,\n\t\t}));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Return the event before the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check before\n\t * @return  The event with the given state before the time\n\t */\n\tgetLastState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tfor (let i = index; i >= 0; i--) {\n\t\t\tconst event = this._timeline[i];\n\t\t\tif (event.state === state) {\n\t\t\t\treturn event;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Return the event after the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check from\n\t * @return  The event with the given state after the time\n\t */\n\tgetNextState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tif (index !== -1) {\n\t\t\tfor (let i = index; i < this._timeline.length; i++) {\n\t\t\t\tconst event = this._timeline[i];\n\t\t\t\tif (event.state === state) {\n\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import { connect } from \"../Connect\";\nimport { AutomationEvent, Param, ParamOptions } from \"../context/Param\";\nimport { InputNode } from \"../context/ToneAudioNode\";\nimport { getContext } from \"../Global\";\nimport { BPM, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n\ninterface TickAutomationEvent extends AutomationEvent {\n\tticks: number;\n}\n\ninterface TickSignalOptions extends ParamOptions {\n\tvalue: Hertz | BPM;\n\tmultiplier: number;\n}\n\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n * @category Core\n */\nexport class TickSignal<Type extends Hertz | BPM> extends Param<Type> {\n\n\treadonly name = \"TickSignal\";\n\n\tprotected _events: Timeline<TickAutomationEvent> = new Timeline(Infinity);\n\n\tprivate _sig: ConstantSourceNode = this.context.createConstantSource();\n\n\tprotected _param = this._sig.offset;\n\n\tprivate _multiplier: number = 1;\n\n\tconstructor(options: Partial<TickSignalOptions>);\n\t/**\n\t * @param value The initial value of the signal\n\t */\n\tconstructor(value?: number);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis._sig = this.context.createConstantSource();\n\t\tthis._sig.start(0);\n\t\tthis._param = this._sig.offset;\n\n\t\t// set the multiplier\n\t\tthis._multiplier = options.multiplier;\n\n\t\t// clear the ticks from the beginning\n\t\tthis._events.cancel(0);\n\t\t// set an initial event\n\t\tthis._events.add({\n\t\t\tticks: 0,\n\t\t\ttime : 0,\n\t\t\ttype : \"setValue\",\n\t\t\tvalue: this._fromType(options.value as Type),\n\t\t});\n\t\tthis.setValueAtTime(options.value as Type, 0);\n\t}\n\n\tstatic getDefaults(): TickSignalOptions {\n\t\treturn Object.assign(Param.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tparam: getContext().createConstantSource().offset,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tsetTargetAtTime(value: Type, time: Time, constant: number): this {\n\t\t// approximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tthis.setRampPoint(time);\n\t\tconst computedValue = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\tconst segments = Math.round(Math.max(1 / constant, 1));\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = constant * i + time;\n\t\t\tconst rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsetValueAtTime(value: Type, time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.setValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: Type, time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.linearRampToValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: Type, time: Time): this {\n\t\t// aproximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tconst computedVal = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\t// approx 10 segments per second\n\t\tconst segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n\t\tconst segmentDur = ((time - prevEvent.time) / segments);\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = segmentDur * i + prevEvent.time;\n\t\t\tconst rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tprivate _getTicksUntilEvent(event: TickAutomationEvent | null, time: number): Ticks {\n\t\tif (event === null) {\n\t\t\tevent = {\n\t\t\t\tticks : 0,\n\t\t\t\ttime : 0,\n\t\t\t\ttype: \"setValue\",\n\t\t\t\tvalue: 0,\n\t\t\t};\n\t\t} else if (isUndef(event.ticks)) {\n\t\t\tconst previousEvent = this._events.previousEvent(event);\n\t\t\tevent.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n\t\t}\n\t\tconst val0 = this._fromType(this.getValueAtTime(event.time));\n\t\tlet val1 = this._fromType(this.getValueAtTime(time));\n\t\t// if it's right on the line, take the previous value\n\t\tconst onTheLineEvent = this._events.get(time);\n\t\tif (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValue\") {\n\t\t\tval1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n\t\t}\n\t\treturn 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst event = this._events.get(computedTime);\n\t\treturn Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n\t}\n\n\t/**\n\t * Return the elapsed time of the number of ticks from the given time\n\t * @param ticks The number of ticks to calculate\n\t * @param  time The time to get the next tick from\n\t * @return The duration of the number of ticks from the given time in seconds\n\t */\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst currentTick = this.getTicksAtTime(time);\n\t\treturn this.getTimeOfTick(currentTick + ticks) - computedTime;\n\t}\n\n\t/**\n\t * Given a tick, returns the time that tick occurs at.\n\t * @return The time that the tick occurs.\n\t */\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\tconst before = this._events.get(tick, \"ticks\");\n\t\tconst after = this._events.getAfter(tick, \"ticks\");\n\t\tif (before && before.ticks === tick) {\n\t\t\treturn before.time;\n\t\t} else if (before && after &&\n\t\t\tafter.type === \"linear\" &&\n\t\t\tbefore.value !== after.value) {\n\t\t\tconst val0 = this._fromType(this.getValueAtTime(before.time));\n\t\t\tconst val1 = this._fromType(this.getValueAtTime(after.time));\n\t\t\tconst delta = (val1 - val0) / (after.time - before.time);\n\t\t\tconst k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n\t\t\tconst sol1 = (-val0 + k) / delta;\n\t\t\tconst sol2 = (-val0 - k) / delta;\n\t\t\treturn (sol1 > 0 ? sol1 : sol2) + before.time;\n\t\t} else if (before) {\n\t\t\tif (before.value === 0) {\n\t\t\t\treturn Infinity;\n\t\t\t} else {\n\t\t\t\treturn before.time + (tick - before.ticks) / before.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn tick / this._initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Convert some number of ticks their the duration in seconds accounting\n\t * for any automation curves starting at the given time.\n\t * @param  ticks The number of ticks to convert to seconds.\n\t * @param  when  When along the automation timeline to convert the ticks.\n\t * @return The duration in seconds of the ticks.\n\t */\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this.getDurationOfTicks(ticks, when);\n\t}\n\n\t/**\n\t * The inverse of [ticksToTime](#tickstotime). Convert a duration in\n\t * seconds to the corresponding number of ticks accounting for any\n\t * automation curves starting at the given time.\n\t * @param  duration The time interval to convert to ticks.\n\t * @param  when When along the automation timeline to convert the ticks.\n\t * @return The duration in ticks.\n\t */\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tconst startTicks = this.getTicksAtTime(computedTime);\n\t\tconst endTicks = this.getTicksAtTime(computedTime + computedDuration);\n\t\treturn endTicks - startTicks;\n\t}\n\n\t/**\n\t * Convert from the type when the unit value is BPM\n\t */\n\tprotected _fromType(val: Type): number {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn 1 / (60 / val / this.multiplier);\n\t\t} else {\n\t\t\treturn super._fromType(val);\n\t\t}\n\t}\n\n\t/**\n\t * Special case of type conversion where the units === \"bpm\"\n\t */\n\tprotected _toType(val: number): Type {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn (val / this.multiplier) * 60 as Type;\n\t\t} else {\n\t\t\treturn super._toType(val);\n\t\t}\n\t}\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\t// get and reset the current value with the new multipler\n\t\t// might be necessary to clear all the previous values\n\t\tconst currentVal = this.value;\n\t\tthis._multiplier = m;\n\t\tthis.value = currentVal;\n\t}\n\n\t/**\n\t * Connect the output signal\n\t */\n\tconnect(dstNode: InputNode, outputNumber = 0, inputNumber = 0): this {\n\t\tconnect(this._sig, dstNode, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { BPM, Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: Frequency;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ninterface TickSourceOffsetEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n * @category Core\n */\nexport class TickSource<Type extends BPM | Hertz> extends ToneWithContext<TickSourceOptions> {\n\n\tname = \"TickSource\";\n\n\t/**\n\t *  The frequency the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<Type>;\n\n\t/**\n\t *  The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\t/**\n\t * @param frequency The initial frequency that the signal ticks at\n\t */\n\tconstructor(frequency?: Frequency);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new TickSignal({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units,\n\t\t\tvalue: this.toFrequency(options.frequency),\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the inital state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign({\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\" as \"hertz\",\n\t\t}, ToneWithContext.getDefaults());\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t *  Start the clock at the given time. Optionally pass in an offset\n\t *  of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t * @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", computedTime);\n\t\tif (!stopEvent) {\n\t\t\treturn 0;\n\t\t}\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time: computedTime};\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedTicks = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t *  The number of times the callback was invoked. Starts counting at 0\n\t *  and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t *  The time since ticks=0 that the TickSource has been running. Accounts\n\t *  for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", time);\n\t\tif (!stopEvent) {\n\t\t\treturn 0;\n\t\t}\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state : \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedSeconds = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds : this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @example\n\t * source.start(\"+0.1\");\n\t * source.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  ticks The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t *  Invoke the callback event at all scheduled ticks between the\n\t *  start time and the end time\n\t * @param  startTime  The beginning of the search range\n\t * @param  endTime    The end of the search range\n\t * @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(startTime: Time, endTime: Time, callback: (when: Seconds, ticks: Ticks) => void): this {\n\t\tconst computedStartTime = this.toSeconds(startTime);\n\t\tconst computedEndTime = this.toSeconds(endTime);\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(computedStartTime);\n\t\tthis._state.forEachBetween(computedStartTime, computedEndTime, event => {\n\t\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n\t\t\t\tthis.forEachTickBetween(Math.max(lastStateEvent.time, computedStartTime), event.time - this.sampleTime, callback);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && this._state) {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, computedStartTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = diff % 1;\n\t\t\tif (offset !== 0) {\n\t\t\t\toffset = 1 - offset;\n\t\t\t}\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\t\t\twhile (nextTickTime < computedEndTime && this._state) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this._state) {\n\t\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { BPM, Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter, EmitterEventObject } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline } from \"../util/StateTimeline\";\nimport { TickSignal } from \"./TickSignal\";\nimport { TickSource } from \"./TickSource\";\n\ntype ClockCallback = (time: Time, ticks?: Ticks) => void;\n\ninterface ClockOptions extends ToneWithContextOptions {\n\tfrequency: number;\n\tcallback: ClockCallback;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ntype ClockEvent = \"start\" | \"stop\" | \"pause\";\n\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * //the callback will be invoked approximately once a second\n * //and will print the time exactly once a second apart.\n * const clock = new Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * @category Core\n */\nexport class Clock<Type extends BPM | Hertz = Hertz>\nextends ToneWithContext<ClockOptions> implements Emitter<ClockEvent> {\n\n\tname = \"Clock\";\n\n\t/**\n\t *  The callback function to invoke at the scheduled tick.\n\t */\n\tcallback: ClockCallback = noOp;\n\n\t/**\n\t *  The tick counter\n\t */\n\tprivate _tickSource: TickSource<Type>;\n\n\t/**\n\t *  The last time the loop callback was invoked\n\t */\n\tprivate _lastUpdate: number = 0;\n\n\t/**\n\t *  Keep track of the playback state\n\t */\n\tprivate _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t * Context bound reference to the _loop method\n\t * This is necessary to remove the event in the end.\n\t */\n\tprivate _boundLoop: () => void = this._loop.bind(this);\n\n\t/**\n\t *  The rate the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<Type>;\n\n\t/**\n\t * @param callback The callback to be invoked with the time of the audio event\n\t * @param frequency The rate of the callback\n\t */\n\tconstructor(callback?: ClockCallback, frequency?: Frequency);\n\tconstructor(options: Partial<ClockOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n\t\tconst options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._tickSource = new TickSource({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._lastUpdate = 0;\n\t\tthis.frequency = this._tickSource.frequency;\n\t\treadOnly(this, \"frequency\");\n\n\t\t// add an initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\n\t\t// bind a callback to the worker thread\n\t\tthis.context.on(\"tick\", this._boundLoop);\n\t}\n\n\tstatic getDefaults(): ClockOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp as ClockCallback,\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}) as ClockOptions;\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t *  Start the clock at the given time. Optionally pass in an offset\n\t *  of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset  Where the tick counter starts counting from.\n\t */\n\tstart(time?: Time, offset?: Ticks): this {\n\t\t// make sure the context is started\n\t\tthis.context.resume();\n\t\t// start the loop\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis._tickSource.start(computedTime, offset);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"start\", computedTime, offset);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t * @example\n\t * clock.stop();\n\t */\n\tstop(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis._tickSource.stop(computedTime);\n\t\tif (computedTime < this._lastUpdate) {\n\t\t\tthis.emit(\"stop\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._tickSource.pause(computedTime);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"pause\", computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The number of times the callback was invoked. Starts counting at 0\n\t *  and increments after the callback was invoked.\n\t */\n\tget ticks(): Ticks {\n\t\treturn Math.ceil(this.getTicksAtTime(this.now()));\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis._tickSource.ticks = t;\n\t}\n\n\t/**\n\t *  The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._tickSource.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tthis._tickSource.seconds = s;\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._tickSource.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\tthis._tickSource.setTicksAtTime(ticks, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn this._tickSource.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the next tick\n\t * @param  ticks The tick number.\n\t */\n\tnextTickTime(offset: Ticks, when: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst currentTick = this.getTicksAtTime(computedTime);\n\t\treturn this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n\t}\n\n\t/**\n\t *  The scheduling loop.\n\t */\n\tprivate _loop(): void {\n\n\t\tconst startTime = this._lastUpdate;\n\t\tconst endTime = this.now();\n\t\tthis._lastUpdate = endTime;\n\n\t\tif (startTime !== endTime) {\n\t\t\t// the state change events\n\t\t\tthis._state.forEachBetween(startTime, endTime, e => {\n\t\t\t\tswitch (e.state) {\n\t\t\t\t\tcase \"started\" :\n\t\t\t\t\t\tconst offset = this._tickSource.getTicksAtTime(e.time);\n\t\t\t\t\t\tthis.emit(\"start\", e.time, offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"stopped\" :\n\t\t\t\t\t\tif (e.time !== 0) {\n\t\t\t\t\t\t\tthis.emit(\"stop\", e.time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"paused\" :\n\t\t\t\t\t\tthis.emit(\"pause\", e.time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// the tick callbacks\n\t\t\tthis._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n\t\t\t\tthis.callback(time, ticks);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t * @example\n\t * clock.start(\"+0.1\");\n\t * clock.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(computedTime);\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.off(\"tick\", this._boundLoop);\n\t\tthis._tickSource.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t///////////////////////////////////////////////////////////////////////\n\n\ton!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\tonce!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\toff!: (event: ClockEvent, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Clock);\n","import { getContext } from \"../Global\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\nimport { TransportTimeClass } from \"./TransportTime\";\nimport { Seconds, Ticks } from \"./Units\";\n\n/**\n * Ticks is a primitive type for encoding Time values.\n * Ticks can be constructed with or without the `new` keyword. Ticks can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * const t = Ticks(\"4n\"); //a quarter note as ticks\n * @category Unit\n */\nexport class TicksClass extends TransportTimeClass<Ticks> {\n\n\tname = \"Ticks\";\n\n\treadonly defaultUnits: TimeBaseUnit = \"i\";\n\n\t/**\n\t * Get the current time in the given units\n\t */\n\tprotected _now(): Ticks {\n\t\treturn this.context.transport.ticks;\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Ticks {\n\t\treturn this._getPPQ() * beats;\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Ticks {\n\t\treturn Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Ticks {\n\t\treturn ticks;\n\t}\n\n\t/**\n\t *  Return the time in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\treturn this.valueOf() as Ticks;\n\t}\n\n\t/**\n\t *  Return the time in seconds\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn (this.valueOf() / this._getPPQ()) * (60 / this._getBpm());\n\t}\n}\n\n/**\n * Convert a time representation to ticks\n * @category Unit\n */\nexport function Ticks(value?: TimeValue, units?: TimeBaseUnit): TicksClass {\n\treturn new TicksClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { ftom, mtof } from \"./Conversions\";\nimport { FrequencyClass, FrequencyUnit } from \"./Frequency\";\nimport { TimeValue } from \"./TimeBase\";\nimport { Hertz, Interval, MidiNote, Seconds, Ticks } from \"./Units\";\n\n/**\n * Midi is a primitive type for encoding Time values.\n * Midi can be constructed with or without the `new` keyword. Midi can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * var t = Midi(\"4n\");//a quarter note\n * @category Unit\n */\nexport class MidiClass extends FrequencyClass<MidiNote> {\n\n\tname = \"Midi\";\n\n\treadonly defaultUnits = \"midi\";\n\n\t/**\n\t *  Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): MidiNote {\n\t\treturn ftom(super._frequencyToUnits(freq));\n\t}\n\n\t/**\n\t *  Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): MidiNote {\n\t\treturn ftom(super._ticksToUnits(ticks));\n\t}\n\n\t/**\n\t *  Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): MidiNote {\n\t\treturn ftom(super._beatsToUnits(beats));\n\t}\n\n\t/**\n\t *  Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): MidiNote {\n\t\treturn ftom(super._secondsToUnits(seconds));\n\t}\n\n\t/**\n\t *  Return the value of the frequency as a MIDI note\n\t * @return  {MIDI}\n\t * @example\n\t * Midi(60).toMidi(); //60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t *  Return the value of the frequency as a MIDI note\n\t * @return  {MIDI}\n\t * @example\n\t * Midi(60).toFrequency(); //261.6255653005986\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn mtof(this.toMidi());\n\t}\n\n\t/**\n\t *  Transposes the frequency by the given number of semitones.\n\t * @return A new transposed MidiClass\n\t * @example\n\t * Midi(\"A4\").transpose(3); //\"C5\"\n\t */\n\ttranspose(interval: Interval): MidiClass {\n\t\treturn new MidiClass(this.context, this.toMidi() + interval);\n\t}\n}\n\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n */\nexport function Midi(value?: TimeValue, units?: FrequencyUnit): MidiClass {\n\treturn new MidiClass(getContext(), value, units);\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Seconds, Time } from \"../type/Units\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\n\ninterface DrawEvent extends TimelineEvent {\n\tcallback: () => void;\n}\n\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule(function(time){\n * \t//use the time argument to schedule a callback with Draw\n * \tDraw.schedule(function(){\n * \t\t//do drawing or DOM manipulation here\n * \t}, time)\n * }, \"+0.5\")\n * @category Core\n */\nexport class Draw extends ToneWithContext<ToneWithContextOptions> {\n\n\tname = \"Draw\";\n\n\t/**\n\t *  The duration after which events are not invoked.\n\t */\n\texpiration: Seconds = 0.25;\n\n\t/**\n\t *  The amount of time before the scheduled time\n\t *  that the callback can be invoked. Default is\n\t *  half the time of an animation frame (0.008 seconds).\n\t */\n\tanticipation: Seconds = 0.008;\n\n\t/**\n\t *  All of the events.\n\t */\n\tprivate _events: Timeline<DrawEvent> = new Timeline();\n\n\t/**\n\t *  The draw loop\n\t */\n\tprivate _boundDrawLoop = this._drawLoop.bind(this);\n\n\t/**\n\t * The animation frame id\n\t */\n\tprivate _animationFrame: number = -1;\n\n\t/**\n\t *  Schedule a function at the given time to be invoked\n\t *  on the nearest animation frame.\n\t * @param  callback  Callback is invoked at the given time.\n\t * @param  time      The time relative to the AudioContext time to invoke the callback.\n\t */\n\tschedule(callback: () => void, time: Time): this {\n\t\tthis._events.add({\n\t\t\tcallback,\n\t\t\ttime : this.toSeconds(time),\n\t\t});\n\t\t// start the draw loop on the first event\n\t\tif (this._events.length === 1) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel events scheduled after the given time\n\t * @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._events.cancel(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The draw loop\n\t */\n\tprivate _drawLoop(): void {\n\t\tconst now = this.context.currentTime;\n\t\twhile (this._events.length && (this._events.peek() as DrawEvent).time - this.anticipation <= now) {\n\t\t\tconst event = this._events.shift();\n\t\t\tif (event && now - event.time <= this.expiration) {\n\t\t\t\tevent.callback();\n\t\t\t}\n\t\t}\n\t\tif (this._events.length > 0) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\tcancelAnimationFrame(this._animationFrame);\n\t\treturn this;\n\t}\n}\n","import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\n\n/**\n * An IntervalTimeline event must have a time and duration\n */\nexport interface IntervalTimelineEvent {\n\ttime: number;\n\tduration: number;\n\t[propName: string]: any;\n}\n\ntype IteratorCallback = (event: IntervalTimelineEvent) => void;\n\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n * @category Core\n */\nexport class IntervalTimeline extends Tone {\n\n\treadonly name = \"IntervalTimeline\";\n\n\t/**\n\t *  The root node of the inteval tree\n\t */\n\tprivate _root: IntervalNode | null = null;\n\n\t/**\n\t *  Keep track of the length of the timeline.\n\t */\n\tprivate _length: number = 0;\n\n\t/**\n\t *  The event to add to the timeline. All events must\n\t *  have a time and duration value\n\t * @param  event  The event to add to the timeline\n\t */\n\tadd(event: IntervalTimelineEvent): this {\n\t\tthis.assert(isDefined(event.time), \"Events must have a time property\");\n\t\tthis.assert(isDefined(event.duration), \"Events must have a duration parameter\");\n\n\t\tevent.time = event.time.valueOf();\n\t\tlet node: IntervalNode | null = new IntervalNode(event.time, event.time + event.duration, event);\n\t\tif (this._root === null) {\n\t\t\tthis._root = node;\n\t\t} else {\n\t\t\tthis._root.insert(node);\n\t\t}\n\t\tthis._length++;\n\t\t// Restructure tree to be balanced\n\t\twhile (node !== null) {\n\t\t\tnode.updateHeight();\n\t\t\tnode.updateMax();\n\t\t\tthis._rebalance(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove an event from the timeline.\n\t * @param  event  The event to remove from the timeline\n\t */\n\tremove(event: IntervalTimelineEvent): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(event.time, results);\n\t\t\tfor (const node of results) {\n\t\t\t\tif (node.event === event) {\n\t\t\t\t\tthis._removeNode(node);\n\t\t\t\t\tthis._length--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The number of items in the timeline.\n\t * @readOnly\n\t */\n\tget length(): number {\n\t\treturn this._length;\n\t}\n\n\t/**\n\t *  Remove events whose time time is after the given time\n\t * @param  time  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tthis.forEachFrom(after, event => this.remove(event));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Set the root node as the given node\n\t */\n\tprivate _setRoot(node: IntervalNode | null): void {\n\t\tthis._root = node;\n\t\tif (this._root !== null) {\n\t\t\tthis._root.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t *  Replace the references to the node in the node's parent\n\t *  with the replacement node.\n\t */\n\tprivate _replaceNodeInParent(node: IntervalNode, replacement: IntervalNode | null): void {\n\t\tif (node.parent !== null) {\n\t\t\tif (node.isLeftChild()) {\n\t\t\t\tnode.parent.left = replacement;\n\t\t\t} else {\n\t\t\t\tnode.parent.right = replacement;\n\t\t\t}\n\t\t\tthis._rebalance(node.parent);\n\t\t} else {\n\t\t\tthis._setRoot(replacement);\n\t\t}\n\t}\n\n\t/**\n\t *  Remove the node from the tree and replace it with\n\t *  a successor which follows the schema.\n\t */\n\tprivate _removeNode(node: IntervalNode): void {\n\t\tif (node.left === null && node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, null);\n\t\t} else if (node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, node.left);\n\t\t} else if (node.left === null) {\n\t\t\tthis._replaceNodeInParent(node, node.right);\n\t\t} else {\n\t\t\tconst balance = node.getBalance();\n\t\t\tlet replacement: IntervalNode;\n\t\t\tlet temp: IntervalNode | null = null;\n\t\t\tif (balance > 0) {\n\t\t\t\tif (node.left.right === null) {\n\t\t\t\t\treplacement = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\ttemp = replacement;\n\t\t\t\t} else {\n\t\t\t\t\treplacement = node.left.right;\n\t\t\t\t\twhile (replacement.right !== null) {\n\t\t\t\t\t\treplacement = replacement.right;\n\t\t\t\t\t}\n\t\t\t\t\tif (replacement.parent) {\n\t\t\t\t\t\treplacement.parent.right = replacement.left;\n\t\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.right.left === null) {\n\t\t\t\treplacement = node.right;\n\t\t\t\treplacement.left = node.left;\n\t\t\t\ttemp = replacement;\n\t\t\t} else {\n\t\t\t\treplacement = node.right.left;\n\t\t\t\twhile (replacement.left !== null) {\n\t\t\t\t\treplacement = replacement.left;\n\t\t\t\t}\n\t\t\t\tif (replacement.parent) {\n\t\t\t\t\treplacement.parent.left = replacement.right;\n\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.parent !== null) {\n\t\t\t\tif (node.isLeftChild()) {\n\t\t\t\t\tnode.parent.left = replacement;\n\t\t\t\t} else {\n\t\t\t\t\tnode.parent.right = replacement;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setRoot(replacement);\n\t\t\t}\n\t\t\tif (temp) {\n\t\t\t\tthis._rebalance(temp);\n\t\t\t}\n\t\t}\n\t\tnode.dispose();\n\t}\n\n\t/**\n\t *  Rotate the tree to the left\n\t */\n\tprivate _rotateLeft(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.right the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.right;\n\t\tif (pivotNode) {\n\t\t\tnode.right = pivotNode.left;\n\t\t\tpivotNode.left = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t *  Rotate the tree to the right\n\t */\n\tprivate _rotateRight(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.left the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.left;\n\t\tif (pivotNode) {\n\t\t\tnode.left = pivotNode.right;\n\t\t\tpivotNode.right = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t *  Balance the BST\n\t */\n\tprivate _rebalance(node: IntervalNode): void {\n\t\tconst balance = node.getBalance();\n\t\tif (balance > 1 && node.left) {\n\t\t\tif (node.left.getBalance() < 0) {\n\t\t\t\tthis._rotateLeft(node.left);\n\t\t\t} else {\n\t\t\t\tthis._rotateRight(node);\n\t\t\t}\n\t\t} else if (balance < -1 && node.right) {\n\t\t\tif (node.right.getBalance() > 0) {\n\t\t\t\tthis._rotateRight(node.right);\n\t\t\t} else {\n\t\t\t\tthis._rotateLeft(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Get an event whose time and duration span the give time. Will\n\t *  return the match whose \"time\" value is closest to the given time.\n\t * @return  The event which spans the desired time\n\t */\n\tget(time: number): IntervalTimelineEvent | null {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tif (results.length > 0) {\n\t\t\t\tlet max = results[0];\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tif (results[i].low > max.low) {\n\t\t\t\t\t\tmax = results[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max.event;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t *  Iterate over everything in the timeline.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst allNodes: IntervalNode[] = [];\n\t\t\tthis._root.traverse(node => allNodes.push(node));\n\t\t\tallNodes.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array in which the given time\n\t *  overlaps with the time and duration time of the event.\n\t * @param  time The time to check if items are overlapping\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over everything in the array in which the time is greater\n\t *  than or equal to the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.searchAfter(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._root !== null) {\n\t\t\tthis._root.traverse(node => node.dispose());\n\t\t}\n\t\tthis._root = null;\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tINTERVAL NODE HELPER\n///////////////////////////////////////////////////////////////////////////\n\n/**\n *  Represents a node in the binary search tree, with the addition\n *  of a \"high\" value which keeps track of the highest value of\n *  its children.\n *  References:\n *  https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n *  http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\n// tslint:disable-next-line: max-classes-per-file\nclass IntervalNode {\n\n\t// the event container\n\tevent: IntervalTimelineEvent | null;\n\t// the low value\n\tlow: number;\n\t// the high value\n\thigh: number;\n\t// the high value for this and all child nodes\n\tmax: number;\n\t// the nodes to the left\n\tprivate _left: IntervalNode | null = null;\n\t// the nodes to the right\n\tprivate _right: IntervalNode | null = null;\n\t// the parent node\n\tparent: IntervalNode | null = null;\n\t// the number of child nodes\n\theight: number = 0;\n\n\tconstructor(low: number, high: number, event: IntervalTimelineEvent) {\n\t\tthis.event = event;\n\t\t// the low value\n\t\tthis.low = low;\n\t\t// the high value\n\t\tthis.high = high;\n\t\t// the high value for this and all child nodes\n\t\tthis.max = this.high;\n\t}\n\n\t/**\n\t *  Insert a node into the correct spot in the tree\n\t */\n\tinsert(node: IntervalNode): void {\n\t\tif (node.low <= this.low) {\n\t\t\tif (this.left === null) {\n\t\t\t\tthis.left = node;\n\t\t\t} else {\n\t\t\t\tthis.left.insert(node);\n\t\t\t}\n\t\t} else if (this.right === null) {\n\t\t\tthis.right = node;\n\t\t} else {\n\t\t\tthis.right.insert(node);\n\t\t}\n\t}\n\n\t/**\n\t *  Search the tree for nodes which overlap\n\t *  with the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearch(point: number, results: IntervalNode[]): void {\n\t\t// If p is to the right of the rightmost point of any interval\n\t\t// in this node and all children, there won't be any matches.\n\t\tif (point > this.max) {\n\t\t\treturn;\n\t\t}\n\t\t// Search left children\n\t\tif (this.left !== null) {\n\t\t\tthis.left.search(point, results);\n\t\t}\n\t\t// Check this node\n\t\tif (this.low <= point && this.high > point) {\n\t\t\tresults.push(this);\n\t\t}\n\t\t// If p is to the left of the time of this interval,\n\t\t// then it can't be in any child to the right.\n\t\tif (this.low > point) {\n\t\t\treturn;\n\t\t}\n\t\t// Search right children\n\t\tif (this.right !== null) {\n\t\t\tthis.right.search(point, results);\n\t\t}\n\t}\n\n\t/**\n\t *  Search the tree for nodes which are less\n\t *  than the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearchAfter(point: number, results: IntervalNode[]): void {\n\t\t// Check this node\n\t\tif (this.low >= point) {\n\t\t\tresults.push(this);\n\t\t\tif (this.left !== null) {\n\t\t\t\tthis.left.searchAfter(point, results);\n\t\t\t}\n\t\t}\n\t\t// search the right side\n\t\tif (this.right !== null) {\n\t\t\tthis.right.searchAfter(point, results);\n\t\t}\n\t}\n\n\t/**\n\t *  Invoke the callback on this element and both it's branches\n\t * @param  {Function}  callback\n\t */\n\ttraverse(callback: (self: IntervalNode) => void): void {\n\t\tcallback(this);\n\t\tif (this.left !== null) {\n\t\t\tthis.left.traverse(callback);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.right.traverse(callback);\n\t\t}\n\t}\n\n\t/**\n\t *  Update the height of the node\n\t */\n\tupdateHeight(): void {\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tthis.height = Math.max(this.left.height, this.right.height) + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tthis.height = this.right.height + 1;\n\t\t} else if (this.left !== null) {\n\t\t\tthis.height = this.left.height + 1;\n\t\t} else {\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\n\t/**\n\t *  Update the height of the node\n\t */\n\tupdateMax(): void {\n\t\tthis.max = this.high;\n\t\tif (this.left !== null) {\n\t\t\tthis.max = Math.max(this.max, this.left.max);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.max = Math.max(this.max, this.right.max);\n\t\t}\n\t}\n\n\t/**\n\t *  The balance is how the leafs are distributed on the node\n\t * @return  Negative numbers are balanced to the right\n\t */\n\tgetBalance(): number {\n\t\tlet balance = 0;\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tbalance = this.left.height - this.right.height;\n\t\t} else if (this.left !== null) {\n\t\t\tbalance = this.left.height + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tbalance = -(this.right.height + 1);\n\t\t}\n\t\treturn balance;\n\t}\n\n\t/**\n\t * @returns true if this node is the left child of its parent\n\t */\n\tisLeftChild(): boolean {\n\t\treturn this.parent !== null && this.parent.left === this;\n\t}\n\n\t/**\n\t *  get/set the left node\n\t */\n\tget left(): IntervalNode | null {\n\t\treturn this._left;\n\t}\n\n\tset left(node: IntervalNode | null) {\n\t\tthis._left = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t *  get/set the right node\n\t */\n\tget right(): IntervalNode | null {\n\t\treturn this._right;\n\t}\n\n\tset right(node: IntervalNode | null) {\n\t\tthis._right = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t *  null out references.\n\t */\n\tdispose(): void {\n\t\tthis.parent = null;\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis.event = null;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { InputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface VolumeOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n * Volume is a simple volume node, useful for creating a volume fader.\n *\n * @example\n * var vol = new Volume(-12);\n * instrument.chain(vol, Tone.Master);\n */\nexport class Volume extends ToneAudioNode<VolumeOptions> {\n\n\treadonly name = \"Volume\";\n\n\t/**\n\t * the output node\n\t */\n\toutput: Gain<Decibels>;\n\n\t/**\n\t * Input and output are the same\n\t */\n\tinput: Gain;\n\n\t/**\n\t * The unmuted volume\n\t */\n\tprivate _unmutedVolume: Decibels;\n\n\t/**\n\t *  The volume control in decibels.\n\t */\n\tvolume: Param<Decibels>;\n\n\t/**\n\t * @param volume the initial volume in decibels\n\t */\n\tconstructor(volume?: Decibels);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<VolumeOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]);\n\n\t\tthis.input = this.output = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.volume,\n\t\t\tunits: \"decibels\",\n\t\t});\n\t\tthis.volume = this.output.gain;\n\t\treadOnly(this, \"volume\");\n\t\tthis._unmutedVolume = options.volume;\n\n\t\t// set the mute initially\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): VolumeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * volume.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.volume.value === -Infinity;\n\t}\n\tset mute(mute: boolean) {\n\t\tif (!this.mute && mute) {\n\t\t\tthis._unmutedVolume = this.volume.value;\n\t\t\t// maybe it should ramp here?\n\t\t\tthis.volume.value = -Infinity;\n\t\t} else if (this.mute && !mute) {\n\t\t\tthis.volume.value = this._unmutedVolume;\n\t\t}\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../../component/channel/Volume\";\nimport { connectSeries } from \"../Connect\";\nimport { Decibels } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\nimport { Gain } from \"./Gain\";\nimport { Param } from \"./Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface DestinationOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n * A single master output which is connected to the\n * AudioDestinationNode (aka your speakers).\n * It provides useful conveniences such as the ability\n * to set the volume and mute the entire application.\n * It also gives you the ability to apply master effects to your application.\n *\n * @example\n * //the audio will go from the oscillator to the speakers\n * oscillator.connect(Destination);\n * //a convenience for connecting to the master output is also provided:\n * oscillator.toDestination();\n * //the above two examples are equivalent.\n * @category Core\n */\nexport class Destination extends ToneAudioNode<DestinationOptions> {\n\n\treadonly name = \"Destination\";\n\n\tinput: Volume = new Volume({ context: this.context });\n\toutput: Gain = new Gain({ context : this.context });\n\n\t/**\n\t * The volume of the master output.\n\t */\n\tvolume: Param<Decibels> = this.input.volume;\n\n\tconstructor(options: Partial<DestinationOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Destination.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Destination.getDefaults(), arguments);\n\n\t\tconnectSeries(this.input, this.output, this.context.rawContext.destination);\n\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): DestinationOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * Destination.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.input.mute;\n\t}\n\n\tset mute(mute: boolean) {\n\t\tthis.input.mute = mute;\n\t}\n\n\t/**\n\t *  Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n\t *  chained in the master effects chain.\n\t * @param nodes All arguments will be connected in a row and the Master will be routed through it.\n\t * @return  {Destination}  this\n\t * @example\n\t * //some overall compression to keep the levels in check\n\t * var masterCompressor = new Tone.Compressor({\n\t * \t\"threshold\" : -6,\n\t * \t\"ratio\" : 3,\n\t * \t\"attack\" : 0.5,\n\t * \t\"release\" : 0.1\n\t * });\n\t * //give a little boost to the lows\n\t * var lowBump = new Tone.Filter(200, \"lowshelf\");\n\t * //route everything through the filter\n\t * //and compressor before going to the speakers\n\t * Destination.chain(lowBump, masterCompressor);\n\t */\n\tchain(...args: Array<AudioNode | ToneAudioNode>): this {\n\t\tthis.input.disconnect();\n\t\targs.unshift(this.input);\n\t\targs.push(this.output);\n\t\tconnectSeries(...args);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// \tINITIALIZATION\n///////////////////////////////////////////////////////////////////////////\n\nonContextInit(context => {\n\tcontext.destination = new Destination({ context });\n});\n\nonContextClose(context => {\n\tcontext.destination.dispose();\n});\n","import { Seconds, Ticks } from \"../type/Units\";\nimport { noOp } from \"../util/Interface\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\nexport interface TransportEventOptions {\n\tcallback: (time: number) => void;\n\tonce: boolean;\n\ttime: Ticks;\n}\n\n/**\n * TransportEvent is an internal class used by (Tone.Transport)[Transport]\n * to schedule events. Do no invoke this class directly, it is\n * handled from within Tone.Transport.\n * @category Core\n */\nexport class TransportEvent {\n\n\t/**\n\t * Reference to the Transport that created it\n\t */\n\tprotected transport: Transport;\n\n\t/**\n\t * The unique id of the event\n\t */\n\tid: number = TransportEvent._eventId++;\n\n\t/**\n\t * The time the event starts\n\t */\n\ttime: Ticks;\n\n\t/**\n\t * The callback to invoke\n\t */\n\tprivate callback?: (time: Seconds) => void;\n\n\t/**\n\t * If the event should be removed after being invoked.\n\t */\n\tprivate _once: boolean;\n\n\t/**\n\t * @param Transport The transport object which the event belongs to\n\t */\n\tconstructor(transport: Transport, opts: Partial<TransportEventOptions>) {\n\n\t\tconst options: TransportEventOptions = Object.assign(TransportEvent.getDefaults(), opts);\n\n\t\tthis.transport = transport;\n\t\tthis.callback = options.callback;\n\t\tthis._once = options.once;\n\t\tthis.time = options.time;\n\t}\n\n\tstatic getDefaults(): TransportEventOptions {\n\t\treturn {\n\t\t\tcallback: noOp,\n\t\t\tonce: false,\n\t\t\ttime: 0,\n\t\t};\n\t}\n\n\t/**\n\t * Current ID counter\n\t */\n\tprivate static _eventId: number = 0;\n\n\t/**\n\t * Invoke the event callback.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\tif (this.callback) {\n\t\t\tthis.callback(time);\n\t\t\tif (this._once) {\n\t\t\t\tthis.transport.clear(this.id);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tthis.callback = undefined;\n\t\treturn this;\n\t}\n}\n","import { Context } from \"../context/Context\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { TransportEvent, TransportEventOptions } from \"./TransportEvent\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\ninterface TransportRepeatEventOptions extends TransportEventOptions {\n\tinterval: Ticks;\n\tduration: Ticks;\n}\n\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n * @category Core\n */\nexport class TransportRepeatEvent extends TransportEvent {\n\n\t/**\n\t * When the event should stop repeating\n\t */\n\tprivate duration: Ticks;\n\n\t/**\n\t * The interval of the repeated event\n\t */\n\tprivate _interval: Ticks;\n\n\t/**\n\t * The ID of the current timeline event\n\t */\n\tprivate _currentId: number = -1;\n\n\t/**\n\t * The ID of the next timeline event\n\t */\n\tprivate _nextId: number = -1;\n\n\t/**\n\t * The time of the next event\n\t */\n\tprivate _nextTick = this.time;\n\n\t/**\n\t * a reference to the bound start method\n\t */\n\tprivate _boundRestart = this._restart.bind(this);\n\n\t/**\n\t * The audio context belonging to this event\n\t */\n\tprotected context: Context;\n\n\t/**\n\t * @param Transport The transport object which the event belongs to\n\t */\n\tconstructor(transport: Transport, opts: Partial<TransportRepeatEventOptions>) {\n\n\t\tsuper(transport, opts);\n\n\t\tconst options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n\n\t\tthis.duration =  new TicksClass(transport.context, options.duration).valueOf();\n\t\tthis._interval = new  TicksClass(transport.context, options.interval).valueOf();\n\t\tthis._nextTick = options.time;\n\t\tthis.transport.on(\"start\", this._boundRestart);\n\t\tthis.transport.on(\"loopStart\", this._boundRestart);\n\t\tthis.context = this.transport.context;\n\t\tthis._restart();\n\t}\n\n\tstatic getDefaults(): TransportRepeatEventOptions {\n\t\treturn Object.assign({}, TransportEvent.getDefaults(), {\n\t\t\tduration: Infinity,\n\t\t\tinterval: 1,\n\t\t\tonce: false,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke the callback. Returns the tick time which\n\t * the next event should be scheduled at.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\t// create more events if necessary\n\t\tthis._createEvents(time);\n\t\t// call the super class\n\t\tsuper.invoke(time);\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _createEvents(time: Seconds): void {\n\t\t// schedule the next event\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n\t\t\tthis._nextTick += this._interval;\n\t\t\tthis._currentId = this._nextId;\n\t\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _restart(time?: Time): void {\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis._nextTick = this.time;\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks > this.time) {\n\t\t\tthis._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n\t\t}\n\t\tthis._currentId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\tthis._nextTick += this._interval;\n\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis.transport.off(\"start\", this._boundRestart);\n\t\tthis.transport.off(\"loopStart\", this._boundRestart);\n\t\treturn this;\n\t}\n}\n","import { TimeClass } from \"../../core/type/Time\";\nimport { PlaybackState } from \"../../core/util/StateTimeline\";\nimport { Signal } from \"../../signal/Signal\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { Param } from \"../context/Param\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { BarsBeatsSixteenths, BPM, NormalRange, Seconds,\n\tSubdivision, Ticks, Time, TimeSignature, TransportTime } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n\ninterface TransportOptions extends ToneWithContextOptions {\n\tbpm: BPM;\n\tswing: NormalRange;\n\tswingSubdivision: Subdivision;\n\ttimeSignature: number;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tppq: number;\n}\n\ntype TransportEventNames = \"start\" | \"stop\" | \"pause\" | \"loop\" | \"loopEnd\" | \"loopStart\";\n\ninterface SyncedSignalEvent {\n\tsignal: Signal;\n\tinitial: number;\n\tratio: Gain;\n}\n\ntype TransportCallback = (time: Seconds) => void;\n\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * //repeated event every 8th note\n * Transport.scheduleRepeat(function(time){\n * \t//do something with the time\n * }, \"8n\");\n * @example\n * //schedule an event on the 16th measure\n * Transport.schedule(function(time){\n * \t//do something with the time\n * }, \"16:0:0\");\n * @category Core\n */\nexport class Transport extends ToneWithContext<TransportOptions> implements Emitter<TransportEventNames> {\n\n\tname = \"Transport\";\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tLOOPING\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * \tIf the transport loops or not.\n\t */\n\tloop: boolean = false;\n\n\t/**\n\t * \tThe loop start position in ticks\n\t */\n\tprivate _loopStart: Ticks = 0;\n\n\t/**\n\t * \tThe loop end position in ticks\n\t */\n\tprivate _loopEnd: Ticks = 0;\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tCLOCK/TEMPO\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Pulses per quarter is the number of ticks per quarter note.\n\t */\n\tprivate _ppq: number;\n\n\t/**\n\t *  watches the main oscillator for timing ticks\n\t *  initially starts at 120bpm\n\t */\n\tprivate _clock: Clock<BPM>;\n\n\t/**\n\t * The Beats Per Minute of the Transport.\n\t * @example\n\t * Transport.bpm.value = 80;\n\t * //ramp the bpm to 120 over 10 seconds\n\t * Transport.bpm.rampTo(120, 10);\n\t */\n\tbpm: Param<BPM>;\n\n\t/**\n\t *  The time signature, or more accurately the numerator\n\t *  of the time signature over a denominator of 4.\n\t */\n\tprivate _timeSignature: number;\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tTIMELINE EVENTS\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  All the events in an object to keep track by ID\n\t */\n\tprivate _scheduledEvents = {};\n\n\t/**\n\t * \tThe scheduled events.\n\t */\n\tprivate _timeline: Timeline<TransportEvent> = new Timeline();\n\n\t/**\n\t *  Repeated events\n\t */\n\tprivate _repeatedEvents: IntervalTimeline = new IntervalTimeline();\n\n\t/**\n\t *  All of the synced Signals\n\t */\n\tprivate _syncedSignals: SyncedSignalEvent[] = [];\n\n\t///////////////////////////////////////////////////////////////////////\n\t// \tSWING\n\t//////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  The subdivision of the swing\n\t */\n\tprivate _swingTicks: Ticks;\n\n\t/**\n\t *  The swing amount\n\t */\n\tprivate _swingAmount: NormalRange = 0;\n\n\tconstructor(options?: Partial<TransportOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Transport.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Transport.getDefaults(), arguments);\n\n\t\t// CLOCK/TEMPO\n\t\tthis._ppq = options.ppq;\n\t\tthis._clock = new Clock({\n\t\t\tcallback : this._processTick.bind(this),\n\t\t\tcontext: this.context,\n\t\t\tfrequency : 0,\n\t\t\tunits: \"bpm\",\n\t\t});\n\t\tthis._bindClockEvents();\n\t\tthis.bpm = this._clock.frequency;\n\t\tthis._clock.frequency.multiplier = options.ppq;\n\t\tthis.bpm.value = options.bpm;\n\t\treadOnly(this, \"bpm\");\n\t\tthis._timeSignature = options.timeSignature;\n\n\t\t// SWING\n\t\tthis._swingTicks = options.ppq / 2; // 8n\n\t}\n\n\tstatic getDefaults(): TransportOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tbpm: 120,\n\t\t\tloopEnd: \"4m\" as Subdivision,\n\t\t\tloopStart: 0,\n\t\t\tppq: 192,\n\t\t\tswing: 0,\n\t\t\tswingSubdivision: \"8n\" as Subdivision,\n\t\t\ttimeSignature: 4,\n\t\t});\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tTICKS\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  called on every tick\n\t * @param  tickTime clock relative tick time\n\t */\n\tprivate _processTick(tickTime: Seconds, ticks: Ticks): void {\n\t\t// handle swing\n\t\tif (this._swingAmount > 0 &&\n\t\t\tticks % this._ppq !== 0 && // not on a downbeat\n\t\t\tticks % (this._swingTicks * 2) !== 0) {\n\t\t\t// add some swing\n\t\t\tconst progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n\t\t\tconst amount = Math.sin((progress) * Math.PI) * this._swingAmount;\n\t\t\ttickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n\t\t}\n\t\t// do the loop test\n\t\tif (this.loop) {\n\t\t\tif (ticks >= this._loopEnd) {\n\t\t\t\tthis.emit(\"loopEnd\", tickTime);\n\t\t\t\tthis._clock.setTicksAtTime(this._loopStart, tickTime);\n\t\t\t\tticks = this._loopStart;\n\t\t\t\tthis.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n\t\t\t\tthis.emit(\"loop\", tickTime);\n\t\t\t}\n\t\t}\n\t\t// invoke the timeline events scheduled on this tick\n\t\tthis._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSCHEDULABLE EVENTS\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Schedule an event along the timeline.\n\t * @param callback The callback to be invoked at the time.\n\t * @param time The time to invoke the callback at.\n\t * @return The id of the event which can be used for canceling the event.\n\t * @example\n\t * //trigger the callback when the Transport reaches the desired time\n\t * Transport.schedule(function(time){\n\t * \tenvelope.triggerAttack(time);\n\t * }, \"128i\");\n\t */\n\tschedule(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\ttime : new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Schedule a repeated event along the timeline. The event will fire\n\t * at the `interval` starting at the `startTime` and for the specified\n\t * `duration`.\n\t * @param  callback   The callback to invoke.\n\t * @param  interval   The duration between successive callbacks. Must be a positive number.\n\t * @param  startTime  When along the timeline the events should start being invoked.\n\t * @param  duration How long the event should repeat.\n\t * @return  The ID of the scheduled event. Use this to cancel the event.\n\t * @example\n\t * //a callback invoked every eighth note after the first measure\n\t * Transport.scheduleRepeat(callback, \"8n\", \"1m\");\n\t */\n\tscheduleRepeat(\n\t\tcallback: TransportCallback,\n\t\tinterval: Time | TimeClass,\n\t\tstartTime?: TransportTime | TransportTimeClass,\n\t\tduration: Time = Infinity,\n\t): number {\n\t\tconst event = new TransportRepeatEvent(this, {\n\t\t\tcallback,\n\t\t\tduration : new TimeClass(this.context, duration).toTicks(),\n\t\t\tinterval: new TimeClass(this.context, interval).toTicks(),\n\t\t\ttime : new TransportTimeClass(this.context, startTime).toTicks(),\n\t\t});\n\t\t// kick it off if the Transport is started\n\t\t// @ts-ignore\n\t\treturn this._addEvent(event, this._repeatedEvents);\n\t}\n\n\t/**\n\t *  Schedule an event that will be removed after it is invoked.\n\t * @param callback The callback to invoke once.\n\t * @param time The time the callback should be invoked.\n\t * @returns The ID of the scheduled event.\n\t */\n\tscheduleOnce(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\tonce : true,\n\t\t\ttime : new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Clear the passed in event id from the timeline\n\t * @param eventId The id of the event.\n\t */\n\tclear(eventId: number): this {\n\t\tif (this._scheduledEvents.hasOwnProperty(eventId)) {\n\t\t\tconst item = this._scheduledEvents[eventId.toString()];\n\t\t\titem.timeline.remove(item.event);\n\t\t\titem.event.dispose();\n\t\t\tdelete this._scheduledEvents[eventId.toString()];\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an event to the correct timeline. Keep track of the\n\t * timeline it was added to.\n\t * @returns the event id which was just added\n\t */\n\tprivate _addEvent(event: TransportEvent, timeline: Timeline<TransportEvent>): number {\n\t\tthis._scheduledEvents[event.id.toString()] = {\n\t\t\tevent,\n\t\t\ttimeline,\n\t\t};\n\t\ttimeline.add(event);\n\t\treturn event.id;\n\t}\n\n\t/**\n\t * Remove scheduled events from the timeline after\n\t * the given time. Repeated events will be removed\n\t * if their startTime is after the given time\n\t * @param after Clear all events after this time.\n\t */\n\tcancel(after: TransportTime = 0): this {\n\t\tconst computedAfter = this.toTicks(after);\n\t\tthis._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\tthis._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSTART/STOP/PAUSE\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Bind start/stop/pause events from the clock and emit them.\n\t */\n\tprivate _bindClockEvents(): void {\n\t\tthis._clock.on(\"start\", (time, offset) => {\n\t\t\toffset = new TicksClass(this.context, offset).toSeconds();\n\t\t\tthis.emit(\"start\", time, offset);\n\t\t});\n\n\t\tthis._clock.on(\"stop\", (time) => {\n\t\t\tthis.emit(\"stop\", time);\n\t\t});\n\n\t\tthis._clock.on(\"pause\", (time) => {\n\t\t\tthis.emit(\"pause\", time);\n\t\t});\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._clock.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the transport and all sources synced to the transport.\n\t * @param  time The time when the transport should start.\n\t * @param  offset The timeline offset to start the transport.\n\t * @example\n\t * //start the transport in one second starting at beginning of the 5th measure.\n\t * Transport.start(\"+1\", \"4:0:0\");\n\t */\n\tstart(time?: Time, offset?: TransportTime): this {\n\t\tlet offsetTicks;\n\t\tif (isDefined(offset)) {\n\t\t\toffsetTicks = this.toTicks(offset);\n\t\t}\n\t\t// start the clock\n\t\tthis._clock.start(time, offsetTicks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the transport and all sources synced to the transport.\n\t * @param time The time when the transport should stop.\n\t * @example\n\t * Transport.stop();\n\t */\n\tstop(time?: Time): this {\n\t\tthis._clock.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the transport and all sources synced to the transport.\n\t */\n\tpause(time?: Time): this {\n\t\tthis._clock.pause(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Toggle the current state of the transport. If it is\n\t * started, it will stop it, otherwise it will start the Transport.\n\t * @param  time The time of the event\n\t */\n\ttoggle(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._clock.getStateAtTime(time) !== \"started\") {\n\t\t\tthis.start(time);\n\t\t} else {\n\t\t\tthis.stop(time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSETTERS/GETTERS\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * The time signature as just the numerator over 4.\n\t * For example 4/4 would be just 4 and 6/8 would be 3.\n\t * @example\n\t * //common time\n\t * Transport.timeSignature = 4;\n\t * // 7/8\n\t * Transport.timeSignature = [7, 8];\n\t * //this will be reduced to a single number\n\t * Transport.timeSignature; //returns 3.5\n\t */\n\tget timeSignature(): TimeSignature {\n\t\treturn this._timeSignature;\n\t}\n\tset timeSignature(timeSig: TimeSignature) {\n\t\tif (isArray(timeSig)) {\n\t\t\ttimeSig = (timeSig[0] / timeSig[1]) * 4;\n\t\t}\n\t\tthis._timeSignature = timeSig;\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the starting position of the loop.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n\t}\n\tset loopStart(startPosition: Time) {\n\t\tthis._loopStart = this.toTicks(startPosition);\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the ending position of the loop.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n\t}\n\tset loopEnd(endPosition: Time) {\n\t\tthis._loopEnd = this.toTicks(endPosition);\n\t}\n\n\t/**\n\t * Set the loop start and stop at the same time.\n\t * @example\n\t * //loop over the first measure\n\t * Transport.setLoopPoints(0, \"1m\");\n\t * Transport.loop = true;\n\t */\n\tsetLoopPoints(startPosition: TransportTime, endPosition: TransportTime): this {\n\t\tthis.loopStart = startPosition;\n\t\tthis.loopEnd = endPosition;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n\t */\n\tget swing(): NormalRange {\n\t\treturn this._swingAmount;\n\t}\n\tset swing(amount: NormalRange) {\n\t\t// scale the values to a normal range\n\t\tthis._swingAmount = amount;\n\t}\n\n\t/**\n\t * Set the subdivision which the swing will be applied to.\n\t * The default value is an 8th note. Value must be less\n\t * than a quarter note.\n\t */\n\tget swingSubdivision(): Subdivision {\n\t\treturn new TicksClass(this.context, this._swingTicks).toNotation();\n\t}\n\tset swingSubdivision(subdivision: Subdivision) {\n\t\tthis._swingTicks = this.toTicks(subdivision);\n\t}\n\n\t/**\n\t *  The Transport's position in Bars:Beats:Sixteenths.\n\t *  Setting the value will jump to that position right away.\n\t */\n\tget position(): BarsBeatsSixteenths | Time {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\treturn new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n\t}\n\tset position(progress: Time) {\n\t\tconst ticks = this.toTicks(progress);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t *  The Transport's position in seconds\n\t *  Setting the value will jump to that position right away.\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._clock.seconds;\n\t}\n\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.frequency.timeToTicks(s, now);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t *  The Transport's loop position as a normalized value. Always\n\t *  returns 0 if the transport if loop is not true.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this.loop) {\n\t\t\tconst now = this.now();\n\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\treturn (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t *  The transports current tick position.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this._clock.ticks;\n\t}\n\tset ticks(t: Ticks) {\n\t\tif (this._clock.ticks !== t) {\n\t\t\tconst now = this.now();\n\t\t\t// stop everything synced to the transport\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis.emit(\"stop\", now);\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t\t// restart it with the new time\n\t\t\t\tthis.emit(\"start\", now, this.seconds);\n\t\t\t} else {\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn Math.round(this._clock.getTicksAtTime(time));\n\t}\n\n\t/**\n\t *  Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._clock.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t *  Pulses Per Quarter note. This is the smallest resolution\n\t *  the Transport timing supports. This should be set once\n\t *  on initialization and not set again. Changing this value\n\t *  after other objects have been created can cause problems.\n\t */\n\tget PPQ(): number {\n\t\treturn this._clock.frequency.multiplier;\n\t}\n\tset PPQ(ppq: number) {\n\t\tthis._clock.frequency.multiplier = ppq;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////////\n\t// \tSYNCING\n\t///////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Returns the time aligned to the next subdivision\n\t * of the Transport. If the Transport is not started,\n\t * it will return 0.\n\t * Note: this will not work precisely during tempo ramps.\n\t * @param  subdivision  The subdivision to quantize to\n\t * @return  The context time of the next subdivision.\n\t * @example\n\t * Transport.start(); //the transport must be started\n\t * Transport.nextSubdivision(\"4n\");\n\t */\n\tnextSubdivision(subdivision?: Time): Seconds {\n\t\tsubdivision = this.toTicks(subdivision);\n\t\tif (this.state !== \"started\") {\n\t\t\t// if the transport's not started, return 0\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tconst now = this.now();\n\t\t\t// the remainder of the current ticks and the subdivision\n\t\t\tconst transportPos = this.getTicksAtTime(now);\n\t\t\tconst remainingTicks = subdivision - transportPos % subdivision;\n\t\t\treturn this._clock.nextTickTime(remainingTicks, now);\n\t\t}\n\t}\n\n\t/**\n\t *  Attaches the signal to the tempo control signal so that\n\t *  any changes in the tempo will change the signal in the same\n\t *  ratio.\n\t *\n\t * @param signal\n\t * @param ratio Optionally pass in the ratio between the two signals.\n\t * \t\t\t\tOtherwise it will be computed based on their current values.\n\t */\n\tsyncSignal(signal: Signal<any>, ratio?: number): this {\n\t\tif (!ratio) {\n\t\t\t// get the sync ratio\n\t\t\tconst now = this.now();\n\t\t\tif (signal.getValueAtTime(now) !== 0) {\n\t\t\t\tconst bpm = this.bpm.getValueAtTime(now);\n\t\t\t\tconst computedFreq = 1 / (60 / bpm / this.PPQ);\n\t\t\t\tratio = signal.getValueAtTime(now) / computedFreq;\n\t\t\t} else {\n\t\t\t\tratio = 0;\n\t\t\t}\n\t\t}\n\t\tconst ratioSignal = new Gain(ratio);\n\t\t// @ts-ignore\n\t\tthis.bpm.connect(ratioSignal);\n\t\t// @ts-ignore\n\t\tratioSignal.connect(signal._param);\n\t\tthis._syncedSignals.push({\n\t\t\tinitial : signal.value,\n\t\t\tratio : ratioSignal,\n\t\t\tsignal,\n\t\t});\n\t\tsignal.value = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Unsyncs a previously synced signal from the transport's control.\n\t *  See Transport.syncSignal.\n\t */\n\tunsyncSignal(signal: Signal<any>): this {\n\t\tfor (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n\t\t\tconst syncedSignal = this._syncedSignals[i];\n\t\t\tif (syncedSignal.signal === signal) {\n\t\t\t\tsyncedSignal.ratio.dispose();\n\t\t\t\tsyncedSignal.signal.value = syncedSignal.initial;\n\t\t\t\tthis._syncedSignals.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._clock.dispose();\n\t\twritable(this, \"bpm\");\n\t\tthis._timeline.dispose();\n\t\tthis._repeatedEvents.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t///////////////////////////////////////////////////////////////////////\n\n\ton!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\tonce!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\toff!: (event: TransportEventNames, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Transport);\n\n///////////////////////////////////////////////////////////////////////////////\n// \tINITIALIZATION\n///////////////////////////////////////////////////////////////////////////////\n\nonContextInit(context => {\n\tcontext.transport = new Transport({ context });\n});\n\nonContextClose(context => {\n\tcontext.transport.dispose();\n});\n","import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels, Seconds, Time } from \"../core/type/Units\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline } from \"../core/util/StateTimeline\";\nimport { isUndef } from \"../core/util/TypeCheck\";\n\ntype onStopCallback = (source: Source<any>) => void;\n\nexport interface SourceOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n\tonstop: onStopCallback;\n}\n\n/**\n * Base class for sources. Sources have start/stop methods\n * and the ability to be synced to the\n * start/stop of this.context.transport.\n *\n * @example\n * //Multiple state change events can be chained together,\n * //but must be set in the correct order and with ascending times\n *\n * // OK\n * state.start().stop(\"+0.2\");\n * // AND\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n *\n * // BAD\n * state.stop(\"+0.2\").start();\n * // OR\n * state.start(\"+0.3\").stop(\"+0.2\");\n *\n */\nexport abstract class Source<Options extends SourceOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t *  The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The output note\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * Sources have no inputs\n\t */\n\tinput = undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * source.volume.value = -6;\n\t */\n\tvolume: Param<Decibels>;\n\n\t/**\n\t * The callback to invoke when the source is stopped.\n\t */\n\tonstop: onStopCallback;\n\n\t/**\n\t * \tKeep track of the scheduled state.\n\t */\n\tprotected _state: StateTimeline<{\n\t\tduration?: Seconds;\n\t\toffset?: Seconds;\n\t\t/**\n\t\t * Either the buffer is explicitly scheduled to end using the stop method,\n\t\t * or it's implicitly ended when the buffer is over.\n\t\t */\n\t\timplicitEnd?: boolean;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The synced `start` callback function from the transport\n\t */\n\tprotected _synced: boolean = false;\n\n\t/**\n\t *  Keep track of all of the scheduled event ids\n\t */\n\tprivate _scheduled: number[] = [];\n\n\t/**\n\t * Placeholder functions for syncing/unsyncing to transport\n\t */\n\tprivate _syncedStart: (time: Seconds, offset: Seconds) => void = noOp;\n\tprivate _syncedStop: (time: Seconds) => void = noOp;\n\n\tconstructor(options: SourceOptions) {\n\t\tsuper(options);\n\t\tthis._state.memory = 100;\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tmute: options.mute,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.onstop = options.onstop;\n\t}\n\n\tstatic getDefaults(): SourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tonstop: noOp,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t *  Returns the playback state of the source, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\tif (this._synced) {\n\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\treturn this._state.getValueAtTime(this.context.transport.seconds) as BasicPlaybackState;\n\t\t\t} else {\n\t\t\t\treturn \"stopped\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._state.getValueAtTime(this.now()) as BasicPlaybackState;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * source.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t// overwrite these functions\n\tprotected abstract _start(time: Time, offset?: Time, duration?: Time): void;\n\tprotected abstract _stop(time: Time): void;\n\tabstract restart(time: Time, offset?: Time, duration?: Time): this;\n\n\t/**\n\t * Ensure that the scheduled time is not before the current time.\n\t * Should only be used when scheduled unsynced.\n\t */\n\tprivate _clampToCurrentTime(time: Seconds): Seconds {\n\t\tif (this._synced) {\n\t\t\treturn time;\n\t\t} else {\n\t\t\treturn Math.max(time, this.context.currentTime);\n\t\t}\n\t}\n\n\t/**\n\t *  Start the source at the specified time. If no time is given,\n\t *  start the source now.\n\t * @param  time When the source should be started.\n\t * @example\n\t * source.start(\"+0.5\"); //starts the source 0.5 seconds from now\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\tthis.log(\"start\", computedTime);\n\t\t// if it's started, stop it and restart it\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis.restart(computedTime, offset, duration);\n\t\t} else {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (this._synced) {\n\t\t\t\t// add the offset time to the event\n\t\t\t\tconst event = this._state.get(computedTime);\n\t\t\t\tif (event) {\n\t\t\t\t\tevent.offset = this.toSeconds(defaultArg(offset, 0));\n\t\t\t\t\tevent.duration = duration ? this.toSeconds(duration) : undefined;\n\t\t\t\t}\n\t\t\t\tconst sched = this.context.transport.schedule(t => {\n\t\t\t\t\tthis._start(t, offset, duration);\n\t\t\t\t}, computedTime);\n\t\t\t\tthis._scheduled.push(sched);\n\n\t\t\t\t// if it's already started\n\t\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\t\tthis._syncedStart(this.now(), this.context.transport.seconds);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._start(computedTime, offset, duration);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the source at the specified time. If no time is given,\n\t *  stop the source now.\n\t * @param  time When the source should be stopped.\n\t * @example\n\t * source.stop(); // stops the source immediately\n\t */\n\tstop(time?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\tthis.log(\"stop\", computedTime);\n\t\tif (!this._synced) {\n\t\t\tthis._stop(computedTime);\n\t\t} else {\n\t\t\tconst sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\t\t\tthis._scheduled.push(sched);\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Sync the source to the Transport so that all subsequent\n\t *  calls to `start` and `stop` are synced to the TransportTime\n\t *  instead of the AudioContext time.\n\t *\n\t * @example\n\t * //sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n\t * source.sync().start(0).stop(0.3);\n\t * //start the transport.\n\t * this.context.transport.start();\n\t *\n\t * @example\n\t * //start the transport with an offset and the sync'ed sources\n\t * //will start in the correct position\n\t * source.sync().start(0.1);\n\t * //the source will be invoked with an offset of 0.4 = (0.5 - 0.1)\n\t * this.context.transport.start(\"+0.5\", 0.5);\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncedStart = (time, offset) => {\n\t\t\t\tif (offset > 0) {\n\t\t\t\t\t// get the playback state at that time\n\t\t\t\t\tconst stateEvent = this._state.get(offset);\n\t\t\t\t\t// listen for start events which may occur in the middle of the sync'ed time\n\t\t\t\t\tif (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n\t\t\t\t\t\t// get the offset\n\t\t\t\t\t\tconst startOffset = offset - this.toSeconds(stateEvent.time);\n\t\t\t\t\t\tlet duration;\n\t\t\t\t\t\tif (stateEvent.duration) {\n\t\t\t\t\t\t\tduration = this.toSeconds(stateEvent.duration) - startOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._syncedStop = time => {\n\t\t\t\tconst seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\t\t\t\tif (this._state.getValueAtTime(seconds) === \"started\") {\n\t\t\t\t\tthis._stop(time);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.context.transport.on(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"loopStart\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedStop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Unsync the source to the Transport. See Source.sync\n\t */\n\tunsync(): this {\n\t\tif (this._synced) {\n\t\t\tthis.context.transport.off(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"loopEnd\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.off(\"loopStart\", this._syncedStart);\n\t\t}\n\t\tthis._synced = false;\n\t\t// clear all of the scheduled ids\n\t\tthis._scheduled.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduled = [];\n\t\tthis._state.cancel(0);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.onstop = noOp;\n\t\tthis.unsync();\n\t\tthis._volume.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { GainFactor, Seconds, Time } from \"../core/type/Units\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState } from \"../core/util/StateTimeline\";\n\nexport type OneShotSourceCurve = \"linear\" | \"exponential\";\n\ntype onEndedCallback = (source: OneShotSource<any>) => void;\n\nexport interface OneShotSourceOptions extends ToneAudioNodeOptions {\n\tonended: onEndedCallback;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tcurve: OneShotSourceCurve;\n}\n\n/**\n * Base class for fire-and-forget nodes\n */\nexport abstract class OneShotSource<Options extends ToneAudioNodeOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t *  The callback to invoke after the\n\t *  source is done playing.\n\t */\n\tonended: onEndedCallback = noOp;\n\n\t/**\n\t * Sources do not have input nodes\n\t */\n\tinput: undefined;\n\n\t/**\n\t *  The start time\n\t */\n\tprotected _startTime: number = -1;\n\n\t/**\n\t *  The stop time\n\t */\n\tprotected _stopTime: number = -1;\n\n\t/**\n\t * The id of the timeout\n\t */\n\tprivate _timeout: number = -1;\n\n\t/**\n\t * The public output node\n\t */\n\toutput: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain : 0,\n\t});\n\n\t/**\n\t *  The output gain node.\n\t */\n\tprotected _gainNode = this.output;\n\n\t/**\n\t *  The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t *  The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tprotected _curve: OneShotSourceCurve;\n\n\tconstructor(options: OneShotSourceOptions) {\n\t\tsuper(options);\n\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t\tthis._curve = options.curve;\n\t\tthis.onended = options.onended;\n\t}\n\n\tstatic getDefaults(): OneShotSourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tcurve: \"linear\" as OneShotSourceCurve,\n\t\t\tfadeIn : 0,\n\t\t\tfadeOut: 0,\n\t\t\tonended : noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Stop the source node\n\t */\n\tprotected abstract _stopSource(time: Seconds): void;\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the node\n\t */\n\tprotected abstract start(time?: Time): this;\n\t/**\n\t * Start the source at the given time\n\t * @param  time When to start the source\n\t */\n\tprotected _startGain(time: Seconds, gain: GainFactor = 1): this {\n\t\tthis.assert(this._startTime === -1, \"Source cannot be started more than once\");\n\t\t// apply a fade in envelope\n\t\tconst fadeInTime = this.toSeconds(this._fadeIn);\n\n\t\t// record the start time\n\t\tthis._startTime = time + fadeInTime;\n\t\tthis._startTime = Math.max(this._startTime, this.context.currentTime);\n\n\t\t// schedule the envelope\n\t\tif (fadeInTime > 0) {\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._gainNode.gain.setValueAtTime(gain, time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source node at the given time.\n\t * @param time When to stop the source\n\t */\n\tstop(time?: Time): this {\n\t\tthis.log(\"stop\", time);\n\t\tthis._stopGain(this.toSeconds(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the given time\n\t * @param  time When to stop the source\n\t */\n\tprotected _stopGain(time: Seconds): this {\n\t\tthis.assert(this._startTime !== -1, \"'start' must be called before 'stop'\");\n\t\t// cancel the previous stop\n\t\tthis.cancelStop();\n\n\t\t// the fadeOut time\n\t\tconst fadeOutTime = this.toSeconds(this._fadeOut);\n\n\t\t// schedule the stop callback\n\t\tthis._stopTime = this.toSeconds(time) + fadeOutTime;\n\t\tthis._stopTime = Math.max(this._stopTime, this.context.currentTime);\n\t\tif (fadeOutTime > 0) {\n\t\t\t// start the fade out curve at the given time\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// stop any ongoing ramps, and set the value to 0\n\t\t\tthis._gainNode.gain.cancelAndHoldAtTime(time);\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t}\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._timeout = this.context.setTimeout(() => {\n\t\t\t// allow additional time for the exponential curve to fully decay\n\t\t\tconst additionalTail = this._curve === \"exponential\" ? fadeOutTime * 2 : 0;\n\t\t\tthis._stopSource(this.now() + additionalTail);\n\t\t\tthis._onended();\n\t\t}, this._stopTime - this.context.now());\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the onended callback\n\t */\n\tprotected _onended(): void {\n\t\tif (this.onended !== noOp) {\n\t\t\tthis.onended(this);\n\t\t\t// overwrite onended to make sure it only is called once\n\t\t\tthis.onended = noOp;\n\t\t\t// dispose when it's ended to free up for garbage collection\n\t\t\tsetTimeout(() => this.dispose(), 1000);\n\t\t}\n\t}\n\n\t/**\n\t *  Get the playback state at the given time\n\t */\n\tgetStateAtTime = function(time: Time): BasicPlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._startTime !== -1 && computedTime >= this._startTime &&\n\t\t\t(this._stopTime === -1 || computedTime <= this._stopTime)) {\n\t\t\treturn \"started\";\n\t\t} else {\n\t\t\treturn \"stopped\";\n\t\t}\n\t};\n\n\t/**\n\t * Get the playback state at the current time\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t *  Cancel a scheduled stop event\n\t */\n\tcancelStop(): this {\n\t\tthis.log(\"cancelStop\");\n\t\tthis.assert(this._startTime !== -1, \"Source is not started\");\n\t\t// cancel the stop envelope\n\t\tthis._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._stopTime = -1;\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../../core/Connect\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { GainFactor, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { OneShotSource, OneShotSourceCurve, OneShotSourceOptions } from \"../OneShotSource\";\n\nexport type ToneBufferSourceCurve = OneShotSourceCurve;\n\ninterface ToneBufferSourceOptions extends OneShotSourceOptions {\n\tbuffer: ToneAudioBuffer;\n\tcurve: ToneBufferSourceCurve;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tloop: boolean;\n\tonload: () => void;\n}\n\n/**\n *  Wrapper around the native BufferSourceNode.\n */\nexport class ToneBufferSource extends OneShotSource<ToneBufferSourceOptions> {\n\n\tname = \"ToneBufferSource\";\n\n\t/**\n\t *  The oscillator\n\t */\n\tprivate _source = this.context.createBufferSource();\n\tprotected _internalChannels = [this._source];\n\n\t/**\n\t *  The frequency of the oscillator\n\t */\n\treadonly playbackRate: Param<Positive>;\n\n\t/**\n\t * The private instance of the buffer object\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * indicators if the source has started/stopped\n\t */\n\tprivate _sourceStarted: boolean = false;\n\tprivate _sourceStopped: boolean = false;\n\n\t/**\n\t * @param buffer The buffer to play\n\t * @param onload The callback to invoke when the buffer is done playing.\n\t */\n\tconstructor(buffer?: ToneAudioBuffer | AudioBuffer | string, onload?: () => void);\n\tconstructor(options?: Partial<ToneBufferSourceOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]));\n\t\tconst options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\t\tthis._source.onended = () => this._stopSource();\n\n\t\t/**\n\t\t *  The playbackRate of the buffer\n\t\t */\n\t\tthis.playbackRate = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._source.playbackRate,\n\t\t\tunits : \"positive\",\n\t\t\tvalue : options.playbackRate,\n\t\t});\n\n\t\t// set some values initially\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis._buffer = new ToneAudioBuffer(options.buffer, options.onload);\n\n\t\tthis._internalChannels.push(this._source);\n\t}\n\n\tstatic getDefaults(): ToneBufferSourceOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tbuffer: new ToneAudioBuffer(),\n\t\t\tloop: false,\n\t\t\tloopEnd : 0,\n\t\t\tloopStart : 0,\n\t\t\tonload: noOp,\n\t\t\tplaybackRate : 1,\n\t\t});\n\t}\n\n\t/**\n\t *  The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(t: Time) {\n\t\tthis._fadeIn = t;\n\t}\n\n\t/**\n\t *  The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(t: Time) {\n\t\tthis._fadeOut = t;\n\t}\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tget curve(): ToneBufferSourceCurve {\n\t\treturn this._curve;\n\t}\n\tset curve(t) {\n\t\tthis._curve = t;\n\t}\n\n\t/**\n\t *  Start the buffer\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration\n\t *                   is given, it will default to the full length\n\t *                   of the sample (minus any offset)\n\t * @param  gain  The gain to play the buffer back at.\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time, gain: GainFactor = 1): this {\n\t\tthis.assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n\t\tconst computedTime = this.toSeconds(time);\n\n\t\t// apply the gain envelope\n\t\tthis._startGain(computedTime, gain);\n\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this.loop) {\n\t\t\toffset = defaultArg(offset, this.loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\t\t// make sure the offset is not less than 0\n\t\tlet computedOffset = Math.max(this.toSeconds(offset), 0);\n\n\t\t// start the buffer source\n\t\tif (this.loop) {\n\t\t\t// modify the offset if it's greater than the loop time\n\t\t\tconst loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\t\tconst loopStart = this.toSeconds(this.loopStart);\n\t\t\tconst loopDuration = loopEnd - loopStart;\n\t\t\t// move the offset back\n\t\t\tif (computedOffset >= loopEnd) {\n\t\t\t\tcomputedOffset = ((computedOffset - loopStart) % loopDuration) + loopStart;\n\t\t\t}\n\t\t}\n\n\t\t// this.buffer.loaded would have return false if the AudioBuffer was undefined\n\t\tthis._source.buffer = this.buffer.get() as AudioBuffer;\n\t\tthis._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\tif (computedOffset < this.buffer.duration) {\n\t\t\tthis._sourceStarted = true;\n\t\t\tthis._source.start(computedTime, computedOffset);\n\t\t}\n\n\t\t// if a duration is given, schedule a stop\n\t\tif (isDefined(duration)) {\n\t\t\tlet computedDur = this.toSeconds(duration);\n\t\t\t// make sure it's never negative\n\t\t\tcomputedDur = Math.max(computedDur, 0);\n\t\t\tthis.stop(computedTime + computedDur);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tif (!this._sourceStopped) {\n\t\t\tthis._sourceStopped = true;\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._onended();\n\t\t}\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._source.loopStart;\n\t}\n\tset loopStart(loopStart: Time) {\n\t\tthis._source.loopStart = this.toSeconds(loopStart);\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._source.loopEnd;\n\t}\n\tset loopEnd(loopEnd: Time) {\n\t\tthis._source.loopEnd = this.toSeconds(loopEnd);\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer: ToneAudioBuffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._source.loop;\n\t}\n\tset loop(loop: boolean) {\n\t\tthis._source.loop = loop;\n\t\tif (this._sourceStarted) {\n\t\t\tthis.cancelStop();\n\t\t}\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._source.onended = null;\n\t\tthis._source.disconnect();\n\t\tthis._buffer.dispose();\n\t\tthis.playbackRate.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { Positive, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Source, SourceOptions } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/BufferSource\";\n\nexport type NoiseType = \"white\" | \"brown\" | \"pink\";\n\nexport interface NoiseOptions extends SourceOptions {\n\ttype: NoiseType;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n}\n\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * //initialize the noise and start\n * var noise = new Noise(\"pink\").start();\n *\n * //make an autofilter to shape the noise\n * var autoFilter = new Tone.AutoFilter({\n * \t\"frequency\" : \"8m\",\n * \t\"min\" : 800,\n * \t\"max\" : 15000\n * }).connect(Tone.Master);\n *\n * //connect the noise\n * noise.connect(autoFilter);\n * //start the autofilter LFO\n * autoFilter.start()\n */\nexport class Noise extends Source<NoiseOptions> {\n\n\treadonly name = \"Noise\";\n\n\t/**\n\t * Private reference to the source\n\t */\n\tprivate _source: ToneBufferSource | null = null;\n\n\t/**\n\t * private reference to the type\n\t */\n\tprivate _type!: NoiseType;\n\n\t/**\n\t *  The playback rate of the noise. Affects\n\t *  the \"frequency\" of the noise.\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t *  The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t *  The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * @param type the noise type (white|pink|brown)\n\t */\n\tconstructor(type?: NoiseType);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<NoiseOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n\t\tconst options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.type = options.type;\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): NoiseOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tplaybackRate: 1,\n\t\t\ttype: \"white\" as NoiseType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n\t * @example\n\t * noise.type = \"white\";\n\t */\n\tget type(): NoiseType {\n\t\treturn this._type;\n\t}\n\tset type(type: NoiseType) {\n\t\tthis.assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\t\tif (this._type !== type) {\n\t\t\tthis._type = type;\n\t\t\t// if it's playing, stop and restart it\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst now = this.now();\n\t\t\t\tthis._stop(now);\n\t\t\t\tthis._start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  The playback rate of the noise. Affects\n\t *  the \"frequency\" of the noise.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate: Positive) {\n\t\tthis._playbackRate = rate;\n\t\tif (this._source) {\n\t\t\tthis._source.playbackRate.value = rate;\n\t\t}\n\t}\n\n\t/**\n\t *  internal start method\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst buffer = _noiseBuffers[this._type];\n\t\tthis._source = new ToneBufferSource({\n\t\t\tbuffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn: this._fadeIn,\n\t\t\tfadeOut: this._fadeOut,\n\t\t\tloop: true,\n\t\t\tonended: () => this.onstop(this),\n\t\t\tplaybackRate: this._playbackRate,\n\t\t}).connect(this.output);\n\t\tthis._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n\t}\n\n\t/**\n\t * internal stop method\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tif (this._source) {\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._source = null;\n\t\t}\n\t}\n\n\t/**\n\t *  The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(time) {\n\t\tthis._fadeIn = time;\n\t\tif (this._source) {\n\t\t\tthis._source.fadeIn = this._fadeIn;\n\t\t}\n\t}\n\n\t/**\n\t *  The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(time) {\n\t\tthis._fadeOut = time;\n\t\tif (this._source) {\n\t\t\tthis._source.fadeOut = this._fadeOut;\n\t\t}\n\t}\n\n\t/**\n\t * Restarts the noise.\n\t * @param  time When to restart the noise.\n\t */\n\trestart(time?: Time): this {\n\t\t// TODO could be optimized by cancelling the buffer source 'stop'\n\t\t// stop and restart\n\t\tthis._stop(time);\n\t\tthis._start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._source) {\n\t\t\tthis._source.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////\n// THE NOISE BUFFERS\n///////////////////////////////////////////////////////////////////////////\n\n// Noise buffer stats\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n\n/**\n * The cached noise buffers\n */\ninterface NoiseCache {\n\t[key: string]: ToneAudioBuffer | null;\n}\n\n/**\n * Cache the noise buffers\n */\nconst _noiseCache: NoiseCache = {\n\tbrown: null,\n\tpink: null,\n\twhite: null,\n};\n\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nconst _noiseBuffers = {\n\tget brown(): ToneAudioBuffer {\n\t\tif (!_noiseCache.brown) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet lastOut = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tchannel[i] = (lastOut + (0.02 * white)) / 1.02;\n\t\t\t\t\tlastOut = channel[i];\n\t\t\t\t\tchannel[i] *= 3.5; // (roughly) compensate for gain\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.brown;\n\t},\n\n\tget pink(): ToneAudioBuffer {\n\t\tif (!_noiseCache.pink) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\t// tslint:disable-next-line: one-variable-per-declaration\n\t\t\t\tlet b0, b1, b2, b3, b4, b5, b6;\n\t\t\t\tb0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tb0 = 0.99886 * b0 + white * 0.0555179;\n\t\t\t\t\tb1 = 0.99332 * b1 + white * 0.0750759;\n\t\t\t\t\tb2 = 0.96900 * b2 + white * 0.1538520;\n\t\t\t\t\tb3 = 0.86650 * b3 + white * 0.3104856;\n\t\t\t\t\tb4 = 0.55000 * b4 + white * 0.5329522;\n\t\t\t\t\tb5 = -0.7616 * b5 - white * 0.0168980;\n\t\t\t\t\tchannel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n\t\t\t\t\tchannel[i] *= 0.11; // (roughly) compensate for gain\n\t\t\t\t\tb6 = white * 0.115926;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.pink;\n\t},\n\n\tget white(): ToneAudioBuffer {\n\t\tif (!_noiseCache.white) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tchannel[i] = Math.random() * 2 - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.white;\n\t},\n};\n","import { AbstractParam } from \"../core/context/AbstractParam\";\nimport { Param } from \"../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connect } from \"../core/context/ToneAudioNode\";\nimport { Time, Unit, UnitName } from \"../core/type/Units\";\nimport { isAudioParam } from \"../core/util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\n\nexport interface SignalOptions<Type> extends ToneAudioNodeOptions {\n\tvalue: Type;\n\tunits: UnitName;\n\tconvert: boolean;\n}\n\n/**\n * A signal is an audio-rate value. Tone.Signal is a core component of the library.\n * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n * has all of the methods available to native Web Audio\n * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n * as well as additional conveniences. Read more about working with signals\n * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n *\n * @example\n * const signal = new Tone.Signal(10);\n */\nexport class Signal<Type extends Unit = number> extends ToneAudioNode<SignalOptions<any>>\nimplements AbstractParam<Type> {\n\n\treadonly name: string = \"Signal\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection.\n\t */\n\treadonly override: boolean = true;\n\n\t/**\n\t * The constant source node which generates the signal\n\t */\n\tprotected _constantSource: ConstantSourceNode = this.context.createConstantSource();\n\treadonly output: OutputNode = this._constantSource;\n\tprotected _param: Param<Type>;\n\treadonly input: InputNode;\n\n\t/**\n\t * @param value Initial value of the signal\n\t * @param units The unit name, e.g. \"frequency\"\n\t */\n\tconstructor(value?: Type, units?: UnitName);\n\tconstructor(options?: Partial<SignalOptions<Type>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n\n\t\tconst options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]) as SignalOptions<Type>;\n\n\t\tthis._constantSource.start(0);\n\t\tthis.input = this._param = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tparam: this._constantSource.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.value,\n\t\t});\n\t}\n\n\tstatic getDefaults(): SignalOptions<any> {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannelCount: 1,\n\t\t\tchannelCountMode: \"explicit\",\n\t\t\tchannelInterpretation: \"discrete\",\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t\tvalue: 0,\n\t\t}) as SignalOptions<any>;\n\t}\n\n\tconnect(destination: InputNode, outputNum: number = 0, inputNum: number = 0): this {\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._param.dispose();\n\t\tthis._constantSource.stop(this.now());\n\t\tthis._constantSource.disconnect();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// ABSTRACT PARAM INTERFACE\n\t// just a proxy for the ConstantSourceNode's offset AudioParam\n\t// all docs are generated from AbstractParam.ts\n\t///////////////////////////////////////////////////////////////////////////\n\n\tsetValueAtTime(value: Type, time: Time): this {\n\t\tthis._param.setValueAtTime(value, time);\n\t\treturn this;\n\t}\n\tgetValueAtTime(time: Time): Type {\n\t\treturn this._param.getValueAtTime(time);\n\t}\n\tsetRampPoint(time: Time): this {\n\t\tthis._param.setRampPoint(time);\n\t\treturn this;\n\t}\n\tlinearRampToValueAtTime(value: Type, time: Time): this {\n\t\tthis._param.linearRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampToValueAtTime(value: Type, time: Time): this {\n\t\tthis._param.exponentialRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.exponentialRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\tlinearRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.linearRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\ttargetRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.targetRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\texponentialApproachValueAtTime(value: Type, time: Time, rampTime: Time): this {\n\t\tthis._param.exponentialApproachValueAtTime(value, time, rampTime);\n\t\treturn this;\n\t}\n\tsetTargetAtTime(value: Type, startTime: Time, timeConstant: number): this {\n\t\tthis._param.setTargetAtTime(value, startTime, timeConstant);\n\t\treturn this;\n\t}\n\tsetValueCurveAtTime(values: Type[], startTime: Time, duration: Time, scaling?: number): this {\n\t\tthis._param.setValueCurveAtTime(values, startTime, duration, scaling);\n\t\treturn this;\n\t}\n\tcancelScheduledValues(time: Time): this {\n\t\tthis._param.cancelScheduledValues(time);\n\t\treturn this;\n\t}\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tthis._param.cancelAndHoldAtTime(time);\n\t\treturn this;\n\t}\n\trampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.rampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\n\tget value(): Type {\n\t\treturn this._param.value;\n\t}\n\tset value(value: Type) {\n\t\tthis._param.value = value;\n\t}\n\n\tget convert(): boolean {\n\t\treturn this._param.convert;\n\t}\n\tset convert(convert: boolean) {\n\t\tthis._param.convert = convert;\n\t}\n\n\tget units(): UnitName {\n\t\treturn this._param.units;\n\t}\n\n\tget overridden(): boolean {\n\t\treturn this._param.overridden;\n\t}\n\tset overridden(overridden: boolean) {\n\t\tthis._param.overridden = overridden;\n\t}\n\n\tget maxValue(): number {\n\t\treturn this._param.maxValue;\n\t}\n\tget minValue(): number {\n\t\treturn this._param.minValue;\n\t}\n}\n\n/**\n * When connecting from a signal, it's necessary to zero out the node destination\n * node if that node is also a signal. If the destination is not 0, then the values\n * will be summed. This method insures that the output of the destination signal will\n * be the same as the source signal, making the destination signal a pass through node.\n * @param signal The output signal to connect from\n * @param destination the destination to connect to\n * @param outputNum the optional output number\n * @param inputNum the input number\n */\nexport function connectSignal(signal: OutputNode, destination: InputNode, outputNum?: number, inputNum?: number): void {\n\tif (destination instanceof Param || isAudioParam(destination) ||\n\t\t(destination instanceof Signal && destination.override)) {\n\t\t// cancel changes\n\t\tdestination.cancelScheduledValues(0);\n\t\t// reset the value\n\t\tdestination.setValueAtTime(0, 0);\n\t\t// mark the value as overridden\n\t\tif (destination instanceof Signal) {\n\t\t\tdestination.overridden = true;\n\t\t}\n\t}\n\tconnect(signal, destination, outputNum, inputNum);\n}\n","import { connect } from \"../../core/Connect\";\nimport { Param } from \"../../core/context/Param\";\nimport { Cents, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource, OneShotSourceOptions } from \"../OneShotSource\";\n\ninterface ToneOscillatorNodeOptions extends OneShotSourceOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\ttype: OscillatorType;\n}\n\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[[Oscillator]] is better for most use-cases***\n */\nexport class ToneOscillatorNode extends OneShotSource<ToneOscillatorNodeOptions> {\n\n\treadonly name = \"ToneOscillatorNode\";\n\n\t/**\n\t *  The oscillator\n\t */\n\tprivate _oscillator = this.context.createOscillator();\n\tprotected _internalChannels = [this._oscillator];\n\n\t/**\n\t *  The frequency of the oscillator\n\t */\n\treadonly frequency: Param<Frequency>;\n\n\t/**\n\t *  The detune of the oscillator\n\t */\n\treadonly detune: Param<Cents>;\n\n\t/**\n\t * @param  frequency   The frequency value\n\t * @param  type  The basic oscillator type\n\t */\n\tconstructor(\n\t\tfrequency: Frequency,\n\t\ttype: OscillatorType,\n\t);\n\tconstructor(options?: Partial<ToneOscillatorNodeOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tconnect(this._oscillator, this._gainNode);\n\n\t\tthis.type = options.type;\n\n\t\tthis.frequency = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._oscillator.frequency,\n\t\t\tunits : \"frequency\",\n\t\t\tvalue : options.frequency,\n\t\t});\n\n\t\tthis.detune = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam : this._oscillator.detune,\n\t\t\tunits : \"cents\",\n\t\t\tvalue : options.detune,\n\t\t});\n\t}\n\n\tstatic getDefaults(): ToneOscillatorNodeOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\ttype: \"sine\" as OscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * Start the oscillator node at the given time\n\t * @param  time When to start the oscillator\n\t */\n\tstart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tthis._startGain(computedTime);\n\t\tthis._oscillator.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\t/**\n\t * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n\t * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n\t */\n\tsetPeriodicWave(periodicWave: PeriodicWave): this {\n\t\tthis._oscillator.setPeriodicWave(periodicWave);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n\t */\n\tget type(): OscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type: OscillatorType) {\n\t\tthis._oscillator.type = type;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this.state === \"started\") {\n\t\t\tthis.stop();\n\t\t}\n\t\tthis._oscillator.disconnect();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioRange, Cents, Degrees, Frequency, Radians, Time } from \"../../core/type/Units\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { ToneOscillatorConstructorOptions, ToneOscillatorInterface,\n\tToneOscillatorOptions, ToneOscillatorType } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./OscillatorNode\";\n\n/**\n *  Oscillator supports a number of features including\n *  phase rotation, multiple oscillator types (see Oscillator.type),\n *  and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * //make and start a 440hz sine tone\n * var osc = new Oscillator(440, \"sine\").toDestination().start();\n */\nexport class Oscillator extends Source<ToneOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"Oscillator\";\n\n\t/**\n\t *  the main oscillator\n\t */\n\tprivate _oscillator: ToneOscillatorNode | null = null;\n\n\t/**\n\t *  The frequency control.\n\t */\n\tfrequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune control signal.\n\t */\n\tdetune: Signal<Cents>;\n\n\t/**\n\t *  the periodic wave\n\t */\n\tprivate _wave?: PeriodicWave;\n\n\t/**\n\t *  The partials of the oscillator\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t *  The number of partials to limit or extend the periodic wave by\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t *  the phase of the oscillator between 0 - 360\n\t */\n\tprivate _phase!: Radians;\n\n\t/**\n\t *  the type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * @param frequency Starting frequency\n\t * @param type The oscillator type. Read more about type below.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType);\n\tconstructor(options?: Partial<ToneOscillatorConstructorOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal<Frequency>({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\tthis.detune = new Signal<Cents>({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, \"detune\");\n\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\t\tthis._type = options.type;\n\n\t\tif (options.partialCount && options.type !== \"custom\") {\n\t\t\tthis._type = this.baseType + options.partialCount.toString() as ToneOscillatorType;\n\t\t}\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): ToneOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tpartialCount: 0,\n\t\t\tpartials: [],\n\t\t\tphase: 0,\n\t\t\ttype: \"sine\",\n\t\t}) as ToneOscillatorOptions;\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// new oscillator with previous values\n\t\tconst oscillator = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\tonended: () => this.onstop(this),\n\t\t});\n\t\tthis._oscillator = oscillator;\n\t\tif (this._wave) {\n\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t} else {\n\t\t\tthis._oscillator.type = this._type as OscillatorType;\n\t\t}\n\t\t// connect the control signal to the oscillator frequency & detune\n\t\tthis._oscillator.connect(this.output);\n\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\tthis.detune.connect(this._oscillator.detune);\n\n\t\t// start the oscillator\n\t\tthis._oscillator.start(computedTime);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.stop(computedTime);\n\t\t}\n\t}\n\n\t/**\n\t * Restart the oscillator. Does not stop the oscillator, but instead\n\t * just cancels any scheduled 'stop' from being invoked.\n\t */\n\trestart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"restart\", computedTime);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.cancelStop();\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n\t *  will also affect the oscillators frequency.\n\t * @example\n\t * Tone.Transport.bpm.value = 120;\n\t * osc.frequency.value = 440;\n\t * //the ration between the bpm and the frequency will be maintained\n\t * osc.syncFrequency();\n\t * Tone.Transport.bpm.value = 240;\n\t * // the frequency of the oscillator is doubled to 880\n\t */\n\tsyncFrequency(): this {\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Unsync the oscillator's frequency from the Transport.\n\t *  See Oscillator.syncFrequency\n\t */\n\tunsyncFrequency(): this {\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cache the periodic waves to avoid having to redo computations\n\t */\n\tprivate static _periodicWaveCache: Array<{\n\t\tpartials: number[];\n\t\tphase: number;\n\t\ttype: string;\n\t\tpartialCount: number;\n\t\treal: Float32Array,\n\t\timag: Float32Array,\n\t}> = [];\n\n\t/**\n\t * Get a cached periodic wave. Avoids having to recompute\n\t * the oscillator values when they have already been computed\n\t * with the same values.\n\t */\n\tprivate _getCachedPeriodicWave(): [Float32Array, Float32Array] | undefined {\n\t\tif (this._type === \"custom\") {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn  description.phase === this._phase &&\n\t\t\t\t\tdeepEquals(description.partials, this._partials);\n\t\t\t});\n\t\t\treturn oscProps && [oscProps.real, oscProps.imag];\n\t\t} else {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn  description.type === this._type &&\n\t\t\t\t\tdescription.phase === this._phase;\n\t\t\t});\n\t\t\tthis._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n\t\t\treturn oscProps && [oscProps.real, oscProps.imag];\n\t\t}\n\t}\n\n\t/* tslint:disable */\n\t/**\n\t * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of\n\t * setting the first x number of partials of the oscillator. For example: \"sine4\" would\n\t * set be the first 4 partials of the sine wave and \"triangle8\" would set the first\n\t * 8 partials of the triangle wave.\n\t * <br><br>\n\t * Uses PeriodicWave internally even for native types so that it can set the phase.\n\t * PeriodicWave equations are from the\n\t * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).\n\t *\n\t * @memberOf Oscillator#\n\t * @type {string}\n\t * @name type\n\t * @example\n\t * //set it to a square wave\n\t * osc.type = \"square\";\n\t * @example\n\t * //set the first 6 partials of a sawtooth wave\n\t * osc.type = \"sawtooth6\";\n\t */\n\t/* tslint:enable */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._type = type;\n\t\tconst isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\t\tif (this._phase === 0 && isBasicType) {\n\t\t\tthis._wave = undefined;\n\t\t\tthis._partialCount = 0;\n\t\t\t// just go with the basic approach\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\t// already tested that it's a basic type\n\t\t\t\tthis._oscillator.type = type as OscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// first check if the value is cached\n\t\t\tconst cache = this._getCachedPeriodicWave();\n\t\t\tif (isDefined(cache)) {\n\t\t\t\tconst [real, imag] = cache;\n\t\t\t\tthis._wave = this.context.createPeriodicWave(real, imag);\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst [real, imag] = this._getRealImaginary(type, this._phase);\n\t\t\t\tconst periodicWave = this.context.createPeriodicWave(real, imag);\n\t\t\t\tthis._wave = periodicWave;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t\t// set the cache\n\t\t\t\tOscillator._periodicWaveCache.push({\n\t\t\t\t\timag,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tpartials: this._partials,\n\t\t\t\t\tphase: this._phase,\n\t\t\t\t\treal,\n\t\t\t\t\ttype: this._type,\n\t\t\t\t});\n\t\t\t\tif (Oscillator._periodicWaveCache.length > 100) {\n\t\t\t\t\tOscillator._periodicWaveCache.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn (this._type as string).replace(this.partialCount.toString(), \"\") as OscillatorType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tif (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n\t\t\tthis.type = baseType + this.partialCount as ToneOscillatorType;\n\t\t} else {\n\t\t\tthis.type = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t * @example\n\t * osc.type = 'sine'\n\t * osc.partialCount = 3\n\t * //is equivalent to\n\t * osc.type = 'sine3'\n\t */\n\tget partialCount(): number {\n\t\treturn this._partialCount;\n\t}\n\tset partialCount(p: number) {\n\t\tlet type = this._type;\n\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\t\tif (partial) {\n\t\t\ttype = partial[1] as OscillatorType;\n\t\t}\n\t\tif (this._type !== \"custom\") {\n\t\t\tif (p === 0) {\n\t\t\t\tthis.type = type;\n\t\t\t} else {\n\t\t\t\tthis.type = type + p.toString() as ToneOscillatorType;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  Get the object's attributes. Given no arguments get\n\t *  will return all available object properties and their corresponding\n\t *  values.\n\t */\n\tget(): ToneOscillatorOptions {\n\t\tconst values = super.get();\n\t\tif (values.type !== \"custom\") {\n\t\t\tdelete values.partials;\n\t\t}\n\t\treturn values;\n\t}\n\n\t/**\n\t * Returns the real and imaginary components based\n\t * on the oscillator type.\n\t * @returns [real: Float32Array, imaginary: Float32Array]\n\t */\n\tprivate _getRealImaginary(type: ToneOscillatorType, phase: Radians): Float32Array[] {\n\t\tconst fftSize = 4096;\n\t\tlet periodicWaveSize = fftSize / 2;\n\n\t\tconst real = new Float32Array(periodicWaveSize);\n\t\tconst imag = new Float32Array(periodicWaveSize);\n\n\t\tlet partialCount = 1;\n\t\tif (type === \"custom\") {\n\t\t\tpartialCount = this._partials.length + 1;\n\t\t\tthis._partialCount = this._partials.length;\n\t\t\tperiodicWaveSize = partialCount;\n\t\t\t// if the partial count is 0, don't bother doing any computation\n\t\t\tif (this._partials.length === 0 ) {\n\t\t\t\treturn [real, imag];\n\t\t\t}\n\t\t} else {\n\t\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\t\t\tif (partial) {\n\t\t\t\tpartialCount = parseInt(partial[2], 10) + 1;\n\t\t\t\tthis._partialCount = parseInt(partial[2], 10);\n\t\t\t\ttype = partial[1] as ToneOscillatorType;\n\t\t\t\tpartialCount = Math.max(partialCount, 2);\n\t\t\t\tperiodicWaveSize = partialCount;\n\t\t\t} else {\n\t\t\t\tthis._partialCount = 0;\n\t\t\t}\n\t\t\tthis._partials = [];\n\t\t}\n\n\t\t// tslint:disable: no-bitwise\n\t\tfor (let n = 1; n < periodicWaveSize; ++n) {\n\t\t\tconst piFactor = 2 / (n * Math.PI);\n\t\t\tlet b;\n\t\t\tswitch (type) {\n\t\t\t\tcase \"sine\":\n\t\t\t\t\tb = (n <= partialCount) ? 1 : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"square\":\n\t\t\t\t\tb = (n & 1) ? 2 * piFactor : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sawtooth\":\n\t\t\t\t\tb = piFactor * ((n & 1) ? 1 : -1);\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"triangle\":\n\t\t\t\t\tif (n & 1) {\n\t\t\t\t\t\tb = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"custom\":\n\t\t\t\t\tb = this._partials[n - 1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new TypeError(\"Oscillator: invalid type: \" + type);\n\t\t\t}\n\t\t\tif (b !== 0) {\n\t\t\t\treal[n] = -b * Math.sin(phase * n);\n\t\t\t\timag[n] = b * Math.cos(phase * n);\n\t\t\t} else {\n\t\t\t\treal[n] = 0;\n\t\t\t\timag[n] = 0;\n\t\t\t}\n\t\t}\n\t\treturn [real, imag];\n\t}\n\n\t/**\n\t *  Compute the inverse FFT for a given phase.\n\t */\n\tprivate _inverseFFT(real: Float32Array, imag: Float32Array, phase: Radians): number {\n\t\tlet sum = 0;\n\t\tconst len = real.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tsum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n\t\t}\n\t\treturn sum;\n\t}\n\n\t/**\n\t *  Returns the initial value of the oscillator.\n\t */\n\tprotected _getInitialValue(): AudioRange {\n\t\tconst [real, imag] = this._getRealImaginary(this._type, 0);\n\t\tlet maxValue = 0;\n\t\tconst twoPi = Math.PI * 2;\n\t\t// check for peaks in 8 places\n\t\tfor (let i = 0; i < 8; i++) {\n\t\t\tmaxValue = Math.max(this._inverseFFT(real, imag, (i / 8) * twoPi), maxValue);\n\t\t}\n\t\treturn -this._inverseFFT(real, imag, this._phase) / maxValue;\n\t}\n\n\t/**\n\t * The partials of the waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tif (partials.length) {\n\t\t\tthis.type = \"custom\";\n\t\t}\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t * @example\n\t * osc.phase = 180; //flips the phase of the oscillator\n\t */\n\tget phase(): Degrees {\n\t\treturn this._phase * (180 / Math.PI);\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase * Math.PI / 180;\n\t\t// reset the type\n\t\tthis.type = this._type;\n\t}\n\n\t/**\n\t *  Dispose and disconnect.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._oscillator !== null) {\n\t\t\tthis._oscillator.dispose();\n\t\t}\n\t\tthis._wave = undefined;\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { optionsFromArguments } from \"..//core/util/Defaults\";\nimport { InputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connectSignal } from \"./Signal\";\n/**\n * A signal operator has an input and output and modifies the signal.\n */\nexport abstract class SignalOperator<Options extends ToneAudioNodeOptions> extends ToneAudioNode<Options> {\n\n\tconstructor(options?: Partial<Options>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(SignalOperator.getDefaults(), arguments, [\"context\"])));\n\t}\n\n\tconnect(destination: InputNode, outputNum: number = 0, inputNum: number = 0): this {\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction, isUndef } from \"../core/util/TypeCheck\";\nimport { Signal, SignalOptions } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n\ntype WaveShaperMappingFn = (value: number, index?: number) => number;\n\ntype WaveShaperMapping =  WaveShaperMappingFn | number[] | Float32Array;\n\ninterface WaveShaperOptions extends ToneAudioNodeOptions {\n\tmapping?: WaveShaperMapping;\n\tlength: number;\n\tcurve?: number[] | Float32Array;\n}\n\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * var timesTwo = new WaveShaper(function(val){\n * \treturn val * 2;\n * }, 2048);\n * @example\n * //a waveshaper can also be constructed with an array of values\n * var invert = new WaveShaper([1, -1]);\n */\nexport class WaveShaper extends SignalOperator<WaveShaperOptions> {\n\n\tname = \"WaveShaper\";\n\n\t/**\n\t *  the waveshaper node\n\t */\n\tprivate _shaper: WaveShaperNode = this.context.createWaveShaper();\n\n\t/**\n\t * The input to the waveshaper node.\n\t */\n\tinput = this._shaper;\n\n\t/**\n\t * The output from the waveshaper node\n\t */\n\toutput = this._shaper;\n\n\t/**\n\t * @param mapping The function used to define the values.\n\t *                 The mapping function should take two arguments:\n\t *                 the first is the value at the current position\n\t *                 and the second is the array position.\n\t *                 If the argument is an array, that array will be\n\t *                 set as the wave shaping function. The input\n\t *                 signal is an AudioRange [-1, 1] value and the output\n\t *                 signal can take on any numerical values.\n\t *\n\t * @param bufferLen The length of the WaveShaperNode buffer.\n\t */\n\tconstructor(mapping?: WaveShaperMapping , length?: number);\n\tconstructor(options?: Partial<WaveShaperOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n\t\tconst options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n\n\t\tif (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n\t\t\tthis.curve = Float32Array.from(options.mapping);\n\t\t} else if (isFunction(options.mapping)) {\n\t\t\tthis.setMap(options.mapping, options.length);\n\t\t}\n\t}\n\n\tstatic getDefaults(): WaveShaperOptions {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tlength: 1024,\n\t\t});\n\t}\n\n\t/**\n\t *  Uses a mapping function to set the value of the curve.\n\t * @param mapping The function used to define the values.\n\t *                 The mapping function take two arguments:\n\t *                 the first is the value at the current position\n\t *                 which goes from -1 to 1 over the number of elements\n\t *                 in the curve array. The second argument is the array position.\n\t * @example\n\t * //map the input signal from [-1, 1] to [0, 10]\n\t * shaper.setMap(function(val, index){\n\t * \treturn (val + 1) * 5;\n\t * })\n\t */\n\tsetMap(mapping: WaveShaperMappingFn, length: number = 1024): this {\n\t\tconst array = new Float32Array(length);\n\t\tfor (let i = 0, len = length; i < len; i++) {\n\t\t\tconst normalized = (i / (len - 1)) * 2 - 1;\n\t\t\tarray[i] = mapping(normalized, i);\n\t\t}\n\t\tthis.curve = array;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The array to set as the waveshaper curve. For linear curves\n\t * array length does not make much difference, but for complex curves\n\t * longer arrays will provide smoother interpolation.\n\t */\n\tget curve(): Float32Array | null {\n\t\treturn this._shaper.curve;\n\t}\n\n\tset curve(mapping: Float32Array | null) {\n\t\tthis._shaper.curve = mapping;\n\t}\n\n\t/**\n\t * Specifies what type of oversampling (if any) should be used when\n\t * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\n\tset oversample(oversampling: OverSampleType) {\n\t\tconst isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n\t\tthis.assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.disconnect();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1].\n * See {@link GainToAudio}.\n *\n * @example\n * var a2g = new AudioToGain();\n */\nexport class AudioToGain extends SignalOperator<ToneAudioNodeOptions> {\n\n\tname = \"AudioToGain\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: x => (x + 1) / 2,\n\t});\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The GainRange output [0, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal, SignalOptions } from \"./Signal\";\n\n/**\n * Multiply two incoming signals. Or, if a number is given in the constructor,\n * multiplies the incoming signal by that value.\n *\n * @example\n * const mult = new Multiply();\n * const sigA = new Tone.Signal(3);\n * const sigB = new Tone.Signal(4);\n * sigA.connect(mult);\n * sigB.connect(mult.factor);\n * //output of mult is 12.\n * @example\n * const mult = new Multiply(10);\n * const sig = new Tone.Signal(2).connect(mult);\n * //the output of mult is 20.\n */\nexport class Multiply extends Signal<number> {\n\n\tname = \"Multiply\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection\n\t */\n\treadonly override = false;\n\n\t/**\n\t * the input gain node\n\t */\n\tprivate _mult: Gain = new Gain({ context : this.context });\n\n\t/**\n\t * The multiplcant input.\n\t */\n\tinput = this._mult;\n\n\t/**\n\t * The product of the input and {@link factor}\n\t */\n\toutput = this._mult;\n\n\t/**\n\t * The multiplication factor. Can be set directly or a signal can be connected to it.\n\t */\n\tfactor: Param<number>;\n\n\t/**\n\t * @param value Constant value to multiple\n\t */\n\tconstructor(value?: number);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<SignalOptions<number>>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"])));\n\t\tconst options = optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis.factor = this._param = this._mult.gain as unknown as Param<number>;\n\t\tthis.factor.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): SignalOptions<number> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._mult.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Cents, Degrees, Frequency, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { AMConstructorOptions, AMOscillatorOptions,\n\tNonCustomOscillatorType, ToneOscillatorInterface,\n\tToneOscillatorType } from \"./OscillatorInterface\";\n\n/**\n * An amplitude modulated oscillator node. It is implemented with\n * two oscillators, one which modulators the other's amplitude\n * through a gain node.\n * ```\n *    +-------------+       +----------+\n *    | Carrier Osc +>------> GainNode |\n *    +-------------+       |          +--->Output\n *                      +---> gain     |\n * +---------------+    |   +----------+\n * | Modulator Osc +>---+\n * +---------------+\n * ```\n *\n * @example\n * //a sine oscillator frequency-modulated by a square wave\n * var fmOsc = new AMOscillator(\"Ab3\", \"sine\", \"square\").toDestination().start();\n */\nexport class AMOscillator extends Source<AMOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"AMOscillator\";\n\n\t/**\n\t *  The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\t/**\n\t *  The oscillator's frequency\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune control signal.\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t *  The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t *  convert the -1,1 output to 0,1\n\t */\n\tprivate _modulationScale = new AudioToGain({ context: this.context });\n\n\t/**\n\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t *  A harmonicity of 1 gives both oscillators the same frequency.\n\t *  Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * //pitch the modulator an octave below carrier\n\t * synth.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<Positive>;\n\n\t/**\n\t *  the node where the modulation happens\n\t */\n\tprivate _modulationNode = new Gain({\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * @param frequency The starting frequency of the oscillator.\n\t * @param type The type of the carrier oscillator.\n\t * @param modulationType The type of the modulator oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor(options?: Partial<AMConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier  = new Oscillator({\n\t\t\tcontext : this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\t\tthis.frequency = this._carrier.frequency,\n\t\tthis.detune = this._carrier.detune;\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext : this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t\tthis._carrier.chain(this._modulationNode, this.output);\n\n\t\treadOnly(this, [\"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): AMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Seconds): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Seconds): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\t/**\n\t *  restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the carrier oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t */\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\t/**\n\t * The partials of the carrier waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis._modulationScale.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { AudioRange, Cents, Degrees, Frequency, Positive, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { FMConstructorOptions, FMOscillatorOptions,\n\tNonCustomOscillatorType, ToneOscillatorInterface, ToneOscillatorType } from \"./OscillatorInterface\";\n\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @example\n * //a sine oscillator frequency-modulated by a square wave\n * var fmOsc = new FMOscillator(\"Ab3\", \"sine\", \"square\").toDestination().start();\n */\nexport class FMOscillator extends Source<FMOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"FMOscillator\";\n\n\t/**\n\t *  The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\t/**\n\t *  The oscillator's frequency\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune control signal.\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t *  The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t *  A harmonicity of 1 gives both oscillators the same frequency.\n\t *  Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * //pitch the modulator an octave below carrier\n\t * synth.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<Positive>;\n\n\t/**\n\t *  The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t *  ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t *  modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Signal<Positive>;\n\n\t/**\n\t *  the node where the modulation happens\n\t */\n\tprivate _modulationNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * @param frequency The starting frequency of the oscillator.\n\t * @param type The type of the carrier oscillator.\n\t * @param modulationType The type of the modulator oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor(options?: Partial<FMConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier = new Oscillator({\n\t\t\tcontext : this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: 0,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\n\t\tthis.detune = this._carrier.detune;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext : this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\tthis.modulationIndex = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.modulationIndex,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t\tthis.detune.connect(this._modulator.detune);\n\n\t\treadOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): FMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationIndex: 2,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\t/**\n\t *  stop and restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the carrier oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t */\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\t/**\n\t * The partials of the carrier waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { AudioRange, Cents, Degrees, Frequency, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { WaveShaper } from \"../../signal/WaveShaper\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { PulseOscillatorOptions, ToneOscillatorInterface } from \"./OscillatorInterface\";\n\n/**\n * PulseOscillator is an oscillator with control over pulse width,\n * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is\n * a square wave.\n * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n * ```\n *    width = -0.25        width = 0.0          width = 0.25\n *\n *   +-----+            +-------+       +    +-------+     +-+\n *   |     |            |       |       |            |     |\n *   |     |            |       |       |            |     |\n * +-+     +-------+    +       +-------+            +-----+\n *\n *\n *    width = -0.5                              width = 0.5\n *\n *     +---+                                 +-------+   +---+\n *     |   |                                         |   |\n *     |   |                                         |   |\n * +---+   +-------+                                 +---+\n *\n *\n *    width = -0.75                             width = 0.75\n *\n *       +-+                                 +-------+ +-----+\n *       | |                                         | |\n *       | |                                         | |\n * +-----+ +-------+                                 +-+\n * ```\n * @example\n * var pulse = new PulseOscillator(\"E5\", 0.4).toDestination().start();\n */\nexport class PulseOscillator extends Source<PulseOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"PulseOscillator\";\n\n\t/**\n\t *  The width of the pulse.\n\t */\n\twidth: Signal<AudioRange>;\n\n\t/**\n\t *  gate the width amount\n\t */\n\tprivate _widthGate: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t *  the sawtooth oscillator\n\t */\n\tprivate _sawtooth: Oscillator;\n\n\t/**\n\t *  The frequency control.\n\t */\n\tfrequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune in cents.\n\t */\n\tdetune: Signal<Cents>;\n\n\t/**\n\t *  Threshold the signal to turn it into a square\n\t */\n\tprivate _thresh = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: val => val <= 0 ? -1 : 1,\n\t});\n\n\t/**\n\t * @param frequency The frequency of the oscillator\n\t * @param width The width of the pulse\n\t */\n\tconstructor(frequency?: Frequency, width?: AudioRange);\n\tconstructor(options?: Partial<PulseOscillatorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]));\n\t\tconst options = optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]);\n\n\t\tthis.width = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"audioRange\",\n\t\t\tvalue: options.width,\n\t\t});\n\n\t\tthis._sawtooth = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype : \"sawtooth\",\n\t\t});\n\t\tthis.frequency = this._sawtooth.frequency;\n\t\tthis.detune = this._sawtooth.detune;\n\n\t\t// connections\n\t\tthis._sawtooth.chain(this._thresh, this.output);\n\t\tthis.width.chain(this._widthGate, this._thresh);\n\t\treadOnly(this, [\"width\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PulseOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tphase: 0,\n\t\t\ttype: \"pulse\" as \"pulse\",\n\t\t\twidth: 0.2,\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._sawtooth.start(time);\n\t\tthis._widthGate.gain.setValueAtTime(1, time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._sawtooth.stop(time);\n\t\t// the width is still connected to the output.\n\t\t// that needs to be stopped also\n\t\tthis._widthGate.gain.cancelScheduledValues(time);\n\t\tthis._widthGate.gain.setValueAtTime(0, time);\n\t}\n\n\t/**\n\t *  Restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._sawtooth.restart(computedTime);\n\t\tthis._widthGate.gain.cancelScheduledValues(computedTime);\n\t\tthis._widthGate.gain.setValueAtTime(1, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._sawtooth.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._sawtooth.phase = phase;\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pulse\".\n\t */\n\tget type(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pulse\".\n\t */\n\tget baseType(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t *  Clean up method.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sawtooth.dispose();\n\t\tthis.width.dispose();\n\t\tthis._widthGate.dispose();\n\t\tthis._thresh.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioRange, Cents, Degrees, Frequency, Positive, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { FatConstructorOptions, FatOscillatorOptions,\n\tToneOscillatorInterface, ToneOscillatorType } from \"./OscillatorInterface\";\n\n/**\n *  FatOscillator is an array of oscillators with detune spread between the oscillators\n * @param frequency The oscillator's frequency.\n * @param type The type of the oscillator.\n * @param spread The detune spread between the oscillators.\n * @example\n * var fatOsc = new FatOscillator(\"Ab3\", \"sine\", 40).toDestination().start();\n */\nexport class FatOscillator extends Source<FatOscillatorOptions> implements ToneOscillatorInterface {\n\n\tname = \"FatOscillator\";\n\n\t/**\n\t *  The oscillator's frequency\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune control signal.\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t *  The array of oscillators\n\t */\n\tprivate _oscillators: Oscillator[] = [];\n\n\t/**\n\t *  The total spread of the oscillators\n\t */\n\tprivate _spread: Cents;\n\n\t/**\n\t *  The type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t *  The phase of the oscillators\n\t */\n\tprivate _phase: Degrees;\n\n\t/**\n\t *  The partials array\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t *  The number of partials to use\n\t */\n\tprivate _partialCount: number;\n\n\tconstructor(options?: Partial<FatConstructorOptions>);\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n\t\tconst options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\tthis._spread = options.spread;\n\t\tthis._type = options.type;\n\t\tthis._phase = options.phase;\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\n\t\t// set the count initially\n\t\tthis.count = options.count;\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): FatOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tcount : 3,\n\t\t\tspread : 20,\n\t\t\ttype : \"sawtooth\",\n\t\t});\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.start(time));\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.stop(time));\n\t}\n\n\t/**\n\t *  restart the oscillator\n\t */\n\trestart(time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.restart(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over all of the oscillators\n\t */\n\tprivate _forEach(iterator: (osc: Oscillator, index: number) => void): void {\n\t\tfor (let i = 0; i < this._oscillators.length; i++) {\n\t\t\titerator(this._oscillators[i], i);\n\t\t}\n\t}\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\n\tset type(type: ToneOscillatorType) {\n\t\tthis._type = type;\n\t\tthis._forEach(osc => osc.type = type);\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents.\n\t */\n\tget spread(): Cents {\n\t\treturn this._spread;\n\t}\n\n\tset spread(spread: Cents) {\n\t\tthis._spread = spread;\n\t\tif (this._oscillators.length > 1) {\n\t\t\tconst start = -spread / 2;\n\t\t\tconst step = spread / (this._oscillators.length - 1);\n\t\t\tthis._forEach((osc, i) => osc.detune.value = start + step * i);\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators. Should be an integer greater than 1.\n\t */\n\tget count(): number {\n\t\treturn this._oscillators.length;\n\t}\n\tset count(count: number) {\n\t\tcount = Math.max(count, 1);\n\t\tif (this._oscillators.length !== count) {\n\t\t\t// dispose the previous oscillators\n\t\t\tthis._forEach(osc => osc.dispose());\n\t\t\tthis._oscillators = [];\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst osc = new Oscillator({\n\t\t\t\t\tcontext : this.context,\n\t\t\t\t\tonstop: i === 0 ? () => this.onstop(this) : noOp,\n\t\t\t\t});\n\t\t\t\tif (this.type === \"custom\") {\n\t\t\t\t\tosc.partials = this._partials;\n\t\t\t\t} else {\n\t\t\t\t\tosc.type = this._type;\n\t\t\t\t}\n\t\t\t\tosc.partialCount = this._partialCount;\n\t\t\t\tosc.phase = this._phase + (i / count) * 360;\n\t\t\t\tosc.volume.value = -6 - count * 1.1;\n\t\t\t\tthis.frequency.connect(osc.frequency);\n\t\t\t\tthis.detune.connect(osc.detune);\n\t\t\t\tosc.connect(this.output);\n\t\t\t\tthis._oscillators[i] = osc;\n\t\t\t}\n\t\t\t// set the spread\n\t\t\tthis.spread = this._spread;\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._forEach(osc => osc.start());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase;\n\t\tthis._forEach(osc => osc.phase = phase);\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._oscillators[0].baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._forEach(osc => osc.baseType = baseType);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\t/**\n\t * The partials of the carrier waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @memberOf FatOscillator#\n\t * @type {Array}\n\t * @name partials\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillators[0].partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tif (partials.length) {\n\t\t\tthis._type = \"custom\";\n\t\t\tthis._forEach(osc => osc.partials = partials);\n\t\t}\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t * @memberOf FatOscillator#\n\t * @type {Number}\n\t * @name partialCount\n\t */\n\tget partialCount(): number {\n\t\treturn this._oscillators[0].partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._partialCount = partialCount;\n\t\tthis._forEach(osc => osc.partialCount = partialCount);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._forEach(osc => osc.dispose());\n\t\treturn this;\n\t}\n}\n","import { Cents, Degrees, Frequency, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { PWMOscillatorOptions, ToneOscillatorInterface } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\n\n/**\n * PWMOscillator modulates the width of a Tone.PulseOscillator\n * at the modulationFrequency. This has the effect of continuously\n * changing the timbre of the oscillator by altering the harmonics\n * generated.\n * @example\n *  var pwm = new PWMOscillator(\"Ab3\", 0.3).toDestination().start();\n */\nexport class PWMOscillator extends Source<PWMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name = \"PWMOscillator\";\n\n\treadonly sourceType = \"pwm\";\n\n\t/**\n\t *  the pulse oscillator\n\t */\n\tprivate _pulse: PulseOscillator;\n\t/**\n\t *  the modulator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t *  Scale the oscillator so it doesn't go silent\n\t *  at the extreme values.\n\t */\n\tprivate _scale: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: 2,\n\t});\n\n\t/**\n\t *  The frequency control.\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune of the oscillator.\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t *  The modulation rate of the oscillator.\n\t */\n\treadonly modulationFrequency: Signal<Frequency>;\n\n\t/**\n\t * @param {Frequency} frequency The starting frequency of the oscillator.\n\t * @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse.\n\t */\n\tconstructor(frequency?: Frequency, modulationFrequency?: Frequency);\n\tconstructor(options?: Partial<PWMOscillatorOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]));\n\t\tconst options = optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]);\n\n\t\tthis._pulse = new PulseOscillator({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.modulationFrequency,\n\t\t});\n\t\t// change the pulse oscillator type\n\t\t// @ts-ignore\n\t\tthis._pulse._sawtooth.type = \"sine\";\n\n\t\tthis.modulationFrequency  = this._pulse.frequency;\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t});\n\n\t\tthis.frequency = this._modulator.frequency;\n\t\tthis.detune = this._modulator.detune;\n\n\t\t// connections\n\t\tthis._modulator.chain(this._scale, this._pulse.width);\n\t\tthis._pulse.connect(this.output);\n\t\treadOnly(this, [\"modulationFrequency\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PWMOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tmodulationFrequency: 0.4,\n\t\t\tphase: 0,\n\t\t\ttype: \"pwm\" as \"pwm\",\n\t\t});\n\t}\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.start(time);\n\t\tthis._pulse.start(time);\n\t}\n\n\t/**\n\t *  stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.stop(time);\n\t\tthis._pulse.stop(time);\n\t}\n\n\t/**\n\t *  restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._pulse.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pwm\".\n\t */\n\tget type(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pwm\".\n\t */\n\tget baseType(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._modulator.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._modulator.phase = phase;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._pulse.dispose();\n\t\tthis._scale.dispose();\n\t\tthis._modulator.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioRange, Cents, Degrees, Frequency, Positive, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments  } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport { OmniOscillatorConstructorOptions,\n\tOmniOscillatorOptions, OmniOscillatorType,\n\tToneOscillatorInterface, ToneOscillatorType } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\n\n/**\n * All of the oscillator types that OmniOscillator can take on\n */\ntype AnyOscillator = Oscillator | PWMOscillator | PulseOscillator | FatOscillator | AMOscillator | FMOscillator;\n\n/**\n * All of the Oscillator constructor types mapped to their name.\n */\ninterface OmniOscillatorSource {\n\t\"fm\": FMOscillator;\n\t\"am\": AMOscillator;\n\t\"pwm\": PWMOscillator;\n\t\"pulse\": PulseOscillator;\n\t\"oscillator\": Oscillator;\n\t\"fat\": FatOscillator;\n}\n\n/**\n * The available oscillator types.\n */\nexport type OmniOscSourceType = keyof OmniOscillatorSource;\n\n// Conditional Types\ntype IsAmOrFmOscillator<Osc, Ret> = Osc extends AMOscillator ? Ret : Osc extends FMOscillator ? Ret : undefined;\ntype IsFatOscillator<Osc, Ret> = Osc extends FatOscillator ? Ret : undefined;\ntype IsPWMOscillator<Osc, Ret> = Osc extends PWMOscillator ? Ret : undefined;\ntype IsPulseOscillator<Osc, Ret> = Osc extends PulseOscillator ? Ret : undefined;\ntype IsFMOscillator<Osc, Ret> = Osc extends FMOscillator ? Ret : undefined;\n\ntype AnyOscillatorConstructor = new (...args: any[]) => AnyOscillator;\n\n// tslint:disable-next-line: variable-name\nconst OmniOscillatorSourceMap: {\n\t[key in OmniOscSourceType] : AnyOscillatorConstructor\n} = {\n\tam: AMOscillator,\n\tfat: FatOscillator,\n\tfm: FMOscillator,\n\toscillator: Oscillator,\n\tpulse: PulseOscillator,\n\tpwm: PWMOscillator,\n};\n\n/**\n * OmniOscillator aggregates Tone.Oscillator, Tone.PulseOscillator,\n * Tone.PWMOscillator, Tone.FMOscillator, Tone.AMOscillator, and Tone.FatOscillator\n * into one class. The oscillator class can be changed by setting the `type`.\n * `omniOsc.type = \"pwm\"` will set it to the Tone.PWMOscillator. Prefixing\n * any of the basic types (\"sine\", \"square4\", etc.) with \"fm\", \"am\", or \"fat\"\n * will use the FMOscillator, AMOscillator or FatOscillator respectively.\n * For example: `omniOsc.type = \"fatsawtooth\"` will create set the oscillator\n * to a FatOscillator of type \"sawtooth\".\n * @example\n * var omniOsc = new OmniOscillator(\"C#4\", \"pwm\");\n */\nexport class OmniOscillator<OscType extends AnyOscillator>\nextends Source<OmniOscillatorConstructorOptions>\nimplements Omit<ToneOscillatorInterface, \"type\"> {\n\n\tname = \"OmniOscillator\";\n\n\t/**\n\t *  The frequency control.\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune control.\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t * The oscillator that can switch types\n\t */\n\tprivate _oscillator!: AnyOscillator;\n\n\t/**\n\t *  the type of the oscillator source\n\t */\n\tprivate _sourceType!: OmniOscSourceType;\n\n\t/**\n\t * @param frequency The initial frequency of the oscillator.\n\t * @param type The type of the oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: OmniOscillatorType);\n\tconstructor(options?: Partial<OmniOscillatorConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\n\t\t// set the options\n\t\tthis.set(options);\n\t}\n\n\tstatic getDefaults(): OmniOscillatorOptions {\n\t\treturn Object.assign(\n\t\t\tOscillator.getDefaults(),\n\t\t\tFMOscillator.getDefaults(),\n\t\t\tAMOscillator.getDefaults(),\n\t\t\tFatOscillator.getDefaults(),\n\t\t\tPulseOscillator.getDefaults(),\n\t\t\tPWMOscillator.getDefaults(),\n\t\t);\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._oscillator.start(time);\n\t}\n\n\t/**\n\t *  start the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\trestart(time?: Time): this {\n\t\tthis._oscillator.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n\t * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n\t * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n\t * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n\t * when it's not.\n\t * @example\n\t * omniOsc.type = \"pwm\";\n\t * //modulationFrequency is parameter which is available\n\t * //only when the type is \"pwm\".\n\t * omniOsc.modulationFrequency.value = 0.5;\n\t * @example\n\t * //an square wave frequency modulated by a sawtooth\n\t * omniOsc.type = \"fmsquare\";\n\t * omniOsc.modulationType = \"sawtooth\";\n\t */\n\tget type(): OmniOscillatorType {\n\t\tlet prefix = \"\";\n\t\tif ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n\t\t\tprefix = this._sourceType;\n\t\t}\n\t\treturn prefix + this._oscillator.type as OmniOscillatorType;\n\t}\n\tset type(type) {\n\t\tif (type.substr(0, 2) === \"fm\") {\n\t\t\tthis._createNewOscillator(\"fm\");\n\t\t\tthis._oscillator = this._oscillator as FMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 2) === \"am\") {\n\t\t\tthis._createNewOscillator(\"am\");\n\t\t\tthis._oscillator = this._oscillator as AMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2)  as ToneOscillatorType;\n\t\t} else if (type.substr(0, 3) === \"fat\") {\n\t\t\tthis._createNewOscillator(\"fat\");\n\t\t\tthis._oscillator = this._oscillator as FatOscillator;\n\t\t\tthis._oscillator.type = type.substr(3)  as ToneOscillatorType;\n\t\t} else if (type === \"pwm\") {\n\t\t\tthis._createNewOscillator(\"pwm\");\n\t\t\tthis._oscillator = this._oscillator as PWMOscillator;\n\t\t} else if (type === \"pulse\") {\n\t\t\tthis._createNewOscillator(\"pulse\");\n\t\t} else {\n\t\t\tthis._createNewOscillator(\"oscillator\");\n\t\t\tthis._oscillator = this._oscillator as Oscillator;\n\t\t\tthis._oscillator.type = (type as ToneOscillatorType);\n\t\t}\n\t}\n\n\t/**\n\t * The partials of the waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partials = partials;\n\t\t}\n\t}\n\n\t/**\n\t * The partial count of the oscillator. This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * @example\n\t * //set the maximum number of partials\n\t * osc.partialCount = 0;\n\t */\n\tget partialCount(): number {\n\t\treturn this._oscillator.partialCount;\n\t}\n\tset partialCount(partialCount) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partialCount = partialCount;\n\t\t}\n\t}\n\n\t/**\n\t * Set the parameters at once. Either pass in an\n\t * object mapping parameters to values, or to set a\n\t * single parameter, by passing in a string and value.\n\t * The last argument is an optional ramp time which\n\t * will ramp any signal values to their destination value\n\t * over the duration of the rampTime.\n\t * @param  params\n\t * @example\n\t * //set values using an object\n\t * filter.set({\n\t * \t\"frequency\" : 300,\n\t * \t\"type\" : \"highpass\"\n\t * });\n\t */\n\tset(props: Partial<OmniOscillatorConstructorOptions>): this {\n\t\t// make sure the type is set first\n\t\tif (Reflect.has(props, \"type\") && props.type) {\n\t\t\tthis.type = props.type;\n\t\t\t// delete props.type;\n\t\t}\n\t\t// then set the rest\n\t\tsuper.set(props);\n\t\treturn this;\n\t}\n\n\tget(): OmniOscillatorConstructorOptions {\n\t\tconst options = this._oscillator.get();\n\t\t// @ts-ignore\n\t\toptions.type = this.type;\n\t\treturn options as OmniOscillatorOptions;\n\t}\n\n\t/**\n\t *  connect the oscillator to the frequency and detune signals\n\t */\n\tprivate _createNewOscillator(oscType: OmniOscSourceType): void {\n\t\tif (oscType !== this._sourceType) {\n\t\t\tthis._sourceType = oscType;\n\t\t\t// tslint:disable-next-line: variable-name\n\t\t\tconst OscConstructor = OmniOscillatorSourceMap[oscType];\n\t\t\t// short delay to avoid clicks on the change\n\t\t\tconst now = this.now();\n\t\t\tif (this._oscillator) {\n\t\t\t\tconst oldOsc = this._oscillator;\n\t\t\t\toldOsc.stop(now);\n\t\t\t\t// dispose the old one\n\t\t\t\tthis.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n\t\t\t}\n\t\t\tthis._oscillator = new OscConstructor({\n\t\t\t\tcontext : this.context,\n\t\t\t});\n\t\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\t\tthis.detune.connect(this._oscillator.detune);\n\t\t\tthis._oscillator.connect(this.output);\n\t\t\tthis._oscillator.onstop = () => this.onstop(this);\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._oscillator.start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t}\n\n\t/**\n\t * The source type of the oscillator.\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"fmsquare\");\n\t * omniOsc.sourceType // 'fm'\n\t */\n\tget sourceType(): OmniOscSourceType {\n\t\treturn this._sourceType;\n\t}\n\tset sourceType(sType) {\n\t\t// the basetype defaults to sine\n\t\tlet baseType = \"sine\";\n\t\tif (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n\t\t\tbaseType = this._oscillator.type;\n\t\t}\n\n\t\t// set the type\n\t\tif (sType === \"fm\") {\n\t\t\tthis.type = \"fm\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"am\") {\n\t\t\tthis.type = \"am\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"fat\") {\n\t\t\tthis.type = \"fat\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"oscillator\") {\n\t\t\tthis.type = baseType as OmniOscillatorType;\n\t\t} else if (sType === \"pulse\") {\n\t\t\tthis.type = \"pulse\";\n\t\t} else if (sType === \"pwm\") {\n\t\t\tthis.type = \"pwm\";\n\t\t}\n\t}\n\n\tprivate _getOscType<SourceType extends OmniOscSourceType>(\n\t\tosc: AnyOscillator,\n\t\tsourceType: SourceType,\n\t): osc is OmniOscillatorSource[SourceType] {\n\t\treturn osc instanceof OmniOscillatorSourceMap[sourceType];\n\t}\n\n\t/**\n\t * The base type of the oscillator.\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"fmsquare4\");\n\t * omniOsc.sourceType // 'fm'\n\t * omniOsc.baseType //'square'\n\t * omniOsc.partialCount //4\n\t */\n\tget baseType(): OscillatorType | \"pwm\" | \"pulse\" {\n\t\treturn this._oscillator.baseType;\n\t}\n\tset baseType(baseType) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") &&\n\t\t\t!this._getOscType(this._oscillator, \"pwm\") &&\n\t\t\tbaseType !== \"pulse\" && baseType !== \"pwm\") {\n\t\t\tthis._oscillator.baseType = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * The width of the oscillator when sourceType === \"pulse\".\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"pulse\");\n\t * //can access the width attribute only if type === \"pulse\"\n\t * omniOsc.width.value = 0.2;\n\t */\n\tget width(): IsPulseOscillator<OscType, Signal<AudioRange>> {\n\t\tif (this._getOscType(this._oscillator, \"pulse\")) {\n\t\t\treturn this._oscillator.width as IsPulseOscillator<OscType, Signal<AudioRange>> ;\n\t\t} else {\n\t\t\treturn undefined as IsPulseOscillator<OscType, Signal<AudioRange>> ;\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators, when sourceType === \"fat\".\n\t */\n\tget count(): IsFatOscillator<OscType, number> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.count as IsFatOscillator<OscType, number>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, number>;\n\t\t}\n\t}\n\tset count(count) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n\t\t\tthis._oscillator.count = count;\n\t\t}\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents. See Tone.FatOscillator\n\t * for more info.\n\t */\n\tget spread(): IsFatOscillator<OscType, Cents> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.spread as IsFatOscillator<OscType, Cents>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, Cents>;\n\t\t}\n\t}\n\tset spread(spread) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n\t\t\tthis._oscillator.spread = spread;\n\t\t}\n\t}\n\n\t/**\n\t * The type of the modulator oscillator. Only if the oscillator\n\t * is set to \"am\" or \"fm\" types. see. Tone.AMOscillator or Tone.FMOscillator\n\t * for more info.\n\t */\n\tget modulationType(): IsAmOrFmOscillator<OscType, ToneOscillatorType> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.modulationType as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t}\n\t}\n\tset modulationType(mType) {\n\t\tif ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n\t\t\tthis._oscillator.modulationType = mType;\n\t\t}\n\t}\n\n\t/**\n\t * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t * See Tone.FMOscillator for more info.\n\t */\n\tget modulationIndex(): IsFMOscillator<OscType, Signal<Positive>> {\n\t\tif (this._getOscType(this._oscillator, \"fm\")) {\n\t\t\treturn this._oscillator.modulationIndex as IsFMOscillator<OscType, Signal<Positive>>;\n\t\t} else {\n\t\t\treturn undefined as IsFMOscillator<OscType, Signal<Positive>>;\n\t\t}\n\t}\n\n\t/**\n\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t *  A harmonicity of 1 gives both oscillators the same frequency.\n\t *  Harmonicity = 2 means a change of an octave. See Tone.AMOscillator or Tone.FMOscillator\n\t *  for more info.\n\t */\n\tget harmonicity(): IsAmOrFmOscillator<OscType, Signal<Positive>> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.harmonicity as IsAmOrFmOscillator<OscType, Signal<Positive>>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, Signal<Positive>>;\n\t\t}\n\t}\n\n\t/**\n\t * The modulationFrequency Signal of the oscillator\n\t * (only if the oscillator type is set to pwm). See\n\t * Tone.PWMOscillator for more info.\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"pwm\");\n\t * //can access the modulationFrequency attribute only if type === \"pwm\"\n\t * omniOsc.modulationFrequency.value = 0.2;\n\t */\n\tget modulationFrequency(): IsPWMOscillator<OscType, Signal<Frequency>> {\n\t\tif (this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\treturn this._oscillator.modulationFrequency as IsPWMOscillator<OscType, Signal<Frequency>>;\n\t\t} else {\n\t\t\treturn undefined as IsPWMOscillator<OscType, Signal<Frequency>>;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._oscillator.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { Positive, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isUndef } from \"../../core/util/TypeCheck\";\nimport { Source, SourceOptions } from \"../Source\";\nimport { ToneBufferSource } from \"./BufferSource\";\n\ninterface PlayerOptions extends SourceOptions {\n\tonload: () => void;\n\tplaybackRate: Positive;\n\tloop: boolean;\n\tautostart: boolean;\n\tloopStart: Time;\n\tloopEnd: Time;\n\treverse: boolean;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\turl?: ToneAudioBuffer | string | AudioBuffer;\n}\n\n/**\n * Player is an audio file player with start, loop, and stop functions.\n * @example\n * var player = new Player(\"./path/to/sample.mp3\").toDestination();\n * //play as soon as the buffer is loaded\n * player.autostart = true;\n */\nexport class Player extends Source<PlayerOptions> {\n\n\tname = \"Player\";\n\n\t/**\n\t * If the file should play as soon\n\t * as the buffer is loaded.\n\t * @example\n\t * //will play as soon as it's loaded\n\t * var player = new Player({\n\t * \t\"url\" : \"./path/to/sample.mp3\",\n\t * \t\"autostart\" : true,\n\t * }).toDestination();\n\t */\n\tautostart: boolean;\n\n\t/**\n\t *  The buffer\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t *  if the buffer should loop once it's over\n\t */\n\tprivate _loop: boolean;\n\n\t/**\n\t *  if 'loop' is true, the loop will start at this position\n\t */\n\tprivate _loopStart: Time;\n\n\t/**\n\t *  if 'loop' is true, the loop will end at this position\n\t */\n\tprivate _loopEnd: Time;\n\n\t/**\n\t *  the playback rate\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t *  All of the active buffer source nodes\n\t */\n\tprivate _activeSources: Set<ToneBufferSource> = new Set();\n\n\t/**\n\t *  The fadeIn time of the amplitude envelope.\n\t */\n\tfadeIn: Time;\n\n\t/**\n\t *  The fadeOut time of the amplitude envelope.\n\t */\n\tfadeOut: Time;\n\n\t/**\n\t * @param url Either the AudioBuffer or the url from which to load the AudioBuffer\n\t * @param onload The function to invoke when the buffer is loaded.\n\t */\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<PlayerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis._buffer = new ToneAudioBuffer({\n\t\t\tonload: this._onload.bind(this, options.onload),\n\t\t\treverse: options.reverse,\n\t\t\turl: options.url,\n\t\t});\n\t\tthis.autostart = options.autostart;\n\t\tthis._loop = options.loop;\n\t\tthis._loopStart = options.loopStart;\n\t\tthis._loopEnd = options.loopEnd;\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.fadeIn = options.fadeIn;\n\t\tthis.fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): PlayerOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tautostart : false,\n\t\t\tfadeIn : 0,\n\t\t\tfadeOut : 0,\n\t\t\tloop : false,\n\t\t\tloopEnd : 0,\n\t\t\tloopStart : 0,\n\t\t\tonload : noOp,\n\t\t\tplaybackRate : 1,\n\t\t\treverse : false,\n\t\t});\n\t}\n\n\t/**\n\t * Load the audio file as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * Note: this does not need to be called if a url\n\t * was passed in to the constructor. Only use this\n\t * if you want to manually load a new url.\n\t * @param url The url of the buffer to load. Filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tawait this._buffer.load(url);\n\t\tthis._onload();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal callback when the buffer is loaded.\n\t */\n\tprivate _onload(callback: () => void = noOp): void {\n\t\tcallback();\n\t\tif (this.autostart) {\n\t\t\tthis.start();\n\t\t}\n\t}\n\n\t/**\n\t * Internal callback when the buffer is done playing.\n\t */\n\tprivate _onSourceEnd(source: ToneBufferSource): void {\n\t\t// invoke the onstop function\n\t\tthis.onstop(this);\n\n\t\t// delete the source from the active sources\n\t\tthis._activeSources.delete(source);\n\t\tif (this._activeSources.size === 0 && !this._synced) {\n\t\t\tthis._state.setStateAtTime(\"stopped\", this.now());\n\t\t}\n\t}\n\n\t/**\n\t *  Play the buffer at the given startTime. Optionally add an offset\n\t *  and/or duration which will play the buffer from a position\n\t *  within the buffer for the given duration.\n\t *\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample\n\t *                                 to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length\n\t *                   of the sample (minus any offset)\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tsuper.start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Internal start method\n\t */\n\tprotected _start(startTime?: Time, offset?: Time, duration?: Time): void {\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this._loop) {\n\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\n\t\t// compute the values in seconds\n\t\tlet comptuedOffset = this.toSeconds(offset);\n\n\t\t// if it's synced, it should factor in the playback rate for computing the offset\n\t\tif (this._synced) {\n\t\t\tcomptuedOffset *= this._playbackRate;\n\t\t}\n\n\t\t// compute the duration which is either the passed in duration of the buffer.duration - offset\n\t\tconst origDuration = duration;\n\t\tduration = defaultArg(duration, Math.max(this._buffer.duration - comptuedOffset, 0));\n\t\tlet computedDuration = this.toSeconds(duration);\n\n\t\t// scale it by the playback rate\n\t\tcomputedDuration = computedDuration / this._playbackRate;\n\n\t\t// get the start time\n\t\tstartTime = this.toSeconds(startTime);\n\n\t\t// make the source\n\t\tconst source = new ToneBufferSource({\n\t\t\tbuffer : this._buffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn : this.fadeIn,\n\t\t\tfadeOut : this.fadeOut,\n\t\t\tloop : this._loop,\n\t\t\tloopEnd : this._loopEnd,\n\t\t\tloopStart : this._loopStart,\n\t\t\tonended : this._onSourceEnd.bind(this),\n\t\t\tplaybackRate : this._playbackRate,\n\t\t}).connect(this.output);\n\n\t\t// set the looping properties\n\t\tif (!this._loop && !this._synced) {\n\t\t\t// if it's not looping, set the state change at the end of the sample\n\t\t\tthis._state.setStateAtTime(\"stopped\", startTime + computedDuration, {\n\t\t\t\timplicitEnd: true,\n\t\t\t});\n\t\t}\n\n\t\t// add it to the array of active sources\n\t\tthis._activeSources.add(source);\n\n\t\t// start it\n\t\tif (this._loop && isUndef(origDuration)) {\n\t\t\tsource.start(startTime, comptuedOffset);\n\t\t} else {\n\t\t\t// subtract the fade out time\n\t\t\tsource.start(startTime, comptuedOffset, computedDuration - this.toSeconds(this.fadeOut));\n\t\t}\n\t}\n\n\t/**\n\t *  Stop playback.\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(source => source.stop(computedTime));\n\t}\n\n\t/**\n\t * Stop and then restart the player from the beginning (or offset)\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given,\n\t * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n\t */\n\trestart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tthis._stop(time);\n\t\tthis._start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Seek to a specific time in the player's buffer. If the\n\t *  source is no longer playing at that time, it will stop.\n\t *  If you seek to a time that\n\t * @param {Time} offset The time to seek to.\n\t * @param {Time=} time The time for the seek event to occur.\n\t * @return {Player} this\n\t * @example\n\t * source.start(0.2);\n\t * source.stop(0.4);\n\t */\n\tseek(offset: Time, when?: Time): this {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tconst comptuedOffset = this.toSeconds(offset);\n\t\t\t// if it's currently playing, stop it\n\t\t\tthis._stop(computedTime);\n\t\t\t// restart it at the given time\n\t\t\tthis._start(computedTime, comptuedOffset);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the loop start and end. Will only loop if loop is set to true.\n\t * @param loopStart The loop end time\n\t * @param loopEnd The loop end time\n\t * @example\n\t * //loop 0.1 seconds of the file.\n\t * player.setLoopPoints(0.2, 0.3);\n\t * player.loop = true;\n\t */\n\tsetLoopPoints(loopStart: Time, loopEnd: Time): this {\n\t\tthis.loopStart = loopStart;\n\t\tthis.loopEnd = loopEnd;\n\t\treturn this;\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = loopStart;\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopStart = loopStart;\n\t\t});\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = loopEnd;\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopEnd = loopEnd;\n\t\t});\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\t// if no change, do nothing\n\t\tif (this._loop === loop) {\n\t\t\treturn;\n\t\t}\n\t\tthis._loop = loop;\n\t\t// set the loop of all of the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loop = loop;\n\t\t});\n\t\tif (loop) {\n\t\t\t// remove the next stopEvent\n\t\t\tconst stopEvent = this._state.getNextState(\"stopped\", this.now());\n\t\t\tif (stopEvent) {\n\t\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The playback speed. 1 is normal speed. This is not a signal because\n\t * Safari and iOS currently don't support playbackRate as a signal.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tconst now = this.now();\n\n\t\t// cancel the stop event since it's at a different time now\n\t\tconst stopEvent = this._state.getNextState(\"stopped\", now);\n\t\tif (stopEvent && stopEvent.implicitEnd) {\n\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\tthis._activeSources.forEach(source => source.cancelStop());\n\t\t}\n\n\t\t// set all the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.playbackRate.setValueAtTime(rate, now);\n\t\t});\n\t}\n\n\t/**\n\t * The direction the buffer should play in\n\t */\n\tget reverse(): boolean {\n\t\treturn this._buffer.reverse;\n\t}\n\tset reverse(rev) {\n\t\tthis._buffer.reverse = rev;\n\t}\n\n\t/**\n\t * If the buffer is loaded\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffer.loaded;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\t// disconnect all of the players\n\t\tthis._activeSources.forEach(source => source.dispose());\n\t\tthis._activeSources.clear();\n\t\tthis._buffer.dispose();\n\t\treturn this;\n\t}\n}\n","import { connectSeries } from \"../core/Connect\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal, SignalOptions } from \"./Signal\";\n\n/**\n * Add a signal and a number or two signals. When no value is\n * passed into the constructor, Tone.Add will sum input and `addend`\n * If a value is passed into the constructor, the it will be added to the input.\n *\n * @example\n * var signal = new Signal(2);\n * var add = new Add(2);\n * signal.connect(add);\n * //the output of add equals 4\n * @example\n * //if constructed with no arguments\n * //it will add the first and second inputs\n * var add = new Add();\n * var sig0 = new Signal(3).connect(add);\n * var sig1 = new Signal(4).connect(add.addend);\n * //the output of add equals 7.\n */\nexport class Add extends Signal {\n\n\toverride = false;\n\n\treadonly name = \"Add\";\n\n\t/**\n\t *  the summing node\n\t */\n\tprivate _sum: Gain = new Gain({ context: this.context });\n\treadonly input = this._sum;\n\treadonly output = this._sum;\n\n\t/**\n\t * The value which is added to the input signal\n\t */\n\treadonly addend: Param<number> = this._param;\n\n\t/**\n\t * @param value If no value is provided, Tone.Add will sum the first  and second inputs.\n\t */\n\tconstructor(value?: number);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<SignalOptions<number>>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Add.getDefaults(), arguments, [\"value\"])));\n\n\t\tconnectSeries(this._constantSource, this._sum);\n\t}\n\n\tstatic getDefaults(): SignalOptions<number> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sum.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * Return the absolute value of an incoming signal.\n *\n * @example\n * var signal = new Tone.Signal(-1);\n * var abs = new Tone.Abs();\n * signal.connect(abs);\n * //the output of abs is 1.\n */\nexport class Abs extends SignalOperator<ToneAudioNodeOptions> {\n\n\tname = \"Abs\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _abs = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: val => {\n\t\t\tif (Math.abs(val) < 0.001) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn Math.abs(val);\n\t\t\t}\n\t\t},\n\t});\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._abs;\n\n\t/**\n\t * The output range [0, 1]\n\t */\n\toutput = this._abs;\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._abs.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * GainToAudio converts an input in NormalRange [0,1] to AudioRange [-1,1].\n * See {@link AudioToGain}.\n *\n * @example\n * var a2g = new GainToAudio();\n */\nexport class GainToAudio extends SignalOperator<ToneAudioNodeOptions> {\n\n\tname = \"GainToAudio\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: x => Math.abs(x) * 2 - 1,\n\t});\n\n\t/**\n\t * The NormalRange input [0, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The AudioRange output [-1, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Multiply } from \"./Multiply\";\nimport { SignalOperator } from \"./SignalOperator\";\n\n/**\n * Negate the incoming signal. i.e. an input signal of 10 will output -10\n *\n * @example\n * var neg = new Negate();\n * var sig = new Signal(-2).connect(neg);\n * //output of neg is positive 2.\n */\nexport class Negate extends SignalOperator<ToneAudioNodeOptions> {\n\n\tname = \"Negate\";\n\n\t/**\n\t *  negation is done by multiplying by -1\n\t */\n\tprivate _multiply: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: -1,\n\t});\n\n\t/**\n\t * The input and output are equal to the multiply node\n\t */\n\tinput = this._multiply;\n\toutput = this._multiply;\n\n\t/**\n\t *  clean up\n\t * @returns {Negate} this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._multiply.dispose();\n\t\treturn this;\n\t}\n}\n","import { connectSeries } from \"../core/Connect\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Negate } from \"../signal/Negate\";\nimport { Signal, SignalOptions } from \"../signal/Signal\";\n\n/**\n * Subtract the signal connected to the input is subtracted from the signal connected\n * The subtrahend.\n *\n * @example\n * var sub = new Subtract(1);\n * var sig = new Tone.Signal(4).connect(sub);\n * //the output of sub is 3.\n * @example\n * var sub = new Subtract();\n * var sigA = new Tone.Signal(10);\n * var sigB = new Tone.Signal(2.5);\n * sigA.connect(sub);\n * sigB.connect(sub.subtrahend);\n * //output of sub is 7.5\n */\nexport class Subtract extends Signal {\n\n\toverride = false;\n\n\treadonly name = \"Subtract\";\n\n\t/**\n\t *  the summing node\n\t */\n\tprivate _sum: Gain = new Gain({ context: this.context });\n\tinput = this._sum;\n\toutput = this._sum;\n\n\t/**\n\t *  Negate the input of the second input before connecting it to the summing node.\n\t */\n\tprivate _neg: Negate = new Negate({ context : this.context });\n\n\t/**\n\t * The value which is subtracted from the main signal\n\t */\n\tsubtrahend: Param<number> = this._param;\n\n\t/**\n\t * @param value The value to subtract from the incoming signal. If the value\n\t *              is omitted, it will subtract the second signal from the first.\n\t */\n\tconstructor(value?: number);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<SignalOptions<number>>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Subtract.getDefaults(), arguments, [\"value\"])));\n\n\t\tconnectSeries(this._constantSource, this._neg, this._sum);\n\t}\n\n\tstatic getDefaults(): SignalOptions<number> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._neg.dispose();\n\t\tthis._sum.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { connect, disconnect, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { SignalOperator } from \"./SignalOperator\";\n\n/**\n *  Tone.Zero outputs 0's at audio-rate. The reason this has to be\n *  it's own class is that many browsers optimize out Tone.Signal\n *  with a value of 0 and will not process nodes further down the graph.\n */\nexport class Zero extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name = \"Zero\";\n\n\t/**\n\t * The gain node which connects the constant source to the output\n\t */\n\tprivate _gain = new Gain({ context : this.context });\n\n\t/**\n\t * Only outputs 0\n\t */\n\toutput = this._gain;\n\n\t/**\n\t * no input node\n\t */\n\tinput = undefined;\n\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Zero.getDefaults(), arguments)));\n\t\tconnect(this.context.getConstant(0), this._gain);\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tdisconnect(this.context.getConstant(0), this._gain);\n\t\treturn this;\n\t}\n}\n","import { InputNode, OutputNode } from \"../../core/context/ToneAudioNode\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\n\ntype BasicEnvelopeCurve = \"linear\" | \"exponential\";\ntype InternalEnvelopeCurve = BasicEnvelopeCurve | number[];\nexport type EnvelopeCurve = EnvelopeCurveName | number[];\n\nexport interface EnvelopeOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tdecay: Time;\n\tsustain: NormalRange;\n\trelease: Time;\n\tattackCurve: EnvelopeCurve;\n\treleaseCurve: EnvelopeCurve;\n\tdecayCurve: BasicEnvelopeCurve;\n}\n\n/**\n *  Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n *  envelope generator. Envelope outputs a signal which\n *  can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n *\n * @example\n * //an amplitude envelope\n * var gainNode = Tone.context.createGain();\n * var env = new Envelope({\n * \t\"attack\" : 0.1,\n * \t\"decay\" : 0.2,\n * \t\"sustain\" : 1,\n * \t\"release\" : 0.8,\n * });\n * env.connect(gainNode.gain);\n */\nexport class Envelope extends ToneAudioNode<EnvelopeOptions> {\n\n\treadonly name: string = \"Envelope\";\n\n\t/**\n\t * When triggerAttack is called, the attack time is the amount of\n\t * time it takes for the envelope to reach it's maximum value.\n\t * ```\n\t *           /\\\n\t *          /X \\\n\t *         /XX  \\\n\t *        /XXX   \\\n\t *       /XXXX    \\___________\n\t *      /XXXXX                \\\n\t *     /XXXXXX                 \\\n\t *    /XXXXXXX                  \\\n\t *   /XXXXXXXX                   \\\n\t * ```\n\t */\n\tattack: Time;\n\n\t/**\n\t * After the attack portion of the envelope, the value will fall\n\t * over the duration of the decay time to it's sustain value.\n\t * ```\n\t *           /\\\n\t *          / X\\\n\t *         /  XX\\\n\t *        /   XXX\\\n\t *       /    XXXX\\___________\n\t *      /     XXXXX           \\\n\t *     /      XXXXX            \\\n\t *    /       XXXXX             \\\n\t *   /        XXXXX              \\\n\t * ```\n\t */\n\tdecay: Time;\n\n\t/**\n\t * \tThe sustain value is the value\n\t * \twhich the envelope rests at after triggerAttack is\n\t * \tcalled, but before triggerRelease is invoked.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /          XXXXXXXXXXX\\\n\t *     /           XXXXXXXXXXX \\\n\t *    /            XXXXXXXXXXX  \\\n\t *   /             XXXXXXXXXXX   \\\n\t * ```\n\t */\n\tsustain: NormalRange;\n\n\t/**\n\t *  After triggerRelease is called, the envelope's\n\t *  value will fall to it's miminum value over the\n\t *  duration of the release time.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /                    X\\\n\t *     /                     XX\\\n\t *    /                      XXX\\\n\t *   /                       XXXX\\\n\t * ```\n\t */\n\trelease: Time;\n\n\t/**\n\t *  The automation curve type for the attack\n\t */\n\tprivate _attackCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t *  The automation curve type for the decay\n\t */\n\tprivate _decayCurve!: BasicEnvelopeCurve;\n\n\t/**\n\t *  The automation curve type for the release\n\t */\n\tprivate _releaseCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t *  the signal which is output.\n\t */\n\tprotected _sig: Signal<NormalRange> = new Signal({\n\t\tcontext: this.context,\n\t\tvalue: 0,\n\t});\n\n\t/**\n\t * The output signal of the envelope\n\t */\n\toutput: OutputNode = this._sig;\n\n\t/**\n\t * Envelope has no input\n\t */\n\tinput: InputNode | undefined = undefined;\n\n\t/**\n\t * @param attack The amount of time it takes for the envelope to go from\n\t *                         0 to it's maximum value.\n\t * @param decay\tThe period of time after the attack that it takes for the envelope\n\t *                       \tto fall to the sustain value. Value must be greater than 0.\n\t * @param sustain\tThe percent of the maximum value that the envelope rests at until\n\t *                                \tthe release is triggered.\n\t * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n\t *                         \tValue must be greater than 0.\n\t */\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tconst options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n\n\t\tthis.attack = options.attack;\n\t\tthis.decay = options.decay;\n\t\tthis.sustain = options.sustain;\n\t\tthis.release = options.release;\n\t\tthis.attackCurve = options.attackCurve;\n\t\tthis.releaseCurve = options.releaseCurve;\n\t\tthis.decayCurve = options.decayCurve;\n\t}\n\n\tstatic getDefaults(): EnvelopeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack : 0.01,\n\t\t\tattackCurve : \"linear\" as EnvelopeCurveName,\n\t\t\tdecay : 0.1,\n\t\t\tdecayCurve : \"exponential\" as BasicEnvelopeCurve,\n\t\t\trelease : 1,\n\t\t\treleaseCurve : \"exponential\" as EnvelopeCurveName,\n\t\t\tsustain : 0.5,\n\t\t});\n\t}\n\n\t/**\n\t * Read the current value of the envelope. Useful for\n\t * syncronizing visual output to the envelope.\n\t */\n\tget value(): NormalRange {\n\t\treturn this.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t *  Get the curve\n\t * @param  curve\n\t * @param  direction  In/Out\n\t * @return The curve name\n\t */\n\tprivate _getCurve(curve: InternalEnvelopeCurve, direction: EnvelopeDirection): EnvelopeCurve {\n\t\tif (isString(curve)) {\n\t\t\treturn curve;\n\t\t} else {\n\t\t\t// look up the name in the curves array\n\t\t\tlet curveName: EnvelopeCurveName;\n\t\t\tfor (curveName in EnvelopeCurves) {\n\t\t\t\tif (EnvelopeCurves[curveName][direction] === curve) {\n\t\t\t\t\treturn curveName;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// return the custom curve\n\t\t\treturn curve;\n\t\t}\n\t}\n\n\t/**\n\t *  Assign a the curve to the given name using the direction\n\t * @param  name\n\t * @param  direction In/Out\n\t * @param  curve\n\t */\n\tprivate _setCurve(\n\t\tname: \"_attackCurve\" | \"_decayCurve\" | \"_releaseCurve\",\n\t\tdirection: EnvelopeDirection,\n\t\tcurve: EnvelopeCurve,\n\t): void {\n\t\t// check if it's a valid type\n\t\tif (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n\t\t\tconst curveDef = EnvelopeCurves[curve];\n\t\t\tif (isObject(curveDef)) {\n\t\t\t\tif (name !== \"_decayCurve\") {\n\t\t\t\t\tthis[name] = curveDef[direction];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis[name] = curveDef;\n\t\t\t}\n\t\t} else if (isArray(curve) && name !== \"_decayCurve\") {\n\t\t\tthis[name] = curve;\n\t\t} else {\n\t\t\tthrow new Error(\"Envelope: invalid curve: \" + curve);\n\t\t}\n\t}\n\n\t/**\n\t * The shape of the attack.\n\t * Can be any of these strings:\n\t * * \"linear\"\n\t * * \"exponential\"\n\t * * \"sine\"\n\t * * \"cosine\"\n\t * * \"bounce\"\n\t * * \"ripple\"\n\t * * \"step\"\n\t *\n\t * Can also be an array which describes the curve. Values\n\t * in the array are evenly subdivided and linearly\n\t * interpolated over the duration of the attack.\n\t * @example\n\t * env.attackCurve = \"linear\";\n\t * @example\n\t * //can also be an array\n\t * env.attackCurve = [0, 0.2, 0.3, 0.4, 1]\n\t */\n\tget attackCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._attackCurve, \"In\");\n\t}\n\tset attackCurve(curve) {\n\t\tthis._setCurve(\"_attackCurve\", \"In\", curve);\n\t}\n\n\t/**\n\t * The shape of the release. See the attack curve types.\n\t * @example\n\t * env.releaseCurve = \"linear\";\n\t */\n\tget releaseCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._releaseCurve, \"Out\");\n\t}\n\tset releaseCurve(curve) {\n\t\tthis._setCurve(\"_releaseCurve\", \"Out\", curve);\n\t}\n\n\t/**\n\t * The shape of the decay either \"linear\" or \"exponential\"\n\t * @example\n\t * env.decayCurve = \"linear\";\n\t */\n\tget decayCurve(): BasicEnvelopeCurve {\n\t\treturn this._decayCurve;\n\t}\n\tset decayCurve(curve) {\n\t\tthis.assert([\"linear\", \"exponential\"].some(c => c === curve), `Invalid envelope curve: ${curve}`);\n\t\tthis._decayCurve = curve;\n\t}\n\n\t/**\n\t * Trigger the attack/decay portion of the ADSR envelope.\n\t * @param  time When the attack should start.\n\t * @param velocity The velocity of the envelope scales the vales.\n\t *                              number between 0-1\n\t * @example\n\t * //trigger the attack 0.5 seconds from now with a velocity of 0.2\n\t * env.triggerAttack(\"+0.5\", 0.2);\n\t */\n\ttriggerAttack(time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", time, velocity);\n\t\ttime = this.toSeconds(time);\n\t\tconst originalAttack = this.toSeconds(this.attack);\n\t\tlet attack = originalAttack;\n\t\tconst decay = this.toSeconds(this.decay);\n\t\t// check if it's not a complete attack\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\t// subtract the current value from the attack time\n\t\t\tconst attackRate = 1 / attack;\n\t\t\tconst remainingDistance = 1 - currentValue;\n\t\t\t// the attack is now the remaining time\n\t\t\tattack = remainingDistance / attackRate;\n\t\t}\n\t\t// attack\n\t\tif (attack === 0) {\n\t\t\t// case where the attack time is 0 should set instantly\n\t\t\tthis._sig.setValueAtTime(velocity, time);\n\t\t} else if (this._attackCurve === \"linear\") {\n\t\t\tthis._sig.linearRampTo(velocity, attack, time);\n\t\t} else if (this._attackCurve === \"exponential\") {\n\t\t\tthis._sig.targetRampTo(velocity, attack, time);\n\t\t} else {\n\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\tlet curve = this._attackCurve;\n\t\t\t// find the starting position in the curve\n\t\t\tfor (let i = 1; i < curve.length; i++) {\n\t\t\t\t// the starting index is between the two values\n\t\t\t\tif (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n\t\t\t\t\tcurve = this._attackCurve.slice(i);\n\t\t\t\t\t// the first index is the current value\n\t\t\t\t\tcurve[0] = currentValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._sig.setValueCurveAtTime(curve, time, attack, velocity);\n\t\t}\n\t\t// decay\n\t\tif (decay) {\n\t\t\tconst decayValue = velocity * this.sustain;\n\t\t\tconst decayStart = time + attack;\n\t\t\tthis.log(\"decay\", decayStart);\n\t\t\tif (this._decayCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampTo(decayValue, decay, decayStart + this.sampleTime);\n\t\t\t} else {\n\t\t\t\tthis.assert(this._decayCurve === \"exponential\",\n\t\t\t\t\t`decayCurve can only be \"linear\" or \"exponential\", got ${this._decayCurve}`);\n\t\t\t\tthis._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Triggers the release of the envelope.\n\t * @param  time When the release portion of the envelope should start.\n\t * @example\n\t *  //trigger release immediately\n\t *  env.triggerRelease();\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\ttime = this.toSeconds(time);\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\tconst release = this.toSeconds(this.release);\n\t\t\tif (this._releaseCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampTo(0, release, time);\n\t\t\t} else if (this._releaseCurve === \"exponential\") {\n\t\t\t\tthis._sig.targetRampTo(0, release, time);\n\t\t\t} else {\n\t\t\t\tthis.assert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n\t\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\t\tthis._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Get the scheduled value at the given time. This will\n\t *  return the unconverted (raw) value.\n\t */\n\tgetValueAtTime(time: Time): NormalRange {\n\t\treturn this._sig.getValueAtTime(time);\n\t}\n\n\t/**\n\t *  triggerAttackRelease is shorthand for triggerAttack, then waiting\n\t *  some duration, then triggerRelease.\n\t * @param duration The duration of the sustain.\n\t * @param time When the attack should be triggered.\n\t * @param velocity The velocity of the envelope.\n\t * @example\n\t * //trigger the attack and then the release after 0.6 seconds.\n\t * env.triggerAttackRelease(0.6);\n\t */\n\ttriggerAttackRelease(duration: Time, time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis.triggerAttack(time, velocity);\n\t\tthis.triggerRelease(time + this.toSeconds(duration));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancels all scheduled envelope changes after the given time.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._sig.cancelScheduledValues(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the envelope to a destination node.\n\t */\n\tconnect(destination: InputNode, outputNumber: number = 0, inputNumber: number = 0): this {\n\t\tconnectSignal(this, destination, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sig.dispose();\n\t\treturn this;\n\t}\n}\n\ninterface EnvelopeCurveObject {\n\tIn: number[];\n\tOut: number[];\n}\n\ntype EnvelopeDirection = keyof EnvelopeCurveObject;\n\ninterface EnvelopeCurveMap {\n\tlinear: \"linear\";\n\texponential: \"exponential\";\n\tbounce: EnvelopeCurveObject;\n\tcosine: EnvelopeCurveObject;\n\tsine: EnvelopeCurveObject;\n\tripple: EnvelopeCurveObject;\n\tstep: EnvelopeCurveObject;\n}\n\ntype EnvelopeCurveName =  keyof EnvelopeCurveMap;\n\n/**\n *  Generate some complex envelope curves.\n */\n// tslint:disable-next-line: variable-name\nconst EnvelopeCurves: EnvelopeCurveMap = (() => {\n\n\tconst curveLen = 128;\n\n\tlet i: number;\n\tlet k: number;\n\n\t// cosine curve\n\tconst cosineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tcosineCurve[i] = Math.sin((i / (curveLen - 1)) * (Math.PI / 2));\n\t}\n\n\t// ripple curve\n\tconst rippleCurve: number[] = [];\n\tconst rippleCurveFreq = 6.4;\n\tfor (i = 0; i < curveLen - 1; i++) {\n\t\tk = (i / (curveLen - 1));\n\t\tconst sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n\t\trippleCurve[i] = sineWave / 10 + k * 0.83;\n\t}\n\trippleCurve[curveLen - 1] = 1;\n\n\t// stairs curve\n\tconst stairsCurve: number[] = [];\n\tconst steps = 5;\n\tfor (i = 0; i < curveLen; i++) {\n\t\tstairsCurve[i] = Math.ceil((i / (curveLen - 1)) * steps) / steps;\n\t}\n\n\t// in-out easing curve\n\tconst sineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tsineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n\t}\n\n\t// a bounce curve\n\tconst bounceCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tconst freq = Math.pow(k, 3) * 4 + 0.2;\n\t\tconst val = Math.cos(freq * Math.PI * 2 * k);\n\t\tbounceCurve[i] = Math.abs(val * (1 - k));\n\t}\n\n\t/**\n\t *  Invert a value curve to make it work for the release\n\t */\n\tfunction invertCurve(curve: number[]): number[] {\n\t\tconst out = new Array(curve.length);\n\t\tfor (let j = 0; j < curve.length; j++) {\n\t\t\tout[j] = 1 - curve[j];\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t *  reverse the curve\n\t */\n\tfunction reverseCurve(curve: number[]): number[] {\n\t\treturn curve.slice(0).reverse();\n\t}\n\n\t/**\n\t *  attack and release curve arrays\n\t */\n\treturn {\n\t\tbounce : {\n\t\t\tIn : invertCurve(bounceCurve),\n\t\t\tOut : bounceCurve,\n\t\t},\n\t\tcosine : {\n\t\t\tIn : cosineCurve,\n\t\t\tOut : reverseCurve(cosineCurve),\n\t\t},\n\t\texponential : \"exponential\" as \"exponential\",\n\t\tlinear : \"linear\" as \"linear\",\n\t\tripple : {\n\t\t\tIn : rippleCurve,\n\t\t\tOut : invertCurve(rippleCurve),\n\t\t},\n\t\tsine : {\n\t\t\tIn : sineCurve,\n\t\t\tOut : invertCurve(sineCurve),\n\t\t},\n\t\tstep : {\n\t\t\tIn : stairsCurve,\n\t\t\tOut : invertCurve(stairsCurve),\n\t\t},\n\t};\n})();\n","import { Gain } from \"../../core/context/Gain\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Envelope, EnvelopeOptions } from \"./Envelope\";\n\n/**\n * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.\n * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts\n * an audio signal as the input and will apply the envelope to the amplitude\n * of the signal.\n * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n *\n * @example\n * var ampEnv = new AmplitudeEnvelope({\n * \t\"attack\": 0.1,\n * \t\"decay\": 0.2,\n * \t\"sustain\": 1.0,\n * \t\"release\": 0.8\n * }).toDestination();\n * //create an oscillator and connect it\n * var osc = new Tone.Oscillator().connect(ampEnv).start();\n * //trigger the envelopes attack and release \"8t\" apart\n * ampEnv.triggerAttackRelease(\"8t\");\n */\nexport class AmplitudeEnvelope extends Envelope {\n\n\tname = \"AmplitudeEnvelope\";\n\n\tprivate _gainNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\toutput: Gain = this._gainNode;\n\tinput: Gain = this._gainNode;\n\n\t/**\n\t * @param attack The amount of time it takes for the envelope to go from 0 to it's maximum value.\n\t * @param decay\tThe period of time after the attack that it takes for the envelope\n\t *                       \tto fall to the sustain value. Value must be greater than 0.\n\t * @param sustain\tThe percent of the maximum value that the envelope rests at until\n\t *                                \tthe release is triggered.\n\t * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n\t *                         \tValue must be greater than 0.\n\t */\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tthis._sig.connect(this._gainNode.gain);\n\t\tthis.output = this._gainNode;\n\t\tthis.input = this._gainNode;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.dispose();\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../component/channel/Volume\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels, Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface InstrumentOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n}\n\n/**\n *  Base-class for all instruments\n */\nexport abstract class Instrument<Options extends InstrumentOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t *  The output and volume triming node\n\t */\n\tprivate _volume: Volume;\n\toutput: OutputNode;\n\n\t/**\n\t * The instrument only has an output\n\t */\n\tinput: undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * source.volume.value = -6;\n\t */\n\tvolume: Param<Decibels>;\n\n\t/**\n\t * Keep track of all events scheduled to the transport\n\t * when the instrument is 'synced'\n\t */\n\tprivate _scheduledEvents: number[] = [];\n\n\t/**\n\t * If the instrument is currently synced\n\t */\n\tprivate _synced: boolean = false;\n\n\tconstructor(options?: Partial<InstrumentOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Instrument.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Instrument.getDefaults(), arguments);\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t}\n\n\tstatic getDefaults(): InstrumentOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Sync the instrument to the Transport. All subsequent calls of\n\t * [triggerAttack](#triggerattack) and [triggerRelease](#triggerrelease)\n\t * will be scheduled along the transport.\n\t * @example\n\t * instrument.sync()\n\t * //schedule 3 notes when the transport first starts\n\t * instrument.triggerAttackRelease('C4', '8n', 0)\n\t * instrument.triggerAttackRelease('E4', '8n', '8n')\n\t * instrument.triggerAttackRelease('G4', '8n', '4n')\n\t * //start the transport to hear the notes\n\t * Transport.start()\n\t * @returns {Instrument} this\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 0);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Wrap the given method so that it can be synchronized\n\t * @param method Which method to wrap and sync\n\t * @param  timePosition What position the time argument appears in\n\t */\n\tprotected _syncMethod(method: string, timePosition: number): void {\n\t\tconst originalMethod = this[\"_original_\" + method] = this[method];\n\t\tthis[method] = (...args: any[]) => {\n\t\t\tconst time = args[timePosition];\n\t\t\tconst id = this.context.transport.schedule((t) => {\n\t\t\t\targs[timePosition] = t;\n\t\t\t\toriginalMethod.apply(this, args);\n\t\t\t}, time);\n\t\t\tthis._scheduledEvents.push(id);\n\t\t};\n\t}\n\n\t/**\n\t * Unsync the instrument from the Transport\n\t */\n\tunsync(): this {\n\t\tthis._scheduledEvents.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduledEvents = [];\n\t\tif (this._synced) {\n\t\t\tthis._synced = false;\n\t\t\tthis.triggerAttack = this._original_triggerAttack;\n\t\t\tthis.triggerRelease = this._original_triggerRelease;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Trigger the attack and then the release after the duration.\n\t * @param  note     The note to trigger.\n\t * @param  duration How long the note should be held for before\n\t *                          triggering the release. This value must be greater than 0.\n\t * @param time  When the note should be triggered.\n\t * @param  velocity The velocity the note should be triggered at.\n\t * @example\n\t * //trigger \"C4\" for the duration of an 8th note\n\t * synth.triggerAttackRelease(\"C4\", \"8n\");\n\t */\n\ttriggerAttackRelease(note: Frequency, duration: Time, time?: Time, velocity?: NormalRange): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tthis.triggerAttack(note, computedTime, velocity);\n\t\tthis.triggerRelease(computedTime + computedDuration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the instrument's note.\n\t * @param note the note to trigger\n\t * @param time the time to trigger the ntoe\n\t * @param velocity the velocity to trigger the note (betwee 0-1)\n\t */\n\tabstract triggerAttack(note: Frequency, time?: Time, velocity?: NormalRange): this;\n\t// tslint:disable-next-line: variable-name\n\tprivate _original_triggerAttack = this.triggerAttack;\n\n\t/**\n\t * Trigger the release phase of the current note.\n\t * @param time when to trigger the release\n\t */\n\tabstract triggerRelease(...args: any[]): this;\n\t// tslint:disable-next-line: variable-name\n\tprivate _original_triggerRelease = this.triggerRelease;\n\n\t/**\n\t *  clean up\n\t * @returns {Instrument} this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.unsync();\n\t\tthis._scheduledEvents = [];\n\t\treturn this;\n\t}\n}\n","import { Envelope } from \"../component/envelope/Envelope\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { Cents, Frequency, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { Signal } from \"../signal/Signal\";\n\ntype onSilenceCallback = (instrument: Monophonic<any>) => void;\n\nexport interface MonophonicOptions extends InstrumentOptions {\n\tportamento: Seconds;\n\tonsilence: onSilenceCallback;\n\tdetune: Cents;\n}\n\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport abstract class Monophonic<Options extends MonophonicOptions> extends Instrument<Options> {\n\n\t/**\n\t *  The glide time between notes.\n\t */\n\tportamento: Seconds;\n\n\t/**\n\t * Invoked when the release has finished and the output is silent.\n\t */\n\tonsilence: onSilenceCallback;\n\n\t/**\n\t * The instrument's envelope\n\t */\n\tabstract envelope: Envelope;\n\n\t/**\n\t * The instrument's frequency signal.\n\t */\n\tabstract readonly frequency: Signal<Frequency>;\n\n\t/**\n\t * The instrument's detune control signal.\n\t */\n\tabstract readonly detune: Signal<Cents>;\n\n\tconstructor(options?: Partial<MonophonicOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Monophonic.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n\n\t\tthis.portamento = options.portamento;\n\t\tthis.onsilence = options.onsilence;\n\t}\n\n\tstatic getDefaults(): MonophonicOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tonsilence: noOp,\n\t\t\tportamento: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack of the note optionally with a given velocity.\n\t * @param  note The note to trigger.\n\t * @param  time When the note should start.\n\t * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n\t * @example\n\t * synth.triggerAttack(\"C4\");\n\t * @example\n\t * //trigger the note a half second from now at half velocity\n\t * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n\t */\n\ttriggerAttack(note: Frequency | FrequencyClass, time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", note, time, velocity);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeAttack(seconds, velocity);\n\t\tthis.setNote(note, seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release portion of the envelope\n\t * @param  time If no time is given, the release happens immediatly\n\t * @example\n\t * synth.triggerRelease();\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeRelease(seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal method which starts the envelope attack\n\t */\n\tprotected abstract _triggerEnvelopeAttack(time: Seconds, velocity: NormalRange): void;\n\n\t/**\n\t * Internal method which starts the envelope release\n\t */\n\tprotected abstract _triggerEnvelopeRelease(time: Seconds): void;\n\n\t/**\n\t * Get the level of the output at the given time. Measures\n\t * the envelope(s) value at the time.\n\t * @param time The time to query the envelope value\n\t * @return The output level between 0-1\n\t */\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Set the note at the given time. If no time is given, the note\n\t * will set immediately.\n\t * @param note The note to change to.\n\t * @param  time The time when the note should be set.\n\t * @example\n\t * //change to F#6 in one quarter note from now.\n\t * synth.setNote(\"F#6\", \"+4n\");\n\t * @example\n\t * //change to Bb4 right now\n\t * synth.setNote(\"Bb4\");\n\t */\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n\t\tif (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n\t\t\tconst portTime = this.toSeconds(this.portamento);\n\t\t\tthis.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n\t\t} else {\n\t\t\tthis.frequency.setValueAtTime(computedFrequency, computedTime);\n\t\t}\n\t\treturn this;\n\t}\n}\n","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Cents, Frequency, Seconds } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { OmniOscillatorConstructorOptions, OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\nimport { Source, SourceOptions } from \"../source/Source\";\nimport { Monophonic, MonophonicOptions } from \"./Monophonic\";\n\nexport interface SynthOptions extends MonophonicOptions {\n\toscillator: OmniOscillatorSynthOptions;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Synth is composed simply of a {@link OmniOscillator} routed through an {@link AmplitudeEnvelope}.\n * ```\n * +----------------+   +-------------------+\n * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output\n * +----------------+   +-------------------+\n * ```\n * @example\n * var synth = new Synth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n */\nexport class Synth<Options extends SynthOptions = SynthOptions> extends Monophonic<Options> {\n\n\treadonly name: string = \"Synth\";\n\n\t/**\n\t *  The oscillator.\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The frequency signal\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t * The detune signal\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t * The envelope\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\t/**\n\t * @param options the options available for the synth.\n\t */\n\tconstructor(options?: RecursivePartial<SynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Synth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Synth.getDefaults(), arguments);\n\n\t\tthis.oscillator = new OmniOscillator(Object.assign({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tonstop: () => this.onsilence(this),\n\t\t}, options.oscillator));\n\n\t\tthis.frequency = this.oscillator.frequency;\n\t\tthis.detune = this.oscillator.detune;\n\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.envelope));\n\n\t\t// connect the oscillators to the output\n\t\tthis.oscillator.chain(this.envelope, this.output);\n\t\treadOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): SynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack : 0.005,\n\t\t\t\t\tdecay : 0.1,\n\t\t\t\t\trelease : 1,\n\t\t\t\t\tsustain : 0.3,\n\t\t\t\t},\n\t\t\t),\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"triangle\",\n\t\t\t\t},\n\t\t\t),\n\t\t});\n\t}\n\n\t/**\n\t *  start the attack portion of the envelope\n\t * @param time the time the attack should start\n\t * @param velocity the velocity of the note (0-1)\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// the envelopes\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis.oscillator.start(time);\n\t\t// if there is no release portion, stop the oscillator\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tconst computedAttack = this.toSeconds(this.envelope.attack);\n\t\t\tconst computedDecay = this.toSeconds(this.envelope.decay);\n\t\t\tthis.oscillator.stop(time + computedAttack + computedDecay);\n\t\t}\n\t}\n\n\t/**\n\t *  start the release portion of the envelope\n\t * @param time the time the release should start\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): void {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.oscillator.stop(time + this.toSeconds(this.envelope.release));\n\t}\n\n\t/**\n\t *  clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.oscillator.dispose();\n\t\tthis.envelope.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { Frequency, Interval, MidiNote, NormalRange, Note, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber, isString } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { ToneBufferSource, ToneBufferSourceCurve } from \"../source/buffer/BufferSource\";\n\ninterface SamplesMap {\n\t[note: string]: ToneAudioBuffer | AudioBuffer | string;\n\t[midi: number]: ToneAudioBuffer | AudioBuffer | string;\n}\n\ninterface SamplerOptions extends InstrumentOptions {\n\tattack: Time;\n\trelease: Time;\n\tonload: () => void;\n\tbaseUrl: string;\n\tcurve: ToneBufferSourceCurve;\n\turls: SamplesMap;\n}\n\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * var sampler = new Sampler({\n * \t\"C3\" : \"path/to/C3.mp3\",\n * \t\"D#3\" : \"path/to/Dsharp3.mp3\",\n * \t\"F#3\" : \"path/to/Fsharp3.mp3\",\n * \t\"A3\" : \"path/to/A3.mp3\",\n * }, function(){\n * \t//sampler will repitch the closest sample\n * \tsampler.triggerAttack(\"D3\")\n * })\n */\nexport class Sampler extends Instrument<SamplerOptions> {\n\n\tname = \"Sampler\";\n\n\t/**\n\t * The stored and loaded buffers\n\t * @type {Tone.Buffers}\n\t */\n\tprivate _buffers: ToneAudioBuffers;\n\n\t/**\n\t * The object of all currently playing BufferSources\n\t */\n\tprivate _activeSources: Map<MidiNote, ToneBufferSource[]> = new Map();\n\n\t/**\n\t * The envelope applied to the beginning of the sample.\n\t */\n\tattack: Time;\n\n\t/**\n\t * The envelope applied to the end of the envelope.\n\t */\n\trelease: Time;\n\n\t/**\n\t *  The shape of the attack/release curve.\n\t *  Either \"linear\" or \"exponential\"\n\t */\n\tcurve: ToneBufferSourceCurve;\n\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param onload The callback to invoke when all of the samples are loaded.\n\t * @param baseUrl The root URL of all of the samples, which is prepended to all the URLs.\n\t */\n\tconstructor(samples?: SamplesMap, onload?: () => void, baseUrl?: string);\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param options The remaining options associated with the sampler\n\t */\n\tconstructor(samples?: SamplesMap, options?: Partial<Omit<SamplerOptions, \"urls\">>);\n\tconstructor(options?: Partial<SamplerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n\t\tconst options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n\n\t\tconst urlMap = {};\n\t\tObject.keys(options.urls).forEach((note) => {\n\t\t\tconst noteNumber = parseInt(note, 10);\n\t\t\tthis.assert(isNote(note)\n\t\t\t\t|| (isNumber(noteNumber) && isFinite(noteNumber)), `url key is neither a note or midi pitch: ${note}`);\n\t\t\tif (isNote(note)) {\n\t\t\t\t// convert the note name to MIDI\n\t\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\t\turlMap[mid] = options.urls[note];\n\t\t\t} else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n\t\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\t\turlMap[noteNumber] = options.urls[noteNumber];\n\t\t\t}\n\t\t});\n\n\t\tthis._buffers = new ToneAudioBuffers(urlMap, options.onload, options.baseUrl);\n\t\tthis.attack = options.attack;\n\t\tthis.release = options.release;\n\t\tthis.curve = options.curve;\n\t}\n\n\tstatic getDefaults(): SamplerOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tattack : 0,\n\t\t\tbaseUrl : \"\",\n\t\t\tcurve : \"exponential\" as \"exponential\",\n\t\t\tonload : noOp,\n\t\t\trelease : 0.1,\n\t\t\turls: {},\n\t\t});\n\t}\n\n\t/**\n\t * Returns the difference in steps between the given midi note at the closets sample.\n\t */\n\tprivate _findClosest(midi: MidiNote): Interval {\n\t\t// searches within 8 octaves of the given midi note\n\t\tconst MAX_INTERVAL = 96;\n\t\tlet interval = 0;\n\t\twhile (interval < MAX_INTERVAL) {\n\t\t\t// check above and below\n\t\t\tif (this._buffers.has(midi + interval)) {\n\t\t\t\treturn -interval;\n\t\t\t} else if (this._buffers.has(midi - interval)) {\n\t\t\t\treturn interval;\n\t\t\t}\n\t\t\tinterval++;\n\t\t}\n\t\tthrow new Error(`No available buffers for note: ${midi}`);\n\t}\n\n\t/**\n\t * @param  notes\tThe note to play, or an array of notes.\n\t * @param  time     When to play the note\n\t * @param  velocity The velocity to play the sample back.\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", notes, time, velocity);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midi = new FrequencyClass(this.context, note).toMidi();\n\t\t\t// find the closest note pitch\n\t\t\tconst difference = this._findClosest(midi);\n\t\t\tconst closestNote = midi - difference;\n\t\t\tconst buffer = this._buffers.get(closestNote);\n\t\t\tconst playbackRate = intervalToFrequencyRatio(difference);\n\t\t\t// play that note\n\t\t\tconst source = new ToneBufferSource({\n\t\t\t\tbuffer,\n\t\t\t\tcontext: this.context,\n\t\t\t\tcurve : this.curve,\n\t\t\t\tfadeIn : this.attack,\n\t\t\t\tfadeOut : this.release,\n\t\t\t\tplaybackRate,\n\t\t\t}).connect(this.output);\n\t\t\tsource.start(time, 0, buffer.duration / playbackRate, velocity);\n\t\t\t// add it to the active sources\n\t\t\tif (!isArray(this._activeSources.get(midi))) {\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t\t(this._activeSources.get(midi) as ToneBufferSource[]).push(source);\n\n\t\t\t// remove it when it's done\n\t\t\tsource.onended = () => {\n\t\t\t\tif (this._activeSources && this._activeSources.has(midi)) {\n\t\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\t\tconst index = sources.indexOf(source);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tsources.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param  notes\tThe note to release, or an array of notes.\n\t * @param  time     \tWhen to release the note.\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tthis.log(\"triggerRelease\", notes, time);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midi = new FrequencyClass(this.context, note).toMidi();\n\t\t\t// find the note\n\t\t\tif (this._activeSources.has(midi) && (this._activeSources.get(midi) as ToneBufferSource[]).length) {\n\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\ttime = this.toSeconds(time);\n\t\t\t\tsources.forEach(source => {\n\t\t\t\t\tsource.stop(time);\n\t\t\t\t});\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Release all currently active notes.\n\t * @param  time     \tWhen to release the notes.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(sources => {\n\t\t\twhile (sources.length) {\n\t\t\t\tconst source = sources.shift() as ToneBufferSource;\n\t\t\t\tsource.stop(computedTime);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the instrument to the Transport. All subsequent calls of\n\t * [triggerAttack](#triggerattack) and [triggerRelease](#triggerrelease)\n\t * will be scheduled along the transport.\n\t * @example\n\t * synth.sync()\n\t * //schedule 3 notes when the transport first starts\n\t * synth.triggerAttackRelease('8n', 0)\n\t * synth.triggerAttackRelease('8n', '8n')\n\t * synth.triggerAttackRelease('8n', '4n')\n\t * //start the transport to hear the notes\n\t * Transport.start()\n\t * @returns {Tone.Instrument} this\n\t */\n\tsync(): this {\n\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the attack phase, then after the duration, invoke the release.\n\t * @param  notes\tThe note to play and release, or an array of notes.\n\t * @param  duration The time the note should be held\n\t * @param  time     When to start the attack\n\t * @param  velocity The velocity of the attack\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency[] | Frequency,\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tthis.assert(isArray(notes), \"notes must be an array when duration is array\");\n\t\t\t(notes as Frequency[]).forEach((note, index) => {\n\t\t\t\tconst d = duration[Math.min(index, duration.length - 1)];\n\t\t\t\tthis.triggerRelease(note, computedTime + this.toSeconds(d));\n\t\t\t});\n\t\t} else {\n\t\t\tthis.triggerRelease(notes, computedTime + this.toSeconds(duration));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a note to the sampler.\n\t * @param  note      The buffer's pitch.\n\t * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(note: Note | MidiNote, url: string | ToneAudioBuffer | AudioBuffer, callback?: () => void): this {\n\t\tthis.assert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n\t\tif (isNote(note)) {\n\t\t\t// convert the note name to MIDI\n\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\tthis._buffers.add(mid, url, callback);\n\t\t} else {\n\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\tthis._buffers.add(note, url, callback);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffers.loaded;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.dispose();\n\t\tthis._activeSources.forEach(sources => {\n\t\t\tsources.forEach(source => source.dispose());\n\t\t});\n\t\tthis._activeSources.clear();\n\t\treturn this;\n\t}\n}\n","import { MidiClass } from \"../core/type/Midi\";\nimport { Frequency, MidiNote, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { isArray } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\nimport { MembraneSynth, MembraneSynthOptions } from \"./MembraneSynth\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth, SynthOptions } from \"./Synth\";\n\ntype VoiceConstructor<V> = {\n\tgetDefaults: () => VoiceOptions<V>,\n} & (new (...args: any[]) => V);\n\ntype OmitMonophonicOptions<T> = Omit<T, \"context\" | \"onsilence\">;\n\ntype VoiceOptions<T> =\n\tT extends MembraneSynth ? MembraneSynthOptions :\n\tT extends Synth ? SynthOptions :\n\tnever;\n\n/**\n * The settable synth options. excludes monophonic options.\n */\ntype PartialVoiceOptions<T> = RecursivePartial<\n\tOmitMonophonicOptions<\n\t\tVoiceOptions<T>\n\t>\n>;\n\ninterface PolySynthOptions<Voice> extends InstrumentOptions {\n\tmaxPolyphony: number;\n\tvoice: VoiceConstructor<Voice>;\n\toptions: PartialVoiceOptions<Voice>;\n}\n\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * var synth = new PolySynth(Tone.Synth, {\n *   oscillator : {\n * \t\ttype : \"square\"\n * \t}\n * }).toMaster();\n * //set the attributes using the set interface\n * synth.set(\"detune\", -1200);\n * //play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], \"4n\");\n */\nexport class PolySynth<Voice extends Monophonic<any> = Synth> extends Instrument<VoiceOptions<Voice>> {\n\n\treadonly name = \"PolySynth\";\n\n\t/**\n\t * The voices which are not currently in use\n\t */\n\tprivate _availableVoices: Voice[] = [];\n\n\t/**\n\t * The currently active voices\n\t */\n\tprivate _activeVoices: Array<{midi: MidiNote, voice: Voice}> = [];\n\n\t/**\n\t * All of the allocated voices for this synth.\n\t */\n\tprivate _voices: Voice[] = [];\n\n\t/**\n\t * The options that are set on the synth.\n\t */\n\tprivate options: VoiceOptions<Voice>;\n\n\t/**\n\t * The polyphony limit.\n\t */\n\tmaxPolyphony: number;\n\n\t/**\n\t * The voice constructor\n\t */\n\tprivate readonly voice: VoiceConstructor<Voice>;\n\n\t/**\n\t * The GC timeout. Held so that it could be cancelled when the node is disposed.\n\t */\n\tprivate _gcTimeout: number = -1;\n\n\t/**\n\t * A moving average of the number of active voices\n\t */\n\tprivate _averageActiveVoices: number = 0;\n\n\t/**\n\t * @param voice The constructor of the voices\n\t * @param options\tThe options object to set the synth voice\n\t */\n\tconstructor(\n\t\tvoice?: VoiceConstructor<Voice>,\n\t\toptions?: PartialVoiceOptions<Voice>,\n\t);\n\tconstructor(options?: Partial<PolySynthOptions<Voice>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n\t\tconst options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]);\n\n\t\tconst defaults = options.voice.getDefaults();\n\t\tthis.options = Object.assign(defaults, options.options) as VoiceOptions<Voice>;\n\t\tthis.voice = options.voice as unknown as VoiceConstructor<Voice>;\n\t\tthis.maxPolyphony = options.maxPolyphony;\n\n\t\t// kick off the GC interval\n\t\tthis._collectGarbage();\n\t}\n\n\tstatic getDefaults(): PolySynthOptions<Synth> {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tmaxPolyphony: 32,\n\t\t\toptions: {},\n\t\t\tvoice: Synth,\n\t\t});\n\t}\n\n\t/**\n\t * The number of active voices.\n\t */\n\tget activeVoices(): number {\n\t\treturn this._activeVoices.length;\n\t}\n\n\t/**\n\t * If there is a voice active on that note, return it\n\t */\n\tprivate _getActiveVoice(note: MidiNote): Voice | undefined {\n\t\tconst event = this._activeVoices.find(({midi}) => midi === note);\n\t\tif (event) {\n\t\t\treturn event.voice;\n\t\t}\n\t}\n\n\t/**\n\t * Invoked when the source is done making sound, so that it can be\n\t * readded to the pool of available voices\n\t */\n\tprivate _makeVoiceAvailable(voice: Voice): void {\n\t\tthis._availableVoices.push(voice);\n\t\t// remove the midi note from 'active voices'\n\t\tconst activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);\n\t\tthis._activeVoices.splice(activeVoiceIndex, 1);\n\t}\n\n\t/**\n\t * Get an available voice from the pool of available voices.\n\t * If one is not available and the maxPolyphony limit is reached,\n\t * steal a voice, otherwise return null.\n\t */\n\tprivate _getNextAvailableVoice(): Voice | undefined {\n\t\t// if there are available voices, return the first one\n\t\tif (this._availableVoices.length) {\n\t\t\treturn this._availableVoices.shift();\n\t\t} else if (this._voices.length < this.maxPolyphony) {\n\t\t\t// otherwise if there is still more maxPolyphony, make a new voice\n\t\t\tconst voice = new this.voice(Object.assign(this.options, {\n\t\t\t\tcontext: this.context,\n\t\t\t\tonsilence: this._makeVoiceAvailable.bind(this),\n\t\t\t}));\n\t\t\tvoice.connect(this.output);\n\t\t\tthis._voices.push(voice);\n\t\t\treturn voice;\n\t\t} else {\n\t\t\tconsole.warn(\"Max polyphony exceeded. Note dropped.\");\n\t\t}\n\t}\n\n\t/**\n\t * Occasionally check if there are any allocated voices which can be cleaned up.\n\t */\n\tprivate _collectGarbage(): void {\n\t\tthis._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n\t\tif (this._availableVoices.length && this._voices.length > this._averageActiveVoices) {\n\t\t\t// take off an available note\n\t\t\tconst firstAvail = this._availableVoices.shift() as Voice;\n\t\t\tconst index = this._voices.indexOf(firstAvail);\n\t\t\tthis._voices.splice(index, 1);\n\t\t\tfirstAvail.dispose();\n\t\t}\n\t\tthis._gcTimeout = this.context.setTimeout(this._collectGarbage.bind(this), 1);\n\t\treturn;\n\t}\n\n\t/**\n\t * Internal method which triggers the attack\n\t */\n\tprivate _triggerAttack(notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\t// let voice: Voice | undefined;\n\t\t\t// if there's already a note at that voice, reuse it\n\t\t\tlet voice = this._getActiveVoice(midiNote);\n\t\t\t// if it has a note, and that note is still active\n\t\t\tif (voice && voice.getLevelAtTime(time) > 0) {\n\t\t\t\tconst activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);\n\t\t\t\tthis._activeVoices.splice(activeVoiceIndex, 1);\n\t\t\t} else {\n\t\t\t\t// otherwise get the next available voice\n\t\t\t\tvoice = this._getNextAvailableVoice();\n\t\t\t}\n\t\t\tif (voice) {\n\t\t\t\tvoice.triggerAttack(note, time, velocity);\n\t\t\t\tthis._activeVoices.unshift({\n\t\t\t\t\tmidi: midiNote, voice,\n\t\t\t\t});\n\t\t\t\tthis.log(\"triggerAttack\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Internal method which triggers the release\n\t */\n\tprivate _triggerRelease(notes: Frequency[], time: Seconds): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst voice = this._getActiveVoice(midiNote);\n\t\t\tif (voice) {\n\t\t\t\t// trigger release on that note\n\t\t\t\tvoice.triggerRelease(time);\n\t\t\t\tthis.log(\"triggerRelease\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n\t * to wait for just-in-time scheduling\n\t */\n\tprivate _scheduleEvent(type: \"attack\" | \"release\", notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tthis.assert(!this.disposed, \"Synth was already disposed\");\n\t\t// if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\t\tif (time <= this.now()) {\n\t\t\t// do it immediately\n\t\t\tif (type === \"attack\") {\n\t\t\t\tthis._triggerAttack(notes, time, velocity);\n\t\t\t} else {\n\t\t\t\tthis._triggerRelease(notes, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// schedule it to start in the future\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tthis._scheduleEvent(type, notes, time, velocity);\n\t\t\t}, time - this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  The start time of the note.\n\t * @param velocity The velocity of the note.\n\t * @example\n\t * //trigger a chord immediately with a velocity of 0.2\n\t * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"], undefined, 0.2);\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity?: NormalRange): this {\n\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release of the note. Unlike monophonic instruments,\n\t * a note (or array of notes) needs to be passed in as the first argument.\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  When the release will be triggered.\n\t * @example\n\t * poly.triggerRelease([\"Ab3\", \"C4\", \"F5\"], \"+2n\");\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"release\", notes, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and release after the specified duration\n\t * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n\t * @param  duration the duration of the note\n\t * @param  time  if no time is given, defaults to now\n\t * @param  velocity the velocity of the attack (0-1)\n\t * @example\n\t * //trigger a chord for a duration of a half note\n\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"C5\"], \"2n\");\n\t * @example\n\t * //can pass in an array of durations as well\n\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"C5\"], [\"2n\", \"4n\", \"4n\"]);\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency | Frequency[],\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity?: NormalRange,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tthis.assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n\t\t\tnotes = notes as Frequency[];\n\t\t\tfor (let i = 0; i < notes.length; i++) {\n\t\t\t\tconst d = duration[Math.min(i, duration.length - 1)];\n\t\t\t\tconst durationSeconds = this.toSeconds(d);\n\t\t\t\tthis.assert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\t\tthis.triggerRelease(notes[i], computedTime + durationSeconds);\n\t\t\t}\n\t\t} else {\n\t\t\tconst durationSeconds = this.toSeconds(duration);\n\t\t\tthis.assert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\tthis.triggerRelease(notes, computedTime + durationSeconds);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the instrument to the Transport. All subsequent calls of\n\t * {@link triggerAttack} and {@link triggerRelease} will be scheduled along the transport.\n\t * @example\n\t * synth.sync()\n\t * //schedule 3 notes when the transport first starts\n\t * synth.triggerAttackRelease('8n', 0)\n\t * synth.triggerAttackRelease('8n', '8n')\n\t * synth.triggerAttackRelease('8n', '4n')\n\t * //start the transport to hear the notes\n\t * Transport.start()\n\t */\n\tsync(): this {\n\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a member/attribute of the voices\n\t * @example\n\t * poly.set({\n\t * \t\"filter\" : {\n\t * \t\t\"type\" : \"highpass\"\n\t * \t},\n\t * \t\"envelope\" : {\n\t * \t\t\"attack\" : 0.25\n\t * \t}\n\t * });\n\t */\n\tset(options: RecursivePartial<VoiceOptions<Voice>>): this {\n\t\tthis.options = deepMerge(this.options, options);\n\t\tthis._voices.forEach(voice => voice.set(this.options));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Get the synth's attributes.\n\t */\n\tget(): VoiceOptions<Voice> {\n\t\t// return a clone of the options\n\t\treturn Object.assign({}, this.options);\n\t}\n\n\t/**\n\t * Trigger the release portion of all the currently active voices immediately.\n\t * Useful for silencing the synth.\n\t */\n\treleaseAll(): this {\n\t\tconst now = this.now();\n\t\tthis._activeVoices.forEach(({voice}) => {\n\t\t\tvoice.triggerRelease(now);\n\t\t});\n\t\tthis._activeVoices = [];\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._voices.forEach(v => v.dispose());\n\t\tthis._activeVoices = [];\n\t\tthis._availableVoices = [];\n\t\tthis.context.clearTimeout(this._gcTimeout);\n\t\treturn this;\n\t}\n}\n","import { FrequencyClass } from \"../core/type/Frequency\";\nimport { Frequency, Positive, Time } from \"../core/type/Units\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth, SynthOptions } from \"./Synth\";\n\nexport interface MembraneSynthOptions extends SynthOptions {\n\tpitchDecay: Time;\n\toctaves: Positive;\n}\n\n/**\n * MembraneSynth makes kick and tom sounds using a single oscillator\n * with an amplitude envelope and frequency ramp. A Tone.OmniOscillator\n * is routed through a Tone.AmplitudeEnvelope to the output. The drum\n * quality of the sound comes from the frequency envelope applied\n * during MembraneSynth.triggerAttack(note). The frequency envelope\n * starts at <code>note * .octaves</code> and ramps to <code>note</code>\n * over the duration of <code>.pitchDecay</code>.\n * @example\n * var synth = new MembraneSynth().toMaster();\n * synth.triggerAttackRelease(\"C2\", \"8n\");\n */\nexport class MembraneSynth extends Synth<MembraneSynthOptions> {\n\n\treadonly name = \"MembraneSynth\";\n\n\t/**\n\t *  The number of octaves the pitch envelope ramps.\n\t */\n\toctaves: Positive;\n\n\t/**\n\t *  The amount of time the frequency envelope takes.\n\t */\n\tpitchDecay: Time;\n\n\t/**\n\t * Portamento is ignored in this synth. use pitch decay instead.\n\t */\n\treadonly portamento = 0;\n\n\t/**\n\t * @param options the options available for the synth see defaults\n\t */\n\tconstructor(options?: RecursivePartial<MembraneSynthOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(MembraneSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(MembraneSynth.getDefaults(), arguments);\n\n\t\tthis.pitchDecay = options.pitchDecay;\n\t\tthis.octaves = options.octaves;\n\t\treadOnly(this, [\"oscillator\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): MembraneSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {\n\t\t\tenvelope : {\n\t\t\t\tattack : 0.001,\n\t\t\t\tattackCurve : \"exponential\",\n\t\t\t\tdecay : 0.4,\n\t\t\t\trelease : 1.4,\n\t\t\t\tsustain : 0.01,\n\t\t\t},\n\t\t\toctaves: 10,\n\t\t\toscillator: {\n\t\t\t\ttype: \"sine\",\n\t\t\t},\n\t\t\tpitchDecay: 0.05,\n\t\t});\n\t}\n\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst seconds = this.toSeconds(time);\n\t\tconst hertz = this.toFrequency(note instanceof FrequencyClass ? note.toFrequency() : note);\n\t\tconst maxNote = hertz * this.octaves;\n\t\tthis.oscillator.frequency.setValueAtTime(maxNote, seconds);\n\t\tthis.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\treturn this;\n\t}\n}\n","import \"../core/clock/Transport\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../core/context/ToneWithContext\";\nimport { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline } from \"../core/util/StateTimeline\";\nimport { isBoolean, isNumber } from \"../core/util/TypeCheck\";\n\nexport type ToneEventCallback<T> = (time: Seconds, value: T) => void;\n\nexport interface ToneEventOptions<T> extends ToneWithContextOptions {\n\tcallback: ToneEventCallback<T>;\n\tloop: boolean | number;\n\tloopEnd: Time;\n\tloopStart: Time;\n\tplaybackRate: Positive;\n\tvalue?: T;\n\tprobability: NormalRange;\n\tmute: boolean;\n\thumanize: boolean | Time;\n}\n\n/**\n * ToneEvent abstracts away this.context.transport.schedule and provides a schedulable\n * callback for a single or repeatable events along the timeline.\n *\n * @example\n * var chord = new ToneEvent(function(time, chord){\n * \t//the chord as well as the exact time of the event\n * \t//are passed in as arguments to the callback function\n * }, [\"D4\", \"E4\", \"F4\"]);\n * //start the chord at the beginning of the transport timeline\n * chord.start();\n * //loop it every measure for 8 measures\n * chord.loop = 8;\n * chord.loopEnd = \"1m\";\n */\nexport class ToneEvent<ValueType = any> extends ToneWithContext<ToneEventOptions<ValueType>> {\n\n\tname = \"ToneEvent\";\n\n\t/**\n\t *  Loop value\n\t */\n\tprotected _loop: boolean | number;\n\n\t/**\n\t *  The callback to invoke.\n\t */\n\tcallback: ToneEventCallback<ValueType>;\n\n\t/**\n\t *  The value which is passed to the\n\t *  callback function.\n\t */\n\tvalue: ValueType;\n\n\t/**\n\t *  When the note is scheduled to start.\n\t */\n\tprotected _loopStart: Ticks;\n\n\t/**\n\t *  When the note is scheduled to start.\n\t */\n\tprotected _loopEnd: Ticks;\n\n\t/**\n\t *  Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number,\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t *  The playback speed of the note. A speed of 1\n\t *  is no change.\n\t */\n\tprotected _playbackRate: Positive;\n\n\t/**\n\t *  A delay time from when the event is scheduled to start\n\t */\n\tprotected _startOffset: Ticks = 0;\n\n\t/**\n\t *  private holder of probability value\n\t */\n\tprotected _probability: NormalRange;\n\n\t/**\n\t *  the amount of variation from the given time.\n\t */\n\tprotected _humanize: boolean | Time;\n\n\t/**\n\t *  If mute is true, the callback won't be invoked.\n\t */\n\tmute: boolean;\n\n\t/**\n\t * @param callback The callback to invoke at the time.\n\t * @param value The value or values which should be passed to the callback function on invocation.\n\t */\n\tconstructor(callback?: ToneEventCallback<ValueType>, value?: ValueType);\n\tconstructor(options?: Partial<ToneEventOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]));\n\t\tconst options = optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]);\n\n\t\tthis._loop = options.loop;\n\t\tthis.callback = options.callback;\n\t\tthis.value = options.value;\n\t\tthis._loopStart = this.toTicks(options.loopStart);\n\t\tthis._loopEnd = this.toTicks(options.loopEnd);\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._probability = options.probability;\n\t\tthis._humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): ToneEventOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback : noOp,\n\t\t\thumanize : false,\n\t\t\tloop : false,\n\t\t\tloopEnd : \"1m\",\n\t\t\tloopStart : 0,\n\t\t\tmute : false,\n\t\t\tplaybackRate : 1,\n\t\t\tprobability : 1,\n\t\t\tvalue : null,\n\t\t});\n\t}\n\n\t/**\n\t *  Reschedule all of the events along the timeline\n\t *  with the updated values.\n\t * @param after Only reschedules events after the given time.\n\t */\n\tprivate _rescheduleEvents(after: Ticks = -1): void {\n\t\t// if no argument is given, schedules all of the events\n\t\tthis._state.forEachFrom(after, event => {\n\t\t\tlet duration;\n\t\t\tif (event.state === \"started\") {\n\t\t\t\tif (event.id !== -1) {\n\t\t\t\t\tthis.context.transport.clear(event.id);\n\t\t\t\t}\n\t\t\t\tconst startTick = event.time + Math.round(this.startOffset / this._playbackRate);\n\t\t\t\tif (this._loop === true || isNumber(this._loop) && this._loop > 1) {\n\t\t\t\t\tduration = Infinity;\n\t\t\t\t\tif (isNumber(this._loop)) {\n\t\t\t\t\t\tduration = (this._loop) * this._getLoopDuration();\n\t\t\t\t\t}\n\t\t\t\t\tconst nextEvent = this._state.getAfter(startTick);\n\t\t\t\t\tif (nextEvent !== null) {\n\t\t\t\t\t\tduration = Math.min(duration, nextEvent.time - startTick);\n\t\t\t\t\t}\n\t\t\t\t\tif (duration !== Infinity) {\n\t\t\t\t\t\t// schedule a stop since it's finite duration\n\t\t\t\t\t\tthis._state.setStateAtTime(\"stopped\", startTick + duration + 1, { id : -1 });\n\t\t\t\t\t\tduration = new TicksClass(this.context, duration);\n\t\t\t\t\t}\n\t\t\t\t\tconst interval = new TicksClass(this.context, this._getLoopDuration());\n\t\t\t\t\tevent.id = this.context.transport.scheduleRepeat(\n\t\t\t\t\t\tthis._tick.bind(this), interval, new TicksClass(this.context, startTick), duration);\n\t\t\t\t} else {\n\t\t\t\t\tevent.id = this.context.transport.schedule(this._tick.bind(this), new TicksClass(this.context, startTick));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t *  Returns the playback state of the note, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._state.getValueAtTime(this.context.transport.ticks) as BasicPlaybackState;\n\t}\n\n\t/**\n\t * The start from the scheduled start time.\n\t */\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t}\n\n\t/**\n\t *  The probability of the notes being triggered.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t}\n\n\t/**\n\t *  If set to true, will apply small random variation\n\t *  to the callback time. If the value is given as a time, it will randomize\n\t *  by that amount.\n\t * @example\n\t * event.humanize = true;\n\t */\n\tget humanize(): Time | boolean {\n\t\treturn this._humanize;\n\t}\n\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t}\n\n\t/**\n\t *  Start the note at the given time.\n\t * @param  time  When the event should start.\n\t */\n\tstart(time?: TransportTime | TransportTimeClass): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) === \"stopped\") {\n\t\t\tthis._state.add({\n\t\t\t\tid : -1,\n\t\t\t\tstate : \"started\",\n\t\t\t\ttime: ticks,\n\t\t\t});\n\t\t\tthis._rescheduleEvents(ticks);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the Event at the given time.\n\t * @param  time  When the event should stop.\n\t */\n\tstop(time?: TransportTime | TransportTimeClass): this {\n\t\tthis.cancel(time);\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"stopped\", ticks, { id: -1 });\n\t\t\tconst previousEvent = this._state.getBefore(ticks);\n\t\t\tlet reschedulTime = ticks;\n\t\t\tif (previousEvent !== null) {\n\t\t\t\treschedulTime = previousEvent.time;\n\t\t\t}\n\t\t\tthis._rescheduleEvents(reschedulTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel all scheduled events greater than or equal to the given time\n\t * @param  time  The time after which events will be cancel.\n\t */\n\tcancel(time?: TransportTime | TransportTimeClass): this {\n\t\ttime = defaultArg(time, -Infinity);\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.forEachFrom(ticks, event => {\n\t\t\tthis.context.transport.clear(event.id);\n\t\t});\n\t\tthis._state.cancel(ticks);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The callback function invoker. Also\n\t *  checks if the Event is done playing\n\t * @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tconst ticks = this.context.transport.getTicksAtTime(time);\n\t\tif (!this.mute && this._state.getValueAtTime(ticks) === \"started\") {\n\t\t\tif (this.probability < 1 && Math.random() > this.probability) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.humanize) {\n\t\t\t\tlet variation = 0.02;\n\t\t\t\tif (!isBoolean(this.humanize)) {\n\t\t\t\t\tvariation = this.toSeconds(this.humanize);\n\t\t\t\t}\n\t\t\t\ttime += (Math.random() * 2 - 1) * variation;\n\t\t\t}\n\t\t\tthis.callback(time, this.value);\n\t\t}\n\t}\n\n\t/**\n\t *  Get the duration of the loop.\n\t */\n\tprotected _getLoopDuration(): Ticks {\n\t\treturn Math.round((this._loopEnd - this._loopStart) / this._playbackRate);\n\t}\n\n\t/**\n\t *  If the note should loop or not\n\t *  between ToneEvent.loopStart and\n\t *  ToneEvent.loopEnd. If set to true,\n\t *  the event will loop indefinitely,\n\t *  if set to a number greater than 1\n\t *  it will play a specific number of\n\t *  times, if set to false, 0 or 1, the\n\t *  part will only play once.\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t * \tThe playback rate of the note. Defaults to 1.\n\t * @example\n\t * note.loop = true;\n\t * //repeat the note twice as fast\n\t * note.playbackRate = 2;\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t *  The loopEnd point is the time the event will loop\n\t *  if ToneEvent.loop is true.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t *  The time when the loop should start.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t *  The current progress of the loop interval.\n\t *  Returns 0 if the event is not started yet or\n\t *  it is not set to loop.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this._loop) {\n\t\t\tconst ticks = this.context.transport.ticks;\n\t\t\tconst lastEvent = this._state.get(ticks);\n\t\t\tif (lastEvent !== null && lastEvent.state === \"started\") {\n\t\t\t\tconst loopDuration = this._getLoopDuration();\n\t\t\t\tconst progress = (ticks - lastEvent.time) % loopDuration;\n\t\t\t\treturn progress / loopDuration;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.cancel();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n","import { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype CallbackType<T> =\n\tT extends {\n\t\ttime: Time;\n\t\t[key: string]: any,\n\t} ? T :\n\tT extends ArrayLike<any> ? T[1] :\n\tT extends Time ? null : never;\n\ninterface PartOptions<T> extends Omit<ToneEventOptions<CallbackType<T>>, \"value\"> {\n\tevents: T[];\n}\n\n/**\n * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n * @example\n * var part = new Part(function(time, note){\n * \t//the notes given as the second element in the array\n * \t//will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }, [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n * @example\n * //use an array of objects as long as the object has a \"time\" attribute\n * var part = new Part(function(time, value){\n * \t//the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }, [{\"time\" : 0, \"note\" : \"C3\", \"velocity\": 0.9},\n * \t   {\"time\" : \"0:2\", \"note\" : \"C4\", \"velocity\": 0.5}\n * ]).start(0);\n */\nexport class Part<ValueType = any> extends ToneEvent<ValueType> {\n\n\tname = \"Part\";\n\n\t/**\n\t *  Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number,\n\t\toffset: number,\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The events that belong to this part\n\t */\n\tprivate _events: Set<ToneEvent> = new Set();\n\n\t/**\n\t * @param callback The callback to invoke on each event\n\t * @param events the array of events\n\t */\n\tconstructor(callback?: ToneEventCallback<CallbackType<ValueType>>, value?: ValueType[]);\n\tconstructor(options?: Partial<PartOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]));\n\t\tconst options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]);\n\n\t\t// add the events\n\t\toptions.events.forEach(event => {\n\t\t\tif (isArray(event)) {\n\t\t\t\tthis.add(event[0], event[1]);\n\t\t\t} else {\n\t\t\t\tthis.add(event);\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic getDefaults(): PartOptions<any> {\n\t\treturn Object.assign(ToneEvent.getDefaults(), {\n\t\t\tevents: [],\n\t\t});\n\t}\n\n\t/**\n\t *  Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset from the start of the part to begin playing at.\n\t */\n\tstart(time?: TransportTime, offset?: Time): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) !== \"started\") {\n\t\t\toffset = defaultArg(offset, this._loop ? this._loopStart : 0);\n\t\t\tif (this._loop) {\n\t\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t\t} else {\n\t\t\t\toffset = defaultArg(offset, 0);\n\t\t\t}\n\t\t\tconst computedOffset = this.toTicks(offset);\n\t\t\tthis._state.add({\n\t\t\t\tid : -1,\n\t\t\t\toffset: computedOffset,\n\t\t\t\tstate : \"started\",\n\t\t\t\ttime : ticks,\n\t\t\t});\n\t\t\tthis._forEach(event => {\n\t\t\t\tthis._startNote(event, ticks, computedOffset);\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Start the event in the given event at the correct time given\n\t *  the ticks and offset and looping.\n\t * @param  event\n\t * @param  ticks\n\t * @param  offset\n\t */\n\tprivate _startNote(event: ToneEvent, ticks: Ticks, offset: Ticks): void {\n\t\tticks -= offset;\n\t\tif (this._loop) {\n\t\t\tif (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n\t\t\t\tif (event.startOffset < offset) {\n\t\t\t\t\t// start it on the next loop\n\t\t\t\t\tticks += this._getLoopDuration();\n\t\t\t\t}\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t} else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n\t\t\t\tevent.loop = false;\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t}\n\t\t} else if (event.startOffset >= offset) {\n\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t\tthis._forEach(event => {\n\t\t\tevent.startOffset += this._startOffset;\n\t\t});\n\t}\n\n\t/**\n\t *  Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.cancel(ticks);\n\t\tthis._state.setStateAtTime(\"stopped\", ticks);\n\t\tthis._forEach(event => {\n\t\t\tevent.stop(time);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get/Set an Event's value at the given time.\n\t * If a value is passed in and no event exists at\n\t * the given time, one will be created with that value.\n\t * If two events are at the same time, the first one will\n\t * be returned.\n\t * @example\n\t * part.at(\"1m\"); //returns the part at the first measure\n\t * part.at(\"2m\", \"C2\"); //set the value at \"2m\" to C2.\n\t * //if an event didn't exist at that time, it will be created.\n\t * @param time The time of the event to get or set.\n\t * @param value If a value is passed in, the value of the event at the given time will be set to it.\n\t */\n\tat(time: Time, value?: any): ToneEvent | null {\n\t\tconst timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n\t\tconst tickTime = new TicksClass(this.context, 1).toSeconds();\n\n\t\tconst iterator = this._events.values();\n\t\tlet result = iterator.next();\n\t\twhile (!result.done) {\n\t\t\tconst event = result.value;\n\t\t\tif (Math.abs(timeInTicks - event.startOffset) < tickTime) {\n\t\t\t\tif (isDefined(value)) {\n\t\t\t\t\tevent.value = value;\n\t\t\t\t}\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tresult = iterator.next();\n\t\t}\n\t\t// if there was no event at that time, create one\n\t\tif (isDefined(value)) {\n\t\t\tthis.add(time, value);\n\t\t\t// return the new event\n\t\t\treturn this.at(time);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t *  Add a an event to the part.\n\t * @param time The time the note should start. If an object is passed in, it should\n\t *  \t\t\thave a 'time' attribute and the rest of the object will be used as the 'value'.\n\t * @param  value\n\t * @example\n\t * part.add(\"1m\", \"C#+11\");\n\t * @example\n\t * part.add({\n\t * \ttime: \"1m\",\n\t * \tnote: \"C#11\"\n\t * });\n\t */\n\tadd(obj: {\n\t\ttime: Time,\n\t\t[key: string]: any;\n\t}): this;\n\tadd(time: Time, value?: any): this;\n\tadd(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (time instanceof Object && Reflect.has(time, \"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\tconst ticks = this.toTicks(time);\n\t\tlet event: ToneEvent;\n\t\tif (value instanceof ToneEvent) {\n\t\t\tevent = value;\n\t\t\tevent.callback = this._tick.bind(this);\n\t\t} else {\n\t\t\tevent = new ToneEvent({\n\t\t\t\tcallback : this._tick.bind(this),\n\t\t\t\tcontext: this.context,\n\t\t\t\tvalue,\n\t\t\t});\n\t\t}\n\t\t// the start offset\n\t\tevent.startOffset = ticks;\n\n\t\t// initialize the values\n\t\tevent.set({\n\t\t\thumanize : this.humanize,\n\t\t\tloop : this.loop,\n\t\t\tloopEnd : this.loopEnd,\n\t\t\tloopStart : this.loopStart,\n\t\t\tplaybackRate : this.playbackRate,\n\t\t\tprobability : this.probability,\n\t\t});\n\n\t\tthis._events.add(event);\n\n\t\t// start the note if it should be played right now\n\t\tthis._restartEvent(event);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Restart the given event\n\t */\n\tprivate _restartEvent(event: ToneEvent): void {\n\t\tthis._state.forEach((stateEvent) => {\n\t\t\tif (stateEvent.state === \"started\") {\n\t\t\t\tthis._startNote(event, stateEvent.time, stateEvent.offset);\n\t\t\t} else {\n\t\t\t\t// stop the note\n\t\t\t\tevent.stop(new TicksClass(this.context, stateEvent.time));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t *  Remove an event from the part. If the event at that time is a Part,\n\t *  it will remove the entire part.\n\t * @param time The time of the event\n\t * @param value Optionally select only a specific event value\n\t */\n\tremove(obj: {\n\t\ttime: Time,\n\t\t[key: string]: any;\n\t}): this;\n\tremove(time: Time, value?: any): this;\n\tremove(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (isObject(time) && time.hasOwnProperty(\"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\ttime = this.toTicks(time);\n\t\tthis._events.forEach(event => {\n\t\t\tif (event.startOffset === time) {\n\t\t\t\tif (isUndef(value) || (isDefined(value) && event.value === value)) {\n\t\t\t\t\tthis._events.delete(event);\n\t\t\t\t\tevent.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Remove all of the notes from the group.\n\t */\n\tclear(): this {\n\t\tthis._forEach(event => event.dispose());\n\t\tthis._events.clear();\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n\t * @param after The time after which to cancel the scheduled events.\n\t */\n\tcancel(after?: TransportTime | TransportTimeClass): this {\n\t\tthis._forEach(event => event.cancel(after));\n\t\tthis._state.cancel(this.toTicks(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Iterate over all of the events\n\t */\n\tprivate _forEach(callback: (event: ToneEvent) => void): this {\n\t\tif (this._events) {\n\t\t\tthis._events.forEach(event => {\n\t\t\t\tif (event instanceof Part) {\n\t\t\t\t\tevent._forEach(callback);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Set the attribute of all of the events\n\t * @param  attr  the attribute to set\n\t * @param  value      The value to set it to\n\t */\n\tprivate _setAll(attr: string, value: any): void {\n\t\tthis._forEach(event => {\n\t\t\tevent[attr] = value;\n\t\t});\n\t}\n\n\t/**\n\t *  Internal tick method\n\t * @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds, value?: any): void {\n\t\tif (!this.mute) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t *  Determine if the event should be currently looping\n\t *  given the loop boundries of this Part.\n\t * @param  event  The event to test\n\t */\n\tprivate _testLoopBoundries(event: ToneEvent): void {\n\t\tif (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n\t\t\tevent.cancel(0);\n\t\t} else if (event.state === \"stopped\") {\n\t\t\t// reschedule it if it's stopped\n\t\t\tthis._restartEvent(event);\n\t\t}\n\t}\n\n\t/**\n\t *  The probability of the notes being triggered.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t\tthis._setAll(\"probability\", prob);\n\t}\n\n\t/**\n\t * If set to true, will apply small random variation\n\t * to the callback time. If the value is given as a time, it will randomize\n\t * by that amount.\n\t * @example\n\t * event.humanize = true;\n\t */\n\tget humanize(): boolean | Time {\n\t\treturn this._humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t\tthis._setAll(\"humanize\", variation);\n\t}\n\n\t/**\n\t * If the part should loop or not\n\t * between Part.loopStart and\n\t * Part.loopEnd. If set to true,\n\t * the part will loop indefinitely,\n\t * if set to a number greater than 1\n\t * it will play a specific number of\n\t * times, if set to false, 0 or 1, the\n\t * part will only play once.\n\t * @example\n\t * //loop the part 8 times\n\t * part.loop = 8;\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._forEach(event => {\n\t\t\tevent.loopStart = this.loopStart;\n\t\t\tevent.loopEnd = this.loopEnd;\n\t\t\tevent.loop = loop;\n\t\t\tthis._testLoopBoundries(event);\n\t\t});\n\t}\n\n\t/**\n\t *  The loopEnd point determines when it will\n\t *  loop if Part.loop is true.\n\t * @memberOf Part#\n\t * @type {Time}\n\t * @name loopEnd\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopEnd = loopEnd;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t *  The loopStart point determines when it will\n\t *  loop if Part.loop is true.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopStart = this.loopStart;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * \tThe playback rate of the part\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._setAll(\"playbackRate\", rate);\n\t}\n\n\t/**\n\t * \tThe number of scheduled notes in the part.\n\t */\n\tget length(): number {\n\t\treturn this._events.size;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.clear();\n\t\treturn this;\n\t}\n}\n","import { TicksClass } from \"../core/type/Ticks\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype SequenceEventDescription<T> = Array<T | T[]>;\n\ninterface SequenceOptions<T> extends Omit<ToneEventOptions<T>, \"value\"> {\n\tloopStart: number;\n\tloopEnd: number;\n\tsubdivision: Time;\n\tevents: SequenceEventDescription<T>;\n}\n\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * var seq = new Sequence(function(time, note){\n * \tconsole.log(note);\n * //straight quater notes\n * }, [\"C4\", \"E4\", \"G4\", \"A4\"], \"4n\");\n * @example\n * var seq = new Sequence(function(time, note){\n * \tconsole.log(note);\n * //subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]);\n */\nexport class Sequence<ValueType = any> extends ToneEvent<ValueType> {\n\n\tname = \"Sequence\";\n\n\t/**\n\t *  The subdivison of each note\n\t */\n\tprivate _subdivision: Ticks;\n\n\t/**\n\t * The object responsible for scheduling all of the events\n\t */\n\tprivate _part: Part = new Part({\n\t\tcallback: this._seqCallback.bind(this),\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * private reference to all of the sequence proxies\n\t */\n\tprivate _events: ValueType[] = [];\n\n\t/**\n\t * The proxied array\n\t */\n\tprivate _eventsArray: ValueType[] = [];\n\n\t/**\n\t * @param  callback  The callback to invoke with every note\n\t * @param  sequence  The sequence\n\t * @param  subdivision  The subdivision between which events are placed.\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tevents?: SequenceEventDescription<ValueType>,\n\t\tsubdivision?: Time,\n\t);\n\tconstructor(options?: Partial<SequenceOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n\t\tconst options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n\n\t\tthis._subdivision = this.toTicks(options.subdivision);\n\n\t\tthis.events = options.events;\n\n\t\t// set all of the values\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.probability = options.probability;\n\t\tthis.humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): SequenceOptions<any> {\n\t\treturn Object.assign( omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n\t\t\tevents: [],\n\t\t\tloop: true,\n\t\t\tloopEnd : 0,\n\t\t\tloopStart: 0,\n\t\t\tsubdivision: \"8n\",\n\t\t});\n\t}\n\n\t/**\n\t * The internal callback for when an event is invoked\n\t */\n\tprivate _seqCallback(time: Seconds, value: any): void {\n\t\tif (value !== null) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * The sequence\n\t */\n\tget events(): any[] {\n\t\treturn this._events;\n\t}\n\tset events(s) {\n\t\tthis.clear();\n\t\tthis._eventsArray = s;\n\t\tthis._events = this._createSequence(this._eventsArray);\n\t\tthis._eventsUpdated();\n\t}\n\n\t/**\n\t *  Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset index to start at\n\t */\n\tstart(time?: TransportTime, offset?: number): this {\n\t\tthis._part.start(time, offset ? this._indexTime(offset) : offset);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._part.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t *  The subdivision of the sequence. This can only be\n\t *  set in the constructor. The subdivision is the\n\t *  interval between successive steps.\n\t */\n\tget subdivision(): Seconds {\n\t\treturn new TicksClass(this.context, this._subdivision).toSeconds();\n\t}\n\n\t/**\n\t * Create a sequence proxy which can be monitored to create subsequences\n\t */\n\tprivate _createSequence(array: any[]): any[] {\n\t\treturn new Proxy(array, {\n\t\t\tget: (target: any[], property: PropertyKey): any => {\n\t\t\t\t// property is index in this case\n\t\t\t\treturn target[property];\n\t\t\t},\n\t\t\tset: (target: any[], property: PropertyKey, value: any): boolean => {\n\t\t\t\tif (isString(property) && isFinite(parseInt(property, 10))) {\n\t\t\t\t\tconst index = parseInt(property, 10);\n\t\t\t\t\tif (isArray(value)) {\n\t\t\t\t\t\ttarget[property] = this._createSequence(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttarget[property] = value;\n\t\t\t\t}\n\t\t\t\tthis._eventsUpdated();\n\t\t\t\t// return true to accept the changes\n\t\t\t\treturn true;\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * When the sequence has changed, all of the events need to be recreated\n\t */\n\tprivate _eventsUpdated(): void {\n\t\tthis._part.clear();\n\t\tthis._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);\n\t\t// update the loopEnd\n\t\tthis.loopEnd = this.loopEnd;\n\t}\n\n\t/**\n\t * reschedule all of the events that need to be rescheduled\n\t */\n\tprivate _rescheduleSequence(sequence: any[], subdivision: Ticks, startOffset: Ticks): void {\n\t\tsequence.forEach((value, index) => {\n\t\t\tconst eventOffset = index * (subdivision) + startOffset;\n\t\t\tif (isArray(value)) {\n\t\t\t\tthis._rescheduleSequence(value, subdivision / value.length, eventOffset);\n\t\t\t} else {\n\t\t\t\tconst startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n\t\t\t\tthis._part.add(startTime, value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t *  Get the time of the index given the Sequence's subdivision\n\t * @param  index\n\t * @return The time of that index\n\t */\n\tprivate _indexTime(index: number): Seconds {\n\t\treturn new TicksClass(this.context, index * (this._subdivision) + this.startOffset).toSeconds();\n\t}\n\n\t/**\n\t * Clear all of the events\n\t */\n\tclear(): this {\n\t\tthis._part.clear();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._part.dispose();\n\t\treturn this;\n\t}\n\n\t///////////////////////////////////////////////////////////////////////////\n\t// PROXY CALLS\n\t///////////////////////////////////////////////////////////////////////////\n\n\tget loop(): boolean | number {\n\t\treturn this._part.loop;\n\t}\n\tset loop(l) {\n\t\tif (this._part) {\n\t\t\tthis._part.loop = l;\n\t\t}\n\t}\n\n\t/**\n\t * The index at which the sequence should start looping\n\t */\n\tget loopStart(): number {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(index) {\n\t\tthis._loopStart = index;\n\t\tif (this._part) {\n\t\t\tthis._part.loopStart = this._indexTime(index);\n\t\t}\n\t}\n\n\t/**\n\t * The index at which the sequence should end looping\n\t */\n\tget loopEnd(): number {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(index) {\n\t\tthis._loopEnd = index;\n\t\tif (this._part) {\n\t\t\tif (index === 0) {\n\t\t\t\tthis._part.loopEnd = this._indexTime(this._eventsArray.length);\n\t\t\t} else {\n\t\t\t\tthis._part.loopEnd = this._indexTime(index);\n\t\t\t}\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._part.startOffset;\n\t}\n\tset startOffset(start) {\n\t\tif (this._part) {\n\t\t\tthis._part.startOffset = start;\n\t\t}\n\t}\n\n\tget playbackRate(): Positive {\n\t\treturn this._part.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tif (this._part) {\n\t\t\tthis._part.playbackRate = rate;\n\t\t}\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._part.probability;\n\t}\n\tset probability(prob) {\n\t\tif (this._part) {\n\t\t\tthis._part.probability = prob;\n\t\t}\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._part.humanize;\n\t}\n\tset humanize(variation) {\n\t\tif (this._part) {\n\t\t\tthis._part.humanize = variation;\n\t\t}\n\t}\n\n\t/**\n\t * The number of scheduled events\n\t */\n\tget length(): number {\n\t\treturn this._part.length;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { connect, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { GainToAudio } from \"../../signal/GainToAudio\";\nimport { Signal } from \"../../signal/Signal\";\n\ninterface CrossFadeOptions extends ToneAudioNodeOptions {\n\tfade: NormalRange;\n}\n\n/**\n * Tone.Crossfade provides equal power fading between two inputs.\n * More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).\n * ```\n *                                             +---------+\n *                                            +> input a +>--+\n * +-----------+   +---------------------+     |         |   |\n * | 1s signal +>--> stereoPannerNode  L +>----> gain    |   |\n * +-----------+   |                     |     +---------+   |\n *               +-> pan               R +>-+                |   +--------+\n *               | +---------------------+  |                +---> output +>\n *  +------+     |                          |  +---------+   |   +--------+\n *  | fade +>----+                          | +> input b +>--+\n *  +------+                                |  |         |\n *                                          +--> gain    |\n *                                             +---------+\n * ```\n * @example\n * var crossFade = new CrossFade(0.5);\n * //connect effect A to crossfade from\n * //effect output 0 to crossfade input 0\n * effectA.connect(crossFade.a);\n * //connect effect B to crossfade from\n * //effect output 0 to crossfade input 1\n * effectB.connect(crossFade.b);\n * crossFade.fade.value = 0;\n * // ^ only effectA is output\n * crossFade.fade.value = 1;\n * // ^ only effectB is output\n * crossFade.fade.value = 0.5;\n * // ^ the two signals are mixed equally.\n */\nexport class CrossFade extends ToneAudioNode<CrossFadeOptions> {\n\n\treadonly name = \"CrossFade\";\n\n\t/**\n\t * The crossfading is done by a StereoPannerNode\n\t */\n\tprivate _panner: StereoPannerNode = this.context.createStereoPanner();\n\n\t/**\n\t * Split the output of the panner node into two values used to control the gains.\n\t */\n\tprivate _split: ChannelSplitterNode = this.context.createChannelSplitter(2);\n\n\t/**\n\t * Convert the fade value into an audio range value so it can be connected\n\t * to the panner.pan AudioParam\n\t */\n\tprivate _g2a: GainToAudio = new GainToAudio({ context : this.context });\n\n\t/**\n\t * The input which is at full level when fade = 0\n\t */\n\treadonly a: Gain = new Gain({\n\t\tcontext : this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The input which is at full level when fade = 1\n\t */\n\treadonly b: Gain = new Gain({\n\t\tcontext : this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The output is a mix between `a` and `b` at the ratio of `fade`\n\t */\n\treadonly output: Gain = new Gain({ context : this.context });\n\n\t/**\n\t * CrossFade has no input, you must choose either `a` or `b`\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * \tThe mix between the two inputs. A fade value of 0\n\t * \twill output 100% crossFade.a and\n\t * \ta value of 1 will output 100% crossFade.b.\n\t */\n\treadonly fade: Signal<NormalRange>;\n\n\tprotected _internalChannels = [this.a, this.b];\n\n\t/**\n\t * @param fade The initial fade value [0, 1].\n\t */\n\tconstructor(fade?: NormalRange);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<CrossFadeOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"])));\n\t\tconst options = optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"]);\n\n\t\tthis.fade = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"normalRange\",\n\t\t\tvalue: options.fade,\n\t\t});\n\t\treadOnly(this, \"fade\");\n\n\t\tthis.context.getConstant(1).connect(this._panner);\n\t\tthis._panner.connect(this._split);\n\t\t// this is necessary for standardized-audio-context\n\t\t// doesn't make any difference for the native AudioContext\n\t\t// https://github.com/chrisguttandin/standardized-audio-context/issues/647\n\t\tthis._panner.channelCount = 1;\n\t\tthis._panner.channelCountMode = \"explicit\";\n\t\tconnect(this._split, this.a.gain, 0);\n\t\tconnect(this._split, this.b.gain, 1);\n\n\t\tthis.fade.chain(this._g2a, this._panner.pan);\n\n\t\tthis.a.connect(this.output);\n\t\tthis.b.connect(this.output);\n\t}\n\n\tstatic getDefaults(): CrossFadeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tfade: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.a.dispose();\n\t\tthis.b.dispose();\n\t\tthis.output.dispose();\n\t\tthis.fade.dispose();\n\t\tthis._g2a.dispose();\n\t\tthis._panner.disconnect();\n\t\tthis._split.disconnect();\n\t\treturn this;\n\t}\n}\n","import { CrossFade } from \"../component/channel/CrossFade\";\nimport { Gain } from \"../core/context/Gain\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\n\nexport interface EffectOptions extends ToneAudioNodeOptions {\n\twet: NormalRange;\n}\n/**\n * Effect is the base class for effects. Connect the effect between\n * the effectSend and effectReturn GainNodes, then control the amount of\n * effect which goes to the output using the wet control.\n */\nexport abstract class Effect<Options extends EffectOptions>\nextends ToneAudioNode<Options> {\n\n\treadonly name: string = \"Effect\";\n\n\t/**\n\t *  the drywet knob to control the amount of effect\n\t */\n\tprivate _dryWet: CrossFade = new CrossFade({ context : this.context });\n\n\t/**\n\t *  The wet control is how much of the effected\n\t *  will pass through to the output. 1 = 100% effected\n\t *  signal, 0 = 100% dry signal.\n\t */\n\twet: Signal<NormalRange> = this._dryWet.fade;\n\n\t/**\n\t *  connect the effectSend to the input of hte effect\n\t */\n\tprotected effectSend: Gain = new Gain({ context : this.context });\n\n\t/**\n\t *  connect the output of the effect to the effectReturn\n\t */\n\tprotected effectReturn: Gain = new Gain({ context : this.context });\n\n\t/**\n\t * The effect input node\n\t */\n\tinput: Gain = new Gain({ context : this.context });\n\n\t/**\n\t * The effect output\n\t */\n\toutput = this._dryWet;\n\n\tconstructor(options: EffectOptions) {\n\t\tsuper(options);\n\n\t\t// connections\n\t\tthis.input.fan(this._dryWet.a, this.effectSend);\n\t\tthis.effectReturn.connect(this._dryWet.b);\n\t\tthis.wet.setValueAtTime(options.wet, 0);\n\t\tthis._internalChannels = [this.effectReturn, this.effectSend];\n\t\treadOnly(this, \"wet\");\n\t}\n\n\tstatic getDefaults(): EffectOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\twet : 1,\n\t\t});\n\t}\n\n\t/**\n\t *  chains the effect in between the effectSend and effectReturn\n\t */\n\tprotected connectEffect(effect: ToneAudioNode | AudioNode): this {\n\t\t// add it to the internal channels\n\t\tthis._internalChannels.push(effect);\n\t\tthis.effectSend.chain(effect, this.effectReturn);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dryWet.dispose();\n\t\tthis.effectSend.dispose();\n\t\tthis.effectReturn.dispose();\n\t\tthis.wet.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\nexport interface FeedbackEffectOptions extends EffectOptions {\n\t/**\n\t * The feedback from the output back to the input\n\t * ```\n\t * +---<--------<---+\n\t * |                |\n\t * |  +----------+  |\n\t * +--> feedback +>-+\n\t *    +----------+\n\t * ```\n\t */\n\tfeedback: NormalRange;\n}\n\n/**\n * FeedbackEffect provides a loop between an audio source and its own output.\n * This is a base-class for feedback effects.\n */\nexport abstract class FeedbackEffect<Options extends FeedbackEffectOptions> extends Effect<Options> {\n\n\tname = \"FeedbackEffect\";\n\n\t/**\n\t *  the gain which controls the feedback\n\t */\n\tprivate _feedbackGain: Gain<NormalRange>;\n\n\t/**\n\t *  The amount of signal which is fed back into the effect input.\n\t */\n\tfeedback: Param<NormalRange>;\n\n\tconstructor(options: FeedbackEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis._feedbackGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.feedback,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\n\t\tthis.feedback = this._feedbackGain.gain;\n\t\treadOnly(this, \"feedback\");\n\n\t\t// the feedback loop\n\t\tthis.effectReturn.chain(this._feedbackGain, this.effectSend);\n\t}\n\n\tstatic getDefaults(): FeedbackEffectOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfeedback: 0.125,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._feedbackGain.dispose();\n\t\tthis.feedback.dispose();\n\t\treturn this;\n\t}\n}\n","import { Delay } from \"../core/context/Delay\";\nimport { Param } from \"../core/context/Param\";\nimport { NormalRange, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { FeedbackEffect,  FeedbackEffectOptions } from \"./FeedbackEffect\";\n\ninterface FeedbackDelayOptions extends FeedbackEffectOptions {\n\tdelayTime: Time;\n\tmaxDelay: Time;\n}\n\n/**\n * FeedbackDelay is a DelayNode in which part of output signal is fed back into the delay.\n *\n * @param delayTime The delay applied to the incoming signal.\n * @param feedback The amount of the effected signal which is fed back through the delay.\n * @example\n * var feedbackDelay = new FeedbackDelay(\"8n\", 0.5).toDestination();\n * var tom = new Tone.MembraneSynth({\n * \t\"octaves\" : 4,\n * \t\"pitchDecay\" : 0.1\n * }).connect(feedbackDelay);\n * tom.triggerAttackRelease(\"A2\",\"32n\");\n */\nexport class FeedbackDelay extends FeedbackEffect<FeedbackDelayOptions> {\n\n\tname = \"FeedbackDelay\";\n\n\t/**\n\t *  the delay node\n\t */\n\tprivate _delayNode: Delay;\n\n\t/**\n\t *  The delayTime of the FeedbackDelay.\n\t */\n\treadonly delayTime: Param<Time>;\n\n\tconstructor(delayTime?: Time, feedback?: NormalRange);\n\tconstructor(options?: Partial<FeedbackDelayOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]));\n\t\tconst options = optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]);\n\n\t\tthis._delayNode = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: options.delayTime,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis.delayTime = this._delayNode.delayTime;\n\n\t\t// connect it up\n\t\tthis.connectEffect(this._delayNode);\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): FeedbackDelayOptions {\n\t\treturn Object.assign(FeedbackEffect.getDefaults(), {\n\t\t\tdelayTime: 0.25,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.dispose();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\ninterface ToneConvolverOptions extends EffectOptions {\n\tonload: () => void;\n\tnormalize: boolean;\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n}\n\n/**\n * Convolver is a wrapper around the Native Web Audio\n * [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).\n * Convolution is useful for reverb and filter emulation. Read more about convolution reverb on\n * [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).\n *\n * @example\n * //initializing the convolver with an impulse response\n * var convolver = new Convolver(\"./path/to/ir.wav\").toDestination();\n */\nexport class Convolver extends Effect<ToneConvolverOptions> {\n\n\tname = \"Convolver\";\n\n\t/**\n\t *  The native ConvolverNode\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t *  The Buffer belonging to the convolver\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * @param url The URL of the impulse response or the Tone.Buffer contianing the impulse response.\n\t * @param onload The callback to invoke when the url is loaded.\n\t */\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<ToneConvolverOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Convolver.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(Convolver.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis._buffer = new ToneAudioBuffer(options.url, buffer => {\n\t\t\tthis.buffer = buffer;\n\t\t\toptions.onload();\n\t\t});\n\n\t\t// set if it's already loaded\n\t\tif (this._buffer.loaded) {\n\t\t\tthis.buffer = this._buffer;\n\t\t}\n\n\t\t// initially set normalization\n\t\tthis.normalize = options.normalize;\n\n\t\t// connect it up\n\t\tthis.connectEffect(this._convolver);\n\t}\n\n\tstatic getDefaults(): ToneConvolverOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tnormalize : true,\n\t\t\tonload : noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Load an impulse response url as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<void> {\n\t\tthis.buffer = await this._buffer.load(url);\n\t}\n\n\t/**\n\t *  The convolver's buffer\n\t */\n\tget buffer(): ToneAudioBuffer | null {\n\t\tif (this._buffer.length) {\n\t\t\treturn this._buffer;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tset buffer(buffer) {\n\t\tif (buffer) {\n\t\t\tthis._buffer.set(buffer);\n\t\t}\n\t\t// if it's already got a buffer, create a new one\n\t\tif (this._convolver.buffer) {\n\t\t\t// disconnect the old one\n\t\t\tthis.effectSend.disconnect();\n\t\t\tthis._convolver.disconnect();\n\t\t\t// create and connect a new one\n\t\t\tthis._convolver = this.context.createConvolver();\n\t\t\tthis.connectEffect(this._convolver);\n\t\t}\n\t\tconst buff = this._buffer.get();\n\t\tthis._convolver.buffer = buff ? buff : null;\n\t}\n\n\t/**\n\t * The normalize property of the ConvolverNode interface is a boolean that\n\t * controls whether the impulse response from the buffer will be scaled by\n\t * an equal-power normalization when the buffer attribute is set, or not.\n\t */\n\tget normalize(): boolean {\n\t\treturn this._convolver.normalize;\n\t}\n\tset normalize(norm) {\n\t\tthis._convolver.normalize = norm;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\ninterface MergeOptions extends ToneAudioNodeOptions {\n\tchannels: Positive;\n}\n\n/**\n * Merge brings multiple mono input channels into a single multichannel output channel.\n *\n * @example\n * var merge = new Merge().toDestination();\n * //routing a sine tone in the left channel\n * //and noise in the right channel\n * var osc = new Tone.Oscillator().connect(merge.left);\n * var noise = new Tone.Noise().connect(merge.right);\n * //starting our oscillators\n * noise.start();\n * osc.start();\n */\nexport class Merge extends ToneAudioNode<MergeOptions> {\n\n\treadonly name = \"Merge\";\n\n\t/**\n\t *  The merger node for the two channels.\n\t */\n\tprivate _merger: ChannelMergerNode;\n\n\t/**\n\t * The output is the input channels combined into a sigle (multichannel) output\n\t */\n\treadonly output: ChannelMergerNode;\n\n\t/**\n\t * Multiple input connections combine into a single output.\n\t */\n\treadonly input: ChannelMergerNode;\n\n\t/**\n\t * @param channels The number of channels to merge.\n\t */\n\tconstructor(channels?: Positive);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<MergeOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]));\n\t\tconst options = optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]);\n\n\t\tthis._merger = this.output = this.input = this.context.createChannelMerger(options.channels);\n\t}\n\n\tstatic getDefaults(): MergeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannels: 2,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._merger.disconnect();\n\t\treturn this;\n\t}\n}\n","import { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Offline } from \"../core/context/Offline\";\nimport { Seconds } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\ninterface ReverbOptions extends EffectOptions {\n\tdecay: Seconds;\n\tpreDelay: Seconds;\n}\n\n/**\n *  Simple convolution created with decaying noise.\n *  Generates an Impulse Response Buffer\n * \twith Tone.Offline then feeds the IR into ConvolverNode.\n * \tNote: the Reverb will not make any sound until [generate](#generate)\n * \thas been invoked and resolved.\n *\n * \tInspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * \tCopyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n */\nexport class Reverb extends Effect<ReverbOptions> {\n\n\treadonly name = \"Reverb\";\n\n\t/**\n\t *  Convolver node\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The duration of the reverb\n\t */\n\tdecay: Seconds;\n\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tpreDelay: Seconds;\n\n\t/**\n\t * @param decay The amount of time it will reverberate for.\n\t */\n\tconstructor(decay?: Seconds);\n\t// tslint:disable-next-line: unified-signatures\n\tconstructor(options?: Partial<ReverbOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n\t\tconst options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n\n\t\tthis.decay = options.decay;\n\t\tthis.preDelay = options.preDelay;\n\n\t\tthis.connectEffect(this._convolver);\n\t}\n\n\tstatic getDefaults(): ReverbOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdecay : 1.5,\n\t\t\tpreDelay : 0.01,\n\t\t});\n\t}\n\n\t/**\n\t * Generate the Impulse Response. Returns a promise while the IR is being generated.\n\t * @return Promise which returns this object.\n\t */\n\tasync generate(): Promise<this> {\n\t\tconst buffer = await Offline((context) => {\n\t\t\t// create a noise burst which decays over the duration\n\t\t\tconst noiseL = new Noise({ context });\n\t\t\tconst noiseR = new Noise({ context });\n\t\t\tconst merge = new Merge({ context });\n\t\t\tnoiseL.connect(merge, 0, 0);\n\t\t\tnoiseR.connect(merge, 0, 1);\n\t\t\tconst gainNode = new Gain({ context }).toDestination();\n\t\t\tmerge.connect(gainNode);\n\t\t\tnoiseL.start(0);\n\t\t\tnoiseR.start(0);\n\t\t\t// predelay\n\t\t\tgainNode.gain.setValueAtTime(0, 0);\n\t\t\tgainNode.gain.setValueAtTime(1, this.preDelay);\n\t\t\t// decay\n\t\t\tgainNode.gain.exponentialApproachValueAtTime(0, this.preDelay, this.decay);\n\t\t}, this.decay + this.preDelay);\n\t\tthis._convolver.buffer = buffer.get() as AudioBuffer;\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, PowerOfTwo } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\ntype AnalyserType = \"fft\" | \"waveform\";\n\ninterface AnalyserOptions extends ToneAudioNodeOptions {\n\tsize: PowerOfTwo;\n\ttype: AnalyserType;\n\tsmoothing: NormalRange;\n}\n\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\nexport class Analyser extends ToneAudioNode<AnalyserOptions> {\n\n\treadonly name = \"Analyser\";\n\n\tinput: AnalyserNode;\n\toutput: AnalyserNode;\n\n\t/**\n\t *  The analyser node.\n\t */\n\tprivate _analyser = this.context.createAnalyser();\n\n\t/**\n\t *  The analysis type\n\t */\n\tprivate _type!: AnalyserType;\n\n\t/**\n\t *  The buffer that the FFT data is written to\n\t */\n\tprivate _buffer!: Float32Array;\n\n\t/**\n\t * @param type The return type of the analysis, either \"fft\", or \"waveform\".\n\t * @param size The size of the FFT. This must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(type?: AnalyserType, size?: number);\n\tconstructor(options?: Partial<AnalyserOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]));\n\t\tconst options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n\t\t// set the values initially\n\t\tthis.size = options.size;\n\t\tthis.type = options.type;\n\t\tthis.input = this.output = this._analyser;\n\t}\n\n\tstatic getDefaults(): AnalyserOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsize: 1024,\n\t\t\tsmoothing: 0.8,\n\t\t\ttype: \"fft\" as AnalyserType,\n\t\t});\n\t}\n\n\t/**\n\t *  Run the analysis given the current settings and return the\n\t */\n\tgetValue(): Float32Array {\n\t\tif (this._type === \"fft\") {\n\t\t\tthis._analyser.getFloatFrequencyData(this._buffer);\n\t\t} else if (this._type === \"waveform\") {\n\t\t\tthis._analyser.getFloatTimeDomainData(this._buffer);\n\t\t}\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t *  The size of analysis. This must be a power of two in the range 16 to 16384.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analyser.frequencyBinCount;\n\t}\n\tset size(size: PowerOfTwo) {\n\t\tthis._analyser.fftSize = size * 2;\n\t\tthis._buffer = new Float32Array(size);\n\t}\n\n\t/**\n\t *  The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n\t */\n\tget type(): AnalyserType {\n\t\treturn this._type;\n\t}\n\tset type(type: AnalyserType) {\n\t\tthis.assert(type === \"waveform\" || type === \"fft\", `Analyser: invalid type: ${type}`);\n\t\tthis._type = type;\n\t}\n\n\t/**\n\t *  0 represents no time averaging with the last analysis frame.\n\t */\n\tget smoothing(): NormalRange {\n\t\treturn this._analyser.smoothingTimeConstant;\n\t}\n\n\tset smoothing(val: NormalRange) {\n\t\tthis._analyser.smoothingTimeConstant = val;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analyser.disconnect();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Cents, Decibels, Frequency, GainFactor, Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { isNumber } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\n\ninterface FilterOptions extends ToneAudioNodeOptions {\n\ttype: BiquadFilterType;\n\tfrequency: Frequency;\n\trolloff: number;\n\tQ: Positive;\n\tdetune: Cents;\n\tgain: GainFactor;\n}\n\n/**\n * Tone.Filter is a filter which allows for all of the same native methods\n * as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface).\n * Tone.Filter has the added ability to set the filter rolloff at -12\n * (default), -24 and -48.\n * @example\n * var filter = new Filter(200, \"highpass\");\n */\nexport class Filter extends ToneAudioNode<FilterOptions> {\n\n\treadonly name = \"Filter\";\n\n\treadonly input = new Gain({ context: this.context });\n\treadonly output = new Gain({ context: this.context });\n\tprivate _filters: BiquadFilterNode[] = [];\n\n\t/**\n\t *  the rolloff value of the filter\n\t */\n\tprivate _rolloff!: number;\n\tprivate _type: BiquadFilterType;\n\n\t/**\n\t *  The Q or Quality of the filter\n\t */\n\treadonly Q: Signal<Positive>;\n\n\t/**\n\t *  The cutoff frequency of the filter.\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t *  The detune parameter\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t *  The gain of the filter, only used in certain filter types\n\t */\n\treadonly gain: Signal<Decibels>;\n\n\t/**\n\t * @param frequency The cutoff frequency of the filter.\n\t * @param type The type of filter.\n\t * @param rolloff The drop in decibels per octave after the cutoff frequency\n\t */\n\tconstructor(frequency?: Frequency, type?: BiquadFilterType, rolloff?: number);\n\tconstructor(options?: Partial<FilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Filter.getDefaults(), arguments, [\"frequency\", \"type\", \"rolloff\"]));\n\t\tconst options = optionsFromArguments(Filter.getDefaults(), arguments, [\"frequency\", \"type\", \"rolloff\"]);\n\n\t\tthis._filters = [];\n\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.Q,\n\t\t});\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\tthis.gain = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"decibels\",\n\t\t\tvalue: options.gain,\n\t\t});\n\t\tthis._type = options.type;\n\t\tthis.rolloff = options.rolloff;\n\t\treadOnly(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): FilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\tdetune: 0,\n\t\t\tfrequency: 350,\n\t\t\tgain: 0,\n\t\t\trolloff: -12,\n\t\t\ttype: \"lowpass\" as BiquadFilterType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the filter. Types: \"lowpass\", \"highpass\",\n\t * \"bandpass\", \"lowshelf\", \"highshelf\", \"notch\", \"allpass\", or \"peaking\".\n\t */\n\tget type(): BiquadFilterType {\n\t\treturn this._type;\n\t}\n\tset type(type: BiquadFilterType) {\n\t\tconst types: BiquadFilterType[] = [\"lowpass\", \"highpass\", \"bandpass\",\n\t\t\t\"lowshelf\", \"highshelf\", \"notch\", \"allpass\", \"peaking\"];\n\t\tthis.assert(types.indexOf(type) !== -1, `Invalid filter type: ${type}`);\n\t\tthis._type = type;\n\t\tthis._filters.forEach(filter => filter.type = type);\n\t}\n\n\t/**\n\t * The rolloff of the filter which is the drop in db\n\t * per octave. Implemented internally by cascading filters.\n\t * Only accepts the values -12, -24, -48 and -96.\n\t */\n\tget rolloff(): number | string {\n\t\treturn this._rolloff;\n\t}\n\tset rolloff(rolloff: number | string) {\n\t\tconst rolloffNum = isNumber(rolloff) ? rolloff : parseInt(rolloff, 10);\n\t\tconst possibilities = [-12, -24, -48, -96];\n\t\tlet cascadingCount = possibilities.indexOf(rolloffNum);\n\t\t// check the rolloff is valid\n\t\tthis.assert(cascadingCount !== -1, `rolloff can only be ${possibilities.join(\", \")}`);\n\t\tcascadingCount += 1;\n\n\t\tthis._rolloff = rolloffNum;\n\t\tthis.input.disconnect();\n\t\tthis._filters.forEach(filter => filter.disconnect());\n\n\t\tthis._filters = new Array(cascadingCount);\n\t\tfor (let count = 0; count < cascadingCount; count++) {\n\t\t\tconst filter = this.context.createBiquadFilter();\n\t\t\tfilter.type = this._type;\n\t\t\tthis.frequency.connect(filter.frequency);\n\t\t\tthis.detune.connect(filter.detune);\n\t\t\tthis.Q.connect(filter.Q);\n\t\t\tthis.gain.connect(filter.gain);\n\t\t\tthis._filters[count] = filter;\n\t\t}\n\t\tthis._internalChannels = this._filters;\n\t\tconnectSeries(this.input, ...this._internalChannels, this.output);\n\t}\n\n\t/**\n\t * Get the frequency response curve. This curve represents how the filter\n\t * responses to frequencies between 20hz-20khz.\n\t * @param  len The number of values to return\n\t * @return The frequency response curve between 20-20kHz\n\t */\n\tgetFrequencyResponse(len: number = 128): Float32Array {\n\t\t// start with all 1s\n\t\tconst totalResponse = new Float32Array(len).map(() => 1);\n\t\tconst freqValues = new Float32Array(len);\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst norm = Math.pow(i / len, 2);\n\t\t\tconst freq = norm * (20000 - 20) + 20;\n\t\t\tfreqValues[i] = freq;\n\t\t}\n\t\tconst magValues = new Float32Array(len);\n\t\tconst phaseValues = new Float32Array(len);\n\t\tthis._filters.forEach(() => {\n\t\t\tconst filterClone = this.context.createBiquadFilter();\n\t\t\tfilterClone.type = this._type;\n\t\t\tfilterClone.Q.value = this.Q.value;\n\t\t\tfilterClone.frequency.value = this.frequency.value as number;\n\t\t\tfilterClone.gain.value = this.gain.value as number;\n\t\t\tfilterClone.getFrequencyResponse(freqValues, magValues, phaseValues);\n\t\t\tmagValues.forEach((val, i) => {\n\t\t\t\ttotalResponse[i] *= val;\n\t\t\t});\n\t\t});\n\t\treturn totalResponse;\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._filters.forEach(filter => {\n\t\t\tfilter.disconnect();\n\t\t});\n\t\twritable(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n\t\tthis.frequency.dispose();\n\t\tthis.Q.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Frequency, Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Filter } from \"../filter/Filter\";\n\ninterface MultibandSplitOptions extends ToneAudioNodeOptions {\n\tQ: Positive;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\n/**\n *  Split the incoming signal into three bands (low, mid, high)\n *  with two crossover frequency controls.\n * ```\n *            +----------------------+\n *          +-> input < lowFrequency +------------------> low\n *          | +----------------------+\n *          |\n *          | +--------------------------------------+\n * input ---+-> lowFrequency < input < highFrequency +--> mid\n *          | +--------------------------------------+\n *          |\n *          | +-----------------------+\n *          +-> highFrequency < input +-----------------> high\n *            +-----------------------+\n * ```\n */\nexport class MultibandSplit extends ToneAudioNode<MultibandSplitOptions> {\n\n\treadonly name = \"MultibandSplit\";\n\n\t/**\n\t *  the input\n\t */\n\treadonly input = new Gain({ context: this.context });\n\n\t/**\n\t * no output node, use either low, mid or high outputs\n\t */\n\treadonly output = undefined;\n\n\t/**\n\t *  The low band.\n\t */\n\treadonly low = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"lowpass\",\n\t});\n\n\t/**\n\t *  the lower filter of the mid band\n\t */\n\tprivate _lowMidFilter = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"highpass\",\n\t});\n\n\t/**\n\t *  The mid band output.\n\t */\n\treadonly mid = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"lowpass\",\n\t});\n\n\t/**\n\t *  The high band output.\n\t */\n\treadonly high = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"highpass\",\n\t});\n\n\t/**\n\t *  The low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<Frequency>;\n\n\t/**\n\t *  The mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<Frequency>;\n\n\tprotected _internalChannels = [this.low, this.mid, this.high];\n\n\t/**\n\t *  The Q or Quality of the filter\n\t */\n\treadonly Q: Signal<Positive>;\n\n\t/**\n\t * @param lowFrequency the low/mid crossover frequency\n\t * @param highFrequency the mid/high crossover frequency\n\t */\n\tconstructor(lowFrequency?: Frequency, highFrequency?: Frequency);\n\tconstructor(options?: Partial<MultibandSplitOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MultibandSplit.getDefaults(), arguments, [\"lowFrequency\", \"highFrequency\"]));\n\t\tconst options = optionsFromArguments(MultibandSplit.getDefaults(), arguments, [\"lowFrequency\", \"highFrequency\"]);\n\n\t\tthis.lowFrequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.lowFrequency,\n\t\t});\n\n\t\tthis.highFrequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.highFrequency,\n\t\t});\n\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.Q,\n\t\t});\n\n\t\tthis.input.fan(this.low, this.high);\n\t\tthis.input.chain(this._lowMidFilter, this.mid);\n\t\t// the frequency control signal\n\t\tthis.lowFrequency.fan(this.low.frequency, this._lowMidFilter.frequency);\n\t\tthis.highFrequency.fan(this.mid.frequency, this.high.frequency);\n\t\t// the Q value\n\t\tthis.Q.connect(this.low.Q);\n\t\tthis.Q.connect(this._lowMidFilter.Q);\n\t\tthis.Q.connect(this.mid.Q);\n\t\tthis.Q.connect(this.high.Q);\n\n\t\treadOnly(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t}\n\n\tstatic getDefaults(): MultibandSplitOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\thighFrequency: 2500,\n\t\t\tlowFrequency: 400,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\twritable(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t\tthis.low.dispose();\n\t\tthis._lowMidFilter.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.lowFrequency.dispose();\n\t\tthis.highFrequency.dispose();\n\t\tthis.Q.dispose();\n\t\treturn this;\n\t}\n\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Cents, Decibels, Frequency, GainFactor, Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { MultibandSplit } from \"../channel/MultibandSplit\";\n\ninterface EQ3Options extends ToneAudioNodeOptions {\n\tlow: Decibels;\n\tmid: Decibels;\n\thigh: Decibels;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\nexport class EQ3 extends ToneAudioNode<EQ3Options> {\n\n\treadonly name = \"EQ3\";\n\n\t/**\n\t *  the input\n\t */\n\treadonly input: MultibandSplit;\n\n\t/**\n\t *  the output\n\t */\n\treadonly output = new Gain({ context: this.context });\n\n\tprivate _multibandSplit: MultibandSplit;\n\n\t/**\n\t *  The gain for the lower signals\n\t */\n\tprivate _lowGain: Gain<Decibels>;\n\n\t/**\n\t *  The gain for the mid signals\n\t */\n\tprivate _midGain: Gain<Decibels>;\n\n\t/**\n\t *  The gain for the high signals\n\t */\n\tprivate _highGain: Gain<Decibels>;\n\n\t/**\n\t * The gain in decibels of the low part\n\t */\n\treadonly low: Param<Decibels>;\n\n\t/**\n\t * The gain in decibels of the mid part\n\t */\n\treadonly mid: Param<Decibels>;\n\n\t/**\n\t * The gain in decibels of the high part\n\t */\n\treadonly high: Param<Decibels>;\n\n\t/**\n\t *  The Q value for all of the filters.\n\t */\n\treadonly Q: Signal<Positive>;\n\n\t/**\n\t *  The low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<Frequency>;\n\n\t/**\n\t *  The mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<Frequency>;\n\n\tprotected _internalChannels: ToneAudioNode[] = [];\n\n\tconstructor(lowLevel?: Decibels, midLevel?: Decibels, highLevel?: Decibels);\n\tconstructor(options: Partial<EQ3Options>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(EQ3.getDefaults(), arguments, [\"low\", \"mid\", \"high\"]));\n\t\tconst options = optionsFromArguments(EQ3.getDefaults(), arguments, [\"low\", \"mid\", \"high\"]);\n\n\t\tthis.input = this._multibandSplit = new MultibandSplit({\n\t\t\tcontext: this.context,\n\t\t\thighFrequency: options.highFrequency,\n\t\t\tlowFrequency: options.lowFrequency,\n\t\t});\n\n\t\tthis._lowGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.low,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis._midGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.mid,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis._highGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.high,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis.low = this._lowGain.gain;\n\t\tthis.mid = this._midGain.gain;\n\t\tthis.high = this._highGain.gain;\n\t\tthis.Q = this._multibandSplit.Q;\n\t\tthis.lowFrequency = this._multibandSplit.lowFrequency;\n\t\tthis.highFrequency\t= this._multibandSplit.highFrequency;\n\n\t\t// the frequency bands\n\t\tthis._multibandSplit.low.chain(this._lowGain, this.output);\n\t\tthis._multibandSplit.mid.chain(this._midGain, this.output);\n\t\tthis._multibandSplit.high.chain(this._highGain, this.output);\n\n\t\treadOnly(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n\t\tthis._internalChannels = [this._multibandSplit];\n\t}\n\n\tstatic getDefaults(): EQ3Options {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\thigh : 0,\n\t\t\thighFrequency : 2500,\n\t\t\tlow : 0,\n\t\t\tlowFrequency : 400,\n\t\t\tmid : 0,\n\t\t});\n\t}\n\n\t/**\n\t *  Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\twritable(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n\t\tthis._multibandSplit.dispose();\n\t\tthis.lowFrequency.dispose();\n\t\tthis.highFrequency.dispose();\n\t\tthis._lowGain.dispose();\n\t\tthis._midGain.dispose();\n\t\tthis._highGain.dispose();\n\t\tthis.low.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.Q.dispose();\n\t\treturn this;\n\t}\n\n}\n","import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels, Positive, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface CompressorOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tknee: Decibels;\n\tratio: Positive;\n\trelease: Time;\n\tthreshold: Decibels;\n}\n\n/**\n * Compressor is a thin wrapper around the Web Audio\n * [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).\n * Compression reduces the volume of loud sounds or amplifies quiet sounds\n * by narrowing or \"compressing\" an audio signal's dynamic range.\n * Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).\n * @example\n * var comp = new Compressor(-30, 3);\n */\nexport class Compressor extends ToneAudioNode<CompressorOptions> {\n\n\treadonly name = \"Compressor\";\n\n\t/**\n\t *  the compressor node\n\t */\n\tprivate _compressor: DynamicsCompressorNode = this.context.createDynamicsCompressor();\n\tinput = this._compressor;\n\toutput = this._compressor;\n\n\t/**\n\t *  The decibel value above which the compression will start taking effect.\n\t */\n\treadonly threshold: Param<Decibels>;\n\n\t/**\n\t *  The amount of time (in seconds) to reduce the gain by 10dB.\n\t */\n\treadonly attack: Param<Time>;\n\n\t/**\n\t * The amount of time (in seconds) to increase the gain by 10dB.\n\t */\n\treadonly release: Param<Time>;\n\n\t/**\n\t * A decibel value representing the range above the threshold where the\n\t * curve smoothly transitions to the \"ratio\" portion.\n\t */\n\treadonly knee: Param<Decibels>;\n\n\t/**\n\t * The amount of dB change in input for a 1 dB change in output.\n\t */\n\treadonly ratio: Param<Decibels>;\n\n\t/**\n\t * @param threshold The value above which the compression starts to be applied.\n\t * @param ratio The gain reduction ratio.\n\t */\n\tconstructor(threshold?: Decibels, ratio?: Positive);\n\tconstructor(options?: Partial<CompressorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Compressor.getDefaults(), arguments, [\"treshold\", \"ratio\"]));\n\t\tconst options = optionsFromArguments(Compressor.getDefaults(), arguments, [\"treshold\", \"ratio\"]);\n\n\t\tthis.threshold = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert : false,\n\t\t\tparam : this._compressor.threshold,\n\t\t\tunits : \"decibels\",\n\t\t\tvalue: options.threshold,\n\t\t});\n\n\t\tthis.attack = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._compressor.attack,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.attack,\n\t\t});\n\n\t\tthis.release = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._compressor.release,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.release,\n\t\t});\n\n\t\tthis.knee = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert : false,\n\t\t\tparam : this._compressor.knee,\n\t\t\tunits : \"decibels\",\n\t\t\tvalue: options.knee,\n\t\t});\n\n\t\tthis.ratio = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert : false,\n\t\t\tparam : this._compressor.ratio,\n\t\t\tunits : \"positive\",\n\t\t\tvalue: options.ratio,\n\t\t});\n\n\t\t// set the defaults\n\t\treadOnly(this, [\"knee\", \"release\", \"attack\", \"ratio\", \"threshold\"]);\n\t}\n\n\tstatic getDefaults(): CompressorOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack : 0.003,\n\t\t\tknee : 30,\n\t\t\tratio : 12,\n\t\t\trelease : 0.25,\n\t\t\tthreshold : -24,\n\t\t});\n\t}\n\n\t/**\n\t * A read-only decibel value for metering purposes, representing the current amount of gain\n\t * reduction that the compressor is applying to the signal. If fed no signal the value will be 0 (no gain reduction).\n\t */\n\tget reduction(): number {\n\t\treturn this._compressor.reduction;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._compressor.disconnect();\n\t\tthis.attack.dispose();\n\t\tthis.release.dispose();\n\t\tthis.threshold.dispose();\n\t\tthis.ratio.dispose();\n\t\tthis.knee.dispose();\n\t\treturn this;\n\t}\n}\n","export { getContext, setContext } from \"./core/Global\";\nexport * from \"./classes\";\nimport { getContext } from \"./core/Global\";\nexport { start } from \"./core/Global\";\n\n/**\n *  The current audio context time\n */\nexport function now(): import(\"./core/type/Units\").Seconds {\n\treturn getContext().now();\n}\n\n/**\n * The Transport object belonging to the global Tone.js Context\n */\n// tslint:disable-next-line: variable-name\nexport const Transport = getContext().transport;\n\n/**\n * The Destination (output) belonging to the global Tone.js Context\n */\n// tslint:disable-next-line: variable-name\nexport const Destination = getContext().destination;\n","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nmodule.exports = _nonIterableRest;","function _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;"],"sourceRoot":""}