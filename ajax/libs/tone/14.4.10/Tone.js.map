{"version":3,"sources":["webpack://Tone/webpack/universalModuleDefinition","webpack://Tone/webpack/bootstrap","webpack://Tone/./node_modules/automation-events/build/es5/bundle.js","webpack://Tone/./node_modules/@babel/runtime/helpers/slicedToArray.js","webpack://Tone/./node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack://Tone/./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack://Tone/./node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack://Tone/./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack://Tone/./node_modules/@babel/runtime/helpers/createClass.js","webpack://Tone/./Tone/version.ts","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/abort-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/globals.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/invalid-state-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-native-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-constructible.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/split-import-statements.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/add-audio-worklet-module.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/analyser-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-value-for-key.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-owned-by-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-audio-graph.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-audio-node-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-audio-node-renderer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/render-inputs-of-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-audio-buffer-copy-channel-methods-subarray-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/index-size-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-buffer-get-channel-data-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-buffer-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-event-listeners-of-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/set-internal-state.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-event-listener.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-buffer-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-native-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-audio-param-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/render-inputs-of-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/connect-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/render-automation.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-audio-param-renderer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-valid-latency-hint.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/event-target.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/audio-node-output-connection.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/audio-worklet-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/connect-native-audio-node-to-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/delete-event-listeners-of-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/disconnect-native-audio-node-from-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/insert-element-in-set.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-active-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/is-passive-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/pick-element-from-set.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/set-internal-state-to-passive-when-necessary.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-audio-node-disconnect-method-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/read-only-map.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-worklet-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/copy-from-channel.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/copy-to-channel.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/create-nested-arrays.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-worklet-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/get-audio-worklet-processor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/biquad-filter-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/channel-merger-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/channel-splitter-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/constant-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/convolver-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/delay-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/disconnect-multiple-outputs.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/dynamics-compressor-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/gain-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/invalid-access-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/iir-filter-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/filter-buffer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-promise-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/minimal-offline-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/assign-native-audio-node-option.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/assign-native-audio-node-options.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-analyser-node-get-float-time-domain-data-method-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/assign-native-audio-node-audio-param-value.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/compute-buffer-size.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/create-audio-worklet-processor-promise.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/clone-audio-worklet-node-options.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/intercept-connections.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-iir-filter-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/not-supported-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/offline-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/oscillator-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/panner-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/periodic-wave-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/stereo-panner-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/unknown-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wave-shaper-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/module.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/cache-test-result.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/window.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-offline-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-native-offline-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/get-backup-native-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-analyser-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-analyser-node-get-float-time-domain-data-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/analyser-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-native-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-native-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-node-disconnect-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/detect-cycles.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/guards/delay-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/none-audio-destination-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-buffer-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/convert-number-to-unsigned-long.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wrap-audio-buffer-copy-channel-methods.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wrap-audio-buffer-copy-channel-methods-subarray.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-buffer-constructor-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-scheduled-source-node-start-method-negative-parameters-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-buffer-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-buffer-source-node-start-method-consecutive-calls-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-buffer-source-node-start-method-duration-parameter-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-audio-buffer-source-node-start-method-offset-clamping-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-buffer-source-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-param-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-param-renderer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/constants.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-destination-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-destination-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-destination-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-biquad-filter-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/biquad-filter-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wrap-channel-merger-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-channel-merger-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/channel-merger-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-channel-splitter-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-channel-splitter-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/channel-splitter-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-gain-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-constant-source-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-constant-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/constant-source-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-convolver-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/convolver-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-delay-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/delay-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-dynamics-compressor-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/dynamics-compressor-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/gain-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-script-processor-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/render-native-offline-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/test-offline-audio-context-current-time-support.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/iir-filter-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/wrap-iir-filter-node-get-frequency-response-method.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-iir-filter-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/minimal-base-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-listener-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-oscillator-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/oscillator-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-wave-shaper-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-wave-shaper-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-panner-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-panner-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/panner-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-periodic-wave-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-stereo-panner-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-stereo-panner-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/stereo-panner-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/wave-shaper-node-renderer-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-secure-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/expose-current-frame-and-current-time.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/evaluate-source.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/fetch-source.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-native-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-native-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/base-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/decode-audio-data.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/detach-array-buffer.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/data-clone-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/encoding-error.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/media-element-audio-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-media-element-audio-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/media-stream-audio-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-media-stream-audio-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/media-stream-track-audio-source-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-media-stream-track-audio-source-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/connect-multiple-outputs.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-worklet-node-faker-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/create-audio-worklet-processor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-worklet-node-factory.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/helpers/test-clonability-of-audio-worklet-node-options.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/native-audio-worklet-node-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/minimal-audio-context-constructor.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/create-native-offline-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/start-rendering.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-any-audio-context.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-any-audio-node.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-any-audio-param.js","webpack://Tone/./node_modules/standardized-audio-context/build/es2018/factories/is-any-offline-audio-context.js","webpack://Tone/./Tone/core/util/Debug.ts","webpack://Tone/./Tone/core/util/TypeCheck.ts","webpack://Tone/./Tone/core/context/AudioContext.ts","webpack://Tone/./Tone/core/clock/Ticker.ts","webpack://Tone/./Tone/core/util/AdvancedTypeCheck.ts","webpack://Tone/./Tone/core/util/Defaults.ts","webpack://Tone/./Tone/core/Tone.ts","webpack://Tone/./Tone/core/util/Emitter.ts","webpack://Tone/./Tone/core/util/Math.ts","webpack://Tone/./Tone/core/util/Timeline.ts","webpack://Tone/./Tone/core/context/ContextInitialization.ts","webpack://Tone/./Tone/core/context/Context.ts","webpack://Tone/./Tone/core/util/Interface.ts","webpack://Tone/./Tone/core/context/ToneAudioBuffer.ts","webpack://Tone/./Tone/core/context/OfflineContext.ts","webpack://Tone/./Tone/core/Global.ts","webpack://Tone/./Tone/core/type/Conversions.ts","webpack://Tone/./Tone/core/type/TimeBase.ts","webpack://Tone/./Tone/core/type/Time.ts","webpack://Tone/./Tone/core/type/Frequency.ts","webpack://Tone/./Tone/core/type/TransportTime.ts","webpack://Tone/./Tone/core/context/ToneWithContext.ts","webpack://Tone/./Tone/core/context/Param.ts","webpack://Tone/./Tone/core/context/ToneAudioNode.ts","webpack://Tone/./Tone/core/context/Gain.ts","webpack://Tone/./Tone/core/context/Offline.ts","webpack://Tone/./Tone/core/context/ToneAudioBuffers.ts","webpack://Tone/./Tone/core/context/Delay.ts","webpack://Tone/./Tone/core/util/StateTimeline.ts","webpack://Tone/./Tone/source/OneShotSource.ts","webpack://Tone/./Tone/signal/ToneConstantSource.ts","webpack://Tone/./Tone/signal/Signal.ts","webpack://Tone/./Tone/core/clock/TickParam.ts","webpack://Tone/./Tone/core/clock/TickSignal.ts","webpack://Tone/./Tone/core/clock/TickSource.ts","webpack://Tone/./Tone/core/clock/Clock.ts","webpack://Tone/./Tone/core/type/Ticks.ts","webpack://Tone/./Tone/core/type/Midi.ts","webpack://Tone/./Tone/core/util/Draw.ts","webpack://Tone/./Tone/core/util/IntervalTimeline.ts","webpack://Tone/./Tone/component/channel/Volume.ts","webpack://Tone/./Tone/core/context/Destination.ts","webpack://Tone/./Tone/core/util/TimelineValue.ts","webpack://Tone/./Tone/core/clock/TransportEvent.ts","webpack://Tone/./Tone/core/clock/TransportRepeatEvent.ts","webpack://Tone/./Tone/core/clock/Transport.ts","webpack://Tone/./Tone/source/Source.ts","webpack://Tone/./Tone/source/buffer/ToneBufferSource.ts","webpack://Tone/./Tone/source/Noise.ts","webpack://Tone/./Tone/source/oscillator/ToneOscillatorNode.ts","webpack://Tone/./Tone/source/oscillator/Oscillator.ts","webpack://Tone/./Tone/signal/SignalOperator.ts","webpack://Tone/./Tone/signal/WaveShaper.ts","webpack://Tone/./Tone/signal/AudioToGain.ts","webpack://Tone/./Tone/signal/Multiply.ts","webpack://Tone/./Tone/source/oscillator/AMOscillator.ts","webpack://Tone/./Tone/source/oscillator/FMOscillator.ts","webpack://Tone/./Tone/source/oscillator/PulseOscillator.ts","webpack://Tone/./Tone/source/oscillator/FatOscillator.ts","webpack://Tone/./Tone/source/oscillator/PWMOscillator.ts","webpack://Tone/./Tone/source/oscillator/OmniOscillator.ts","webpack://Tone/./Tone/source/buffer/Player.ts","webpack://Tone/./Tone/source/buffer/Players.ts","webpack://Tone/./Tone/source/buffer/GrainPlayer.ts","webpack://Tone/./Tone/signal/Add.ts","webpack://Tone/./Tone/signal/Abs.ts","webpack://Tone/./Tone/signal/GainToAudio.ts","webpack://Tone/./Tone/signal/Negate.ts","webpack://Tone/./Tone/signal/Subtract.ts","webpack://Tone/./Tone/signal/Zero.ts","webpack://Tone/./Tone/component/envelope/Envelope.ts","webpack://Tone/./Tone/component/envelope/AmplitudeEnvelope.ts","webpack://Tone/./Tone/instrument/Instrument.ts","webpack://Tone/./Tone/instrument/Monophonic.ts","webpack://Tone/./Tone/instrument/Synth.ts","webpack://Tone/./Tone/instrument/Sampler.ts","webpack://Tone/./Tone/instrument/PolySynth.ts","webpack://Tone/./Tone/instrument/MembraneSynth.ts","webpack://Tone/./Tone/component/filter/Filter.ts","webpack://Tone/./Tone/signal/Scale.ts","webpack://Tone/./Tone/instrument/MetalSynth.ts","webpack://Tone/./Tone/core/context/ToneAudioWorklet.ts","webpack://Tone/./Tone/component/filter/FeedbackCombFilter.ts","webpack://Tone/./Tone/component/filter/OnePoleFilter.ts","webpack://Tone/./Tone/component/filter/LowpassCombFilter.ts","webpack://Tone/./Tone/instrument/PluckSynth.ts","webpack://Tone/./Tone/instrument/FMSynth.ts","webpack://Tone/./Tone/event/ToneEvent.ts","webpack://Tone/./Tone/event/Part.ts","webpack://Tone/./Tone/event/Sequence.ts","webpack://Tone/./Tone/component/channel/CrossFade.ts","webpack://Tone/./Tone/effect/Effect.ts","webpack://Tone/./Tone/effect/FeedbackEffect.ts","webpack://Tone/./Tone/effect/FeedbackDelay.ts","webpack://Tone/./Tone/effect/Convolver.ts","webpack://Tone/./Tone/component/channel/Merge.ts","webpack://Tone/./Tone/effect/Reverb.ts","webpack://Tone/./Tone/component/analysis/Analyser.ts","webpack://Tone/./Tone/component/channel/Panner.ts","webpack://Tone/./Tone/component/channel/MultibandSplit.ts","webpack://Tone/./Tone/component/filter/EQ3.ts","webpack://Tone/./Tone/component/dynamics/Compressor.ts","webpack://Tone/./Tone/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_slicedToArray","_classCallCheck","_createClass","createExtendedExponentialRampToValueAutomationEvent","endTime","insertTime","type","createExtendedLinearRampToValueAutomationEvent","createSetValueAutomationEvent","startTime","createSetValueCurveAutomationEvent","values","duration","getTargetValueAtTime","time","valueAtStartTime","_ref","target","timeConstant","Math","exp","isExponentialRampToValueAutomationEvent","automationEvent","isLinearRampToValueAutomationEvent","isAnyRampToValueAutomationEvent","isSetValueAutomationEvent","isSetValueCurveAutomationEvent","getValueOfAutomationEventAtIndexAtTime","automationEvents","index","defaultValue","undefined","length","getEndTimeAndValueOfPreviousAutomationEvent","currentAutomationEvent","nextAutomationEvent","isCancelAndHoldAutomationEvent","isCancelScheduledValuesAutomationEvent","getEventTime","cancelTime","getExponentialRampValueAtTime","pow","getLinearRampValueAtTime","getValueCurveValueAtTime","theoreticIndex","lowerIndex","floor","upperIndex","ceil","interpolateValue","isSetTargetAutomationEvent","AutomationEventList","this","_automationEvents","_currenTime","_defaultValue","iterator","eventTime","findIndex","removedAutomationEvent","slice","lastAutomationEvent","Error","startValue","truncatedAutomationEvent","push","getValue","Float32Array","_index","previousAutomationEvent","persistentAutomationEvent","splice","remainingAutomationEvents","firstRemainingAutomationEvent","unshift","_getEndTimeAndValueOf","_getEndTimeAndValueOf2","_getEndTimeAndValueOf3","_getEndTimeAndValueOf4","_startTime","_value","createCancelAndHoldAutomationEvent","createCancelScheduledValuesAutomationEvent","createExponentialRampToValueAutomationEvent","createLinearRampToValueAutomationEvent","createSetTargetAutomationEvent","arrayWithHoles","iterableToArrayLimit","nonIterableRest","arr","Array","isArray","toString","_arr","_n","_d","_e","_s","_i","next","done","err","TypeError","instance","Constructor","_defineProperties","props","descriptor","configurable","writable","protoProps","staticProps","DOMException","code","ACTIVE_AUDIO_NODE_STORE","WeakSet","AUDIO_BUFFER_STORE","AUDIO_NODE_STORE","WeakMap","AUDIO_GRAPHS","AUDIO_PARAM_STORE","AUDIO_PARAM_AUDIO_NODE_STORE","AUXILIARY_GAIN_NODE_STORE","BACKUP_NATIVE_CONTEXT_STORE","CONTEXT_STORE","DETACHED_ARRAY_BUFFERS","EVENT_LISTENERS","NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","NODE_TO_PROCESSOR_MAPS","PERIODIC_WAVE_STORE","TEST_RESULTS","getNativeContext","context","nativeContext","handler","construct","IMPORT_STATEMENT_REGEX","splitImportStatements","source","url","importStatements","sourceWithoutImportStatements","replace","result","match","unresolvedUrl","importStatementWithResolvedUrl","URL","join","verifyParameterDescriptors","parameterDescriptors","verifyProcessorCtor","processorCtor","constructible","Proxy","_a","isConstructible","process","DEFAULT_OPTIONS","channelCount","channelCountMode","channelInterpretation","fftSize","maxDecibels","minDecibels","smoothingTimeConstant","map","getNativeAudioNode","audioNode","isOwnedByContext","nativeAudioNode","getAudioGraph","audioGraph","nodes","getAudioNodeRenderer","audioNodeConnections","renderer","renderInputsOfAudioNode","nativeOfflineAudioContext","Promise","all","activeInputs","connections","input","from","output","render","then","node","connect","reduce","allRenderingPromises","renderingPromises","nativeAudioBuffer","copyToChannel","copyFromChannel","wrapAudioBufferGetChannelDataMethod","audioBuffer","getChannelData","channel","numberOfChannels","getEventListenersOfAudioNode","setInternalState","internalState","has","add","delete","forEach","eventListener","wrapEventListener","event","defineProperties","currentTarget","buffer","loop","loopEnd","loopStart","playbackRate","getNativeAudioParam","audioParam","getAudioParamConnections","params","renderInputsOfAudioParam","nativeAudioParam","audioParamConnections","connectAudioParam","renderAutomation","getAudioParamRenderer","replay","isValidLatencyHint","latencyHint","_nativeEventTarget","_listeners","listener","options","wrappedEventListener","set","addEventListener","dispatchEvent","removeEventListener","isAudioNode","audioNodeOrAudioParam","isAudioNodeOutputConnection","outputConnection","isAudioWorkletNode","connectNativeAudioNodeToNativeAudioNode","nativeSourceAudioNode","nativeDestinationAudioNode","inputs","deleteEventListenerOfAudioNode","disconnectNativeAudioNodeFromNativeAudioNode","disconnect","insertElementInSet","element","predicate","ignoreDuplicates","lmnt","isActiveAudioNode","isPassiveAudioNode","pickElementFromSet","matchingElements","filter","matchingElement","setInternalStateToPassiveWhenNecessary","every","size","testAudioNodeDisconnectMethodSupport","nativeAudioContext","resolve","analyzer","createScriptProcessor","dummy","createGain","ones","createBuffer","channelData","createBufferSource","destination","onaudioprocess","chnnlDt","inputBuffer","some","sample","stop","start","nativeAudioNodeOrAudioParam","addActiveInputConnectionToAudioNode","activeInputConnection","addActiveInputConnectionToAudioParam","addPassiveInputConnectionToAudioNode","passiveInputs","passiveInputConnections","Set","passiveInputConnection","addPassiveInputConnectionToAudioParam","deletePassiveInputConnectionToAudioNode","matchingConnection","deletePassiveInputConnectionToAudioParam","addConnectionToAudioNodeOfAudioContext","outputs","eventListeners","partialConnection","deleteActiveInputConnectionToAudioNode","addConnectionToAudioParamOfAudioContext","deleteActiveInputConnectionToAudioParam","deleteActiveInputConnection","activeInputConnections","deleteInputsOfAudioNode","deleteInputConnectionOfAudioNode","deleteInputsOfAudioParam","deleteInputConnectionOfAudioParam","ReadOnlyMap","parameters","_map","Map","entries","callback","thisArg","keys","numberOfInputs","numberOfOutputs","outputChannelCount","parameterData","processorOptions","createChannelCount","parent","channelNumber","bufferOffset","byteLength","slicedInput","BYTES_PER_ELEMENT","createNestedArrays","x","y","arrays","array","j","processBuffer","async","proxy","renderedBuffer","processorConstructor","numberOfInputChannels","numberOfOutputChannels","sum","processedBuffer","sampleRate","audioWorkletProcessor","nodeToProcessorMap","nativeAudioWorkletNode","getAudioWorkletProcessor","prmtrs","k","potentiallyEmptyInputs","activeSourceFlag","outputChannelSplitterNodeOutput","error","ErrorEvent","Q","detune","frequency","gain","offset","disableNormalization","delayTime","maxDelayTime","getOutputAudioNodeAtIndex","createIndexSizeError","outputAudioNodes","outputAudioNode","attack","knee","ratio","release","threshold","filterBuffer","feedback","feedbackLength","feedforward","feedforwardLength","minLength","xBuffer","yBuffer","bufferIndex","bufferLength","inputLength","uint32Array","Uint32Array","promise","decodeAudioData","catch","assignNativeAudioNodeOption","option","assignNativeAudioNodeOptions","testAnalyserNodeGetFloatTimeDomainDataMethodSupport","nativeAnalyserNode","getFloatTimeDomainData","assignNativeAudioNodeAudioParamValue","wrapAudioScheduledSourceNodeStartMethodNegativeParameters","nativeAudioScheduledSourceNode","when","RangeError","wrapAudioScheduledSourceNodeStopMethodNegativeParameters","computeBufferSize","baseLatency","max","min","round","log2","createAudioWorkletProcessorPromise","audioWorkletNodeOptions","reject","port1","port2","MessageChannel","onmessage","data","close","onmessageerror","postMessage","cloneAudioWorkletNodeOptions","interceptConnections","original","interceptor","apply","arguments","divide","a","b","denominator","evaluatePolynomial","coefficient","z","coneInnerAngle","coneOuterAngle","coneOuterGain","distanceModel","maxDistance","orientationX","orientationY","orientationZ","panningModel","positionX","positionY","positionZ","refDistance","rolloffFactor","pan","curve","oversample","ongoingTests","tester","test","cachedTestResult","ongoingTest","synchronousTestResult","finalTestResult","createCacheTestResult","createWindow","OfflineAudioContext","webkitOfflineAudioContext","createNativeOfflineAudioContextConstructor","nativeOfflineAudioContextConstructor","anything","createIsNativeOfflineAudioContext","AudioContext","webkitAudioContext","createNativeAudioContextConstructor","isNativeOfflineAudioContext","nativeAudioContextConstructor","state","backupNativeContext","bckpNtveCntxt","createGetBackupNativeContext","getBackupNativeContext","factoryFunction","createNativeAudioNodeFactory","cacheTestResult","createNativeAudioNode","ntvCntxt","createAnalyser","byteTimeDomainData","Uint8Array","getByteTimeDomainData","wrapAnalyserNodeGetFloatTimeDomainDataMethod","createNativeAnalyserNodeFactory","createNativeAnalyserNode","renderedNativeAnalyserNodes","renderedNativeAnalyserNode","createAnalyserNode","createAnalyserNodeRendererFactory","AudioNode","createIsNativeAudioNode","AudioParam","createIsNativeAudioParam","createInvalidAccessError","createNotSupportedError","detectCycles","isNativeAudioNode","isNativeAudioParam","audioNodeRenderer","super","_context","_nativeAudioNode","returnValue","connectionsToDestination","connection","destinationOrOutput","clear","filteredConnections","wrapAudioNodeDisconnectMethod","audioNoderRender","addAudioNode","isOffline","auxiliaryGainNodes","nativeGainNode","addConnectionToAudioNodeOfOfflineAudioContext","addConnectionToAudioParamOfOfflineAudioContext","audioNodeConnectionsOfSource","deleteAnyConnection","deleteConnectionAtOutput","numberOfDeletedConnections","deleteConnectionToDestination","createAudioNodeConstructor","audioParamAudioNodeStore","getAudioNodeConnections","getValueForKey","audioNodeOfDestination","isDelayNode","createDetectCycles","audioNodeConstructor","createNoneAudioDestinationNodeConstructor","analyserNodeConstructor","createAnalyserNodeRenderer","noneAudioDestinationNodeConstructor","mergedOptions","_nativeAnalyserNode","frequencyBinCount","getByteFrequencyData","getFloatFrequencyData","createAnalyserNodeConstructor","AudioBuffer","createNativeAudioBufferConstructor","convertNumberToUnsignedLong","unit32Array","createConvertNumberToUnsignedLong","channelNumberAsNumber","bufferOffsetAsNumber","audioBufferLength","destinationLength","sourceLength","createWrapAudioBufferCopyChannelMethods","createWrapAudioBufferCopyChannelMethodsOutOfBounds","subarray","createWrapAudioBufferCopyChannelMethodsSubarray","audioBufferConstructor","audioBufferStore","nativeAudioBufferConstructor","testNativeAudioBufferConstructorSupport","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","wrapAudioBufferCopyChannelMethodsSubarray","hasInstance","getPrototypeOf","createAudioBufferConstructor","createTestAudioBufferConstructorSupport","nativeAudioBufferSourceNode","createOscillator","createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport","createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport","disconnectGainNode","isStopped","setValueAtTime","createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","testAudioBufferSourceNodeStartMethodDurationParameterSupport","testAudioBufferSourceNodeStartMethodOffsetClampingSupport","testAudioScheduledSourceNodeStartMethodNegativeParametersSupport","testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport","testAudioScheduledSourceNodeStopMethodNegativeParametersSupport","wrapAudioBufferSourceNodeStartMethodOffsetClampling","wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","isScheduled","wrapAudioBufferSourceNodeStartMethodConsecutiveCalls","Number","POSITIVE_INFINITY","stopTime","actualStartTime","currentTime","durationInBufferTime","wrapAudioBufferSourceNodeStartMethodDurationParameter","createNativeAudioBufferSourceNodeFactory","createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport","offlineAudioContext","audioBufferSourceNode","oncomplete","startRendering","createTestAudioBufferSourceNodeStartMethodDurationParameterSupport","createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport","clampedOffset","createNativeAudioBufferSourceNode","renderedNativeAudioBufferSourceNodes","renderedNativeAudioBufferSourceNode","nativeAudioBufferSourceNodeIsOwnedByContext","createAudioBufferSourceNode","createAudioBufferSourceNodeRendererFactory","createAudioParamRenderer","isAudioParamOfOfflineAudioContext","maxValue","minValue","automationEventList","audioParamRenderer","cancelAndHoldAtTime","flush","previousLastEvent","pop","currentLastEvent","cancelScheduledValues","exponentialRampToValueAtTime","linearRampToValueAtTime","setValueCurveAtTime","setTargetAtTime","firstSample","lastSample","numberOfInterpolatedValues","interpolatedValues","timeOfLastSample","addAudioParam","createAudioParamFactory","audioBufferSourceNodeConstructor","createAudioBufferSourceNodeRenderer","createAudioParam","createInvalidStateError","audioBufferSourceNodeRenderer","_audioBufferSourceNodeRenderer","_isBufferNullified","_isBufferSet","_nativeAudioBufferSourceNode","_onended","_playbackRate","fill","wrappedListener","onended","nativeOnEnded","setInternalStateToInactive","setTimeout","createAudioBufferSourceNodeConstructor","createAudioDestinationNodeRenderer","createNativeAudioDestinationNode","nativeAudioDestinationNode","audioDestinationNodeRenderer","audioWorkletGlobalScope","_isNodeOfNativeOfflineAudioContext","_nativeAudioDestinationNode","maxChannelCount","createAudioDestinationNodeConstructor","nativeAudioDestinationNodePromise","createAudioDestinationNode","isNodeOfNativeOfflineAudioContext","nativeBiquadFilterNode","createBiquadFilter","createNativeBiquadFilterNodeFactory","biquadFilterNodeConstructor","createBiquadFilterNodeRenderer","createNativeBiquadFilterNode","_Q","_detune","_frequency","_gain","_nativeBiquadFilterNode","frequencyHz","magResponse","phaseResponse","getFrequencyResponse","createBiquadFilterNodeConstructor","renderedNativeBiquadFilterNodes","renderedNativeBiquadFilterNode","nativeBiquadFilterNodeIsOwnedByContext","createBiquadFilterNode","createBiquadFilterNodeRendererFactory","channelMergerNode","createWrapChannelMergerNode","wrapChannelMergerNode","nativeChannelMergerNode","createChannelMerger","createNativeChannelMergerNodeFactory","channelMergerNodeConstructor","createChannelMergerNodeRenderer","createNativeChannelMergerNode","createChannelMergerNodeConstructor","renderedNativeAudioNodes","renderedNativeAudioNode","createAudioNode","createChannelMergerNodeRendererFactory","nativeChannelSplitterNode","createChannelSplitter","channelSplitterNode","wrapChannelSplitterNode","createNativeChannelSplitterNodeFactory","channelSplitterNodeConstructor","createChannelSplitterNodeRenderer","createNativeChannelSplitterNode","createChannelSplitterNodeConstructor","createChannelSplitterNodeRendererFactory","createNativeGainNodeFactory","createNativeGainNode","audioNodeOptions","gainNode","args","createNativeConstantSourceNodeFakerFactory","createNativeConstantSourceNodeFaker","createConstantSource","nativeConstantSourceNode","createNativeConstantSourceNodeFactory","constantSourceNodeConstructor","createConstantSourceNodeRendererFactory","createNativeConstantSourceNode","constantSourceNodeRenderer","_constantSourceNodeRenderer","_nativeConstantSourceNode","_offset","createConstantSourceNodeConstructor","renderedNativeConstantSourceNodes","renderedNativeConstantSourceNode","nativeConstantSourceNodeIsOwnedByContext","createConstantSourceNode","nativeConvolverNode","createConvolver","normalize","createNativeConvolverNodeFactory","convolverNodeConstructor","createConvolverNodeRenderer","createNativeConvolverNode","_nativeConvolverNode","createConvolverNodeConstructor","renderedNativeConvolverNodes","renderedNativeConvolverNode","createConvolverNode","createConvolverNodeRendererFactory","nativeDelayNode","createDelay","createNativeDelayNodeFactory","delayNodeConstructor","createDelayNodeRenderer","createNativeDelayNode","_delayTime","createDelayNodeConstructor","renderedNativeDelayNodes","renderedNativeDelayNode","nativeDelayNodeIsOwnedByContext","createDelayNode","createDelayNodeRendererFactory","nativeDynamicsCompressorNode","createDynamicsCompressor","createNativeDynamicsCompressorNodeFactory","dynamicsCompressorNodeConstructor","createDynamicsCompressorNodeRenderer","createNativeDynamicsCompressorNode","_attack","_knee","_nativeDynamicsCompressorNode","_ratio","_release","_threshold","previousChannelCount","reduction","createDynamicsCompressorNodeConstructor","renderedNativeDynamicsCompressorNodes","renderedNativeDynamicsCompressorNode","nativeDynamicsCompressorNodeIsOwnedByContext","createDynamicsCompressorNode","createDynamicsCompressorNodeRendererFactory","createGainNodeRenderer","createGainNodeConstructor","renderedNativeGainNodes","renderedNativeGainNode","nativeGainNodeIsOwnedByContext","createGainNode","createGainNodeRendererFactory","bufferSize","createNativeScriptProcessorNodeFactory","createNativeScriptProcessorNode","scriptProcessorNode","bufferIndexes","xBuffers","yBuffers","outputBuffer","nyquist","omega","PI","cos","sin","response","sqrt","atan2","createNativeIIRFilterNodeFakerFactory","testOfflineAudioContextCurrentTimeSupport","isOfflineAudioContextCurrentTimeSupported","createRenderNativeOfflineAudioContext","createTestOfflineAudioContextCurrentTimeSupport","renderNativeOfflineAudioContext","nativeIIRFilterNode","nativeIIRFilterNodeIsOwnedByContext","createIIRFilter","partialOfflineAudioContext","filteredBuffer","filterFullBuffer","createIIRFilterNodeRendererFactory","iIRFilterNodeConstructor","createNativeIIRFilterNode","createIIRFilterNodeRenderer","wrapIIRFilterNodeGetFrequencyResponseMethod","_nativeIIRFilterNode","createIIRFilterNodeConstructor","createNativeIIRFilterNodeFaker","createNativeIIRFilterNodeFactory","audioDestinationNodeConstructor","createAudioListener","_nativeContext","_destination","_listener","_onstatechange","onstatechange","nativeOnStateChange","createMinimalBaseAudioContextConstructor","nativeListener","forwardX","forwardY","forwardZ","upX","upY","upZ","createFakeAudioParam","constantSourceNode","lastOrientation","lastPosition","orientation","setOrientation","positon","setPosition","createFakeAudioParams","createAudioListenerFactory","nativeOscillatorNode","periodicWave","setPeriodicWave","createNativeOscillatorNodeFactory","createNativeOscillatorNode","renderedNativeOscillatorNodes","renderedNativeOscillatorNode","nativeOscillatorNodeIsOwnedByContext","createOscillatorNode","createOscillatorNodeRendererFactory","oscillatorNodeConstructor","createOscillatorNodeRenderer","oscillatorNodeRenderer","_nativeOscillatorNode","_oscillatorNodeRenderer","createOscillatorNodeConstructor","negativeWaveShaperNode","createWaveShaper","positiveWaveShaperNode","inputGainNode","invertGainNode","outputGainNode","revertGainNode","unmodifiedCurve","nativeWaveShaperNodeFaker","curveLength","negativeCurve","positiveCurve","centerIndex","createNativeWaveShaperNodeFakerFactory","createNativeWaveShaperNodeFaker","nativeWaveShaperNode","createNativeWaveShaperNodeFactory","createNativeWaveShaperNode","pannerNode","createPanner","SINGLE_CHANNEL_OPTIONS","orientationXGainNode","orientationYGainNode","orientationZGainNode","positionXGainNode","positionYGainNode","positionZGainNode","waveShaperNode","nativePannerNodeFaker","createNativePannerNodeFakerFactory","createNativePannerNodeFaker","nativePannerNode","createNativePannerNodeFactory","pannerNodeConstructor","createNativePannerNode","createPannerNodeRenderer","_nativePannerNode","_orientationX","_orientationY","_orientationZ","_positionX","_positionY","_positionZ","createPannerNodeConstructor","renderedNativePannerNodes","renderedNativePannerNode","nativePannerNodeIsOwnedByContext","createPannerNode","createPannerNodeRendererFactory","periodicWaveConstructor","createNativePeriodicWave","periodicWaveStore","PeriodicWave","createPeriodicWaveConstructor","imag","real","wrappedImag","wrappedReal","createPeriodicWave","createNativePeriodicWaveFactory","DC_CURVE","HALF_PI","SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS","buildInternalGraph","panGainNode","leftWaveShaperCurve","rightWaveShaperCurve","leftGainNode","leftWaveShaperNode","panWaveShaperNode","rightGainNode","rightWaveShaperNode","buildInternalGraphForMono","leftInputForLeftOutputWaveShaperCurve","leftInputForRightOutputWaveShaperCurve","rightInputForLeftOutputWaveShaperCurve","rightInputForRightOutputWaveShaperCurve","CURVE_SIZE","leftInputForLeftOutputGainNode","leftInputForLeftOutputWaveShaperNode","leftInputForRightOutputGainNode","leftInputForRightOutputWaveShaperNode","rightInputForLeftOutputGainNode","rightInputForLeftOutputWaveShaperNode","rightInputForRightOutputGainNode","rightInputForRightOutputWaveShaperNode","buildInternalGraphForStereo","outputNodes","outputNode","createNativeStereoPannerNodeFakerFactory","createNativeStereoPannerNodeFaker","createStereoPanner","nativeStereoPannerNode","createNativeStereoPannerNodeFactory","stereoPannerNodeConstructor","createNativeStereoPannerNode","createStereoPannerNodeRenderer","_pan","createStereoPannerNodeConstructor","renderedNativeStereoPannerNodes","renderedNativeStereoPannerNode","nativeStereoPannerNodeIsOwnedByContext","createStereoPannerNode","createStereoPannerNodeRendererFactory","renderedNativeWaveShaperNodes","renderedNativeWaveShaperNode","createWaveShaperNode","createWaveShaperNodeRendererFactory","waveShaperNodeConstructor","createWaveShaperNodeRenderer","_isCurveNullified","_nativeWaveShaperNode","createWaveShaperNodeConstructor","isSecureContext","createIsSecureContext","fn","currentFrame","createExposeCurrentFrameAndCurrentTime","addAudioWorkletModule","createAbortError","exposeCurrentFrameAndCurrentTime","fetchSource","ongoingRequests","resolvedRequests","moduleURL","credentials","absoluteUrl","location","href","audioWorklet","blob","Blob","createObjectURL","addModule","revokeObjectURL","resolvedRequestsOfContext","ongoingRequestsOfContext","promiseOfOngoingRequest","head","document","SyntaxError","script","createElement","originalOnErrorHandler","onerror","removeErrorEventListenerAndRevokeUrl","message","src","lineno","colno","onload","appendChild","evaluateSource","evaluateAudioWorkletGlobalScope","_AWGS","trim","nodeNameToProcessorConstructorMap","rslvdRqstsFCntxt","ngngRqstsFCntxt","createAddAudioWorkletModule","fetch","ok","text","createFetchSource","isNativeAudioContext","createIsNativeAudioContext","createIsNativeContext","gainNodeConstructor","minimalBaseAudioContextConstructor","_audioWorklet","constraints","audioData","successCallback","errorCallback","createBaseAudioContextConstructor","createDataCloneError","createEncodingError","isNativeContext","testAudioBufferCopyChannelMethodsOutOfBoundsSupport","testAudioBufferCopyChannelMethodsSubarraySupport","testPromiseSupport","anyContext","complete","arrayBuffer","detachArrayBuffer","fail","createDecodeAudioData","createNativeMediaElementAudioSourceNode","nativeMediaElementAudioSourceNode","_mediaElement","mediaElement","_nativeMediaElementAudioSourceNode","createMediaElementAudioSourceNodeConstructor","ntvDCntxt","createMediaElementSource","createNativeMediaElementAudioSourceNodeFactory","createNativeMediaStreamAudioSourceNode","nativeMediaStreamAudioSourceNode","_nativeMediaStreamAudioSourceNode","mediaStream","createMediaStreamAudioSourceNodeConstructor","audioStreamTracks","getAudioTracks","filteredAudioStreamTracks","sort","id","createMediaStreamSource","MediaStream","createNativeMediaStreamAudioSourceNodeFactory","createNativeMediaStreamTrackAudioSourceNode","createMediaStreamTrackAudioSourceNodeConstructor","mediaStreamTrack","createMediaStreamTrackSource","kind","createNativeMediaStreamTrackAudioSourceNodeFactory","audioContextConstructor","baseAudioContextConstructor","createUnknownError","mediaElementAudioSourceNodeConstructor","mediaStreamAudioSourceNodeConstructor","mediaStreamTrackAudioSourceNodeConstructor","_baseLatency","_nativeAudioContext","_state","revokeState","resolvePromise","resume","suspend","createAudioContextConstructor","createConnectMultipleOutputs","createDisconnectMultipleOutputs","connectMultipleOutputs","disconnectMultipleOutputs","numberOfParameters","messageChannel","gainNodes","inputChannelSplitterNodes","constantSourceNodes","inputChannelMergerNode","outputChannelSplitterNode","outputChannelMergerNodes","parameterMap","outputChannelMergerNode","onprocessorerror","nativeAudioWorkletNodeFaker","_","patchedEventListeners","unpatchedEventListener","handleEvent","patchedEventListener","port","audioWorkletProcessorPromise","createAudioWorkletProcessor","dWrkltPrcssr","isActive","createNativeAudioWorkletNodeFakerFactory","createNativeAudioWorkletNodeFaker","nativeAudioWorkletNodeConstructor","hasNoOutput","testClonabilityOfAudioWorkletNodeOptions","createNativeAudioWorkletNodeFactory","AudioWorkletNode","createNativeAudioWorkletNodeConstructor","renderedNativeAudioWorkletNodeOrOutputNodes","renderedNativeAudioWorkletNodeOrGainNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","nm","createAudioWorkletNodeRendererFactory","audioWorkletNodeConstructor","createAudioWorkletNodeRenderer","createNativeAudioWorkletNode","sanitizedOptions","_nativeAudioWorkletNode","_numberOfOutputs","_onprocessorerror","_parameters","nativeOnProcessorError","createAudioWorkletNodeConstructor","createMinimalAudioContextConstructor","createCreateNativeOfflineAudioContext","createStartRendering","offlineAudioContextConstructor","createNativeOfflineAudioContext","delayStateChangeEvent","stopImmediatePropagation","_waitForThePromiseToSettle","_length","_nativeOfflineAudioContext","createMinimalOfflineAudioContextConstructor","createOfflineAudioContextConstructor","isAnyAudioContext","contextStore","createIsAnyAudioContext","isAnyAudioNode","audioNodeStore","createIsAnyAudioNode","isAnyAudioParam","audioParamStore","createIsAnyAudioParam","isAnyOfflineAudioContext","createIsAnyOfflineAudioContext","assert","statement","defaultLogger","console","setLogger","logger","log","warn","isUndef","arg","isDefined","isFunction","isNumber","isObject","constructor","isBoolean","isString","isNote","globalContext","theWindow","self","hasAudioContext","getAudioContext","TONE_AUDIO_CONTEXT","updateInterval","_callback","_type","_updateInterval","_createClock","_createWorker","toFixed","blobUrl","worker","Worker","_worker","_createTimeout","_timeout","e","_disposeClock","clearTimeout","terminate","interval","dispose","isAudioParam","isOfflineAudioContext","isAudioContext","isAudioBuffer","noCopy","deepMerge","sources","shift","assign","optionsFromArguments","defaults","argsArray","objKey","opts","Reflect","indexOf","defaultArg","given","fallback","omitFromObject","obj","omit","prop","debug","_wasDisposed","getDefaults","TONE_DEBUG_CLASS","version","on","split","eventName","_events","once","boundCallback","off","eventList","emit","len","mixin","constr","getOwnPropertyDescriptor","Emitter","EPSILON","GT","LT","EQ","abs","_timeline","_epsilon","Timeline","memory","increasing","Infinity","valueOf","lastValue","_search","diff","remove","param","peek","getAfter","getBefore","cancel","after","cancelBefore","previousEvent","_eq","_gt","_lt","beginning","end","midPoint","nextEvent","_iterate","lowerBound","upperBound","forEachBefore","forEachAfter","forEachBetween","forEachFrom","forEachAtTime","notifyNewContext","onContextInit","cb","notifyCloseContext","onContextClose","_constants","_timeouts","_timeoutIds","_initialized","_workletModules","Context","_latencyHint","lookAhead","_ticker","Ticker","clockSource","_timeoutLoop","initialize","ctx","feedForward","stream","_transport","createAudioWorkletNode","rawContext","workletsAreReady","promises","hint","lookAheadValue","now","getConstant","val","constant","firstEvent","timeout","clearInterval","setInterval","intervalFn","readOnly","str","noOp","ToneAudioBuffer","reverse","load","_buffer","getContext","loaded","_reversed","_reverse","downloads","fromArray","isMultidimensional","channels","multiChannelArray","toMono","chanNum","toArray","outputArray","channelArray","ret","startSamples","endSamples","retBuffer","rev","fromUrl","matches","extensions","extension","ext","supportsType","baseUrl","canPlayType","_currentTime","_duration","_renderClock","asynchronous","yieldEvery","dummyContext","transport","setContext","TONE_SILENCE_LOGGING","prefix","printString","dbToGain","db","gainToDb","LN10","intervalToFrequencyRatio","A4","ftom","ftomf","mtof","midi","units","defaultUnits","_val","_units","_expressions","_getExpressions","hz","method","_frequencyToUnits","parseFloat","regexp","_ticksToUnits","parseInt","_beatsToUnits","_getTimeSignature","dot","numericValue","scalar","number","_secondsToUnits","samples","tr","q","total","TimeBaseClass","fromType","_noArg","typeName","quantity","expr","matching","freq","beats","_getBpm","seconds","ticks","_getPPQ","_now","bpm","timeSignature","PPQ","toSeconds","toTicks","toFrequency","toMidi","toSamples","toMilliseconds","capture","quantize","quantTo","TimeClass","nextSubdivision","subdiv","percent","subdivision","toNotation","testNotations","power","closest","closestSeconds","notation","notationSeconds","toBarsBeatsSixteenths","quarterTime","quarters","measures","sixteenths","sixteenthString","Time","setA4","FrequencyClass","note","pitch","octave","noteNumber","noteToScaleIndex","toLowerCase","transpose","harmonize","intervals","toNote","scaleIndexToNote","cbb","cx","dbb","dx","ebb","eb","ex","fbb","fb","f","fx","gbb","gb","g","gx","abb","ab","ax","bbb","bb","bx","Frequency","TransportTime","TransportTimeClass","ToneWithContext","defaultContext","immediate","_getPartialProperties","attribute","member","Param","overridden","_minOutput","_param","_swappable","swappable","_initialValue","convert","_minValue","_maxValue","_toType","getValueAtTime","_fromType","_is","computedTime","isFinite","JSON","stringify","before","beforeValue","previous","_linearInterpolate","_exponentialInterpolate","previousVal","_exponentialApproach","setRampPoint","currentVal","exponentialRampTo","rampTime","linearRampTo","targetRampTo","exponentialApproachValueAtTime","scaling","startingValue","segTime","valueAtTime","sampleTime","rampTo","subdivisions","setParam","t0","v0","v1","t1","_internalChannels","_isAudioNode","ToneAudioNode","_getInternalNodes","nodeList","_setChannelProperties","_getChannelProperties","outputNum","inputNum","toDestination","toMaster","chain","connectSeries","fan","first","prev","current","srcNode","dstNode","outputNumber","inputNumber","Gain","_gainNode","Offline","originalContext","bufferPromise","_buffers","_loadingCount","ToneAudioBuffers","urls","_bufferLoaded","Delay","maxDelayInSeconds","maxDelay","_delayNode","initial","_initial","setStateAtTime","getLastState","getNextState","_stopTime","getStateAtTime","_fadeIn","fadeIn","_fadeOut","fadeOut","_curve","_startGain","fadeInTime","_stopGain","cancelStop","fadeOutTime","additionalTail","_stopSource","ToneConstantSource","_source","Signal","override","_constantSource","connectSignal","signal","TickParam","_multiplier","multiplier","computedValue","prevEvent","segments","rampVal","ticksUntilTime","_getTicksUntilEvent","computedVal","segmentDur","val0","val1","onTheLineEvent","getTicksAtTime","getDurationOfTicks","currentTick","getTimeOfTick","tick","delta","sol1","ticksToTime","timeToTicks","computedDuration","startTicks","TickSignal","TickSource","StateTimeline","_tickOffset","setTicksAtTime","pause","stopEvent","tmpEvent","lastState","elapsedTicks","periodStartTime","offsetEvent","getSecondsAtTime","elapsedSeconds","absoluteTicks","forEachTickBetween","computedStartTime","computedEndTime","lastStateEvent","maxStartTime","nextTickTime","Clock","_lastUpdate","_boundLoop","_loop","_tickSource","Ticks","TicksClass","MidiClass","Midi","expiration","anticipation","_boundDrawLoop","_drawLoop","_animationFrame","schedule","requestAnimationFrame","cancelAnimationFrame","_root","IntervalNode","insert","updateHeight","updateMax","_rebalance","results","search","_removeNode","_setRoot","_replaceNodeInParent","replacement","isLeftChild","left","right","temp","getBalance","_rotateLeft","pivotNode","_rotateRight","balance","low","traverse","searchAfter","high","_left","_right","height","point","Volume","volume","_unmutedVolume","mute","Destination","initialValue","TransportEvent","_eventId","_once","invoke","_currentId","_nextId","_nextTick","_boundRestart","_restart","TransportRepeatEvent","_interval","_createEvents","scheduleOnce","Transport","_loopStart","_loopEnd","_scheduledEvents","_repeatedEvents","_syncedSignals","_swingAmount","_ppq","ppq","_clock","_processTick","_bindClockEvents","_timeSignature","_swingTicks","swing","swingSubdivision","tickTime","progress","amount","_addEvent","scheduleRepeat","eventId","item","timeline","computedAfter","offsetTicks","toggle","timeSig","startPosition","endPosition","setLoopPoints","remainingTicks","syncSignal","computedFreq","ratioSignal","unsyncSignal","syncedSignal","_synced","_scheduled","_syncedStart","_syncedStop","_volume","onstop","_clampToCurrentTime","restart","sched","_start","_stop","sync","stateEvent","startOffset","unsync","ToneBufferSource","_sourceStarted","_sourceStopped","computedOffset","loopDuration","computedDur","Noise","_noiseBuffers","rate","random","_noiseCache","brown","pink","white","channelNum","lastOut","b0","b1","b2","b3","b4","b5","b6","ToneOscillatorNode","_oscillator","Oscillator","_partials","partials","_partialCount","partialCount","baseType","phase","oscillator","_wave","syncFrequency","unsyncFrequency","_getCachedPeriodicWave","oscProps","_periodicWaveCache","find","description","_phase","arrayA","arrayB","isBasicType","cache","partial","exec","_getRealImaginary","periodicWaveSize","piFactor","_inverseFFT","getInitialValue","twoPi","SignalOperator","WaveShaper","_shaper","mapping","setMap","normalized","oversampling","isOverSampleType","includes","_norm","Multiply","_mult","factor","AMOscillator","_modulationScale","_modulationNode","_carrier","_modulator","modulationType","harmonicity","FMOscillator","modulationIndex","PulseOscillator","_widthGate","_thresh","width","_sawtooth","FatOscillator","_oscillators","_spread","spread","count","_forEach","osc","PWMOscillator","sourceType","_scale","_pulse","modulationFrequency","OmniOscillatorSourceMap","am","fat","fm","pulse","pwm","OmniOscillator","_sourceType","substr","_createNewOscillator","_getOscType","oscType","OscConstructor","blockTime","sType","mType","Player","_activeSources","_onload","autostart","_onSourceEnd","comptuedOffset","origDuration","implicitEnd","seek","Players","_players","player","stopAll","GrainPlayer","_tick","grainSize","_grainSize","_overlap","overlap","_onstop","Add","_sum","addend","_abs","_multiply","Subtract","_neg","subtrahend","Zero","Envelope","_sig","decay","sustain","attackCurve","releaseCurve","decayCurve","_getCurve","direction","curveName","EnvelopeCurves","_setCurve","curveDef","_attackCurve","_releaseCurve","_decayCurve","triggerAttack","velocity","currentValue","decayValue","decayStart","triggerRelease","triggerAttackRelease","cosineCurve","rippleCurve","curveLen","sineWave","stairsCurve","sineCurve","bounceCurve","invertCurve","out","bounce","In","Out","cosine","exponential","linear","ripple","sine","step","AmplitudeEnvelope","Instrument","_original_triggerAttack","_original_triggerRelease","_syncMethod","timePosition","originalMethod","Monophonic","portamento","onsilence","_triggerEnvelopeAttack","setNote","_triggerEnvelopeRelease","getLevelAtTime","envelope","computedFrequency","portTime","Synth","computedAttack","computedDecay","Sampler","urlMap","mid","_findClosest","notes","difference","closestNote","releaseAll","PolySynth","_availableVoices","_activeVoices","_voices","_gcTimeout","_averageActiveVoices","voice","maxPolyphony","_collectGarbage","_getActiveVoice","_makeVoiceAvailable","activeVoiceIndex","_getNextAvailableVoice","activeVoices","firstAvail","_triggerAttack","midiNote","_triggerRelease","_scheduleEvent","disposed","durationSeconds","v","MembraneSynth","pitchDecay","octaves","hertz","maxNote","Filter","_filters","rolloff","_rolloff","rolloffNum","possibilities","cascadingCount","totalResponse","freqValues","magValues","phaseValues","filterClone","Scale","_outputMin","_outputMax","_setRange","inharmRatios","MetalSynth","_freqMultipliers","_amplitude","_highpass","mult","_filterFreqScaler","resonance","_octaves","freqMult","workletOptions","_audioWorkletName","_worklet","onReady","FeedbackCombFilter","dummyGain","ToneAudioWorklet","OnePoleFilter","_createFilter","oldFilter","_filter","a0","fq","LowpassCombFilter","_combFilter","_lowpass","dampening","PluckSynth","_noise","attackNoise","_lfcf","delayAmount","FMSynth","modulation","modulationEnvelope","ToneEvent","_startOffset","_probability","probability","_humanize","humanize","_rescheduleEvents","startTick","_getLoopDuration","prob","variation","reschedulTime","lastEvent","Part","events","_startNote","at","timeInTicks","_restartEvent","_setAll","attr","_testLoopBoundries","Sequence","_part","_seqCallback","_eventsArray","_subdivision","_createSequence","_eventsUpdated","_indexTime","_rescheduleSequence","sequence","eventOffset","CrossFade","_panner","_split","_g2a","fade","_dryWet","wet","effectSend","effectReturn","connectEffect","effect","_feedbackGain","FeedbackDelay","Convolver","_convolver","buff","norm","Merge","_merger","Reverb","preDelay","generate","noiseL","noiseR","merge","Analyser","_analyser","smoothing","Panner","MultibandSplit","_lowMidFilter","lowFrequency","highFrequency","EQ3","_multibandSplit","_lowGain","_midGain","_highGain","Compressor","_compressor"],"mappings":"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","file":"Tone.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Tone\"] = factory();\n\telse\n\t\troot[\"Tone\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/slicedToArray'), require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass')) :\n    typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/slicedToArray', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass'], factory) :\n    (global = global || self, factory(global.automationEvents = {}, global._slicedToArray, global._classCallCheck, global._createClass));\n}(this, function (exports, _slicedToArray, _classCallCheck, _createClass) { 'use strict';\n\n    _slicedToArray = _slicedToArray && _slicedToArray.hasOwnProperty('default') ? _slicedToArray['default'] : _slicedToArray;\n    _classCallCheck = _classCallCheck && _classCallCheck.hasOwnProperty('default') ? _classCallCheck['default'] : _classCallCheck;\n    _createClass = _createClass && _createClass.hasOwnProperty('default') ? _createClass['default'] : _createClass;\n\n    var createExtendedExponentialRampToValueAutomationEvent = function createExtendedExponentialRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createExtendedLinearRampToValueAutomationEvent = function createExtendedLinearRampToValueAutomationEvent(value, endTime, insertTime) {\n      return {\n        endTime: endTime,\n        insertTime: insertTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetValueAutomationEvent = function createSetValueAutomationEvent(value, startTime) {\n      return {\n        startTime: startTime,\n        type: 'setValue',\n        value: value\n      };\n    };\n\n    var createSetValueCurveAutomationEvent = function createSetValueCurveAutomationEvent(values, startTime, duration) {\n      return {\n        duration: duration,\n        startTime: startTime,\n        type: 'setValueCurve',\n        values: values\n      };\n    };\n\n    var getTargetValueAtTime = function getTargetValueAtTime(time, valueAtStartTime, _ref) {\n      var startTime = _ref.startTime,\n          target = _ref.target,\n          timeConstant = _ref.timeConstant;\n      return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n    };\n\n    var isExponentialRampToValueAutomationEvent = function isExponentialRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'exponentialRampToValue';\n    };\n\n    var isLinearRampToValueAutomationEvent = function isLinearRampToValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'linearRampToValue';\n    };\n\n    var isAnyRampToValueAutomationEvent = function isAnyRampToValueAutomationEvent(automationEvent) {\n      return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n    };\n\n    var isSetValueAutomationEvent = function isSetValueAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValue';\n    };\n\n    var isSetValueCurveAutomationEvent = function isSetValueCurveAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setValueCurve';\n    };\n\n    var getValueOfAutomationEventAtIndexAtTime = function getValueOfAutomationEventAtIndexAtTime(automationEvents, index, time, defaultValue) {\n      var automationEvent = automationEvents[index];\n      return automationEvent === undefined ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);\n    };\n\n    var getEndTimeAndValueOfPreviousAutomationEvent = function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) {\n      return currentAutomationEvent === undefined ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime + currentAutomationEvent.duration, currentAutomationEvent.values[currentAutomationEvent.values.length - 1]] : [currentAutomationEvent.startTime, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)];\n    };\n\n    var isCancelAndHoldAutomationEvent = function isCancelAndHoldAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelAndHold';\n    };\n\n    var isCancelScheduledValuesAutomationEvent = function isCancelScheduledValuesAutomationEvent(automationEvent) {\n      return automationEvent.type === 'cancelScheduledValues';\n    };\n\n    var getEventTime = function getEventTime(automationEvent) {\n      if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n        return automationEvent.cancelTime;\n      }\n\n      if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n        return automationEvent.endTime;\n      }\n\n      return automationEvent.startTime;\n    };\n\n    var getExponentialRampValueAtTime = function getExponentialRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n          value = _ref.value;\n\n      if (valueAtStartTime === value) {\n        return value;\n      }\n\n      if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {\n        return valueAtStartTime * Math.pow(value / valueAtStartTime, (time - startTime) / (endTime - startTime));\n      }\n\n      return 0;\n    };\n\n    var getLinearRampValueAtTime = function getLinearRampValueAtTime(time, startTime, valueAtStartTime, _ref) {\n      var endTime = _ref.endTime,\n          value = _ref.value;\n      return valueAtStartTime + (time - startTime) / (endTime - startTime) * (value - valueAtStartTime);\n    };\n\n    var interpolateValue = function interpolateValue(values, theoreticIndex) {\n      var lowerIndex = Math.floor(theoreticIndex);\n      var upperIndex = Math.ceil(theoreticIndex);\n\n      if (lowerIndex === upperIndex) {\n        return values[lowerIndex];\n      }\n\n      return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n    };\n\n    var getValueCurveValueAtTime = function getValueCurveValueAtTime(time, _ref) {\n      var duration = _ref.duration,\n          startTime = _ref.startTime,\n          values = _ref.values;\n      var theoreticIndex = (time - startTime) / duration * (values.length - 1);\n      return interpolateValue(values, theoreticIndex);\n    };\n\n    var isSetTargetAutomationEvent = function isSetTargetAutomationEvent(automationEvent) {\n      return automationEvent.type === 'setTarget';\n    };\n\n    var AutomationEventList =\n    /*#__PURE__*/\n    function () {\n      function AutomationEventList(defaultValue) {\n        _classCallCheck(this, AutomationEventList);\n\n        this._automationEvents = [];\n        this._currenTime = 0;\n        this._defaultValue = defaultValue;\n      }\n\n      _createClass(AutomationEventList, [{\n        key: Symbol.iterator,\n        value: function value() {\n          return this._automationEvents[Symbol.iterator]();\n        }\n      }, {\n        key: \"add\",\n        value: function add(automationEvent) {\n          var eventTime = getEventTime(automationEvent);\n\n          if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n            var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) >= eventTime;\n            });\n\n            var removedAutomationEvent = this._automationEvents[index];\n\n            if (index !== -1) {\n              this._automationEvents = this._automationEvents.slice(0, index);\n            }\n\n            if (isCancelAndHoldAutomationEvent(automationEvent)) {\n              var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n              if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n                if (isSetTargetAutomationEvent(lastAutomationEvent)) {\n                  throw new Error('The internal list is malformed.');\n                }\n\n                var startTime = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);\n                var startValue = isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;\n                var value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n                var truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n\n                this._automationEvents.push(truncatedAutomationEvent);\n              }\n\n              if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n              }\n\n              if (lastAutomationEvent !== undefined && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {\n                this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(new Float32Array([6, 7]), lastAutomationEvent.startTime, eventTime - lastAutomationEvent.startTime);\n              }\n            }\n          } else {\n            var _index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n              return getEventTime(currentAutomationEvent) > eventTime;\n            });\n\n            var previousAutomationEvent = _index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[_index - 1];\n\n            if (previousAutomationEvent !== undefined && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {\n              return false;\n            }\n\n            var persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;\n\n            if (_index === -1) {\n              this._automationEvents.push(persistentAutomationEvent);\n            } else {\n              if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[_index])) {\n                return false;\n              }\n\n              this._automationEvents.splice(_index, 0, persistentAutomationEvent);\n            }\n          }\n\n          return true;\n        }\n      }, {\n        key: \"flush\",\n        value: function flush(time) {\n          var index = this._automationEvents.findIndex(function (currentAutomationEvent) {\n            return getEventTime(currentAutomationEvent) > time;\n          });\n\n          if (index > 1) {\n            var remainingAutomationEvents = this._automationEvents.slice(index - 1);\n\n            var firstRemainingAutomationEvent = remainingAutomationEvents[0];\n\n            if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n              remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));\n            }\n\n            this._automationEvents = remainingAutomationEvents;\n          }\n        }\n      }, {\n        key: \"getValue\",\n        value: function getValue(time) {\n          if (this._automationEvents.length === 0) {\n            return this._defaultValue;\n          }\n\n          var lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n          var index = this._automationEvents.findIndex(function (automationEvent) {\n            return getEventTime(automationEvent) > time;\n          });\n\n          var nextAutomationEvent = this._automationEvents[index];\n          var currentAutomationEvent = getEventTime(lastAutomationEvent) <= time ? lastAutomationEvent : this._automationEvents[index - 1];\n\n          if (currentAutomationEvent !== undefined && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time)) {\n            return getTargetValueAtTime(time, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);\n          }\n\n          if (currentAutomationEvent !== undefined && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n\n          if (currentAutomationEvent !== undefined && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time)) {\n            if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n              return getValueCurveValueAtTime(time, currentAutomationEvent);\n            }\n\n            return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n          }\n\n          if (currentAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {\n            return currentAutomationEvent.value;\n          }\n\n          if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n                _getEndTimeAndValueOf2 = _slicedToArray(_getEndTimeAndValueOf, 2),\n                startTime = _getEndTimeAndValueOf2[0],\n                value = _getEndTimeAndValueOf2[1];\n\n            return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n          }\n\n          if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n            var _getEndTimeAndValueOf3 = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, index - 1, currentAutomationEvent, nextAutomationEvent, this._defaultValue),\n                _getEndTimeAndValueOf4 = _slicedToArray(_getEndTimeAndValueOf3, 2),\n                _startTime = _getEndTimeAndValueOf4[0],\n                _value = _getEndTimeAndValueOf4[1];\n\n            return getLinearRampValueAtTime(time, _startTime, _value, nextAutomationEvent);\n          }\n\n          return this._defaultValue;\n        }\n      }]);\n\n      return AutomationEventList;\n    }();\n\n    var createCancelAndHoldAutomationEvent = function createCancelAndHoldAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelAndHold'\n      };\n    };\n\n    var createCancelScheduledValuesAutomationEvent = function createCancelScheduledValuesAutomationEvent(cancelTime) {\n      return {\n        cancelTime: cancelTime,\n        type: 'cancelScheduledValues'\n      };\n    };\n\n    var createExponentialRampToValueAutomationEvent = function createExponentialRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'exponentialRampToValue',\n        value: value\n      };\n    };\n\n    var createLinearRampToValueAutomationEvent = function createLinearRampToValueAutomationEvent(value, endTime) {\n      return {\n        endTime: endTime,\n        type: 'linearRampToValue',\n        value: value\n      };\n    };\n\n    var createSetTargetAutomationEvent = function createSetTargetAutomationEvent(target, startTime, timeConstant) {\n      return {\n        startTime: startTime,\n        target: target,\n        timeConstant: timeConstant,\n        type: 'setTarget'\n      };\n    };\n\n    exports.AutomationEventList = AutomationEventList;\n    exports.createCancelAndHoldAutomationEvent = createCancelAndHoldAutomationEvent;\n    exports.createCancelScheduledValuesAutomationEvent = createCancelScheduledValuesAutomationEvent;\n    exports.createExponentialRampToValueAutomationEvent = createExponentialRampToValueAutomationEvent;\n    exports.createLinearRampToValueAutomationEvent = createLinearRampToValueAutomationEvent;\n    exports.createSetTargetAutomationEvent = createSetTargetAutomationEvent;\n    exports.createSetValueAutomationEvent = createSetValueAutomationEvent;\n    exports.createSetValueCurveAutomationEvent = createSetValueCurveAutomationEvent;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nmodule.exports = _nonIterableRest;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","export const version: string = \"14.4.10\";\n","export const createAbortError = () => {\n    try {\n        return new DOMException('', 'AbortError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 20;\n        err.name = 'AbortError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/abort-error.js.map","export const ACTIVE_AUDIO_NODE_STORE = new WeakSet();\nexport const AUDIO_BUFFER_STORE = new WeakSet();\nexport const AUDIO_NODE_STORE = new WeakMap();\nexport const AUDIO_GRAPHS = new WeakMap();\nexport const AUDIO_PARAM_STORE = new WeakMap();\nexport const AUDIO_PARAM_AUDIO_NODE_STORE = new WeakMap();\nexport const AUXILIARY_GAIN_NODE_STORE = new WeakMap();\nexport const BACKUP_NATIVE_CONTEXT_STORE = new WeakMap();\nexport const CONTEXT_STORE = new WeakMap();\nexport const DETACHED_ARRAY_BUFFERS = new WeakSet();\nexport const EVENT_LISTENERS = new WeakMap();\n// This clunky name is borrowed from the spec. :-)\nexport const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = new WeakMap();\nexport const NODE_TO_PROCESSOR_MAPS = new WeakMap();\nexport const PERIODIC_WAVE_STORE = new WeakSet();\nexport const TEST_RESULTS = new WeakMap();\n//# sourceMappingURL=/build/es2018/globals.js.map","export const createInvalidStateError = () => {\n    try {\n        return new DOMException('', 'InvalidStateError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 11;\n        err.name = 'InvalidStateError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/invalid-state-error.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nimport { CONTEXT_STORE } from '../globals';\nexport const getNativeContext = (context) => {\n    const nativeContext = CONTEXT_STORE.get(context);\n    if (nativeContext === undefined) {\n        throw createInvalidStateError();\n    }\n    return nativeContext;\n};\n//# sourceMappingURL=/build/es2018/helpers/get-native-context.js.map","const handler = {\n    construct() {\n        return handler;\n    }\n};\nexport const isConstructible = (constructible) => {\n    try {\n        const proxy = new Proxy(constructible, handler);\n        new proxy(); // tslint:disable-line:no-unused-expression\n    }\n    catch (_a) {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=/build/es2018/helpers/is-constructible.js.map","/*\n * This massive regex tries to cover all the following cases.\n *\n * import './path';\n * import defaultImport from './path';\n * import { namedImport } from './path';\n * import { namedImport as renamendImport } from './path';\n * import * as namespaceImport from './path';\n * import defaultImport, { namedImport } from './path';\n * import defaultImport, { namedImport as renamendImport } from './path';\n * import defaultImport, * as namespaceImport from './path';\n */\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\nexport const splitImportStatements = (source, url) => {\n    const importStatements = [];\n    let sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n    let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    while (result !== null) {\n        const unresolvedUrl = result[1].slice(1, -1);\n        const importStatementWithResolvedUrl = result[0]\n            .replace(/([\\s]+)?;?$/, '')\n            .replace(unresolvedUrl, (new URL(unresolvedUrl, url)).toString());\n        importStatements.push(importStatementWithResolvedUrl);\n        sourceWithoutImportStatements = sourceWithoutImportStatements\n            .slice(result[0].length)\n            .replace(/^[\\s]+/, '');\n        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    }\n    return [importStatements.join(';'), sourceWithoutImportStatements];\n};\n//# sourceMappingURL=/build/es2018/helpers/split-import-statements.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { evaluateSource } from '../helpers/evaluate-source';\nimport { getNativeContext } from '../helpers/get-native-context';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nconst verifyParameterDescriptors = (parameterDescriptors) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\nconst verifyProcessorCtor = (processorCtor) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n    if (typeof processorCtor.prototype.process !== 'function') {\n        throw new TypeError('The given value for processorCtor should have a callable process() function.');\n    }\n};\nexport const createAddAudioWorkletModule = (createAbortError, createNotSupportedError, exposeCurrentFrameAndCurrentTime, fetchSource, getBackupNativeContext, ongoingRequests, resolvedRequests) => {\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const nativeContext = getNativeContext(context);\n        const absoluteUrl = (new URL(moduleURL, location.href)).toString();\n        // Bug #59: Only Chrome & Opera do implement the audioWorklet property.\n        if (nativeContext.audioWorklet !== undefined) {\n            return fetchSource(moduleURL)\n                .then((source) => {\n                const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                /*\n                 * Bug #86: Chrome Canary does not invoke the process() function if the corresponding AudioWorkletNode has no output.\n                 *\n                 * This is the unminified version of the code used below:\n                 *\n                 * ```js\n                 * `${ importStatements };\n                 * ((registerProcessor) => {${ sourceWithoutImportStatements }\n                 * })((name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                 *\n                 *     constructor (options) {\n                 *         const { hasNoOutput, ...otherParameterData } = options.parameterData;\n                 *\n                 *         if (hasNoOutput === 1) {\n                 *             super({ ...options, numberOfOutputs: 0, outputChannelCount: [ ], parameterData: otherParameterData });\n                 *\n                 *             this._hasNoOutput = true;\n                 *         } else {\n                 *             super(options);\n                 *\n                 *             this._hasNoOutput = false;\n                 *         }\n                 *     }\n                 *\n                 *     process (inputs, outputs, parameters) {\n                 *         return super.process(inputs, (this._hasNoOutput) ? [ ] : outputs, parameters);\n                 *     }\n                 *\n                 * }))`\n                 * ```\n                 */\n                const wrappedSource = `${importStatements};(registerProcessor=>{${sourceWithoutImportStatements}\n})((n,p)=>registerProcessor(n,class extends p{constructor(o){const{hasNoOutput,...q}=o.parameterData;if(hasNoOutput===1){super({...o,numberOfOutputs:0,outputChannelCount:[],parameterData:q});this._h=true}else{super(o);this._h=false}}process(i,o,p){return super.process(i,(this._h)?[]:o,p)}}))`; // tslint:disable-line:max-line-length\n                const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                const url = URL.createObjectURL(blob);\n                const backupNativeContext = getBackupNativeContext(nativeContext);\n                const nativeContextOrBackupNativeContext = (backupNativeContext !== null) ? backupNativeContext : nativeContext;\n                return nativeContextOrBackupNativeContext.audioWorklet\n                    .addModule(url, options)\n                    .then(() => URL.revokeObjectURL(url))\n                    // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                    .catch((err) => {\n                    URL.revokeObjectURL(url);\n                    throw err; // tslint:disable-line:rxjs-throw-error\n                });\n            });\n        }\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n        const promise = fetchSource(moduleURL)\n            .then((source) => {\n            const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n            /*\n             * This is the unminified version of the code used below:\n             *\n             * ```js\n             * ${ importStatements };\n             * ((a, b) => {\n             *     (a[b] = a[b] || [ ]).push(\n             *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n             *             ${ sourceWithoutImportStatements }\n             *         }\n             *     );\n             * })(window, '_AWGS');\n             * ```\n             */\n            // tslint:disable-next-line:max-line-length\n            const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n            // @todo Evaluating the given source code is a possible security problem.\n            return evaluateSource(wrappedSource);\n        })\n            .then(() => {\n            const evaluateAudioWorkletGlobalScope = window._AWGS.pop();\n            if (evaluateAudioWorkletGlobalScope === undefined) {\n                throw new SyntaxError();\n            }\n            exposeCurrentFrameAndCurrentTime(nativeContext, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {\n            }, undefined, (name, processorCtor) => {\n                if (name.trim() === '') {\n                    throw createNotSupportedError();\n                }\n                const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n                if (nodeNameToProcessorConstructorMap !== undefined) {\n                    if (nodeNameToProcessorConstructorMap.has(name)) {\n                        throw createNotSupportedError();\n                    }\n                    verifyProcessorCtor(processorCtor);\n                    verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                    nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                }\n                else {\n                    verifyProcessorCtor(processorCtor);\n                    verifyParameterDescriptors(processorCtor.parameterDescriptors);\n                    NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                }\n            }, nativeContext.sampleRate, undefined, undefined));\n        })\n            .catch((err) => {\n            if (err.name === 'SyntaxError') {\n                throw createAbortError();\n            }\n            throw err; // tslint:disable-line:rxjs-throw-error\n        });\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        }\n        else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n        promise\n            .then(() => {\n            const rslvdRqstsFCntxt = resolvedRequests.get(context);\n            if (rslvdRqstsFCntxt === undefined) {\n                resolvedRequests.set(context, new Set([moduleURL]));\n            }\n            else {\n                rslvdRqstsFCntxt.add(moduleURL);\n            }\n        })\n            .catch(() => { }) // tslint:disable-line:no-empty\n            // @todo Use finally when it becomes available in all supported browsers.\n            .then(() => {\n            const ngngRqstsFCntxt = ongoingRequests.get(context);\n            if (ngngRqstsFCntxt !== undefined) {\n                ngngRqstsFCntxt.delete(moduleURL);\n            }\n        });\n        return promise;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/add-audio-worklet-module.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    fftSize: 2048,\n    maxDecibels: -30,\n    minDecibels: -100,\n    smoothingTimeConstant: 0.8\n};\nexport const createAnalyserNodeConstructor = (createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class AnalyserNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n            const analyserNodeRenderer = ((isNativeOfflineAudioContext(nativeContext))\n                ? createAnalyserNodeRenderer()\n                : null);\n            super(context, 'passive', nativeAnalyserNode, analyserNodeRenderer);\n            this._nativeAnalyserNode = nativeAnalyserNode;\n        }\n        get fftSize() {\n            return this._nativeAnalyserNode.fftSize;\n        }\n        set fftSize(value) {\n            this._nativeAnalyserNode.fftSize = value;\n        }\n        get frequencyBinCount() {\n            return this._nativeAnalyserNode.frequencyBinCount;\n        }\n        get maxDecibels() {\n            return this._nativeAnalyserNode.maxDecibels;\n        }\n        set maxDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const maxDecibels = this._nativeAnalyserNode.maxDecibels;\n            this._nativeAnalyserNode.maxDecibels = value;\n            if (!(value > this._nativeAnalyserNode.minDecibels)) {\n                this._nativeAnalyserNode.maxDecibels = maxDecibels;\n                throw createIndexSizeError();\n            }\n        }\n        get minDecibels() {\n            return this._nativeAnalyserNode.minDecibels;\n        }\n        set minDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const minDecibels = this._nativeAnalyserNode.minDecibels;\n            this._nativeAnalyserNode.minDecibels = value;\n            if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n                this._nativeAnalyserNode.minDecibels = minDecibels;\n                throw createIndexSizeError();\n            }\n        }\n        get smoothingTimeConstant() {\n            return this._nativeAnalyserNode.smoothingTimeConstant;\n        }\n        set smoothingTimeConstant(value) {\n            this._nativeAnalyserNode.smoothingTimeConstant = value;\n        }\n        getByteFrequencyData(array) {\n            this._nativeAnalyserNode.getByteFrequencyData(array);\n        }\n        getByteTimeDomainData(array) {\n            this._nativeAnalyserNode.getByteTimeDomainData(array);\n        }\n        getFloatFrequencyData(array) {\n            this._nativeAnalyserNode.getFloatFrequencyData(array);\n        }\n        getFloatTimeDomainData(array) {\n            this._nativeAnalyserNode.getFloatTimeDomainData(array);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/analyser-node-constructor.js.map","export const getValueForKey = (map, key) => {\n    const value = map.get(key);\n    if (value === undefined) {\n        throw new Error('A value with the given key could not be found.');\n    }\n    return value;\n};\n//# sourceMappingURL=/build/es2018/helpers/get-value-for-key.js.map","import { AUDIO_NODE_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioNode = (audioNode) => {\n    return getValueForKey(AUDIO_NODE_STORE, audioNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-native-audio-node.js.map","export const isOwnedByContext = (nativeAudioNode, nativeContext) => {\n    return nativeAudioNode.context === nativeContext;\n};\n//# sourceMappingURL=/build/es2018/helpers/is-owned-by-context.js.map","import { AUDIO_GRAPHS } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport function getAudioGraph(context) {\n    return getValueForKey(AUDIO_GRAPHS, context);\n}\n//# sourceMappingURL=/build/es2018/helpers/get-audio-graph.js.map","import { getAudioGraph } from './get-audio-graph';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioNodeConnections = (audioNode) => {\n    const audioGraph = getAudioGraph(audioNode.context);\n    return getValueForKey(audioGraph.nodes, audioNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-audio-node-connections.js.map","import { getAudioNodeConnections } from './get-audio-node-connections';\nexport const getAudioNodeRenderer = (audioNode) => {\n    const audioNodeConnections = getAudioNodeConnections(audioNode);\n    if (audioNodeConnections.renderer === null) {\n        throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n    }\n    return audioNodeConnections.renderer;\n};\n//# sourceMappingURL=/build/es2018/helpers/get-audio-node-renderer.js.map","import { getAudioNodeConnections } from './get-audio-node-connections';\nimport { getAudioNodeRenderer } from './get-audio-node-renderer';\nexport const renderInputsOfAudioNode = (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n    const audioNodeConnections = getAudioNodeConnections(audioNode);\n    return Promise\n        .all(audioNodeConnections.activeInputs\n        .map((connections, input) => Array\n        .from(connections)\n        .map(([source, output]) => {\n        return getAudioNodeRenderer(source)\n            .render(source, nativeOfflineAudioContext)\n            .then((node) => node.connect(nativeAudioNode, output, input));\n    }))\n        .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));\n};\n//# sourceMappingURL=/build/es2018/helpers/render-inputs-of-audio-node.js.map","export const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer) => {\n    try {\n        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n    }\n    catch (_a) {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=/build/es2018/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js.map","export const testAudioBufferCopyChannelMethodsSubarraySupport = (nativeAudioBuffer) => {\n    const source = new Float32Array(2);\n    try {\n        /*\n         * Firefox up to version 67 didn't fully support the copyFromChannel() and copyToChannel() methods. Therefore testing one of those\n         * methods is enough to know if the other one it supported as well.\n         */\n        nativeAudioBuffer.copyFromChannel(source, 0, nativeAudioBuffer.length - 1);\n    }\n    catch (_a) {\n        return false;\n    }\n    return true;\n};\n//# sourceMappingURL=/build/es2018/helpers/test-audio-buffer-copy-channel-methods-subarray-support.js.map","export const createIndexSizeError = () => {\n    try {\n        return new DOMException('', 'IndexSizeError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 1;\n        err.name = 'IndexSizeError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/index-size-error.js.map","import { createIndexSizeError } from '../factories/index-size-error';\nexport const wrapAudioBufferGetChannelDataMethod = (audioBuffer) => {\n    audioBuffer.getChannelData = ((getChannelData) => {\n        return (channel) => {\n            try {\n                return getChannelData.call(audioBuffer, channel);\n            }\n            catch (err) {\n                if (err.code === 12) {\n                    throw createIndexSizeError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            }\n        };\n    })(audioBuffer.getChannelData);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-buffer-get-channel-data-method.js.map","import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testAudioBufferCopyChannelMethodsSubarraySupport } from '../helpers/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createAudioBufferConstructor = (audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds, wrapAudioBufferCopyChannelMethodsSubarray) => {\n    let nativeOfflineAudioContext = null;\n    return class AudioBuffer {\n        constructor(options) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer = (nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)) ?\n                new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate }) :\n                nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().\n            }\n            else if (!cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, () => testAudioBufferCopyChannelMethodsSubarraySupport(audioBuffer))) {\n                wrapAudioBufferCopyChannelMethodsSubarray(audioBuffer);\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                // Bug #157: No browser does allow the bufferOffset to be out-of-bounds.\n            }\n            else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n            audioBufferStore.add(audioBuffer);\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n        static [Symbol.hasInstance](instance) {\n            return (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype)\n                || (audioBufferStore.has(instance));\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-buffer-constructor.js.map","import { EVENT_LISTENERS } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getEventListenersOfAudioNode = (audioNode) => {\n    return getValueForKey(EVENT_LISTENERS, audioNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-event-listeners-of-audio-node.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const setInternalState = (audioNode, internalState) => {\n    if (internalState === 'active') {\n        if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n            throw new Error('The AudioNode is already stored.');\n        }\n        ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n    }\n    else {\n        if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n            throw new Error('The AudioNode is not stored.');\n        }\n        ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n    }\n    getEventListenersOfAudioNode(audioNode)\n        .forEach((eventListener) => eventListener(internalState));\n};\n//# sourceMappingURL=/build/es2018/helpers/set-internal-state.js.map","export const wrapEventListener = (target, eventListener) => {\n    if (typeof eventListener === 'function') {\n        return (event) => {\n            const descriptor = { value: target };\n            Object.defineProperties(event, {\n                currentTarget: descriptor,\n                target: descriptor\n            });\n            return eventListener.call(target, event);\n        };\n    }\n    return eventListener;\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-event-listener.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { getNativeContext } from '../helpers/get-native-context';\nimport { setInternalState } from '../helpers/set-internal-state';\nimport { wrapEventListener } from '../helpers/wrap-event-listener';\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n};\nexport const createAudioBufferSourceNodeConstructor = (createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class AudioBufferSourceNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = ((isOffline)\n                ? createAudioBufferSourceNodeRenderer()\n                : null);\n            super(context, 'passive', nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = false;\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n        set buffer(value) {\n            // Bug #71: Edge does not allow to set the buffer to null.\n            try {\n                this._nativeAudioBufferSourceNode.buffer = value;\n            }\n            catch (err) {\n                if (value !== null || err.code !== 17) {\n                    throw err; // tslint:disable-line:rxjs-throw-error\n                }\n                // This will modify the buffer in place. Luckily that works in Edge and has the same effect as setting the buffer to null.\n                if (this._nativeAudioBufferSourceNode.buffer !== null) {\n                    const buffer = this._nativeAudioBufferSourceNode.buffer;\n                    const numberOfChannels = buffer.numberOfChannels;\n                    for (let i = 0; i < numberOfChannels; i += 1) {\n                        buffer\n                            .getChannelData(i)\n                            .fill(0);\n                    }\n                    this._isBufferNullified = true;\n                }\n            }\n            // Bug #72: Only Chrome, Edge & Opera do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n                this._isBufferSet = true;\n            }\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = wrapEventListener(this, value);\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n            this._onended = (nativeOnEnded === wrappedListener) ? value : nativeOnEnded;\n        }\n        get loop() {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n        get loopEnd() {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n        get loopStart() {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n        get playbackRate() {\n            return this._playbackRate;\n        }\n        start(when = 0, offset = 0, duration) {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = (duration === undefined) ? [when, offset] : [when, offset, duration];\n            }\n            else {\n                setInternalState(this, 'active');\n                const setInternalStateToInactive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', setInternalStateToInactive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalState(this, 'passive'), 1000);\n                };\n                this._nativeAudioBufferSourceNode.addEventListener('ended', setInternalStateToInactive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeAudioBufferSourceNode.stop(when);\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-buffer-source-node-constructor.js.map","import { AUDIO_PARAM_STORE } from '../globals';\nimport { getValueForKey } from './get-value-for-key';\nexport const getNativeAudioParam = (audioParam) => {\n    return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-native-audio-param.js.map","import { getAudioGraph } from './get-audio-graph';\nimport { getValueForKey } from './get-value-for-key';\nexport function getAudioParamConnections(context, audioParam) {\n    const audioGraph = getAudioGraph(context);\n    return getValueForKey(audioGraph.params, audioParam);\n}\n//# sourceMappingURL=/build/es2018/helpers/get-audio-param-connections.js.map","import { getAudioNodeRenderer } from './get-audio-node-renderer';\nimport { getAudioParamConnections } from './get-audio-param-connections';\nexport const renderInputsOfAudioParam = (context, audioParam, nativeOfflineAudioContext, nativeAudioParam) => {\n    const audioParamConnections = getAudioParamConnections(context, audioParam);\n    return Promise\n        .all(Array\n        .from(audioParamConnections.activeInputs)\n        .map(([source, output]) => {\n        return getAudioNodeRenderer(source)\n            .render(source, nativeOfflineAudioContext)\n            .then((node) => node.connect(nativeAudioParam, output));\n    }));\n};\n//# sourceMappingURL=/build/es2018/helpers/render-inputs-of-audio-param.js.map","import { getNativeAudioParam } from './get-native-audio-param';\nimport { renderInputsOfAudioParam } from './render-inputs-of-audio-param';\nexport const connectAudioParam = (context, nativeOfflineAudioContext, audioParam, nativeAudioParam = getNativeAudioParam(audioParam)) => {\n    return renderInputsOfAudioParam(context, audioParam, nativeOfflineAudioContext, nativeAudioParam);\n};\n//# sourceMappingURL=/build/es2018/helpers/connect-audio-param.js.map","import { getAudioParamRenderer } from './get-audio-param-renderer';\nimport { renderInputsOfAudioParam } from './render-inputs-of-audio-param';\nexport const renderAutomation = (context, nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n    const audioParamRenderer = getAudioParamRenderer(context, audioParam);\n    audioParamRenderer.replay(nativeAudioParam);\n    return renderInputsOfAudioParam(context, audioParam, nativeOfflineAudioContext, nativeAudioParam);\n};\n//# sourceMappingURL=/build/es2018/helpers/render-automation.js.map","import { getAudioParamConnections } from './get-audio-param-connections';\nexport function getAudioParamRenderer(context, audioParam) {\n    const audioParamConnections = getAudioParamConnections(context, audioParam);\n    if (audioParamConnections.renderer === null) {\n        throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n    }\n    return audioParamConnections.renderer;\n}\n//# sourceMappingURL=/build/es2018/helpers/get-audio-param-renderer.js.map","export const isValidLatencyHint = (latencyHint) => {\n    return latencyHint === undefined ||\n        typeof latencyHint === 'number' ||\n        (typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback'));\n};\n//# sourceMappingURL=/build/es2018/helpers/is-valid-latency-hint.js.map","import { wrapEventListener } from './helpers/wrap-event-listener';\nexport class EventTarget {\n    constructor(_nativeEventTarget) {\n        this._nativeEventTarget = _nativeEventTarget;\n        this._listeners = new WeakMap();\n    }\n    addEventListener(type, listener, // @todo EventListenerOrEventListenerObject | null = null,\n    options) {\n        let wrappedEventListener = this._listeners.get(listener);\n        if (wrappedEventListener === undefined) {\n            wrappedEventListener = wrapEventListener(this, listener);\n            if (typeof listener === 'function') {\n                this._listeners.set(listener, wrappedEventListener);\n            }\n        }\n        return this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n    }\n    dispatchEvent(event) {\n        return this._nativeEventTarget.dispatchEvent(event);\n    }\n    removeEventListener(type, listener, // @todo EventListenerOrEventListenerObject | null = null,\n    options) {\n        const wrappedEventListener = this._listeners.get(listener);\n        return this._nativeEventTarget.removeEventListener(type, (wrappedEventListener === undefined) ? null : wrappedEventListener, options);\n    }\n}\n//# sourceMappingURL=/build/es2018/event-target.js.map","export const isAudioNode = (audioNodeOrAudioParam) => {\n    return 'context' in audioNodeOrAudioParam;\n};\n//# sourceMappingURL=/build/es2018/guards/audio-node.js.map","import { isAudioNode } from './audio-node';\nexport const isAudioNodeOutputConnection = (outputConnection) => {\n    return isAudioNode(outputConnection[0]);\n};\n//# sourceMappingURL=/build/es2018/guards/audio-node-output-connection.js.map","export const isAudioWorkletNode = (audioNode) => {\n    return 'port' in audioNode;\n};\n//# sourceMappingURL=/build/es2018/guards/audio-worklet-node.js.map","export const connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    const inputs = nativeDestinationAudioNode.inputs;\n    if (inputs !== undefined) {\n        nativeSourceAudioNode.connect(inputs[input], output, 0);\n        return [inputs[input], output, 0];\n    }\n    nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n    return [nativeDestinationAudioNode, output, input];\n};\n//# sourceMappingURL=/build/es2018/helpers/connect-native-audio-node-to-native-audio-node.js.map","import { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\nexport const deleteEventListenerOfAudioNode = (audioNode, eventListener) => {\n    const eventListeners = getEventListenersOfAudioNode(audioNode);\n    if (!eventListeners.delete(eventListener)) {\n        throw new Error('Missing the expected event listener');\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/delete-event-listeners-of-audio-node.js.map","export const disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {\n    const inputs = nativeDestinationAudioNode.inputs;\n    if (input === undefined || output === undefined) {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode);\n    }\n    else if (inputs !== undefined) {\n        nativeSourceAudioNode.disconnect(inputs[input], output, 0);\n    }\n    else {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/disconnect-native-audio-node-from-native-audio-node.js.map","export const insertElementInSet = (set, element, predicate, ignoreDuplicates) => {\n    for (const lmnt of set) {\n        if (predicate(lmnt)) {\n            if (ignoreDuplicates) {\n                return false;\n            }\n            throw Error('The set contains at least one similar element.');\n        }\n    }\n    set.add(element);\n    return true;\n};\n//# sourceMappingURL=/build/es2018/helpers/insert-element-in-set.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isActiveAudioNode = (audioNode) => {\n    return ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/is-active-audio-node.js.map","import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nexport const isPassiveAudioNode = (audioNode) => {\n    return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/is-passive-audio-node.js.map","export const pickElementFromSet = (set, predicate) => {\n    const matchingElements = Array\n        .from(set)\n        .filter(predicate);\n    if (matchingElements.length > 1) {\n        throw Error('More than one element was found.');\n    }\n    if (matchingElements.length === 0) {\n        throw Error('No element was found.');\n    }\n    const [matchingElement] = matchingElements;\n    set.delete(matchingElement);\n    return matchingElement;\n};\n//# sourceMappingURL=/build/es2018/helpers/pick-element-from-set.js.map","import { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { setInternalState } from './set-internal-state';\n// Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\nexport const setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {\n    if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => (connections.size === 0))) {\n        setInternalState(audioNode, 'passive');\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/set-internal-state-to-passive-when-necessary.js.map","export const testAudioNodeDisconnectMethodSupport = (nativeAudioContext) => {\n    return new Promise((resolve) => {\n        const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1);\n        const dummy = nativeAudioContext.createGain();\n        // Bug #95: Safari does not play one sample buffers.\n        const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n        const channelData = ones.getChannelData(0);\n        channelData[0] = 1;\n        channelData[1] = 1;\n        const source = nativeAudioContext.createBufferSource();\n        source.buffer = ones;\n        source.loop = true;\n        source.connect(analyzer);\n        analyzer.connect(nativeAudioContext.destination);\n        source.connect(dummy);\n        source.disconnect(dummy);\n        analyzer.onaudioprocess = (event) => {\n            const chnnlDt = event.inputBuffer.getChannelData(0);\n            if (Array.prototype.some.call(chnnlDt, (sample) => sample === 1)) {\n                resolve(true);\n            }\n            else {\n                resolve(false);\n            }\n            source.stop();\n            analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n            source.disconnect(analyzer);\n            analyzer.disconnect(nativeAudioContext.destination);\n        };\n        source.start();\n    });\n};\n//# sourceMappingURL=/build/es2018/helpers/test-audio-node-disconnect-method-support.js.map","export const isNativeAudioNode = (nativeAudioNodeOrAudioParam) => {\n    return 'context' in nativeAudioNodeOrAudioParam;\n};\n//# sourceMappingURL=/build/es2018/guards/native-audio-node.js.map","import { EventTarget } from '../event-target';\nimport { ACTIVE_AUDIO_NODE_STORE, AUDIO_NODE_STORE, AUXILIARY_GAIN_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioGraph } from '../helpers/get-audio-graph';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { getNativeContext } from '../helpers/get-native-context';\nimport { getValueForKey } from '../helpers/get-value-for-key';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { pickElementFromSet } from '../helpers/pick-element-from-set';\nimport { setInternalState } from '../helpers/set-internal-state';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nconst addAudioNode = (context, audioNode, audioNoderRender, nativeAudioNode) => {\n    const activeInputs = [];\n    for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n        activeInputs.push(new Set());\n    }\n    const { nodes } = getAudioGraph(context);\n    nodes.set(audioNode, {\n        activeInputs,\n        outputs: new Set(),\n        passiveInputs: new WeakMap(),\n        renderer: audioNoderRender\n    });\n};\nconst addActiveInputConnectionToAudioNode = (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n    insertElementInSet(activeInputs[input], [source, output, eventListener], (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output), ignoreDuplicates);\n};\nconst addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {\n    insertElementInSet(activeInputs, [source, output, eventListener], (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output), ignoreDuplicates);\n};\nconst deleteActiveInputConnectionToAudioNode = (activeInputs, source, output, input) => {\n    return pickElementFromSet(activeInputs[input], (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output));\n};\nconst deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {\n    return pickElementFromSet(activeInputs, (activeInputConnection) => (activeInputConnection[0] === source && activeInputConnection[1] === output));\n};\nconst addPassiveInputConnectionToAudioNode = (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n    const passiveInputConnections = passiveInputs.get(source);\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, input, eventListener]]));\n    }\n    else {\n        insertElementInSet(passiveInputConnections, [output, input, eventListener], (passiveInputConnection) => (passiveInputConnection[0] === output && passiveInputConnection[1] === input), ignoreDuplicates);\n    }\n};\nconst addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {\n    const passiveInputConnections = passiveInputs.get(source);\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, eventListener]]));\n    }\n    else {\n        insertElementInSet(passiveInputConnections, [output, eventListener], (passiveInputConnection) => (passiveInputConnection[0] === output), ignoreDuplicates);\n    }\n};\nconst deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => (passiveInputConnection[0] === output && passiveInputConnection[1] === input));\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\nconst deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => (passiveInputConnection[0] === output));\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n    return matchingConnection;\n};\nconst addConnectionToAudioNodeOfAudioContext = (source, destination, output, input) => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n    const eventListener = ((type) => {\n        const nativeDestinationAudioNode = getNativeAudioNode(destination);\n        const nativeSourceAudioNode = getNativeAudioNode(source);\n        if (type === 'active') {\n            const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n            addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n            connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n            if (isPassiveAudioNode(destination)) {\n                setInternalState(destination, 'active');\n            }\n        }\n        else if (type === 'passive') {\n            const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n            addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n            disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n            if (isActiveAudioNode(destination)) {\n                setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n            }\n        }\n    });\n    if (insertElementInSet(outputs, [destination, output, input], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input), true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n        }\n        else {\n            addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n        }\n    }\n};\nconst addConnectionToAudioNodeOfOfflineAudioContext = (source, destination, output, input) => {\n    const { activeInputs } = getAudioNodeConnections(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    if (insertElementInSet(outputs, [destination, output, input], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input), true)) {\n        addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, null], true);\n    }\n};\nconst addConnectionToAudioParamOfAudioContext = (source, destination, output) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(source.context, destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n    const eventListener = ((type) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n        if (type === 'active') {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n            nativeAudioNode.connect(nativeAudioParam, output);\n        }\n        else if (type === 'passive') {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n            nativeAudioNode.disconnect(nativeAudioParam, output);\n        }\n    });\n    if (insertElementInSet(outputs, [destination, output], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output), true)) {\n        eventListeners.add(eventListener);\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        }\n        else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n    }\n};\nconst addConnectionToAudioParamOfOfflineAudioContext = (source, destination, output) => {\n    const { activeInputs } = getAudioParamConnections(source.context, destination);\n    const { outputs } = getAudioNodeConnections(source);\n    if (insertElementInSet(outputs, [destination, output], (outputConnection) => (outputConnection[0] === destination && outputConnection[1] === output), true)) {\n        addActiveInputConnectionToAudioParam(activeInputs, source, [output, null], true);\n    }\n};\nconst deleteActiveInputConnection = (activeInputConnections, source, output) => {\n    for (const activeInputConnection of activeInputConnections) {\n        if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n            activeInputConnections.delete(activeInputConnection);\n            return activeInputConnection;\n        }\n    }\n    return null;\n};\nconst deleteInputConnectionOfAudioNode = (source, destination, output, input) => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n        return [passiveInputConnection[2], 'passive'];\n    }\n    return [activeInputConnection[2], 'active'];\n};\nconst deleteInputConnectionOfAudioParam = (source, destination, output) => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections(source.context, destination);\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n        return [passiveInputConnection[1], 'passive'];\n    }\n    return [activeInputConnection[2], 'active'];\n};\nconst deleteInputsOfAudioNode = (source, destination, output, input) => {\n    const [listener, internalState] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (internalState === 'active') {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\nconst deleteInputsOfAudioParam = (source, destination, output) => {\n    const [listener, internalState] = deleteInputConnectionOfAudioParam(source, destination, output);\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n        if (internalState === 'active') {\n            getNativeAudioNode(source)\n                .disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\nconst deleteAnyConnection = (source) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, ...outputConnection);\n        }\n    }\n    audioNodeConnectionsOfSource.outputs.clear();\n};\nconst deleteConnectionAtOutput = (source, output) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, ...outputConnection);\n            }\n            else {\n                deleteInputsOfAudioParam(source, ...outputConnection);\n            }\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n};\nconst deleteConnectionToDestination = (source, destination, output, input) => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    return Array\n        .from(audioNodeConnectionsOfSource.outputs)\n        .filter((outputConnection) => (outputConnection[0] === destination\n        && (output === undefined || outputConnection[1] === output)\n        && (input === undefined || outputConnection[2] === input)))\n        .reduce((numberOfDeletedConnections, outputConnection) => {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, ...outputConnection);\n        }\n        else {\n            deleteInputsOfAudioParam(source, ...outputConnection);\n        }\n        audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        return numberOfDeletedConnections + 1;\n    }, 0);\n};\nexport const createAudioNodeConstructor = (cacheTestResult, createIndexSizeError, createInvalidAccessError, createNotSupportedError, detectCycles, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext) => {\n    return class AudioNode extends EventTarget {\n        constructor(context, internalState, nativeAudioNode, audioNodeRenderer) {\n            super(nativeAudioNode);\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n            const nativeContext = getNativeContext(context);\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            // @todo Make sure this is not used with an OfflineAudioContext.\n            if (!isNativeOfflineAudioContext(nativeContext) && true !== cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                return testAudioNodeDisconnectMethodSupport(nativeContext);\n            })) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n            if (internalState === 'active') {\n                ACTIVE_AUDIO_NODE_STORE.add(this);\n            }\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n            addAudioNode(context, this, audioNodeRenderer, nativeAudioNode);\n        }\n        get channelCount() {\n            return this._nativeAudioNode.channelCount;\n        }\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n        get channelInterpretation() {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n        get context() {\n            return this._context;\n        }\n        get numberOfInputs() {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n        get numberOfOutputs() {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n        connect(destination, output = 0, input = 0) {\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n                    if (isOffline || isPassiveAudioNode(this)) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n                    else if (isPassiveAudioNode(destination)) {\n                        setInternalState(destination, 'active');\n                    }\n                    // An AudioWorklet needs a connection because it otherwise may truncate the input array.\n                    // @todo Count the number of connections which depend on this auxiliary GainNode to know when it can be removed again.\n                    if (isAudioWorkletNode(destination)) {\n                        const auxiliaryGainNodes = AUXILIARY_GAIN_NODE_STORE.get(nativeDestinationAudioNode);\n                        if (auxiliaryGainNodes === undefined) {\n                            const nativeGainNode = nativeContext.createGain();\n                            nativeGainNode.connect(connection[0], 0, connection[2]);\n                            AUXILIARY_GAIN_NODE_STORE.set(nativeDestinationAudioNode, new Map([[input, nativeGainNode]]));\n                        }\n                        else if (auxiliaryGainNodes.get(input) === undefined) {\n                            const nativeGainNode = nativeContext.createGain();\n                            nativeGainNode.connect(connection[0], 0, connection[2]);\n                            auxiliaryGainNodes.set(input, nativeGainNode);\n                        }\n                    }\n                }\n                catch (err) {\n                    // Bug #41: Only Chrome, Firefox and Opera throw the correct exception by now.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n                    throw err; // tslint:disable-line:rxjs-throw-error\n                }\n                detectCycles(this, destination);\n                if (isOffline) {\n                    addConnectionToAudioNodeOfOfflineAudioContext(this, destination, output, input);\n                }\n                else {\n                    addConnectionToAudioNodeOfAudioContext(this, destination, output, input);\n                }\n                return destination;\n            }\n            const nativeAudioParam = getNativeAudioParam(destination);\n            /*\n             * Bug #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari.\n             */\n            if (nativeAudioParam.name === 'playbackRate') {\n                throw createNotSupportedError();\n            }\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            }\n            catch (err) {\n                // Bug #58: Only Firefox does throw an InvalidStateError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            }\n            detectCycles(this, destination);\n            if (isOffline) {\n                addConnectionToAudioParamOfOfflineAudioContext(this, destination, output);\n            }\n            else {\n                addConnectionToAudioParamOfAudioContext(this, destination, output);\n            }\n        }\n        disconnect(destinationOrOutput, output, input) {\n            if (destinationOrOutput === undefined) {\n                deleteAnyConnection(this);\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n                deleteConnectionAtOutput(this, destinationOrOutput);\n            }\n            else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n                if (isAudioNode(destinationOrOutput)\n                    && input !== undefined\n                    && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n                if (deleteConnectionToDestination(this, destinationOrOutput, output, input) === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-node-constructor.js.map","export class ReadOnlyMap {\n    constructor(parameters) {\n        this._map = new Map(parameters);\n    }\n    get size() {\n        return this._map.size;\n    }\n    entries() {\n        return this._map.entries();\n    }\n    forEach(callback, thisArg = null) {\n        return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));\n    }\n    get(name) {\n        return this._map.get(name);\n    }\n    has(name) {\n        return this._map.has(name);\n    }\n    keys() {\n        return this._map.keys();\n    }\n    values() {\n        return this._map.values();\n    }\n}\n//# sourceMappingURL=/build/es2018/read-only-map.js.map","import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { getNativeContext } from '../helpers/get-native-context';\nimport { wrapEventListener } from '../helpers/wrap-event-listener';\nimport { ReadOnlyMap } from '../read-only-map';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    outputChannelCount: undefined,\n    parameterData: {},\n    processorOptions: {}\n};\nconst createChannelCount = (length) => {\n    const channelCount = [];\n    for (let i = 0; i < length; i += 1) {\n        channelCount.push(1);\n    }\n    return channelCount;\n};\nconst sanitizedOptions = (options) => {\n    return {\n        ...options,\n        outputChannelCount: (options.outputChannelCount !== undefined) ?\n            options.outputChannelCount :\n            (options.numberOfInputs === 1 && options.numberOfOutputs === 1) ?\n                /*\n                 * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                 * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                 * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                 */\n                [options.channelCount] :\n                createChannelCount(options.numberOfOutputs)\n    };\n};\nexport const createAudioWorkletNodeConstructor = (createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, gainNodeConstructor, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, noneAudioDestinationNodeConstructor) => {\n    return class AudioWorkletNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, name, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = (nodeNameToProcessorConstructorMap === undefined) ?\n                undefined :\n                nodeNameToProcessorConstructorMap.get(name);\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n            const audioWorkletNodeRenderer = ((isOffline)\n                ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor)\n                : null);\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, 'active', nativeAudioWorkletNode, audioWorkletNodeRenderer);\n            const parameters = [];\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n                parameters.push([nm, audioParam]);\n            });\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            // Bug #86 & #87: Every browser but Firefox needs to get an unused output which should not be exposed.\n            this._numberOfOutputs = (options.numberOfOutputs === 0) ? 0 : this._nativeAudioWorkletNode.numberOfOutputs;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n            /*\n             * Bug #86 & #87: Every browser but Firefox needs an output to be connected.\n             *\n             * Bug #50: Only Edge does not yet allow to create AudioNodes on a closed AudioContext. Therefore this is currently faked by\n             * using another AudioContext. And that is the reason why this will fail in case of a closed AudioContext.\n             */\n            if (context.state !== 'closed') {\n                const gainNode = new gainNodeConstructor(context, { gain: 0 });\n                try {\n                    this\n                        .connect(gainNode)\n                        .connect(context.destination);\n                }\n                catch (err) {\n                    if (err.name !== 'IndexSizeError') {\n                        throw err; // tslint:disable-line:rxjs-throw-error\n                    }\n                }\n            }\n        }\n        get numberOfOutputs() {\n            return this._numberOfOutputs;\n        }\n        get onprocessorerror() {\n            return this._onprocessorerror;\n        }\n        set onprocessorerror(value) {\n            const wrappedListener = wrapEventListener(this, value);\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n            this._onprocessorerror = (nativeOnProcessorError === wrappedListener) ? value : nativeOnProcessorError;\n        }\n        get parameters() {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return this._nativeAudioWorkletNode.parameters;\n            }\n            return this._parameters;\n        }\n        get port() {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-worklet-node-constructor.js.map","export function copyFromChannel(audioBuffer, \n// @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\nparent, key, channelNumber, bufferOffset) {\n    if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = new Float32Array(128);\n        }\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n        // Bug #5: Safari does not support copyFromChannel().\n    }\n    else {\n        const channelData = audioBuffer.getChannelData(channelNumber);\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        }\n        else {\n            const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n            parent[key].set(slicedInput);\n        }\n    }\n}\n//# sourceMappingURL=/build/es2018/helpers/copy-from-channel.js.map","export const copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {\n    if (typeof audioBuffer.copyToChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n        }\n        // Bug #5: Safari does not support copyToChannel().\n    }\n    else {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer\n                .getChannelData(channelNumber)\n                .set(parent[key], bufferOffset);\n        }\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/copy-to-channel.js.map","export const createNestedArrays = (x, y) => {\n    const arrays = [];\n    for (let i = 0; i < x; i += 1) {\n        const array = [];\n        const length = (typeof y === 'number') ? y : y[i];\n        for (let j = 0; j < length; j += 1) {\n            array.push(new Float32Array(128));\n        }\n        arrays.push(array);\n    }\n    return arrays;\n};\n//# sourceMappingURL=/build/es2018/helpers/create-nested-arrays.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nconst processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor) => {\n    const { length } = renderedBuffer;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer = (numberOfOutputChannels === 0) ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, renderedBuffer.sampleRate);\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n    const parameters = Array\n        .from(proxy.parameters.keys())\n        .reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n    for (let i = 0; i < length; i += 128) {\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.channelCount; k += 1) {\n                copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n            }\n        }\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n        try {\n            const potentiallyEmptyInputs = inputs\n                .map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [new Float32Array(0)];\n                }\n                return input;\n            });\n            const activeSourceFlag = audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters);\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n                    outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                }\n            }\n            if (!activeSourceFlag) {\n                break;\n            }\n        }\n        catch (error) {\n            proxy.dispatchEvent(new ErrorEvent('processorerror', { error }));\n            break;\n        }\n    }\n    return processedBuffer;\n};\nexport const createAudioWorkletNodeRendererFactory = (connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, disconnectMultipleOutputs, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderNativeOfflineAudioContext) => {\n    return (name, options, processorConstructor) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioWorkletNode = getNativeAudioNode(proxy);\n            let nativeOutputNodes = null;\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes = [];\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: options.outputChannelCount[i]\n                    }));\n                }\n                // Bug #87: Expose at least one output to make this node connectable.\n                const outputAudioNodes = (options.numberOfOutputs === 0) ?\n                    [outputChannelSplitterNode] :\n                    outputChannelMergerNodes;\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputAudioNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputAudioNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            }\n            else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, (nativeOutputNodes === null) ? nativeAudioWorkletNode : nativeOutputNodes);\n            if (nativeOutputNodes !== null) {\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n                if (processorConstructor === undefined) {\n                    throw new Error('Missing the processor constructor.');\n                }\n                if (nativeOfflineAudioContextConstructor === null) {\n                    throw new Error('Missing the native OfflineAudioContext constructor.');\n                }\n                // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                const numberOfParameters = (processorConstructor.parameterDescriptors === undefined)\n                    ? 0\n                    : processorConstructor.parameterDescriptors.length;\n                const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfInputChannels + numberOfParameters, \n                // Ceil the length to the next full render quantum.\n                // Bug #17: Safari does not yet expose the length.\n                Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                const gainNodes = [];\n                const inputChannelSplitterNodes = [];\n                for (let i = 0; i < options.numberOfInputs; i += 1) {\n                    gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                        channelCount: options.channelCount,\n                        channelCountMode: options.channelCountMode,\n                        channelInterpretation: options.channelInterpretation,\n                        gain: 1\n                    }));\n                    inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                        channelCount: options.channelCount,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'discrete',\n                        numberOfOutputs: options.channelCount\n                    }));\n                }\n                const constantSourceNodes = await Promise\n                    .all(Array\n                    .from(proxy.parameters.values())\n                    .map(async (audioParam) => {\n                    const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'discrete',\n                        offset: audioParam.value\n                    });\n                    await renderAutomation(proxy.context, partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n                    return constantSourceNode;\n                }));\n                const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'speakers',\n                    numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                });\n                for (let i = 0; i < options.numberOfInputs; i += 1) {\n                    gainNodes[i].connect(inputChannelSplitterNodes[i]);\n                    for (let j = 0; j < options.channelCount; j += 1) {\n                        inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, (i * options.channelCount) + j);\n                    }\n                }\n                for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                    constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                    constantSourceNode.start(0);\n                }\n                inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                return Promise\n                    .all(gainNodes\n                    .map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode)))\n                    .then(() => renderNativeOfflineAudioContext(partialOfflineAudioContext))\n                    .then(async (renderedBuffer) => {\n                    const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n                    const processedBuffer = await processBuffer(proxy, renderedBuffer, nativeOfflineAudioContext, options, processorConstructor);\n                    if (processedBuffer !== null) {\n                        audioBufferSourceNode.buffer = processedBuffer;\n                        audioBufferSourceNode.start(0);\n                    }\n                    audioBufferSourceNode.connect(outputChannelSplitterNode);\n                    for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                        const outputChannelMergerNode = outputChannelMergerNodes[i];\n                        for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                            outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                        }\n                        outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n                    }\n                    return outputGainNode;\n                });\n            }\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(proxy.context, nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm));\n                }\n            }\n            else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(proxy.context, nativeOfflineAudioContext, audioParam, \n                    // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                    nativeAudioWorkletNode.parameters.get(nm));\n                }\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n            return nativeAudioWorkletNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAudioWorkletNodeOrOutputNodes = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioWorkletNodeOrOutputNodes !== undefined) {\n                    const renderedNativeAudioWorkletNodeOrGainNode = Array.isArray(renderedNativeAudioWorkletNodeOrOutputNodes)\n                        ? renderedNativeAudioWorkletNodeOrOutputNodes[2]\n                        : renderedNativeAudioWorkletNodeOrOutputNodes;\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-worklet-node-renderer-factory.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { getNativeAudioNode } from './get-native-audio-node';\nimport { getValueForKey } from './get-value-for-key';\nexport const getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {\n    const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n    const nativeAudioWorkletNode = getNativeAudioNode(proxy);\n    return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};\n//# sourceMappingURL=/build/es2018/helpers/get-audio-worklet-processor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    Q: 1,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 350,\n    gain: 0,\n    type: 'lowpass'\n};\nexport const createBiquadFilterNodeConstructor = (createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class BiquadFilterNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const biquadFilterNodeRenderer = ((isOffline) ? createBiquadFilterNodeRenderer() : null);\n            super(context, 'passive', nativeBiquadFilterNode, biquadFilterNodeRenderer);\n            // Bug #80: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._Q = createAudioParam(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #78: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeBiquadFilterNode.detune, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #77: Chrome, Edge, Firefox, Opera & Safari do not export the correct values for maxValue and minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeBiquadFilterNode.frequency, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #79: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeBiquadFilterNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n        }\n        get Q() {\n            return this._Q;\n        }\n        get detune() {\n            return this._detune;\n        }\n        get frequency() {\n            return this._frequency;\n        }\n        get gain() {\n            return this._gain;\n        }\n        get type() {\n            return this._nativeBiquadFilterNode.type;\n        }\n        set type(value) {\n            this._nativeBiquadFilterNode.type = value;\n        }\n        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n            // Bug #68: Only Chrome & Opera do throw an error if the parameters differ in their length.\n            if ((frequencyHz.length !== magResponse.length) || (magResponse.length !== phaseResponse.length)) {\n                throw createInvalidAccessError();\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/biquad-filter-node-constructor.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 6\n};\nexport const createChannelMergerNodeConstructor = (createChannelMergerNodeRenderer, createNativeChannelMergerNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class ChannelMergerNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n            const channelMergerNodeRenderer = ((isNativeOfflineAudioContext(nativeContext))\n                ? createChannelMergerNodeRenderer()\n                : null);\n            super(context, 'passive', nativeChannelMergerNode, channelMergerNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/channel-merger-node-constructor.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 6,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete',\n    numberOfOutputs: 6\n};\nconst sanitizedOptions = (options) => {\n    return { ...options, channelCount: options.numberOfOutputs };\n};\nexport const createChannelSplitterNodeConstructor = (createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class ChannelSplitterNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizedOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n            const channelSplitterNodeRenderer = ((isNativeOfflineAudioContext(nativeContext))\n                ? createChannelSplitterNodeRenderer()\n                : null);\n            super(context, 'passive', nativeChannelSplitterNode, channelSplitterNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/channel-splitter-node-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { getNativeContext } from '../helpers/get-native-context';\nimport { setInternalState } from '../helpers/set-internal-state';\nimport { wrapEventListener } from '../helpers/wrap-event-listener';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    offset: 1\n};\nexport const createConstantSourceNodeConstructor = (createAudioParam, createConstantSourceNodeRendererFactory, createNativeConstantSourceNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class ConstantSourceNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const constantSourceNodeRenderer = ((isOffline)\n                ? createConstantSourceNodeRendererFactory()\n                : null);\n            super(context, 'passive', nativeConstantSourceNode, constantSourceNodeRenderer);\n            this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n            this._nativeConstantSourceNode = nativeConstantSourceNode;\n            /*\n             * Bug #62 & #74: Edge & Safari do not support ConstantSourceNodes and do not export the correct values for maxValue and\n             * minValue for GainNodes.\n             */\n            this._offset = createAudioParam(this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._onended = null;\n        }\n        get offset() {\n            return this._offset;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = wrapEventListener(this, value);\n            this._nativeConstantSourceNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeConstantSourceNode.onended;\n            this._onended = (nativeOnEnded === wrappedListener) ? value : nativeOnEnded;\n        }\n        start(when = 0) {\n            this._nativeConstantSourceNode.start(when);\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.start = when;\n            }\n            else {\n                setInternalState(this, 'active');\n                const setInternalStateToInactive = () => {\n                    this._nativeConstantSourceNode.removeEventListener('ended', setInternalStateToInactive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalState(this, 'passive'), 1000);\n                };\n                this._nativeConstantSourceNode.addEventListener('ended', setInternalStateToInactive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeConstantSourceNode.stop(when);\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/constant-source-node-constructor.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    disableNormalization: false\n};\nexport const createConvolverNodeConstructor = (createConvolverNodeRenderer, createNativeConvolverNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class ConvolverNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const convolverNodeRenderer = ((isOffline) ? createConvolverNodeRenderer() : null);\n            super(context, 'passive', nativeConvolverNode, convolverNodeRenderer);\n            this._isBufferNullified = false;\n            this._nativeConvolverNode = nativeConvolverNode;\n        }\n        get buffer() {\n            if (this._isBufferNullified) {\n                return null;\n            }\n            return this._nativeConvolverNode.buffer;\n        }\n        set buffer(value) {\n            this._nativeConvolverNode.buffer = value;\n            // Bug #115: Safari does not allow to set the buffer to null.\n            if (value === null && this._nativeConvolverNode.buffer !== null) {\n                const nativeContext = this._nativeConvolverNode.context;\n                this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n                this._isBufferNullified = true;\n            }\n            else {\n                this._isBufferNullified = false;\n            }\n        }\n        get normalize() {\n            return this._nativeConvolverNode.normalize;\n        }\n        set normalize(value) {\n            this._nativeConvolverNode.normalize = value;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/convolver-node-constructor.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    delayTime: 0,\n    maxDelayTime: 1\n};\nexport const createDelayNodeConstructor = (createAudioParam, createDelayNodeRenderer, createNativeDelayNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class DelayNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const delayNodeRenderer = ((isOffline)\n                ? createDelayNodeRenderer(mergedOptions.maxDelayTime)\n                : null);\n            super(context, 'passive', nativeDelayNode, delayNodeRenderer);\n            // @todo Edge does not export the correct values for maxValue and minValue.\n            this._delayTime = createAudioParam(this, isOffline, nativeDelayNode.delayTime, mergedOptions.maxDelayTime, 0);\n        }\n        get delayTime() {\n            return this._delayTime;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/delay-node-constructor.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nconst getOutputAudioNodeAtIndex = (createIndexSizeError, outputAudioNodes, output) => {\n    const outputAudioNode = outputAudioNodes[output];\n    if (outputAudioNode === undefined) {\n        throw createIndexSizeError();\n    }\n    return outputAudioNode;\n};\nexport const createDisconnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {\n        if (destinationOrOutput === undefined) {\n            return outputAudioNodes\n                .forEach((outputAudioNode) => outputAudioNode.disconnect());\n        }\n        if (typeof destinationOrOutput === 'number') {\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput)\n                .disconnect();\n        }\n        if (isNativeAudioNode(destinationOrOutput)) {\n            if (output === undefined) {\n                return outputAudioNodes\n                    .forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n            }\n            if (input === undefined) {\n                return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output)\n                    .disconnect(destinationOrOutput, 0);\n            }\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output)\n                .disconnect(destinationOrOutput, 0, input);\n        }\n        if (output === undefined) {\n            return outputAudioNodes\n                .forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n        }\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output)\n            .disconnect(destinationOrOutput, 0);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/disconnect-multiple-outputs.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    attack: 0.003,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    knee: 30,\n    ratio: 12,\n    release: 0.25,\n    threshold: -24\n};\nexport const createDynamicsCompressorNodeConstructor = (createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class DynamicsCompressorNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const dynamicsCompressorNodeRenderer = ((isOffline)\n                ? createDynamicsCompressorNodeRenderer()\n                : null);\n            super(context, 'passive', nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);\n            // Bug #110: Edge does not export the correct values for maxValue and minValue.\n            this._attack = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.attack, 1, 0);\n            this._knee = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.knee, 40, 0);\n            this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n            this._ratio = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.ratio, 20, 1);\n            this._release = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.release, 1, 0);\n            this._threshold = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.threshold, 0, -100);\n        }\n        get attack() {\n            return this._attack;\n        }\n        /*\n         * Bug #108: Only Chrome, Firefox and Opera disallow a channelCount of three and above yet which is why the getter and setter needs\n         * to be overwritten here.\n         */\n        get channelCount() {\n            return this._nativeDynamicsCompressorNode.channelCount;\n        }\n        set channelCount(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n            this._nativeDynamicsCompressorNode.channelCount = value;\n            if (value > 2) {\n                this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n                throw createNotSupportedError();\n            }\n        }\n        /*\n         * Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n         * overwritten here.\n         */\n        get channelCountMode() {\n            return this._nativeDynamicsCompressorNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n            this._nativeDynamicsCompressorNode.channelCountMode = value;\n            if (value === 'max') {\n                this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n                throw createNotSupportedError();\n            }\n        }\n        get knee() {\n            return this._knee;\n        }\n        get ratio() {\n            return this._ratio;\n        }\n        get reduction() {\n            // Bug #111: Safari returns an AudioParam instead of a number.\n            if (typeof this._nativeDynamicsCompressorNode.reduction.value === 'number') {\n                return this._nativeDynamicsCompressorNode.reduction.value;\n            }\n            return this._nativeDynamicsCompressorNode.reduction;\n        }\n        get release() {\n            return this._release;\n        }\n        get threshold() {\n            return this._threshold;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/dynamics-compressor-node-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    gain: 1\n};\nexport const createGainNodeConstructor = (createAudioParam, createGainNodeRenderer, createNativeGainNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class GainNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const gainNodeRenderer = ((isOffline) ? createGainNodeRenderer() : null);\n            super(context, 'passive', nativeGainNode, gainNodeRenderer);\n            // Bug #74: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get gain() {\n            return this._gain;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/gain-node-constructor.js.map","export const createInvalidAccessError = () => {\n    try {\n        return new DOMException('', 'InvalidAccessError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 15;\n        err.name = 'InvalidAccessError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/invalid-access-error.js.map","import { getNativeContext } from '../helpers/get-native-context';\nimport { wrapIIRFilterNodeGetFrequencyResponseMethod } from '../helpers/wrap-iir-filter-node-get-frequency-response-method';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers'\n};\nexport const createIIRFilterNodeConstructor = (createNativeIIRFilterNode, createIIRFilterNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class IIRFilterNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeIIRFilterNode = createNativeIIRFilterNode(nativeContext, isOffline ? null : context.baseLatency, mergedOptions);\n            const iirFilterNodeRenderer = ((isOffline)\n                ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward)\n                : null);\n            super(context, 'passive', nativeIIRFilterNode, iirFilterNodeRenderer);\n            // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n            // @todo Write a test which allows other browsers to remain unpatched.\n            wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n            this._nativeIIRFilterNode = nativeIIRFilterNode;\n        }\n        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n            return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/iir-filter-node-constructor.js.map","// This implementation as shamelessly inspired by source code of\n// tslint:disable-next-line:max-line-length\n// {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\nexport const filterBuffer = (feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input, output) => {\n    const inputLength = input.length;\n    let i = bufferIndex;\n    for (let j = 0; j < inputLength; j += 1) {\n        let y = feedforward[0] * input[j];\n        for (let k = 1; k < minLength; k += 1) {\n            const x = (i - k) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n            y += feedforward[k] * xBuffer[x];\n            y -= feedback[k] * yBuffer[x];\n        }\n        for (let k = minLength; k < feedforwardLength; k += 1) {\n            y += feedforward[k] * xBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n        for (let k = minLength; k < feedbackLength; k += 1) {\n            y -= feedback[k] * yBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n        xBuffer[i] = input[j];\n        yBuffer[i] = y;\n        i = (i + 1) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n        output[j] = y;\n    }\n    return i;\n};\n//# sourceMappingURL=/build/es2018/helpers/filter-buffer.js.map","export const testPromiseSupport = (nativeContext) => {\n    // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n    const uint32Array = new Uint32Array([\n        1179011410,\n        40,\n        1163280727,\n        544501094,\n        16,\n        131073,\n        44100,\n        176400,\n        1048580,\n        1635017060,\n        4,\n        0\n    ]);\n    try {\n        // Bug #1: Safari requires a successCallback.\n        const promise = nativeContext.decodeAudioData(uint32Array.buffer, () => {\n            // Ignore the success callback.\n        });\n        if (promise === undefined) {\n            return false;\n        }\n        promise.catch(() => {\n            // Ignore rejected errors.\n        });\n        return true;\n    }\n    catch (_a) {\n        // Ignore errors.\n    }\n    return false;\n};\n//# sourceMappingURL=/build/es2018/helpers/test-promise-support.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createMinimalOfflineAudioContextConstructor = (cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering) => {\n    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(options) {\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return (this._state === null) ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return startRendering(this.destination, this._nativeOfflineAudioContext)\n                .then((audioBuffer) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                return audioBuffer;\n            })\n                // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                .catch((err) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/minimal-offline-audio-context-constructor.js.map","export const assignNativeAudioNodeOption = (nativeAudioNode, options, option) => {\n    const value = options[option];\n    if (value !== undefined && value !== nativeAudioNode[option]) {\n        nativeAudioNode[option] = value;\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/assign-native-audio-node-option.js.map","import { assignNativeAudioNodeOption } from './assign-native-audio-node-option';\nexport const assignNativeAudioNodeOptions = (nativeAudioNode, options) => {\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n};\n//# sourceMappingURL=/build/es2018/helpers/assign-native-audio-node-options.js.map","export const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode) => {\n    return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n};\n//# sourceMappingURL=/build/es2018/helpers/test-analyser-node-get-float-time-domain-data-method-support.js.map","export const assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options, audioParam) => {\n    const value = options[audioParam];\n    if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n        nativeAudioNode[audioParam].value = value;\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/assign-native-audio-node-audio-param-value.js.map","export const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            if ((typeof duration === 'number' && duration < 0) || offset < 0 || when < 0) {\n                throw new RangeError(\"The parameters can't be negative.\");\n            }\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            start.call(nativeAudioScheduledSourceNode, when, offset, duration);\n        };\n    })(nativeAudioScheduledSourceNode.start);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js.map","export const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            if (when < 0) {\n                throw new RangeError(\"The parameter can't be negative.\");\n            }\n            stop.call(nativeAudioScheduledSourceNode, when);\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js.map","export const computeBufferSize = (baseLatency, sampleRate) => {\n    if (baseLatency === null) {\n        return 512;\n    }\n    return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};\n//# sourceMappingURL=/build/es2018/helpers/compute-buffer-size.js.map","import { cloneAudioWorkletNodeOptions } from './clone-audio-worklet-node-options';\nexport const createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {\n    const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n    return new processorConstructor(clonedAudioWorkletNodeOptions);\n};\n//# sourceMappingURL=/build/es2018/helpers/create-audio-worklet-processor-promise.js.map","export const cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    return new Promise((resolve, reject) => {\n        const { port1, port2 } = new MessageChannel();\n        port1.onmessage = ({ data }) => {\n            port1.close();\n            port2.close();\n            resolve(data);\n        };\n        port1.onmessageerror = ({ data }) => {\n            port1.close();\n            port2.close();\n            reject(data);\n        };\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port2.postMessage(audioWorkletNodeOptions);\n    });\n};\n//# sourceMappingURL=/build/es2018/helpers/clone-audio-worklet-node-options.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const interceptConnections = (original, interceptor) => {\n    original.connect = ((destination, \n    // @todo TypeScript can't infer the type for the parameters output and input in this case.\n    output = 0, // tslint:disable-line:no-inferrable-types\n    input = 0 // tslint:disable-line:no-inferrable-types\n    ) => {\n        if (isNativeAudioNode(destination)) {\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            interceptor.connect.call(interceptor, destination, output, input);\n            // Bug #11: Safari does not support chaining yet.\n            return destination;\n        }\n        // @todo TypeScript does still assume that connect() returns void.\n        return interceptor.connect.call(interceptor, destination, output);\n    });\n    original.disconnect = function () {\n        // @todo TypeScript cannot infer all the signatures yet.\n        interceptor.disconnect.apply(interceptor, arguments);\n    };\n    return original;\n};\n//# sourceMappingURL=/build/es2018/helpers/intercept-connections.js.map","import { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { filterBuffer } from '../helpers/filter-buffer';\nimport { interceptConnections } from '../helpers/intercept-connections';\nfunction divide(a, b) {\n    const denominator = (b[0] * b[0]) + (b[1] * b[1]);\n    return [(((a[0] * b[0]) + (a[1] * b[1])) / denominator), (((a[1] * b[0]) - (a[0] * b[1])) / denominator)];\n}\nfunction multiply(a, b) {\n    return [((a[0] * b[0]) - (a[1] * b[1])), ((a[0] * b[1]) + (a[1] * b[0]))];\n}\nfunction evaluatePolynomial(coefficient, z) {\n    let result = [0, 0];\n    for (let i = coefficient.length - 1; i >= 0; i -= 1) {\n        result = multiply(result, z);\n        result[0] += coefficient[i];\n    }\n    return result;\n}\nexport const createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError) => {\n    return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const feedbackLength = feedback.length;\n        const feedforwardLength = feedforward.length;\n        const minLength = Math.min(feedbackLength, feedforwardLength);\n        if (feedback.length === 0 || feedback.length > 20) {\n            throw createNotSupportedError();\n        }\n        if (feedback[0] === 0) {\n            throw createInvalidStateError();\n        }\n        if (feedforward.length === 0 || feedforward.length > 20) {\n            throw createNotSupportedError();\n        }\n        if (feedforward[0] === 0) {\n            throw createInvalidStateError();\n        }\n        if (feedback[0] !== 1) {\n            for (let i = 0; i < feedforwardLength; i += 1) {\n                feedforward[i] /= feedback[0];\n            }\n            for (let i = 1; i < feedbackLength; i += 1) {\n                feedback[i] /= feedback[0];\n            }\n        }\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n        scriptProcessorNode.channelCount = channelCount;\n        scriptProcessorNode.channelCountMode = channelCountMode;\n        scriptProcessorNode.channelInterpretation = channelInterpretation;\n        const bufferLength = 32;\n        const bufferIndexes = [];\n        const xBuffers = [];\n        const yBuffers = [];\n        for (let i = 0; i < channelCount; i += 1) {\n            bufferIndexes.push(0);\n            const xBuffer = new Float32Array(bufferLength);\n            const yBuffer = new Float32Array(bufferLength);\n            // @todo Add a test which checks support for TypedArray.prototype.fill().\n            xBuffer.fill(0);\n            yBuffer.fill(0);\n            xBuffers.push(xBuffer);\n            yBuffers.push(yBuffer);\n        }\n        scriptProcessorNode.onaudioprocess = (event) => {\n            const inputBuffer = event.inputBuffer;\n            const outputBuffer = event.outputBuffer;\n            const numberOfChannels = inputBuffer.numberOfChannels;\n            for (let i = 0; i < numberOfChannels; i += 1) {\n                const input = inputBuffer.getChannelData(i);\n                const output = outputBuffer.getChannelData(i);\n                bufferIndexes[i] = filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffers[i], yBuffers[i], bufferIndexes[i], bufferLength, input, output);\n            }\n        };\n        const nyquist = nativeContext.sampleRate / 2;\n        const nativeIIRFilterNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return scriptProcessorNode.channelCount;\n            },\n            set channelCount(value) {\n                scriptProcessorNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return scriptProcessorNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                scriptProcessorNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return scriptProcessorNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                scriptProcessorNode.channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return [scriptProcessorNode];\n            },\n            get numberOfInputs() {\n                return scriptProcessorNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return scriptProcessorNode.numberOfOutputs;\n            },\n            addEventListener(...args) {\n                // @todo Dissallow adding an audioprocess listener.\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {\n                if ((frequencyHz.length !== magResponse.length) || (magResponse.length !== phaseResponse.length)) {\n                    throw createInvalidAccessError();\n                }\n                const length = frequencyHz.length;\n                for (let i = 0; i < length; i += 1) {\n                    const omega = -Math.PI * (frequencyHz[i] / nyquist);\n                    const z = [Math.cos(omega), Math.sin(omega)];\n                    const numerator = evaluatePolynomial(feedforward, z);\n                    const denominator = evaluatePolynomial(feedback, z);\n                    const response = divide(numerator, denominator);\n                    magResponse[i] = Math.sqrt((response[0] * response[0]) + (response[1] * response[1]));\n                    phaseResponse[i] = Math.atan2(response[1], response[0]);\n                }\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-iir-filter-node-faker-factory.js.map","export const createNotSupportedError = () => {\n    try {\n        return new DOMException('', 'NotSupportedError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 9;\n        err.name = 'NotSupportedError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/not-supported-error.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n};\nexport const createOfflineAudioContextConstructor = (baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering) => {\n    return class OfflineAudioContext extends baseAudioContextConstructor {\n        constructor(a, b, c) {\n            let options;\n            if (typeof a === 'number' && b !== undefined && c !== undefined) {\n                options = { length: b, numberOfChannels: a, sampleRate: c };\n            }\n            else if (typeof a === 'object') {\n                options = a;\n            }\n            else {\n                throw new Error('The given parameters are not valid.');\n            }\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener('statechange', (() => {\n                    let i = 0;\n                    const delayStateChangeEvent = (event) => {\n                        if (this._state === 'running') {\n                            if (i > 0) {\n                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                event.stopImmediatePropagation();\n                                this._waitForThePromiseToSettle(event);\n                            }\n                            else {\n                                i += 1;\n                            }\n                        }\n                    };\n                    return delayStateChangeEvent;\n                })());\n            }\n            super(nativeOfflineAudioContext, numberOfChannels);\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n        get length() {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n            return this._nativeOfflineAudioContext.length;\n        }\n        get state() {\n            return (this._state === null) ? this._nativeOfflineAudioContext.state : this._state;\n        }\n        startRendering() {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n            this._state = 'running';\n            return startRendering(this.destination, this._nativeOfflineAudioContext)\n                .then((audioBuffer) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                return audioBuffer;\n            })\n                // @todo This could be written more elegantly when Promise.finally() becomes avalaible.\n                .catch((err) => {\n                this._state = null;\n                /*\n                 * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n                 * deleteAudioGraph(this, this._nativeOfflineAudioContext);\n                 */\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n        _waitForThePromiseToSettle(event) {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            }\n            else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/offline-audio-context-constructor.js.map","import { getNativeContext } from '../helpers/get-native-context';\nimport { setInternalState } from '../helpers/set-internal-state';\nimport { wrapEventListener } from '../helpers/wrap-event-listener';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 440,\n    type: 'sine'\n};\nexport const createOscillatorNodeConstructor = (createAudioParam, createInvalidStateError, createNativeOscillatorNode, createOscillatorNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class OscillatorNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const oscillatorNodeRenderer = ((isOffline) ? createOscillatorNodeRenderer() : null);\n            const nyquist = context.sampleRate / 2;\n            super(context, 'passive', nativeOscillatorNode, oscillatorNodeRenderer);\n            // Bug #81: Edge, Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);\n            // Bug #76: Edge & Safari do not export the correct values for maxValue and minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n            this._nativeOscillatorNode = nativeOscillatorNode;\n            this._onended = null;\n            this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n            if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n                this._oscillatorNodeRenderer.periodicWave =\n                    mergedOptions.periodicWave;\n            }\n        }\n        get detune() {\n            return this._detune;\n        }\n        get frequency() {\n            return this._frequency;\n        }\n        get onended() {\n            return this._onended;\n        }\n        set onended(value) {\n            const wrappedListener = wrapEventListener(this, value);\n            this._nativeOscillatorNode.onended = wrappedListener;\n            const nativeOnEnded = this._nativeOscillatorNode.onended;\n            this._onended = (nativeOnEnded === wrappedListener) ? value : nativeOnEnded;\n        }\n        get type() {\n            return this._nativeOscillatorNode.type;\n        }\n        set type(value) {\n            this._nativeOscillatorNode.type = value;\n            // Bug #57: Edge will not throw an error when assigning the type to 'custom'. But it still will change the value.\n            if (value === 'custom') {\n                throw createInvalidStateError();\n            }\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = null;\n            }\n        }\n        setPeriodicWave(periodicWave) {\n            this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = periodicWave;\n            }\n        }\n        start(when = 0) {\n            this._nativeOscillatorNode.start(when);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.start = when;\n            }\n            else {\n                setInternalState(this, 'active');\n                const setInternalStateToInactive = () => {\n                    this._nativeOscillatorNode.removeEventListener('ended', setInternalStateToInactive);\n                    // @todo Determine a meaningful delay instead of just using one second.\n                    setTimeout(() => setInternalState(this, 'passive'), 1000);\n                };\n                this._nativeOscillatorNode.addEventListener('ended', setInternalStateToInactive);\n            }\n        }\n        stop(when = 0) {\n            this._nativeOscillatorNode.stop(when);\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/oscillator-node-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    coneInnerAngle: 360,\n    coneOuterAngle: 360,\n    coneOuterGain: 0,\n    distanceModel: 'inverse',\n    maxDistance: 10000,\n    orientationX: 1,\n    orientationY: 0,\n    orientationZ: 0,\n    panningModel: 'equalpower',\n    positionX: 0,\n    positionY: 0,\n    positionZ: 0,\n    refDistance: 1,\n    rolloffFactor: 1\n};\nexport const createPannerNodeConstructor = (createAudioParam, createNativePannerNode, createPannerNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class PannerNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const pannerNodeRenderer = ((isOffline) ? createPannerNodeRenderer() : null);\n            super(context, 'passive', nativePannerNode, pannerNodeRenderer);\n            this._nativePannerNode = nativePannerNode;\n            // Bug #74: Edge & Safari do not export the correct values for maxValue and minValue for GainNodes.\n            this._orientationX = createAudioParam(this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._orientationY = createAudioParam(this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._orientationZ = createAudioParam(this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionX = createAudioParam(this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionY = createAudioParam(this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            this._positionZ = createAudioParam(this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n        get coneInnerAngle() {\n            return this._nativePannerNode.coneInnerAngle;\n        }\n        set coneInnerAngle(value) {\n            this._nativePannerNode.coneInnerAngle = value;\n        }\n        get coneOuterAngle() {\n            return this._nativePannerNode.coneOuterAngle;\n        }\n        set coneOuterAngle(value) {\n            this._nativePannerNode.coneOuterAngle = value;\n        }\n        get coneOuterGain() {\n            return this._nativePannerNode.coneOuterGain;\n        }\n        set coneOuterGain(value) {\n            this._nativePannerNode.coneOuterGain = value;\n        }\n        get distanceModel() {\n            return this._nativePannerNode.distanceModel;\n        }\n        set distanceModel(value) {\n            this._nativePannerNode.distanceModel = value;\n        }\n        get maxDistance() {\n            return this._nativePannerNode.maxDistance;\n        }\n        set maxDistance(value) {\n            this._nativePannerNode.maxDistance = value;\n        }\n        get orientationX() {\n            return this._orientationX;\n        }\n        get orientationY() {\n            return this._orientationY;\n        }\n        get orientationZ() {\n            return this._orientationZ;\n        }\n        get panningModel() {\n            return this._nativePannerNode.panningModel;\n        }\n        set panningModel(value) {\n            this._nativePannerNode.panningModel = value;\n        }\n        get positionX() {\n            return this._positionX;\n        }\n        get positionY() {\n            return this._positionY;\n        }\n        get positionZ() {\n            return this._positionZ;\n        }\n        get refDistance() {\n            return this._nativePannerNode.refDistance;\n        }\n        set refDistance(value) {\n            this._nativePannerNode.refDistance = value;\n        }\n        get rolloffFactor() {\n            return this._nativePannerNode.rolloffFactor;\n        }\n        set rolloffFactor(value) {\n            this._nativePannerNode.rolloffFactor = value;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/panner-node-constructor.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    disableNormalization: false\n};\nexport const createPeriodicWaveConstructor = (createNativePeriodicWave, periodicWaveStore) => {\n    return class PeriodicWave {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);\n            periodicWaveStore.add(periodicWave);\n            // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n            return periodicWave;\n        }\n        static [Symbol.hasInstance](instance) {\n            return (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype)\n                || (periodicWaveStore.has(instance));\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/periodic-wave-constructor.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    /*\n     * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n     * behavior.\n     */\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    pan: 0\n};\nexport const createStereoPannerNodeConstructor = (createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class StereoPannerNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const stereoPannerNodeRenderer = ((isOffline) ? createStereoPannerNodeRenderer() : null);\n            super(context, 'passive', nativeStereoPannerNode, stereoPannerNodeRenderer);\n            // Bug #106: Edge does not export a maxValue and minValue property.\n            this._pan = createAudioParam(this, isOffline, nativeStereoPannerNode.pan, 1, -1);\n        }\n        get pan() {\n            return this._pan;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/stereo-panner-node-constructor.js.map","export const createUnknownError = () => {\n    try {\n        return new DOMException('', 'UnknownError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.name = 'UnknownError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/unknown-error.js.map","import { getNativeContext } from '../helpers/get-native-context';\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    curve: null,\n    oversample: 'none'\n};\nexport const createWaveShaperNodeConstructor = (createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class WaveShaperNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options = DEFAULT_OPTIONS) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const waveShaperNodeRenderer = ((isOffline) ? createWaveShaperNodeRenderer() : null);\n            super(context, 'passive', nativeWaveShaperNode, waveShaperNodeRenderer);\n            this._isCurveNullified = false;\n            this._nativeWaveShaperNode = nativeWaveShaperNode;\n        }\n        get curve() {\n            if (this._isCurveNullified) {\n                return null;\n            }\n            return this._nativeWaveShaperNode.curve;\n        }\n        set curve(value) {\n            // Bug #103: Safari does not allow to set the curve to null.\n            if (value === null) {\n                this._isCurveNullified = true;\n                this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n            }\n            else {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n                if (value.length < 2) {\n                    throw createInvalidStateError();\n                }\n                this._isCurveNullified = false;\n                this._nativeWaveShaperNode.curve = value;\n            }\n        }\n        get oversample() {\n            return this._nativeWaveShaperNode.oversample;\n        }\n        set oversample(value) {\n            this._nativeWaveShaperNode.oversample = value;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wave-shaper-node-constructor.js.map","import { createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent } from 'automation-events';\nimport { createAbortError } from './factories/abort-error';\nimport { createAddAudioWorkletModule } from './factories/add-audio-worklet-module';\nimport { createAnalyserNodeConstructor } from './factories/analyser-node-constructor';\nimport { createAnalyserNodeRendererFactory } from './factories/analyser-node-renderer-factory';\nimport { createAudioBufferConstructor } from './factories/audio-buffer-constructor';\nimport { createAudioBufferSourceNodeConstructor } from './factories/audio-buffer-source-node-constructor';\nimport { createAudioBufferSourceNodeRendererFactory } from './factories/audio-buffer-source-node-renderer-factory';\nimport { createAudioContextConstructor } from './factories/audio-context-constructor';\nimport { createAudioDestinationNodeConstructor } from './factories/audio-destination-node-constructor';\nimport { createAudioDestinationNodeRenderer } from './factories/audio-destination-node-renderer-factory';\nimport { createAudioListenerFactory } from './factories/audio-listener-factory';\nimport { createAudioNodeConstructor } from './factories/audio-node-constructor';\nimport { createAudioParamFactory } from './factories/audio-param-factory';\nimport { createAudioParamRenderer } from './factories/audio-param-renderer';\nimport { createAudioWorkletNodeConstructor } from './factories/audio-worklet-node-constructor';\nimport { createAudioWorkletNodeRendererFactory } from './factories/audio-worklet-node-renderer-factory';\nimport { createBaseAudioContextConstructor } from './factories/base-audio-context-constructor';\nimport { createBiquadFilterNodeConstructor } from './factories/biquad-filter-node-constructor';\nimport { createBiquadFilterNodeRendererFactory } from './factories/biquad-filter-node-renderer-factory';\nimport { createCacheTestResult } from './factories/cache-test-result';\nimport { createChannelMergerNodeConstructor } from './factories/channel-merger-node-constructor';\nimport { createChannelMergerNodeRendererFactory } from './factories/channel-merger-node-renderer-factory';\nimport { createChannelSplitterNodeConstructor } from './factories/channel-splitter-node-constructor';\nimport { createChannelSplitterNodeRendererFactory } from './factories/channel-splitter-node-renderer-factory';\nimport { createConnectMultipleOutputs } from './factories/connect-multiple-outputs';\nimport { createConstantSourceNodeConstructor } from './factories/constant-source-node-constructor';\nimport { createConstantSourceNodeRendererFactory } from './factories/constant-source-node-renderer-factory';\nimport { createConvertNumberToUnsignedLong } from './factories/convert-number-to-unsigned-long';\nimport { createConvolverNodeConstructor } from './factories/convolver-node-constructor';\nimport { createConvolverNodeRendererFactory } from './factories/convolver-node-renderer-factory';\nimport { createCreateNativeOfflineAudioContext } from './factories/create-native-offline-audio-context';\nimport { createDataCloneError } from './factories/data-clone-error';\nimport { createDecodeAudioData } from './factories/decode-audio-data';\nimport { createDelayNodeConstructor } from './factories/delay-node-constructor';\nimport { createDelayNodeRendererFactory } from './factories/delay-node-renderer-factory';\nimport { createDetectCycles } from './factories/detect-cycles';\nimport { createDisconnectMultipleOutputs } from './factories/disconnect-multiple-outputs';\nimport { createDynamicsCompressorNodeConstructor } from './factories/dynamics-compressor-node-constructor';\nimport { createDynamicsCompressorNodeRendererFactory } from './factories/dynamics-compressor-node-renderer-factory';\nimport { createEncodingError } from './factories/encoding-error';\nimport { createExposeCurrentFrameAndCurrentTime } from './factories/expose-current-frame-and-current-time';\nimport { createFetchSource } from './factories/fetch-source';\nimport { createGainNodeConstructor } from './factories/gain-node-constructor';\nimport { createGainNodeRendererFactory } from './factories/gain-node-renderer-factory';\nimport { createGetBackupNativeContext } from './factories/get-backup-native-context';\nimport { createIIRFilterNodeConstructor } from './factories/iir-filter-node-constructor';\nimport { createIIRFilterNodeRendererFactory } from './factories/iir-filter-node-renderer-factory';\nimport { createIndexSizeError } from './factories/index-size-error';\nimport { createInvalidAccessError } from './factories/invalid-access-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsAnyAudioContext } from './factories/is-any-audio-context';\nimport { createIsAnyAudioNode } from './factories/is-any-audio-node';\nimport { createIsAnyAudioParam } from './factories/is-any-audio-param';\nimport { createIsAnyOfflineAudioContext } from './factories/is-any-offline-audio-context';\nimport { createIsNativeAudioContext } from './factories/is-native-audio-context';\nimport { createIsNativeAudioNode } from './factories/is-native-audio-node';\nimport { createIsNativeAudioParam } from './factories/is-native-audio-param';\nimport { createIsNativeContext } from './factories/is-native-context';\nimport { createIsNativeOfflineAudioContext } from './factories/is-native-offline-audio-context';\nimport { createIsSecureContext } from './factories/is-secure-context';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaElementAudioSourceNodeConstructor } from './factories/media-element-audio-source-node-constructor';\nimport { createMediaStreamAudioSourceNodeConstructor } from './factories/media-stream-audio-source-node-constructor';\nimport { createMediaStreamTrackAudioSourceNodeConstructor } from './factories/media-stream-track-audio-source-node-constructor';\nimport { createMinimalAudioContextConstructor } from './factories/minimal-audio-context-constructor';\nimport { createMinimalBaseAudioContextConstructor } from './factories/minimal-base-audio-context-constructor';\nimport { createMinimalOfflineAudioContextConstructor } from './factories/minimal-offline-audio-context-constructor';\nimport { createNativeAnalyserNodeFactory } from './factories/native-analyser-node-factory';\nimport { createNativeAudioBufferConstructor } from './factories/native-audio-buffer-constructor';\nimport { createNativeAudioBufferSourceNodeFactory } from './factories/native-audio-buffer-source-node-factory';\nimport { createNativeAudioContextConstructor } from './factories/native-audio-context-constructor';\nimport { createNativeAudioDestinationNode } from './factories/native-audio-destination-node';\nimport { createNativeAudioNodeFactory } from './factories/native-audio-node-factory';\nimport { createNativeAudioWorkletNodeConstructor } from './factories/native-audio-worklet-node-constructor';\nimport { createNativeAudioWorkletNodeFactory } from './factories/native-audio-worklet-node-factory';\nimport { createNativeAudioWorkletNodeFakerFactory } from './factories/native-audio-worklet-node-faker-factory';\nimport { createNativeBiquadFilterNodeFactory } from './factories/native-biquad-filter-node-factory';\nimport { createNativeChannelMergerNodeFactory } from './factories/native-channel-merger-node-factory';\nimport { createNativeChannelSplitterNodeFactory } from './factories/native-channel-splitter-node-factory';\nimport { createNativeConstantSourceNodeFactory } from './factories/native-constant-source-node-factory';\nimport { createNativeConstantSourceNodeFakerFactory } from './factories/native-constant-source-node-faker-factory';\nimport { createNativeConvolverNodeFactory } from './factories/native-convolver-node-factory';\nimport { createNativeDelayNodeFactory } from './factories/native-delay-node-factory';\nimport { createNativeDynamicsCompressorNodeFactory } from './factories/native-dynamics-compressor-node-factory';\nimport { createNativeGainNodeFactory } from './factories/native-gain-node-factory';\nimport { createNativeIIRFilterNodeFactory } from './factories/native-iir-filter-node-factory';\nimport { createNativeIIRFilterNodeFakerFactory } from './factories/native-iir-filter-node-faker-factory';\nimport { createNativeMediaElementAudioSourceNodeFactory } from './factories/native-media-element-audio-source-node-factory';\nimport { createNativeMediaStreamAudioSourceNodeFactory } from './factories/native-media-stream-audio-source-node-factory';\nimport { createNativeMediaStreamTrackAudioSourceNodeFactory } from './factories/native-media-stream-track-audio-source-node-factory';\nimport { createNativeOfflineAudioContextConstructor } from './factories/native-offline-audio-context-constructor';\nimport { createNativeOscillatorNodeFactory } from './factories/native-oscillator-node-factory';\nimport { createNativePannerNodeFactory } from './factories/native-panner-node-factory';\nimport { createNativePannerNodeFakerFactory } from './factories/native-panner-node-faker-factory';\nimport { createNativePeriodicWaveFactory } from './factories/native-periodic-wave-factory';\nimport { createNativeScriptProcessorNodeFactory } from './factories/native-script-processor-node-factory';\nimport { createNativeStereoPannerNodeFactory } from './factories/native-stereo-panner-node-factory';\nimport { createNativeStereoPannerNodeFakerFactory } from './factories/native-stereo-panner-node-faker-factory';\nimport { createNativeWaveShaperNodeFactory } from './factories/native-wave-shaper-node-factory';\nimport { createNativeWaveShaperNodeFakerFactory } from './factories/native-wave-shaper-node-faker-factory';\nimport { createNoneAudioDestinationNodeConstructor } from './factories/none-audio-destination-node-constructor';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createOfflineAudioContextConstructor } from './factories/offline-audio-context-constructor';\nimport { createOscillatorNodeConstructor } from './factories/oscillator-node-constructor';\nimport { createOscillatorNodeRendererFactory } from './factories/oscillator-node-renderer-factory';\nimport { createPannerNodeConstructor } from './factories/panner-node-constructor';\nimport { createPannerNodeRendererFactory } from './factories/panner-node-renderer-factory';\nimport { createPeriodicWaveConstructor } from './factories/periodic-wave-constructor';\nimport { createRenderNativeOfflineAudioContext } from './factories/render-native-offline-audio-context';\nimport { createStartRendering } from './factories/start-rendering';\nimport { createStereoPannerNodeConstructor } from './factories/stereo-panner-node-constructor';\nimport { createStereoPannerNodeRendererFactory } from './factories/stereo-panner-node-renderer-factory';\nimport { createTestAudioBufferConstructorSupport } from './factories/test-audio-buffer-constructor-support';\nimport { createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport } from './factories/test-audio-buffer-source-node-start-method-consecutive-calls-support';\nimport { createTestAudioBufferSourceNodeStartMethodDurationParameterSupport } from './factories/test-audio-buffer-source-node-start-method-duration-parameter-support';\nimport { createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport } from './factories/test-audio-buffer-source-node-start-method-offset-clamping-support';\nimport { createTestAudioContextCloseMethodSupport } from './factories/test-audio-context-close-method-support';\nimport { createTestAudioContextDecodeAudioDataMethodTypeErrorSupport } from './factories/test-audio-context-decode-audio-data-method-type-error-support';\nimport { createTestAudioContextOptionsSupport } from './factories/test-audio-context-options-support';\nimport { createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport } from './factories/test-audio-scheduled-source-node-start-method-negative-parameters-support';\nimport { createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport } from './factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support';\nimport { createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport } from './factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support';\nimport { createTestAudioWorkletProcessorNoOutputsSupport } from './factories/test-audio-worklet-processor-no-outputs-support';\nimport { createTestChannelSplitterNodeChannelCountSupport } from './factories/test-channel-splitter-node-channel-count-support';\nimport { createTestConstantSourceNodeAccurateSchedulingSupport } from './factories/test-constant-source-node-accurate-scheduling-support';\nimport { createTestConvolverNodeBufferReassignabilitySupport } from './factories/test-convolver-node-buffer-reassignability-support';\nimport { createTestIsSecureContextSupport } from './factories/test-is-secure-context-support';\nimport { createTestOfflineAudioContextCurrentTimeSupport } from './factories/test-offline-audio-context-current-time-support';\nimport { createTestStereoPannerNodeDefaultValueSupport } from './factories/test-stereo-panner-node-default-value-support';\nimport { createUnknownError } from './factories/unknown-error';\nimport { createWaveShaperNodeConstructor } from './factories/wave-shaper-node-constructor';\nimport { createWaveShaperNodeRendererFactory } from './factories/wave-shaper-node-renderer-factory';\nimport { createWindow } from './factories/window';\nimport { createWrapAudioBufferCopyChannelMethods } from './factories/wrap-audio-buffer-copy-channel-methods';\nimport { createWrapAudioBufferCopyChannelMethodsOutOfBounds } from './factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds';\nimport { createWrapAudioBufferCopyChannelMethodsSubarray } from './factories/wrap-audio-buffer-copy-channel-methods-subarray';\nimport { createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls } from './factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls';\nimport { createWrapChannelMergerNode } from './factories/wrap-channel-merger-node';\nimport { AUDIO_BUFFER_STORE, AUDIO_NODE_STORE, AUDIO_PARAM_AUDIO_NODE_STORE, AUDIO_PARAM_STORE, CONTEXT_STORE, PERIODIC_WAVE_STORE } from './globals';\nimport { getAudioNodeConnections } from './helpers/get-audio-node-connections';\nimport { getValueForKey } from './helpers/get-value-for-key';\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from './helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testAudioBufferCopyChannelMethodsSubarraySupport } from './helpers/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { testPromiseSupport } from './helpers/test-promise-support';\nimport { testTransferablesSupport } from './helpers/test-transferables-support';\nimport { wrapAudioBufferSourceNodeStartMethodOffsetClamping } from './helpers/wrap-audio-buffer-source-node-start-method-offset-clamping';\nconst cacheTestResult = createCacheTestResult(new Map());\nconst window = createWindow();\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window);\nconst getBackupNativeContext = createGetBackupNativeContext(isNativeOfflineAudioContext, nativeAudioContextConstructor, nativeOfflineAudioContextConstructor);\nconst createNativeAudioNode = createNativeAudioNodeFactory(getBackupNativeContext);\nconst createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError, createNativeAudioNode);\nconst createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode);\nconst isNativeAudioNode = createIsNativeAudioNode(window);\nconst isNativeAudioParam = createIsNativeAudioParam(window);\nconst audioNodeConstructor = createAudioNodeConstructor(cacheTestResult, createIndexSizeError, createInvalidAccessError, createNotSupportedError, createDetectCycles(AUDIO_PARAM_AUDIO_NODE_STORE, createNotSupportedError, getAudioNodeConnections, getValueForKey), isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext);\nconst noneAudioDestinationNodeConstructor = createNoneAudioDestinationNodeConstructor(audioNodeConstructor);\nconst analyserNodeConstructor = createAnalyserNodeConstructor(createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nexport { analyserNodeConstructor as AnalyserNode };\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst wrapAudioBufferCopyChannelMethodsSubarray = createWrapAudioBufferCopyChannelMethodsSubarray(convertNumberToUnsignedLong, createIndexSizeError);\nconst audioBufferConstructor = createAudioBufferConstructor(AUDIO_BUFFER_STORE, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds, wrapAudioBufferCopyChannelMethodsSubarray);\nexport { audioBufferConstructor as AudioBuffer };\nconst testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport(createNativeAudioNode);\nconst testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(createNativeAudioNode);\nconst testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport(createNativeAudioNode);\nconst wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(createNativeAudioNode);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(cacheTestResult, createNativeAudioNode, createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(createNativeAudioNode), createTestAudioBufferSourceNodeStartMethodDurationParameterSupport(nativeOfflineAudioContextConstructor), createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport(createNativeAudioNode), testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(createNativeAudioBufferSourceNode);\nconst createAudioParam = createAudioParamFactory(createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor);\nconst audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nexport { audioBufferSourceNodeConstructor as AudioBufferSourceNode };\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, isNativeOfflineAudioContext);\nconst createNativeBiquadFilterNode = createNativeBiquadFilterNodeFactory(createNativeAudioNode);\nconst createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(createNativeBiquadFilterNode);\nconst biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, createNativeAudioNode);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(createNativeAudioNode, wrapChannelMergerNode);\nconst createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode);\nconst channelMergerNodeConstructor = createChannelMergerNodeConstructor(createChannelMergerNodeRenderer, createNativeChannelMergerNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeChannelSplitterNode = createNativeChannelSplitterNodeFactory(createNativeAudioNode);\nconst createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode);\nconst channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeGainNode = createNativeGainNodeFactory(createNativeAudioNode);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(createNativeAudioBufferSourceNode, createNativeGainNode);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(cacheTestResult, createNativeAudioNode, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);\nconst createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(createNativeConstantSourceNode);\nconst constantSourceNodeConstructor = createConstantSourceNodeConstructor(createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeConvolverNode = createNativeConvolverNodeFactory(createNativeAudioNode, createNotSupportedError);\nconst createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode);\nconst convolverNodeConstructor = createConvolverNodeConstructor(createConvolverNodeRenderer, createNativeConvolverNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeDelayNode = createNativeDelayNodeFactory(createNativeAudioNode);\nconst createDelayNodeRenderer = createDelayNodeRendererFactory(createNativeDelayNode);\nconst delayNodeConstructor = createDelayNodeConstructor(createAudioParam, createDelayNodeRenderer, createNativeDelayNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNativeAudioNode, createNotSupportedError);\nconst createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(createNativeDynamicsCompressorNode);\nconst dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createGainNodeRenderer = createGainNodeRendererFactory(createNativeGainNode);\nconst gainNodeConstructor = createGainNodeConstructor(createAudioParam, createGainNodeRenderer, createNativeGainNode, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeScriptProcessorNode = createNativeScriptProcessorNodeFactory(createNativeAudioNode);\nconst createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError, createNativeScriptProcessorNode, createNotSupportedError);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));\nconst createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, createNativeAudioNode, nativeOfflineAudioContextConstructor, renderNativeOfflineAudioContext);\nconst createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeAudioNode, createNativeIIRFilterNodeFaker);\nconst iIRFilterNodeConstructor = createIIRFilterNodeConstructor(createNativeIIRFilterNode, createIIRFilterNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext);\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener);\nconst createNativeOscillatorNode = createNativeOscillatorNodeFactory(cacheTestResult, createNativeAudioNode, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);\nconst createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(createNativeOscillatorNode);\nconst oscillatorNodeConstructor = createOscillatorNodeConstructor(createAudioParam, createInvalidStateError, createNativeOscillatorNode, createOscillatorNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createInvalidStateError, createNativeAudioNode, createNativeGainNode);\nconst createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker);\nconst createNativePannerNodeFaker = createNativePannerNodeFakerFactory(createInvalidStateError, createNativeAudioNode, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError);\nconst createNativePannerNode = createNativePannerNodeFactory(createNativeAudioNode, createNativePannerNodeFaker);\nconst createPannerNodeRenderer = createPannerNodeRendererFactory(createNativePannerNode);\nconst pannerNodeConstructor = createPannerNodeConstructor(createAudioParam, createNativePannerNode, createPannerNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativePeriodicWave = createNativePeriodicWaveFactory(getBackupNativeContext);\nconst periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, PERIODIC_WAVE_STORE);\nconst nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError);\nconst createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(createNativeAudioNode, nativeStereoPannerNodeFakerFactory, createNotSupportedError);\nconst createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(createNativeStereoPannerNode);\nconst stereoPannerNodeConstructor = createStereoPannerNodeConstructor(createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode);\nconst waveShaperNodeConstructor = createWaveShaperNodeConstructor(createInvalidStateError, createNativeWaveShaperNode, createWaveShaperNodeRenderer, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst isSecureContext = createIsSecureContext(window);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window);\n// The addAudioWorkletModule() function is only available in a SecureContext.\nexport const addAudioWorkletModule = (isSecureContext) ?\n    createAddAudioWorkletModule(createAbortError, createNotSupportedError, exposeCurrentFrameAndCurrentTime, createFetchSource(createAbortError), getBackupNativeContext, new WeakMap(), new WeakMap()) :\n    undefined;\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\nexport const decodeAudioData = createDecodeAudioData(AUDIO_BUFFER_STORE, cacheTestResult, createDataCloneError, createEncodingError, nativeOfflineAudioContextConstructor, isNativeContext, isNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testAudioBufferCopyChannelMethodsSubarraySupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds, wrapAudioBufferCopyChannelMethodsSubarray);\nconst baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);\nconst createNativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNodeFactory(createNativeAudioNode);\nconst mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(createNativeMediaElementAudioSourceNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNodeFactory(createInvalidStateError, createNativeAudioNode);\nconst mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(createNativeMediaStreamAudioSourceNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError, createNativeAudioNode);\nconst mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(createNativeMediaStreamTrackAudioSourceNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor);\nconst audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);\nexport { audioContextConstructor as AudioContext };\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNotSupportedError, isNativeOfflineAudioContext);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, disconnectMultipleOutputs, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderNativeOfflineAudioContext);\n// The AudioWorkletNode constructor is only available in a SecureContext.\nconst audioWorkletNodeConstructor = (isSecureContext) ?\n    createAudioWorkletNodeConstructor(createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, gainNodeConstructor, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, noneAudioDestinationNodeConstructor) :\n    undefined;\nexport { audioWorkletNodeConstructor as AudioWorkletNode };\nexport { biquadFilterNodeConstructor as BiquadFilterNode };\nexport { channelMergerNodeConstructor as ChannelMergerNode };\nexport { channelSplitterNodeConstructor as ChannelSplitterNode };\nexport { convolverNodeConstructor as ConvolverNode };\nexport { constantSourceNodeConstructor as ConstantSourceNode };\nexport { delayNodeConstructor as DelayNode };\nexport { dynamicsCompressorNodeConstructor as DynamicsCompressorNode };\nexport { gainNodeConstructor as GainNode };\nexport { iIRFilterNodeConstructor as IIRFilterNode };\nexport { mediaElementAudioSourceNodeConstructor as MediaElementAudioSourceNode };\nexport { mediaStreamAudioSourceNodeConstructor as MediaStreamAudioSourceNode };\nexport { mediaStreamTrackAudioSourceNodeConstructor as MediaStreamTrackAudioSourceNode };\nconst minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);\nexport { minimalAudioContextConstructor as MinimalAudioContext };\nconst createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError, nativeOfflineAudioContextConstructor);\nconst startRendering = createStartRendering(AUDIO_BUFFER_STORE, cacheTestResult, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testAudioBufferCopyChannelMethodsSubarraySupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds, wrapAudioBufferCopyChannelMethodsSubarray);\nconst minimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);\nexport { minimalOfflineAudioContextConstructor as MinimalOfflineAudioContext };\nconst offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError, createNativeOfflineAudioContext, startRendering);\nexport { offlineAudioContextConstructor as OfflineAudioContext };\nexport { oscillatorNodeConstructor as OscillatorNode };\nexport { pannerNodeConstructor as PannerNode };\nexport { periodicWaveConstructor as PeriodicWave };\nexport { stereoPannerNodeConstructor as StereoPannerNode };\nexport { waveShaperNodeConstructor as WaveShaperNode };\nexport const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\nexport const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\nexport const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\nexport const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\nexport const isSupported = () => createIsSupportedPromise(cacheTestResult, createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor), createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor), createTestAudioContextOptionsSupport(nativeAudioContextConstructor), createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor), createTestChannelSplitterNodeChannelCountSupport(nativeOfflineAudioContextConstructor), createTestConstantSourceNodeAccurateSchedulingSupport(createNativeAudioNode, nativeOfflineAudioContextConstructor), createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor), createTestIsSecureContextSupport(window), createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor), testTransferablesSupport);\n//# sourceMappingURL=/build/es2018/module.js.map","import { TEST_RESULTS } from '../globals';\nexport const createCacheTestResult = (ongoingTests) => {\n    return (tester, test) => {\n        const cachedTestResult = TEST_RESULTS.get(tester);\n        if (cachedTestResult !== undefined) {\n            return cachedTestResult;\n        }\n        const ongoingTest = ongoingTests.get(tester);\n        if (ongoingTest !== undefined) {\n            return ongoingTest;\n        }\n        const synchronousTestResult = test();\n        if (synchronousTestResult instanceof Promise) {\n            ongoingTests.set(tester, synchronousTestResult);\n            return synchronousTestResult\n                .then((finalTestResult) => {\n                ongoingTests.delete(tester);\n                TEST_RESULTS.set(tester, finalTestResult);\n                return finalTestResult;\n            });\n        }\n        TEST_RESULTS.set(tester, synchronousTestResult);\n        return synchronousTestResult;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/cache-test-result.js.map","export const createWindow = () => (typeof window === 'undefined') ? null : window;\n//# sourceMappingURL=/build/es2018/factories/window.js.map","export const createNativeOfflineAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('OfflineAudioContext')) {\n        return window.OfflineAudioContext;\n    }\n    return (window.hasOwnProperty('webkitOfflineAudioContext')) ? window.webkitOfflineAudioContext : null;\n};\n//# sourceMappingURL=/build/es2018/factories/native-offline-audio-context-constructor.js.map","export const createIsNativeOfflineAudioContext = (nativeOfflineAudioContextConstructor) => {\n    return (anything) => {\n        return (nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-native-offline-audio-context.js.map","export const createNativeAudioContextConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioContext')) {\n        return window.AudioContext;\n    }\n    return (window.hasOwnProperty('webkitAudioContext')) ? window.webkitAudioContext : null;\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-context-constructor.js.map","import { BACKUP_NATIVE_CONTEXT_STORE } from '../globals';\nexport const createGetBackupNativeContext = (isNativeOfflineAudioContext, nativeAudioContextConstructor, nativeOfflineAudioContextConstructor) => {\n    return (nativeContext) => {\n        /*\n         * Bug #50: Only Edge does currently not allow to create AudioNodes on a closed context yet which is why there needs to be no\n         * backupNativeContext in that case.\n         */\n        if (nativeContext.state === 'closed'\n            && nativeAudioContextConstructor !== null\n            && nativeAudioContextConstructor.name !== 'webkitAudioContext') {\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                const backupNativeContext = BACKUP_NATIVE_CONTEXT_STORE.get(nativeContext);\n                if (backupNativeContext !== undefined) {\n                    return backupNativeContext;\n                }\n                if (nativeOfflineAudioContextConstructor !== null) {\n                    // @todo Copy the attached AudioWorkletProcessors and other settings.\n                    const bckpNtveCntxt = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n                    BACKUP_NATIVE_CONTEXT_STORE.set(nativeContext, bckpNtveCntxt);\n                    return bckpNtveCntxt;\n                }\n            }\n            else {\n                const backupNativeContext = BACKUP_NATIVE_CONTEXT_STORE.get(nativeContext);\n                if (backupNativeContext !== undefined) {\n                    return backupNativeContext;\n                }\n                // @todo Copy the attached AudioWorkletProcessors and other settings.\n                const bckpNtveCntxt = new nativeAudioContextConstructor();\n                BACKUP_NATIVE_CONTEXT_STORE.set(nativeContext, bckpNtveCntxt);\n                return bckpNtveCntxt;\n            }\n        }\n        return null;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/get-backup-native-context.js.map","export const createNativeAudioNodeFactory = (getBackupNativeContext) => {\n    return (nativeContext, factoryFunction) => {\n        // Bug #50: Only Edge does currently not allow to create AudioNodes on a closed context yet.\n        const backupNativeContext = getBackupNativeContext(nativeContext);\n        if (backupNativeContext !== null) {\n            return factoryFunction(backupNativeContext);\n        }\n        return factoryFunction(nativeContext);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-node-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { testAnalyserNodeGetFloatTimeDomainDataMethodSupport } from '../helpers/test-analyser-node-get-float-time-domain-data-method-support';\nimport { wrapAnalyserNodeGetFloatTimeDomainDataMethod } from '../helpers/wrap-analyser-node-get-float-time-domain-data-method';\nexport const createNativeAnalyserNodeFactory = (cacheTestResult, createIndexSizeError, createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeAnalyserNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createAnalyser());\n        // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n        assignNativeAudioNodeOptions(nativeAnalyserNode, options);\n        // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n        if (!(options.maxDecibels > options.minDecibels)) {\n            throw createIndexSizeError();\n        }\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant');\n        // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n        if (!cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () => testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode))) {\n            wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n        }\n        return nativeAnalyserNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-analyser-node-factory.js.map","export const wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode) => {\n    nativeAnalyserNode.getFloatTimeDomainData = (array) => {\n        const byteTimeDomainData = new Uint8Array(array.length);\n        nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n        const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n        for (let i = 0; i < length; i += 1) {\n            array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n        }\n        return array;\n    };\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-analyser-node-get-float-time-domain-data-method.js.map","import { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createAnalyserNodeRendererFactory = (createNativeAnalyserNode) => {\n    return () => {\n        const renderedNativeAnalyserNodes = new WeakMap();\n        const createAnalyserNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAnalyserNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n            if (!nativeAnalyserNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAnalyserNode.channelCount,\n                    channelCountMode: nativeAnalyserNode.channelCountMode,\n                    channelInterpretation: nativeAnalyserNode.channelInterpretation,\n                    fftSize: nativeAnalyserNode.fftSize,\n                    maxDecibels: nativeAnalyserNode.maxDecibels,\n                    minDecibels: nativeAnalyserNode.minDecibels,\n                    smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n                };\n                nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode);\n            return nativeAnalyserNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAnalyserNode !== undefined) {\n                    return Promise.resolve(renderedNativeAnalyserNode);\n                }\n                return createAnalyserNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/analyser-node-renderer-factory.js.map","export const createIsNativeAudioNode = (window) => {\n    return (anything) => {\n        return (window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-native-audio-node.js.map","export const createIsNativeAudioParam = (window) => {\n    return (anything) => {\n        return (window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-native-audio-param.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {\n    const connections = new Map();\n    nativeAudioNode.connect = ((connect) => {\n        return (destination, output = 0, input = 0) => {\n            const returnValue = (isNativeAudioNode(destination))\n                ? connect(destination, output, input)\n                : connect(destination, output);\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            }\n            else {\n                if (connectionsToDestination.every((connection) => (connection.input !== input || connection.output !== output))) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput, output, input) => {\n            disconnect.apply(nativeAudioNode);\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            }\n            else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination\n                        .filter((connection) => (connection.output !== destinationOrOutput));\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    }\n                    else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            }\n            else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                }\n                else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination\n                            .filter((connection) => (connection.output !== output && (connection.input !== input || input === undefined)));\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        }\n                        else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination\n                    .forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    }\n                    else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-node-disconnect-method.js.map","import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nexport const createDetectCycles = (audioParamAudioNodeStore, createNotSupportedError, getAudioNodeConnections, getValueForKey) => {\n    return function detectCycles(source, destination) {\n        const audioNodeOfDestination = (isAudioNode(destination))\n            ? destination\n            : getValueForKey(audioParamAudioNodeStore, destination);\n        if (isDelayNode(audioNodeOfDestination)) {\n            return true;\n        }\n        if (source === audioNodeOfDestination) {\n            throw createNotSupportedError();\n        }\n        const { outputs } = getAudioNodeConnections(audioNodeOfDestination);\n        for (const outputConnection of outputs) {\n            if (detectCycles(source, outputConnection[0])) {\n                return true;\n            }\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/detect-cycles.js.map","export const isDelayNode = (audioNode) => {\n    return 'delayTime' in audioNode;\n};\n//# sourceMappingURL=/build/es2018/guards/delay-node.js.map","export const createNoneAudioDestinationNodeConstructor = (audioNodeConstructor) => {\n    return class NoneAudioDestinationNode extends audioNodeConstructor {\n        constructor(context, internalState, nativeAudioNode, audioNodeRenderer) {\n            super(context, internalState, nativeAudioNode, audioNodeRenderer);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/none-audio-destination-node-constructor.js.map","export const createNativeAudioBufferConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    if (window.hasOwnProperty('AudioBuffer')) {\n        return window.AudioBuffer;\n    }\n    return null;\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-buffer-constructor.js.map","export const createConvertNumberToUnsignedLong = (unit32Array) => {\n    return (value) => {\n        unit32Array[0] = value;\n        return unit32Array[0];\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/convert-number-to-unsigned-long.js.map","export const createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong, createIndexSizeError) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const destinationLength = destination.length;\n            for (let i = (bufferOffset < 0) ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n                destination[i] = channelData[i + bufferOffset];\n            }\n        };\n        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const sourceLength = source.length;\n            for (let i = (bufferOffset < 0) ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n                channelData[i + bufferOffset] = source[i];\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-audio-buffer-copy-channel-methods.js.map","export const createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyFromChannel);\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js.map","export const createWrapAudioBufferCopyChannelMethodsSubarray = (convertNumberToUnsignedLong, createIndexSizeError) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (channelNumber >= audioBuffer.numberOfChannels) {\n                    throw createIndexSizeError();\n                }\n                if (bufferOffset < audioBuffer.length && audioBuffer.length - bufferOffset < destination.length) {\n                    return copyFromChannel.call(audioBuffer, destination.subarray(0, audioBuffer.length - bufferOffset), channelNumber, bufferOffset);\n                }\n                return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n            };\n        })(audioBuffer.copyFromChannel);\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (channelNumber >= audioBuffer.numberOfChannels) {\n                    throw createIndexSizeError();\n                }\n                if (bufferOffset < audioBuffer.length && audioBuffer.length - bufferOffset < source.length) {\n                    return copyToChannel.call(audioBuffer, source.subarray(0, audioBuffer.length - bufferOffset), channelNumber, bufferOffset);\n                }\n                return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-audio-buffer-copy-channel-methods-subarray.js.map","// Bug #33: Edge & Safari expose an AudioBuffer but it can't be used as a constructor.\nexport const createTestAudioBufferConstructorSupport = (nativeAudioBufferConstructor) => {\n    return () => {\n        if (nativeAudioBufferConstructor === null) {\n            return false;\n        }\n        try {\n            new nativeAudioBufferConstructor({ length: 1, sampleRate: 44100 }); // tslint:disable-line:no-unused-expression\n        }\n        catch (_a) {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-buffer-constructor-support.js.map","export const createTestAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createOscillator());\n        try {\n            nativeAudioBufferSourceNode.start(-1);\n        }\n        catch (err) {\n            return (err instanceof RangeError);\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-scheduled-source-node-start-method-negative-parameters-support.js.map","export const createTestAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.start();\n        nativeAudioBufferSourceNode.stop();\n        try {\n            nativeAudioBufferSourceNode.stop();\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js.map","export const createTestAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createOscillator());\n        try {\n            nativeAudioBufferSourceNode.stop(-1);\n        }\n        catch (err) {\n            return (err instanceof RangeError);\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createWrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (createNativeAudioNode) => {\n    return (nativeAudioScheduledSourceNode, nativeContext) => {\n        const nativeGainNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createGain());\n        nativeAudioScheduledSourceNode.connect(nativeGainNode);\n        const disconnectGainNode = ((disconnect) => {\n            return () => {\n                // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n                nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n            };\n        })(nativeAudioScheduledSourceNode.disconnect);\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n        interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n        nativeAudioScheduledSourceNode.stop = ((stop) => {\n            let isStopped = false;\n            return (when = 0) => {\n                if (isStopped) {\n                    try {\n                        stop.call(nativeAudioScheduledSourceNode, when);\n                    }\n                    catch (_a) {\n                        nativeGainNode.gain.setValueAtTime(0, when);\n                    }\n                }\n                else {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                    isStopped = true;\n                }\n            };\n        })(nativeAudioScheduledSourceNode.stop);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioBufferSourceNodeStartMethodDurationParameter } from '../helpers/wrap-audio-buffer-source-node-start-method-duration-parameter';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeAudioBufferSourceNodeFactory = (cacheTestResult, createNativeAudioNode, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodDurationParameterSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options = {}) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n        // Bug #71: Edge does not allow to set the buffer to null.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n        // Bug #149: Safari does not yet support the detune AudioParam.\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n        // Bug #92: Edge does not respect the duration parameter yet.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodDurationParameterSupport, testAudioBufferSourceNodeStartMethodDurationParameterSupport)) {\n            wrapAudioBufferSourceNodeStartMethodDurationParameter(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (!cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext))) {\n            wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n        // Bug #44: Only Chrome, Firefox & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n        // Bug #44: Only Firefox does throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n        return nativeAudioBufferSourceNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-buffer-source-node-factory.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        let isScheduled = false;\n        return (when = 0, offset = 0, duration) => {\n            if (isScheduled) {\n                throw createInvalidStateError();\n            }\n            start.call(nativeAudioBufferSourceNode, when, offset, duration);\n            isScheduled = true;\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js.map","export const wrapAudioBufferSourceNodeStartMethodDurationParameter = (nativeAudioScheduledSourceNode, nativeContext) => {\n    let endTime = Number.POSITIVE_INFINITY;\n    let stopTime = Number.POSITIVE_INFINITY;\n    nativeAudioScheduledSourceNode.start = ((start, stop) => {\n        return (when = 0, offset = 0, duration = Number.POSITIVE_INFINITY) => {\n            start.call(nativeAudioScheduledSourceNode, when, offset);\n            if (duration >= 0 && duration < Number.POSITIVE_INFINITY) {\n                const actualStartTime = Math.max(when, nativeContext.currentTime);\n                // @todo The playbackRate could of course also have been automated and is not always fixed.\n                const durationInBufferTime = (duration / nativeAudioScheduledSourceNode.playbackRate.value);\n                endTime = actualStartTime + durationInBufferTime;\n                stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n            }\n        };\n    })(nativeAudioScheduledSourceNode.start, nativeAudioScheduledSourceNode.stop);\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            stopTime = Math.max(when, nativeContext.currentTime);\n            stop.call(nativeAudioScheduledSourceNode, Math.min(endTime, stopTime));\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-duration-parameter.js.map","export const createTestAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        nativeAudioBufferSourceNode.start();\n        try {\n            nativeAudioBufferSourceNode.start();\n        }\n        catch (_a) {\n            return true;\n        }\n        return false;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-buffer-source-node-start-method-consecutive-calls-support.js.map","// Bug #92: Edge does not respect the duration parameter yet.\nexport const createTestAudioBufferSourceNodeStartMethodDurationParameterSupport = (nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const audioBuffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n        const audioBufferSourceNode = offlineAudioContext.createBufferSource();\n        audioBuffer.getChannelData(0)[0] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.start(0, 0, 0);\n        audioBufferSourceNode.connect(offlineAudioContext.destination);\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            offlineAudioContext.oncomplete = ({ renderedBuffer }) => {\n                // Bug #5: Safari does not support copyFromChannel().\n                resolve(renderedBuffer.getChannelData(0)[0] === 0);\n            };\n            offlineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-buffer-source-node-start-method-duration-parameter-support.js.map","export const createTestAudioBufferSourceNodeStartMethodOffsetClampingSupport = (createNativeAudioNode) => {\n    return (nativeContext) => {\n        const nativeAudioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        try {\n            nativeAudioBufferSourceNode.start(0, 1);\n        }\n        catch (_a) {\n            return false;\n        }\n        return true;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-audio-buffer-source-node-start-method-offset-clamping-support.js.map","export const wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode) => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration) => {\n            const buffer = nativeAudioBufferSourceNode.buffer;\n            // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n            const clampedOffset = (buffer === null) ? offset : Math.min(buffer.duration, offset);\n            // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n            if (buffer !== null && clampedOffset > buffer.duration - (0.5 / nativeAudioBufferSourceNode.context.sampleRate)) {\n                start.call(nativeAudioBufferSourceNode, when, 0, 0);\n            }\n            else {\n                start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n            }\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createAudioBufferSourceNodeRendererFactory = (createNativeAudioBufferSourceNode) => {\n    return () => {\n        const renderedNativeAudioBufferSourceNodes = new WeakMap();\n        let start = null;\n        let stop = null;\n        const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioBufferSourceNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeAudioBufferSourceNode.buffer,\n                    channelCount: nativeAudioBufferSourceNode.channelCount,\n                    channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n                    channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n                    // Bug #149: Safari does not yet support the detune AudioParam.\n                    loop: nativeAudioBufferSourceNode.loop,\n                    loopEnd: nativeAudioBufferSourceNode.loopEnd,\n                    loopStart: nativeAudioBufferSourceNode.loopStart,\n                    playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n                };\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeAudioBufferSourceNode.start(...start);\n                }\n                if (stop !== null) {\n                    nativeAudioBufferSourceNode.stop(stop);\n                }\n            }\n            renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            }\n            else {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.playbackRate);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n            return nativeAudioBufferSourceNode;\n        };\n        return {\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioBufferSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioBufferSourceNode);\n                }\n                return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-buffer-source-node-renderer-factory.js.map","import { AutomationEventList } from 'automation-events';\nimport { AUDIO_PARAM_AUDIO_NODE_STORE, AUDIO_PARAM_STORE } from '../globals';\nimport { getAudioGraph } from '../helpers/get-audio-graph';\nconst addAudioParam = (context, audioParam, audioParamRenderer) => {\n    const audioGraph = getAudioGraph(context);\n    audioGraph.params.set(audioParam, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: audioParamRenderer });\n};\nexport const createAudioParamFactory = (createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor) => {\n    return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n        const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n        const audioParamRenderer = (isAudioParamOfOfflineAudioContext) ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue() {\n                return nativeAudioParam.defaultValue;\n            },\n            get maxValue() {\n                return (maxValue === null) ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue() {\n                return (minValue === null) ? nativeAudioParam.minValue : minValue;\n            },\n            get value() {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n                // Bug #98: Edge, Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime) {\n                // Bug #28: Edge, Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                }\n                else {\n                    const previousLastEvent = Array\n                        .from(automationEventList)\n                        .pop();\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    const currentLastEvent = Array\n                        .from(automationEventList)\n                        .pop();\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        }\n                        else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n                        }\n                    }\n                }\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value, endTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            linearRampToValueAtTime(value, endTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            setTargetAtTime(target, startTime, timeConstant) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n                return audioParam;\n            },\n            setValueAtTime(value, startTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n                return audioParam;\n            },\n            setValueCurveAtTime(values, startTime, duration) {\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor((endTime) * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((values.length - 1) / duration) * (((firstSample + i) / sampleRate) - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        interpolatedValues[i] = (lowerIndex === upperIndex)\n                            ? values[lowerIndex]\n                            : ((1 - (theoreticIndex - lowerIndex)) * values[lowerIndex])\n                                + ((1 - (upperIndex - theoreticIndex)) * values[upperIndex]);\n                    }\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n                    const timeOfLastSample = lastSample / sampleRate;\n                    if (timeOfLastSample < endTime) {\n                        audioParam.setValueAtTime(interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n                    audioParam.setValueAtTime(values[values.length - 1], endTime);\n                }\n                else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(values, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(values, startTime, duration);\n                }\n                return audioParam;\n            }\n        };\n        AUDIO_PARAM_STORE.set(audioParam, nativeAudioParam);\n        AUDIO_PARAM_AUDIO_NODE_STORE.set(audioParam, audioNode);\n        addAudioParam(audioNode.context, audioParam, audioParamRenderer);\n        return audioParam;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-param-factory.js.map","export const createAudioParamRenderer = (automationEventList) => {\n    return {\n        replay(audioParam) {\n            for (const automationEvent of automationEventList) {\n                if (automationEvent.type === 'exponentialRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.exponentialRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'linearRampToValue') {\n                    const { endTime, value } = automationEvent;\n                    audioParam.linearRampToValueAtTime(value, endTime);\n                }\n                else if (automationEvent.type === 'setTarget') {\n                    const { startTime, target, timeConstant } = automationEvent;\n                    audioParam.setTargetAtTime(target, startTime, timeConstant);\n                }\n                else if (automationEvent.type === 'setValue') {\n                    const { startTime, value } = automationEvent;\n                    audioParam.setValueAtTime(value, startTime);\n                }\n                else if (automationEvent.type === 'setValueCurve') {\n                    const { duration, startTime, values } = automationEvent;\n                    audioParam.setValueCurveAtTime(values, startTime, duration);\n                }\n                else {\n                    throw new Error(\"Can't apply an unknown automation.\");\n                }\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-param-renderer.js.map","export const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\nexport const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\n//# sourceMappingURL=/build/es2018/constants.js.map","import { AUDIO_GRAPHS } from '../globals';\nimport { getNativeContext } from '../helpers/get-native-context';\nexport const createAudioDestinationNodeConstructor = (audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError, createNativeAudioDestinationNode, isNativeOfflineAudioContext) => {\n    return class AudioDestinationNode extends audioNodeConstructor {\n        constructor(context, channelCount) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n            const audioDestinationNodeRenderer = ((isOffline) ? createAudioDestinationNodeRenderer() : null);\n            const audioGraph = { audioWorkletGlobalScope: null, nodes: new WeakMap(), params: new WeakMap() };\n            AUDIO_GRAPHS.set(context, audioGraph);\n            super(context, 'passive', nativeAudioDestinationNode, audioDestinationNodeRenderer);\n            this._isNodeOfNativeOfflineAudioContext = isOffline;\n            this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n        }\n        get channelCount() {\n            return this._nativeAudioDestinationNode.channelCount;\n        }\n        set channelCount(value) {\n            // Bug #52: Chrome, Edge, Opera & Safari do not throw an exception at all.\n            // Bug #54: Firefox does throw an IndexSizeError.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            // Bug #47: The AudioDestinationNode in Edge and Safari do not initialize the maxChannelCount property correctly.\n            if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n                throw createIndexSizeError();\n            }\n            this._nativeAudioDestinationNode.channelCount = value;\n        }\n        get channelCountMode() {\n            return this._nativeAudioDestinationNode.channelCountMode;\n        }\n        set channelCountMode(value) {\n            // Bug #53: No browser does throw an exception yet.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n            this._nativeAudioDestinationNode.channelCountMode = value;\n        }\n        get maxChannelCount() {\n            return this._nativeAudioDestinationNode.maxChannelCount;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-destination-node-constructor.js.map","import { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createAudioDestinationNodeRenderer = () => {\n    let nativeAudioDestinationNodePromise = null;\n    const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);\n        return nativeAudioDestinationNode;\n    };\n    return {\n        render(proxy, nativeOfflineAudioContext) {\n            if (nativeAudioDestinationNodePromise === null) {\n                nativeAudioDestinationNodePromise = createAudioDestinationNode(proxy, nativeOfflineAudioContext);\n            }\n            return nativeAudioDestinationNodePromise;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-destination-node-renderer-factory.js.map","export const createNativeAudioDestinationNode = (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n    const nativeAudioDestinationNode = nativeContext.destination;\n    // Bug #132: Edge & Safari do not have the correct channelCount.\n    if (nativeAudioDestinationNode.channelCount !== channelCount) {\n        nativeAudioDestinationNode.channelCount = channelCount;\n    }\n    // Bug #83: Edge & Safari do not have the correct channelCountMode.\n    if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n        nativeAudioDestinationNode.channelCountMode = 'explicit';\n    }\n    // Bug #47: The AudioDestinationNode in Edge and Safari does not initialize the maxChannelCount property correctly.\n    if (nativeAudioDestinationNode.maxChannelCount === 0) {\n        Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n            get: () => nativeAudioDestinationNode.channelCount\n        });\n    }\n    return nativeAudioDestinationNode;\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-destination-node.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeBiquadFilterNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeBiquadFilterNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBiquadFilter());\n        assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n        assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n        assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n        return nativeBiquadFilterNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-biquad-filter-node-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createBiquadFilterNodeRendererFactory = (createNativeBiquadFilterNode) => {\n    return () => {\n        const renderedNativeBiquadFilterNodes = new WeakMap();\n        const createBiquadFilterNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeBiquadFilterNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                const options = {\n                    Q: nativeBiquadFilterNode.Q.value,\n                    channelCount: nativeBiquadFilterNode.channelCount,\n                    channelCountMode: nativeBiquadFilterNode.channelCountMode,\n                    channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n                    detune: nativeBiquadFilterNode.detune.value,\n                    frequency: nativeBiquadFilterNode.frequency.value,\n                    gain: nativeBiquadFilterNode.gain.value,\n                    type: nativeBiquadFilterNode.type\n                };\n                nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.Q);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.detune);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.frequency);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.gain);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);\n            return nativeBiquadFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeBiquadFilterNode !== undefined) {\n                    return Promise.resolve(renderedNativeBiquadFilterNode);\n                }\n                return createBiquadFilterNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/biquad-filter-node-renderer-factory.js.map","export const createWrapChannelMergerNode = (createInvalidStateError, createNativeAudioNode) => {\n    return (nativeContext, channelMergerNode) => {\n        const audioBufferSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createBufferSource());\n        channelMergerNode.channelCount = 1;\n        channelMergerNode.channelCountMode = 'explicit';\n        // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n        const length = channelMergerNode.numberOfInputs;\n        for (let i = 0; i < length; i += 1) {\n            audioBufferSourceNode.connect(channelMergerNode, 0, i);\n        }\n        Object.defineProperty(channelMergerNode, 'channelCount', {\n            get: () => 1,\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n        Object.defineProperty(channelMergerNode, 'channelCountMode', {\n            get: () => 'explicit',\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wrap-channel-merger-node.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeChannelMergerNodeFactory = (createNativeAudioNode, wrapChannelMergerNode) => {\n    return (nativeContext, options) => {\n        const nativeChannelMergerNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createChannelMerger(options.numberOfInputs);\n        });\n        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n        // Bug #15: Safari does not return the default properties.\n        if (nativeChannelMergerNode.channelCount !== 1 &&\n            nativeChannelMergerNode.channelCountMode !== 'explicit') {\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n        // Bug #16: Firefox does not throw an error when setting a different channelCount or channelCountMode.\n        try {\n            nativeChannelMergerNode.channelCount = (options.numberOfInputs === undefined) ? 6 : options.numberOfInputs;\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n        catch ( /* Ignore errors. */_a) { /* Ignore errors. */ } // tslint:disable-line:no-empty\n        return nativeChannelMergerNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-channel-merger-node-factory.js.map","import { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfInputs: nativeAudioNode.numberOfInputs\n                };\n                nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n            return nativeAudioNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/channel-merger-node-renderer-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapChannelSplitterNode } from '../helpers/wrap-channel-splitter-node';\nexport const createNativeChannelSplitterNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeChannelSplitterNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createChannelSplitter(options.numberOfOutputs);\n        });\n        // Bug #96: Safari does not have the correct channelCount.\n        // Bug #29: Edge & Safari do not have the correct channelCountMode.\n        // Bug #31: Edge & Safari do not have the correct channelInterpretation.\n        assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n        // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Firefox & Opera partially support the spec yet.\n        wrapChannelSplitterNode(nativeChannelSplitterNode);\n        return nativeChannelSplitterNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-channel-splitter-node-factory.js.map","import { createInvalidStateError } from '../factories/invalid-state-error';\nexport const wrapChannelSplitterNode = (channelSplitterNode) => {\n    const channelCount = channelSplitterNode.numberOfOutputs;\n    // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n    Object.defineProperty(channelSplitterNode, 'channelCount', {\n        get: () => channelCount,\n        set: (value) => {\n            if (value !== channelCount) {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    /*\n     * Bug #30: Only Chrome, Firefox & Opera throw an error when attempting to change the channelCountMode to something other than\n     * explicit.\n     */\n    Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n        get: () => 'explicit',\n        set: (value) => {\n            if (value !== 'explicit') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n    /*\n     * Bug #32: Only Chrome, Firefox & Opera throws an error when attempting to change the channelInterpretation to something other than\n     * discrete.\n     */\n    Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n        get: () => 'discrete',\n        set: (value) => {\n            if (value !== 'discrete') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-channel-splitter-node.js.map","import { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createChannelSplitterNodeRendererFactory = (createNativeChannelSplitterNode) => {\n    return () => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode(proxy);\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfOutputs: nativeAudioNode.numberOfOutputs\n                };\n                nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n            return nativeAudioNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/channel-splitter-node-renderer-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeGainNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeGainNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createGain());\n        assignNativeAudioNodeOptions(nativeGainNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n        return nativeGainNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-gain-node-factory.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConstantSourceNodeFakerFactory = (createNativeAudioBufferSourceNode, createNativeGainNode) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext);\n        /*\n         * @todo Edge will throw a NotSupportedError when calling createBuffer() on a closed context. That's why the audioBuffer is created\n         * after the audioBufferSourceNode in this case. If the context is closed createNativeAudioBufferSourceNode() will throw the\n         * expected error and createBuffer() never gets called.\n         */\n        const audioBuffer = nativeContext.createBuffer(1, 2, nativeContext.sampleRate);\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n        audioBufferSourceNode.connect(gainNode);\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context() {\n                return gainNode.context;\n            },\n            get inputs() {\n                return undefined;\n            },\n            get numberOfInputs() {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return gainNode.numberOfOutputs;\n            },\n            get offset() {\n                return gainNode.gain;\n            },\n            get onended() {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = value;\n            },\n            addEventListener(...args) {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0) {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0) {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n        return interceptConnections(nativeConstantSourceNodeFaker, gainNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-constant-source-node-faker-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeConstantSourceNodeFactory = (cacheTestResult, createNativeAudioNode, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport) => {\n    return (nativeContext, options) => {\n        // Bug #62: Edge & Safari do not support ConstantSourceNodes.\n        if (nativeContext.createConstantSource === undefined) {\n            return createNativeConstantSourceNodeFaker(nativeContext, options);\n        }\n        const nativeConstantSourceNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createConstantSource();\n        });\n        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');\n        // Bug #44: Only Chrome, Firefox & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        // Bug #44: Only Firefox does throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n        }\n        return nativeConstantSourceNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-constant-source-node-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createConstantSourceNodeRendererFactory = (createNativeConstantSourceNode) => {\n    return () => {\n        const renderedNativeConstantSourceNodes = new WeakMap();\n        let start = null;\n        let stop = null;\n        const createConstantSourceNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeConstantSourceNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeConstantSourceNode.channelCount,\n                    channelCountMode: nativeConstantSourceNode.channelCountMode,\n                    channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n                    offset: nativeConstantSourceNode.offset.value\n                };\n                nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeConstantSourceNode.start(start);\n                }\n                if (stop !== null) {\n                    nativeConstantSourceNode.stop(stop);\n                }\n            }\n            renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.offset);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);\n            return nativeConstantSourceNode;\n        };\n        return {\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeConstantSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeConstantSourceNode);\n                }\n                return createConstantSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/constant-source-node-renderer-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeConvolverNodeFactory = (createNativeAudioNode, createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const nativeConvolverNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createConvolver());\n        assignNativeAudioNodeOptions(nativeConvolverNode, options);\n        // The normalize property needs to be set before setting the buffer.\n        if (options.disableNormalization === nativeConvolverNode.normalize) {\n            nativeConvolverNode.normalize = !options.disableNormalization;\n        }\n        assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer');\n        // Bug #113: Edge & Safari allow to change the channelCount\n        if (options.channelCount !== 2) {\n            throw createNotSupportedError();\n        }\n        Object.defineProperty(nativeConvolverNode, 'channelCount', {\n            get: () => options.channelCount,\n            set: (value) => {\n                if (value !== options.channelCount) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n        // Bug #114: Edge & Safari allow to change the channelCountMode\n        if (options.channelCountMode !== 'clamped-max') {\n            throw createNotSupportedError();\n        }\n        Object.defineProperty(nativeConvolverNode, 'channelCountMode', {\n            get: () => options.channelCountMode,\n            set: (value) => {\n                if (value !== options.channelCountMode) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n        return nativeConvolverNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-convolver-node-factory.js.map","import { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createConvolverNodeRendererFactory = (createNativeConvolverNode) => {\n    return () => {\n        const renderedNativeConvolverNodes = new WeakMap();\n        const createConvolverNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeConvolverNode = getNativeAudioNode(proxy);\n            // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n            if (!nativeConvolverNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeConvolverNode.buffer,\n                    channelCount: nativeConvolverNode.channelCount,\n                    channelCountMode: nativeConvolverNode.channelCountMode,\n                    channelInterpretation: nativeConvolverNode.channelInterpretation,\n                    disableNormalization: !nativeConvolverNode.normalize\n                };\n                nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode);\n            return nativeConvolverNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeConvolverNode !== undefined) {\n                    return Promise.resolve(renderedNativeConvolverNode);\n                }\n                return createConvolverNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/convolver-node-renderer-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDelayNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, options) => {\n        const nativeDelayNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createDelay(options.maxDelayTime));\n        assignNativeAudioNodeOptions(nativeDelayNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n        return nativeDelayNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-delay-node-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createDelayNodeRendererFactory = (createNativeDelayNode) => {\n    return (maxDelayTime) => {\n        const renderedNativeDelayNodes = new WeakMap();\n        const createDelayNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeDelayNode = getNativeAudioNode(proxy);\n            // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n            if (!nativeDelayNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeDelayNode.channelCount,\n                    channelCountMode: nativeDelayNode.channelCountMode,\n                    channelInterpretation: nativeDelayNode.channelInterpretation,\n                    delayTime: nativeDelayNode.delayTime.value,\n                    maxDelayTime\n                };\n                nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n            if (!nativeDelayNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.delayTime);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode);\n            return nativeDelayNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeDelayNode !== undefined) {\n                    return Promise.resolve(renderedNativeDelayNode);\n                }\n                return createDelayNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/delay-node-renderer-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeDynamicsCompressorNodeFactory = (createNativeAudioNode, createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const nativeDynamicsCompressorNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createDynamicsCompressor());\n        assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);\n        // Bug #108: Only Chrome, Firefox and Opera disallow a channelCount of three and above yet.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        // Bug #109: Only Chrome, Firefox and Opera disallow a channelCountMode of 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n        return nativeDynamicsCompressorNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-dynamics-compressor-node-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createDynamicsCompressorNodeRendererFactory = (createNativeDynamicsCompressorNode) => {\n    return () => {\n        const renderedNativeDynamicsCompressorNodes = new WeakMap();\n        const createDynamicsCompressorNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeDynamicsCompressorNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n             * created again.\n             */\n            const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                const options = {\n                    attack: nativeDynamicsCompressorNode.attack.value,\n                    channelCount: nativeDynamicsCompressorNode.channelCount,\n                    channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n                    channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n                    knee: nativeDynamicsCompressorNode.knee.value,\n                    ratio: nativeDynamicsCompressorNode.ratio.value,\n                    release: nativeDynamicsCompressorNode.release.value,\n                    threshold: nativeDynamicsCompressorNode.threshold.value\n                };\n                nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.attack);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.knee);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.ratio);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.release);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.threshold);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n            return nativeDynamicsCompressorNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeDynamicsCompressorNode !== undefined) {\n                    return Promise.resolve(renderedNativeDynamicsCompressorNode);\n                }\n                return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/dynamics-compressor-node-renderer-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createGainNodeRendererFactory = (createNativeGainNode) => {\n    return () => {\n        const renderedNativeGainNodes = new WeakMap();\n        const createGainNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeGainNode = getNativeAudioNode(proxy);\n            // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n            if (!nativeGainNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeGainNode.channelCount,\n                    channelCountMode: nativeGainNode.channelCountMode,\n                    channelInterpretation: nativeGainNode.channelInterpretation,\n                    gain: nativeGainNode.gain.value\n                };\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n            if (!nativeGainNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.gain);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode);\n            return nativeGainNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNode);\n                }\n                return createGainNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/gain-node-renderer-factory.js.map","export const createNativeScriptProcessorNodeFactory = (createNativeAudioNode) => {\n    return (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {\n        return createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-script-processor-node-factory.js.map","import { testPromiseSupport } from '../helpers/test-promise-support';\nexport const createRenderNativeOfflineAudioContext = (cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, testOfflineAudioContextCurrentTimeSupport) => {\n    return (nativeOfflineAudioContext) => {\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n            // Bug #158: Edge does not advance currentTime if it is not accessed while rendering the audio.\n            return Promise\n                .resolve(cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport))\n                .then((isOfflineAudioContextCurrentTimeSupported) => {\n                if (!isOfflineAudioContextCurrentTimeSupported) {\n                    const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n                    nativeOfflineAudioContext.oncomplete = () => {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        scriptProcessorNode.disconnect();\n                    };\n                    scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation\n                    scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n                }\n                return nativeOfflineAudioContext.startRendering();\n            });\n        }\n        return new Promise((resolve) => {\n            // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n            const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                gain: 0\n            });\n            nativeOfflineAudioContext.oncomplete = (event) => {\n                gainNode.disconnect();\n                resolve(event.renderedBuffer);\n            };\n            gainNode.connect(nativeOfflineAudioContext.destination);\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/render-native-offline-audio-context.js.map","export const createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode, nativeOfflineAudioContextConstructor) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n        const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            nativeOfflineAudioContext.oncomplete = () => {\n                gainNode.disconnect();\n                resolve(nativeOfflineAudioContext.currentTime !== 0);\n            };\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/test-offline-audio-context-current-time-support.js.map","import { filterBuffer } from '../helpers/filter-buffer';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nconst filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {\n    const feedbackLength = feedback.length;\n    const feedforwardLength = feedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n    if (feedback[0] !== 1) {\n        for (let i = 0; i < feedbackLength; i += 1) {\n            feedforward[i] /= feedback[0];\n        }\n        for (let i = 1; i < feedforwardLength; i += 1) {\n            feedback[i] /= feedback[0];\n        }\n    }\n    const bufferLength = 32;\n    const xBuffer = new Float32Array(bufferLength);\n    const yBuffer = new Float32Array(bufferLength);\n    const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);\n    const numberOfChannels = renderedBuffer.numberOfChannels;\n    for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = renderedBuffer.getChannelData(i);\n        const output = filteredBuffer.getChannelData(i);\n        // @todo Add a test which checks support for TypedArray.prototype.fill().\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n        filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);\n    }\n    return filteredBuffer;\n};\nexport const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode, createNativeAudioNode, nativeOfflineAudioContextConstructor, renderNativeOfflineAudioContext) => {\n    return (feedback, feedforward) => {\n        const renderedNativeAudioNodes = new WeakMap();\n        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeIIRFilterNode = getNativeAudioNode(proxy);\n            let nativeAudioBufferSourceNode = null;\n            // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);\n            // Bug #9: Safari does not support IIRFilterNodes.\n            if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);\n            }\n            else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                nativeIIRFilterNode = createNativeAudioNode(nativeOfflineAudioContext, (ntvCntxt) => {\n                    return ntvCntxt.createIIRFilter(feedforward, feedback);\n                });\n            }\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, (nativeAudioBufferSourceNode === null) ? nativeIIRFilterNode : nativeAudioBufferSourceNode);\n            if (nativeAudioBufferSourceNode !== null) {\n                if (nativeOfflineAudioContextConstructor === null) {\n                    throw new Error('Missing the native OfflineAudioContext constructor.');\n                }\n                const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.\n                proxy.context.destination.channelCount, \n                // Bug #17: Safari does not yet expose the length.\n                proxy.context.length, nativeOfflineAudioContext.sampleRate);\n                await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);\n                const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                nativeAudioBufferSourceNode.buffer = filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n                nativeAudioBufferSourceNode.start(0);\n                return nativeAudioBufferSourceNode;\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);\n            return nativeIIRFilterNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/iir-filter-node-renderer-factory.js.map","import { createInvalidAccessError } from '../factories/invalid-access-error';\nexport const wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode) => {\n    nativeIIRFilterNode.getFrequencyResponse = ((getFrequencyResponse) => {\n        return (frequencyHz, magResponse, phaseResponse) => {\n            if ((frequencyHz.length !== magResponse.length) || (magResponse.length !== phaseResponse.length)) {\n                throw createInvalidAccessError();\n            }\n            return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n        };\n    })(nativeIIRFilterNode.getFrequencyResponse);\n};\n//# sourceMappingURL=/build/es2018/helpers/wrap-iir-filter-node-get-frequency-response-method.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeIIRFilterNodeFactory = (createNativeAudioNode, createNativeIIRFilterNodeFaker) => {\n    return (nativeContext, baseLatency, options) => {\n        // Bug #9: Safari does not support IIRFilterNodes.\n        if (nativeContext.createIIRFilter === undefined) {\n            return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n        }\n        const nativeIIRFilterNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n            return ntvCntxt.createIIRFilter(options.feedforward, options.feedback);\n        });\n        assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n        return nativeIIRFilterNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-iir-filter-node-factory.js.map","import { EventTarget } from '../event-target';\nimport { CONTEXT_STORE } from '../globals';\nimport { wrapEventListener } from '../helpers/wrap-event-listener';\nexport const createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor, createAudioListener) => {\n    return class MinimalBaseAudioContext extends EventTarget {\n        constructor(_nativeContext, numberOfChannels) {\n            super(_nativeContext);\n            this._nativeContext = _nativeContext;\n            CONTEXT_STORE.set(this, _nativeContext);\n            // Bug #93: Edge will set the sampleRate of an AudioContext to zero when it is closed.\n            const sampleRate = _nativeContext.sampleRate;\n            Object.defineProperty(_nativeContext, 'sampleRate', {\n                get: () => sampleRate\n            });\n            this._destination = new audioDestinationNodeConstructor(this, numberOfChannels);\n            this._listener = createAudioListener(this, _nativeContext);\n            this._onstatechange = null;\n        }\n        get currentTime() {\n            return this._nativeContext.currentTime;\n        }\n        get destination() {\n            return this._destination;\n        }\n        get listener() {\n            return this._listener;\n        }\n        get onstatechange() {\n            return this._onstatechange;\n        }\n        set onstatechange(value) {\n            const wrappedListener = wrapEventListener(this, value);\n            this._nativeContext.onstatechange = wrappedListener;\n            const nativeOnStateChange = this._nativeContext.onstatechange;\n            this._onstatechange = (nativeOnStateChange === wrappedListener) ? value : nativeOnStateChange;\n        }\n        get sampleRate() {\n            return this._nativeContext.sampleRate;\n        }\n        get state() {\n            return this._nativeContext.state;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/minimal-base-audio-context-constructor.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nexport const createAudioListenerFactory = (createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, isNativeOfflineAudioContext) => {\n    return (context, nativeContext) => {\n        const nativeListener = nativeContext.listener;\n        // Bug #117: Only Chrome & Opera support the new interface already.\n        const createFakeAudioParams = () => {\n            const channelMergerNode = createNativeChannelMergerNode(nativeContext, { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'speakers', numberOfInputs: 9 });\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n            const createFakeAudioParam = (input, value) => {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete', offset: value });\n                constantSourceNode.connect(channelMergerNode, 0, input);\n                // @todo This should be stopped when the context is closed.\n                constantSourceNode.start();\n                Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n                    get() {\n                        return value;\n                    }\n                });\n                /*\n                 * Bug #62 & #74: Edge & Safari do not support ConstantSourceNodes and do not export the correct values for maxValue and\n                 * minValue for GainNodes.\n                 */\n                return createAudioParam({ context }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            };\n            let lastOrientation = [0, 0, -1, 0, 1, 0];\n            let lastPosition = [0, 0, 0];\n            scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n                const orientation = [\n                    inputBuffer.getChannelData(0)[0],\n                    inputBuffer.getChannelData(1)[0],\n                    inputBuffer.getChannelData(2)[0],\n                    inputBuffer.getChannelData(3)[0],\n                    inputBuffer.getChannelData(4)[0],\n                    inputBuffer.getChannelData(5)[0]\n                ];\n                if (orientation.some((value, index) => (value !== lastOrientation[index]))) {\n                    nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n                    lastOrientation = orientation;\n                }\n                const positon = [\n                    inputBuffer.getChannelData(6)[0],\n                    inputBuffer.getChannelData(7)[0],\n                    inputBuffer.getChannelData(8)[0]\n                ];\n                if (positon.some((value, index) => (value !== lastPosition[index]))) {\n                    nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n                    lastPosition = positon;\n                }\n            };\n            channelMergerNode.connect(scriptProcessorNode);\n            return {\n                forwardX: createFakeAudioParam(0, 0),\n                forwardY: createFakeAudioParam(1, 0),\n                forwardZ: createFakeAudioParam(2, -1),\n                positionX: createFakeAudioParam(6, 0),\n                positionY: createFakeAudioParam(7, 0),\n                positionZ: createFakeAudioParam(8, 0),\n                upX: createFakeAudioParam(3, 0),\n                upY: createFakeAudioParam(4, 1),\n                upZ: createFakeAudioParam(5, 0)\n            };\n        };\n        const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } = (nativeListener.forwardX === undefined)\n            ? createFakeAudioParams()\n            : nativeListener;\n        return {\n            get forwardX() {\n                return forwardX;\n            },\n            get forwardY() {\n                return forwardY;\n            },\n            get forwardZ() {\n                return forwardZ;\n            },\n            get positionX() {\n                return positionX;\n            },\n            get positionY() {\n                return positionY;\n            },\n            get positionZ() {\n                return positionZ;\n            },\n            get upX() {\n                return upX;\n            },\n            get upY() {\n                return upY;\n            },\n            get upZ() {\n                return upZ;\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-listener-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nexport const createNativeOscillatorNodeFactory = (cacheTestResult, createNativeAudioNode, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls) => {\n    return (nativeContext, options) => {\n        const nativeOscillatorNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createOscillator());\n        assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n        if (options.periodicWave !== undefined) {\n            nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n        }\n        else {\n            assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n        }\n        // Bug #44: Only Chrome & Opera throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n        }\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n        }\n        // Bug #44: No browser does throw a RangeError yet.\n        if (!cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n        }\n        return nativeOscillatorNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-oscillator-node-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createOscillatorNodeRendererFactory = (createNativeOscillatorNode) => {\n    return () => {\n        const renderedNativeOscillatorNodes = new WeakMap();\n        let periodicWave = null;\n        let start = null;\n        let stop = null;\n        const createOscillatorNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeOscillatorNode = getNativeAudioNode(proxy);\n            // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeOscillatorNode.channelCount,\n                    channelCountMode: nativeOscillatorNode.channelCountMode,\n                    channelInterpretation: nativeOscillatorNode.channelInterpretation,\n                    detune: nativeOscillatorNode.detune.value,\n                    frequency: nativeOscillatorNode.frequency.value,\n                    periodicWave: (periodicWave === null) ? undefined : periodicWave,\n                    type: nativeOscillatorNode.type\n                };\n                nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n                if (start !== null) {\n                    nativeOscillatorNode.start(start);\n                }\n                if (stop !== null) {\n                    nativeOscillatorNode.stop(stop);\n                }\n            }\n            renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.detune);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.frequency);\n            }\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode);\n            return nativeOscillatorNode;\n        };\n        return {\n            set periodicWave(value) {\n                periodicWave = value;\n            },\n            set start(value) {\n                start = value;\n            },\n            set stop(value) {\n                stop = value;\n            },\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeOscillatorNode !== undefined) {\n                    return Promise.resolve(renderedNativeOscillatorNode);\n                }\n                return createOscillatorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/oscillator-node-renderer-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeWaveShaperNodeFakerFactory = (createInvalidStateError, createNativeAudioNode, createNativeGainNode) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        const positiveWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        inputGainNode.connect(negativeWaveShaperNode);\n        negativeWaveShaperNode.connect(outputGainNode);\n        inputGainNode.connect(invertGainNode);\n        invertGainNode.connect(positiveWaveShaperNode);\n        positiveWaveShaperNode.connect(revertGainNode);\n        revertGainNode.connect(outputGainNode);\n        let unmodifiedCurve = null;\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return negativeWaveShaperNode.context;\n            },\n            get curve() {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (curve !== null && curve.length < 2) {\n                    throw createInvalidStateError();\n                }\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                }\n                else {\n                    const curveLength = value.length;\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = ((curveLength + 1) / 2) - 1;\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        negativeCurve[i] = (lowerIndex === upperIndex)\n                            ? value[lowerIndex]\n                            : ((1 - (theoreticIndex - lowerIndex)) * value[lowerIndex])\n                                + ((1 - (upperIndex - theoreticIndex)) * value[upperIndex]);\n                        positiveCurve[i] = (lowerIndex === upperIndex)\n                            ? -value[curveLength - 1 - lowerIndex]\n                            : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex])\n                                - ((1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex]);\n                    }\n                    negativeCurve[length] = (curveLength % 2 === 1) ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n                unmodifiedCurve = value;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample() {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (curve !== nativeWaveShaperNodeFaker.curve) {\n            nativeWaveShaperNodeFaker.curve = curve;\n        }\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n        return interceptConnections(nativeWaveShaperNodeFaker, outputGainNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-wave-shaper-node-faker-factory.js.map","import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeWaveShaperNodeFactory = (createInvalidStateError, createNativeAudioNode, createNativeWaveShaperNodeFaker) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createWaveShaper());\n        try {\n            // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n            // Bug #119: Safari does not correctly map the values. Bug #102 is only used to detect Safari in this case.\n            nativeWaveShaperNode.curve = new Float32Array([1]);\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n        catch ( /* Ignore errors. */_a) { /* Ignore errors. */ }\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n        const curve = options.curve;\n        // Bug #104: Chrome will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n        return nativeWaveShaperNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-wave-shaper-node-factory.js.map","import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativePannerNodeFakerFactory = (createInvalidStateError, createNativeAudioNode, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError) => {\n    return (nativeContext, { coneInnerAngle, coneOuterAngle, coneOuterGain, distanceModel, maxDistance, orientationX, orientationY, orientationZ, panningModel, positionX, positionY, positionZ, refDistance, rolloffFactor, ...audioNodeOptions }) => {\n        const pannerNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createPanner());\n        // Bug #125: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n        // Bug #126: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n        const SINGLE_CHANNEL_OPTIONS = {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete'\n        };\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, channelInterpretation: 'speakers', numberOfInputs: 6 });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const orientationXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });\n        const orientationYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const orientationZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 0);\n        const waveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, curve: new Float32Array([1, 1]), oversample: 'none' });\n        let lastOrientation = [1, 0, 0];\n        let lastPosition = [0, 0, 0];\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n            const orientation = [\n                inputBuffer.getChannelData(0)[0],\n                inputBuffer.getChannelData(1)[0],\n                inputBuffer.getChannelData(2)[0]\n            ];\n            if (orientation.some((value, index) => (value !== lastOrientation[index]))) {\n                pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation\n                lastOrientation = orientation;\n            }\n            const positon = [\n                inputBuffer.getChannelData(6)[0],\n                inputBuffer.getChannelData(7)[0],\n                inputBuffer.getChannelData(8)[0]\n            ];\n            if (positon.some((value, index) => (value !== lastPosition[index]))) {\n                pannerNode.setPosition(...positon); // tslint:disable-line:deprecation\n                lastPosition = positon;\n            }\n        };\n        inputGainNode.connect(pannerNode);\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n        waveShaperNode.connect(orientationXGainNode);\n        waveShaperNode.connect(orientationYGainNode);\n        waveShaperNode.connect(orientationZGainNode);\n        waveShaperNode.connect(positionXGainNode);\n        waveShaperNode.connect(positionYGainNode);\n        waveShaperNode.connect(positionZGainNode);\n        orientationXGainNode.connect(channelMergerNode);\n        orientationYGainNode.connect(channelMergerNode);\n        orientationZGainNode.connect(channelMergerNode);\n        positionXGainNode.connect(channelMergerNode);\n        positionYGainNode.connect(channelMergerNode);\n        positionZGainNode.connect(channelMergerNode);\n        channelMergerNode.connect(scriptProcessorNode);\n        Object.defineProperty(orientationYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(orientationZGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionXGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionZGainNode.gain, 'defaultValue', { get: () => 0 });\n        const nativePannerNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return pannerNode.channelCount;\n            },\n            set channelCount(value) {\n                // Bug #125: Safari does not throw an error yet.\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCount = value;\n                pannerNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return pannerNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                // Bug #126: Safari does not throw an error yet.\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCountMode = value;\n                pannerNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return pannerNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                pannerNode.channelInterpretation = value;\n            },\n            get coneInnerAngle() {\n                return pannerNode.coneInnerAngle;\n            },\n            set coneInnerAngle(value) {\n                pannerNode.coneInnerAngle = value;\n            },\n            get coneOuterAngle() {\n                return pannerNode.coneOuterAngle;\n            },\n            set coneOuterAngle(value) {\n                pannerNode.coneOuterAngle = value;\n            },\n            get coneOuterGain() {\n                return pannerNode.coneOuterGain;\n            },\n            set coneOuterGain(value) {\n                // Bug #127: Edge & Safari do not throw an InvalidStateError yet.\n                if (value < 0 || value > 1) {\n                    throw createInvalidStateError();\n                }\n                pannerNode.coneOuterGain = value;\n            },\n            get context() {\n                return pannerNode.context;\n            },\n            get distanceModel() {\n                return pannerNode.distanceModel;\n            },\n            set distanceModel(value) {\n                pannerNode.distanceModel = value;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get maxDistance() {\n                return pannerNode.maxDistance;\n            },\n            set maxDistance(value) {\n                // Bug #128: Edge & Safari do not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.maxDistance = value;\n            },\n            get numberOfInputs() {\n                return pannerNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return pannerNode.numberOfOutputs;\n            },\n            get orientationX() {\n                return orientationXGainNode.gain;\n            },\n            get orientationY() {\n                return orientationYGainNode.gain;\n            },\n            get orientationZ() {\n                return orientationZGainNode.gain;\n            },\n            get panningModel() {\n                return pannerNode.panningModel;\n            },\n            set panningModel(value) {\n                pannerNode.panningModel = value;\n                // Bug #123: Edge does not support HRTF as panningModel.\n                if (pannerNode.panningModel !== value && value === 'HRTF') {\n                    throw createNotSupportedError();\n                }\n            },\n            get positionX() {\n                return positionXGainNode.gain;\n            },\n            get positionY() {\n                return positionYGainNode.gain;\n            },\n            get positionZ() {\n                return positionZGainNode.gain;\n            },\n            get refDistance() {\n                return pannerNode.refDistance;\n            },\n            set refDistance(value) {\n                // Bug #129: Edge & Safari do not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.refDistance = value;\n            },\n            get rolloffFactor() {\n                return pannerNode.rolloffFactor;\n            },\n            set rolloffFactor(value) {\n                // Bug #130: Edge & Safari do not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n                pannerNode.rolloffFactor = value;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n            nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n        }\n        if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n            nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n        }\n        if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n            nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n        }\n        if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n            nativePannerNodeFaker.distanceModel = distanceModel;\n        }\n        if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n            nativePannerNodeFaker.maxDistance = maxDistance;\n        }\n        if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n            nativePannerNodeFaker.orientationX.value = orientationX;\n        }\n        if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n            nativePannerNodeFaker.orientationY.value = orientationY;\n        }\n        if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n            nativePannerNodeFaker.orientationZ.value = orientationZ;\n        }\n        if (panningModel !== nativePannerNodeFaker.panningModel) {\n            nativePannerNodeFaker.panningModel = panningModel;\n        }\n        if (positionX !== nativePannerNodeFaker.positionX.value) {\n            nativePannerNodeFaker.positionX.value = positionX;\n        }\n        if (positionY !== nativePannerNodeFaker.positionY.value) {\n            nativePannerNodeFaker.positionY.value = positionY;\n        }\n        if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n            nativePannerNodeFaker.positionZ.value = positionZ;\n        }\n        if (refDistance !== nativePannerNodeFaker.refDistance) {\n            nativePannerNodeFaker.refDistance = refDistance;\n        }\n        if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n            nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n        }\n        return interceptConnections(nativePannerNodeFaker, pannerNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-panner-node-faker-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativePannerNodeFactory = (createNativeAudioNode, createNativePannerNodeFaker) => {\n    return (nativeContext, options) => {\n        const nativePannerNode = createNativeAudioNode(nativeContext, (ntvCntxt) => ntvCntxt.createPanner());\n        // Bug #124: Edge & Safari do not support modifying the orientation and the position with AudioParams.\n        if (nativePannerNode.orientationX === undefined) {\n            return createNativePannerNodeFaker(nativeContext, options);\n        }\n        assignNativeAudioNodeOptions(nativePannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n        return nativePannerNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-panner-node-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createPannerNodeRendererFactory = (createNativePannerNode) => {\n    return () => {\n        const renderedNativePannerNodes = new WeakMap();\n        const createPannerNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativePannerNode = getNativeAudioNode(proxy);\n            // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);\n            if (!nativePannerNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativePannerNode.channelCount,\n                    channelCountMode: nativePannerNode.channelCountMode,\n                    channelInterpretation: nativePannerNode.channelInterpretation,\n                    coneInnerAngle: nativePannerNode.coneInnerAngle,\n                    coneOuterAngle: nativePannerNode.coneOuterAngle,\n                    coneOuterGain: nativePannerNode.coneOuterGain,\n                    distanceModel: nativePannerNode.distanceModel,\n                    maxDistance: nativePannerNode.maxDistance,\n                    orientationX: nativePannerNode.orientationX.value,\n                    orientationY: nativePannerNode.orientationY.value,\n                    orientationZ: nativePannerNode.orientationZ.value,\n                    panningModel: nativePannerNode.panningModel,\n                    positionX: nativePannerNode.positionX.value,\n                    positionY: nativePannerNode.positionY.value,\n                    positionZ: nativePannerNode.positionZ.value,\n                    refDistance: nativePannerNode.refDistance,\n                    rolloffFactor: nativePannerNode.rolloffFactor\n                };\n                nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativePannerNodes.set(nativeOfflineAudioContext, nativePannerNode);\n            if (!nativePannerNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.orientationX);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.orientationY);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.orientationZ);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.positionX);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.positionY);\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.positionZ);\n            }\n            if (nativePannerNode.inputs !== undefined) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode);\n            }\n            return nativePannerNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativePannerNode = renderedNativePannerNodes.get(nativeOfflineAudioContext);\n                if (renderedNativePannerNode !== undefined) {\n                    return Promise.resolve(renderedNativePannerNode);\n                }\n                return createPannerNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/panner-node-renderer-factory.js.map","export const createNativePeriodicWaveFactory = (getBackupNativeContext) => {\n    return (nativeContext, { disableNormalization, imag, real }) => {\n        // Bug #50: Only Edge does currently not allow to create AudioNodes (and other objects) on a closed context yet.\n        const backupNativeContext = getBackupNativeContext(nativeContext);\n        // @todo Edge, Firefox & Safari do only accept Float32Arrays.\n        const wrappedImag = new Float32Array(imag);\n        const wrappedReal = new Float32Array(real);\n        if (backupNativeContext !== null) {\n            return backupNativeContext.createPeriodicWave(wrappedReal, wrappedImag, { disableNormalization });\n        }\n        return nativeContext.createPeriodicWave(wrappedReal, wrappedImag, { disableNormalization });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-periodic-wave-factory.js.map","import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError) => {\n    // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n    const CURVE_SIZE = 16385;\n    const DC_CURVE = new Float32Array([1, 1]);\n    const HALF_PI = Math.PI / 2;\n    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete' };\n    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: 'none' };\n    const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            const x = (i / (CURVE_SIZE - 1)) * HALF_PI;\n            leftWaveShaperCurve[i] = Math.cos(x);\n            rightWaveShaperCurve[i] = Math.sin(x);\n        }\n        const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });\n        const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve });\n        inputGainNode.connect(leftGainNode);\n        inputGainNode.connect(panWaveShaperNode.inputs[0]);\n        inputGainNode.connect(rightGainNode);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightWaveShaperNode.inputs[0]);\n        leftWaveShaperNode.connect(leftGainNode.gain);\n        rightWaveShaperNode.connect(rightGainNode.gain);\n        leftGainNode.connect(channelMergerNode, 0, 0);\n        rightGainNode.connect(channelMergerNode, 0, 1);\n        return [leftGainNode, rightGainNode];\n    };\n    const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {\n        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const centerIndex = Math.floor(CURVE_SIZE / 2);\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            if (i > centerIndex) {\n                const x = ((i - centerIndex) / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n                rightInputForLeftOutputWaveShaperCurve[i] = 0;\n                rightInputForRightOutputWaveShaperCurve[i] = 1;\n            }\n            else {\n                const x = (i / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n                leftInputForLeftOutputWaveShaperCurve[i] = 1;\n                leftInputForRightOutputWaveShaperCurve[i] = 0;\n                rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            }\n        }\n        const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: 2,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: 2\n        });\n        const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftInputForLeftOutputWaveShaperCurve });\n        const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftInputForRightOutputWaveShaperCurve });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });\n        const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightInputForLeftOutputWaveShaperCurve });\n        const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightInputForRightOutputWaveShaperCurve });\n        inputGainNode.connect(channelSplitterNode);\n        inputGainNode.connect(panWaveShaperNode.inputs[0]);\n        channelSplitterNode.connect(leftInputForLeftOutputGainNode, 1);\n        channelSplitterNode.connect(leftInputForRightOutputGainNode, 1);\n        channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n        channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs[0]);\n        leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n        leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n        rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n        rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n        leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n        rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n        return [\n            leftInputForLeftOutputGainNode,\n            rightInputForLeftOutputGainNode,\n            leftInputForRightOutputGainNode,\n            rightInputForRightOutputGainNode\n        ];\n    };\n    const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {\n        if (channelCount === 1) {\n            return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        if (channelCount === 2) {\n            return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n        throw createNotSupportedError();\n    };\n    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {\n        if (channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...audioNodeOptions,\n            channelCount: 1,\n            channelCountMode,\n            numberOfInputs: 2\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });\n        const panGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: pan\n        });\n        let outputNodes = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);\n        Object.defineProperty(panGainNode.gain, 'defaultValue', { get: () => 0 });\n        const nativeStereoPannerNodeFakerFactory = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return inputGainNode.channelCount;\n            },\n            set channelCount(value) {\n                if (inputGainNode.channelCount !== value) {\n                    inputGainNode.disconnect();\n                    outputNodes.forEach((outputNode) => outputNode.disconnect());\n                    outputNodes = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode);\n                }\n                inputGainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return inputGainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                if (value === 'clamped-max' || value === 'max') {\n                    throw createNotSupportedError();\n                }\n                inputGainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return inputGainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n            },\n            get context() {\n                return inputGainNode.context;\n            },\n            get inputs() {\n                return [inputGainNode];\n            },\n            get numberOfInputs() {\n                return inputGainNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return inputGainNode.numberOfOutputs;\n            },\n            get pan() {\n                return panGainNode.gain;\n            },\n            addEventListener(...args) {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        return interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-stereo-panner-node-faker-factory.js.map","import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nexport const createNativeStereoPannerNodeFactory = (createNativeAudioNode, createNativeStereoPannerNodeFaker, createNotSupportedError) => {\n    return (nativeContext, options) => createNativeAudioNode(nativeContext, (ntvCntxt) => {\n        const channelCountMode = options.channelCountMode;\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        if (channelCountMode === 'clamped-max') {\n            throw createNotSupportedError();\n        }\n        // Bug #105: Safari does not support the StereoPannerNode.\n        if (nativeContext.createStereoPanner === undefined) {\n            return createNativeStereoPannerNodeFaker(nativeContext, options);\n        }\n        const nativeStereoPannerNode = ntvCntxt.createStereoPanner();\n        assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n        assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n            get: () => channelCountMode,\n            set: (value) => {\n                if (value !== channelCountMode) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n        return nativeStereoPannerNode;\n    });\n};\n//# sourceMappingURL=/build/es2018/factories/native-stereo-panner-node-factory.js.map","import { connectAudioParam } from '../helpers/connect-audio-param';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderAutomation } from '../helpers/render-automation';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createStereoPannerNodeRendererFactory = (createNativeStereoPannerNode) => {\n    return () => {\n        const renderedNativeStereoPannerNodes = new WeakMap();\n        const createStereoPannerNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeStereoPannerNode = getNativeAudioNode(proxy);\n            /*\n             * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeStereoPannerNode.channelCount,\n                    channelCountMode: nativeStereoPannerNode.channelCountMode,\n                    channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n                    pan: nativeStereoPannerNode.pan.value\n                };\n                nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                await renderAutomation(proxy.context, nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n            }\n            else {\n                await connectAudioParam(proxy.context, nativeOfflineAudioContext, proxy.pan);\n            }\n            if (nativeStereoPannerNode.inputs !== undefined) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);\n            }\n            return nativeStereoPannerNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeStereoPannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeStereoPannerNode);\n                }\n                return createStereoPannerNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/stereo-panner-node-renderer-factory.js.map","import { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';\nexport const createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode) => {\n    return () => {\n        const renderedNativeWaveShaperNodes = new WeakMap();\n        const createWaveShaperNode = async (proxy, nativeOfflineAudioContext) => {\n            let nativeWaveShaperNode = getNativeAudioNode(proxy);\n            // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n            if (!nativeWaveShaperNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeWaveShaperNode.channelCount,\n                    channelCountMode: nativeWaveShaperNode.channelCountMode,\n                    channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                    curve: nativeWaveShaperNode.curve,\n                    oversample: nativeWaveShaperNode.oversample\n                };\n                nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n            }\n            renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n            if (nativeWaveShaperNode.inputs !== undefined) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);\n            }\n            else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);\n            }\n            return nativeWaveShaperNode;\n        };\n        return {\n            render(proxy, nativeOfflineAudioContext) {\n                const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n                if (renderedNativeWaveShaperNode !== undefined) {\n                    return Promise.resolve(renderedNativeWaveShaperNode);\n                }\n                return createWaveShaperNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/wave-shaper-node-renderer-factory.js.map","export const createIsSecureContext = (window) => (window !== null && window.isSecureContext);\n//# sourceMappingURL=/build/es2018/factories/is-secure-context.js.map","export const createExposeCurrentFrameAndCurrentTime = (window) => {\n    return (nativeContext, fn) => {\n        Object.defineProperties(window, {\n            currentFrame: {\n                configurable: true,\n                get() {\n                    return Math.round(nativeContext.currentTime * nativeContext.sampleRate);\n                }\n            },\n            currentTime: {\n                configurable: true,\n                get() {\n                    return nativeContext.currentTime;\n                }\n            }\n        });\n        try {\n            return fn();\n        }\n        finally {\n            if (window !== null) {\n                delete window.currentFrame;\n                delete window.currentTime;\n            }\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/expose-current-frame-and-current-time.js.map","export const evaluateSource = (source) => {\n    return new Promise((resolve, reject) => {\n        const head = document.head;\n        if (head === null) {\n            reject(new SyntaxError());\n        }\n        else {\n            const script = document.createElement('script');\n            // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n            const blob = new Blob([source], { type: 'application/javascript' });\n            const url = URL.createObjectURL(blob);\n            const originalOnErrorHandler = window.onerror;\n            const removeErrorEventListenerAndRevokeUrl = () => {\n                window.onerror = originalOnErrorHandler;\n                URL.revokeObjectURL(url);\n            };\n            window.onerror = (message, src, lineno, colno, error) => {\n                // @todo Edge thinks the source is the one of the html document.\n                if (src === url || (src === location.href && lineno === 1 && colno === 1)) {\n                    removeErrorEventListenerAndRevokeUrl();\n                    reject(error);\n                    return false;\n                }\n                if (originalOnErrorHandler !== null) {\n                    return originalOnErrorHandler(message, src, lineno, colno, error);\n                }\n            };\n            script.onerror = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                reject(new SyntaxError());\n            };\n            script.onload = () => {\n                removeErrorEventListenerAndRevokeUrl();\n                resolve();\n            };\n            script.src = url;\n            script.type = 'module';\n            head.appendChild(script);\n        }\n    });\n};\n//# sourceMappingURL=/build/es2018/helpers/evaluate-source.js.map","export const createFetchSource = (createAbortError) => {\n    return async (url) => {\n        try {\n            const response = await fetch(url);\n            if (response.ok) {\n                return response.text();\n            }\n        }\n        catch ( /* Ignore errors. */_a) { /* Ignore errors. */ } // tslint:disable-line:no-empty\n        throw createAbortError();\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/fetch-source.js.map","export const createIsNativeAudioContext = (nativeAudioContextConstructor) => {\n    return (anything) => {\n        return (nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-native-audio-context.js.map","export const createIsNativeContext = (isNativeAudioContext, isNativeOfflineAudioContext) => {\n    return (anything) => {\n        return (isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything));\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-native-context.js.map","export const createBaseAudioContextConstructor = (addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor) => {\n    return class BaseAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(_nativeContext, numberOfChannels) {\n            super(_nativeContext, numberOfChannels);\n            this._nativeContext = _nativeContext;\n            this._audioWorklet = (addAudioWorkletModule === undefined) ?\n                undefined :\n                { addModule: (moduleURL, options) => addAudioWorkletModule(this, moduleURL, options) };\n        }\n        get audioWorklet() {\n            return this._audioWorklet;\n        }\n        createAnalyser() {\n            return new analyserNodeConstructor(this);\n        }\n        createBiquadFilter() {\n            return new biquadFilterNodeConstructor(this);\n        }\n        createBuffer(numberOfChannels, length, sampleRate) {\n            return new audioBufferConstructor({ length, numberOfChannels, sampleRate });\n        }\n        createBufferSource() {\n            return new audioBufferSourceNodeConstructor(this);\n        }\n        createChannelMerger(numberOfInputs = 6) {\n            return new channelMergerNodeConstructor(this, { numberOfInputs });\n        }\n        createChannelSplitter(numberOfOutputs = 6) {\n            return new channelSplitterNodeConstructor(this, { numberOfOutputs });\n        }\n        createConstantSource() {\n            return new constantSourceNodeConstructor(this);\n        }\n        createConvolver() {\n            return new convolverNodeConstructor(this);\n        }\n        createDelay(maxDelayTime = 1) {\n            return new delayNodeConstructor(this, { maxDelayTime });\n        }\n        createDynamicsCompressor() {\n            return new dynamicsCompressorNodeConstructor(this);\n        }\n        createGain() {\n            return new gainNodeConstructor(this);\n        }\n        createIIRFilter(feedforward, feedback) {\n            return new iIRFilterNodeConstructor(this, { feedback, feedforward });\n        }\n        createOscillator() {\n            return new oscillatorNodeConstructor(this);\n        }\n        createPanner() {\n            return new pannerNodeConstructor(this);\n        }\n        createPeriodicWave(real, imag, constraints = { disableNormalization: false }) {\n            return new periodicWaveConstructor(this, { ...constraints, imag, real });\n        }\n        createStereoPanner() {\n            return new stereoPannerNodeConstructor(this);\n        }\n        createWaveShaper() {\n            return new waveShaperNodeConstructor(this);\n        }\n        decodeAudioData(audioData, successCallback, errorCallback) {\n            return decodeAudioData(this._nativeContext, audioData)\n                .then((audioBuffer) => {\n                if (typeof successCallback === 'function') {\n                    successCallback(audioBuffer);\n                }\n                return audioBuffer;\n            })\n                .catch((err) => {\n                if (typeof errorCallback === 'function') {\n                    errorCallback(err);\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/base-audio-context-constructor.js.map","import { DETACHED_ARRAY_BUFFERS } from '../globals';\nimport { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { getNativeContext } from '../helpers/get-native-context';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createDecodeAudioData = (audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, nativeOfflineAudioContextConstructor, isNativeContext, isNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testAudioBufferCopyChannelMethodsSubarraySupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds, wrapAudioBufferCopyChannelMethodsSubarray) => {\n    return (anyContext, audioData) => {\n        const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n        // Bug #43: Only Chrome and Opera do throw a DataCloneError.\n        if (DETACHED_ARRAY_BUFFERS.has(audioData)) {\n            const err = createDataCloneError();\n            return Promise.reject(err);\n        }\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n            DETACHED_ARRAY_BUFFERS.add(audioData);\n        }\n        catch (_a) {\n            // Ignore errors.\n        }\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n            // Bug #101: Edge does not decode something on a closed OfflineAudioContext.\n            const nativeContextOrBackupNativeContext = (nativeContext.state === 'closed' &&\n                nativeOfflineAudioContextConstructor !== null &&\n                isNativeOfflineAudioContext(nativeContext)) ?\n                new nativeOfflineAudioContextConstructor(1, 1, nativeContext.sampleRate) :\n                nativeContext;\n            const promise = nativeContextOrBackupNativeContext\n                .decodeAudioData(audioData)\n                .catch((err) => {\n                // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.\n                if (err instanceof DOMException && err.name === 'NotSupportedError') {\n                    throw new TypeError();\n                }\n                throw err;\n            });\n            return promise\n                .then((audioBuffer) => {\n                // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().\n                if (!cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, () => testAudioBufferCopyChannelMethodsSubarraySupport(audioBuffer))) {\n                    wrapAudioBufferCopyChannelMethodsSubarray(audioBuffer);\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                    // Bug #157: No browser does allow the bufferOffset to be out-of-bounds.\n                }\n                else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n                audioBufferStore.add(audioBuffer);\n                return audioBuffer;\n            });\n        }\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise((resolve, reject) => {\n            const complete = () => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                try {\n                    detachArrayBuffer(audioData);\n                }\n                catch ( /* Ignore errors. */_a) { /* Ignore errors. */ }\n            };\n            const fail = (err) => {\n                reject(err);\n                complete();\n            };\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                // Bug #1: Safari requires a successCallback.\n                nativeContext.decodeAudioData(audioData, (audioBuffer) => {\n                    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                    // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                    if (typeof audioBuffer.copyFromChannel !== 'function') {\n                        wrapAudioBufferCopyChannelMethods(audioBuffer);\n                        wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                    }\n                    audioBufferStore.add(audioBuffer);\n                    complete();\n                    resolve(audioBuffer);\n                }, (err) => {\n                    // Bug #4: Safari returns null instead of an error.\n                    if (err === null) {\n                        fail(createEncodingError());\n                    }\n                    else {\n                        fail(err);\n                    }\n                });\n            }\n            catch (err) {\n                fail(err);\n            }\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/decode-audio-data.js.map","export const detachArrayBuffer = (arrayBuffer) => {\n    const { port1 } = new MessageChannel();\n    port1.postMessage(arrayBuffer, [arrayBuffer]);\n};\n//# sourceMappingURL=/build/es2018/helpers/detach-array-buffer.js.map","export const createDataCloneError = () => {\n    try {\n        return new DOMException('', 'DataCloneError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 25;\n        err.name = 'DataCloneError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/data-clone-error.js.map","export const createEncodingError = () => {\n    try {\n        return new DOMException('', 'EncodingError');\n    }\n    catch (err) {\n        // Bug #122: Edge is the only browser that does not yet allow to construct a DOMException.\n        err.code = 0;\n        err.name = 'EncodingError';\n        return err;\n    }\n};\n//# sourceMappingURL=/build/es2018/factories/encoding-error.js.map","import { getNativeContext } from '../helpers/get-native-context';\nexport const createMediaElementAudioSourceNodeConstructor = (createNativeMediaElementAudioSourceNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class MediaElementAudioSourceNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw createNotSupportedError();\n            }\n            const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options);\n            super(context, 'active', nativeMediaElementAudioSourceNode, null);\n            // Bug #63: Edge & Firefox do not expose the mediaElement yet.\n            this._mediaElement = options.mediaElement;\n            this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n        }\n        get mediaElement() {\n            return (this._nativeMediaElementAudioSourceNode.mediaElement === undefined) ?\n                this._mediaElement :\n                this._nativeMediaElementAudioSourceNode.mediaElement;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/media-element-audio-source-node-constructor.js.map","export const createNativeMediaElementAudioSourceNodeFactory = (createNativeAudioNode) => {\n    return (nativeAudioContext, options) => createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n        return ntvDCntxt.createMediaElementSource(options.mediaElement);\n    });\n};\n//# sourceMappingURL=/build/es2018/factories/native-media-element-audio-source-node-factory.js.map","import { getNativeContext } from '../helpers/get-native-context';\nexport const createMediaStreamAudioSourceNodeConstructor = (createNativeMediaStreamAudioSourceNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class MediaStreamAudioSourceNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw createNotSupportedError();\n            }\n            const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options);\n            super(context, 'active', nativeMediaStreamAudioSourceNode, null);\n            this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n        }\n        get mediaStream() {\n            return this._nativeMediaStreamAudioSourceNode.mediaStream;\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/media-stream-audio-source-node-constructor.js.map","export const createNativeMediaStreamAudioSourceNodeFactory = (createInvalidStateError, createNativeAudioNode) => {\n    return (nativeAudioContext, { mediaStream }) => {\n        const audioStreamTracks = mediaStream.getAudioTracks();\n        const nativeMediaStreamAudioSourceNode = createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n            /*\n             * Bug #151: Firefox does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n             * Bug #159: Chrome and Firefox pick the first audio track if the MediaStream has more than one audio track.\n             */\n            const filteredAudioStreamTracks = audioStreamTracks\n                .sort((a, b) => ((a.id < b.id) ? -1 : (a.id > b.id) ? 1 : 0))\n                .slice(0, 1);\n            return ntvDCntxt.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n        });\n        // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n        if (audioStreamTracks.length === 0) {\n            throw createInvalidStateError();\n        }\n        // Bug #63: Edge & Firefox do not expose the mediaStream yet.\n        Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', { value: mediaStream });\n        return nativeMediaStreamAudioSourceNode;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-media-stream-audio-source-node-factory.js.map","import { getNativeContext } from '../helpers/get-native-context';\nexport const createMediaStreamTrackAudioSourceNodeConstructor = (createNativeMediaStreamTrackAudioSourceNode, createNotSupportedError, isNativeOfflineAudioContext, noneAudioDestinationNodeConstructor) => {\n    return class MediaStreamTrackAudioSourceNode extends noneAudioDestinationNodeConstructor {\n        constructor(context, options) {\n            const nativeContext = getNativeContext(context);\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw createNotSupportedError();\n            }\n            const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n            super(context, 'active', nativeMediaStreamTrackAudioSourceNode, null);\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/media-stream-track-audio-source-node-constructor.js.map","export const createNativeMediaStreamTrackAudioSourceNodeFactory = (createInvalidStateError, createNativeAudioNode) => {\n    return (nativeAudioContext, { mediaStreamTrack }) => {\n        if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n            return createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => ntvDCntxt.createMediaStreamTrackSource(mediaStreamTrack));\n        }\n        // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n        return createNativeAudioNode(nativeAudioContext, (ntvDCntxt) => {\n            const mediaStream = new MediaStream([mediaStreamTrack]);\n            const nativeMediaStreamAudioSourceNode = ntvDCntxt.createMediaStreamSource(mediaStream);\n            // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n            if (mediaStreamTrack.kind !== 'audio') {\n                throw createInvalidStateError();\n            }\n            return nativeMediaStreamAudioSourceNode;\n        });\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-media-stream-track-audio-source-node-factory.js.map","import { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createAudioContextConstructor = (baseAudioContextConstructor, createInvalidStateError, createNotSupportedError, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor) => {\n    return class AudioContext extends baseAudioContextConstructor {\n        constructor(options = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n            const nativeAudioContext = new nativeAudioContextConstructor(options);\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n            // Bug #51 Only Chrome and Opera throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n            }\n            // Bug #150 Only Chrome, Firefox and Opera support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n            super(nativeAudioContext, nativeAudioContext.destination.channelCount);\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency = (typeof nativeAudioContext.baseLatency === 'number')\n                ? nativeAudioContext.baseLatency\n                : (latencyHint === 'balanced')\n                    ? (512 / sampleRate)\n                    : (latencyHint === 'interactive' || latencyHint === undefined)\n                        ? (256 / sampleRate)\n                        : (latencyHint === 'playback')\n                            ? (1024 / sampleRate)\n                            /*\n                             * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                             * ScriptProcessorNode.\n                             */\n                            : ((Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate);\n            this._nativeAudioContext = nativeAudioContext;\n            this._state = null;\n            /*\n             * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n        get baseLatency() {\n            return this._baseLatency;\n        }\n        get state() {\n            return (this._state !== null) ? this._state : this._nativeAudioContext.state;\n        }\n        close() {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext\n                    .close()\n                    .then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n            return this._nativeAudioContext.close();\n            /*\n             * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n             * ...then(() => deleteAudioGraph(this, this._nativeAudioContext));\n             */\n        }\n        createMediaElementSource(mediaElement) {\n            return new mediaElementAudioSourceNodeConstructor(this, { mediaElement });\n        }\n        createMediaStreamSource(mediaStream) {\n            return new mediaStreamAudioSourceNodeConstructor(this, { mediaStream });\n        }\n        createMediaStreamTrackSource(mediaStreamTrack) {\n            return new mediaStreamTrackAudioSourceNodeConstructor(this, { mediaStreamTrack });\n        }\n        resume() {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        }\n                        else {\n                            this\n                                .resume()\n                                .then(resolve, reject);\n                        }\n                    };\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n            return this._nativeAudioContext\n                .resume()\n                .catch((err) => {\n                // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n        suspend() {\n            return this._nativeAudioContext\n                .suspend()\n                .catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/audio-context-constructor.js.map","import { isNativeAudioNode } from '../guards/native-audio-node';\nexport const createConnectMultipleOutputs = (createIndexSizeError) => {\n    return (outputAudioNodes, destination, output = 0, input = 0) => {\n        const outputAudioNode = outputAudioNodes[output];\n        if (outputAudioNode === undefined) {\n            throw createIndexSizeError();\n        }\n        if (isNativeAudioNode(destination)) {\n            return outputAudioNode.connect(destination, 0, input);\n        }\n        return outputAudioNode.connect(destination, 0);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/connect-multiple-outputs.js.map","import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { AUXILIARY_GAIN_NODE_STORE } from '../globals';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { ReadOnlyMap } from '../read-only-map';\nexport const createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n        if (options.outputChannelCount !== undefined) {\n            if (options.outputChannelCount.length !== options.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n            // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n            if (options.outputChannelCount.some((channelCount) => (channelCount < 1))) {\n                throw createNotSupportedError();\n            }\n        }\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = options.outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters = (processorConstructor.parameterDescriptors === undefined)\n            ? 0\n            : processorConstructor.parameterDescriptors.length;\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n        const messageChannel = new MessageChannel();\n        const gainNodes = [];\n        const inputChannelSplitterNodes = [];\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(createNativeGainNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: options.channelCountMode,\n                channelInterpretation: options.channelInterpretation,\n                gain: 1\n            }));\n            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext, {\n                channelCount: options.channelCount,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                numberOfOutputs: options.channelCount\n            }));\n        }\n        const constantSourceNodes = [];\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: (options.parameterData[name] !== undefined)\n                        ? options.parameterData[name]\n                        : (defaultValue === undefined)\n                            ? 0\n                            : defaultValue\n                });\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined) ? 0 : defaultValue\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined) ? MOST_POSITIVE_SINGLE_FLOAT : maxValue\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined) ? MOST_NEGATIVE_SINGLE_FLOAT : minValue\n                    }\n                });\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, numberOfInputChannels + numberOfParameters, \n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        Math.max(1, numberOfOutputChannels));\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes = [];\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: options.outputChannelCount[i]\n            }));\n        }\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, (i * options.channelCount) + j);\n            }\n        }\n        const parameterMap = new ReadOnlyMap((processorConstructor.parameterDescriptors === undefined)\n            ? []\n            : processorConstructor.parameterDescriptors\n                .map(({ name }, index) => {\n                const constantSourceNode = constantSourceNodes[index];\n                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                constantSourceNode.start(0);\n                return [name, constantSourceNode.offset];\n            }));\n        inputChannelMergerNode.connect(scriptProcessorNode);\n        if (options.numberOfOutputs > 0) {\n            scriptProcessorNode.connect(outputChannelSplitterNode);\n        }\n        for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n            const outputChannelMergerNode = outputChannelMergerNodes[i];\n            for (let j = 0; j < options.outputChannelCount[i]; j += 1) {\n                outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n            }\n            outputChannelSplitterNodeOutput += options.outputChannelCount[i];\n        }\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror = null;\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = (options.numberOfOutputs === 0) ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize() {\n                return bufferSize;\n            },\n            get channelCount() {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode() {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation() {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n                channelInterpretation = value;\n            },\n            get context() {\n                return scriptProcessorNode.context;\n            },\n            get inputs() {\n                return gainNodes;\n            },\n            get numberOfInputs() {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror() {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n                onprocessorerror = (typeof value === 'function') ? value : null;\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters() {\n                return parameterMap;\n            },\n            get port() {\n                return messageChannel.port2;\n            },\n            addEventListener(...args) {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args) {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n        const patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener = (typeof args[1] === 'function')\n                        ? args[1]\n                        : (typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function')\n                            ? args[1].handleEvent\n                            : null;\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n                        if (patchedEventListener !== undefined) {\n                            args[1] = patchedEventListener;\n                        }\n                        else {\n                            args[1] = (event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext, () => unpatchedEventListener(event));\n                            };\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args) => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n                        args[1] = patchedEventListener;\n                    }\n                }\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n        let onmessage = null;\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n                onmessage = (typeof value === 'function') ? value : null;\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n        processorConstructor.prototype.port = messageChannel.port1;\n        let audioWorkletProcessor = null;\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);\n        audioWorkletProcessorPromise\n            .then((dWrkltPrcssr) => audioWorkletProcessor = dWrkltPrcssr);\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);\n        const parameters = (processorConstructor.parameterDescriptors === undefined) ?\n            [] :\n            processorConstructor.parameterDescriptors\n                .reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});\n        let isActive = true;\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {\n            if (audioWorkletProcessor !== null) {\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n                    try {\n                        const potentiallyEmptyInputs = inputs\n                            .map((input, index) => {\n                            const auxiliaryGainNodes = AUXILIARY_GAIN_NODE_STORE.get(nativeAudioWorkletNodeFaker);\n                            if (auxiliaryGainNodes === undefined || auxiliaryGainNodes.get(index) === undefined) {\n                                return [new Float32Array(0)];\n                            }\n                            return input;\n                        });\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(nativeContext, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));\n                        isActive = activeSourceFlag;\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < options.outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n                            outputChannelSplitterNodeOutput += options.outputChannelCount[j];\n                        }\n                    }\n                    catch (error) {\n                        isActive = false;\n                        nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent('processorerror', { error }));\n                    }\n                    if (!isActive) {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        break;\n                    }\n                }\n            }\n        };\n        return nativeAudioWorkletNodeFaker;\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-worklet-node-faker-factory.js.map","import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { createAudioWorkletProcessorPromise } from './create-audio-worklet-processor-promise';\nexport const createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {\n    let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n    if (nodeToProcessorMap === undefined) {\n        nodeToProcessorMap = new WeakMap();\n        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n    }\n    const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n    nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n    return audioWorkletProcessorPromise;\n};\n//# sourceMappingURL=/build/es2018/helpers/create-audio-worklet-processor.js.map","import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nexport const createNativeAudioWorkletNodeFactory = (createInvalidStateError, createNativeAudioNode, createNativeAudioWorkletNodeFaker, createNotSupportedError, isNativeOfflineAudioContext) => {\n    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            try {\n                // Bug #86: Chrome Canary does not invoke the process() function if the corresponding AudioWorkletNode has no output.\n                const nativeAudioWorkletNode = createNativeAudioNode(nativeContext, (ntvCntxt) => {\n                    return (isNativeOfflineAudioContext(ntvCntxt) && options.numberOfInputs !== 0 && options.numberOfOutputs === 0) ?\n                        new nativeAudioWorkletNodeConstructor(ntvCntxt, name, {\n                            ...options,\n                            numberOfOutputs: 1,\n                            outputChannelCount: [1],\n                            parameterData: { ...options.parameterData, hasNoOutput: 1 }\n                        }) :\n                        new nativeAudioWorkletNodeConstructor(ntvCntxt, name, options);\n                });\n                const patchedEventListeners = new Map(); // tslint:disable-line:max-line-length\n                let onprocessorerror = null;\n                Object.defineProperties(nativeAudioWorkletNode, {\n                    /*\n                     * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n                     * browsers have no native implementation to achieve a consistent behavior.\n                     */\n                    channelCount: {\n                        get: () => options.channelCount,\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    channelCountMode: {\n                        get: () => 'explicit',\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    // Bug #156: Chrome does not yet fire an ErrorEvent.\n                    onprocessorerror: {\n                        get: () => onprocessorerror,\n                        set: (value) => {\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                            }\n                            onprocessorerror = (typeof value === 'function') ? value : null;\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                            }\n                        }\n                    }\n                });\n                nativeAudioWorkletNode.addEventListener = ((addEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const unpatchedEventListener = (typeof args[1] === 'function')\n                                ? args[1]\n                                : (typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function')\n                                    ? args[1].handleEvent\n                                    : null;\n                            if (unpatchedEventListener !== null) {\n                                const patchedEventListener = patchedEventListeners.get(args[1]);\n                                if (patchedEventListener !== undefined) {\n                                    args[1] = patchedEventListener;\n                                }\n                                else {\n                                    args[1] = (event) => {\n                                        unpatchedEventListener(new ErrorEvent(args[0], { ...event, error: new Error( /* @todo */) }));\n                                    };\n                                    patchedEventListeners.set(unpatchedEventListener, args[1]);\n                                }\n                            }\n                        }\n                        return addEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.addEventListener);\n                nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {\n                    return (...args) => {\n                        if (args[0] === 'processorerror') {\n                            const patchedEventListener = patchedEventListeners.get(args[1]);\n                            if (patchedEventListener !== undefined) {\n                                patchedEventListeners.delete(args[1]);\n                                args[1] = patchedEventListener;\n                            }\n                        }\n                        return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.removeEventListener);\n                return nativeAudioWorkletNode;\n            }\n            catch (err) {\n                // Bug #60: Chrome Canary throws an InvalidStateError instead of a NotSupportedError.\n                if (err.code === 11) {\n                    throw createNotSupportedError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            }\n        }\n        // Bug #61: Only Chrome & Opera have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n            throw createNotSupportedError();\n        }\n        testClonabilityOfAudioWorkletNodeOptions(options);\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-worklet-node-factory.js.map","export const testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {\n    const { port1 } = new MessageChannel();\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    }\n    finally {\n        port1.close();\n    }\n};\n//# sourceMappingURL=/build/es2018/helpers/test-clonability-of-audio-worklet-node-options.js.map","export const createNativeAudioWorkletNodeConstructor = (window) => {\n    if (window === null) {\n        return null;\n    }\n    return (window.hasOwnProperty('AudioWorkletNode')) ? window.AudioWorkletNode : null;\n};\n//# sourceMappingURL=/build/es2018/factories/native-audio-worklet-node-constructor.js.map","import { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nexport const createMinimalAudioContextConstructor = (createInvalidStateError, createNotSupportedError, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor) => {\n    return class MinimalAudioContext extends minimalBaseAudioContextConstructor {\n        constructor(options = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n            const nativeAudioContext = new nativeAudioContextConstructor(options);\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n            // Bug #51 Only Chrome and Opera throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);\n            }\n            // Bug #150 Only Chrome, Firefox and Opera support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n            super(nativeAudioContext, nativeAudioContext.destination.channelCount);\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency = (typeof nativeAudioContext.baseLatency === 'number')\n                ? nativeAudioContext.baseLatency\n                : (latencyHint === 'balanced')\n                    ? (512 / sampleRate)\n                    : (latencyHint === 'interactive' || latencyHint === undefined)\n                        ? (256 / sampleRate)\n                        : (latencyHint === 'playback')\n                            ? (1024 / sampleRate)\n                            /*\n                             * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                             * ScriptProcessorNode.\n                             */\n                            : ((Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate);\n            this._nativeAudioContext = nativeAudioContext;\n            this._state = null;\n            /*\n             * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually\n             * changes to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n        get baseLatency() {\n            return this._baseLatency;\n        }\n        get state() {\n            return (this._state !== null) ? this._state : this._nativeAudioContext.state;\n        }\n        close() {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext\n                    .close()\n                    .then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n            return this._nativeAudioContext.close();\n            /*\n             * Bug #50: Deleting the AudioGraph is currently not possible anymore.\n             * ...then(() => deleteAudioGraph(this, this._nativeAudioContext));\n             */\n        }\n        resume() {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        }\n                        else {\n                            this\n                                .resume()\n                                .then(resolve, reject);\n                        }\n                    };\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n            return this._nativeAudioContext\n                .resume()\n                .catch((err) => {\n                // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n        suspend() {\n            return this._nativeAudioContext\n                .suspend()\n                .catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n                throw err; // tslint:disable-line:rxjs-throw-error\n            });\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/minimal-audio-context-constructor.js.map","export const createCreateNativeOfflineAudioContext = (createNotSupportedError, nativeOfflineAudioContextConstructor) => {\n    return (numberOfChannels, length, sampleRate) => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n        try {\n            return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n        }\n        catch (err) {\n            // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n            // Bug #143: Edge throws a SyntaxError when numberOfChannels or length are invalid.\n            // Bug #145: Edge throws an IndexSizeError when sampleRate is zero.\n            if (err.name === 'IndexSizeError' || err.name === 'SyntaxError') {\n                throw createNotSupportedError();\n            }\n            throw err; // tslint:disable-line:rxjs-throw-error\n        }\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/create-native-offline-audio-context.js.map","import { getAudioNodeRenderer } from '../helpers/get-audio-node-renderer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nexport const createStartRendering = (audioBufferStore, cacheTestResult, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testAudioBufferCopyChannelMethodsSubarraySupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds, wrapAudioBufferCopyChannelMethodsSubarray) => {\n    return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer(destination)\n        .render(destination, nativeOfflineAudioContext)\n        .then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext))\n        .then((audioBuffer) => {\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n        if (typeof audioBuffer.copyFromChannel !== 'function') {\n            wrapAudioBufferCopyChannelMethods(audioBuffer);\n            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n            // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().\n        }\n        else if (!cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, () => testAudioBufferCopyChannelMethodsSubarraySupport(audioBuffer))) {\n            wrapAudioBufferCopyChannelMethodsSubarray(audioBuffer);\n            wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            // Bug #157: No browser does allow the bufferOffset to be out-of-bounds.\n        }\n        else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {\n            wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n        }\n        audioBufferStore.add(audioBuffer);\n        return audioBuffer;\n    });\n};\n//# sourceMappingURL=/build/es2018/factories/start-rendering.js.map","export const createIsAnyAudioContext = (contextStore, isNativeAudioContext) => {\n    return (anything) => {\n        const nativeContext = contextStore.get(anything);\n        return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-any-audio-context.js.map","export const createIsAnyAudioNode = (audioNodeStore, isNativeAudioNode) => {\n    return (anything) => audioNodeStore.has(anything) || isNativeAudioNode(anything);\n};\n//# sourceMappingURL=/build/es2018/factories/is-any-audio-node.js.map","export const createIsAnyAudioParam = (audioParamStore, isNativeAudioParam) => {\n    return (anything) => audioParamStore.has(anything) || isNativeAudioParam(anything);\n};\n//# sourceMappingURL=/build/es2018/factories/is-any-audio-param.js.map","export const createIsAnyOfflineAudioContext = (contextStore, isNativeOfflineAudioContext) => {\n    return (anything) => {\n        const nativeContext = contextStore.get(anything);\n        return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);\n    };\n};\n//# sourceMappingURL=/build/es2018/factories/is-any-offline-audio-context.js.map","/**\n * Assert that the statement is true, otherwise invoke an error with the given message.\n */\nexport function assert(statement: boolean, error: string): void {\n\tif (!statement) {\n\t\tthrow new Error(error);\n\t}\n}\n\n/**\n * A basic logging interface\n */\ninterface Logger {\n\tlog: (args?: any[]) => void;\n\twarn: (args?: any[]) => void;\n}\n\n/**\n * The default logger is the console\n */\nlet defaultLogger: Logger = console;\n\n/**\n * Set the logging interface\n */\nexport function setLogger(logger: Logger): void {\n\tdefaultLogger = logger;\n}\n\n/**\n * Log anything\n */\nexport function log(...args: any[]): void {\n\tdefaultLogger.log(...args);\n}\n\n/**\n * Warn anything\n */\nexport function warn(...args: any[]): void {\n\tdefaultLogger.warn(...args);\n}\n","import { Note } from \"../type/Units\";\n\n/**\n * Test if the arg is undefined\n */\nexport function isUndef(arg: any): arg is undefined {\n\treturn typeof arg === \"undefined\";\n}\n\n/**\n * Test if the arg is not undefined\n */\nexport function isDefined<T>(arg: T | undefined): arg is T {\n\treturn !isUndef(arg);\n}\n\n/**\n * Test if the arg is a function\n */\nexport function isFunction(arg: any): arg is (a: any) => any {\n\treturn typeof arg === \"function\";\n}\n\n/**\n * Test if the argument is a number.\n */\nexport function isNumber(arg: any): arg is number {\n\treturn (typeof arg === \"number\");\n}\n\n/**\n * Test if the given argument is an object literal (i.e. `{}`);\n */\nexport function isObject(arg: any): arg is object {\n\treturn (Object.prototype.toString.call(arg) === \"[object Object]\" && arg.constructor === Object);\n}\n\n/**\n * Test if the argument is a boolean.\n */\nexport function isBoolean(arg: any): arg is boolean {\n\treturn (typeof arg === \"boolean\");\n}\n\n/**\n * Test if the argument is an Array\n */\nexport function isArray(arg: any): arg is any[] {\n\treturn (Array.isArray(arg));\n}\n\n/**\n * Test if the argument is a string.\n */\nexport function isString(arg: any): arg is string {\n\treturn (typeof arg === \"string\");\n}\n\n/**\n * Test if the argument is in the form of a note in scientific pitch notation.\n * e.g. \"C4\"\n */\nexport function isNote(arg: any): arg is Note {\n\treturn isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}\n","import {\n\tAudioContext as stdAudioContext,\n\tAudioWorkletNode as stdAudioWorkletNode,\n\tOfflineAudioContext as stdOfflineAudioContext,\n} from \"standardized-audio-context\";\nimport { assert } from \"../util/Debug\";\nimport { isDefined } from \"../util/TypeCheck\";\n\n/**\n * Create a new AudioContext\n */\nfunction createAudioContext(): AudioContext {\n\treturn new stdAudioContext() as unknown as AudioContext;\n}\n\n/**\n * Create a new OfflineAudioContext\n */\nexport function createOfflineAudioContext(channels: number, length: number, sampleRate: number): OfflineAudioContext {\n\treturn new stdOfflineAudioContext(channels, length, sampleRate) as unknown as OfflineAudioContext;\n}\n\n/**\n * Either the online or offline audio context\n */\nexport type AnyAudioContext = AudioContext | OfflineAudioContext;\n\n/**\n * Interface for things that Tone.js adds to the window\n */\ninterface ToneWindow extends Window {\n\tTONE_AUDIO_CONTEXT?: AnyAudioContext;\n\tTONE_SILENCE_LOGGING?: boolean;\n\tTONE_DEBUG_CLASS?: string;\n}\n\n/**\n * A reference to the window object\n * @hidden\n */\nexport const theWindow: ToneWindow | null = typeof self === \"object\" ? self : null;\n\n/**\n * If the browser has a window object which has an AudioContext\n * @hidden\n */\nexport const hasAudioContext = theWindow &&\n\t(theWindow.hasOwnProperty(\"AudioContext\") || theWindow.hasOwnProperty(\"webkitAudioContext\"));\n\n/**\n * The global audio context which is getable and assignable through\n * getAudioContext and setAudioContext\n */\nlet globalContext: AnyAudioContext;\n\n// if it was created already, use that one\n// this enables multiple versions of Tone.js to run on the same page.\nif (theWindow && theWindow.TONE_AUDIO_CONTEXT) {\n\tglobalContext = theWindow.TONE_AUDIO_CONTEXT;\n}\n\n/**\n * Returns the default system-wide AudioContext\n */\nexport function getAudioContext(): AnyAudioContext {\n\tif (!globalContext && hasAudioContext) {\n\t\tsetAudioContext(createAudioContext());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n */\nexport function setAudioContext(context: AnyAudioContext): void {\n\tglobalContext = context;\n\tif (theWindow) {\n\t\ttheWindow.TONE_AUDIO_CONTEXT = globalContext;\n\t}\n}\n\nexport function createAudioWorkletNode(context: AnyAudioContext, name: string, options?: Partial<AudioWorkletNodeOptions>): AudioWorkletNode {\n\tassert(isDefined(stdAudioWorkletNode), \"This node only works in a secure context (https or localhost)\");\n\t// @ts-ignore\n\treturn new stdAudioWorkletNode(context, name, options);\n}\n","import { Seconds } from \"../type/Units\";\n\nexport type TickerClockSource = \"worker\" | \"timeout\" | \"offline\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n\n\t/**\n\t * Either \"worker\" or \"timeout\" or \"offline\"\n\t */\n\tprivate _type: TickerClockSource;\n\n\t/**\n\t * The update interval of the worker\n\t */\n\tprivate _updateInterval: Seconds;\n\n\t/**\n\t * The callback to invoke at regular intervals\n\t */\n\tprivate _callback: () => void;\n\n\t/**\n\t * track the callback interval\n\t */\n\tprivate _timeout!: number;\n\n\t/**\n\t * private reference to the worker\n\t */\n\tprivate _worker!: Worker;\n\n\tconstructor(callback: () => void, type: TickerClockSource, updateInterval: Seconds) {\n\n\t\tthis._callback = callback;\n\t\tthis._type = type;\n\t\tthis._updateInterval = updateInterval;\n\n\t\t// create the clock source for the first time\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Generate a web worker\n\t */\n\tprivate _createWorker(): void {\n\n\t\tconst blob = new Blob([\n\t\t\t/* javascript */`\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`\n\t\t], { type: \"text/javascript\" });\n\t\tconst blobUrl = URL.createObjectURL(blob);\n\t\tconst worker = new Worker(blobUrl);\n\n\t\tworker.onmessage = this._callback.bind(this);\n\n\t\tthis._worker = worker;\n\t}\n\n\t/**\n\t * Create a timeout loop\n\t */\n\tprivate _createTimeout(): void {\n\t\tthis._timeout = setTimeout(() => {\n\t\t\tthis._createTimeout();\n\t\t\tthis._callback();\n\t\t}, this._updateInterval * 1000);\n\t}\n\n\t/**\n\t * Create the clock source.\n\t */\n\tprivate _createClock(): void {\n\t\tif (this._type === \"worker\") {\n\t\t\ttry {\n\t\t\t\tthis._createWorker();\n\t\t\t} catch (e) {\n\t\t\t\t// workers not supported, fallback to timeout\n\t\t\t\tthis._type = \"timeout\";\n\t\t\t\tthis._createClock();\n\t\t\t}\n\t\t} else if (this._type === \"timeout\") {\n\t\t\tthis._createTimeout();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up the current clock source\n\t */\n\tprivate _disposeClock(): void {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t\tthis._timeout = 0;\n\t\t}\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\t\t\tthis._worker.onmessage = null;\n\t\t}\n\t}\n\n\t/**\n\t * The rate in seconds the ticker will update\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._updateInterval = Math.max(interval, 128 / 44100);\n\t\tif (this._type === \"worker\") {\n\t\t\tthis._worker.postMessage(Math.max(interval * 1000, 1));\n\t\t}\n\t}\n\n\t/**\n\t * The type of the ticker, either a worker or a timeout\n\t */\n\tget type(): TickerClockSource {\n\t\treturn this._type;\n\t}\n\tset type(type: TickerClockSource) {\n\t\tthis._disposeClock();\n\t\tthis._type = type;\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): void {\n\t\tthis._disposeClock();\n\t}\n}\n","import {\n\tisAnyAudioContext, isAnyAudioNode,\n\tisAnyAudioParam, isAnyOfflineAudioContext,\n} from \"standardized-audio-context\";\n\n/**\n * Test if the given value is an instanceof AudioParam\n */\nexport function isAudioParam(arg: any): arg is AudioParam {\n\treturn isAnyAudioParam(arg);\n}\n\n/**\n * Test if the given value is an instanceof AudioNode\n */\nexport function isAudioNode(arg: any): arg is AudioNode {\n\treturn isAnyAudioNode(arg);\n}\n\n/**\n * Test if the arg is instanceof an OfflineAudioContext\n */\nexport function isOfflineAudioContext(arg: any): arg is OfflineAudioContext {\n\treturn isAnyOfflineAudioContext(arg);\n}\n\n/**\n * Test if the arg is an instanceof AudioContext\n */\nexport function isAudioContext(arg: any): arg is AudioContext {\n\treturn isAnyAudioContext(arg);\n}\n\n/**\n * Test if the arg is instanceof an AudioBuffer\n */\nexport function isAudioBuffer(arg: any): arg is AudioBuffer {\n\treturn arg instanceof AudioBuffer;\n}\n","import { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n\ntype BaseToneOptions = import(\"../Tone\").BaseToneOptions;\n\n/**\n * Some objects should not be merged\n */\nfunction noCopy(key: string, arg: any): boolean {\n\treturn key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\n\n/**\n * Recursively merge an object\n * @param target the object to merge into\n * @param sources the source objects to merge\n */\nexport function deepMerge<T>(target: T): T;\nexport function deepMerge<T, U>(target: T, source1: U): T & U;\nexport function deepMerge<T, U, V>(target: T, source1: U, source2: V): T & U & V;\nexport function deepMerge<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function deepMerge(target: any, ...sources: any[]): any {\n\tif (!sources.length) {\n\t\treturn target; \n\t}\n\tconst source = sources.shift();\n\n\tif (isObject(target) && isObject(source)) {\n\t\tfor (const key in source) {\n\t\t\tif (noCopy(key, source[key])) {\n\t\t\t\ttarget[key] = source[key];\n\t\t\t} else if (isObject(source[key])) {\n\t\t\t\tif (!target[key]) {\n\t\t\t\t\tObject.assign(target, { [key]: {} }); \n\t\t\t\t}\n\t\t\t\tdeepMerge(target[key], source[key] as any);\n\t\t\t} else {\n\t\t\t\tObject.assign(target, { [key]: source[key] as any });\n\t\t\t}\n\t\t}\n\t}\n\t// @ts-ignore\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\nexport function deepEquals(arrayA: number[] | string[], arrayB: number[] | string[]): boolean {\n\treturn arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);\n}\n\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments<T extends object>(\n\tdefaults: T,\n\targsArray: IArguments,\n\tkeys: string[] = [],\n\tobjKey?: string,\n): T {\n\tconst opts: any = {};\n\tconst args = Array.from(argsArray);\n\t// if the first argument is an object and has an object key\n\tif (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n\t\t// if it's not part of the defaults\n\t\tconst partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n\t\tif (!partOfDefaults) {\n\t\t\t// merge that key\n\t\t\tdeepMerge(opts, { [objKey]: args[0] });\n\t\t\t// remove the obj key from the keys\n\t\t\tkeys.splice(keys.indexOf(objKey), 1);\n\t\t\t// shift the first argument off\n\t\t\targs.shift();\n\t\t}\n\t}\n\tif (args.length === 1 && isObject(args[0])) {\n\t\tdeepMerge(opts, args[0]);\n\t} else {\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tif (isDefined(args[i])) {\n\t\t\t\topts[keys[i]] = args[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn deepMerge(defaults, opts);\n}\n\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance<T>(instance: T): BaseToneOptions {\n\ttype ToneClass = {\n\t\tconstructor: ToneClass;\n\t\tgetDefaults: () => BaseToneOptions;\n\t} & T;\n\n\treturn (instance as ToneClass).constructor.getDefaults();\n}\n\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg<T>(given: T, fallback: T): T {\n\tif (isUndef(given)) {\n\t\treturn fallback;\n\t} else {\n\t\treturn given;\n\t}\n}\n\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject<T extends object, O extends string[]>(obj: T, omit: O): Omit<T, keyof O> {\n\tomit.forEach(prop => {\n\t\tif (Reflect.has(obj, prop)) {\n\t\t\tdelete obj[prop];\n\t\t}\n\t});\n\treturn obj;\n}\n","/**\n * Tone.js\n * @author Yotam Mann\n * @license http://opensource.org/licenses/MIT MIT License\n * @copyright 2014-2019 Yotam Mann\n */\nimport { version } from \"../version\";\nimport { theWindow } from \"./context/AudioContext\";\nimport { assert, log } from \"./util/Debug\";\n\n//-------------------------------------\n// \tTONE\n//-------------------------------------\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface BaseToneOptions {}\n\n/**\n * @class  Tone is the base class of all other classes.\n * @constructor\n */\nexport abstract class Tone {\n\n\t/**\n\t * The version number semver\n\t */\n\tstatic version: string = version;\n\n\t/**\n\t * The name of the class\n\t */\n\tprotected abstract name: string;\n\n\t/**\n\t * Returns all of the default options belonging to the class.\n\t */\n\tstatic getDefaults(): BaseToneOptions {\n\t\treturn {};\n\t}\n\n\t//-------------------------------------\n\t// \tDEBUGGING\n\t//-------------------------------------\n\n\t/**\n\t * Set this debug flag to log all events that happen in this class.\n\t */\n\tdebug: boolean = false;\n\n\t/**\n\t * Prints the outputs to the console log for debugging purposes.\n\t * Prints the contents only if either the object has a property\n\t * called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n\t * is set to the name of the class.\n\t * @example\n\t * //prints all logs originating from Tone.OscillatorNode\n\t * Tone.global.TONE_DEBUG_CLASS = \"OscillatorNode\"\n\t */\n\tprotected log(...args: any[]): void {\n\t\t// if the object is either set to debug = true\n\t\t// or if there is a string on the Tone.global.with the class name\n\t\tif (this.debug || (theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS)) {\n\t\t\tlog(this, ...args);\n\t\t}\n\t}\n\n\t/**\n\t * Assert that the statement is true, otherwise invoke the error.\n\t * @param statement\n\t * @param error The message which is passed into an Error\n\t */\n\tprotected assert(statement: boolean, error: string): void {\n\t\tassert(statement, error);\n\t}\n\n\t//-------------------------------------\n\t// \tDISPOSING\n\t//-------------------------------------\n\n\t/**\n\t * Indicates if the instance was disposed\n\t */\n\tprivate _wasDisposed: boolean = false;\n\n\t/**\n\t * disconnect and dispose.\n\t */\n\tdispose(): this {\n\t\tthis._wasDisposed = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Indicates if the instance was disposed. 'Disposing' an\n\t * instance means that all of the Web Audio nodes that were\n\t * created for the instance are disconnected and freed for garbage collection.\n\t */\n\tget disposed(): boolean {\n\t\treturn this._wasDisposed;\n\t}\n\n\t/**\n\t * Convert the class to a string\n\t * @example\n\t * const osc = new Oscillator()\n\t * osc.toString() // \"Oscillator\"\n\t */\n\ttoString(): string {\n\t\treturn this.name;\n\t}\n}\n","import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n\nexport interface EmitterEventObject {\n\t[event: string]: Array<(...args: any[]) => void>;\n}\n\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n */\nexport class Emitter<EventType extends string = string> extends Tone {\n\n\treadonly name: string = \"Emitter\";\n\n\t/**\n\t * Private container for the events\n\t */\n\tprivate _events?: EmitterEventObject;\n\n\t/**\n\t * Bind a callback to a specific event.\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\ton(event: EventType, callback: (...args: any[]) => void): this {\n\t\t// split the event\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (!this._events.hasOwnProperty(eventName)) {\n\t\t\t\tthis._events[eventName] = [];\n\t\t\t}\n\t\t\tthis._events[eventName].push(callback);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Bind a callback which is only invoked once\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\tonce(event: EventType, callback: (...args: any[]) => void): this {\n\t\tconst boundCallback = (...args: any[]) => {\n\t\t\t// invoke the callback\n\t\t\tcallback(...args);\n\t\t\t// remove the event\n\t\t\tthis.off(event, boundCallback);\n\t\t};\n\t\tthis.on(event, boundCallback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove the event listener.\n\t * @param  event     The event to stop listening to.\n\t * @param  callback  The callback which was bound to the event with Emitter.on.\n\t *                   If no callback is given, all callbacks events are removed.\n\t */\n\toff(event: EventType, callback?: (...args: any[]) => void): this {\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tif (isUndef(callback)) {\n\t\t\t\t\tthis._events[event] = [];\n\t\t\t\t} else {\n\t\t\t\t\tconst eventList = this._events[event];\n\t\t\t\t\tfor (let i = 0; i < eventList.length; i++) {\n\t\t\t\t\t\tif (eventList[i] === callback) {\n\t\t\t\t\t\t\teventList.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke all of the callbacks bound to the event\n\t * with any arguments passed in.\n\t * @param  event  The name of the event.\n\t * @param args The arguments to pass to the functions listening.\n\t */\n\temit(event, ...args: any[]): this {\n\t\tif (this._events) {\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tconst eventList = this._events[event].slice(0);\n\t\t\t\tfor (let i = 0, len = eventList.length; i < len; i++) {\n\t\t\t\t\teventList[i].apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add Emitter functions (on/off/emit) to the object\n\t */\n\tstatic mixin(constr: any): void {\n\t\t// instance._events = {};\n\t\t[\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n\t\t\tconst property = Object.getOwnPropertyDescriptor(Emitter.prototype, name) as PropertyDescriptor;\n\t\t\tObject.defineProperty(constr.prototype, name, property);\n\t\t});\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events = undefined;\n\t\treturn this;\n\t}\n}\n","/**\n * The threshold for correctness for operators. Less than one sample even \n * at very high sampling rates (e.g. `1e-6 < 1 / 192000`).\n */\nconst EPSILON = 1e-6;\n\n/**\n * Test if A is greater than B\n */\nexport function GT(a: number, b: number): boolean {\n\treturn a > b + EPSILON;\n}\n\n/**\n * Test if A is greater than or equal to B\n */\nexport function GTE(a: number, b: number): boolean {\n\treturn GT(a, b) || EQ(a, b);\n}\n\n/**\n * Test if A is less than B\n */\nexport function LT(a: number, b: number): boolean {\n\treturn a + EPSILON < b;\n}\n\n/**\n * Test if A is less than B\n */\nexport function EQ(a: number, b: number): boolean {\n\treturn Math.abs(a - b) < EPSILON;\n}\n","import { Tone } from \"../Tone\";\nimport { Seconds } from \"../type/Units\";\nimport { optionsFromArguments } from \"./Defaults\";\nimport { EQ, GT, LT } from \"./Math\";\n\ntype TimelineSearchParam = \"ticks\" | \"time\";\n\n/**\n * The options object for Timeline\n */\ninterface TimelineOptions {\n\tmemory: number;\n\tincreasing: boolean;\n}\n\n/**\n * An event must have a time number\n */\nexport interface TimelineEvent {\n\ttime: number;\n}\n\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n */\nexport class Timeline<GenericEvent extends TimelineEvent> extends Tone {\n\n\treadonly name: string = \"Timeline\";\n\n\t/**\n\t * The memory of the timeline, i.e.\n\t * how many events in the past it will retain\n\t */\n\tmemory: number;\n\n\t/**\n\t * The array of scheduled timeline events\n\t */\n\tprotected _timeline: GenericEvent[] = [];\n\n\t/**\n\t * If the time value must always be greater than or equal to the last \n\t * element on the list. \n\t */\n\tincreasing: boolean;\n\n\t/**\n\t * @param memory The number of previous events that are retained.\n\t */\n\tconstructor(memory?: number);\n\tconstructor(options?: Partial<TimelineOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n\n\t\tthis.memory = options.memory;\n\t\tthis.increasing = options.increasing;\n\t}\n\n\tstatic getDefaults(): TimelineOptions {\n\t\treturn {\n\t\t\tmemory: Infinity,\n\t\t\tincreasing: false,\n\t\t};\n\t}\n\n\t/**\n\t * The number of items in the timeline.\n\t */\n\tget length(): number {\n\t\treturn this._timeline.length;\n\t}\n\n\t/**\n\t * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n\t * @param event  The event object to insert into the timeline.\n\t */\n\tadd(event: GenericEvent): this {\n\t\t// the event needs to have a time attribute\n\t\tthis.assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n\t\tevent.time = event.time.valueOf();\n\t\tif (this.increasing && this.length) {\n\t\t\tconst lastValue = this._timeline[this.length - 1] as GenericEvent;\n\t\t\tthis.assert(lastValue.time <= event.time, \"The time must be greater than or equal to the last scheduled time\");\n\t\t\tthis._timeline.push(event);\n\t\t} else {\n\t\t\tconst index = this._search(event.time);\n\t\t\tthis._timeline.splice(index + 1, 0, event);\n\t\t}\n\t\t// if the length is more than the memory, remove the previous ones\n\t\tif (this.length > this.memory) {\n\t\t\tconst diff = this.length - this.memory;\n\t\t\tthis._timeline.splice(0, diff);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event from the timeline.\n\t * @param  {Object}  event  The event object to remove from the list.\n\t * @returns {Timeline} this\n\t */\n\tremove(event: GenericEvent): this {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index !== -1) {\n\t\t\tthis._timeline.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the nearest event whose time is less than or equal to the given time.\n\t * @param  time  The time to query.\n\t */\n\tget(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index !== -1) {\n\t\t\treturn this._timeline[index];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Return the first event in the timeline without removing it\n\t * @returns {Object} The first event object\n\t */\n\tpeek(): GenericEvent | undefined {\n\t\treturn this._timeline[0];\n\t}\n\n\t/**\n\t * Return the first event in the timeline and remove it\n\t */\n\tshift(): GenericEvent | undefined {\n\t\treturn this._timeline.shift();\n\t}\n\n\t/**\n\t * Get the event which is scheduled after the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetAfter(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index + 1 < this._timeline.length) {\n\t\t\treturn this._timeline[index + 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get the event before the event at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetBefore(time: number): GenericEvent | null {\n\t\tconst len = this._timeline.length;\n\t\t// if it's after the last item, return the last item\n\t\tif (len > 0 && this._timeline[len - 1].time < time) {\n\t\t\treturn this._timeline[len - 1];\n\t\t}\n\t\tconst index = this._search(time);\n\t\tif (index - 1 >= 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel events at and after the given time\n\t * @param  time  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tif (this._timeline.length > 1) {\n\t\t\tlet index = this._search(after);\n\t\t\tif (index >= 0) {\n\t\t\t\tif (this._timeline[index].time === after) {\n\t\t\t\t\t// get the first item with that time\n\t\t\t\t\tfor (let i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (this._timeline[i].time === after) {\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index);\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t} else if (this._timeline.length === 1) {\n\t\t\t// the first item's time\n\t\t\tif (this._timeline[0].time >= after) {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel events before or equal to the given time.\n\t * @param  time  The time to cancel before.\n\t */\n\tcancelBefore(time: number): this {\n\t\tconst index = this._search(time);\n\t\tif (index >= 0) {\n\t\t\tthis._timeline = this._timeline.slice(index + 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the previous event if there is one. null otherwise\n\t * @param  event The event to find the previous one of\n\t * @return The event right before the given event\n\t */\n\tpreviousEvent(event: GenericEvent): GenericEvent | null {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index > 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate readonly _epsilon = 1e-6;\n\n\t/**\n\t * Test if a value is the same (by some small epsilon)\n\t */\n\tprivate _eq(a: number, b: number): boolean {\n\t\treturn Math.abs(a - b) < this._epsilon;\n\t}\n\n\t/**\n\t * Test if a is greater than b\n\t */\n\tprivate _gt(a: number, b: number): boolean {\n\t\treturn a > b + this._epsilon;\n\t}\n\n\t/**\n\t * Test if a is greater than b\n\t */\n\tprivate _lt(a: number, b: number): boolean {\n\t\treturn a < b + this._epsilon;\n\t}\n\n\t/**\n\t * Does a binary search on the timeline array and returns the\n\t * nearest event index whose time is after or equal to the given time.\n\t * If a time is searched before the first index in the timeline, -1 is returned.\n\t * If the time is after the end, the index of the last item is returned.\n\t * @param  time\n\t */\n\tprotected _search(time: number, param: TimelineSearchParam = \"time\"): number {\n\t\tif (this._timeline.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet beginning = 0;\n\t\tconst len = this._timeline.length;\n\t\tlet end = len;\n\t\tif (len > 0 && this._timeline[len - 1][param] <= time) {\n\t\t\treturn len - 1;\n\t\t}\n\t\twhile (beginning < end) {\n\t\t\t// calculate the midpoint for roughly equal partition\n\t\t\tlet midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t\t\tconst event = this._timeline[midPoint];\n\t\t\tconst nextEvent = this._timeline[midPoint + 1];\n\t\t\tif (EQ(event[param], time)) {\n\t\t\t\t// choose the last one that has the same time\n\t\t\t\tfor (let i = midPoint; i < this._timeline.length; i++) {\n\t\t\t\t\tconst testEvent = this._timeline[i];\n\t\t\t\t\tif (EQ(testEvent[param], time)) {\n\t\t\t\t\t\tmidPoint = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn midPoint;\n\t\t\t} else if (LT(event[param], time) && GT(nextEvent[param], time)) {\n\t\t\t\treturn midPoint;\n\t\t\t} else if (GT(event[param], time)) {\n\t\t\t\t// search lower\n\t\t\t\tend = midPoint;\n\t\t\t} else {\n\t\t\t\t// search upper\n\t\t\t\tbeginning = midPoint + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Internal iterator. Applies extra safety checks for\n\t * removing items from the array.\n\t */\n\tprivate _iterate(\n\t\tcallback: (event: GenericEvent) => void,\n\t\tlowerBound = 0, upperBound = this._timeline.length - 1,\n\t): void {\n\t\tthis._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n\t}\n\n\t/**\n\t * Iterate over everything in the array\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: GenericEvent) => void): this {\n\t\tthis._iterate(callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at or before the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBefore(time: Seconds, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array after the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAfter(time: Seconds, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst lowerBound = this._search(time);\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array between the startTime and endTime.\n\t * The timerange is inclusive of the startTime, but exclusive of the endTime.\n\t * range = [startTime, endTime).\n\t * @param  startTime The time to check if items are before\n\t * @param  endTime The end of the test interval.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBetween(startTime: number, endTime: number, callback: (event: GenericEvent) => void): this {\n\t\tlet lowerBound = this._search(startTime);\n\t\tlet upperBound = this._search(endTime);\n\t\tif (lowerBound !== -1 && upperBound !== -1) {\n\t\t\tif (this._timeline[lowerBound].time !== startTime) {\n\t\t\t\tlowerBound += 1;\n\t\t\t}\n\t\t\t// exclusive of the end time\n\t\t\tif (this._timeline[upperBound].time === endTime) {\n\t\t\t\tupperBound -= 1;\n\t\t\t}\n\t\t\tthis._iterate(callback, lowerBound, upperBound);\n\t\t} else if (lowerBound === -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at or after the given time. Similar to\n\t * forEachAfter, but includes the item(s) at the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tlet lowerBound = this._search(time);\n\t\t// work backwards until the event time is less than time\n\t\twhile (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n\t\t\tlowerBound--;\n\t\t}\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at the given time\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(event => {\n\t\t\t\tif (event.time === time) {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t}, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._timeline = [];\n\t\treturn this;\n\t}\n}\n","//-------------------------------------\n// INITIALIZING NEW CONTEXT\n//-------------------------------------\n\ntype Context = import(\"./Context\").Context;\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyNewContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to setup a new Context\n */\nexport function onContextInit(cb: (ctx: Context) => void): void {\n\tnotifyNewContext.push(cb);\n}\n\n/**\n * Invoke any classes which need to also be initialized when a new context is created.\n */\nexport function initializeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyNewContext.forEach(cb => cb(ctx));\n}\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyCloseContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to tear down a Context\n */\nexport function onContextClose(cb: (ctx: Context) => void): void {\n\tnotifyCloseContext.push(cb);\n}\n\nexport function closeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyCloseContext.forEach(cb => cb(ctx));\n}\n","import { Ticker, TickerClockSource } from \"../clock/Ticker\";\nimport { Seconds } from \"../type/Units\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, Omit } from \"../util/Interface\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isString } from \"../util/TypeCheck\";\nimport { AnyAudioContext, createAudioWorkletNode, getAudioContext } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\ntype Destination = import(\"./Destination\").Destination;\n\nexport type ContextLatencyHint = AudioContextLatencyCategory | \"fastest\";\n\n// these are either not used in Tone.js or deprecated and not implemented.\nexport type ExcludedFromBaseAudioContext = \"onstatechange\" | \"addEventListener\" |\n\"removeEventListener\" | \"listener\" | \"dispatchEvent\" | \"audioWorklet\" | \"destination\" | \"createScriptProcessor\";\n// \"createMediaStreamSource\" | \"createMediaElementSource\" | \"createMediaStreamTrackSource\" |\n// \"baseLatency\" | \"suspend\" |\n\n// the subset of the BaseAudioContext which Tone.Context implements.\nexport type BaseAudioContextSubset = Omit<BaseAudioContext, ExcludedFromBaseAudioContext>;\n\nexport interface ContextOptions {\n\tclockSource: TickerClockSource;\n\tlatencyHint: ContextLatencyHint;\n\tlookAhead: Seconds;\n\tupdateInterval: Seconds;\n\tcontext: AnyAudioContext;\n}\n\nexport interface ContextTimeoutEvent {\n\tcallback: (...args: any[]) => void;\n\tid: number;\n\ttime: Seconds;\n}\n\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\nexport class Context extends Emitter<\"statechange\" | \"tick\"> implements BaseAudioContextSubset {\n\n\treadonly name: string = \"Context\";\n\n\t/**\n\t * The amount of time into the future events are scheduled. Giving Web Audio\n\t * a short amount of time into the future to schedule events can reduce clicks and\n\t * improve performance. This value can be set to 0 to get the lowest latency.\n\t */\n\tlookAhead: Seconds;\n\n\t/**\n\t * private reference to the BaseAudioContext\n\t */\n\tprotected readonly _context: AnyAudioContext;\n\n\t/**\n\t * A reliable callback method\n\t */\n\tprivate readonly _ticker: Ticker;\n\n\t/**\n\t * The default latency hint\n\t */\n\tprivate _latencyHint: ContextLatencyHint | Seconds;\n\n\t/**\n\t * An object containing all of the constants AudioBufferSourceNodes\n\t */\n\tprivate _constants = new Map<number, AudioBufferSourceNode>();\n\n\t/**\n\t * All of the setTimeout events.\n\t */\n\tprivate _timeouts: Timeline<ContextTimeoutEvent> = new Timeline();\n\n\t/**\n\t * The timeout id counter\n\t */\n\tprivate _timeoutIds = 0;\n\n\t/**\n\t * A reference the Transport singleton belonging to this context\n\t */\n\tprivate _transport!: Transport;\n\n\t/**\n\t * A reference the Destination singleton belonging to this context\n\t */\n\tprivate _destination!: Destination;\n\n\t/**\n\t * Private indicator if the context has been initialized\n\t */\n\tprivate _initialized: boolean = false;\n\n\t/**\n\t * Indicates if the context is an OfflineAudioContext or an AudioContext\n\t */\n\treadonly isOffline: boolean = false;\n\n\tconstructor(context?: AnyAudioContext);\n\tconstructor(options?: Partial<ContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n\n\t\tthis._context = options.context;\n\n\t\tthis._latencyHint = options.latencyHint;\n\t\tthis.lookAhead = options.lookAhead;\n\n\t\tthis._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n\t\tthis.on(\"tick\", this._timeoutLoop.bind(this));\n\n\t\t// fwd events from the context\n\t\tthis._context.onstatechange = () => {\n\t\t\tthis.emit(\"statechange\", this.state);\n\t\t};\n\t}\n\n\tstatic getDefaults(): ContextOptions {\n\t\treturn {\n\t\t\tclockSource: \"worker\",\n\t\t\tcontext: getAudioContext(),\n\t\t\tlatencyHint: \"interactive\",\n\t\t\tlookAhead: 0.1,\n\t\t\tupdateInterval: 0.03,\n\t\t};\n\t}\n\n\t/**\n\t * Finish setting up the context. **You usually do not need to do this manually.**\n\t */\n\tprivate initialize(): this {\n\t\tif (!this._initialized) {\n\t\t\t// add any additional modules\n\t\t\tinitializeContext(this);\n\t\t\tthis._initialized = true;\n\t\t}\n\t\treturn this;\n\t}\n\n\t//---------------------------\n\t// BASE AUDIO CONTEXT METHODS\n\t//---------------------------\n\n\tcreateAnalyser(): AnalyserNode {\n\t\treturn this._context.createAnalyser();\n\t}\n\tcreateOscillator(): OscillatorNode {\n\t\treturn this._context.createOscillator();\n\t}\n\tcreateBufferSource(): AudioBufferSourceNode {\n\t\treturn this._context.createBufferSource();\n\t}\n\tcreateBiquadFilter(): BiquadFilterNode {\n\t\treturn this._context.createBiquadFilter();\n\t}\n\tcreateBuffer(numberOfChannels: number, length: number, sampleRate: number): AudioBuffer {\n\t\treturn this._context.createBuffer(numberOfChannels, length, sampleRate);\n\t}\n\tcreateChannelMerger(numberOfInputs?: number | undefined): ChannelMergerNode {\n\t\treturn this._context.createChannelMerger(numberOfInputs);\n\t}\n\tcreateChannelSplitter(numberOfOutputs?: number | undefined): ChannelSplitterNode {\n\t\treturn this._context.createChannelSplitter(numberOfOutputs);\n\t}\n\tcreateConstantSource(): ConstantSourceNode {\n\t\treturn this._context.createConstantSource();\n\t}\n\tcreateConvolver(): ConvolverNode {\n\t\treturn this._context.createConvolver();\n\t}\n\tcreateDelay(maxDelayTime?: number | undefined): DelayNode {\n\t\treturn this._context.createDelay(maxDelayTime);\n\t}\n\tcreateDynamicsCompressor(): DynamicsCompressorNode {\n\t\treturn this._context.createDynamicsCompressor();\n\t}\n\tcreateGain(): GainNode {\n\t\treturn this._context.createGain();\n\t}\n\tcreateIIRFilter(feedForward: number[] | Float32Array, feedback: number[] | Float32Array): IIRFilterNode {\n\t\t// @ts-ignore\n\t\treturn this._context.createIIRFilter(feedForward, feedback);\n\t}\n\tcreatePanner(): PannerNode {\n\t\treturn this._context.createPanner();\n\t}\n\tcreatePeriodicWave(\n\t\treal: number[] | Float32Array,\n\t\timag: number[] | Float32Array,\n\t\tconstraints?: PeriodicWaveConstraints | undefined,\n\t): PeriodicWave {\n\t\treturn this._context.createPeriodicWave(real, imag, constraints);\n\t}\n\tcreateStereoPanner(): StereoPannerNode {\n\t\treturn this._context.createStereoPanner();\n\t}\n\tcreateWaveShaper(): WaveShaperNode {\n\t\treturn this._context.createWaveShaper();\n\t}\n\tcreateMediaStreamSource(stream: MediaStream): MediaStreamAudioSourceNode {\n\t\tthis.assert(isAudioContext(this._context), \"Only available on online audio context\");\n\t\t// @ts-ignore\n\t\treturn this._context.createMediaStreamSource(stream);\n\t}\n\tdecodeAudioData(audioData: ArrayBuffer): Promise<AudioBuffer> {\n\t\treturn this._context.decodeAudioData(audioData);\n\t}\n\n\t/**\n\t * The current time in seconds of the AudioContext.\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._context.currentTime;\n\t}\n\t/**\n\t * The current time in seconds of the AudioContext.\n\t */\n\tget state(): AudioContextState {\n\t\treturn this._context.state;\n\t}\n\t/**\n\t * The current time in seconds of the AudioContext.\n\t */\n\tget sampleRate(): number {\n\t\treturn this._context.sampleRate;\n\t}\n\t/**\n\t * The listener\n\t */\n\tget listener(): AudioListener {\n\t\treturn this._context.listener;\n\t}\n\n\t/**\n\t * There is only one Transport per Context. It is created on initialization.\n\t */\n\tget transport(): Transport {\n\t\tthis.initialize();\n\t\treturn this._transport;\n\t}\n\tset transport(t: Transport) {\n\t\tthis.assert(!this._initialized, \"The transport cannot be set after initialization.\");\n\t\tthis._transport = t;\n\t}\n\n\t/**\n\t * A reference to the Context's destination node.\n\t */\n\tget destination(): Destination {\n\t\tthis.initialize();\n\t\treturn this._destination;\n\t}\n\tset destination(d: Destination) {\n\t\tthis.assert(!this._initialized, \"The destination cannot be set after initialization.\");\n\t\tthis._destination = d;\n\t}\n\n\t//--------------------------------------------\n\t// AUDIO WORKLET\n\t//--------------------------------------------\n\n\t/**\n\t * Maps a module name to promise of the addModule method\n\t */\n\tprivate _workletModules: Map<string, Promise<void>> = new Map()\n\n\t/**\n\t * Create an audio worklet node from a name and options. The module\n\t * must first be loaded using [[addAudioWorkletModule]]. \n\t */\n\tcreateAudioWorkletNode(\n\t\tname: string, \n\t\toptions?: Partial<AudioWorkletNodeOptions>\n\t): AudioWorkletNode {\n\t\treturn createAudioWorkletNode(this.rawContext, name, options);\n\t}\n\t\n\t/**\n\t * Add an AudioWorkletProcessor module\n\t * @param url The url of the module\n\t * @param name The name of the module\n\t */\n\tasync addAudioWorkletModule(url: string, name: string): Promise<void> {\n\t\tthis.assert(isDefined(this.rawContext.audioWorklet), \"AudioWorkletNode is only available in a secure context (https or localhost)\");\n\t\tif (!this._workletModules.has(name)) {\n\t\t\tthis._workletModules.set(name, this.rawContext.audioWorklet.addModule(url));\n\t\t}\n\t\tawait this._workletModules.get(name);\n\t}\n\n\t/**\n\t * Returns a promise which resolves when all of the worklets have been loaded on this context\n\t */\n\tprotected async workletsAreReady(): Promise<void> {\n\t\tconst promises: Promise<void>[] = [];\n\t\tthis._workletModules.forEach(promise => promises.push(promise));\n\t\tawait Promise.all(promises);\n\t}\n\n\t//---------------------------\n\t// TICKER\n\t//---------------------------\n\n\t/**\n\t * How often the interval callback is invoked.\n\t * This number corresponds to how responsive the scheduling\n\t * can be. context.updateInterval + context.lookAhead gives you the\n\t * total latency between scheduling an event and hearing it.\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._ticker.updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._ticker.updateInterval = interval;\n\t}\n\n\t/**\n\t * What the source of the clock is, either \"worker\" (default),\n\t * \"timeout\", or \"offline\" (none).\n\t */\n\tget clockSource(): TickerClockSource {\n\t\treturn this._ticker.type;\n\t}\n\tset clockSource(type: TickerClockSource) {\n\t\tthis._ticker.type = type;\n\t}\n\n\t/**\n\t * The type of playback, which affects tradeoffs between audio\n\t * output latency and responsiveness.\n\t * In addition to setting the value in seconds, the latencyHint also\n\t * accepts the strings \"interactive\" (prioritizes low latency),\n\t * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n\t * latency and performance), and \"fastest\" (lowest latency, might glitch more often).\n\t * @example\n\t * //set the lookAhead to 0.3 seconds\n\t * Tone.context.latencyHint = 0.3;\n\t */\n\tget latencyHint(): ContextLatencyHint | Seconds {\n\t\treturn this._latencyHint;\n\t}\n\tset latencyHint(hint: ContextLatencyHint | Seconds) {\n\t\tlet lookAheadValue = 0;\n\t\tthis._latencyHint = hint;\n\t\tif (isString(hint)) {\n\t\t\tswitch (hint) {\n\t\t\t\tcase \"interactive\":\n\t\t\t\t\tlookAheadValue = 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"playback\":\n\t\t\t\t\tlookAheadValue = 0.8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"balanced\":\n\t\t\t\t\tlookAheadValue = 0.25;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"fastest\":\n\t\t\t\t\tlookAheadValue = 0.01;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.lookAhead = lookAheadValue;\n\t\tthis.updateInterval = lookAheadValue / 3;\n\t}\n\n\t/**\n\t * The unwrapped AudioContext.\n\t */\n\tget rawContext(): AnyAudioContext {\n\t\treturn this._context;\n\t}\n\n\t/**\n\t * The current audio context time plus a short {@link lookAhead}.\n\t */\n\tnow(): Seconds {\n\t\treturn this._context.currentTime + this.lookAhead;\n\t}\n\n\t/**\n\t * Starts the audio context from a suspended state. This is required\n\t * to initially start the AudioContext.\n\t */\n\tresume(): Promise<void> {\n\t\tif (this._context.state === \"suspended\" && isAudioContext(this._context)) {\n\t\t\treturn this._context.resume();\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t * Promise which is invoked when the context is running.\n\t * Tries to resume the context if it's not started.\n\t */\n\tasync close(): Promise<void> {\n\t\tif (isAudioContext(this._context)) {\n\t\t\tawait this._context.close();\n\t\t}\n\t\tif (this._initialized) {\n\t\t\tcloseContext(this);\n\t\t}\n\t}\n\n\t/**\n\t * Generate a looped buffer at some constant value.\n\t */\n\tgetConstant(val: number): AudioBufferSourceNode {\n\t\tif (this._constants.has(val)) {\n\t\t\treturn this._constants.get(val) as AudioBufferSourceNode;\n\t\t} else {\n\t\t\tconst buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\t\t\tconst arr = buffer.getChannelData(0);\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = val;\n\t\t\t}\n\t\t\tconst constant = this._context.createBufferSource();\n\t\t\tconstant.channelCount = 1;\n\t\t\tconstant.channelCountMode = \"explicit\";\n\t\t\tconstant.buffer = buffer;\n\t\t\tconstant.loop = true;\n\t\t\tconstant.start(0);\n\t\t\tthis._constants.set(val, constant);\n\t\t\treturn constant;\n\t\t}\n\t}\n\n\t/**\n\t * Clean up. Also closes the audio context.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._ticker.dispose();\n\t\tthis._timeouts.dispose();\n\t\tObject.keys(this._constants).map(val => this._constants[val].disconnect());\n\t\treturn this;\n\t}\n\n\t//---------------------------\n\t// TIMEOUTS\n\t//---------------------------\n\n\t/**\n\t * The private loop which keeps track of the context scheduled timeouts\n\t * Is invoked from the clock source\n\t */\n\tprivate _timeoutLoop(): void {\n\t\tconst now = this.now();\n\t\tlet firstEvent = this._timeouts.peek();\n\t\twhile (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n\t\t\t// invoke the callback\n\t\t\tfirstEvent.callback();\n\t\t\t// shift the first event off\n\t\t\tthis._timeouts.shift();\n\t\t\t// get the next one\n\t\t\tfirstEvent = this._timeouts.peek();\n\t\t}\n\t}\n\n\t/**\n\t * A setTimeout which is guaranteed by the clock source.\n\t * Also runs in the offline context.\n\t * @param  fn       The callback to invoke\n\t * @param  timeout  The timeout in seconds\n\t * @returns ID to use when invoking Context.clearTimeout\n\t */\n\tsetTimeout(fn: (...args: any[]) => void, timeout: Seconds): number {\n\t\tthis._timeoutIds++;\n\t\tconst now = this.now();\n\t\tthis._timeouts.add({\n\t\t\tcallback: fn,\n\t\t\tid: this._timeoutIds,\n\t\t\ttime: now + timeout,\n\t\t});\n\t\treturn this._timeoutIds;\n\t}\n\n\t/**\n\t * Clears a previously scheduled timeout with Tone.context.setTimeout\n\t * @param  id  The ID returned from setTimeout\n\t */\n\tclearTimeout(id: number): this {\n\t\tthis._timeouts.forEach(event => {\n\t\t\tif (event.id === id) {\n\t\t\t\tthis._timeouts.remove(event);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clear the function scheduled by [[setInterval]]\n\t */\n\tclearInterval(id: number): this {\n\t\treturn this.clearTimeout(id);\n\t}\n\n\t/**\n\t * Adds a repeating event to the context's callback clock\n\t */\n\tsetInterval(fn: (...args: any[]) => void, interval: Seconds): number {\n\t\tconst id = ++this._timeoutIds;\n\t\tconst intervalFn = () => {\n\t\t\tconst now = this.now();\n\t\t\tthis._timeouts.add({\n\t\t\t\tcallback: () => {\n\t\t\t\t\t// invoke the callback\n\t\t\t\t\tfn();\n\t\t\t\t\t// invoke the event to repeat it\n\t\t\t\t\tintervalFn();\n\t\t\t\t},\n\t\t\t\tid,\n\t\t\t\ttime: now + interval,\n\t\t\t});\n\t\t};\n\t\t// kick it off\n\t\tintervalFn();\n\t\treturn id;\n\t}\n}\n","import { isArray } from \"./TypeCheck\";\n\n// return an interface which excludes certain keys\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n/**\n * Make the property not writable using `defineProperty`. Internal use only.\n */\nexport function readOnly(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => readOnly(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\tenumerable: true,\n\t\t\twritable: false,\n\t\t});\n\t}\n}\n\n/**\n * Make an attribute writeable. Internal use only.\n */\nexport function writable(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => writable(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\twritable: true,\n\t\t});\n\t}\n}\n\nexport const noOp: (...args: any[]) => any = () => {\n\t// no op!\n};\n\n/**\n * Recursive Partial taken from here: https://stackoverflow.com/a/51365037\n */\nexport type RecursivePartial<T> = {\n\t[P in keyof T]?:\n\tT[P] extends Array<infer U> ? Array<RecursivePartial<U>> :\n\t\tT[P] extends object ? RecursivePartial<T[P]> :\n\t\t\tT[P];\n};\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { Samples, Seconds, Time } from \"../type/Units\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\n\ninterface ToneAudioBufferOptions {\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n\treverse: boolean;\n\tonload: (buffer?: ToneAudioBuffer) => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n *\n * Aside from load callbacks from individual buffers, ToneAudioBuffer\n * provides events which keep track of the loading progress\n * of _all_ of the buffers. These are ToneAudioBuffer.on(\"load\" / \"progress\" / \"error\")\n * @example\n * var buffer = new ToneAudioBuffer(\"path/to/sound.mp3\", function(){\n * \t//the buffer is now available.\n * \tvar buff = buffer.get();\n * });\n * @example\n * //can load provide fallback extension types if the first type is not supported.\n * var buffer = new ToneAudioBuffer(\"path/to/sound.[mp3|ogg|wav]\");\n * @category Core\n */\nexport class ToneAudioBuffer extends Tone {\n\n\treadonly name: string = \"ToneAudioBuffer\";\n\n\t/**\n\t * stores the loaded AudioBuffer\n\t */\n\tprivate _buffer?: AudioBuffer;\n\n\t/**\n\t * indicates if the buffer should be reversed or not\n\t */\n\tprivate _reversed!: boolean;\n\n\t/**\n\t * Callback when the buffer is loaded.\n\t */\n\tonload: (buffer: ToneAudioBuffer) => void = noOp;\n\n\t/**\n\t *\n\t * @param url The url to load, or the audio buffer to set.\n\t * @param onload A callback which is invoked after the buffer is loaded.\n\t *                           It's recommended to use `ToneAudioBuffer.on('load', callback)` instead\n\t *                           since it will give you a callback when _all_ buffers are loaded.\n\t * @param onerror The callback to invoke if there is an error\n\t */\n\tconstructor(\n\t\turl?: string | ToneAudioBuffer | AudioBuffer,\n\t\tonload?: (buffer: ToneAudioBuffer) => void,\n\t\tonerror?: (error: Error) => void,\n\t);\n\tconstructor(options?: Partial<ToneAudioBufferOptions>);\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tconst options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n\n\t\tthis.reverse = options.reverse;\n\t\tthis.onload = options.onload;\n\n\t\tif (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n\t\t\tthis.set(options.url);\n\t\t} else if (isString(options.url)) {\n\t\t\t// initiate the download\n\t\t\tthis.load(options.url).catch(options.onerror);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneAudioBufferOptions {\n\t\treturn {\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\treverse: false,\n\t\t};\n\t}\n\n\t/**\n\t * The sample rate of the AudioBuffer\n\t */\n\tget sampleRate(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.sampleRate;\n\t\t} else {\n\t\t\treturn getContext().sampleRate;\n\t\t}\n\t}\n\n\t/**\n\t * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n\t */\n\tset(buffer: AudioBuffer | ToneAudioBuffer): this {\n\t\tif (buffer instanceof ToneAudioBuffer) {\n\t\t\t// if it's loaded, set it\n\t\t\tif (buffer.loaded) {\n\t\t\t\tthis._buffer = buffer.get();\n\t\t\t} else {\n\t\t\t\t// otherwise when it's loaded, invoke it's callback\n\t\t\t\tbuffer.onload = () => {\n\t\t\t\t\tthis.set(buffer);\n\t\t\t\t\tthis.onload(this);\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tthis._buffer = buffer;\n\t\t}\n\t\t// reverse it initially\n\t\tif (this._reversed) {\n\t\t\tthis._reverse();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The audio buffer stored in the object.\n\t */\n\tget(): AudioBuffer | undefined {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n\t * Invokes the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t * @returns A Promise which resolves with this ToneAudioBuffer\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tconst promise = ToneAudioBuffer.load(url);\n\t\tToneAudioBuffer.downloads.push(promise);\n\t\ttry {\n\t\t\tconst audioBuffer = await promise;\n\t\t\tthis.set(audioBuffer);\n\t\t\t// invoke the onload method\n\t\t\tthis.onload(this);\n\t\t} catch (e) {\n\t\t\t// remove the failed file before throwing error\n\t\t\tconst index = ToneAudioBuffer.downloads.indexOf(promise);\n\t\t\tToneAudioBuffer.downloads.splice(index, 1);\n\t\t\tthrow e;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the audio buffer from the array.\n\t * To create a multichannel AudioBuffer, pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t */\n\tfromArray(array: Float32Array | Float32Array[]): this {\n\t\tconst isMultidimensional = isArray(array) && array[0].length > 0;\n\t\tconst channels = isMultidimensional ? array.length : 1;\n\t\tconst len = isMultidimensional ? (array[0] as Float32Array).length : array.length;\n\t\tconst context = getContext();\n\t\tconst buffer = context.createBuffer(channels, len, context.sampleRate);\n\t\tconst multiChannelArray: Float32Array[] = !isMultidimensional && channels === 1 ?\n\t\t\t[array as Float32Array] : array as Float32Array[];\n\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\tbuffer.copyToChannel(multiChannelArray[c], c);\n\t\t}\n\t\tthis._buffer = buffer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sums multiple channels into 1 channel\n\t * @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoMono(chanNum?: number): this {\n\t\tif (isNumber(chanNum)) {\n\t\t\tthis.fromArray(this.toArray(chanNum));\n\t\t} else {\n\t\t\tlet outputArray = new Float32Array(this.length as number);\n\t\t\tconst numChannels = this.numberOfChannels;\n\t\t\tfor (let channel = 0; channel < numChannels; channel++) {\n\t\t\t\tconst channelArray = this.toArray(channel) as Float32Array;\n\t\t\t\tfor (let i = 0; i < channelArray.length; i++) {\n\t\t\t\t\toutputArray[i] += channelArray[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// divide by the number of channels\n\t\t\toutputArray = outputArray.map(sample => sample / numChannels);\n\t\t\tthis.fromArray(outputArray);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n\t * Float32Array, and multichannel buffers will return multidimensional arrays.\n\t * @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoArray(channel?: number): Float32Array | Float32Array[] {\n\t\tif (isNumber(channel)) {\n\t\t\treturn this.getChannelData(channel);\n\t\t} else if (this.numberOfChannels === 1) {\n\t\t\treturn this.toArray(0);\n\t\t} else {\n\t\t\tconst ret: Float32Array[] = [];\n\t\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\t\tret[c] = this.getChannelData(c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the Float32Array representing the PCM audio data for the specific channel.\n\t * @param  channel  The channel number to return\n\t * @return The audio as a TypedArray\n\t */\n\tgetChannelData(channel: number): Float32Array {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.getChannelData(channel);\n\t\t} else {\n\t\t\treturn new Float32Array(0);\n\t\t}\n\t}\n\n\t/**\n\t * Cut a subsection of the array and return a buffer of the\n\t * subsection. Does not modify the original buffer\n\t * @param start The time to start the slice\n\t * @param end The end time to slice. If none is given will default to the end of the buffer\n\t */\n\tslice(start: Seconds, end: Seconds = this.duration): ToneAudioBuffer {\n\t\tconst startSamples = Math.floor(start * this.sampleRate);\n\t\tconst endSamples = Math.floor(end * this.sampleRate);\n\t\tthis.assert(startSamples < endSamples, \"The start time must be less than the end time\");\n\t\tconst length = endSamples - startSamples;\n\t\tconst retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\t\tfor (let channel = 0; channel < this.numberOfChannels; channel++) {\n\t\t\tretBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n\t\t}\n\t\treturn new ToneAudioBuffer(retBuffer);\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tprivate _reverse(): this {\n\t\tif (this.loaded) {\n\t\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\t\tthis.getChannelData(i).reverse();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffer is loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this.length > 0;\n\t}\n\n\t/**\n\t * The duration of the buffer in seconds.\n\t */\n\tget duration(): Seconds {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.duration;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The length of the buffer in samples\n\t */\n\tget length(): Samples {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n\t */\n\tget numberOfChannels(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.numberOfChannels;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tget reverse(): boolean {\n\t\treturn this._reversed;\n\t}\n\tset reverse(rev: boolean) {\n\t\tif (this._reversed !== rev) {\n\t\t\tthis._reversed = rev;\n\t\t\tthis._reverse();\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// STATIC METHODS\n\t//-------------------------------------\n\n\t/**\n\t * A path which is prefixed before every url.\n\t */\n\tstatic baseUrl = \"\";\n\n\t/**\n\t * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n\t * pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t * @return A ToneAudioBuffer created from the array\n\t */\n\tstatic fromArray(array: Float32Array | Float32Array[]): ToneAudioBuffer {\n\t\treturn (new ToneAudioBuffer()).fromArray(array);\n\t}\n\n\t/**\n\t * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n\t * @param  url The url to load.\n\t * @return A promise which resolves to a ToneAudioBuffer\n\t */\n\tstatic async fromUrl(url: string): Promise<ToneAudioBuffer> {\n\t\tconst buffer = new ToneAudioBuffer();\n\t\treturn await buffer.load(url);\n\t}\n\n\t/**\n\t * All of the downloads\n\t */\n\tstatic downloads: Array<Promise<AudioBuffer>> = [];\n\n\t/**\n\t * Loads a url using fetch and returns the AudioBuffer.\n\t */\n\tstatic async load(url: string): Promise<AudioBuffer> {\n\n\t\t// test if the url contains multiple extensions\n\t\tconst matches = url.match(/\\[(.+\\|?)+\\]$/);\n\t\tif (matches) {\n\t\t\tconst extensions = matches[1].split(\"|\");\n\t\t\tlet extension = extensions[0];\n\t\t\tfor (const ext of extensions) {\n\t\t\t\tif (ToneAudioBuffer.supportsType(ext)) {\n\t\t\t\t\textension = ext;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\turl = url.replace(matches[0], extension);\n\t\t}\n\n\t\tconst response = await fetch(ToneAudioBuffer.baseUrl + url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`could not load url: ${url}`);\n\t\t}\n\t\tconst arrayBuffer = await response.arrayBuffer();\n\n\t\tconst audioBuffer = await getContext().decodeAudioData(arrayBuffer);\n\n\t\treturn audioBuffer;\n\t}\n\n\t/**\n\t * Checks a url's extension to see if the current browser can play that file type.\n\t * @param url The url/extension to test\n\t * @return If the file extension can be played\n\t * @static\n\t * @example\n\t * ToneAudioBuffer.supportsType(\"wav\"); //returns true\n\t * ToneAudioBuffer.supportsType(\"path/to/file.wav\"); //returns true\n\t */\n\tstatic supportsType(url: string): boolean {\n\t\tconst extensions = url.split(\".\");\n\t\tconst extension = extensions[extensions.length - 1];\n\t\tconst response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n\t\treturn response !== \"\";\n\t}\n\n\t/**\n\t * Returns a Promise which resolves when all of the buffers have loaded\n\t */\n\tstatic async loaded(): Promise<void> {\n\t\tfor (const promise of ToneAudioBuffer.downloads) {\n\t\t\tawait promise;\n\t\t}\n\t}\n}\n","import { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { Seconds } from \"../type/Units\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n */\nexport class OfflineContext extends Context {\n\n\treadonly name: string = \"OfflineContext\";\n\n\t/**\n\t * A private reference to the duration\n\t */\n\tprivate readonly _duration: Seconds;\n\n\t/**\n\t * An artificial clock source\n\t */\n\tprivate _currentTime: Seconds = 0;\n\n\t/**\n\t * Private reference to the OfflineAudioContext.\n\t */\n\tprotected _context!: OfflineAudioContext;\n\n\treadonly isOffline: boolean = true;\n\n\t/**\n\t * @param  channels  The number of channels to render\n\t * @param  duration  The duration to render in seconds\n\t * @param sampleRate the sample rate to render at\n\t */\n\tconstructor(\n\t\tchannels: number,\n\t\tduration: Seconds, sampleRate: number,\n\t);\n\tconstructor(context: OfflineAudioContext);\n\tconstructor() {\n\n\t\tsuper({\n\t\t\tclockSource: \"offline\",\n\t\t\tcontext: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\targuments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n\t\t\tlookAhead: 0,\n\t\t\tupdateInterval: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\t128 / arguments[0].sampleRate : 128 / arguments[2],\n\t\t});\n\n\t\tthis._duration = isOfflineAudioContext(arguments[0]) ?\n\t\t\targuments[0].length / arguments[0].sampleRate : arguments[1];\n\t}\n\n\t/**\n\t * Override the now method to point to the internal clock time\n\t */\n\tnow(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Same as this.now()\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Render just the clock portion of the audio context.\n\t */\n\tprivate async _renderClock(asynchronous: boolean): Promise<void> {\n\t\tlet index = 0;\n\t\twhile (this._duration - this._currentTime >= 0) {\n\t\t\t\n\t\t\t// invoke all the callbacks on that time\n\t\t\tthis.emit(\"tick\");\n\t\t\t\n\t\t\t// increment the clock in block-sized chunks\n\t\t\tthis._currentTime += 128 / this.sampleRate;\n\t\t\t\n\t\t\t// yield once a second of audio\n\t\t\tindex++;\n\t\t\tconst yieldEvery = Math.floor(this.sampleRate / 128);\n\t\t\tif (asynchronous && index % yieldEvery === 0) {\n\t\t\t\tawait new Promise(done => setTimeout(done, 1));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Render the output of the OfflineContext\n\t * @param async If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n\t */\n\tasync render(asynchronous: boolean = true): Promise<ToneAudioBuffer> {\n\t\tawait this.workletsAreReady();\n\t\tawait this._renderClock(asynchronous);\n\t\tconst buffer = await this._context.startRendering();\n\t\treturn new ToneAudioBuffer(buffer);\n\t}\n\n\t/**\n\t * Close the context\n\t */\n\tclose(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n}\n","import { version } from \"../version\";\nimport { hasAudioContext, theWindow } from \"./context/AudioContext\";\nimport { Context } from \"./context/Context\";\nimport { OfflineContext } from \"./context/OfflineContext\";\nimport { isAudioContext, isOfflineAudioContext } from \"./util/AdvancedTypeCheck\";\n\n/**\n * This dummy context is used to avoid throwing immediate errors when importing in Node.js\n */\n// eslint-disable-next-line @typescript-eslint/no-object-literal-type-assertion\nconst dummyContext: Context = {\n\tdestination: {},\n\ttransport: {},\n} as Context;\n\n/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext: Context = dummyContext;\n\n/**\n * Returns the default system-wide [[Context]]\n * @category Core\n */\nexport function getContext(): Context {\n\tif (globalContext === dummyContext && hasAudioContext) {\n\t\tsetContext(new Context());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n * @category Core\n */\nexport function setContext(context: Context | AudioContext | OfflineAudioContext): void {\n\tif (isAudioContext(context)) {\n\t\tglobalContext = new Context(context);\n\t} else if (isOfflineAudioContext(context)) {\n\t\tglobalContext = new OfflineContext(context);\n\t} else {\n\t\tglobalContext = context;\n\t}\n}\n\n/**\n * Most browsers will not play _any_ audio until a user\n * clicks something (like a play button). Invoke this method\n * on a click or keypress event handler to start the audio context.\n * More about the Autoplay policy\n * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n * @example\n * document.querySelector('#playbutton').addEventListener('click', async () => {\n * \tawait Tone.start()\n * \tconsole.log('audio ready')\n * })\n * @category Core\n */\nexport function start(): Promise <void> {\n\treturn globalContext.resume();\n}\n\n/**\n * Log Tone.js + version in the console.\n */\nif (theWindow && !theWindow.TONE_SILENCE_LOGGING) {\n\tlet prefix = \"v\";\n\tif (version === \"dev\") {\n\t\tprefix = \"\";\n\t}\n\tconst printString = ` * Tone.js ${prefix}${version} * `;\n\t// eslint-disable-next-line no-console\n\tconsole.log(`%c${printString}`, \"background: #000; color: #fff\");\n}\n","import { Decibels, GainFactor, Hertz, Interval, MidiNote, NormalRange } from \"./Units\";\n\n/**\n * Equal power gain scale. Good for cross-fading.\n * @param  percent (0-1)\n */\nexport function equalPowerScale(percent: NormalRange): number {\n\tconst piFactor = 0.5 * Math.PI;\n\treturn Math.sin(percent * piFactor);\n}\n\n/**\n * Convert decibels into gain.\n */\nexport function dbToGain(db: Decibels): GainFactor {\n\treturn Math.pow(10, db / 20);\n}\n\n/**\n * Convert gain to decibels.\n */\nexport function gainToDb(gain: GainFactor): Decibels {\n\treturn 20 * (Math.log(gain) / Math.LN10);\n}\n\n/**\n * Convert an interval (in semitones) to a frequency ratio.\n * @param interval the number of semitones above the base note\n * @example\n * tone.intervalToFrequencyRatio(0); // 1\n * tone.intervalToFrequencyRatio(12); // 2\n * tone.intervalToFrequencyRatio(-12); // 0.5\n */\nexport function intervalToFrequencyRatio(interval: Interval): number {\n\treturn Math.pow(2, (interval / 12));\n}\n\n/**\n * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n * to generate all the other pitch values from notes. A4's values in Hertz.\n */\nlet A4: Hertz = 440;\n\nexport function getA4(): Hertz {\n\treturn A4;\n}\n\nexport function setA4(freq: Hertz): void {\n\tA4 = freq;\n}\n\n/**\n * Convert a frequency value to a MIDI note.\n * @param frequency The value to frequency value to convert.\n * @example\n * ftom(440); // returns 69\n */\nexport function ftom(frequency: Hertz): MidiNote {\n\treturn Math.round(ftomf(frequency)) as MidiNote;\n}\n\n/**\n * Convert a frequency to a floating point midi value\n */\nexport function ftomf(frequency: Hertz): number {\n\treturn 69 + 12 * Math.log2(frequency / A4);\n}\n\n/**\n * Convert a MIDI note to frequency value.\n * @param  midi The midi number to convert.\n * @return The corresponding frequency value\n * @example\n */\nexport function mtof(midi: MidiNote): Hertz {\n\treturn A4 * Math.pow(2, (midi - 69) / 12);\n}\n","import { Context } from \"../context/Context\";\nimport { Tone } from \"../Tone\";\nimport { isDefined, isObject, isString, isUndef } from \"../util/TypeCheck\";\nimport { BPM, Hertz, MidiNote, Milliseconds, Samples, Seconds, Ticks, Time } from \"./Units\";\n\nexport type TimeValue = Time | TimeBaseClass<any, any>;\n\n/**\n * The units that the TimeBase can accept. extended by other classes\n */\nexport type TimeBaseUnit = \"s\" | \"n\" | \"t\" | \"m\" | \"i\" | \"hz\" | \"tr\" | \"samples\" | \"number\";\n\nexport interface TypeFunction {\n\tregexp: RegExp;\n\tmethod: (value: string, ...args: string[]) => number;\n}\n\nexport interface TimeExpression<Type extends number> {\n\t[key: string]: {\n\t\tregexp: RegExp;\n\t\tmethod: (value: string, ...args: string[]) => Type;\n\t};\n}\n\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n * @example\n * new TimeBase(4, \"n\")\n * new TimeBase(2, \"t\")\n * new TimeBase(\"2t\")\n * new TimeBase({\"2t\" : 2})\n * new TimeBase(\"2t\") + new TimeBase(\"4n\");\n */\nexport abstract class TimeBaseClass<Type extends number, Unit extends string> extends Tone {\n\n\treadonly context: Context;\n\n\t/**\n\t * The value of the units\n\t */\n\tprotected _val?: TimeValue;\n\n\t/**\n\t * The units of time\n\t */\n\tprotected _units?: Unit;\n\n\t/**\n\t * All of the conversion expressions\n\t */\n\tprotected _expressions: TimeExpression<Type>;\n\n\t/**\n\t * The default units\n\t */\n\treadonly defaultUnits: Unit = \"s\" as Unit;\n\n\t/**\n\t * @param context The context associated with the time value. Used to compute\n\t * Transport and context-relative timing.\n\t * @param  value  The time value as a number, string or object\n\t * @param  units  Unit values\n\t */\n\tconstructor(context: Context, value?: TimeValue, units?: Unit) {\n\t\tsuper();\n\n\t\tthis._val = value;\n\t\tthis._units = units;\n\t\tthis.context = context;\n\t\tthis._expressions = this._getExpressions();\n\t}\n\n\t/**\n\t * All of the time encoding expressions\n\t */\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn {\n\t\t\thz: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._frequencyToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n\t\t\t},\n\t\t\ti: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._ticksToUnits(parseInt(value, 10));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)i$/i,\n\t\t\t},\n\t\t\tm: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)m$/i,\n\t\t\t},\n\t\t\tn: {\n\t\t\t\tmethod: (value, dot) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\tconst scalar = dot === \".\" ? 1.5 : 1;\n\t\t\t\t\tif (numericValue === 1) {\n\t\t\t\t\t\treturn this._beatsToUnits(this._getTimeSignature()) * scalar as Type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this._beatsToUnits(4 / numericValue) * scalar as Type;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)n(\\.?)$/i,\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._expressions[this.defaultUnits].method.call(this, value);\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)$/,\n\t\t\t},\n\t\t\ts: {\n\t\t\t\tmethod: (value): Type => {\n\t\t\t\t\treturn this._secondsToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)s$/,\n\t\t\t},\n\t\t\tsamples: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn parseInt(value, 10) / this.context.sampleRate as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)samples$/,\n\t\t\t},\n\t\t\tt: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\treturn this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)t$/i,\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tmethod: (m, q, s) => {\n\t\t\t\t\tlet total = 0;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n\t\t\t},\n\t\t};\n\t}\n\n\t//-------------------------------------\n\t// \tVALUE OF\n\t//-------------------------------------\n\n\t/**\n\t * Evaluate the time value. Returns the time in seconds.\n\t */\n\tvalueOf(): Type {\n\t\tif (this._val instanceof TimeBaseClass) {\n\t\t\tthis.fromType(this._val);\n\t\t}\n\t\tif (isUndef(this._val)) {\n\t\t\treturn this._noArg();\n\t\t} else if (isString(this._val) && isUndef(this._units)) {\n\t\t\tfor (const units in this._expressions) {\n\t\t\t\tif (this._expressions[units].regexp.test(this._val.trim())) {\n\t\t\t\t\tthis._units = units as Unit;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(this._val)) {\n\t\t\tlet total = 0;\n\t\t\tfor (const typeName in this._val) {\n\t\t\t\tif (isDefined(this._val[typeName])) {\n\t\t\t\t\tconst quantity = this._val[typeName];\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst time = (new this.constructor(this.context, typeName)).valueOf() * quantity;\n\t\t\t\t\ttotal += time;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn total as Type;\n\t\t}\n\t\tif (isDefined(this._units)) {\n\t\t\tconst expr = this._expressions[this._units];\n\t\t\tconst matching = this._val.toString().trim().match(expr.regexp);\n\t\t\tif (matching) {\n\t\t\t\treturn expr.method.apply(this, matching.slice(1));\n\t\t\t} else {\n\t\t\t\treturn expr.method.call(this, this._val);\n\t\t\t}\n\t\t} else if (isString(this._val)) {\n\t\t\treturn parseFloat(this._val) as Type;\n\t\t} else {\n\t\t\treturn this._val as Type;\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn 1 / freq as Type;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn (60 / this._getBpm()) * beats as Type;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn seconds as Type;\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn (ticks * (this._beatsToUnits(1)) / this._getPPQ()) as Type;\n\t}\n\n\t/**\n\t * With no arguments, return 'now'\n\t */\n\tprotected _noArg(): Type {\n\t\treturn this._now();\n\t}\n\n\t//-------------------------------------\n\t// \tTEMPO CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Return the bpm\n\t */\n\tprotected _getBpm(): BPM {\n\t\treturn this.context.transport.bpm.value;\n\t}\n\n\t/**\n\t * Return the timeSignature\n\t */\n\tprotected _getTimeSignature(): number {\n\t\treturn this.context.transport.timeSignature as number;\n\t}\n\n\t/**\n\t * Return the PPQ or 192 if Transport is not available\n\t */\n\tprotected _getPPQ(): number {\n\t\treturn this.context.transport.PPQ;\n\t}\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected abstract _now(): Type;\n\n\t//-------------------------------------\n\t// \tCONVERSION INTERFACE\n\t//-------------------------------------\n\n\t/**\n\t * Coerce a time type into this units type.\n\t * @param type Any time type units\n\t */\n\tfromType(type: TimeBaseClass<any, any>): this {\n\t\tthis._units = undefined;\n\t\tswitch (this.defaultUnits) {\n\t\t\tcase \"s\":\n\t\t\t\tthis._val = type.toSeconds();\n\t\t\t\tbreak;\n\t\t\tcase \"i\":\n\t\t\t\tthis._val = type.toTicks();\n\t\t\t\tbreak;\n\t\t\tcase \"hz\":\n\t\t\t\tthis._val = type.toFrequency();\n\t\t\t\tbreak;\n\t\t\tcase \"midi\":\n\t\t\t\tthis._val = type.toMidi();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the value in seconds\n\t */\n\tabstract toSeconds(): Seconds;\n\n\t/**\n\t * Return the value as a Midi note\n\t */\n\tabstract toMidi(): MidiNote;\n\n\t/**\n\t * Convert the value into ticks\n\t */\n\tabstract toTicks(): Ticks;\n\n\t/**\n\t * Return the value in hertz\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn 1 / this.toSeconds();\n\t}\n\n\t/**\n\t * Return the time in samples\n\t */\n\ttoSamples(): Samples {\n\t\treturn this.toSeconds() * this.context.sampleRate;\n\t}\n\n\t/**\n\t * Return the time in milliseconds.\n\t */\n\ttoMilliseconds(): Milliseconds {\n\t\treturn this.toSeconds() * 1000;\n\t}\n}\n","import { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass, TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\nimport { BarsBeatsSixteenths, MidiNote, Seconds, Subdivision, Ticks, Time } from \"./Units\";\n\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * var t = Time(\"4n\");//a quarter note\n * @category Unit\n */\nexport class TimeClass<Type extends Seconds | Ticks = Seconds, Unit extends string = TimeBaseUnit>\n\textends TimeBaseClass<Type, Unit> {\n\n\treadonly name: string = \"Time\";\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign(super._getExpressions(), {\n\t\t\tnow: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\treturn this._now() + new (this.constructor as typeof TimeClass)(this.context, capture).valueOf() as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^\\+(.+)/,\n\t\t\t},\n\t\t\tquantize: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\tconst quantTo = new TimeClass(this.context, capture).valueOf();\n\t\t\t\t\treturn this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n\t\t\t\t},\n\t\t\t\tregexp: /^@(.+)/,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Quantize the time by the given subdivision. Optionally add a\n\t * percentage which will move the time value towards the ideal\n\t * quantized value by that percentage.\n\t * @param  val    The subdivision to quantize to\n\t * @param  percent  Move the time value towards the quantized value by a percentage.\n\t * @example\n\t * Time(21).quantize(2) //returns 22\n\t * Time(0.6).quantize(\"4n\", 0.5) //returns 0.55\n\t */\n\tquantize(subdiv: Time, percent = 1): Type {\n\t\tconst subdivision = new (this.constructor as typeof TimeClass)(this.context, subdiv).valueOf();\n\t\tconst value = this.valueOf();\n\t\tconst multiple = Math.round(value / subdivision);\n\t\tconst ideal = multiple * subdivision;\n\t\tconst diff = ideal - value;\n\t\treturn value + diff * percent as Type;\n\t}\n\n\t//-------------------------------------\n\t// CONVERSIONS\n\t//-------------------------------------\n\t/**\n\t * Convert a Time to Notation. The notation values are will be the\n\t * closest representation between 1m to 128th note.\n\t * @return {Notation}\n\t * @example\n\t * //if the Transport is at 120bpm:\n\t * Time(2).toNotation();//returns \"1m\"\n\t */\n\ttoNotation(): Subdivision {\n\t\tconst time = this.toSeconds();\n\t\tconst testNotations: Subdivision[] = [\"1m\"];\n\t\tfor (let power = 1; power < 9; power++) {\n\t\t\tconst subdiv = Math.pow(2, power);\n\t\t\ttestNotations.push(subdiv + \"n.\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"n\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"t\" as Subdivision);\n\t\t}\n\t\ttestNotations.push(\"0\");\n\t\t// find the closets notation representation\n\t\tlet closest = testNotations[0];\n\t\tlet closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n\t\ttestNotations.forEach(notation => {\n\t\t\tconst notationSeconds = new TimeClass(this.context, notation).toSeconds();\n\t\t\tif (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n\t\t\t\tclosest = notation;\n\t\t\t\tclosestSeconds = notationSeconds;\n\t\t\t}\n\t\t});\n\t\treturn closest;\n\t}\n\n\t/**\n\t * Return the time encoded as Bars:Beats:Sixteenths.\n\t */\n\ttoBarsBeatsSixteenths(): BarsBeatsSixteenths {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tlet quarters = this.valueOf() / quarterTime;\n\t\tquarters = parseFloat(quarters.toFixed(4));\n\t\tconst measures = Math.floor(quarters / this._getTimeSignature());\n\t\tlet sixteenths = (quarters % 1) * 4;\n\t\tquarters = Math.floor(quarters) % this._getTimeSignature();\n\t\tconst sixteenthString = sixteenths.toString();\n\t\tif (sixteenthString.length > 3) {\n\t\t\t// the additional parseFloat removes insignificant trailing zeroes\n\t\t\tsixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n\t\t}\n\t\tconst progress = [measures, quarters, sixteenths];\n\t\treturn progress.join(\":\");\n\t}\n\n\t/**\n\t * Return the time in ticks.\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.round(quarters * this._getPPQ());\n\t}\n\n\t/**\n\t * Return the time in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t * Return the value as a midi note.\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.toFrequency());\n\t}\n\n\tprotected _now(): Type {\n\t\treturn this.context.now() as Type;\n\t}\n}\n\n/**\n * Create a TimeClass from a time string or number.\n * @param value A value which reprsents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n */\nexport function Time(value?: TimeValue, units?: TimeBaseUnit): TimeClass<Seconds> {\n\treturn new TimeClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { intervalToFrequencyRatio, mtof } from \"./Conversions\";\nimport { ftom, getA4, setA4 } from \"./Conversions\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseClass, TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\nimport { Frequency, Hertz, Interval, MidiNote, Note, Seconds, Ticks } from \"./Units\";\n\nexport type FrequencyUnit = TimeBaseUnit | \"midi\";\n\n/**\n * Frequency is a primitive type for encoding Frequency values.\n * Eventually all time values are evaluated to hertz using the `eval` method.\n * @example\n * Frequency(\"C3\") // 261\n * Frequency(38, \"midi\") //\n * Frequency(\"C3\").transpose(4);\n * @category Unit\n */\nexport class FrequencyClass<Type extends number = Hertz> extends TimeClass<Type, FrequencyUnit> {\n\n\treadonly name: string = \"Frequency\";\n\n\treadonly defaultUnits: FrequencyUnit = \"hz\";\n\n\t/**\n\t * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n\t * to generate all the other pitch values from notes. A4's values in Hertz.\n\t */\n\tstatic get A4(): Hertz {\n\t\treturn getA4();\n\t}\n\tstatic set A4(freq: Hertz) {\n\t\tsetA4(freq);\n\t}\n\n\t//-------------------------------------\n\t// \tAUGMENT BASE EXPRESSIONS\n\t//-------------------------------------\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign({}, super._getExpressions(), {\n\t\t\tmidi: {\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?midi)/,\n\t\t\t\tmethod(value): number {\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\tnote: {\n\t\t\t\tregexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n\t\t\t\tmethod(pitch, octave): number {\n\t\t\t\t\tconst index = noteToScaleIndex[pitch.toLowerCase()];\n\t\t\t\t\tconst noteNumber = index + (parseInt(octave, 10) + 1) * 12;\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn noteNumber;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(noteNumber);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\t\t\t\tmethod(m, q, s): number {\n\t\t\t\t\tlet total = 1;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total;\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tEXPRESSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Transposes the frequency by the given number of semitones.\n\t * @return  A new transposed frequency\n\t * @example\n\t * Frequency(\"A4\").transpose(3); //\"C5\"\n\t */\n\ttranspose(interval: Interval): FrequencyClass {\n\t\treturn new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));\n\t}\n\n\t/**\n\t * Takes an array of semitone intervals and returns\n\t * an array of frequencies transposed by those intervals.\n\t * @return  Returns an array of Frequencies\n\t * @example\n\t * Frequency(\"A4\").harmonize([0, 3, 7]); //[\"A4\", \"C5\", \"E5\"]\n\t */\n\tharmonize(intervals: Interval[]): FrequencyClass[] {\n\t\treturn intervals.map(interval => {\n\t\t\treturn this.transpose(interval);\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @example\n\t * Frequency(\"C4\").toMidi(); //60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.valueOf());\n\t}\n\n\t/**\n\t * Return the value of the frequency in Scientific Pitch Notation\n\t * @example\n\t * Frequency(69, \"midi\").toNote(); //\"A4\"\n\t */\n\ttoNote(): Note {\n\t\tconst freq = this.toFrequency();\n\t\tconst log = Math.log2(freq / FrequencyClass.A4);\n\t\tlet noteNumber = Math.round(12 * log) + 57;\n\t\tconst octave = Math.floor(noteNumber / 12);\n\t\tif (octave < 0) {\n\t\t\tnoteNumber += -12 * octave;\n\t\t}\n\t\tconst noteName = scaleIndexToNote[noteNumber % 12];\n\t\treturn noteName + octave.toString() as Note;\n\t}\n\n\t/**\n\t * Return the duration of one cycle in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn 1 / super.toSeconds();\n\t}\n\n\t/**\n\t * Return the duration of one cycle in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.floor(quarters * this._getPPQ());\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS HELPERS\n\t//-------------------------------------\n\n\t/**\n\t * With no arguments, return 0\n\t */\n\tprotected _noArg(): Type {\n\t\treturn 0 as Type;\n\t}\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn freq as Type;\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn 1 / ((ticks * 60) / (this._getBpm() * this._getPPQ())) as Type;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn 1 / super._beatsToUnits(beats) as Type;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn 1 / seconds as Type;\n\t}\n\n\t/**\n\t * Convert a MIDI note to frequency value.\n\t * @param  midi The midi number to convert.\n\t * @return The corresponding frequency value\n\t * @example\n\t * FrequencyClass.mtof(69); // returns 440\n\t */\n\tstatic mtof(midi: MidiNote): Hertz {\n\t\treturn mtof(midi);\n\t}\n\n\t/**\n\t * Convert a frequency value to a MIDI note.\n\t * @param frequency The value to frequency value to convert.\n\t * @example\n\t * Frequency.ftom(440); // returns 69\n\t */\n\tstatic ftom(frequency: Hertz): MidiNote {\n\t\treturn ftom(frequency);\n\t}\n}\n\n//-------------------------------------\n// \tFREQUENCY CONVERSIONS\n//-------------------------------------\n\n/**\n * Note to scale index. \n * @hidden\n */\nconst noteToScaleIndex = {\n\tcbb: -2, cb: -1, c: 0, \"c#\": 1, cx: 2,\n\tdbb: 0, db: 1, d: 2, \"d#\": 3, dx: 4,\n\tebb: 2, eb: 3, e: 4, \"e#\": 5, ex: 6,\n\tfbb: 3, fb: 4, f: 5, \"f#\": 6, fx: 7,\n\tgbb: 5, gb: 6, g: 7, \"g#\": 8, gx: 9,\n\tabb: 7, ab: 8, a: 9, \"a#\": 10, ax: 11,\n\tbbb: 9, bb: 10, b: 11, \"b#\": 12, bx: 13,\n};\n\n/**\n * scale index to note (sharps)\n * @hidden\n */\nconst scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n */\nexport function Frequency(value?: TimeValue | Frequency, units?: FrequencyUnit): FrequencyClass {\n\treturn new FrequencyClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { Seconds, Ticks } from \"../type/Units\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport class TransportTimeClass<Type extends Seconds | Ticks = Seconds> extends TimeClass<Type> {\n\n\treadonly name: string = \"TransportTime\";\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected _now(): Type {\n\t\treturn this.context.transport.seconds as Type;\n\t}\n}\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to [[Time]], but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport function TransportTime(value?: TimeValue, units?: TimeBaseUnit): TransportTimeClass {\n\treturn new TransportTimeClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { FrequencyClass } from \"../type/Frequency\";\nimport { TimeClass } from \"../type/Time\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { getDefaultsFromInstance, omitFromObject, optionsFromArguments } from \"../util/Defaults\";\nimport { RecursivePartial } from \"../util/Interface\";\nimport { isArray, isBoolean, isDefined, isNumber, isString, isUndef } from \"../util/TypeCheck\";\nimport { Context } from \"./Context\";\n\n/**\n * A unit which process audio\n */\nexport interface ToneWithContextOptions {\n\tcontext: Context;\n}\n\n/**\n * The Base class for all nodes that have an AudioContext.\n */\nexport abstract class ToneWithContext<Options extends ToneWithContextOptions> extends Tone {\n\n\t/**\n\t * The context belonging to the node.\n\t */\n\treadonly context: Context;\n\n\t/**\n\t * The default context to use if no AudioContext is passed in to the constructor.\n\t * Probably should not be set manually. Used internally.\n\t * @hidden\n\t */\n\treadonly defaultContext?: Context;\n\n\t/**\n\t * Pass in a constructor as the first argument\n\t */\n\tconstructor(context?: Context)\n\tconstructor(options?: Partial<ToneWithContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(ToneWithContext.getDefaults(), arguments, [\"context\"]);\n\t\tif (this.defaultContext) {\n\t\t\tthis.context = this.defaultContext;\n\t\t} else {\n\t\t\tthis.context = options.context;\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneWithContextOptions {\n\t\treturn {\n\t\t\tcontext: getContext(),\n\t\t};\n\t}\n\n\t/**\n\t * Return the current time of the Context clock plus the lookAhead.\n\t */\n\tnow(): Seconds {\n\t\treturn this.context.currentTime + this.context.lookAhead;\n\t}\n\n\t/**\n\t * Return the current time of the Context clock without any lookAhead.\n\t */\n\timmediate(): Seconds {\n\t\treturn this.context.currentTime;\n\t}\n\n\t/**\n\t * The duration in seconds of one sample.\n\t */\n\tget sampleTime(): Seconds {\n\t\treturn 1 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * The number of seconds of 1 processing block (128 samples)\n\t */\n\tget blockTime(): Seconds {\n\t\treturn 128 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * Convert the incoming time to seconds\n\t */\n\ttoSeconds(time?: Time): Seconds {\n\t\treturn new TimeClass(this.context, time).toSeconds();\n\t}\n\n\t/**\n\t * Convert the input to a frequency number\n\t */\n\ttoFrequency(freq: Frequency): Hertz {\n\t\treturn new FrequencyClass(this.context, freq).toFrequency();\n\t}\n\n\t/**\n\t * Convert the input time into ticks\n\t */\n\ttoTicks(time?: Time | TimeClass): Ticks {\n\t\treturn new TransportTimeClass(this.context, time).toTicks();\n\t}\n\n\t//-------------------------------------\n\t// \tGET/SET\n\t//-------------------------------------\n\n\t/**\n\t * Get a subset of the properties which are in the partial props\n\t */\n\tprotected _getPartialProperties(props: Options): Partial<Options> {\n\t\tconst options = this.get();\n\t\t// remove attributes from the prop that are not in the partial\n\t\tObject.keys(options).forEach(name => {\n\t\t\tif (isUndef(props[name])) {\n\t\t\t\tdelete options[name];\n\t\t\t}\n\t\t});\n\t\treturn options;\n\t}\n\n\t/**\n\t * Get the object's attributes.\n\t * @example\n\t * osc.get();\n\t * //returns {\"type\" : \"sine\", \"frequency\" : 440, ...etc}\n\t */\n\tget(): Options {\n\t\tconst defaults = getDefaultsFromInstance(this) as Options;\n\t\tObject.keys(defaults).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute)) {\n\t\t\t\tconst member = this[attribute];\n\t\t\t\tif (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {\n\t\t\t\t\tdefaults[attribute] = member.value;\n\t\t\t\t} else if (member instanceof ToneWithContext) {\n\t\t\t\t\tdefaults[attribute] = member._getPartialProperties(defaults[attribute]);\n\t\t\t\t// otherwise make sure it's a serializable type\n\t\t\t\t} else if (isArray(member) || isNumber(member) || isString(member) || isBoolean(member)) {\n\t\t\t\t\tdefaults[attribute] = member;\n\t\t\t\t} else {\n\t\t\t\t\t// remove all undefined and unserializable attributes\n\t\t\t\t\tdelete defaults[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn defaults;\n\t}\n\n\t/**\n\t * Set multiple properties at once with an object.\n\t * @param  params\n\t * @example\n\t * //set values using an object\n\t * filter.set({\n\t * \t\"frequency\" : 300,\n\t * \t\"type\" : \"highpass\"\n\t * });\n\t */\n\tset(props: RecursivePartial<Options>): this {\n\t\tObject.keys(props).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute) && isDefined(this[attribute])) {\n\t\t\t\tif (this[attribute] && isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {\n\t\t\t\t\t// small optimization\n\t\t\t\t\tif (this[attribute].value !== props[attribute]) {\n\t\t\t\t\t\tthis[attribute].value = props[attribute];\n\t\t\t\t\t}\n\t\t\t\t} else if (this[attribute] instanceof ToneWithContext) {\n\t\t\t\t\tthis[attribute].set(props[attribute]);\n\t\t\t\t} else {\n\t\t\t\t\tthis[attribute] = props[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n","import { AbstractParam } from \"../context/AbstractParam\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { AudioRange, Decibels, Frequency, NormalRange, Positive, Time, Unit, UnitName } from \"../type/Units\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\n\nexport interface ParamOptions<Type> extends ToneWithContextOptions {\n\tunits: UnitName;\n\tvalue?: Type;\n\tparam: AudioParam | Param<Type>;\n\tconvert: boolean;\n\tminValue?: number;\n\tmaxValue?: number;\n\tswappable?: boolean;\n}\n\n/**\n * the possible automation types\n */\ntype AutomationType = \"linearRampToValueAtTime\" | \"exponentialRampToValueAtTime\" | \"setValueAtTime\" | \"setTargetAtTime\" | \"cancelScheduledValues\";\n\ninterface TargetAutomationEvent {\n\ttype: \"setTargetAtTime\";\n\ttime: number;\n\tvalue: number;\n\tconstant: number;\n}\n\ninterface NormalAutomationEvent {\n\ttype: Exclude<AutomationType, \"setTargetAtTime\">;\n\ttime: number;\n\tvalue: number;\n}\n/**\n * The events on the automation\n */\nexport type AutomationEvent = NormalAutomationEvent | TargetAutomationEvent;\n\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n */\nexport class Param<Type extends Unit = number>\n\textends ToneWithContext<ParamOptions<Type>>\n\timplements AbstractParam<Type> {\n\n\treadonly name: string = \"Param\";\n\n\treadonly input: GainNode | AudioParam;\n\n\treadonly units: UnitName;\n\tconvert: boolean;\n\toverridden: boolean = false;\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<AutomationEvent>;\n\n\t/**\n\t * The native parameter to control\n\t */\n\tprotected _param: AudioParam;\n\n\t/**\n\t * The default value before anything is assigned\n\t */\n\tprotected _initialValue: number;\n\n\t/**\n\t * The minimum output value\n\t */\n\tprivate _minOutput = 1e-7;\n\n\t/**\n\t * Private reference to the min and max values if passed into the constructor\n\t */\n\tprivate readonly _minValue?: number;\n\tprivate readonly _maxValue?: number;\n\n\t/**\n\t * If the underlying AudioParam can be swapped out\n\t * using the setParam method. \n\t */\n\tprotected readonly _swappable: boolean;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\tconstructor(param: AudioParam, units?: Unit, convert?: boolean);\n\tconstructor(options: Partial<ParamOptions<Type>>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n\n\t\tconst options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n\n\t\tthis.assert(isDefined(options.param) &&\n\t\t\t(isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n\n\t\twhile (!isAudioParam(options.param)) {\n\t\t\toptions.param = options.param._param;\n\t\t}\n\n\t\tthis._swappable = isDefined(options.swappable) ? options.swappable : false;\n\t\tif (this._swappable) {\n\t\t\tthis.input = this.context.createGain();\n\t\t\t// initialize\n\t\t\tthis._param = options.param;\n\t\t\tthis.input.connect(this._param);\n\t\t} else {\n\t\t\tthis._param = this.input = options.param;\n\t\t}\n\t\tthis._events = new Timeline<AutomationEvent>(1000);\n\t\tthis._initialValue = this._param.defaultValue;\n\t\tthis.units = options.units;\n\t\tthis.convert = options.convert;\n\t\tthis._minValue = options.minValue;\n\t\tthis._maxValue = options.maxValue;\n\n\t\t// if the value is defined, set it immediately\n\t\tif (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n\t\t\tthis.setValueAtTime(options.value, 0);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ParamOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t} as ParamOptions<any>);\n\t}\n\n\tget value(): Type {\n\t\tconst now = this.now();\n\t\treturn this.getValueAtTime(now);\n\t}\n\tset value(value: Type) {\n\t\tthis._initialValue = this._fromType(value);\n\t\tthis.cancelScheduledValues(this.now());\n\t\tthis.setValueAtTime(value, this.now());\n\t}\n\n\tget minValue(): number {\n\t\t// if it's not the default minValue, return it\n\t\tif (isDefined(this._minValue)) {\n\t\t\treturn this._minValue;\n\t\t} else if (this.units === \"time\" || this.units === \"frequency\" ||\n\t\t\tthis.units === \"normalRange\" || this.units === \"positive\" ||\n\t\t\tthis.units === \"transportTime\" || this.units === \"ticks\" ||\n\t\t\tthis.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n\t\t\treturn 0;\n\t\t} else if (this.units === \"audioRange\") {\n\t\t\treturn -1;\n\t\t} else if (this.units === \"decibels\") {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn this._param.minValue;\n\t\t}\n\t}\n\n\tget maxValue(): number {\n\t\tif (isDefined(this._maxValue)) {\n\t\t\treturn this._maxValue;\n\t\t} else if (this.units === \"normalRange\" ||\n\t\t\tthis.units === \"audioRange\") {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn this._param.maxValue;\n\t\t}\n\t}\n\n\t/**\n\t * Type guard based on the unit name\n\t */\n\tprivate _is<T>(arg: any, type: UnitName): arg is T {\n\t\treturn this.units === type;\n\t}\n\n\t/**\n\t * Convert the given value from the type specified by Param.units\n\t * into the destination value (such as Gain or Frequency).\n\t */\n\tprotected _fromType(val: Type): number {\n\t\tif (this.convert && !this.overridden) {\n\t\t\tif (this._is<Time>(val, \"time\")) {\n\t\t\t\treturn this.toSeconds(val);\n\t\t\t} else if (this._is<Decibels>(val, \"decibels\")) {\n\t\t\t\treturn dbToGain(val);\n\t\t\t} else if (this._is<Frequency>(val, \"frequency\")) {\n\t\t\t\treturn this.toFrequency(val);\n\t\t\t} else if (this._is<NormalRange>(val, \"normalRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, 0), 1);\n\t\t\t} else if (this._is<AudioRange>(val, \"audioRange\")) {\n\t\t\t\treturn Math.min(Math.max(val, -1), 1);\n\t\t\t} else if (this._is<Positive>(val, \"positive\")) {\n\t\t\t\treturn Math.max(val, 0);\n\t\t\t} else if (this._is<number>(val, \"number\")) {\n\t\t\t\treturn val;\n\t\t\t} else {\n\t\t\t\treturn val as number;\n\t\t\t}\n\t\t} else {\n\t\t\treturn val as number;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the parameters value into the units specified by Param.units.\n\t */\n\tprotected _toType(val: number): Type {\n\t\tif (this.convert && this.units === \"decibels\") {\n\t\t\treturn gainToDb(val) as Type;\n\t\t} else {\n\t\t\treturn val as Type;\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// ABSTRACT PARAM INTERFACE\n\t// all docs are generated from ParamInterface.ts\n\t//-------------------------------------\n\n\tsetValueAtTime(value: Type, time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst numericValue = this._fromType(value);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n\n\t\tthis.log(this.units, \"setValueAtTime\", value, computedTime);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis._param.setValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\tgetValueAtTime(time: Time): Type {\n\t\tconst computedTime = Math.max(this.toSeconds(time), 0);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tconst before = this._events.get(computedTime);\n\t\tlet value = this._initialValue;\n\t\t// if it was set by\n\t\tif (before === null) {\n\t\t\tvalue = this._initialValue;\n\t\t} else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\tlet previousVal;\n\t\t\tif (previous === null) {\n\t\t\t\tpreviousVal = this._initialValue;\n\t\t\t} else {\n\t\t\t\tpreviousVal = previous.value;\n\t\t\t}\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tvalue = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n\t\t\t}\n\t\t} else if (after === null) {\n\t\t\tvalue = before.value;\n\t\t} else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n\t\t\tlet beforeValue = before.value;\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\t\tif (previous === null) {\n\t\t\t\t\tbeforeValue = this._initialValue;\n\t\t\t\t} else {\n\t\t\t\t\tbeforeValue = previous.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tvalue = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t} else {\n\t\t\t\tvalue = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = before.value;\n\t\t}\n\t\treturn this._toType(value);\n\t}\n\n\tsetRampPoint(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tlet currentVal = this.getValueAtTime(time);\n\t\tthis.cancelAndHoldAtTime(time);\n\t\tif (this._fromType(currentVal) === 0) {\n\t\t\tcurrentVal = this._toType(this._minOutput);\n\t\t}\n\t\tthis.setValueAtTime(currentVal, time);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: Type, endTime: Time): this {\n\t\tconst numericValue = this._fromType(value);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"linearRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n\t\tthis._param.linearRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: Type, endTime: Time): this {\n\t\tlet numericValue = this._fromType(value);\n\t\tnumericValue = Math.max(this._minOutput, numericValue);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\t// store the event\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"exponentialRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n\t\tthis._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\tlinearRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialApproachValueAtTime(value, startTime, rampTime);\n\t\treturn this;\n\t}\n\n\texponentialApproachValueAtTime(value: Type, time: Time, rampTime: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\trampTime = this.toSeconds(rampTime);\n\t\tconst timeConstant = Math.log(rampTime + 1) / Math.log(200);\n\t\tthis.setTargetAtTime(value, time, timeConstant);\n\t\t// at 90% start a linear ramp to the final value\n\t\tthis.cancelAndHoldAtTime(time + rampTime * 0.9);\n\t\tthis.linearRampToValueAtTime(value, time + rampTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(value: Type, startTime: Time, timeConstant: Positive): this {\n\t\tconst numericValue = this._fromType(value);\n\t\t// The value will never be able to approach without timeConstant > 0.\n\t\tthis.assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n\t\tconst computedTime = this.toSeconds(startTime);\n\t\tthis.assert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n\t\tthis._events.add({\n\t\t\tconstant: timeConstant,\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setTargetAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n\t\tthis._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: Type[], startTime: Time, duration: Time, scaling: number = 1): this {\n\t\tduration = this.toSeconds(duration);\n\t\tstartTime = this.toSeconds(startTime);\n\t\tconst startingValue = this._fromType(values[0]) * scaling;\n\t\tthis.setValueAtTime(this._toType(startingValue), startTime);\n\t\tconst segTime = duration / (values.length - 1);\n\t\tfor (let i = 1; i < values.length; i++) {\n\t\t\tconst numericValue = this._fromType(values[i]) * scaling;\n\t\t\tthis.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n\t\tthis._events.cancel(computedTime);\n\t\tthis._param.cancelScheduledValues(computedTime);\n\t\tthis.log(this.units, \"cancelScheduledValues\", computedTime);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n\t\t// remove the schedule events\n\t\tthis.assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n\n\t\tthis.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n\n\t\tthis._param.cancelScheduledValues(computedTime);\n\n\t\t// if there is an event at the given computedTime\n\t\t// and that even is not a \"set\"\n\t\tconst before = this._events.get(computedTime);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tif (before && before.time === computedTime) {\n\t\t\t// remove everything after\n\t\t\tif (after) {\n\t\t\t\tthis._events.cancel(after.time);\n\t\t\t} else {\n\t\t\t\tthis._events.cancel(computedTime + this.sampleTime);\n\t\t\t}\n\t\t} else if (after) {\n\t\t\t// cancel the next event(s)\n\t\t\tthis._events.cancel(after.time);\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tthis.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t} else if (after.type === \"exponentialRampToValueAtTime\") {\n\t\t\t\tthis.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t}\n\t\t}\n\n\t\t// set the value at the given time\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: valueAtTime,\n\t\t});\n\t\tthis._param.setValueAtTime(valueAtTime, computedTime);\n\t\treturn this;\n\t}\n\n\trampTo(value: Type, rampTime: Time = 0.1, startTime?: Time): this {\n\t\tif (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n\t\t\tthis.exponentialRampTo(value, rampTime, startTime);\n\t\t} else {\n\t\t\tthis.linearRampTo(value, rampTime, startTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n\t * The applied values will start at the context's current time and schedule\n\t * all of the events which are scheduled on this Param onto the passed in param.\n\t */\n\tapply(param: Param | AudioParam): this {\n\t\tconst now = this.context.currentTime;\n\t\t// set the param's value at the current time and schedule everything else\n\t\tparam.setValueAtTime(this.getValueAtTime(now) as number, now);\n\t\t// if the previous event was a curve, then set the rest of it\n\t\tconst previousEvent = this._events.get(now);\n\t\tif (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n\t\t\t// approx it until the next event with linear ramps\n\t\t\tconst nextEvent = this._events.getAfter(previousEvent.time);\n\t\t\t// or for 2 seconds if there is no event\n\t\t\tconst endTime = nextEvent ? nextEvent.time : now + 2;\n\t\t\tconst subdivisions = (endTime - now) / 10;\n\t\t\tfor (let i = now; i < endTime; i += subdivisions) {\n\t\t\t\tparam.linearRampToValueAtTime(this.getValueAtTime(i) as number, i);\n\t\t\t}\n\t\t}\n\t\tthis._events.forEachAfter(this.context.currentTime, event => {\n\t\t\tif (event.type === \"cancelScheduledValues\") {\n\t\t\t\tparam.cancelScheduledValues(event.time);\n\t\t\t} else if (event.type === \"setTargetAtTime\") {\n\t\t\t\tparam.setTargetAtTime(event.value, event.time, event.constant);\n\t\t\t} else {\n\t\t\t\tparam[event.type](event.value, event.time);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Replace the Param's internal AudioParam. Will apply scheduled curves \n\t * onto the parameter and replace the connections.\n\t */\n\tsetParam(param: AudioParam): this {\n\t\tthis.assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n\t\tconst input = this.input as GainNode;\n\t\tinput.disconnect(this._param);\n\t\tthis.apply(param);\n\t\tthis._param = param;\n\t\tinput.connect(this._param);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\treturn this;\n\t}\n\n\tget defaultValue(): Type {\n\t\treturn this._toType(this._param.defaultValue);\n\t}\n\n\t//-------------------------------------\n\t// \tAUTOMATION CURVE CALCULATIONS\n\t// \tMIT License, copyright (c) 2014 Jordan Santell\n\t//-------------------------------------\n\n\t// Calculates the the value along the curve produced by setTargetAtTime\n\tprotected _exponentialApproach(t0: number, v0: number, v1: number, timeConstant: number, t: number): number {\n\t\treturn v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t}\n\n\t// Calculates the the value along the curve produced by linearRampToValueAtTime\n\tprotected _linearInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t}\n\n\t// Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\tprotected _exponentialInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t}\n}\n","import { Unit } from \"../type/Units\";\nimport { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { assert } from \"../util/Debug\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\nimport { warn } from \"../util/Debug\";\n\nexport type InputNode = ToneAudioNode | AudioNode | Param<any> | AudioParam;\nexport type OutputNode = ToneAudioNode | AudioNode;\n\ninterface ChannelProperties {\n\tchannelCount: number;\n\tchannelCountMode: ChannelCountMode;\n\tchannelInterpretation: ChannelInterpretation;\n}\n\n/**\n * The possible options for this node\n */\nexport type ToneAudioNodeOptions = ToneWithContextOptions;\n\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\nexport abstract class ToneAudioNode<Options extends ToneAudioNodeOptions = ToneAudioNodeOptions>\n\textends ToneWithContext<Options> {\n\n\t/**\n\t * The name of the class\n\t */\n\tabstract readonly name: string = \"AudioNode\";\n\n\t/**\n\t * The input node or nodes. If the object is a source,\n\t * it does not have any input and this.input is undefined.\n\t */\n\tabstract input: InputNode | undefined;\n\n\t/**\n\t * The output nodes. If the object is a sink,\n\t * it does not have any output and this.output is undefined.\n\t */\n\tabstract output: OutputNode | undefined;\n\n\t/**\n\t * The number of inputs feeding into the AudioNode.\n\t * For source nodes, this will be 0.\n\t */\n\tget numberOfInputs(): number {\n\t\tif (isDefined(this.input)) {\n\t\t\tif (isAudioParam(this.input) || this.input instanceof Param) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn this.input.numberOfInputs;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of outputs of the AudioNode.\n\t */\n\tget numberOfOutputs(): number {\n\t\tif (isDefined(this.output)) {\n\t\t\treturn this.output.numberOfOutputs;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * List all of the node that must be set to match the ChannelProperties\n\t */\n\tprotected _internalChannels: OutputNode[] = [];\n\n\t//-------------------------------------\n\t// AUDIO PROPERTIES\n\t//-------------------------------------\n\n\t/**\n\t * Used to decide which nodes to get/set properties on\n\t */\n\tprivate _isAudioNode(node: any): node is AudioNode | ToneAudioNode {\n\t\treturn isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n\t}\n\n\t/**\n\t * Get all of the audio nodes (either internal or input/output) which together\n\t * make up how the class node responds to channel input/output\n\t */\n\tprivate _getInternalNodes(): OutputNode[] {\n\t\tconst nodeList = this._internalChannels.slice(0);\n\t\tif (this._isAudioNode(this.input)) {\n\t\t\tnodeList.push(this.input);\n\t\t}\n\t\tif (this._isAudioNode(this.output)) {\n\t\t\tif (this.input !== this.output) {\n\t\t\t\tnodeList.push(this.output);\n\t\t\t}\n\t\t}\n\t\treturn nodeList;\n\t}\n\n\t/**\n\t * Set the audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t * @param options\n\t */\n\tprivate _setChannelProperties(options: ChannelProperties): void {\n\t\tconst nodeList = this._getInternalNodes();\n\t\tnodeList.forEach(node => {\n\t\t\tnode.channelCount = options.channelCount;\n\t\t\tnode.channelCountMode = options.channelCountMode;\n\t\t\tnode.channelInterpretation = options.channelInterpretation;\n\t\t});\n\t}\n\n\t/**\n\t * Get the current audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t */\n\tprivate _getChannelProperties(): ChannelProperties {\n\t\tconst nodeList = this._getInternalNodes();\n\t\tthis.assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\");\n\t\t// use the first node to get properties\n\t\t// they should all be the same\n\t\tconst node = nodeList[0];\n\t\treturn {\n\t\t\tchannelCount: node.channelCount,\n\t\t\tchannelCountMode: node.channelCountMode,\n\t\t\tchannelInterpretation: node.channelInterpretation,\n\t\t};\n\t}\n\n\t/**\n\t * channelCount is the number of channels used when up-mixing and down-mixing\n\t * connections to any inputs to the node. The default value is 2 except for\n\t * specific nodes where its value is specially determined.\n\t */\n\tget channelCount(): number {\n\t\treturn this._getChannelProperties().channelCount;\n\t}\n\tset channelCount(channelCount) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCount }));\n\t}\n\n\t/**\n\t * channelCountMode determines how channels will be counted when up-mixing and\n\t * down-mixing connections to any inputs to the node.\n\t * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n\t * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n\t * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n\t * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n\t */\n\tget channelCountMode(): ChannelCountMode {\n\t\treturn this._getChannelProperties().channelCountMode;\n\t}\n\tset channelCountMode(channelCountMode) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCountMode }));\n\t}\n\n\t/**\n\t * channelInterpretation determines how individual channels will be treated\n\t * when up-mixing and down-mixing connections to any inputs to the node.\n\t * The default value is \"speakers\".\n\t */\n\tget channelInterpretation(): ChannelInterpretation {\n\t\treturn this._getChannelProperties().channelInterpretation;\n\t}\n\tset channelInterpretation(channelInterpretation) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelInterpretation }));\n\t}\n\n\t//-------------------------------------\n\t// CONNECTIONS\n\t//-------------------------------------\n\n\t/**\n\t * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n\t * @param unit The output to connect to\n\t * @param outputNum The output to connect from\n\t * @param inputNum The input to connect to\n\t */\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t */\n\ttoDestination(): this {\n\t\tthis.connect(this.context.destination);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t * alias for {@link toDestination}\n\t * @deprecated\n\t */\n\ttoMaster(): this {\n\t\twarn(\"toMaster() has been renamed toDestination()\");\n\t\treturn this.toDestination();\n\t}\n\n\t/**\n\t * disconnect the output\n\t */\n\tdisconnect(destination?: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tdisconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output of this node to the rest of the nodes in series.\n\t * @example\n\t * //connect a node to an effect, panVol and then to the master output\n\t * node.chain(effect, panVol, Tone.Destination);\n\t */\n\tchain(...nodes: InputNode[]): this {\n\t\tconnectSeries(this, ...nodes);\n\t\treturn this;\n\t}\n\n\t/**\n\t * connect the output of this node to the rest of the nodes in parallel.\n\t */\n\tfan(...nodes: InputNode[]): this {\n\t\tnodes.forEach(node => this.connect(node));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Dispose and disconnect\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (isDefined(this.input)) {\n\t\t\tif (this.input instanceof ToneAudioNode) {\n\t\t\t\tthis.input.dispose();\n\t\t\t} else if (isAudioNode(this.input)) {\n\t\t\t\tthis.input.disconnect();\n\t\t\t}\n\t\t}\n\t\tif (isDefined(this.output)) {\n\t\t\tif (this.output instanceof ToneAudioNode) {\n\t\t\t\tthis.output.dispose();\n\t\t\t} else if (isAudioNode(this.output)) {\n\t\t\t\tthis.output.disconnect();\n\t\t\t}\n\t\t}\n\t\tthis._internalChannels = [];\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\nexport function connectSeries(...nodes: InputNode[]): void {\n\tconst first = nodes.shift();\n\tnodes.reduce((prev, current) => {\n\t\tif (prev instanceof ToneAudioNode) {\n\t\t\tprev.connect(current);\n\t\t} else if (isAudioNode(prev)) {\n\t\t\tconnect(prev, current);\n\t\t}\n\t\treturn current;\n\t}, first);\n}\n\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(srcNode: OutputNode, dstNode: InputNode, outputNumber = 0, inputNumber = 0): void {\n\n\tassert(isDefined(srcNode), \"Cannot connect from undefined node\");\n\tassert(isDefined(dstNode), \"Cannot connect to undefined node\");\n\n\tif (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n\t\tassert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n\t}\n\tassert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\");\n\n\t// resolve the input of the dstNode\n\twhile (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {\n\t\tif (isDefined(dstNode.input)) {\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t}\n\n\twhile (srcNode instanceof ToneAudioNode) {\n\t\tif (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t}\n\n\t// make the connection\n\tif (isAudioParam(dstNode)) {\n\t\tsrcNode.connect(dstNode as AudioParam, outputNumber);\n\t} else {\n\t\tsrcNode.connect(dstNode, outputNumber, inputNumber);\n\t}\n}\n\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(\n\tsrcNode: OutputNode,\n\tdstNode?: InputNode,\n\toutputNumber = 0,\n\tinputNumber = 0,\n): void {\n\n\t// resolve the destination node\n\tif (isDefined(dstNode)) {\n\t\twhile (dstNode instanceof ToneAudioNode) {\n\t\t\tif (dstNode.input) {\n\t\t\t\tdstNode = dstNode.input;\n\t\t\t}\n\t\t}\n\t}\n\n\t// resolve the src node\n\twhile (!(isAudioNode(srcNode))) {\n\t\tif (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t}\n\n\tif (isAudioParam(dstNode)) {\n\t\tsrcNode.disconnect(dstNode as AudioParam, outputNumber);\n\t} else if (isAudioNode(dstNode)) {\n\t\tsrcNode.disconnect(dstNode, outputNumber, inputNumber);\n\t} else {\n\t\tsrcNode.disconnect();\n\t}\n}\n","import { Param } from \"../context/Param\";\nimport { GainFactor, Unit, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface GainOptions extends ToneAudioNodeOptions {\n\tgain: number;\n\tunits: UnitName;\n\tconvert: boolean;\n}\n\n/**\n * A thin wrapper around the Native Web Audio GainNode.\n * The GainNode is a basic building block of the Web Audio\n * API and is useful for routing audio and adjusting gains.\n * @category Core\n */\nexport class Gain<Type extends Unit = GainFactor> extends ToneAudioNode<GainOptions> {\n\n\treadonly name: string = \"Gain\";\n\n\t/**\n\t * The gain parameter of the gain node.\n\t */\n\treadonly gain: Param<Type>;\n\n\t/**\n\t * The wrapped GainNode.\n\t */\n\tprivate _gainNode: GainNode = this.context.createGain();\n\n\t// input = output\n\treadonly input: GainNode = this._gainNode;\n\treadonly output: GainNode = this._gainNode;\n\n\t/**\n\t * @param  gain The initial gain of the GainNode\n\t * @param units The units of the gain parameter.\n\t */\n\tconstructor(gain?: GainFactor, units?: Unit);\n\tconstructor(options?: Partial<GainOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]));\n\t\tconst options = optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]);\n\n\t\tthis.gain = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tparam: this._gainNode.gain,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.gain as Type,\n\t\t});\n\t\treadOnly(this, \"gain\");\n\t}\n\n\tstatic getDefaults(): GainOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tgain: 1,\n\t\t\tunits: \"gain\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","import { getContext, setContext } from \"../Global\";\nimport { Seconds } from \"../type/Units\";\nimport { OfflineContext } from \"./OfflineContext\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of [[Context]] which can be used\n * to schedule events along the Transport. \n * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.\n * @example\n * //render 2 seconds of the oscillator\n * Tone.Offline(() => {\n * \t//only nodes created in this callback will be recorded\n * \tvar oscillator = new Tone.Oscillator().toDestination().start(0)\n * \t//schedule their events\n * }, 2).then((buffer) => {\n * \t//do something with the output buffer\n * })\n * @example\n * //can also schedule events along the Transport\n * //using the passed in Offline Transport\n * Tone.Offline(({ transport }) => {\n * \tvar osc = new Tone.Oscillator().toDestination()\n * \ttransport.schedule(function(time){\n * \t\tosc.start(time).stop(time + 0.1)\n * \t}, 1)\n * \ttransport.start(0.2)\n * }, 4).then((buffer) => {\n * \t//do something with the output buffer\n * })\n * @category Core\n */\nexport async function Offline(\n\tcallback: (context: OfflineContext) => Promise<void> | void,\n\tduration: Seconds,\n\tchannels: number = 2,\n\tsampleRate: number = getContext().sampleRate,\n): Promise<ToneAudioBuffer> {\n\t// set the OfflineAudioContext based on the current context\n\tconst originalContext = getContext();\n\n\tconst context = new OfflineContext(channels, duration, sampleRate);\n\tsetContext(context);\n\n\t// invoke the callback/scheduling\n\tawait callback(context);\n\n\t// then render the audio\n\tconst bufferPromise = context.render();\n\n\t// return the original AudioContext\n\tsetContext(originalContext);\n\n\t// await the rendering\n\tconst buffer = await bufferPromise;\n\n\t// return the audio\n\treturn new ToneAudioBuffer(buffer);\n}\n","import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isString } from \"../util/TypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\nexport interface ToneAudioBuffersUrlMap {\n\t[name: string]: string | AudioBuffer | ToneAudioBuffer;\n\t[name: number]: string | AudioBuffer | ToneAudioBuffer;\n}\n\ninterface ToneAudioBuffersOptions {\n\turls: ToneAudioBuffersUrlMap;\n\tonload: () => void;\n\tonerror?: (error: Error) => void;\n\tbaseUrl: string;\n}\n\n/**\n * A data structure for holding multiple buffers in a Map-like datastructure.\n *\n * @example\n * //load a whole bank of piano samples\n * var pianoSamples = new ToneAudioBuffers({\n * \t\"C4\" : \"path/to/C4.mp3\"\n * \t\"C#4\" : \"path/to/C#4.mp3\"\n * \t\"D4\" : \"path/to/D4.mp3\"\n * \t\"D#4\" : \"path/to/D#4.mp3\"\n * }, function(){\n * \t//play one of the samples when they all load\n * \tplayer.buffer = pianoSamples.get(\"C4\");\n * \tplayer.start();\n * });\n * @example\n * //To pass in additional parameters in the second parameter\n * var buffers = new ToneAudioBuffers(urls, {\n * \t\"onload\" : callback,\n * \t\"baseUrl\" : \"../path/to/audio/\"\n * })\n * @category Core\n */\nexport class ToneAudioBuffers extends Tone {\n\n\treadonly name: string = \"ToneAudioBuffers\";\n\n\t/**\n\t * All of the buffers\n\t */\n\tprivate _buffers: Map<string, ToneAudioBuffer> = new Map();\n\n\t/**\n\t * A path which is prefixed before every url.\n\t */\n\tbaseUrl: string;\n\n\t/**\n\t * Keep track of the number of loaded buffers\n\t */\n\tprivate _loadingCount: number = 0;\n\n\t/**\n\t * @param  urls  An object literal or array of urls to load.\n\t * @param onload  The callback to invoke when the buffers are loaded.\n\t * @param baseUrl A prefix url to add before all the urls\n\t */\n\tconstructor(\n\t\turls?: ToneAudioBuffersUrlMap,\n\t\tonload?: () => void,\n\t\tbaseUrl?: string,\n\t);\n\tconstructor(options?: Partial<ToneAudioBuffersOptions>);\n\tconstructor() {\n\n\t\tsuper();\n\t\tconst options = optionsFromArguments(\n\t\t\tToneAudioBuffers.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\",\n\t\t);\n\n\t\tthis.baseUrl = options.baseUrl;\n\t\t// add each one\n\t\tObject.keys(options.urls).forEach(name => {\n\t\t\tthis._loadingCount++;\n\t\t\tconst url = options.urls[name];\n\t\t\tthis.add(name, url, this._bufferLoaded.bind(this, options.onload));\n\t\t});\n\n\t}\n\n\tstatic getDefaults(): ToneAudioBuffersOptions {\n\t\treturn {\n\t\t\tbaseUrl: \"\",\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\turls: {},\n\t\t};\n\t}\n\n\t/**\n\t * True if the buffers object has a buffer by that name.\n\t * @param  name  The key or index of the buffer.\n\t */\n\thas(name: string | number): boolean {\n\t\treturn this._buffers.has(name.toString());\n\t}\n\n\t/**\n\t * Get a buffer by name. If an array was loaded,\n\t * then use the array index.\n\t * @param  name  The key or index of the buffer.\n\t */\n\tget(name: string | number): ToneAudioBuffer {\n\t\tthis.assert(this.has(name), `ToneAudioBuffers has no buffer named: ${name}`);\n\t\treturn this._buffers.get(name.toString()) as ToneAudioBuffer;\n\t}\n\n\t/**\n\t * A buffer was loaded. decrement the counter.\n\t */\n\tprivate _bufferLoaded(callback: () => void): void {\n\t\tthis._loadingCount--;\n\t\tif (this._loadingCount === 0 && callback) {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn Array.from(this._buffers).every(([_, buffer]) => buffer.loaded);\n\t}\n\n\t/**\n\t * Add a buffer by name and url to the Buffers\n\t * @param  name      A unique name to give the buffer\n\t * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(\n\t\tname: string | number,\n\t\turl: string | AudioBuffer | ToneAudioBuffer,\n\t\tcallback: () => void = noOp,\n\t): this {\n\t\tif (isString(url)) {\n\t\t\tthis._buffers.set(name.toString(), new ToneAudioBuffer(this.baseUrl + url, callback));\n\t\t} else {\n\t\t\tthis._buffers.set(name.toString(), new ToneAudioBuffer(url, callback));\n\t\t}\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.forEach(buffer => buffer.dispose());\n\t\tthis._buffers.clear();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../context/Param\";\nimport { Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\nexport interface DelayOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tmaxDelay: Time;\n}\n\n/**\n * Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).\n * @category Core\n */\nexport class Delay extends ToneAudioNode<DelayOptions> {\n\n\treadonly name: string = \"Delay\";\n\n\t/**\n\t * The maximum delay time. This cannot be changed after\n\t * the value is passed into the constructor.\n\t */\n\treadonly maxDelay: Time;\n\n\t/**\n\t * The amount of time the incoming signal is delayed.\n\t */\n\treadonly delayTime: Param<Time>;\n\n\t/**\n\t * Private reference to the internal DelayNode\n\t */\n\tprivate _delayNode: DelayNode;\n\treadonly input: DelayNode;\n\treadonly output: DelayNode;\n\n\t/**\n\t * @param delayTime The delay applied to the incoming signal.\n\t * @param maxDelay The maximum delay time.\n\t */\n\tconstructor(delayTime?: Time, maxDelay?: Time);\n\tconstructor(options?: Partial<DelayOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]));\n\n\t\tconst options = optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]);\n\n\t\tconst maxDelayInSeconds = this.toSeconds(options.maxDelay);\n\t\tthis.maxDelay = Math.max(maxDelayInSeconds, this.toSeconds(options.delayTime));\n\n\t\tthis._delayNode = this.input = this.output = this.context.createDelay(maxDelayInSeconds);\n\n\t\tthis.delayTime = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._delayNode.delayTime,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.delayTime,\n\t\t});\n\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): DelayOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime: 0,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.disconnect();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { Seconds } from \"../type/Units\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\n\nexport type BasicPlaybackState = \"started\" | \"stopped\";\nexport type PlaybackState = BasicPlaybackState | \"paused\";\n\nexport interface StateTimelineEvent extends TimelineEvent {\n\tstate: PlaybackState;\n}\n\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\nexport class StateTimeline<AdditionalOptions extends {} = {}> extends Timeline<StateTimelineEvent & AdditionalOptions> {\n\n\treadonly name: string = \"StateTimeline\";\n\n\t/**\n\t * The initial state\n\t */\n\tprivate _initial: PlaybackState;\n\n\tconstructor(initial: PlaybackState = \"stopped\") {\n\t\tsuper();\n\t\tthis._initial = initial;\n\t}\n\n\t/**\n\t * Returns the scheduled state scheduled before or at\n\t * the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t */\n\tgetValueAtTime(time: Seconds): PlaybackState {\n\t\tconst event = this.get(time);\n\t\tif (event !== null) {\n\t\t\treturn event.state;\n\t\t} else {\n\t\t\treturn this._initial;\n\t\t}\n\t}\n\n\t/**\n\t * Add a state to the timeline.\n\t * @param  state The name of the state to set.\n\t * @param  time  The time to query.\n\t * @param options Any additional options that are needed in the timeline.\n\t */\n\tsetStateAtTime(state: PlaybackState, time: Seconds, options?: AdditionalOptions): this {\n\t\tthis.add(Object.assign({}, options, {\n\t\t\tstate,\n\t\t\ttime,\n\t\t}));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the event before the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check before\n\t * @return  The event with the given state before the time\n\t */\n\tgetLastState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tfor (let i = index; i >= 0; i--) {\n\t\t\tconst event = this._timeline[i];\n\t\t\tif (event.state === state) {\n\t\t\t\treturn event;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the event after the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check from\n\t * @return  The event with the given state after the time\n\t */\n\tgetNextState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tif (index !== -1) {\n\t\t\tfor (let i = index; i < this._timeline.length; i++) {\n\t\t\t\tconst event = this._timeline[i];\n\t\t\t\tif (event.state === state) {\n\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { GainFactor, Seconds, Time } from \"../core/type/Units\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState } from \"../core/util/StateTimeline\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\n\nexport type OneShotSourceCurve = \"linear\" | \"exponential\";\n\ntype onEndedCallback = (source: OneShotSource<any>) => void;\n\nexport interface OneShotSourceOptions extends ToneAudioNodeOptions {\n\tonended: onEndedCallback;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tcurve: OneShotSourceCurve;\n}\n\n/**\n * Base class for fire-and-forget nodes\n */\nexport abstract class OneShotSource<Options extends ToneAudioNodeOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t * The callback to invoke after the\n\t * source is done playing.\n\t */\n\tonended: onEndedCallback = noOp;\n\n\t/**\n\t * Sources do not have input nodes\n\t */\n\tinput: undefined;\n\n\t/**\n\t * The start time\n\t */\n\tprotected _startTime: number = -1;\n\n\t/**\n\t * The stop time\n\t */\n\tprotected _stopTime: number = -1;\n\n\t/**\n\t * The id of the timeout\n\t */\n\tprivate _timeout: number = -1;\n\n\t/**\n\t * The public output node\n\t */\n\toutput: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The output gain node.\n\t */\n\tprotected _gainNode = this.output;\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tprotected _curve: OneShotSourceCurve;\n\n\tconstructor(options: OneShotSourceOptions) {\n\t\tsuper(options);\n\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t\tthis._curve = options.curve;\n\t\tthis.onended = options.onended;\n\t}\n\n\tstatic getDefaults(): OneShotSourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tcurve: \"linear\" as OneShotSourceCurve,\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tonended: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Stop the source node\n\t */\n\tprotected abstract _stopSource(time: Seconds): void;\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the node\n\t */\n\tprotected abstract start(time?: Time): this;\n\t/**\n\t * Start the source at the given time\n\t * @param  time When to start the source\n\t */\n\tprotected _startGain(time: Seconds, gain: GainFactor = 1): this {\n\t\tthis.assert(this._startTime === -1, \"Source cannot be started more than once\");\n\t\t// apply a fade in envelope\n\t\tconst fadeInTime = this.toSeconds(this._fadeIn);\n\n\t\t// record the start time\n\t\tthis._startTime = time + fadeInTime;\n\t\tthis._startTime = Math.max(this._startTime, this.context.currentTime);\n\n\t\t// schedule the envelope\n\t\tif (fadeInTime > 0) {\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampToValueAtTime(gain, time + fadeInTime);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.exponentialApproachValueAtTime(gain, time, fadeInTime);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._gainNode.gain.setValueAtTime(gain, time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source node at the given time.\n\t * @param time When to stop the source\n\t */\n\tstop(time?: Time): this {\n\t\tthis.log(\"stop\", time);\n\t\tthis._stopGain(this.toSeconds(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the given time\n\t * @param  time When to stop the source\n\t */\n\tprotected _stopGain(time: Seconds): this {\n\t\tthis.assert(this._startTime !== -1, \"'start' must be called before 'stop'\");\n\t\t// cancel the previous stop\n\t\tthis.cancelStop();\n\n\t\t// the fadeOut time\n\t\tconst fadeOutTime = this.toSeconds(this._fadeOut);\n\n\t\t// schedule the stop callback\n\t\tthis._stopTime = this.toSeconds(time) + fadeOutTime;\n\t\tthis._stopTime = Math.max(this._stopTime, this.context.currentTime);\n\t\tif (fadeOutTime > 0) {\n\t\t\t// start the fade out curve at the given time\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// stop any ongoing ramps, and set the value to 0\n\t\t\tthis._gainNode.gain.cancelAndHoldAtTime(time);\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t}\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._timeout = this.context.setTimeout(() => {\n\t\t\t// allow additional time for the exponential curve to fully decay\n\t\t\tconst additionalTail = this._curve === \"exponential\" ? fadeOutTime * 2 : 0;\n\t\t\tthis._stopSource(this.now() + additionalTail);\n\t\t\tthis._onended();\n\t\t}, this._stopTime - this.context.now());\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the onended callback\n\t */\n\tprotected _onended(): void {\n\t\tif (this.onended !== noOp) {\n\t\t\tthis.onended(this);\n\t\t\t// overwrite onended to make sure it only is called once\n\t\t\tthis.onended = noOp;\n\t\t\t// dispose when it's ended to free up for garbage collection only in the online context\n\t\t\tif (!this.context.isOffline) {\n\t\t\t\tsetTimeout(() => this.dispose(), 1000);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the playback state at the given time\n\t */\n\tgetStateAtTime = function(time: Time): BasicPlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._startTime !== -1 && computedTime >= this._startTime &&\n\t\t\t(this._stopTime === -1 || computedTime <= this._stopTime)) {\n\t\t\treturn \"started\";\n\t\t} else {\n\t\t\treturn \"stopped\";\n\t\t}\n\t};\n\n\t/**\n\t * Get the playback state at the current time\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Cancel a scheduled stop event\n\t */\n\tcancelStop(): this {\n\t\tthis.log(\"cancelStop\");\n\t\tthis.assert(this._startTime !== -1, \"Source is not started\");\n\t\t// cancel the stop envelope\n\t\tthis._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._stopTime = -1;\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../core/Connect\";\nimport { Param } from \"../core/context/Param\";\nimport { Seconds, Time, Unit, UnitName } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { OneShotSource, OneShotSourceOptions } from \"../source/OneShotSource\";\n\nexport interface ToneConstantSourceOptions<Type> extends OneShotSourceOptions {\n\tconvert: boolean;\n\toffset: Type;\n\tunits: UnitName;\n}\n\n/**\n * Wrapper around the native fire-and-forget ConstantSource.\n * Adds the ability to reschedule the stop method.\n * @category Signal\n */\nexport class ToneConstantSource<Type extends Unit = number> extends OneShotSource<ToneConstantSourceOptions<Type>> {\n\n\treadonly name: string = \"ToneConstantSource\";\n\n\t/**\n\t * The signal generator\n\t */\n\tprivate _source = this.context.createConstantSource();\n\n\t/**\n\t * The offset of the signal generator\n\t */\n\treadonly offset: Param<Type>;\n\n\t/**\n\t * @param  offset   The offset value\n\t */\n\tconstructor(offset: Type);\n\tconstructor(options?: Partial<ToneConstantSourceOptions<Type>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneConstantSource.getDefaults(), arguments, [\"offset\"]));\n\t\tconst options = optionsFromArguments(ToneConstantSource.getDefaults(), arguments, [\"offset\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\n\t\tthis.offset = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tparam: this._source.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.offset,\n\t\t});\n\t}\n\n\tstatic getDefaults(): ToneConstantSourceOptions<any> {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\toffset: 1,\n\t\t\tunits: \"number\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the source\n\t */\n\tstart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tthis._startGain(computedTime);\n\t\tthis._source.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tthis._source.stop(time);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this.state === \"started\") {\n\t\t\tthis.stop();\n\t\t}\n\t\tthis._source.disconnect();\n\t\tthis.offset.dispose();\n\t\treturn this;\n\t}\n}\n","import { AbstractParam } from \"../core/context/AbstractParam\";\nimport { Param } from \"../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connect } from \"../core/context/ToneAudioNode\";\nimport { Time, Unit, UnitName } from \"../core/type/Units\";\nimport { isAudioParam } from \"../core/util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\n\nexport interface SignalOptions<Type> extends ToneAudioNodeOptions {\n\tvalue: Type;\n\tunits: UnitName;\n\tconvert: boolean;\n}\n\n/**\n * A signal is an audio-rate value. Tone.Signal is a core component of the library.\n * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n * has all of the methods available to native Web Audio\n * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n * as well as additional conveniences. Read more about working with signals\n * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n *\n * @example\n * const signal = new Tone.Signal(10);\n * @category Signal\n */\nexport class Signal<Type extends Unit = number> extends ToneAudioNode<SignalOptions<any>>\n\timplements AbstractParam<Type> {\n\n\treadonly name: string = \"Signal\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection.\n\t */\n\treadonly override: boolean = true;\n\n\t/**\n\t * The constant source node which generates the signal\n\t */\n\tprotected _constantSource: ToneConstantSource<Type>;\n\treadonly output: OutputNode;\n\tprotected _param: Param<Type>;\n\treadonly input: InputNode;\n\n\t/**\n\t * @param value Initial value of the signal\n\t * @param units The unit name, e.g. \"frequency\"\n\t */\n\tconstructor(value?: Type, units?: UnitName);\n\tconstructor(options?: Partial<SignalOptions<Type>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n\n\t\tconst options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]) as SignalOptions<Type>;\n\n\t\tthis.output = this._constantSource = new ToneConstantSource({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\toffset: options.value,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._constantSource.start(0);\n\t\tthis.input = this._param = this._constantSource.offset;\n\t}\n\n\tstatic getDefaults(): SignalOptions<any> {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tconnect(destination: InputNode, outputNum: number = 0, inputNum: number = 0): this {\n\t\t// start it only when connected to something\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._param.dispose();\n\t\tthis._constantSource.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// ABSTRACT PARAM INTERFACE\n\t// just a proxy for the ConstantSourceNode's offset AudioParam\n\t// all docs are generated from AbstractParam.ts\n\t//-------------------------------------\n\n\tsetValueAtTime(value: Type, time: Time): this {\n\t\tthis._param.setValueAtTime(value, time);\n\t\treturn this;\n\t}\n\tgetValueAtTime(time: Time): Type {\n\t\treturn this._param.getValueAtTime(time);\n\t}\n\tsetRampPoint(time: Time): this {\n\t\tthis._param.setRampPoint(time);\n\t\treturn this;\n\t}\n\tlinearRampToValueAtTime(value: Type, time: Time): this {\n\t\tthis._param.linearRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampToValueAtTime(value: Type, time: Time): this {\n\t\tthis._param.exponentialRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.exponentialRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\tlinearRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.linearRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\ttargetRampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.targetRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\texponentialApproachValueAtTime(value: Type, time: Time, rampTime: Time): this {\n\t\tthis._param.exponentialApproachValueAtTime(value, time, rampTime);\n\t\treturn this;\n\t}\n\tsetTargetAtTime(value: Type, startTime: Time, timeConstant: number): this {\n\t\tthis._param.setTargetAtTime(value, startTime, timeConstant);\n\t\treturn this;\n\t}\n\tsetValueCurveAtTime(values: Type[], startTime: Time, duration: Time, scaling?: number): this {\n\t\tthis._param.setValueCurveAtTime(values, startTime, duration, scaling);\n\t\treturn this;\n\t}\n\tcancelScheduledValues(time: Time): this {\n\t\tthis._param.cancelScheduledValues(time);\n\t\treturn this;\n\t}\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tthis._param.cancelAndHoldAtTime(time);\n\t\treturn this;\n\t}\n\trampTo(value: Type, rampTime: Time, startTime?: Time): this {\n\t\tthis._param.rampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\n\tget value(): Type {\n\t\treturn this._param.value;\n\t}\n\tset value(value: Type) {\n\t\tthis._param.value = value;\n\t}\n\n\tget convert(): boolean {\n\t\treturn this._param.convert;\n\t}\n\tset convert(convert: boolean) {\n\t\tthis._param.convert = convert;\n\t}\n\n\tget units(): UnitName {\n\t\treturn this._param.units;\n\t}\n\n\tget overridden(): boolean {\n\t\treturn this._param.overridden;\n\t}\n\tset overridden(overridden: boolean) {\n\t\tthis._param.overridden = overridden;\n\t}\n\n\tget maxValue(): number {\n\t\treturn this._param.maxValue;\n\t}\n\tget minValue(): number {\n\t\treturn this._param.minValue;\n\t}\n\n\t/**\n\t * See [[Param.apply]].\n\t */\n\tapply(param: Param | AudioParam): this {\n\t\tthis._param.apply(param);\n\t\treturn this;\n\t}\n}\n\n/**\n * When connecting from a signal, it's necessary to zero out the node destination\n * node if that node is also a signal. If the destination is not 0, then the values\n * will be summed. This method insures that the output of the destination signal will\n * be the same as the source signal, making the destination signal a pass through node.\n * @param signal The output signal to connect from\n * @param destination the destination to connect to\n * @param outputNum the optional output number\n * @param inputNum the input number\n */\nexport function connectSignal(signal: OutputNode, destination: InputNode, outputNum?: number, inputNum?: number): void {\n\tif (destination instanceof Param || isAudioParam(destination) ||\n\t\t(destination instanceof Signal && destination.override)) {\n\t\t// cancel changes\n\t\tdestination.cancelScheduledValues(0);\n\t\t// reset the value\n\t\tdestination.setValueAtTime(0, 0);\n\t\t// mark the value as overridden\n\t\tif (destination instanceof Signal) {\n\t\t\tdestination.overridden = true;\n\t\t}\n\t}\n\tconnect(signal, destination, outputNum, inputNum);\n}\n","import { AutomationEvent, Param, ParamOptions } from \"../context/Param\";\nimport { BPM, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n\ntype TickAutomationEvent = AutomationEvent & {\n\tticks: number;\n};\n\ninterface TickParamOptions<Type> extends ParamOptions<Type> {\n\tmultiplier: number;\n}\n\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\nexport class TickParam<Type extends Hertz | BPM> extends Param<Type> {\n\n\treadonly name: string = \"TickParam\";\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<TickAutomationEvent> = new Timeline(Infinity);\n\n\t/**\n\t * The internal holder for the multiplier value\n\t */\n\tprivate _multiplier: number = 1;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\t/**\n\t * @param value The initial value of the signal\n\t */\n\tconstructor(value?: number);\n\tconstructor(options: Partial<TickParamOptions<Type>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]);\n\n\t\t// set the multiplier\n\t\tthis._multiplier = options.multiplier;\n\n\t\t// clear the ticks from the beginning\n\t\tthis._events.cancel(0);\n\t\t// set an initial event\n\t\tthis._events.add({\n\t\t\tticks: 0,\n\t\t\ttime: 0,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: this._fromType(options.value),\n\t\t});\n\t\tthis.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): TickParamOptions<any> {\n\t\treturn Object.assign(Param.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tsetTargetAtTime(value: Type, time: Time, constant: number): this {\n\t\t// approximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tthis.setRampPoint(time);\n\t\tconst computedValue = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\tconst segments = Math.round(Math.max(1 / constant, 1));\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = constant * i + time;\n\t\t\tconst rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsetValueAtTime(value: Type, time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.setValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: Type, time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.linearRampToValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: Type, time: Time): this {\n\t\t// aproximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tconst computedVal = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\t// approx 10 segments per second\n\t\tconst segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n\t\tconst segmentDur = ((time - prevEvent.time) / segments);\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = segmentDur * i + prevEvent.time;\n\t\t\tconst rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tprivate _getTicksUntilEvent(event: TickAutomationEvent | null, time: number): Ticks {\n\t\tif (event === null) {\n\t\t\tevent = {\n\t\t\t\tticks: 0,\n\t\t\t\ttime: 0,\n\t\t\t\ttype: \"setValueAtTime\",\n\t\t\t\tvalue: 0,\n\t\t\t};\n\t\t} else if (isUndef(event.ticks)) {\n\t\t\tconst previousEvent = this._events.previousEvent(event);\n\t\t\tevent.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n\t\t}\n\t\tconst val0 = this._fromType(this.getValueAtTime(event.time));\n\t\tlet val1 = this._fromType(this.getValueAtTime(time));\n\t\t// if it's right on the line, take the previous value\n\t\tconst onTheLineEvent = this._events.get(time);\n\t\tif (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n\t\t\tval1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n\t\t}\n\t\treturn 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst event = this._events.get(computedTime);\n\t\treturn Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n\t}\n\n\t/**\n\t * Return the elapsed time of the number of ticks from the given time\n\t * @param ticks The number of ticks to calculate\n\t * @param  time The time to get the next tick from\n\t * @return The duration of the number of ticks from the given time in seconds\n\t */\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst currentTick = this.getTicksAtTime(time);\n\t\treturn this.getTimeOfTick(currentTick + ticks) - computedTime;\n\t}\n\n\t/**\n\t * Given a tick, returns the time that tick occurs at.\n\t * @return The time that the tick occurs.\n\t */\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\tconst before = this._events.get(tick, \"ticks\");\n\t\tconst after = this._events.getAfter(tick, \"ticks\");\n\t\tif (before && before.ticks === tick) {\n\t\t\treturn before.time;\n\t\t} else if (before && after &&\n\t\t\tafter.type === \"linearRampToValueAtTime\" &&\n\t\t\tbefore.value !== after.value) {\n\t\t\tconst val0 = this._fromType(this.getValueAtTime(before.time));\n\t\t\tconst val1 = this._fromType(this.getValueAtTime(after.time));\n\t\t\tconst delta = (val1 - val0) / (after.time - before.time);\n\t\t\tconst k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n\t\t\tconst sol1 = (-val0 + k) / delta;\n\t\t\tconst sol2 = (-val0 - k) / delta;\n\t\t\treturn (sol1 > 0 ? sol1 : sol2) + before.time;\n\t\t} else if (before) {\n\t\t\tif (before.value === 0) {\n\t\t\t\treturn Infinity;\n\t\t\t} else {\n\t\t\t\treturn before.time + (tick - before.ticks) / before.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn tick / this._initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Convert some number of ticks their the duration in seconds accounting\n\t * for any automation curves starting at the given time.\n\t * @param  ticks The number of ticks to convert to seconds.\n\t * @param  when  When along the automation timeline to convert the ticks.\n\t * @return The duration in seconds of the ticks.\n\t */\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this.getDurationOfTicks(ticks, when);\n\t}\n\n\t/**\n\t * The inverse of [[ticksToTime]]. Convert a duration in\n\t * seconds to the corresponding number of ticks accounting for any\n\t * automation curves starting at the given time.\n\t * @param  duration The time interval to convert to ticks.\n\t * @param  when When along the automation timeline to convert the ticks.\n\t * @return The duration in ticks.\n\t */\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tconst startTicks = this.getTicksAtTime(computedTime);\n\t\tconst endTicks = this.getTicksAtTime(computedTime + computedDuration);\n\t\treturn endTicks - startTicks;\n\t}\n\n\t/**\n\t * Convert from the type when the unit value is BPM\n\t */\n\tprotected _fromType(val: Type): number {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn 1 / (60 / val / this.multiplier);\n\t\t} else {\n\t\t\treturn super._fromType(val);\n\t\t}\n\t}\n\n\t/**\n\t * Special case of type conversion where the units === \"bpm\"\n\t */\n\tprotected _toType(val: number): Type {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn (val / this.multiplier) * 60 as Type;\n\t\t} else {\n\t\t\treturn super._toType(val);\n\t\t}\n\t}\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\t// get and reset the current value with the new multiplier\n\t\t// might be necessary to clear all the previous values\n\t\tconst currentVal = this.value;\n\t\tthis._multiplier = m;\n\t\tthis.value = currentVal;\n\t}\n}\n","import { Signal, SignalOptions } from \"../../signal/Signal\";\nimport { InputNode } from \"../context/ToneAudioNode\";\nimport { BPM, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { TickParam } from \"./TickParam\";\n\ninterface TickSignalOptions<T> extends SignalOptions<T> {\n\tvalue: T;\n\tmultiplier: number;\n}\n\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n */\nexport class TickSignal<Type extends Hertz | BPM> extends Signal<Type> {\n\n\treadonly name: string = \"TickSignal\";\n\n\t/**\n\t * The param which controls the output signal value\n\t */\n\tprotected _param: TickParam<Type>;\n\treadonly input: InputNode;\n\n\t/**\n\t * @param value The initial value of the signal\n\t */\n\tconstructor(value?: Type);\n\tconstructor(options: Partial<TickSignalOptions<Type>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis.input = this._param = new TickParam({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tmultiplier: options.multiplier,\n\t\t\tparam: this._constantSource.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.value,\n\t\t});\n\t}\n\n\tstatic getDefaults(): TickSignalOptions<any> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this._param.ticksToTime(ticks, when);\n\t}\n\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\treturn this._param.timeToTicks(duration, when);\n\t}\n\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\treturn this._param.getTimeOfTick(tick);\n\t}\n\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\treturn this._param.getDurationOfTicks(ticks, time);\n\t}\n\n\tgetTicksAtTime(time: Time): Ticks {\n\t\treturn this._param.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._param.multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\tthis._param.multiplier = m;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._param.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { BPM, Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: Frequency;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ninterface TickSourceOffsetEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource<Type extends BPM | Hertz> extends ToneWithContext<TickSourceOptions> {\n\n\treadonly name: string = \"TickSource\";\n\n\t/**\n\t * The frequency the callback function should be invoked.\n\t */\n\treadonly frequency: TickSignal<Type>;\n\n\t/**\n\t * The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\t/**\n\t * @param frequency The initial frequency that the signal ticks at\n\t */\n\tconstructor(frequency?: Frequency);\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new TickSignal<Type>({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.frequency as Type,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the inital state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign({\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\" as \"hertz\",\n\t\t}, ToneWithContext.getDefaults());\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t * @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", computedTime);\n\t\tif (!stopEvent) {\n\t\t\treturn 0;\n\t\t}\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time: computedTime };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedTicks = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t * The time since ticks=0 that the TickSource has been running. Accounts\n\t * for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", time);\n\t\tif (!stopEvent) {\n\t\t\treturn 0;\n\t\t}\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedSeconds = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds: this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @example\n\t * source.start(\"+0.1\");\n\t * source.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  ticks The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t * Invoke the callback event at all scheduled ticks between the\n\t * start time and the end time\n\t * @param  startTime  The beginning of the search range\n\t * @param  endTime    The end of the search range\n\t * @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(startTime: Time, endTime: Time, callback: (when: Seconds, ticks: Ticks) => void): this {\n\t\tconst computedStartTime = this.toSeconds(startTime);\n\t\tconst computedEndTime = this.toSeconds(endTime);\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(computedStartTime);\n\t\tthis._state.forEachBetween(computedStartTime, computedEndTime, event => {\n\t\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n\t\t\t\tthis.forEachTickBetween(Math.max(lastStateEvent.time, computedStartTime), event.time - this.sampleTime, callback);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && this._state) {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, computedStartTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = diff % 1;\n\t\t\tif (offset !== 0) {\n\t\t\t\toffset = 1 - offset;\n\t\t\t}\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\t\t\twhile (nextTickTime < computedEndTime && this._state) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (this._state) {\n\t\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { BPM, Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline } from \"../util/StateTimeline\";\nimport { TickSignal } from \"./TickSignal\";\nimport { TickSource } from \"./TickSource\";\n\ntype ClockCallback = (time: Time, ticks?: Ticks) => void;\n\ninterface ClockOptions extends ToneWithContextOptions {\n\tfrequency: Hertz;\n\tcallback: ClockCallback;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ntype ClockEvent = \"start\" | \"stop\" | \"pause\";\n\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * //the callback will be invoked approximately once a second\n * //and will print the time exactly once a second apart.\n * const clock = new Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * @category Core\n */\nexport class Clock<Type extends BPM | Hertz = Hertz>\n\textends ToneWithContext<ClockOptions> implements Emitter<ClockEvent> {\n\n\treadonly name: string = \"Clock\";\n\n\t/**\n\t * The callback function to invoke at the scheduled tick.\n\t */\n\tcallback: ClockCallback = noOp;\n\n\t/**\n\t * The tick counter\n\t */\n\tprivate _tickSource: TickSource<Type>;\n\n\t/**\n\t * The last time the loop callback was invoked\n\t */\n\tprivate _lastUpdate: number = 0;\n\n\t/**\n\t * Keep track of the playback state\n\t */\n\tprivate _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t * Context bound reference to the _loop method\n\t * This is necessary to remove the event in the end.\n\t */\n\tprivate _boundLoop: () => void = this._loop.bind(this);\n\n\t/**\n\t * The rate the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<Type>;\n\n\t/**\n\t * @param callback The callback to be invoked with the time of the audio event\n\t * @param frequency The rate of the callback\n\t */\n\tconstructor(callback?: ClockCallback, frequency?: Frequency);\n\tconstructor(options: Partial<ClockOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n\t\tconst options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._tickSource = new TickSource({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._lastUpdate = 0;\n\t\tthis.frequency = this._tickSource.frequency;\n\t\treadOnly(this, \"frequency\");\n\n\t\t// add an initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\n\t\t// bind a callback to the worker thread\n\t\tthis.context.on(\"tick\", this._boundLoop);\n\t}\n\n\tstatic getDefaults(): ClockOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp as ClockCallback,\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}) as ClockOptions;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset  Where the tick counter starts counting from.\n\t */\n\tstart(time?: Time, offset?: Ticks): this {\n\t\t// make sure the context is started\n\t\t// this.context.resume();\n\t\t// start the loop\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis._tickSource.start(computedTime, offset);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"start\", computedTime, offset);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t * @example\n\t * clock.stop();\n\t */\n\tstop(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"stop\", computedTime);\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis._tickSource.stop(computedTime);\n\t\tif (computedTime < this._lastUpdate) {\n\t\t\tthis.emit(\"stop\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._tickSource.pause(computedTime);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"pause\", computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked.\n\t */\n\tget ticks(): Ticks {\n\t\treturn Math.ceil(this.getTicksAtTime(this.now()));\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis._tickSource.ticks = t;\n\t}\n\n\t/**\n\t * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._tickSource.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tthis._tickSource.seconds = s;\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._tickSource.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\tthis._tickSource.setTicksAtTime(ticks, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn this._tickSource.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the next tick\n\t * @param  ticks The tick number.\n\t */\n\tnextTickTime(offset: Ticks, when: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst currentTick = this.getTicksAtTime(computedTime);\n\t\treturn this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n\t}\n\n\t/**\n\t * The scheduling loop.\n\t */\n\tprivate _loop(): void {\n\n\t\tconst startTime = this._lastUpdate;\n\t\tconst endTime = this.now();\n\t\tthis._lastUpdate = endTime;\n\t\tthis.log(\"loop\", startTime, endTime);\n\n\t\tif (startTime !== endTime) {\n\t\t\t// the state change events\n\t\t\tthis._state.forEachBetween(startTime, endTime, e => {\n\t\t\t\tswitch (e.state) {\n\t\t\t\t\tcase \"started\" :\n\t\t\t\t\t\tconst offset = this._tickSource.getTicksAtTime(e.time);\n\t\t\t\t\t\tthis.emit(\"start\", e.time, offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"stopped\" :\n\t\t\t\t\t\tif (e.time !== 0) {\n\t\t\t\t\t\t\tthis.emit(\"stop\", e.time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"paused\" :\n\t\t\t\t\t\tthis.emit(\"pause\", e.time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// the tick callbacks\n\t\t\tthis._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n\t\t\t\tthis.callback(time, ticks);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t * @example\n\t * clock.start(\"+0.1\");\n\t * clock.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(computedTime);\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.off(\"tick\", this._boundLoop);\n\t\tthis._tickSource.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\tonce!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\toff!: (event: ClockEvent, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Clock);\n","import { getContext } from \"../Global\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\nimport { TransportTimeClass } from \"./TransportTime\";\nimport { Seconds, Ticks } from \"./Units\";\n\n/**\n * Ticks is a primitive type for encoding Time values.\n * Ticks can be constructed with or without the `new` keyword. Ticks can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * const t = Ticks(\"4n\"); //a quarter note as ticks\n * @category Unit\n */\nexport class TicksClass extends TransportTimeClass<Ticks> {\n\n\treadonly name: string = \"Ticks\";\n\n\treadonly defaultUnits: TimeBaseUnit = \"i\";\n\n\t/**\n\t * Get the current time in the given units\n\t */\n\tprotected _now(): Ticks {\n\t\treturn this.context.transport.ticks;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Ticks {\n\t\treturn this._getPPQ() * beats;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Ticks {\n\t\treturn Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Ticks {\n\t\treturn ticks;\n\t}\n\n\t/**\n\t * Return the time in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\treturn this.valueOf() as Ticks;\n\t}\n\n\t/**\n\t * Return the time in seconds\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn (this.valueOf() / this._getPPQ()) * (60 / this._getBpm());\n\t}\n}\n\n/**\n * Convert a time representation to ticks\n * @category Unit\n */\nexport function Ticks(value?: TimeValue, units?: TimeBaseUnit): TicksClass {\n\treturn new TicksClass(getContext(), value, units);\n}\n","import { getContext } from \"../Global\";\nimport { ftom, mtof } from \"./Conversions\";\nimport { FrequencyClass, FrequencyUnit } from \"./Frequency\";\nimport { TimeValue } from \"./TimeBase\";\nimport { Hertz, Interval, MidiNote, Seconds, Ticks } from \"./Units\";\n\n/**\n * Midi is a primitive type for encoding Time values.\n * Midi can be constructed with or without the `new` keyword. Midi can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * var t = Midi(\"4n\");//a quarter note\n * @category Unit\n */\nexport class MidiClass extends FrequencyClass<MidiNote> {\n\n\treadonly name: string = \"Midi\";\n\n\treadonly defaultUnits = \"midi\";\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): MidiNote {\n\t\treturn ftom(super._frequencyToUnits(freq));\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): MidiNote {\n\t\treturn ftom(super._ticksToUnits(ticks));\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): MidiNote {\n\t\treturn ftom(super._beatsToUnits(beats));\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): MidiNote {\n\t\treturn ftom(super._secondsToUnits(seconds));\n\t}\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @return  {MIDI}\n\t * @example\n\t * Midi(60).toMidi(); //60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @return  {MIDI}\n\t * @example\n\t * Midi(60).toFrequency(); //261.6255653005986\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn mtof(this.toMidi());\n\t}\n\n\t/**\n\t * Transposes the frequency by the given number of semitones.\n\t * @return A new transposed MidiClass\n\t * @example\n\t * Midi(\"A4\").transpose(3); //\"C5\"\n\t */\n\ttranspose(interval: Interval): MidiClass {\n\t\treturn new MidiClass(this.context, this.toMidi() + interval);\n\t}\n}\n\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n */\nexport function Midi(value?: TimeValue, units?: FrequencyUnit): MidiClass {\n\treturn new MidiClass(getContext(), value, units);\n}\n","import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Seconds, Time } from \"../type/Units\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\n\ninterface DrawEvent extends TimelineEvent {\n\tcallback: () => void;\n}\n\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule(function(time){\n * \t//use the time argument to schedule a callback with Draw\n * \tDraw.schedule(function(){\n * \t\t//do drawing or DOM manipulation here\n * \t}, time)\n * }, \"+0.5\")\n * @category Core\n */\nexport class Draw extends ToneWithContext<ToneWithContextOptions> {\n\n\treadonly name: string = \"Draw\";\n\n\t/**\n\t * The duration after which events are not invoked.\n\t */\n\texpiration: Seconds = 0.25;\n\n\t/**\n\t * The amount of time before the scheduled time\n\t * that the callback can be invoked. Default is\n\t * half the time of an animation frame (0.008 seconds).\n\t */\n\tanticipation: Seconds = 0.008;\n\n\t/**\n\t * All of the events.\n\t */\n\tprivate _events: Timeline<DrawEvent> = new Timeline();\n\n\t/**\n\t * The draw loop\n\t */\n\tprivate _boundDrawLoop = this._drawLoop.bind(this);\n\n\t/**\n\t * The animation frame id\n\t */\n\tprivate _animationFrame: number = -1;\n\n\t/**\n\t * Schedule a function at the given time to be invoked\n\t * on the nearest animation frame.\n\t * @param  callback  Callback is invoked at the given time.\n\t * @param  time      The time relative to the AudioContext time to invoke the callback.\n\t */\n\tschedule(callback: () => void, time: Time): this {\n\t\tthis._events.add({\n\t\t\tcallback,\n\t\t\ttime: this.toSeconds(time),\n\t\t});\n\t\t// start the draw loop on the first event\n\t\tif (this._events.length === 1) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel events scheduled after the given time\n\t * @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._events.cancel(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * The draw loop\n\t */\n\tprivate _drawLoop(): void {\n\t\tconst now = this.context.currentTime;\n\t\twhile (this._events.length && (this._events.peek() as DrawEvent).time - this.anticipation <= now) {\n\t\t\tconst event = this._events.shift();\n\t\t\tif (event && now - event.time <= this.expiration) {\n\t\t\t\tevent.callback();\n\t\t\t}\n\t\t}\n\t\tif (this._events.length > 0) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\tcancelAnimationFrame(this._animationFrame);\n\t\treturn this;\n\t}\n}\n","import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\n\n/**\n * An IntervalTimeline event must have a time and duration\n */\nexport interface IntervalTimelineEvent {\n\ttime: number;\n\tduration: number;\n\t[propName: string]: any;\n}\n\ntype IteratorCallback = (event: IntervalTimelineEvent) => void;\n\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport class IntervalTimeline extends Tone {\n\n\treadonly name: string = \"IntervalTimeline\";\n\n\t/**\n\t * The root node of the inteval tree\n\t */\n\tprivate _root: IntervalNode | null = null;\n\n\t/**\n\t * Keep track of the length of the timeline.\n\t */\n\tprivate _length: number = 0;\n\n\t/**\n\t * The event to add to the timeline. All events must\n\t * have a time and duration value\n\t * @param  event  The event to add to the timeline\n\t */\n\tadd(event: IntervalTimelineEvent): this {\n\t\tthis.assert(isDefined(event.time), \"Events must have a time property\");\n\t\tthis.assert(isDefined(event.duration), \"Events must have a duration parameter\");\n\n\t\tevent.time = event.time.valueOf();\n\t\tlet node: IntervalNode | null = new IntervalNode(event.time, event.time + event.duration, event);\n\t\tif (this._root === null) {\n\t\t\tthis._root = node;\n\t\t} else {\n\t\t\tthis._root.insert(node);\n\t\t}\n\t\tthis._length++;\n\t\t// Restructure tree to be balanced\n\t\twhile (node !== null) {\n\t\t\tnode.updateHeight();\n\t\t\tnode.updateMax();\n\t\t\tthis._rebalance(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event from the timeline.\n\t * @param  event  The event to remove from the timeline\n\t */\n\tremove(event: IntervalTimelineEvent): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(event.time, results);\n\t\t\tfor (const node of results) {\n\t\t\t\tif (node.event === event) {\n\t\t\t\t\tthis._removeNode(node);\n\t\t\t\t\tthis._length--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of items in the timeline.\n\t * @readOnly\n\t */\n\tget length(): number {\n\t\treturn this._length;\n\t}\n\n\t/**\n\t * Remove events whose time time is after the given time\n\t * @param  time  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tthis.forEachFrom(after, event => this.remove(event));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the root node as the given node\n\t */\n\tprivate _setRoot(node: IntervalNode | null): void {\n\t\tthis._root = node;\n\t\tif (this._root !== null) {\n\t\t\tthis._root.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t * Replace the references to the node in the node's parent\n\t * with the replacement node.\n\t */\n\tprivate _replaceNodeInParent(node: IntervalNode, replacement: IntervalNode | null): void {\n\t\tif (node.parent !== null) {\n\t\t\tif (node.isLeftChild()) {\n\t\t\t\tnode.parent.left = replacement;\n\t\t\t} else {\n\t\t\t\tnode.parent.right = replacement;\n\t\t\t}\n\t\t\tthis._rebalance(node.parent);\n\t\t} else {\n\t\t\tthis._setRoot(replacement);\n\t\t}\n\t}\n\n\t/**\n\t * Remove the node from the tree and replace it with\n\t * a successor which follows the schema.\n\t */\n\tprivate _removeNode(node: IntervalNode): void {\n\t\tif (node.left === null && node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, null);\n\t\t} else if (node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, node.left);\n\t\t} else if (node.left === null) {\n\t\t\tthis._replaceNodeInParent(node, node.right);\n\t\t} else {\n\t\t\tconst balance = node.getBalance();\n\t\t\tlet replacement: IntervalNode;\n\t\t\tlet temp: IntervalNode | null = null;\n\t\t\tif (balance > 0) {\n\t\t\t\tif (node.left.right === null) {\n\t\t\t\t\treplacement = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\ttemp = replacement;\n\t\t\t\t} else {\n\t\t\t\t\treplacement = node.left.right;\n\t\t\t\t\twhile (replacement.right !== null) {\n\t\t\t\t\t\treplacement = replacement.right;\n\t\t\t\t\t}\n\t\t\t\t\tif (replacement.parent) {\n\t\t\t\t\t\treplacement.parent.right = replacement.left;\n\t\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.right.left === null) {\n\t\t\t\treplacement = node.right;\n\t\t\t\treplacement.left = node.left;\n\t\t\t\ttemp = replacement;\n\t\t\t} else {\n\t\t\t\treplacement = node.right.left;\n\t\t\t\twhile (replacement.left !== null) {\n\t\t\t\t\treplacement = replacement.left;\n\t\t\t\t}\n\t\t\t\tif (replacement.parent) {\n\t\t\t\t\treplacement.parent.left = replacement.right;\n\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.parent !== null) {\n\t\t\t\tif (node.isLeftChild()) {\n\t\t\t\t\tnode.parent.left = replacement;\n\t\t\t\t} else {\n\t\t\t\t\tnode.parent.right = replacement;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setRoot(replacement);\n\t\t\t}\n\t\t\tif (temp) {\n\t\t\t\tthis._rebalance(temp);\n\t\t\t}\n\t\t}\n\t\tnode.dispose();\n\t}\n\n\t/**\n\t * Rotate the tree to the left\n\t */\n\tprivate _rotateLeft(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.right the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.right;\n\t\tif (pivotNode) {\n\t\t\tnode.right = pivotNode.left;\n\t\t\tpivotNode.left = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Rotate the tree to the right\n\t */\n\tprivate _rotateRight(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.left the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.left;\n\t\tif (pivotNode) {\n\t\t\tnode.left = pivotNode.right;\n\t\t\tpivotNode.right = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Balance the BST\n\t */\n\tprivate _rebalance(node: IntervalNode): void {\n\t\tconst balance = node.getBalance();\n\t\tif (balance > 1 && node.left) {\n\t\t\tif (node.left.getBalance() < 0) {\n\t\t\t\tthis._rotateLeft(node.left);\n\t\t\t} else {\n\t\t\t\tthis._rotateRight(node);\n\t\t\t}\n\t\t} else if (balance < -1 && node.right) {\n\t\t\tif (node.right.getBalance() > 0) {\n\t\t\t\tthis._rotateRight(node.right);\n\t\t\t} else {\n\t\t\t\tthis._rotateLeft(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get an event whose time and duration span the give time. Will\n\t * return the match whose \"time\" value is closest to the given time.\n\t * @return  The event which spans the desired time\n\t */\n\tget(time: number): IntervalTimelineEvent | null {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tif (results.length > 0) {\n\t\t\t\tlet max = results[0];\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tif (results[i].low > max.low) {\n\t\t\t\t\t\tmax = results[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max.event;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Iterate over everything in the timeline.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst allNodes: IntervalNode[] = [];\n\t\t\tthis._root.traverse(node => allNodes.push(node));\n\t\t\tallNodes.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the given time\n\t * overlaps with the time and duration time of the event.\n\t * @param  time The time to check if items are overlapping\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the time is greater\n\t * than or equal to the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.searchAfter(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._root !== null) {\n\t\t\tthis._root.traverse(node => node.dispose());\n\t\t}\n\t\tthis._root = null;\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\nclass IntervalNode {\n\n\t// the event container\n\tevent: IntervalTimelineEvent | null;\n\t// the low value\n\tlow: number;\n\t// the high value\n\thigh: number;\n\t// the high value for this and all child nodes\n\tmax: number;\n\t// the nodes to the left\n\tprivate _left: IntervalNode | null = null;\n\t// the nodes to the right\n\tprivate _right: IntervalNode | null = null;\n\t// the parent node\n\tparent: IntervalNode | null = null;\n\t// the number of child nodes\n\theight: number = 0;\n\n\tconstructor(low: number, high: number, event: IntervalTimelineEvent) {\n\t\tthis.event = event;\n\t\t// the low value\n\t\tthis.low = low;\n\t\t// the high value\n\t\tthis.high = high;\n\t\t// the high value for this and all child nodes\n\t\tthis.max = this.high;\n\t}\n\n\t/**\n\t * Insert a node into the correct spot in the tree\n\t */\n\tinsert(node: IntervalNode): void {\n\t\tif (node.low <= this.low) {\n\t\t\tif (this.left === null) {\n\t\t\t\tthis.left = node;\n\t\t\t} else {\n\t\t\t\tthis.left.insert(node);\n\t\t\t}\n\t\t} else if (this.right === null) {\n\t\t\tthis.right = node;\n\t\t} else {\n\t\t\tthis.right.insert(node);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which overlap\n\t * with the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearch(point: number, results: IntervalNode[]): void {\n\t\t// If p is to the right of the rightmost point of any interval\n\t\t// in this node and all children, there won't be any matches.\n\t\tif (point > this.max) {\n\t\t\treturn;\n\t\t}\n\t\t// Search left children\n\t\tif (this.left !== null) {\n\t\t\tthis.left.search(point, results);\n\t\t}\n\t\t// Check this node\n\t\tif (this.low <= point && this.high > point) {\n\t\t\tresults.push(this);\n\t\t}\n\t\t// If p is to the left of the time of this interval,\n\t\t// then it can't be in any child to the right.\n\t\tif (this.low > point) {\n\t\t\treturn;\n\t\t}\n\t\t// Search right children\n\t\tif (this.right !== null) {\n\t\t\tthis.right.search(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which are less\n\t * than the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearchAfter(point: number, results: IntervalNode[]): void {\n\t\t// Check this node\n\t\tif (this.low >= point) {\n\t\t\tresults.push(this);\n\t\t\tif (this.left !== null) {\n\t\t\t\tthis.left.searchAfter(point, results);\n\t\t\t}\n\t\t}\n\t\t// search the right side\n\t\tif (this.right !== null) {\n\t\t\tthis.right.searchAfter(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the callback on this element and both it's branches\n\t * @param  {Function}  callback\n\t */\n\ttraverse(callback: (self: IntervalNode) => void): void {\n\t\tcallback(this);\n\t\tif (this.left !== null) {\n\t\t\tthis.left.traverse(callback);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.right.traverse(callback);\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateHeight(): void {\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tthis.height = Math.max(this.left.height, this.right.height) + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tthis.height = this.right.height + 1;\n\t\t} else if (this.left !== null) {\n\t\t\tthis.height = this.left.height + 1;\n\t\t} else {\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateMax(): void {\n\t\tthis.max = this.high;\n\t\tif (this.left !== null) {\n\t\t\tthis.max = Math.max(this.max, this.left.max);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.max = Math.max(this.max, this.right.max);\n\t\t}\n\t}\n\n\t/**\n\t * The balance is how the leafs are distributed on the node\n\t * @return  Negative numbers are balanced to the right\n\t */\n\tgetBalance(): number {\n\t\tlet balance = 0;\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tbalance = this.left.height - this.right.height;\n\t\t} else if (this.left !== null) {\n\t\t\tbalance = this.left.height + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tbalance = -(this.right.height + 1);\n\t\t}\n\t\treturn balance;\n\t}\n\n\t/**\n\t * @returns true if this node is the left child of its parent\n\t */\n\tisLeftChild(): boolean {\n\t\treturn this.parent !== null && this.parent.left === this;\n\t}\n\n\t/**\n\t * get/set the left node\n\t */\n\tget left(): IntervalNode | null {\n\t\treturn this._left;\n\t}\n\n\tset left(node: IntervalNode | null) {\n\t\tthis._left = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * get/set the right node\n\t */\n\tget right(): IntervalNode | null {\n\t\treturn this._right;\n\t}\n\n\tset right(node: IntervalNode | null) {\n\t\tthis._right = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * null out references.\n\t */\n\tdispose(): void {\n\t\tthis.parent = null;\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis.event = null;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { InputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface VolumeOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n * Volume is a simple volume node, useful for creating a volume fader.\n *\n * @example\n * var vol = new Volume(-12);\n * instrument.chain(vol, Tone.Destination);\n * @category Component\n */\nexport class Volume extends ToneAudioNode<VolumeOptions> {\n\n\treadonly name: string = \"Volume\";\n\n\t/**\n\t * the output node\n\t */\n\toutput: Gain<Decibels>;\n\n\t/**\n\t * Input and output are the same\n\t */\n\tinput: Gain;\n\n\t/**\n\t * The unmuted volume\n\t */\n\tprivate _unmutedVolume: Decibels;\n\n\t/**\n\t * The volume control in decibels.\n\t */\n\tvolume: Param<Decibels>;\n\n\t/**\n\t * @param volume the initial volume in decibels\n\t */\n\tconstructor(volume?: Decibels);\n\tconstructor(options?: Partial<VolumeOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]);\n\n\t\tthis.input = this.output = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.volume,\n\t\t\tunits: \"decibels\",\n\t\t});\n\t\tthis.volume = this.output.gain;\n\t\treadOnly(this, \"volume\");\n\t\tthis._unmutedVolume = options.volume;\n\n\t\t// set the mute initially\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): VolumeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * volume.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.volume.value === -Infinity;\n\t}\n\tset mute(mute: boolean) {\n\t\tif (!this.mute && mute) {\n\t\t\tthis._unmutedVolume = this.volume.value;\n\t\t\t// maybe it should ramp here?\n\t\t\tthis.volume.value = -Infinity;\n\t\t} else if (this.mute && !mute) {\n\t\t\tthis.volume.value = this._unmutedVolume;\n\t\t}\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../../component/channel/Volume\";\nimport { connectSeries } from \"../Connect\";\nimport { Decibels } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\nimport { Gain } from \"./Gain\";\nimport { Param } from \"./Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface DestinationOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n * A single master output which is connected to the\n * AudioDestinationNode (aka your speakers).\n * It provides useful conveniences such as the ability\n * to set the volume and mute the entire application.\n * It also gives you the ability to apply master effects to your application.\n *\n * @example\n * //the audio will go from the oscillator to the speakers\n * oscillator.connect(Destination);\n * //a convenience for connecting to the master output is also provided:\n * oscillator.toDestination();\n * //the above two examples are equivalent.\n * @category Core\n */\nexport class Destination extends ToneAudioNode<DestinationOptions> {\n\n\treadonly name: string = \"Destination\";\n\n\tinput: Volume = new Volume({ context: this.context });\n\toutput: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The volume of the master output.\n\t */\n\tvolume: Param<Decibels> = this.input.volume;\n\n\tconstructor(options: Partial<DestinationOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Destination.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Destination.getDefaults(), arguments);\n\n\t\tconnectSeries(this.input, this.output, this.context.rawContext.destination);\n\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): DestinationOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * Destination.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.input.mute;\n\t}\n\n\tset mute(mute: boolean) {\n\t\tthis.input.mute = mute;\n\t}\n\n\t/**\n\t * Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n\t * chained in the master effects chain.\n\t * @param nodes All arguments will be connected in a row and the Master will be routed through it.\n\t * @return  {Destination}  this\n\t * @example\n\t * //some overall compression to keep the levels in check\n\t * var masterCompressor = new Tone.Compressor({\n\t * \t\"threshold\" : -6,\n\t * \t\"ratio\" : 3,\n\t * \t\"attack\" : 0.5,\n\t * \t\"release\" : 0.1\n\t * });\n\t * //give a little boost to the lows\n\t * var lowBump = new Tone.Filter(200, \"lowshelf\");\n\t * //route everything through the filter\n\t * //and compressor before going to the speakers\n\t * Destination.chain(lowBump, masterCompressor);\n\t */\n\tchain(...args: Array<AudioNode | ToneAudioNode>): this {\n\t\tthis.input.disconnect();\n\t\targs.unshift(this.input);\n\t\targs.push(this.output);\n\t\tconnectSeries(...args);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.destination = new Destination({ context });\n});\n\nonContextClose(context => {\n\tcontext.destination.dispose();\n});\n","import { Timeline, TimelineEvent } from \"./Timeline\";\nimport { Tone } from \"../Tone\";\nimport { Seconds } from \"../type/Units\";\nimport { isDefined } from \"./TypeCheck\";\n\ninterface TimelineValueEvent<T> extends TimelineEvent {\n\tvalue: T;\n}\n\n/**\n * Represents a single value which is gettable and settable in a timed way\n */\nexport class TimelineValue<Type> extends Tone {\n\n\treadonly name: string = \"TimelineValue\";\n\n\t/**\n\t * The timeline which stores the values\n\t */\n\tprivate _timeline: Timeline<TimelineValueEvent<Type>> = new Timeline({ memory: 10 })\n\n\t/**\n\t * Hold the value to return if there is no scheduled values\n\t */\n\tprivate _initialValue: Type;\n\n\t/**\n\t * @param initialValue The value to return if there is no scheduled values\n\t */\n\tconstructor(initialValue: Type) {\n\n\t\tsuper();\n\t\tthis._initialValue = initialValue;\n\t}\n\n\t/**\n\t * Set the value at the given time\n\t */\n\tset(value: Type, time: Seconds): this {\n\t\tthis._timeline.add({\n\t\t\tvalue, time\n\t\t});\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Get the value at the given time\n\t */\n\tget(time: Seconds): Type {\n\t\tconst event = this._timeline.get(time);\n\t\tif (event) {\n\t\t\treturn event.value;\n\t\t} else {\n\t\t\treturn this._initialValue;\n\t\t}\n\t}\n}\n","import { Seconds, Ticks } from \"../type/Units\";\nimport { noOp } from \"../util/Interface\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\nexport interface TransportEventOptions {\n\tcallback: (time: number) => void;\n\tonce: boolean;\n\ttime: Ticks;\n}\n\n/**\n * TransportEvent is an internal class used by [[Transport]]\n * to schedule events. Do no invoke this class directly, it is\n * handled from within Tone.Transport.\n */\nexport class TransportEvent {\n\n\t/**\n\t * Reference to the Transport that created it\n\t */\n\tprotected transport: Transport;\n\n\t/**\n\t * The unique id of the event\n\t */\n\tid: number = TransportEvent._eventId++;\n\n\t/**\n\t * The time the event starts\n\t */\n\ttime: Ticks;\n\n\t/**\n\t * The callback to invoke\n\t */\n\tprivate callback?: (time: Seconds) => void;\n\n\t/**\n\t * If the event should be removed after being invoked.\n\t */\n\tprivate _once: boolean;\n\n\t/**\n\t * @param Transport The transport object which the event belongs to\n\t */\n\tconstructor(transport: Transport, opts: Partial<TransportEventOptions>) {\n\n\t\tconst options: TransportEventOptions = Object.assign(TransportEvent.getDefaults(), opts);\n\n\t\tthis.transport = transport;\n\t\tthis.callback = options.callback;\n\t\tthis._once = options.once;\n\t\tthis.time = options.time;\n\t}\n\n\tstatic getDefaults(): TransportEventOptions {\n\t\treturn {\n\t\t\tcallback: noOp,\n\t\t\tonce: false,\n\t\t\ttime: 0,\n\t\t};\n\t}\n\n\t/**\n\t * Current ID counter\n\t */\n\tprivate static _eventId: number = 0;\n\n\t/**\n\t * Invoke the event callback.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\tif (this.callback) {\n\t\t\tthis.callback(time);\n\t\t\tif (this._once) {\n\t\t\t\tthis.transport.clear(this.id);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tthis.callback = undefined;\n\t\treturn this;\n\t}\n}\n","import { Context } from \"../context/Context\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { TransportEvent, TransportEventOptions } from \"./TransportEvent\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\ninterface TransportRepeatEventOptions extends TransportEventOptions {\n\tinterval: Ticks;\n\tduration: Ticks;\n}\n\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n\n\t/**\n\t * When the event should stop repeating\n\t */\n\tprivate duration: Ticks;\n\n\t/**\n\t * The interval of the repeated event\n\t */\n\tprivate _interval: Ticks;\n\n\t/**\n\t * The ID of the current timeline event\n\t */\n\tprivate _currentId: number = -1;\n\n\t/**\n\t * The ID of the next timeline event\n\t */\n\tprivate _nextId: number = -1;\n\n\t/**\n\t * The time of the next event\n\t */\n\tprivate _nextTick = this.time;\n\n\t/**\n\t * a reference to the bound start method\n\t */\n\tprivate _boundRestart = this._restart.bind(this);\n\n\t/**\n\t * The audio context belonging to this event\n\t */\n\tprotected context: Context;\n\n\t/**\n\t * @param Transport The transport object which the event belongs to\n\t */\n\tconstructor(transport: Transport, opts: Partial<TransportRepeatEventOptions>) {\n\n\t\tsuper(transport, opts);\n\n\t\tconst options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n\n\t\tthis.duration = new TicksClass(transport.context, options.duration).valueOf();\n\t\tthis._interval = new TicksClass(transport.context, options.interval).valueOf();\n\t\tthis._nextTick = options.time;\n\t\tthis.transport.on(\"start\", this._boundRestart);\n\t\tthis.transport.on(\"loopStart\", this._boundRestart);\n\t\tthis.context = this.transport.context;\n\t\tthis._restart();\n\t}\n\n\tstatic getDefaults(): TransportRepeatEventOptions {\n\t\treturn Object.assign({}, TransportEvent.getDefaults(), {\n\t\t\tduration: Infinity,\n\t\t\tinterval: 1,\n\t\t\tonce: false,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke the callback. Returns the tick time which\n\t * the next event should be scheduled at.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\t// create more events if necessary\n\t\tthis._createEvents(time);\n\t\t// call the super class\n\t\tsuper.invoke(time);\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _createEvents(time: Seconds): void {\n\t\t// schedule the next event\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n\t\t\tthis._nextTick += this._interval;\n\t\t\tthis._currentId = this._nextId;\n\t\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _restart(time?: Time): void {\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis._nextTick = this.time;\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks > this.time) {\n\t\t\tthis._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n\t\t}\n\t\tthis._currentId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\tthis._nextTick += this._interval;\n\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis.transport.off(\"start\", this._boundRestart);\n\t\tthis.transport.off(\"loopStart\", this._boundRestart);\n\t\treturn this;\n\t}\n}\n","import { TimeClass } from \"../../core/type/Time\";\nimport { PlaybackState } from \"../../core/util/StateTimeline\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { Signal } from \"../../signal/Signal\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { BarsBeatsSixteenths, BPM, NormalRange, Seconds,\n\tSubdivision, Ticks, Time, TimeSignature, TransportTime } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TickParam } from \"./TickParam\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n\ninterface TransportOptions extends ToneWithContextOptions {\n\tbpm: BPM;\n\tswing: NormalRange;\n\tswingSubdivision: Subdivision;\n\ttimeSignature: number;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tppq: number;\n}\n\ntype TransportEventNames = \"start\" | \"stop\" | \"pause\" | \"loop\" | \"loopEnd\" | \"loopStart\";\n\ninterface SyncedSignalEvent {\n\tsignal: Signal;\n\tinitial: number;\n\tratio: Gain;\n}\n\ntype TransportCallback = (time: Seconds) => void;\n\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * //repeated event every 8th note\n * Transport.scheduleRepeat(function(time){\n * //do something with the time\n * }, \"8n\");\n * @example\n * //schedule an event on the 16th measure\n * Transport.schedule(function(time){\n * //do something with the time\n * }, \"16:0:0\");\n * @category Core\n */\nexport class Transport extends ToneWithContext<TransportOptions> implements Emitter<TransportEventNames> {\n\n\treadonly name: string = \"Transport\";\n\n\t//-------------------------------------\n\t// \tLOOPING\n\t//-------------------------------------\n\n\t/**\n\t * If the transport loops or not.\n\t */\n\tprivate _loop: TimelineValue<boolean> = new TimelineValue(false);\n\n\t/**\n\t * The loop start position in ticks\n\t */\n\tprivate _loopStart: Ticks = 0;\n\n\t/**\n\t * The loop end position in ticks\n\t */\n\tprivate _loopEnd: Ticks = 0;\n\n\t//-------------------------------------\n\t// \tCLOCK/TEMPO\n\t//-------------------------------------\n\n\t/**\n\t * Pulses per quarter is the number of ticks per quarter note.\n\t */\n\tprivate _ppq: number;\n\n\t/**\n\t * watches the main oscillator for timing ticks\n\t * initially starts at 120bpm\n\t */\n\tprivate _clock: Clock<BPM>;\n\n\t/**\n\t * The Beats Per Minute of the Transport.\n\t * @example\n\t * Transport.bpm.value = 80;\n\t * //ramp the bpm to 120 over 10 seconds\n\t * Transport.bpm.rampTo(120, 10);\n\t */\n\tbpm: TickParam<BPM>;\n\n\t/**\n\t * The time signature, or more accurately the numerator\n\t * of the time signature over a denominator of 4.\n\t */\n\tprivate _timeSignature: number;\n\n\t//-------------------------------------\n\t// \tTIMELINE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * All the events in an object to keep track by ID\n\t */\n\tprivate _scheduledEvents = {};\n\n\t/**\n\t * The scheduled events.\n\t */\n\tprivate _timeline: Timeline<TransportEvent> = new Timeline();\n\n\t/**\n\t * Repeated events\n\t */\n\tprivate _repeatedEvents: IntervalTimeline = new IntervalTimeline();\n\n\t/**\n\t * All of the synced Signals\n\t */\n\tprivate _syncedSignals: SyncedSignalEvent[] = [];\n\n\t//-------------------------------------\n\t// \tSWING\n\t//-------------------------------------\n\n\t/**\n\t * The subdivision of the swing\n\t */\n\tprivate _swingTicks: Ticks;\n\n\t/**\n\t * The swing amount\n\t */\n\tprivate _swingAmount: NormalRange = 0;\n\n\tconstructor(options?: Partial<TransportOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Transport.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Transport.getDefaults(), arguments);\n\n\t\t// CLOCK/TEMPO\n\t\tthis._ppq = options.ppq;\n\t\tthis._clock = new Clock({\n\t\t\tcallback: this._processTick.bind(this),\n\t\t\tcontext: this.context,\n\t\t\tfrequency: 0,\n\t\t\tunits: \"bpm\",\n\t\t});\n\t\tthis._bindClockEvents();\n\t\tthis.bpm = this._clock.frequency as unknown as TickParam<BPM>;\n\t\tthis._clock.frequency.multiplier = options.ppq;\n\t\tthis.bpm.value = options.bpm;\n\t\treadOnly(this, \"bpm\");\n\t\tthis._timeSignature = options.timeSignature;\n\n\t\t// SWING\n\t\tthis._swingTicks = options.ppq / 2; // 8n\n\t}\n\n\tstatic getDefaults(): TransportOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tbpm: 120,\n\t\t\tloopEnd: \"4m\" as Subdivision,\n\t\t\tloopStart: 0,\n\t\t\tppq: 192,\n\t\t\tswing: 0,\n\t\t\tswingSubdivision: \"8n\" as Subdivision,\n\t\t\ttimeSignature: 4,\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tTICKS\n\t//-------------------------------------\n\n\t/**\n\t * called on every tick\n\t * @param  tickTime clock relative tick time\n\t */\n\tprivate _processTick(tickTime: Seconds, ticks: Ticks): void {\n\t\t// handle swing\n\t\tif (this._swingAmount > 0 &&\n\t\t\tticks % this._ppq !== 0 && // not on a downbeat\n\t\t\tticks % (this._swingTicks * 2) !== 0) {\n\t\t\t// add some swing\n\t\t\tconst progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n\t\t\tconst amount = Math.sin((progress) * Math.PI) * this._swingAmount;\n\t\t\ttickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n\t\t}\n\t\t// do the loop test\n\t\tif (this._loop.get(tickTime)) {\n\t\t\tif (ticks >= this._loopEnd) {\n\t\t\t\tthis.emit(\"loopEnd\", tickTime);\n\t\t\t\tthis._clock.setTicksAtTime(this._loopStart, tickTime);\n\t\t\t\tticks = this._loopStart;\n\t\t\t\tthis.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n\t\t\t\tthis.emit(\"loop\", tickTime);\n\t\t\t}\n\t\t}\n\t\t// invoke the timeline events scheduled on this tick\n\t\tthis._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n\t}\n\n\t//-------------------------------------\n\t// \tSCHEDULABLE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * Schedule an event along the timeline.\n\t * @param callback The callback to be invoked at the time.\n\t * @param time The time to invoke the callback at.\n\t * @return The id of the event which can be used for canceling the event.\n\t * @example\n\t * //trigger the callback when the Transport reaches the desired time\n\t * Transport.schedule(function(time){\n\t * envelope.triggerAttack(time);\n\t * }, \"128i\");\n\t */\n\tschedule(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Schedule a repeated event along the timeline. The event will fire\n\t * at the `interval` starting at the `startTime` and for the specified\n\t * `duration`.\n\t * @param  callback   The callback to invoke.\n\t * @param  interval   The duration between successive callbacks. Must be a positive number.\n\t * @param  startTime  When along the timeline the events should start being invoked.\n\t * @param  duration How long the event should repeat.\n\t * @return  The ID of the scheduled event. Use this to cancel the event.\n\t * @example\n\t * //a callback invoked every eighth note after the first measure\n\t * Transport.scheduleRepeat(callback, \"8n\", \"1m\");\n\t */\n\tscheduleRepeat(\n\t\tcallback: TransportCallback,\n\t\tinterval: Time | TimeClass,\n\t\tstartTime?: TransportTime | TransportTimeClass,\n\t\tduration: Time = Infinity,\n\t): number {\n\t\tconst event = new TransportRepeatEvent(this, {\n\t\t\tcallback,\n\t\t\tduration: new TimeClass(this.context, duration).toTicks(),\n\t\t\tinterval: new TimeClass(this.context, interval).toTicks(),\n\t\t\ttime: new TransportTimeClass(this.context, startTime).toTicks(),\n\t\t});\n\t\t// kick it off if the Transport is started\n\t\t// @ts-ignore\n\t\treturn this._addEvent(event, this._repeatedEvents);\n\t}\n\n\t/**\n\t * Schedule an event that will be removed after it is invoked.\n\t * @param callback The callback to invoke once.\n\t * @param time The time the callback should be invoked.\n\t * @returns The ID of the scheduled event.\n\t */\n\tscheduleOnce(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\tonce: true,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Clear the passed in event id from the timeline\n\t * @param eventId The id of the event.\n\t */\n\tclear(eventId: number): this {\n\t\tif (this._scheduledEvents.hasOwnProperty(eventId)) {\n\t\t\tconst item = this._scheduledEvents[eventId.toString()];\n\t\t\titem.timeline.remove(item.event);\n\t\t\titem.event.dispose();\n\t\t\tdelete this._scheduledEvents[eventId.toString()];\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an event to the correct timeline. Keep track of the\n\t * timeline it was added to.\n\t * @returns the event id which was just added\n\t */\n\tprivate _addEvent(event: TransportEvent, timeline: Timeline<TransportEvent>): number {\n\t\tthis._scheduledEvents[event.id.toString()] = {\n\t\t\tevent,\n\t\t\ttimeline,\n\t\t};\n\t\ttimeline.add(event);\n\t\treturn event.id;\n\t}\n\n\t/**\n\t * Remove scheduled events from the timeline after\n\t * the given time. Repeated events will be removed\n\t * if their startTime is after the given time\n\t * @param after Clear all events after this time.\n\t */\n\tcancel(after: TransportTime = 0): this {\n\t\tconst computedAfter = this.toTicks(after);\n\t\tthis._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\tthis._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSTART/STOP/PAUSE\n\t//-------------------------------------\n\n\t/**\n\t * Bind start/stop/pause events from the clock and emit them.\n\t */\n\tprivate _bindClockEvents(): void {\n\t\tthis._clock.on(\"start\", (time, offset) => {\n\t\t\toffset = new TicksClass(this.context, offset).toSeconds();\n\t\t\tthis.emit(\"start\", time, offset);\n\t\t});\n\n\t\tthis._clock.on(\"stop\", (time) => {\n\t\t\tthis.emit(\"stop\", time);\n\t\t});\n\n\t\tthis._clock.on(\"pause\", (time) => {\n\t\t\tthis.emit(\"pause\", time);\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._clock.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the transport and all sources synced to the transport.\n\t * @param  time The time when the transport should start.\n\t * @param  offset The timeline offset to start the transport.\n\t * @example\n\t * //start the transport in one second starting at beginning of the 5th measure.\n\t * Transport.start(\"+1\", \"4:0:0\");\n\t */\n\tstart(time?: Time, offset?: TransportTime): this {\n\t\tlet offsetTicks;\n\t\tif (isDefined(offset)) {\n\t\t\toffsetTicks = this.toTicks(offset);\n\t\t}\n\t\t// start the clock\n\t\tthis._clock.start(time, offsetTicks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the transport and all sources synced to the transport.\n\t * @param time The time when the transport should stop.\n\t * @example\n\t * Transport.stop();\n\t */\n\tstop(time?: Time): this {\n\t\tthis._clock.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the transport and all sources synced to the transport.\n\t */\n\tpause(time?: Time): this {\n\t\tthis._clock.pause(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Toggle the current state of the transport. If it is\n\t * started, it will stop it, otherwise it will start the Transport.\n\t * @param  time The time of the event\n\t */\n\ttoggle(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._clock.getStateAtTime(time) !== \"started\") {\n\t\t\tthis.start(time);\n\t\t} else {\n\t\t\tthis.stop(time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSETTERS/GETTERS\n\t//-------------------------------------\n\n\t/**\n\t * The time signature as just the numerator over 4.\n\t * For example 4/4 would be just 4 and 6/8 would be 3.\n\t * @example\n\t * //common time\n\t * Transport.timeSignature = 4;\n\t * // 7/8\n\t * Transport.timeSignature = [7, 8];\n\t * //this will be reduced to a single number\n\t * Transport.timeSignature; //returns 3.5\n\t */\n\tget timeSignature(): TimeSignature {\n\t\treturn this._timeSignature;\n\t}\n\tset timeSignature(timeSig: TimeSignature) {\n\t\tif (isArray(timeSig)) {\n\t\t\ttimeSig = (timeSig[0] / timeSig[1]) * 4;\n\t\t}\n\t\tthis._timeSignature = timeSig;\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the starting position of the loop.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n\t}\n\tset loopStart(startPosition: Time) {\n\t\tthis._loopStart = this.toTicks(startPosition);\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the ending position of the loop.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n\t}\n\tset loopEnd(endPosition: Time) {\n\t\tthis._loopEnd = this.toTicks(endPosition);\n\t}\n\t\n\t/**\n\t * If the transport loops or not.\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop.get(this.now());\n\t}\n\tset loop(loop) {\n\t\tthis._loop.set(loop, this.now());\n\t}\n\n\t/**\n\t * Set the loop start and stop at the same time.\n\t * @example\n\t * //loop over the first measure\n\t * Transport.setLoopPoints(0, \"1m\");\n\t * Transport.loop = true;\n\t */\n\tsetLoopPoints(startPosition: TransportTime, endPosition: TransportTime): this {\n\t\tthis.loopStart = startPosition;\n\t\tthis.loopEnd = endPosition;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n\t */\n\tget swing(): NormalRange {\n\t\treturn this._swingAmount;\n\t}\n\tset swing(amount: NormalRange) {\n\t\t// scale the values to a normal range\n\t\tthis._swingAmount = amount;\n\t}\n\n\t/**\n\t * Set the subdivision which the swing will be applied to.\n\t * The default value is an 8th note. Value must be less\n\t * than a quarter note.\n\t */\n\tget swingSubdivision(): Subdivision {\n\t\treturn new TicksClass(this.context, this._swingTicks).toNotation();\n\t}\n\tset swingSubdivision(subdivision: Subdivision) {\n\t\tthis._swingTicks = this.toTicks(subdivision);\n\t}\n\n\t/**\n\t * The Transport's position in Bars:Beats:Sixteenths.\n\t * Setting the value will jump to that position right away.\n\t */\n\tget position(): BarsBeatsSixteenths | Time {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\treturn new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n\t}\n\tset position(progress: Time) {\n\t\tconst ticks = this.toTicks(progress);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's position in seconds\n\t * Setting the value will jump to that position right away.\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._clock.seconds;\n\t}\n\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.frequency.timeToTicks(s, now);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's loop position as a normalized value. Always\n\t * returns 0 if the transport if loop is not true.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this.loop) {\n\t\t\tconst now = this.now();\n\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\treturn (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The transports current tick position.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this._clock.ticks;\n\t}\n\tset ticks(t: Ticks) {\n\t\tif (this._clock.ticks !== t) {\n\t\t\tconst now = this.now();\n\t\t\t// stop everything synced to the transport\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis.emit(\"stop\", now);\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t\t// restart it with the new time\n\t\t\t\tthis.emit(\"start\", now, this.seconds);\n\t\t\t} else {\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn Math.round(this._clock.getTicksAtTime(time));\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._clock.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Pulses Per Quarter note. This is the smallest resolution\n\t * the Transport timing supports. This should be set once\n\t * on initialization and not set again. Changing this value\n\t * after other objects have been created can cause problems.\n\t */\n\tget PPQ(): number {\n\t\treturn this._clock.frequency.multiplier;\n\t}\n\tset PPQ(ppq: number) {\n\t\tthis._clock.frequency.multiplier = ppq;\n\t}\n\n\t//-------------------------------------\n\t// \tSYNCING\n\t//-------------------------------------\n\n\t/**\n\t * Returns the time aligned to the next subdivision\n\t * of the Transport. If the Transport is not started,\n\t * it will return 0.\n\t * Note: this will not work precisely during tempo ramps.\n\t * @param  subdivision  The subdivision to quantize to\n\t * @return  The context time of the next subdivision.\n\t * @example\n\t * Transport.start(); //the transport must be started\n\t * Transport.nextSubdivision(\"4n\");\n\t */\n\tnextSubdivision(subdivision?: Time): Seconds {\n\t\tsubdivision = this.toTicks(subdivision);\n\t\tif (this.state !== \"started\") {\n\t\t\t// if the transport's not started, return 0\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tconst now = this.now();\n\t\t\t// the remainder of the current ticks and the subdivision\n\t\t\tconst transportPos = this.getTicksAtTime(now);\n\t\t\tconst remainingTicks = subdivision - transportPos % subdivision;\n\t\t\treturn this._clock.nextTickTime(remainingTicks, now);\n\t\t}\n\t}\n\n\t/**\n\t * Attaches the signal to the tempo control signal so that\n\t * any changes in the tempo will change the signal in the same\n\t * ratio.\n\t *\n\t * @param signal\n\t * @param ratio Optionally pass in the ratio between the two signals.\n\t * \t\t\tOtherwise it will be computed based on their current values.\n\t */\n\tsyncSignal(signal: Signal<any>, ratio?: number): this {\n\t\tif (!ratio) {\n\t\t\t// get the sync ratio\n\t\t\tconst now = this.now();\n\t\t\tif (signal.getValueAtTime(now) !== 0) {\n\t\t\t\tconst bpm = this.bpm.getValueAtTime(now);\n\t\t\t\tconst computedFreq = 1 / (60 / bpm / this.PPQ);\n\t\t\t\tratio = signal.getValueAtTime(now) / computedFreq;\n\t\t\t} else {\n\t\t\t\tratio = 0;\n\t\t\t}\n\t\t}\n\t\tconst ratioSignal = new Gain(ratio);\n\t\t// @ts-ignore\n\t\tthis.bpm.connect(ratioSignal);\n\t\t// @ts-ignore\n\t\tratioSignal.connect(signal._param);\n\t\tthis._syncedSignals.push({\n\t\t\tinitial: signal.value,\n\t\t\tratio: ratioSignal,\n\t\t\tsignal,\n\t\t});\n\t\tsignal.value = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsyncs a previously synced signal from the transport's control.\n\t * See Transport.syncSignal.\n\t */\n\tunsyncSignal(signal: Signal<any>): this {\n\t\tfor (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n\t\t\tconst syncedSignal = this._syncedSignals[i];\n\t\t\tif (syncedSignal.signal === signal) {\n\t\t\t\tsyncedSignal.ratio.dispose();\n\t\t\t\tsyncedSignal.signal.value = syncedSignal.initial;\n\t\t\t\tthis._syncedSignals.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._clock.dispose();\n\t\twritable(this, \"bpm\");\n\t\tthis._timeline.dispose();\n\t\tthis._repeatedEvents.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\tonce!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\toff!: (event: TransportEventNames, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Transport);\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.transport = new Transport({ context });\n});\n\nonContextClose(context => {\n\tcontext.transport.dispose();\n});\n","import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels, Seconds, Time } from \"../core/type/Units\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline } from \"../core/util/StateTimeline\";\nimport { isUndef } from \"../core/util/TypeCheck\";\n\ntype onStopCallback = (source: Source<any>) => void;\n\nexport interface SourceOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n\tonstop: onStopCallback;\n}\n\n/**\n * Base class for sources. Sources have start/stop methods\n * and the ability to be synced to the\n * start/stop of this.context.transport.\n *\n * @example\n * //Multiple state change events can be chained together,\n * //but must be set in the correct order and with ascending times\n *\n * // OK\n * state.start().stop(\"+0.2\");\n * // AND\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n *\n * // BAD\n * state.stop(\"+0.2\").start();\n * // OR\n * state.start(\"+0.3\").stop(\"+0.2\");\n *\n */\nexport abstract class Source<Options extends SourceOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The output note\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * Sources have no inputs\n\t */\n\tinput = undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * source.volume.value = -6;\n\t */\n\tvolume: Param<Decibels>;\n\n\t/**\n\t * The callback to invoke when the source is stopped.\n\t */\n\tonstop: onStopCallback;\n\n\t/**\n\t * Keep track of the scheduled state.\n\t */\n\tprotected _state: StateTimeline<{\n\t\tduration?: Seconds;\n\t\toffset?: Seconds;\n\t\t/**\n\t\t * Either the buffer is explicitly scheduled to end using the stop method,\n\t\t * or it's implicitly ended when the buffer is over.\n\t\t */\n\t\timplicitEnd?: boolean;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The synced `start` callback function from the transport\n\t */\n\tprotected _synced: boolean = false;\n\n\t/**\n\t * Keep track of all of the scheduled event ids\n\t */\n\tprivate _scheduled: number[] = [];\n\n\t/**\n\t * Placeholder functions for syncing/unsyncing to transport\n\t */\n\tprivate _syncedStart: (time: Seconds, offset: Seconds) => void = noOp;\n\tprivate _syncedStop: (time: Seconds) => void = noOp;\n\n\tconstructor(options: SourceOptions) {\n\t\tsuper(options);\n\t\tthis._state.memory = 100;\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tmute: options.mute,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.onstop = options.onstop;\n\t}\n\n\tstatic getDefaults(): SourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tonstop: noOp,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\tif (this._synced) {\n\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\treturn this._state.getValueAtTime(this.context.transport.seconds) as BasicPlaybackState;\n\t\t\t} else {\n\t\t\t\treturn \"stopped\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._state.getValueAtTime(this.now()) as BasicPlaybackState;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * source.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t// overwrite these functions\n\tprotected abstract _start(time: Time, offset?: Time, duration?: Time): void;\n\tprotected abstract _stop(time: Time): void;\n\tabstract restart(time: Time, offset?: Time, duration?: Time): this;\n\n\t/**\n\t * Ensure that the scheduled time is not before the current time.\n\t * Should only be used when scheduled unsynced.\n\t */\n\tprivate _clampToCurrentTime(time: Seconds): Seconds {\n\t\tif (this._synced) {\n\t\t\treturn time;\n\t\t} else {\n\t\t\treturn Math.max(time, this.context.currentTime);\n\t\t}\n\t}\n\n\t/**\n\t * Start the source at the specified time. If no time is given,\n\t * start the source now.\n\t * @param  time When the source should be started.\n\t * @example\n\t * source.start(\"+0.5\"); //starts the source 0.5 seconds from now\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\t// if it's started, stop it and restart it\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis.log(\"restart\", computedTime);\n\t\t\tthis.restart(computedTime, offset, duration);\n\t\t} else {\n\t\t\tthis.log(\"start\", computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (this._synced) {\n\t\t\t\t// add the offset time to the event\n\t\t\t\tconst event = this._state.get(computedTime);\n\t\t\t\tif (event) {\n\t\t\t\t\tevent.offset = this.toSeconds(defaultArg(offset, 0));\n\t\t\t\t\tevent.duration = duration ? this.toSeconds(duration) : undefined;\n\t\t\t\t}\n\t\t\t\tconst sched = this.context.transport.schedule(t => {\n\t\t\t\t\tthis._start(t, offset, duration);\n\t\t\t\t}, computedTime);\n\t\t\t\tthis._scheduled.push(sched);\n\n\t\t\t\t// if it's already started\n\t\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\t\tthis._syncedStart(this.now(), this.context.transport.seconds);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._start(computedTime, offset, duration);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the specified time. If no time is given,\n\t * stop the source now.\n\t * @param  time When the source should be stopped.\n\t * @example\n\t * source.stop(); // stops the source immediately\n\t */\n\tstop(time?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\tthis.log(\"stop\", computedTime);\n\t\tif (!this._synced) {\n\t\t\tthis._stop(computedTime);\n\t\t} else {\n\t\t\tconst sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\t\t\tthis._scheduled.push(sched);\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the source to the Transport so that all subsequent\n\t * calls to `start` and `stop` are synced to the TransportTime\n\t * instead of the AudioContext time.\n\t *\n\t * @example\n\t * //sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n\t * source.sync().start(0).stop(0.3);\n\t * //start the transport.\n\t * this.context.transport.start();\n\t *\n\t * @example\n\t * //start the transport with an offset and the sync'ed sources\n\t * //will start in the correct position\n\t * source.sync().start(0.1);\n\t * //the source will be invoked with an offset of 0.4 = (0.5 - 0.1)\n\t * this.context.transport.start(\"+0.5\", 0.5);\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncedStart = (time, offset) => {\n\t\t\t\tif (offset > 0) {\n\t\t\t\t\t// get the playback state at that time\n\t\t\t\t\tconst stateEvent = this._state.get(offset);\n\t\t\t\t\t// listen for start events which may occur in the middle of the sync'ed time\n\t\t\t\t\tif (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n\t\t\t\t\t\t// get the offset\n\t\t\t\t\t\tconst startOffset = offset - this.toSeconds(stateEvent.time);\n\t\t\t\t\t\tlet duration;\n\t\t\t\t\t\tif (stateEvent.duration) {\n\t\t\t\t\t\t\tduration = this.toSeconds(stateEvent.duration) - startOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._syncedStop = time => {\n\t\t\t\tconst seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\t\t\t\tif (this._state.getValueAtTime(seconds) === \"started\") {\n\t\t\t\t\tthis._stop(time);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.context.transport.on(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"loopStart\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedStop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the source to the Transport. See Source.sync\n\t */\n\tunsync(): this {\n\t\tif (this._synced) {\n\t\t\tthis.context.transport.off(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"loopEnd\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.off(\"loopStart\", this._syncedStart);\n\t\t}\n\t\tthis._synced = false;\n\t\t// clear all of the scheduled ids\n\t\tthis._scheduled.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduled = [];\n\t\tthis._state.cancel(0);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.onstop = noOp;\n\t\tthis.unsync();\n\t\tthis._volume.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n","import { connect } from \"../../core/Connect\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { GainFactor, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { OneShotSource, OneShotSourceCurve, OneShotSourceOptions } from \"../OneShotSource\";\nimport { EQ, GTE, LT } from \"../../core/util/Math\";\n\nexport type ToneBufferSourceCurve = OneShotSourceCurve;\n\nexport interface ToneBufferSourceOptions extends OneShotSourceOptions {\n\tbuffer: ToneAudioBuffer;\n\tcurve: ToneBufferSourceCurve;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tloop: boolean;\n\tonload: () => void;\n}\n\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nexport class ToneBufferSource extends OneShotSource<ToneBufferSourceOptions> {\n\n\treadonly name: string = \"ToneBufferSource\";\n\n\t/**\n\t * The oscillator\n\t */\n\tprivate _source = this.context.createBufferSource();\n\tprotected _internalChannels = [this._source];\n\n\t/**\n\t * The frequency of the oscillator\n\t */\n\treadonly playbackRate: Param<Positive>;\n\n\t/**\n\t * The private instance of the buffer object\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * indicators if the source has started/stopped\n\t */\n\tprivate _sourceStarted: boolean = false;\n\tprivate _sourceStopped: boolean = false;\n\n\t/**\n\t * @param buffer The buffer to play\n\t * @param onload The callback to invoke when the buffer is done playing.\n\t */\n\tconstructor(buffer?: ToneAudioBuffer | AudioBuffer | string, onload?: () => void);\n\tconstructor(options?: Partial<ToneBufferSourceOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]));\n\t\tconst options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"buffer\", \"onload\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\t\tthis._source.onended = () => this._stopSource();\n\n\t\t/**\n\t\t * The playbackRate of the buffer\n\t\t */\n\t\tthis.playbackRate = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._source.playbackRate,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.playbackRate,\n\t\t});\n\n\t\t// set some values initially\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis._buffer = new ToneAudioBuffer(options.buffer, options.onload);\n\n\t\tthis._internalChannels.push(this._source);\n\t}\n\n\tstatic getDefaults(): ToneBufferSourceOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tbuffer: new ToneAudioBuffer(),\n\t\t\tloop: false,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tonload: noOp,\n\t\t\tplaybackRate: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(t: Time) {\n\t\tthis._fadeIn = t;\n\t}\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(t: Time) {\n\t\tthis._fadeOut = t;\n\t}\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tget curve(): ToneBufferSourceCurve {\n\t\treturn this._curve;\n\t}\n\tset curve(t) {\n\t\tthis._curve = t;\n\t}\n\n\t/**\n\t * Start the buffer\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration\n\t *                  is given, it will default to the full length\n\t *                  of the sample (minus any offset)\n\t * @param  gain  The gain to play the buffer back at.\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time, gain: GainFactor = 1): this {\n\t\tthis.assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n\t\tconst computedTime = this.toSeconds(time);\n\n\t\t// apply the gain envelope\n\t\tthis._startGain(computedTime, gain);\n\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this.loop) {\n\t\t\toffset = defaultArg(offset, this.loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\t\t// make sure the offset is not less than 0\n\t\tlet computedOffset = Math.max(this.toSeconds(offset), 0);\n\n\t\t// start the buffer source\n\t\tif (this.loop) {\n\t\t\t// modify the offset if it's greater than the loop time\n\t\t\tconst loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\t\tconst loopStart = this.toSeconds(this.loopStart);\n\t\t\tconst loopDuration = loopEnd - loopStart;\n\t\t\t// move the offset back\n\t\t\tif (GTE(computedOffset, loopEnd)) {\n\t\t\t\tcomputedOffset = ((computedOffset - loopStart) % loopDuration) + loopStart;\n\t\t\t}\n\t\t}\n\n\t\t// this.buffer.loaded would have return false if the AudioBuffer was undefined\n\t\tthis._source.buffer = this.buffer.get() as AudioBuffer;\n\t\tthis._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\tif (LT(computedOffset, this.buffer.duration)) {\n\t\t\tthis._sourceStarted = true;\n\t\t\tthis._source.start(computedTime, computedOffset);\n\t\t}\n\n\t\t// if a duration is given, schedule a stop\n\t\tif (isDefined(duration)) {\n\t\t\tlet computedDur = this.toSeconds(duration);\n\t\t\t// make sure it's never negative\n\t\t\tcomputedDur = Math.max(computedDur, 0);\n\t\t\tthis.stop(computedTime + computedDur);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tif (!this._sourceStopped && this._sourceStarted) {\n\t\t\tthis._sourceStopped = true;\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._onended();\n\t\t}\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._source.loopStart;\n\t}\n\tset loopStart(loopStart: Time) {\n\t\tthis._source.loopStart = this.toSeconds(loopStart);\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._source.loopEnd;\n\t}\n\tset loopEnd(loopEnd: Time) {\n\t\tthis._source.loopEnd = this.toSeconds(loopEnd);\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer: ToneAudioBuffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._source.loop;\n\t}\n\tset loop(loop: boolean) {\n\t\tthis._source.loop = loop;\n\t\tif (this._sourceStarted) {\n\t\t\tthis.cancelStop();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._source.onended = null;\n\t\tthis._source.disconnect();\n\t\tthis._buffer.dispose();\n\t\tthis.playbackRate.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { Positive, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Source, SourceOptions } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n\nexport type NoiseType = \"white\" | \"brown\" | \"pink\";\n\nexport interface NoiseOptions extends SourceOptions {\n\ttype: NoiseType;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n}\n\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * //initialize the noise and start\n * var noise = new Noise(\"pink\").start();\n *\n * //make an autofilter to shape the noise\n * var autoFilter = new Tone.AutoFilter({\n * \t\"frequency\" : \"8m\",\n * \t\"min\" : 800,\n * \t\"max\" : 15000\n * }).connect(Tone.Destination);\n *\n * //connect the noise\n * noise.connect(autoFilter);\n * //start the autofilter LFO\n * autoFilter.start()\n * @category Source\n */\nexport class Noise extends Source<NoiseOptions> {\n\n\treadonly name: string = \"Noise\";\n\n\t/**\n\t * Private reference to the source\n\t */\n\tprivate _source: ToneBufferSource | null = null;\n\n\t/**\n\t * private reference to the type\n\t */\n\tprivate _type!: NoiseType;\n\n\t/**\n\t * The playback rate of the noise. Affects\n\t * the \"frequency\" of the noise.\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * @param type the noise type (white|pink|brown)\n\t */\n\tconstructor(type?: NoiseType);\n\tconstructor(options?: Partial<NoiseOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n\t\tconst options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.type = options.type;\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): NoiseOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tplaybackRate: 1,\n\t\t\ttype: \"white\" as NoiseType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n\t * @example\n\t * noise.type = \"white\";\n\t */\n\tget type(): NoiseType {\n\t\treturn this._type;\n\t}\n\tset type(type: NoiseType) {\n\t\tthis.assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\t\tif (this._type !== type) {\n\t\t\tthis._type = type;\n\t\t\t// if it's playing, stop and restart it\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst now = this.now();\n\t\t\t\tthis._stop(now);\n\t\t\t\tthis._start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The playback rate of the noise. Affects\n\t * the \"frequency\" of the noise.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate: Positive) {\n\t\tthis._playbackRate = rate;\n\t\tif (this._source) {\n\t\t\tthis._source.playbackRate.value = rate;\n\t\t}\n\t}\n\n\t/**\n\t * internal start method\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst buffer = _noiseBuffers[this._type];\n\t\tthis._source = new ToneBufferSource({\n\t\t\tbuffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn: this._fadeIn,\n\t\t\tfadeOut: this._fadeOut,\n\t\t\tloop: true,\n\t\t\tonended: () => this.onstop(this),\n\t\t\tplaybackRate: this._playbackRate,\n\t\t}).connect(this.output);\n\t\tthis._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n\t}\n\n\t/**\n\t * internal stop method\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tif (this._source) {\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._source = null;\n\t\t}\n\t}\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(time) {\n\t\tthis._fadeIn = time;\n\t\tif (this._source) {\n\t\t\tthis._source.fadeIn = this._fadeIn;\n\t\t}\n\t}\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(time) {\n\t\tthis._fadeOut = time;\n\t\tif (this._source) {\n\t\t\tthis._source.fadeOut = this._fadeOut;\n\t\t}\n\t}\n\n\t/**\n\t * Restarts the noise.\n\t * @param  time When to restart the noise.\n\t */\n\trestart(time?: Time): this {\n\t\t// TODO could be optimized by cancelling the buffer source 'stop'\n\t\t// stop and restart\n\t\tthis._stop(time);\n\t\tthis._start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._source) {\n\t\t\tthis._source.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n//--------------------\n// THE NOISE BUFFERS\n//--------------------\n\n// Noise buffer stats\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n\n/**\n * The cached noise buffers\n */\ninterface NoiseCache {\n\t[key: string]: ToneAudioBuffer | null;\n}\n\n/**\n * Cache the noise buffers\n */\nconst _noiseCache: NoiseCache = {\n\tbrown: null,\n\tpink: null,\n\twhite: null,\n};\n\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nconst _noiseBuffers = {\n\tget brown(): ToneAudioBuffer {\n\t\tif (!_noiseCache.brown) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet lastOut = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tchannel[i] = (lastOut + (0.02 * white)) / 1.02;\n\t\t\t\t\tlastOut = channel[i];\n\t\t\t\t\tchannel[i] *= 3.5; // (roughly) compensate for gain\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.brown;\n\t},\n\n\tget pink(): ToneAudioBuffer {\n\t\tif (!_noiseCache.pink) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet b0, b1, b2, b3, b4, b5, b6;\n\t\t\t\tb0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tb0 = 0.99886 * b0 + white * 0.0555179;\n\t\t\t\t\tb1 = 0.99332 * b1 + white * 0.0750759;\n\t\t\t\t\tb2 = 0.96900 * b2 + white * 0.1538520;\n\t\t\t\t\tb3 = 0.86650 * b3 + white * 0.3104856;\n\t\t\t\t\tb4 = 0.55000 * b4 + white * 0.5329522;\n\t\t\t\t\tb5 = -0.7616 * b5 - white * 0.0168980;\n\t\t\t\t\tchannel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n\t\t\t\t\tchannel[i] *= 0.11; // (roughly) compensate for gain\n\t\t\t\t\tb6 = white * 0.115926;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.pink;\n\t},\n\n\tget white(): ToneAudioBuffer {\n\t\tif (!_noiseCache.white) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tchannel[i] = Math.random() * 2 - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.white;\n\t},\n};\n","import { connect } from \"../../core/Connect\";\nimport { Param } from \"../../core/context/Param\";\nimport { Cents, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource, OneShotSourceOptions } from \"../OneShotSource\";\n\nexport interface ToneOscillatorNodeOptions extends OneShotSourceOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\ttype: OscillatorType;\n}\n\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[[Oscillator]] is better for most use-cases***\n * @category Source\n */\nexport class ToneOscillatorNode extends OneShotSource<ToneOscillatorNodeOptions> {\n\n\treadonly name: string = \"ToneOscillatorNode\";\n\n\t/**\n\t * The oscillator\n\t */\n\tprivate _oscillator = this.context.createOscillator();\n\tprotected _internalChannels = [this._oscillator];\n\n\t/**\n\t * The frequency of the oscillator\n\t */\n\treadonly frequency: Param<Frequency>;\n\n\t/**\n\t * The detune of the oscillator\n\t */\n\treadonly detune: Param<Cents>;\n\n\t/**\n\t * @param  frequency   The frequency value\n\t * @param  type  The basic oscillator type\n\t */\n\tconstructor(\n\t\tfrequency: Frequency,\n\t\ttype: OscillatorType,\n\t);\n\tconstructor(options?: Partial<ToneOscillatorNodeOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tconnect(this._oscillator, this._gainNode);\n\n\t\tthis.type = options.type;\n\n\t\tthis.frequency = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._oscillator.frequency,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis.detune = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._oscillator.detune,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t}\n\n\tstatic getDefaults(): ToneOscillatorNodeOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\ttype: \"sine\" as OscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * Start the oscillator node at the given time\n\t * @param  time When to start the oscillator\n\t */\n\tstart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tthis._startGain(computedTime);\n\t\tthis._oscillator.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\t/**\n\t * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n\t * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n\t */\n\tsetPeriodicWave(periodicWave: PeriodicWave): this {\n\t\tthis._oscillator.setPeriodicWave(periodicWave);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n\t */\n\tget type(): OscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type: OscillatorType) {\n\t\tthis._oscillator.type = type;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this.state === \"started\") {\n\t\t\tthis.stop();\n\t\t}\n\t\tthis._oscillator.disconnect();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioRange, Cents, Degrees, Frequency, Radians, Time } from \"../../core/type/Units\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { ToneOscillatorConstructorOptions, ToneOscillatorInterface,\n\tToneOscillatorOptions, ToneOscillatorType } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\n\nexport { ToneOscillatorOptions, ToneOscillatorType } from \"./OscillatorInterface\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * //make and start a 440hz sine tone\n * var osc = new Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\nexport class Oscillator extends Source<ToneOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"Oscillator\";\n\n\t/**\n\t * the main oscillator\n\t */\n\tprivate _oscillator: ToneOscillatorNode | null = null;\n\n\t/**\n\t * The frequency control.\n\t */\n\tfrequency: Signal<Frequency>;\n\n\t/**\n\t * The detune control signal.\n\t */\n\tdetune: Signal<Cents>;\n\n\t/**\n\t * the periodic wave\n\t */\n\tprivate _wave?: PeriodicWave;\n\n\t/**\n\t * The partials of the oscillator\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to limit or extend the periodic wave by\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t * the phase of the oscillator between 0 - 360\n\t */\n\tprivate _phase!: Radians;\n\n\t/**\n\t * the type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * @param frequency Starting frequency\n\t * @param type The oscillator type. Read more about type below.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType);\n\tconstructor(options?: Partial<ToneOscillatorConstructorOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal<Frequency>({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\tthis.detune = new Signal<Cents>({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, \"detune\");\n\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\t\tthis._type = options.type;\n\n\t\tif (options.partialCount && options.type !== \"custom\") {\n\t\t\tthis._type = this.baseType + options.partialCount.toString() as ToneOscillatorType;\n\t\t}\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): ToneOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tpartialCount: 0,\n\t\t\tpartials: [],\n\t\t\tphase: 0,\n\t\t\ttype: \"sine\",\n\t\t}) as ToneOscillatorOptions;\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// new oscillator with previous values\n\t\tconst oscillator = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\tonended: () => this.onstop(this),\n\t\t});\n\t\tthis._oscillator = oscillator;\n\t\tif (this._wave) {\n\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t} else {\n\t\t\tthis._oscillator.type = this._type as OscillatorType;\n\t\t}\n\t\t// connect the control signal to the oscillator frequency & detune\n\t\tthis._oscillator.connect(this.output);\n\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\tthis.detune.connect(this._oscillator.detune);\n\n\t\t// start the oscillator\n\t\tthis._oscillator.start(computedTime);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.stop(computedTime);\n\t\t}\n\t}\n\n\t/**\n\t * Restart the oscillator. Does not stop the oscillator, but instead\n\t * just cancels any scheduled 'stop' from being invoked.\n\t */\n\trestart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"restart\", computedTime);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.cancelStop();\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n\t * will also affect the oscillators frequency.\n\t * @example\n\t * Tone.Transport.bpm.value = 120;\n\t * osc.frequency.value = 440;\n\t * //the ration between the bpm and the frequency will be maintained\n\t * osc.syncFrequency();\n\t * Tone.Transport.bpm.value = 240;\n\t * // the frequency of the oscillator is doubled to 880\n\t */\n\tsyncFrequency(): this {\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the oscillator's frequency from the Transport.\n\t * See Oscillator.syncFrequency\n\t */\n\tunsyncFrequency(): this {\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cache the periodic waves to avoid having to redo computations\n\t */\n\tprivate static _periodicWaveCache: Array<{\n\t\tpartials: number[];\n\t\tphase: number;\n\t\ttype: string;\n\t\tpartialCount: number;\n\t\treal: Float32Array;\n\t\timag: Float32Array;\n\t}> = [];\n\n\t/**\n\t * Get a cached periodic wave. Avoids having to recompute\n\t * the oscillator values when they have already been computed\n\t * with the same values.\n\t */\n\tprivate _getCachedPeriodicWave(): [Float32Array, Float32Array] | undefined {\n\t\tif (this._type === \"custom\") {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn description.phase === this._phase &&\n\t\t\t\t\tdeepEquals(description.partials, this._partials);\n\t\t\t});\n\t\t\treturn oscProps && [oscProps.real, oscProps.imag];\n\t\t} else {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn description.type === this._type &&\n\t\t\t\t\tdescription.phase === this._phase;\n\t\t\t});\n\t\t\tthis._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n\t\t\treturn oscProps && [oscProps.real, oscProps.imag];\n\t\t}\n\t}\n\n\t/**\n\t * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of\n\t * setting the first x number of partials of the oscillator. For example: \"sine4\" would\n\t * set be the first 4 partials of the sine wave and \"triangle8\" would set the first\n\t * 8 partials of the triangle wave.\n\t * <br><br>\n\t * Uses PeriodicWave internally even for native types so that it can set the phase.\n\t * PeriodicWave equations are from the\n\t * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).\n\t *\n\t * @memberOf Oscillator#\n\t * @type {string}\n\t * @name type\n\t * @example\n\t * //set it to a square wave\n\t * osc.type = \"square\";\n\t * @example\n\t * //set the first 6 partials of a sawtooth wave\n\t * osc.type = \"sawtooth6\";\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type) {\n\t\tthis._type = type;\n\t\tconst isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\t\tif (this._phase === 0 && isBasicType) {\n\t\t\tthis._wave = undefined;\n\t\t\tthis._partialCount = 0;\n\t\t\t// just go with the basic approach\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\t// already tested that it's a basic type\n\t\t\t\tthis._oscillator.type = type as OscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// first check if the value is cached\n\t\t\tconst cache = this._getCachedPeriodicWave();\n\t\t\tif (isDefined(cache)) {\n\t\t\t\tconst [real, imag] = cache;\n\t\t\t\tthis._wave = this.context.createPeriodicWave(real, imag);\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst [real, imag] = this._getRealImaginary(type, this._phase);\n\t\t\t\tconst periodicWave = this.context.createPeriodicWave(real, imag);\n\t\t\t\tthis._wave = periodicWave;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t\t// set the cache\n\t\t\t\tOscillator._periodicWaveCache.push({\n\t\t\t\t\timag,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tpartials: this._partials,\n\t\t\t\t\tphase: this._phase,\n\t\t\t\t\treal,\n\t\t\t\t\ttype: this._type,\n\t\t\t\t});\n\t\t\t\tif (Oscillator._periodicWaveCache.length > 100) {\n\t\t\t\t\tOscillator._periodicWaveCache.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn (this._type as string).replace(this.partialCount.toString(), \"\") as OscillatorType;\n\t}\n\tset baseType(baseType) {\n\t\tif (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n\t\t\tthis.type = baseType + this.partialCount as ToneOscillatorType;\n\t\t} else {\n\t\t\tthis.type = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t * @example\n\t * osc.type = 'sine'\n\t * osc.partialCount = 3\n\t * //is equivalent to\n\t * osc.type = 'sine3'\n\t */\n\tget partialCount(): number {\n\t\treturn this._partialCount;\n\t}\n\tset partialCount(p) {\n\t\tlet type = this._type;\n\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\t\tif (partial) {\n\t\t\ttype = partial[1] as OscillatorType;\n\t\t}\n\t\tif (this._type !== \"custom\") {\n\t\t\tif (p === 0) {\n\t\t\t\tthis.type = type;\n\t\t\t} else {\n\t\t\t\tthis.type = type + p.toString() as ToneOscillatorType;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the object's attributes. Given no arguments get\n\t * will return all available object properties and their corresponding\n\t * values.\n\t */\n\tget(): ToneOscillatorOptions {\n\t\tconst values = super.get();\n\t\tif (values.type !== \"custom\") {\n\t\t\tdelete values.partials;\n\t\t}\n\t\treturn values;\n\t}\n\n\t/**\n\t * Returns the real and imaginary components based\n\t * on the oscillator type.\n\t * @returns [real: Float32Array, imaginary: Float32Array]\n\t */\n\tprivate _getRealImaginary(type: ToneOscillatorType, phase: Radians): Float32Array[] {\n\t\tconst fftSize = 4096;\n\t\tlet periodicWaveSize = fftSize / 2;\n\n\t\tconst real = new Float32Array(periodicWaveSize);\n\t\tconst imag = new Float32Array(periodicWaveSize);\n\n\t\tlet partialCount = 1;\n\t\tif (type === \"custom\") {\n\t\t\tpartialCount = this._partials.length + 1;\n\t\t\tthis._partialCount = this._partials.length;\n\t\t\tperiodicWaveSize = partialCount;\n\t\t\t// if the partial count is 0, don't bother doing any computation\n\t\t\tif (this._partials.length === 0) {\n\t\t\t\treturn [real, imag];\n\t\t\t}\n\t\t} else {\n\t\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\t\t\tif (partial) {\n\t\t\t\tpartialCount = parseInt(partial[2], 10) + 1;\n\t\t\t\tthis._partialCount = parseInt(partial[2], 10);\n\t\t\t\ttype = partial[1] as ToneOscillatorType;\n\t\t\t\tpartialCount = Math.max(partialCount, 2);\n\t\t\t\tperiodicWaveSize = partialCount;\n\t\t\t} else {\n\t\t\t\tthis._partialCount = 0;\n\t\t\t}\n\t\t\tthis._partials = [];\n\t\t}\n\n\t\tfor (let n = 1; n < periodicWaveSize; ++n) {\n\t\t\tconst piFactor = 2 / (n * Math.PI);\n\t\t\tlet b;\n\t\t\tswitch (type) {\n\t\t\t\tcase \"sine\":\n\t\t\t\t\tb = (n <= partialCount) ? 1 : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"square\":\n\t\t\t\t\tb = (n & 1) ? 2 * piFactor : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sawtooth\":\n\t\t\t\t\tb = piFactor * ((n & 1) ? 1 : -1);\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"triangle\":\n\t\t\t\t\tif (n & 1) {\n\t\t\t\t\t\tb = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"custom\":\n\t\t\t\t\tb = this._partials[n - 1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new TypeError(\"Oscillator: invalid type: \" + type);\n\t\t\t}\n\t\t\tif (b !== 0) {\n\t\t\t\treal[n] = -b * Math.sin(phase * n);\n\t\t\t\timag[n] = b * Math.cos(phase * n);\n\t\t\t} else {\n\t\t\t\treal[n] = 0;\n\t\t\t\timag[n] = 0;\n\t\t\t}\n\t\t}\n\t\treturn [real, imag];\n\t}\n\n\t/**\n\t * Compute the inverse FFT for a given phase.\n\t */\n\tprivate _inverseFFT(real: Float32Array, imag: Float32Array, phase: Radians): number {\n\t\tlet sum = 0;\n\t\tconst len = real.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tsum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n\t\t}\n\t\treturn sum;\n\t}\n\n\t/**\n\t * Returns the initial value of the oscillator when stopped.\n\t * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n\t */\n\tgetInitialValue(): AudioRange {\n\t\tconst [real, imag] = this._getRealImaginary(this._type, 0);\n\t\tlet maxValue = 0;\n\t\tconst twoPi = Math.PI * 2;\n\t\tconst testPositions = 32;\n\t\t// check for peaks in 16 places\n\t\tfor (let i = 0; i < testPositions; i++) {\n\t\t\tmaxValue = Math.max(this._inverseFFT(real, imag, (i / testPositions) * twoPi), maxValue);\n\t\t}\n\t\treturn -this._inverseFFT(real, imag, this._phase) / maxValue;\n\t}\n\n\t/**\n\t * The partials of the waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._partials;\n\t}\n\tset partials(partials) {\n\t\tthis._partials = partials;\n\t\tif (partials.length) {\n\t\t\tthis.type = \"custom\";\n\t\t}\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t * @example\n\t * osc.phase = 180; //flips the phase of the oscillator\n\t */\n\tget phase(): Degrees {\n\t\treturn this._phase * (180 / Math.PI);\n\t}\n\tset phase(phase) {\n\t\tthis._phase = phase * Math.PI / 180;\n\t\t// reset the type\n\t\tthis.type = this._type;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._oscillator !== null) {\n\t\t\tthis._oscillator.dispose();\n\t\t}\n\t\tthis._wave = undefined;\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n","import { optionsFromArguments } from \"..//core/util/Defaults\";\nimport { InputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connectSignal } from \"./Signal\";\n/**\n * A signal operator has an input and output and modifies the signal.\n */\nexport abstract class SignalOperator<Options extends ToneAudioNodeOptions> extends ToneAudioNode<Options> {\n\n\tconstructor(options?: Partial<Options>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(SignalOperator.getDefaults(), arguments, [\"context\"])));\n\t}\n\n\tconnect(destination: InputNode, outputNum: number = 0, inputNum: number = 0): this {\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction, isUndef } from \"../core/util/TypeCheck\";\nimport { Signal, SignalOptions } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n\nexport type WaveShaperMappingFn = (value: number, index?: number) => number;\n\ntype WaveShaperMapping = WaveShaperMappingFn | number[] | Float32Array;\n\ninterface WaveShaperOptions extends ToneAudioNodeOptions {\n\tmapping?: WaveShaperMapping;\n\tlength: number;\n\tcurve?: number[] | Float32Array;\n}\n\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * var timesTwo = new WaveShaper(function(val){\n * \treturn val * 2;\n * }, 2048);\n * @example\n * //a waveshaper can also be constructed with an array of values\n * var invert = new WaveShaper([1, -1]);\n * @category Signal\n */\nexport class WaveShaper extends SignalOperator<WaveShaperOptions> {\n\n\treadonly name: string = \"WaveShaper\";\n\n\t/**\n\t * the waveshaper node\n\t */\n\tprivate _shaper: WaveShaperNode = this.context.createWaveShaper();\n\n\t/**\n\t * The input to the waveshaper node.\n\t */\n\tinput = this._shaper;\n\n\t/**\n\t * The output from the waveshaper node\n\t */\n\toutput = this._shaper;\n\n\t/**\n\t * @param mapping The function used to define the values.\n\t *                The mapping function should take two arguments:\n\t *                the first is the value at the current position\n\t *                and the second is the array position.\n\t *                If the argument is an array, that array will be\n\t *                set as the wave shaping function. The input\n\t *                signal is an AudioRange [-1, 1] value and the output\n\t *                signal can take on any numerical values.\n\t *\n\t * @param bufferLen The length of the WaveShaperNode buffer.\n\t */\n\tconstructor(mapping?: WaveShaperMapping, length?: number);\n\tconstructor(options?: Partial<WaveShaperOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n\t\tconst options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n\n\t\tif (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n\t\t\tthis.curve = Float32Array.from(options.mapping);\n\t\t} else if (isFunction(options.mapping)) {\n\t\t\tthis.setMap(options.mapping, options.length);\n\t\t}\n\t}\n\n\tstatic getDefaults(): WaveShaperOptions {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tlength: 1024,\n\t\t});\n\t}\n\n\t/**\n\t * Uses a mapping function to set the value of the curve.\n\t * @param mapping The function used to define the values.\n\t *                The mapping function take two arguments:\n\t *                the first is the value at the current position\n\t *                which goes from -1 to 1 over the number of elements\n\t *                in the curve array. The second argument is the array position.\n\t * @example\n\t * //map the input signal from [-1, 1] to [0, 10]\n\t * shaper.setMap(function(val, index){\n\t * \treturn (val + 1) * 5;\n\t * })\n\t */\n\tsetMap(mapping: WaveShaperMappingFn, length: number = 1024): this {\n\t\tconst array = new Float32Array(length);\n\t\tfor (let i = 0, len = length; i < len; i++) {\n\t\t\tconst normalized = (i / (len - 1)) * 2 - 1;\n\t\t\tarray[i] = mapping(normalized, i);\n\t\t}\n\t\tthis.curve = array;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The array to set as the waveshaper curve. For linear curves\n\t * array length does not make much difference, but for complex curves\n\t * longer arrays will provide smoother interpolation.\n\t */\n\tget curve(): Float32Array | null {\n\t\treturn this._shaper.curve;\n\t}\n\n\tset curve(mapping: Float32Array | null) {\n\t\tthis._shaper.curve = mapping;\n\t}\n\n\t/**\n\t * Specifies what type of oversampling (if any) should be used when\n\t * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\n\tset oversample(oversampling: OverSampleType) {\n\t\tconst isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n\t\tthis.assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.disconnect();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1].\n * See {@link GainToAudio}.\n *\n * @example\n * var a2g = new AudioToGain();\n * @category Signal\n */\nexport class AudioToGain extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"AudioToGain\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: x => (x + 1) / 2,\n\t});\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The GainRange output [0, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal, SignalOptions } from \"./Signal\";\n\n/**\n * Multiply two incoming signals. Or, if a number is given in the constructor,\n * multiplies the incoming signal by that value.\n *\n * @example\n * const mult = new Multiply();\n * const sigA = new Tone.Signal(3);\n * const sigB = new Tone.Signal(4);\n * sigA.connect(mult);\n * sigB.connect(mult.factor);\n * //output of mult is 12.\n * @example\n * const mult = new Multiply(10);\n * const sig = new Tone.Signal(2).connect(mult);\n * //the output of mult is 20.\n * @category Signal\n */\nexport class Multiply extends Signal<number> {\n\n\treadonly name: string = \"Multiply\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection\n\t */\n\treadonly override = false;\n\n\t/**\n\t * the input gain node\n\t */\n\tprivate _mult: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The multiplicand input.\n\t */\n\tinput = this._mult;\n\n\t/**\n\t * The product of the input and {@link factor}\n\t */\n\toutput = this._mult;\n\n\t/**\n\t * The multiplication factor. Can be set directly or a signal can be connected to it.\n\t */\n\tfactor: Param<number>;\n\n\t/**\n\t * @param value Constant value to multiple\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<SignalOptions<number>>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"])));\n\t\tconst options = optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis.factor = this._param = this._mult.gain as unknown as Param<number>;\n\t\tthis.factor.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): SignalOptions<number> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._mult.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Cents, Degrees, Frequency, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { AMConstructorOptions, AMOscillatorOptions,\n\tNonCustomOscillatorType, ToneOscillatorInterface,\n\tToneOscillatorType } from \"./OscillatorInterface\";\n\nexport { AMOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * An amplitude modulated oscillator node. It is implemented with\n * two oscillators, one which modulators the other's amplitude\n * through a gain node.\n * ```\n *    +-------------+       +----------+\n *    | Carrier Osc +>------> GainNode |\n *    +-------------+       |          +--->Output\n *                      +---> gain     |\n * +---------------+    |   +----------+\n * | Modulator Osc +>---+\n * +---------------+\n * ```\n *\n * @example\n * //a sine oscillator amplitude-modulated by a square wave\n * var amOsc = new AMOscillator(\"Ab3\", \"sine\", \"square\").toDestination().start();\n * @category Source\n */\nexport class AMOscillator extends Source<AMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"AMOscillator\";\n\n\t/**\n\t * The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\t/**\n\t * The oscillator's frequency\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t * The detune control signal.\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t * The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * convert the -1,1 output to 0,1\n\t */\n\tprivate _modulationScale = new AudioToGain({ context: this.context });\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * A harmonicity of 1 gives both oscillators the same frequency.\n\t * Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * //pitch the modulator an octave below carrier\n\t * synth.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<Positive>;\n\n\t/**\n\t * the node where the modulation happens\n\t */\n\tprivate _modulationNode = new Gain({\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * @param frequency The starting frequency of the oscillator.\n\t * @param type The type of the carrier oscillator.\n\t * @param modulationType The type of the modulator oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor(options?: Partial<AMConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\t\tthis.frequency = this._carrier.frequency,\n\t\tthis.detune = this._carrier.detune;\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t\tthis._carrier.chain(this._modulationNode, this.output);\n\n\t\treadOnly(this, [\"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): AMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Seconds): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Seconds): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\t/**\n\t * restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the carrier oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t */\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\t/**\n\t * The partials of the carrier waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis._modulationScale.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { AudioRange, Cents, Degrees, Frequency, Positive, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { FMConstructorOptions, FMOscillatorOptions,\n\tNonCustomOscillatorType, ToneOscillatorInterface, ToneOscillatorType } from \"./OscillatorInterface\";\n\nexport { FMOscillatorOptions } from \"./OscillatorInterface\";\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @example\n * //a sine oscillator frequency-modulated by a square wave\n * var fmOsc = new FMOscillator(\"Ab3\", \"sine\", \"square\").toDestination().start();\n * @category Source\n */\nexport class FMOscillator extends Source<FMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"FMOscillator\";\n\n\t/**\n\t * The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\t/**\n\t * The oscillator's frequency\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t * The detune control signal.\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t * The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * A harmonicity of 1 gives both oscillators the same frequency.\n\t * Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * //pitch the modulator an octave below carrier\n\t * synth.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<Positive>;\n\n\t/**\n\t * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Signal<Positive>;\n\n\t/**\n\t * the node where the modulation happens\n\t */\n\tprivate _modulationNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * @param frequency The starting frequency of the oscillator.\n\t * @param type The type of the carrier oscillator.\n\t * @param modulationType The type of the modulator oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor(options?: Partial<FMConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: 0,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\n\t\tthis.detune = this._carrier.detune;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\tthis.modulationIndex = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.modulationIndex,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t\tthis.detune.connect(this._modulator.detune);\n\n\t\treadOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): FMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationIndex: 2,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\t/**\n\t * stop and restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the carrier oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t */\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\t/**\n\t * The partials of the carrier waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { AudioRange, Cents, Degrees, Frequency, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { WaveShaper } from \"../../signal/WaveShaper\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { PulseOscillatorOptions, ToneOscillatorInterface } from \"./OscillatorInterface\";\n\nexport { PulseOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * PulseOscillator is an oscillator with control over pulse width,\n * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is\n * a square wave.\n * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n * ```\n *    width = -0.25        width = 0.0          width = 0.25\n *\n *   +-----+            +-------+       +    +-------+     +-+\n *   |     |            |       |       |            |     |\n *   |     |            |       |       |            |     |\n * +-+     +-------+    +       +-------+            +-----+\n *\n *\n *    width = -0.5                              width = 0.5\n *\n *     +---+                                 +-------+   +---+\n *     |   |                                         |   |\n *     |   |                                         |   |\n * +---+   +-------+                                 +---+\n *\n *\n *    width = -0.75                             width = 0.75\n *\n *       +-+                                 +-------+ +-----+\n *       | |                                         | |\n *       | |                                         | |\n * +-----+ +-------+                                 +-+\n * ```\n * @example\n * var pulse = new PulseOscillator(\"E5\", 0.4).toDestination().start();\n * @category Source\n */\nexport class PulseOscillator extends Source<PulseOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"PulseOscillator\";\n\n\t/**\n\t * The width of the pulse.\n\t */\n\twidth: Signal<AudioRange>;\n\n\t/**\n\t * gate the width amount\n\t */\n\tprivate _widthGate: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * the sawtooth oscillator\n\t */\n\tprivate _sawtooth: Oscillator;\n\n\t/**\n\t * The frequency control.\n\t */\n\tfrequency: Signal<Frequency>;\n\n\t/**\n\t * The detune in cents.\n\t */\n\tdetune: Signal<Cents>;\n\n\t/**\n\t * Threshold the signal to turn it into a square\n\t */\n\tprivate _thresh = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: val => val <= 0 ? -1 : 1,\n\t});\n\n\t/**\n\t * @param frequency The frequency of the oscillator\n\t * @param width The width of the pulse\n\t */\n\tconstructor(frequency?: Frequency, width?: AudioRange);\n\tconstructor(options?: Partial<PulseOscillatorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]));\n\t\tconst options = optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]);\n\n\t\tthis.width = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"audioRange\",\n\t\t\tvalue: options.width,\n\t\t});\n\n\t\tthis._sawtooth = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: \"sawtooth\",\n\t\t});\n\t\tthis.frequency = this._sawtooth.frequency;\n\t\tthis.detune = this._sawtooth.detune;\n\n\t\t// connections\n\t\tthis._sawtooth.chain(this._thresh, this.output);\n\t\tthis.width.chain(this._widthGate, this._thresh);\n\t\treadOnly(this, [\"width\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PulseOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tphase: 0,\n\t\t\ttype: \"pulse\" as \"pulse\",\n\t\t\twidth: 0.2,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._sawtooth.start(time);\n\t\tthis._widthGate.gain.setValueAtTime(1, time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._sawtooth.stop(time);\n\t\t// the width is still connected to the output.\n\t\t// that needs to be stopped also\n\t\tthis._widthGate.gain.cancelScheduledValues(time);\n\t\tthis._widthGate.gain.setValueAtTime(0, time);\n\t}\n\n\t/**\n\t * Restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._sawtooth.restart(computedTime);\n\t\tthis._widthGate.gain.cancelScheduledValues(computedTime);\n\t\tthis._widthGate.gain.setValueAtTime(1, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._sawtooth.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._sawtooth.phase = phase;\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pulse\".\n\t */\n\tget type(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pulse\".\n\t */\n\tget baseType(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Clean up method.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sawtooth.dispose();\n\t\tthis.width.dispose();\n\t\tthis._widthGate.dispose();\n\t\tthis._thresh.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioRange, Cents, Degrees, Frequency, Positive, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { FatConstructorOptions, FatOscillatorOptions,\n\tToneOscillatorInterface, ToneOscillatorType } from \"./OscillatorInterface\";\n\nexport { FatOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @param frequency The oscillator's frequency.\n * @param type The type of the oscillator.\n * @param spread The detune spread between the oscillators.\n * @example\n * var fatOsc = new FatOscillator(\"Ab3\", \"sine\", 40).toDestination().start();\n * @category Source\n */\nexport class FatOscillator extends Source<FatOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"FatOscillator\";\n\n\t/**\n\t * The oscillator's frequency\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t * The detune control signal.\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t * The array of oscillators\n\t */\n\tprivate _oscillators: Oscillator[] = [];\n\n\t/**\n\t * The total spread of the oscillators\n\t */\n\tprivate _spread: Cents;\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * The phase of the oscillators\n\t */\n\tprivate _phase: Degrees;\n\n\t/**\n\t * The partials array\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to use\n\t */\n\tprivate _partialCount: number;\n\n\tconstructor(options?: Partial<FatConstructorOptions>);\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n\t\tconst options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\tthis._spread = options.spread;\n\t\tthis._type = options.type;\n\t\tthis._phase = options.phase;\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\n\t\t// set the count initially\n\t\tthis.count = options.count;\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): FatOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tcount: 3,\n\t\t\tspread: 20,\n\t\t\ttype: \"sawtooth\",\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.start(time));\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.stop(time));\n\t}\n\n\t/**\n\t * restart the oscillator\n\t */\n\trestart(time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.restart(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over all of the oscillators\n\t */\n\tprivate _forEach(iterator: (osc: Oscillator, index: number) => void): void {\n\t\tfor (let i = 0; i < this._oscillators.length; i++) {\n\t\t\titerator(this._oscillators[i], i);\n\t\t}\n\t}\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\n\tset type(type: ToneOscillatorType) {\n\t\tthis._type = type;\n\t\tthis._forEach(osc => osc.type = type);\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents.\n\t */\n\tget spread(): Cents {\n\t\treturn this._spread;\n\t}\n\n\tset spread(spread: Cents) {\n\t\tthis._spread = spread;\n\t\tif (this._oscillators.length > 1) {\n\t\t\tconst start = -spread / 2;\n\t\t\tconst step = spread / (this._oscillators.length - 1);\n\t\t\tthis._forEach((osc, i) => osc.detune.value = start + step * i);\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators. Should be an integer greater than 1.\n\t */\n\tget count(): number {\n\t\treturn this._oscillators.length;\n\t}\n\tset count(count: number) {\n\t\tcount = Math.max(count, 1);\n\t\tif (this._oscillators.length !== count) {\n\t\t\t// dispose the previous oscillators\n\t\t\tthis._forEach(osc => osc.dispose());\n\t\t\tthis._oscillators = [];\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst osc = new Oscillator({\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tonstop: i === 0 ? () => this.onstop(this) : noOp,\n\t\t\t\t});\n\t\t\t\tif (this.type === \"custom\") {\n\t\t\t\t\tosc.partials = this._partials;\n\t\t\t\t} else {\n\t\t\t\t\tosc.type = this._type;\n\t\t\t\t}\n\t\t\t\tosc.partialCount = this._partialCount;\n\t\t\t\tosc.phase = this._phase + (i / count) * 360;\n\t\t\t\tosc.volume.value = -6 - count * 1.1;\n\t\t\t\tthis.frequency.connect(osc.frequency);\n\t\t\t\tthis.detune.connect(osc.detune);\n\t\t\t\tosc.connect(this.output);\n\t\t\t\tthis._oscillators[i] = osc;\n\t\t\t}\n\t\t\t// set the spread\n\t\t\tthis.spread = this._spread;\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._forEach(osc => osc.start());\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase;\n\t\tthis._forEach(osc => osc.phase = phase);\n\t}\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * osc.type = 'sine2'\n\t * osc.baseType //'sine'\n\t * osc.partialCount = 2\n\t */\n\tget baseType(): OscillatorType {\n\t\treturn this._oscillators[0].baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._forEach(osc => osc.baseType = baseType);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\t/**\n\t * The partials of the carrier waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @memberOf FatOscillator#\n\t * @type {Array}\n\t * @name partials\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillators[0].partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tif (partials.length) {\n\t\t\tthis._type = \"custom\";\n\t\t\tthis._forEach(osc => osc.partials = partials);\n\t\t}\n\t}\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array.\n\t * @memberOf FatOscillator#\n\t * @type {Number}\n\t * @name partialCount\n\t */\n\tget partialCount(): number {\n\t\treturn this._oscillators[0].partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._partialCount = partialCount;\n\t\tthis._forEach(osc => osc.partialCount = partialCount);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._forEach(osc => osc.dispose());\n\t\treturn this;\n\t}\n}\n","import { Cents, Degrees, Frequency, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { PWMOscillatorOptions, ToneOscillatorInterface } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\n\nexport { PWMOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * PWMOscillator modulates the width of a Tone.PulseOscillator\n * at the modulationFrequency. This has the effect of continuously\n * changing the timbre of the oscillator by altering the harmonics\n * generated.\n * @example\n * var pwm = new PWMOscillator(\"Ab3\", 0.3).toDestination().start();\n * @category Source\n */\nexport class PWMOscillator extends Source<PWMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"PWMOscillator\";\n\n\treadonly sourceType = \"pwm\";\n\n\t/**\n\t * the pulse oscillator\n\t */\n\tprivate _pulse: PulseOscillator;\n\t/**\n\t * the modulator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * Scale the oscillator so it doesn't go silent\n\t * at the extreme values.\n\t */\n\tprivate _scale: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: 2,\n\t});\n\n\t/**\n\t * The frequency control.\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t * The detune of the oscillator.\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t * The modulation rate of the oscillator.\n\t */\n\treadonly modulationFrequency: Signal<Frequency>;\n\n\t/**\n\t * @param {Frequency} frequency The starting frequency of the oscillator.\n\t * @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse.\n\t */\n\tconstructor(frequency?: Frequency, modulationFrequency?: Frequency);\n\tconstructor(options?: Partial<PWMOscillatorOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]));\n\t\tconst options = optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]);\n\n\t\tthis._pulse = new PulseOscillator({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.modulationFrequency,\n\t\t});\n\t\t// change the pulse oscillator type\n\t\t// @ts-ignore\n\t\tthis._pulse._sawtooth.type = \"sine\";\n\n\t\tthis.modulationFrequency = this._pulse.frequency;\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t});\n\n\t\tthis.frequency = this._modulator.frequency;\n\t\tthis.detune = this._modulator.detune;\n\n\t\t// connections\n\t\tthis._modulator.chain(this._scale, this._pulse.width);\n\t\tthis._pulse.connect(this.output);\n\t\treadOnly(this, [\"modulationFrequency\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PWMOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tmodulationFrequency: 0.4,\n\t\t\tphase: 0,\n\t\t\ttype: \"pwm\" as \"pwm\",\n\t\t});\n\t}\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.start(time);\n\t\tthis._pulse.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.stop(time);\n\t\tthis._pulse.stop(time);\n\t}\n\n\t/**\n\t * restart the oscillator\n\t */\n\trestart(time?: Time): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._pulse.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pwm\".\n\t */\n\tget type(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pwm\".\n\t */\n\tget baseType(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._modulator.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._modulator.phase = phase;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._pulse.dispose();\n\t\tthis._scale.dispose();\n\t\tthis._modulator.dispose();\n\t\treturn this;\n\t}\n}\n","import { AudioRange, Cents, Degrees, Frequency, Positive, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport { OmniOscillatorConstructorOptions,\n\tOmniOscillatorOptions, OmniOscillatorType,\n\tToneOscillatorInterface, ToneOscillatorType } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\n\nexport { OmniOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * All of the oscillator types that OmniOscillator can take on\n */\ntype AnyOscillator = Oscillator | PWMOscillator | PulseOscillator | FatOscillator | AMOscillator | FMOscillator;\n\n/**\n * All of the Oscillator constructor types mapped to their name.\n */\ninterface OmniOscillatorSource {\n\t\"fm\": FMOscillator;\n\t\"am\": AMOscillator;\n\t\"pwm\": PWMOscillator;\n\t\"pulse\": PulseOscillator;\n\t\"oscillator\": Oscillator;\n\t\"fat\": FatOscillator;\n}\n\n/**\n * The available oscillator types.\n */\nexport type OmniOscSourceType = keyof OmniOscillatorSource;\n\n// Conditional Types\ntype IsAmOrFmOscillator<Osc, Ret> = Osc extends AMOscillator ? Ret : Osc extends FMOscillator ? Ret : undefined;\ntype IsFatOscillator<Osc, Ret> = Osc extends FatOscillator ? Ret : undefined;\ntype IsPWMOscillator<Osc, Ret> = Osc extends PWMOscillator ? Ret : undefined;\ntype IsPulseOscillator<Osc, Ret> = Osc extends PulseOscillator ? Ret : undefined;\ntype IsFMOscillator<Osc, Ret> = Osc extends FMOscillator ? Ret : undefined;\n\ntype AnyOscillatorConstructor = new (...args: any[]) => AnyOscillator;\n\nconst OmniOscillatorSourceMap: {\n\t[key in OmniOscSourceType]: AnyOscillatorConstructor\n} = {\n\tam: AMOscillator,\n\tfat: FatOscillator,\n\tfm: FMOscillator,\n\toscillator: Oscillator,\n\tpulse: PulseOscillator,\n\tpwm: PWMOscillator,\n};\n\n/**\n * OmniOscillator aggregates Tone.Oscillator, Tone.PulseOscillator,\n * Tone.PWMOscillator, Tone.FMOscillator, Tone.AMOscillator, and Tone.FatOscillator\n * into one class. The oscillator class can be changed by setting the `type`.\n * `omniOsc.type = \"pwm\"` will set it to the Tone.PWMOscillator. Prefixing\n * any of the basic types (\"sine\", \"square4\", etc.) with \"fm\", \"am\", or \"fat\"\n * will use the FMOscillator, AMOscillator or FatOscillator respectively.\n * For example: `omniOsc.type = \"fatsawtooth\"` will create set the oscillator\n * to a FatOscillator of type \"sawtooth\".\n * @example\n * var omniOsc = new OmniOscillator(\"C#4\", \"pwm\");\n * @category Source\n */\nexport class OmniOscillator<OscType extends AnyOscillator>\n\textends Source<OmniOscillatorConstructorOptions>\n\timplements Omit<ToneOscillatorInterface, \"type\"> {\n\n\treadonly name: string = \"OmniOscillator\";\n\n\t/**\n\t * The frequency control.\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t * The detune control.\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t * The oscillator that can switch types\n\t */\n\tprivate _oscillator!: AnyOscillator;\n\n\t/**\n\t * the type of the oscillator source\n\t */\n\tprivate _sourceType!: OmniOscSourceType;\n\n\t/**\n\t * @param frequency The initial frequency of the oscillator.\n\t * @param type The type of the oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: OmniOscillatorType);\n\tconstructor(options?: Partial<OmniOscillatorConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\n\t\t// set the options\n\t\tthis.set(options);\n\t}\n\n\tstatic getDefaults(): OmniOscillatorOptions {\n\t\treturn Object.assign(\n\t\t\tOscillator.getDefaults(),\n\t\t\tFMOscillator.getDefaults(),\n\t\t\tAMOscillator.getDefaults(),\n\t\t\tFatOscillator.getDefaults(),\n\t\t\tPulseOscillator.getDefaults(),\n\t\t\tPWMOscillator.getDefaults(),\n\t\t);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._oscillator.start(time);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\trestart(time?: Time): this {\n\t\tthis._oscillator.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n\t * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n\t * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n\t * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n\t * when it's not.\n\t * @example\n\t * omniOsc.type = \"pwm\";\n\t * //modulationFrequency is parameter which is available\n\t * //only when the type is \"pwm\".\n\t * omniOsc.modulationFrequency.value = 0.5;\n\t * @example\n\t * //an square wave frequency modulated by a sawtooth\n\t * omniOsc.type = \"fmsquare\";\n\t * omniOsc.modulationType = \"sawtooth\";\n\t */\n\tget type(): OmniOscillatorType {\n\t\tlet prefix = \"\";\n\t\tif ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n\t\t\tprefix = this._sourceType;\n\t\t}\n\t\treturn prefix + this._oscillator.type as OmniOscillatorType;\n\t}\n\tset type(type) {\n\t\tif (type.substr(0, 2) === \"fm\") {\n\t\t\tthis._createNewOscillator(\"fm\");\n\t\t\tthis._oscillator = this._oscillator as FMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 2) === \"am\") {\n\t\t\tthis._createNewOscillator(\"am\");\n\t\t\tthis._oscillator = this._oscillator as AMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 3) === \"fat\") {\n\t\t\tthis._createNewOscillator(\"fat\");\n\t\t\tthis._oscillator = this._oscillator as FatOscillator;\n\t\t\tthis._oscillator.type = type.substr(3) as ToneOscillatorType;\n\t\t} else if (type === \"pwm\") {\n\t\t\tthis._createNewOscillator(\"pwm\");\n\t\t\tthis._oscillator = this._oscillator as PWMOscillator;\n\t\t} else if (type === \"pulse\") {\n\t\t\tthis._createNewOscillator(\"pulse\");\n\t\t} else {\n\t\t\tthis._createNewOscillator(\"oscillator\");\n\t\t\tthis._oscillator = this._oscillator as Oscillator;\n\t\t\tthis._oscillator.type = (type as ToneOscillatorType);\n\t\t}\n\t}\n\n\t/**\n\t * The partials of the waveform. A partial represents\n\t * the amplitude at a harmonic. The first harmonic is the\n\t * fundamental frequency, the second is the octave and so on\n\t * following the harmonic series.\n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * @example\n\t * osc.partials = [1, 0.2, 0.01];\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partials = partials;\n\t\t}\n\t}\n\n\t/**\n\t * The partial count of the oscillator. This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * @example\n\t * //set the maximum number of partials\n\t * osc.partialCount = 0;\n\t */\n\tget partialCount(): number {\n\t\treturn this._oscillator.partialCount;\n\t}\n\tset partialCount(partialCount) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partialCount = partialCount;\n\t\t}\n\t}\n\n\t/**\n\t * Set the parameters at once. Either pass in an\n\t * object mapping parameters to values, or to set a\n\t * single parameter, by passing in a string and value.\n\t * The last argument is an optional ramp time which\n\t * will ramp any signal values to their destination value\n\t * over the duration of the rampTime.\n\t * @param  params\n\t * @example\n\t * //set values using an object\n\t * filter.set({\n\t * \t\"frequency\" : 300,\n\t * \t\"type\" : \"highpass\"\n\t * });\n\t */\n\tset(props: Partial<OmniOscillatorConstructorOptions>): this {\n\t\t// make sure the type is set first\n\t\tif (Reflect.has(props, \"type\") && props.type) {\n\t\t\tthis.type = props.type;\n\t\t}\n\t\t// then set the rest\n\t\tsuper.set(props);\n\t\treturn this;\n\t}\n\n\t/**\n\t * connect the oscillator to the frequency and detune signals\n\t */\n\tprivate _createNewOscillator(oscType: OmniOscSourceType): void {\n\t\tif (oscType !== this._sourceType) {\n\t\t\tthis._sourceType = oscType;\n\t\t\tconst OscConstructor = OmniOscillatorSourceMap[oscType];\n\t\t\t// short delay to avoid clicks on the change\n\t\t\tconst now = this.now();\n\t\t\tif (this._oscillator) {\n\t\t\t\tconst oldOsc = this._oscillator;\n\t\t\t\toldOsc.stop(now);\n\t\t\t\t// dispose the old one\n\t\t\t\tthis.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n\t\t\t}\n\t\t\tthis._oscillator = new OscConstructor({\n\t\t\t\tcontext: this.context,\n\t\t\t});\n\t\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\t\tthis.detune.connect(this._oscillator.detune);\n\t\t\tthis._oscillator.connect(this.output);\n\t\t\tthis._oscillator.onstop = () => this.onstop(this);\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._oscillator.start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t}\n\n\t/**\n\t * The source type of the oscillator.\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"fmsquare\");\n\t * omniOsc.sourceType // 'fm'\n\t */\n\tget sourceType(): OmniOscSourceType {\n\t\treturn this._sourceType;\n\t}\n\tset sourceType(sType) {\n\t\t// the basetype defaults to sine\n\t\tlet baseType = \"sine\";\n\t\tif (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n\t\t\tbaseType = this._oscillator.type;\n\t\t}\n\n\t\t// set the type\n\t\tif (sType === \"fm\") {\n\t\t\tthis.type = \"fm\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"am\") {\n\t\t\tthis.type = \"am\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"fat\") {\n\t\t\tthis.type = \"fat\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"oscillator\") {\n\t\t\tthis.type = baseType as OmniOscillatorType;\n\t\t} else if (sType === \"pulse\") {\n\t\t\tthis.type = \"pulse\";\n\t\t} else if (sType === \"pwm\") {\n\t\t\tthis.type = \"pwm\";\n\t\t}\n\t}\n\n\tprivate _getOscType<SourceType extends OmniOscSourceType>(\n\t\tosc: AnyOscillator,\n\t\tsourceType: SourceType,\n\t): osc is OmniOscillatorSource[SourceType] {\n\t\treturn osc instanceof OmniOscillatorSourceMap[sourceType];\n\t}\n\n\t/**\n\t * The base type of the oscillator.\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"fmsquare4\");\n\t * omniOsc.sourceType // 'fm'\n\t * omniOsc.baseType //'square'\n\t * omniOsc.partialCount //4\n\t */\n\tget baseType(): OscillatorType | \"pwm\" | \"pulse\" {\n\t\treturn this._oscillator.baseType;\n\t}\n\tset baseType(baseType) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") &&\n\t\t\t!this._getOscType(this._oscillator, \"pwm\") &&\n\t\t\tbaseType !== \"pulse\" && baseType !== \"pwm\") {\n\t\t\tthis._oscillator.baseType = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * The width of the oscillator when sourceType === \"pulse\".\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"pulse\");\n\t * //can access the width attribute only if type === \"pulse\"\n\t * omniOsc.width.value = 0.2;\n\t */\n\tget width(): IsPulseOscillator<OscType, Signal<AudioRange>> {\n\t\tif (this._getOscType(this._oscillator, \"pulse\")) {\n\t\t\treturn this._oscillator.width as IsPulseOscillator<OscType, Signal<AudioRange>> ;\n\t\t} else {\n\t\t\treturn undefined as IsPulseOscillator<OscType, Signal<AudioRange>> ;\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators, when sourceType === \"fat\".\n\t */\n\tget count(): IsFatOscillator<OscType, number> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.count as IsFatOscillator<OscType, number>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, number>;\n\t\t}\n\t}\n\tset count(count) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n\t\t\tthis._oscillator.count = count;\n\t\t}\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents. See Tone.FatOscillator\n\t * for more info.\n\t */\n\tget spread(): IsFatOscillator<OscType, Cents> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.spread as IsFatOscillator<OscType, Cents>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, Cents>;\n\t\t}\n\t}\n\tset spread(spread) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n\t\t\tthis._oscillator.spread = spread;\n\t\t}\n\t}\n\n\t/**\n\t * The type of the modulator oscillator. Only if the oscillator\n\t * is set to \"am\" or \"fm\" types. see. Tone.AMOscillator or Tone.FMOscillator\n\t * for more info.\n\t */\n\tget modulationType(): IsAmOrFmOscillator<OscType, ToneOscillatorType> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.modulationType as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t}\n\t}\n\tset modulationType(mType) {\n\t\tif ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n\t\t\tthis._oscillator.modulationType = mType;\n\t\t}\n\t}\n\n\t/**\n\t * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t * See Tone.FMOscillator for more info.\n\t */\n\tget modulationIndex(): IsFMOscillator<OscType, Signal<Positive>> {\n\t\tif (this._getOscType(this._oscillator, \"fm\")) {\n\t\t\treturn this._oscillator.modulationIndex as IsFMOscillator<OscType, Signal<Positive>>;\n\t\t} else {\n\t\t\treturn undefined as IsFMOscillator<OscType, Signal<Positive>>;\n\t\t}\n\t}\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * A harmonicity of 1 gives both oscillators the same frequency.\n\t * Harmonicity = 2 means a change of an octave. See Tone.AMOscillator or Tone.FMOscillator\n\t * for more info.\n\t */\n\tget harmonicity(): IsAmOrFmOscillator<OscType, Signal<Positive>> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.harmonicity as IsAmOrFmOscillator<OscType, Signal<Positive>>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, Signal<Positive>>;\n\t\t}\n\t}\n\n\t/**\n\t * The modulationFrequency Signal of the oscillator\n\t * (only if the oscillator type is set to pwm). See\n\t * Tone.PWMOscillator for more info.\n\t * @example\n\t * var omniOsc = new OmniOscillator(440, \"pwm\");\n\t * //can access the modulationFrequency attribute only if type === \"pwm\"\n\t * omniOsc.modulationFrequency.value = 0.2;\n\t * @min 0.1\n\t * @max 5\n\t */\n\tget modulationFrequency(): IsPWMOscillator<OscType, Signal<Frequency>> {\n\t\tif (this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\treturn this._oscillator.modulationFrequency as IsPWMOscillator<OscType, Signal<Frequency>>;\n\t\t} else {\n\t\t\treturn undefined as IsPWMOscillator<OscType, Signal<Frequency>>;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._oscillator.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { Positive, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isUndef } from \"../../core/util/TypeCheck\";\nimport { Source, SourceOptions } from \"../Source\";\nimport { ToneBufferSource } from \"./ToneBufferSource\";\n\nexport interface PlayerOptions extends SourceOptions {\n\tonload: () => void;\n\tplaybackRate: Positive;\n\tloop: boolean;\n\tautostart: boolean;\n\tloopStart: Time;\n\tloopEnd: Time;\n\treverse: boolean;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\turl?: ToneAudioBuffer | string | AudioBuffer;\n}\n\n/**\n * Player is an audio file player with start, loop, and stop functions.\n * @example\n * var player = new Player(\"./path/to/sample.mp3\").toDestination();\n * //play as soon as the buffer is loaded\n * player.autostart = true;\n * @category Source\n */\nexport class Player extends Source<PlayerOptions> {\n\n\treadonly name: string = \"Player\";\n\n\t/**\n\t * If the file should play as soon\n\t * as the buffer is loaded.\n\t * @example\n\t * //will play as soon as it's loaded\n\t * var player = new Player({\n\t * \t\"url\" : \"./path/to/sample.mp3\",\n\t * \t\"autostart\" : true,\n\t * }).toDestination();\n\t */\n\tautostart: boolean;\n\n\t/**\n\t * The buffer\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * if the buffer should loop once it's over\n\t */\n\tprivate _loop: boolean;\n\n\t/**\n\t * if 'loop' is true, the loop will start at this position\n\t */\n\tprivate _loopStart: Time;\n\n\t/**\n\t * if 'loop' is true, the loop will end at this position\n\t */\n\tprivate _loopEnd: Time;\n\n\t/**\n\t * the playback rate\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * All of the active buffer source nodes\n\t */\n\tprivate _activeSources: Set<ToneBufferSource> = new Set();\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tfadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tfadeOut: Time;\n\n\t/**\n\t * @param url Either the AudioBuffer or the url from which to load the AudioBuffer\n\t * @param onload The function to invoke when the buffer is loaded.\n\t */\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<PlayerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis._buffer = new ToneAudioBuffer({\n\t\t\tonload: this._onload.bind(this, options.onload),\n\t\t\treverse: options.reverse,\n\t\t\turl: options.url,\n\t\t});\n\t\tthis.autostart = options.autostart;\n\t\tthis._loop = options.loop;\n\t\tthis._loopStart = options.loopStart;\n\t\tthis._loopEnd = options.loopEnd;\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.fadeIn = options.fadeIn;\n\t\tthis.fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): PlayerOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tautostart: false,\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tloop: false,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tonload: noOp,\n\t\t\tplaybackRate: 1,\n\t\t\treverse: false,\n\t\t});\n\t}\n\n\t/**\n\t * Load the audio file as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * Note: this does not need to be called if a url\n\t * was passed in to the constructor. Only use this\n\t * if you want to manually load a new url.\n\t * @param url The url of the buffer to load. Filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tawait this._buffer.load(url);\n\t\tthis._onload();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal callback when the buffer is loaded.\n\t */\n\tprivate _onload(callback: () => void = noOp): void {\n\t\tcallback();\n\t\tif (this.autostart) {\n\t\t\tthis.start();\n\t\t}\n\t}\n\n\t/**\n\t * Internal callback when the buffer is done playing.\n\t */\n\tprivate _onSourceEnd(source: ToneBufferSource): void {\n\t\t// invoke the onstop function\n\t\tthis.onstop(this);\n\n\t\t// delete the source from the active sources\n\t\tthis._activeSources.delete(source);\n\t\tif (this._activeSources.size === 0 && !this._synced) {\n\t\t\tthis._state.setStateAtTime(\"stopped\", this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Play the buffer at the given startTime. Optionally add an offset\n\t * and/or duration which will play the buffer from a position\n\t * within the buffer for the given duration.\n\t *\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample\n\t *                                to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length\n\t *                  of the sample (minus any offset)\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tsuper.start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal start method\n\t */\n\tprotected _start(startTime?: Time, offset?: Time, duration?: Time): void {\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this._loop) {\n\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\n\t\t// compute the values in seconds\n\t\tlet comptuedOffset = this.toSeconds(offset);\n\n\t\t// if it's synced, it should factor in the playback rate for computing the offset\n\t\tif (this._synced) {\n\t\t\tcomptuedOffset *= this._playbackRate;\n\t\t}\n\n\t\t// compute the duration which is either the passed in duration of the buffer.duration - offset\n\t\tconst origDuration = duration;\n\t\tduration = defaultArg(duration, Math.max(this._buffer.duration - comptuedOffset, 0));\n\t\tlet computedDuration = this.toSeconds(duration);\n\n\t\t// scale it by the playback rate\n\t\tcomputedDuration = computedDuration / this._playbackRate;\n\n\t\t// get the start time\n\t\tstartTime = this.toSeconds(startTime);\n\n\t\t// make the source\n\t\tconst source = new ToneBufferSource({\n\t\t\tbuffer: this._buffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn: this.fadeIn,\n\t\t\tfadeOut: this.fadeOut,\n\t\t\tloop: this._loop,\n\t\t\tloopEnd: this._loopEnd,\n\t\t\tloopStart: this._loopStart,\n\t\t\tonended: this._onSourceEnd.bind(this),\n\t\t\tplaybackRate: this._playbackRate,\n\t\t}).connect(this.output);\n\n\t\t// set the looping properties\n\t\tif (!this._loop && !this._synced) {\n\t\t\t// if it's not looping, set the state change at the end of the sample\n\t\t\tthis._state.setStateAtTime(\"stopped\", startTime + computedDuration, {\n\t\t\t\timplicitEnd: true,\n\t\t\t});\n\t\t}\n\n\t\t// add it to the array of active sources\n\t\tthis._activeSources.add(source);\n\n\t\t// start it\n\t\tif (this._loop && isUndef(origDuration)) {\n\t\t\tsource.start(startTime, comptuedOffset);\n\t\t} else {\n\t\t\t// subtract the fade out time\n\t\t\tsource.start(startTime, comptuedOffset, computedDuration - this.toSeconds(this.fadeOut));\n\t\t}\n\t}\n\n\t/**\n\t * Stop playback.\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(source => source.stop(computedTime));\n\t}\n\n\t/**\n\t * Stop and then restart the player from the beginning (or offset)\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given,\n\t * \t\t\t\tit will default to the full length of the sample (minus any offset)\n\t */\n\trestart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tthis._stop(time);\n\t\tthis._start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Seek to a specific time in the player's buffer. If the\n\t * source is no longer playing at that time, it will stop.\n\t * If you seek to a time that\n\t * @param {Time} offset The time to seek to.\n\t * @param {Time=} time The time for the seek event to occur.\n\t * @return {Player} this\n\t * @example\n\t * source.start(0.2);\n\t * source.stop(0.4);\n\t */\n\tseek(offset: Time, when?: Time): this {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tconst comptuedOffset = this.toSeconds(offset);\n\t\t\t// if it's currently playing, stop it\n\t\t\tthis._stop(computedTime);\n\t\t\t// restart it at the given time\n\t\t\tthis._start(computedTime, comptuedOffset);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the loop start and end. Will only loop if loop is set to true.\n\t * @param loopStart The loop end time\n\t * @param loopEnd The loop end time\n\t * @example\n\t * //loop 0.1 seconds of the file.\n\t * player.setLoopPoints(0.2, 0.3);\n\t * player.loop = true;\n\t */\n\tsetLoopPoints(loopStart: Time, loopEnd: Time): this {\n\t\tthis.loopStart = loopStart;\n\t\tthis.loopEnd = loopEnd;\n\t\treturn this;\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = loopStart;\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopStart = loopStart;\n\t\t});\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = loopEnd;\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopEnd = loopEnd;\n\t\t});\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\t// if no change, do nothing\n\t\tif (this._loop === loop) {\n\t\t\treturn;\n\t\t}\n\t\tthis._loop = loop;\n\t\t// set the loop of all of the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loop = loop;\n\t\t});\n\t\tif (loop) {\n\t\t\t// remove the next stopEvent\n\t\t\tconst stopEvent = this._state.getNextState(\"stopped\", this.now());\n\t\t\tif (stopEvent) {\n\t\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The playback speed. 1 is normal speed. This is not a signal because\n\t * Safari and iOS currently don't support playbackRate as a signal.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tconst now = this.now();\n\n\t\t// cancel the stop event since it's at a different time now\n\t\tconst stopEvent = this._state.getNextState(\"stopped\", now);\n\t\tif (stopEvent && stopEvent.implicitEnd) {\n\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\tthis._activeSources.forEach(source => source.cancelStop());\n\t\t}\n\n\t\t// set all the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.playbackRate.setValueAtTime(rate, now);\n\t\t});\n\t}\n\n\t/**\n\t * The direction the buffer should play in\n\t */\n\tget reverse(): boolean {\n\t\treturn this._buffer.reverse;\n\t}\n\tset reverse(rev) {\n\t\tthis._buffer.reverse = rev;\n\t}\n\n\t/**\n\t * If the buffer is loaded\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffer.loaded;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\t// disconnect all of the players\n\t\tthis._activeSources.forEach(source => source.dispose());\n\t\tthis._activeSources.clear();\n\t\tthis._buffer.dispose();\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../../component/channel/Volume\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { ToneAudioBuffers, ToneAudioBuffersUrlMap } from \"../../core/context/ToneAudioBuffers\";\nimport { OutputNode, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Decibels, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { BasicPlaybackState } from \"../../core/util/StateTimeline\";\nimport { Source, SourceOptions } from \"../Source\";\nimport { Player } from \"./Player\";\n\nexport interface PlayersOptions extends SourceOptions {\n\turls: ToneAudioBuffersUrlMap;\n\tvolume: Decibels;\n\tmute: boolean;\n\tonload: () => void;\n\tbaseUrl: string;\n\tfadeIn: Time;\n\tfadeOut: Time;\n}\n\n/**\n * Players combines multiple [[Player]] objects.\n * @category Source\n */\nexport class Players extends ToneAudioNode<PlayersOptions> {\n\n\treadonly name: string = \"Players\";\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * source.volume.value = -6;\n\t */\n\treadonly volume: Param<Decibels>;\n\n\t/**\n\t * The combined output of all of the players\n\t */\n\treadonly output: OutputNode;\n\n\t/**\n\t * Players has no input.\n\t */\n\treadonly input = undefined;\n\n\t/**\n\t * The container of all of the players\n\t */\n\tprivate _players: Map<string, Player> = new Map();\n\n\t/**\n\t * The container of all the buffers\n\t */\n\tprivate _buffers: ToneAudioBuffers;\n\n\t/**\n\t * private holder of the fadeIn time\n\t */\n\tprivate _fadeIn: Time;\n\n\t/**\n\t * private holder of the fadeOut time\n\t */\n\tprivate _fadeOut: Time;\n\n\t/**\n\t * @param urls An object mapping a name to a url.\n\t * @param onload The function to invoke when all buffers are loaded.\n\t */\n\tconstructor(urls?: ToneAudioBuffersUrlMap, onload?: () => void);\n\t/**\n\t * @param urls An object mapping a name to a url.\n\t * @param options The remaining options associated with the players\n\t */\n\tconstructor(urls?: ToneAudioBuffersUrlMap, options?: Partial<Omit<PlayersOptions, \"urls\">>);\n\tconstructor(options?: Partial<GainOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Players.getDefaults(), arguments, [\"urls\", \"onload\"], \"urls\"));\n\t\tconst options = optionsFromArguments(Players.getDefaults(), arguments, [\"urls\", \"onload\"], \"urls\");\n\n\t\t/**\n\t\t * The output volume node\n\t\t */\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis._buffers = new ToneAudioBuffers(options.urls, options.onload, options.baseUrl);\n\t\t// mute initially\n\t\tthis.mute = options.mute;\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): PlayersOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tbaseUrl: \"\",\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tmute: false,\n\t\t\tonload: noOp,\n\t\t\turls: {},\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * //mute the output\n\t * source.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t/**\n\t * The fadeIn time of the envelope applied to the source.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(fadeIn) {\n\t\tthis._fadeIn = fadeIn;\n\t\tthis._players.forEach(player => {\n\t\t\tplayer.fadeIn = fadeIn;\n\t\t});\n\t}\n\n\t/**\n\t * The fadeOut time of the each of the sources.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(fadeOut) {\n\t\tthis._fadeOut = fadeOut;\n\t\tthis._players.forEach(player => {\n\t\t\tplayer.fadeOut = fadeOut;\n\t\t});\n\t}\n\n\t/**\n\t * The state of the players object. Returns \"started\" if any of the players are playing.\n\t */\n\tget state(): BasicPlaybackState {\n\t\tconst playing = Array.from(this._players).some(([_, player]) => player.state === \"started\");\n\t\treturn playing ? \"started\" : \"stopped\";\n\t}\n\n\t/**\n\t * True if the buffers object has a buffer by that name.\n\t * @param name  The key or index of the buffer.\n\t */\n\thas(name: string): boolean {\n\t\treturn this._buffers.has(name);\n\t}\n\n\t/**\n\t * Get a player by name.\n\t * @param  name  The players name as defined in the constructor object or `add` method.\n\t */\n\tplayer(name: string): Player {\n\t\tthis.assert(this.has(name), `No Player with the name ${name} exists on this object`);\n\t\tif (!this._players.has(name)) {\n\t\t\tconst player = new Player({\n\t\t\t\tcontext: this.context,\n\t\t\t\tfadeIn: this._fadeIn,\n\t\t\t\tfadeOut: this._fadeOut,\n\t\t\t\turl: this._buffers.get(name),\n\t\t\t}).connect(this.output);\n\t\t\tthis._players.set(name, player);\n\t\t}\n\t\treturn this._players.get(name) as Player;\n\t}\n\n\t/**\n\t * If all the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffers.loaded;\n\t}\n\n\t/**\n\t * Add a player by name and url to the Players\n\t * @param  name A unique name to give the player\n\t * @param  url  Either the url of the bufer or a buffer which will be added with the given name.\n\t * @param callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(name: string, url: string | ToneAudioBuffer | AudioBuffer, callback?: () => void): this {\n\t\tthis.assert(!this._buffers.has(name), \"A buffer with that name already exists on this object\");\n\t\tthis._buffers.add(name, url, callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop all of the players at the given time\n\t * @param time The time to stop all of the players.\n\t */\n\tstopAll(time?: Time): this {\n\t\tthis._players.forEach(player => player.stop(time));\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.volume.dispose();\n\t\tthis._players.forEach(player => player.dispose());\n\t\tthis._buffers.dispose();\n\t\treturn this;\n\t}\n}\n","import { Source, SourceOptions } from \"../Source\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Clock } from \"../../core/clock/Clock\";\nimport { Cents, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { ToneBufferSource } from \"./ToneBufferSource\";\nimport { intervalToFrequencyRatio } from \"../../core/type/Conversions\";\n\ninterface GrainPlayerOptions extends SourceOptions {\n\tonload: () => void;\n\treverse: boolean;\n\turl?: ToneAudioBuffer | string | AudioBuffer;\n\toverlap: Seconds;\n\tgrainSize: Seconds;\n\tplaybackRate: Positive;\n\tdetune: Cents;\n\tloop: boolean;\n\tloopStart: Time;\n\tloopEnd: Time;\n}\n\n/**\n * GrainPlayer implements [granular synthesis](https://en.wikipedia.org/wiki/Granular_synthesis).\n * Granular Synthesis enables you to adjust pitch and playback rate independently. The grainSize is the\n * amount of time each small chunk of audio is played for and the overlap is the\n * amount of crossfading transition time between successive grains.\n * @category Source\n */\nexport class GrainPlayer extends Source<GrainPlayerOptions> {\n\n\treadonly name: string = \"GrainPlayer\";\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tbuffer: ToneAudioBuffer;\n\n\t/**\n\t *  Create a repeating tick to schedule the grains.\n\t */\n\tprivate _clock: Clock;\n\n\t/**\n\t * Internal loopStart value\n\t */\n\tprivate _loopStart: number = 0;\n\n\t/**\n\t * Internal loopStart value\n\t */\n\tprivate _loopEnd: number = 0;\n\n\t/**\n\t * All of the currently playing BufferSources\n\t */\n\tprivate _activeSources: ToneBufferSource[] = [];\n\n\t/**\n\t * Internal reference to the playback rate\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * Internal grain size reference;\n\t */\n\tprivate _grainSize: Seconds; \n\n\t/**\n\t * Internal overlap reference;\n\t */\n\tprivate _overlap: Seconds; \n\n\t/**\n\t * Adjust the pitch independently of the playbackRate.\n\t */\n\tdetune: Cents;\n\n\t/**\n\t * If the buffer should loop back to the loopStart when completed\n\t */\n\tloop: boolean;\n\t\t\n\t/**\n\t * @param url Either the AudioBuffer or the url from which to load the AudioBuffer\n\t * @param onload The function to invoke when the buffer is loaded.\n\t */\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<GrainPlayerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(GrainPlayer.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(GrainPlayer.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis.buffer = new ToneAudioBuffer({\n\t\t\tonload: options.onload,\n\t\t\treverse: options.reverse,\n\t\t\turl: options.url,\n\t\t});\n\t\tthis._clock = new Clock({\n\t\t\tcontext: this.context,\n\t\t\tcallback: this._tick.bind(this), \n\t\t\tfrequency: 1 / options.grainSize\n\t\t});\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._grainSize = options.grainSize;\n\t\tthis._overlap = options.overlap;\n\t\tthis.detune = options.detune;\n\n\t\t// setup\n\t\tthis.overlap = options.overlap;\n\t\tthis.loop = options.loop;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.grainSize = options.grainSize;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.reverse = options.reverse;\n\t\tthis._clock.on(\"stop\", this._onstop.bind(this));\n\t}\n\n\tstatic getDefaults(): GrainPlayerOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tonload: noOp,\n\t\t\toverlap: 0.1,\n\t\t\tgrainSize: 0.2,\n\t\t\tplaybackRate: 1,\n\t\t\tdetune: 0,\n\t\t\tloop: false,\n\t\t\tloopStart: 0,\n\t\t\tloopEnd: 0,\n\t\t\treverse: false\n\t\t});\n\t}\n\n\t/**\n     *  Internal start method\n     */\n\tprotected _start(time?: Time, offset?: Time, duration?: Time): void {\n\t\toffset = defaultArg(offset, 0);\n\t\toffset = this.toSeconds(offset);\n\t\ttime = this.toSeconds(time);\n\n\t\tconst grainSize = 1 / this._clock.frequency.getValueAtTime(time);\n\t\tthis._clock.start(time, offset / grainSize);\n\n\t\tif (duration) {\n\t\t\tthis.stop(time + this.toSeconds(duration));\n\t\t}\n\t}\n\n\t/**\n\t * Stop and then restart the player from the beginning (or offset)\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, \n\t * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n\t */\n\trestart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tthis._stop(time);\n\t\tthis._start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n     *  Internal stop method\n     */\n\tprotected _stop(time?: Time): void {\n\t\tthis._clock.stop(time);\n\t}\n\n\t/**\n     * Invoked when the clock is stopped\n     */\n\tprivate _onstop(time: Seconds): void {\n\t\t// stop the players\n\t\tthis._activeSources.forEach((source) => {\n\t\t\tsource.fadeOut = 0;\n\t\t\tsource.stop(time);\n\t\t});\n\t\tthis.onstop(this);\n\t}\n\n\t/**\n     *  Invoked on each clock tick. scheduled a new grain at this time.\n     */\n\tprivate _tick(time: Seconds): void {\n\t\t// check if it should stop looping\n\t\tconst ticks = this._clock.getTicksAtTime(time);\n\t\tconst grainSize = 1 / this._clock.frequency.getValueAtTime(time);\n\t\tconst offset = ticks * grainSize;\n\t\tthis.log(\"offset\", offset);\n\n\t\tif (!this.loop && offset > this.buffer.duration) {\n\t\t\tthis.stop(time);\n\t\t\treturn;\n\t\t}\n\n\t\t// at the beginning of the file, the fade in should be 0\n\t\tconst fadeIn = offset < this._overlap ? 0 : this._overlap;\n\n\t\t// create a buffer source\n\t\tconst source = new ToneBufferSource({\n\t\t\tcontext: this.context,\n\t\t\tbuffer: this.buffer,\n\t\t\tfadeIn: fadeIn,\n\t\t\tfadeOut: this._overlap,\n\t\t\tloop: this.loop,\n\t\t\tloopStart: this._loopStart,\n\t\t\tloopEnd: this._loopEnd,\n\t\t\t// compute the playbackRate based on the detune\n\t\t\tplaybackRate: intervalToFrequencyRatio(this.detune / 100)\n\t\t}).connect(this.output);\n\n\t\tsource.start(time, this._grainSize * ticks);\n\t\tsource.stop(time + this._grainSize / this.playbackRate);\n\n\t\t// add it to the active sources\n\t\tthis._activeSources.push(source);\n\t\t// remove it when it's done\n\t\tsource.onended = () => {\n\t\t\tconst index = this._activeSources.indexOf(source);\n\t\t\tif (index !== -1) {\n\t\t\t\tthis._activeSources.splice(index, 1);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n     * The playback rate of the sample\n     */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis.grainSize = this._grainSize;\n\t}\n\n\t/**\n     * The loop start time.\n     */\n\tget loopStart(): Time {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(time) {\n\t\tthis._loopStart = this.toSeconds(time);\n\t}\n\n\t/**\n     * The loop end time.\n     */\n\tget loopEnd(): Time {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(time) {\n\t\tthis._loopEnd = this.toSeconds(time);\n\t}\n\n\t/**\n     * The direction the buffer should play in\n     */\n\tget reverse() {\n\t\treturn this.buffer.reverse;\n\t}\n\n\tset reverse(rev) {\n\t\tthis.buffer.reverse = rev;\n\t}\n\n\t/**\n     * The size of each chunk of audio that the\n     * buffer is chopped into and played back at.\n     */\n\tget grainSize(): Time {\n\t\treturn this._grainSize;\n\t}\n\tset grainSize(size) {\n\t\tthis._grainSize = this.toSeconds(size);\n\t\tthis._clock.frequency.setValueAtTime(this._playbackRate / this._grainSize, this.now());\n\t}\n\n\t/**\n     * The duration of the cross-fade between successive grains.\n     */\n\tget overlap(): Time {\n\t\treturn this._overlap;\n\t}\n\tset overlap(time) {\n\t\tthis._overlap = this.toSeconds(time);\n\t}\n\n\t/**\n     * If all the buffer is loaded\n     */\n\tget loaded(): boolean {\n\t\treturn this.buffer.loaded;\n\t}\n\n\tdispose(): this{\n\t\tsuper.dispose();\n\t\tthis.buffer.dispose();\n\t\tthis._clock.dispose();\n\t\tthis._activeSources.forEach((source) => source.dispose());\n\t\treturn this;\n\t}\n}\n","import { connectSeries } from \"../core/Connect\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal, SignalOptions } from \"./Signal\";\n\n/**\n * Add a signal and a number or two signals. When no value is\n * passed into the constructor, Tone.Add will sum input and `addend`\n * If a value is passed into the constructor, the it will be added to the input.\n *\n * @example\n * var signal = new Signal(2);\n * var add = new Add(2);\n * signal.connect(add);\n * //the output of add equals 4\n * @example\n * //if constructed with no arguments\n * //it will add the first and second inputs\n * var add = new Add();\n * var sig0 = new Signal(3).connect(add);\n * var sig1 = new Signal(4).connect(add.addend);\n * //the output of add equals 7.\n * @category Signal\n */\nexport class Add extends Signal {\n\n\toverride = false;\n\n\treadonly name: string = \"Add\";\n\n\t/**\n\t * the summing node\n\t */\n\tprivate _sum: Gain = new Gain({ context: this.context });\n\treadonly input = this._sum;\n\treadonly output = this._sum;\n\n\t/**\n\t * The value which is added to the input signal\n\t */\n\treadonly addend: Param<number> = this._param;\n\n\t/**\n\t * @param value If no value is provided, Tone.Add will sum the first  and second inputs.\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<SignalOptions<number>>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Add.getDefaults(), arguments, [\"value\"])));\n\n\t\tconnectSeries(this._constantSource, this._sum);\n\t}\n\n\tstatic getDefaults(): SignalOptions<number> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sum.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * Return the absolute value of an incoming signal.\n *\n * @example\n * var signal = new Tone.Signal(-1);\n * var abs = new Tone.Abs();\n * signal.connect(abs);\n * //the output of abs is 1.\n * @category Signal\n */\nexport class Abs extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"Abs\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _abs = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: val => {\n\t\t\tif (Math.abs(val) < 0.001) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn Math.abs(val);\n\t\t\t}\n\t\t},\n\t});\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._abs;\n\n\t/**\n\t * The output range [0, 1]\n\t */\n\toutput = this._abs;\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._abs.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * GainToAudio converts an input in NormalRange [0,1] to AudioRange [-1,1].\n * See {@link AudioToGain}.\n *\n * @example\n * var a2g = new GainToAudio();\n * @category Signal\n */\nexport class GainToAudio extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"GainToAudio\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: x => Math.abs(x) * 2 - 1,\n\t});\n\n\t/**\n\t * The NormalRange input [0, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The AudioRange output [-1, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Multiply } from \"./Multiply\";\nimport { SignalOperator } from \"./SignalOperator\";\n\n/**\n * Negate the incoming signal. i.e. an input signal of 10 will output -10\n *\n * @example\n * var neg = new Negate();\n * var sig = new Signal(-2).connect(neg);\n * //output of neg is positive 2.\n * @category Signal\n */\nexport class Negate extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"Negate\";\n\n\t/**\n\t * negation is done by multiplying by -1\n\t */\n\tprivate _multiply: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: -1,\n\t});\n\n\t/**\n\t * The input and output are equal to the multiply node\n\t */\n\tinput = this._multiply;\n\toutput = this._multiply;\n\n\t/**\n\t * clean up\n\t * @returns {Negate} this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._multiply.dispose();\n\t\treturn this;\n\t}\n}\n","import { connectSeries } from \"../core/Connect\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Negate } from \"../signal/Negate\";\nimport { Signal, SignalOptions } from \"../signal/Signal\";\n\n/**\n * Subtract the signal connected to the input is subtracted from the signal connected\n * The subtrahend.\n *\n * @example\n * var sub = new Subtract(1);\n * var sig = new Tone.Signal(4).connect(sub);\n * //the output of sub is 3.\n * @example\n * var sub = new Subtract();\n * var sigA = new Tone.Signal(10);\n * var sigB = new Tone.Signal(2.5);\n * sigA.connect(sub);\n * sigB.connect(sub.subtrahend);\n * //output of sub is 7.5\n * @category Signal\n */\nexport class Subtract extends Signal {\n\n\toverride = false;\n\n\treadonly name: string = \"Subtract\";\n\n\t/**\n\t * the summing node\n\t */\n\tprivate _sum: Gain = new Gain({ context: this.context });\n\treadonly input: Gain = this._sum;\n\treadonly output: Gain = this._sum;\n\n\t/**\n\t * Negate the input of the second input before connecting it to the summing node.\n\t */\n\tprivate _neg: Negate = new Negate({ context: this.context });\n\n\t/**\n\t * The value which is subtracted from the main signal\n\t */\n\tsubtrahend: Param<number> = this._param;\n\n\t/**\n\t * @param value The value to subtract from the incoming signal. If the value\n\t *             is omitted, it will subtract the second signal from the first.\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<SignalOptions<number>>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Subtract.getDefaults(), arguments, [\"value\"])));\n\n\t\tconnectSeries(this._constantSource, this._neg, this._sum);\n\t}\n\n\tstatic getDefaults(): SignalOptions<number> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._neg.dispose();\n\t\tthis._sum.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { connect, disconnect, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { SignalOperator } from \"./SignalOperator\";\n\n/**\n * Tone.Zero outputs 0's at audio-rate. The reason this has to be\n * it's own class is that many browsers optimize out Tone.Signal\n * with a value of 0 and will not process nodes further down the graph.\n * @category Signal\n */\nexport class Zero extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"Zero\";\n\n\t/**\n\t * The gain node which connects the constant source to the output\n\t */\n\tprivate _gain = new Gain({ context: this.context });\n\n\t/**\n\t * Only outputs 0\n\t */\n\toutput = this._gain;\n\n\t/**\n\t * no input node\n\t */\n\tinput = undefined;\n\n\tconstructor(options?: Partial<ToneAudioNodeOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Zero.getDefaults(), arguments)));\n\t\tconnect(this.context.getConstant(0), this._gain);\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tdisconnect(this.context.getConstant(0), this._gain);\n\t\treturn this;\n\t}\n}\n","import { InputNode, OutputNode } from \"../../core/context/ToneAudioNode\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\n\ntype BasicEnvelopeCurve = \"linear\" | \"exponential\";\ntype InternalEnvelopeCurve = BasicEnvelopeCurve | number[];\nexport type EnvelopeCurve = EnvelopeCurveName | number[];\n\nexport interface EnvelopeOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tdecay: Time;\n\tsustain: NormalRange;\n\trelease: Time;\n\tattackCurve: EnvelopeCurve;\n\treleaseCurve: EnvelopeCurve;\n\tdecayCurve: BasicEnvelopeCurve;\n}\n\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n *\n * @example\n * //an amplitude envelope\n * var gainNode = Tone.context.createGain();\n * var env = new Envelope({\n * \t\"attack\" : 0.1,\n * \t\"decay\" : 0.2,\n * \t\"sustain\" : 1,\n * \t\"release\" : 0.8,\n * });\n * env.connect(gainNode.gain);\n * @category Component\n */\nexport class Envelope extends ToneAudioNode<EnvelopeOptions> {\n\n\treadonly name: string = \"Envelope\";\n\n\t/**\n\t * When triggerAttack is called, the attack time is the amount of\n\t * time it takes for the envelope to reach it's maximum value.\n\t * ```\n\t *           /\\\n\t *          /X \\\n\t *         /XX  \\\n\t *        /XXX   \\\n\t *       /XXXX    \\___________\n\t *      /XXXXX                \\\n\t *     /XXXXXX                 \\\n\t *    /XXXXXXX                  \\\n\t *   /XXXXXXXX                   \\\n\t * ```\n\t * @min 0\n\t * @max 2\n\t */\n\tattack: Time;\n\n\t/**\n\t * After the attack portion of the envelope, the value will fall\n\t * over the duration of the decay time to it's sustain value.\n\t * ```\n\t *           /\\\n\t *          / X\\\n\t *         /  XX\\\n\t *        /   XXX\\\n\t *       /    XXXX\\___________\n\t *      /     XXXXX           \\\n\t *     /      XXXXX            \\\n\t *    /       XXXXX             \\\n\t *   /        XXXXX              \\\n\t * ```\n\t * @min 0\n\t * @max 2\n\t */\n\tdecay: Time;\n\n\t/**\n\t * The sustain value is the value\n\t * which the envelope rests at after triggerAttack is\n\t * called, but before triggerRelease is invoked.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /          XXXXXXXXXXX\\\n\t *     /           XXXXXXXXXXX \\\n\t *    /            XXXXXXXXXXX  \\\n\t *   /             XXXXXXXXXXX   \\\n\t * ```\n\t */\n\tsustain: NormalRange;\n\n\t/**\n\t * After triggerRelease is called, the envelope's\n\t * value will fall to it's miminum value over the\n\t * duration of the release time.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /                    X\\\n\t *     /                     XX\\\n\t *    /                      XXX\\\n\t *   /                       XXXX\\\n\t * ```\n\t * @min 0\n\t * @max 5\n\t */\n\trelease: Time;\n\n\t/**\n\t * The automation curve type for the attack\n\t */\n\tprivate _attackCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t * The automation curve type for the decay\n\t */\n\tprivate _decayCurve!: BasicEnvelopeCurve;\n\n\t/**\n\t * The automation curve type for the release\n\t */\n\tprivate _releaseCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t * the signal which is output.\n\t */\n\tprotected _sig: Signal<NormalRange> = new Signal({\n\t\tcontext: this.context,\n\t\tvalue: 0,\n\t});\n\n\t/**\n\t * The output signal of the envelope\n\t */\n\toutput: OutputNode = this._sig;\n\n\t/**\n\t * Envelope has no input\n\t */\n\tinput: InputNode | undefined = undefined;\n\n\t/**\n\t * @param attack The amount of time it takes for the envelope to go from\n\t *                        0 to it's maximum value.\n\t * @param decay\tThe period of time after the attack that it takes for the envelope\n\t *                      \tto fall to the sustain value. Value must be greater than 0.\n\t * @param sustain\tThe percent of the maximum value that the envelope rests at until\n\t *                               \tthe release is triggered.\n\t * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n\t *                        \tValue must be greater than 0.\n\t */\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tconst options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n\n\t\tthis.attack = options.attack;\n\t\tthis.decay = options.decay;\n\t\tthis.sustain = options.sustain;\n\t\tthis.release = options.release;\n\t\tthis.attackCurve = options.attackCurve;\n\t\tthis.releaseCurve = options.releaseCurve;\n\t\tthis.decayCurve = options.decayCurve;\n\t}\n\n\tstatic getDefaults(): EnvelopeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack: 0.01,\n\t\t\tattackCurve: \"linear\" as EnvelopeCurveName,\n\t\t\tdecay: 0.1,\n\t\t\tdecayCurve: \"exponential\" as BasicEnvelopeCurve,\n\t\t\trelease: 1,\n\t\t\treleaseCurve: \"exponential\" as EnvelopeCurveName,\n\t\t\tsustain: 0.5,\n\t\t});\n\t}\n\n\t/**\n\t * Read the current value of the envelope. Useful for\n\t * syncronizing visual output to the envelope.\n\t */\n\tget value(): NormalRange {\n\t\treturn this.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Get the curve\n\t * @param  curve\n\t * @param  direction  In/Out\n\t * @return The curve name\n\t */\n\tprivate _getCurve(curve: InternalEnvelopeCurve, direction: EnvelopeDirection): EnvelopeCurve {\n\t\tif (isString(curve)) {\n\t\t\treturn curve;\n\t\t} else {\n\t\t\t// look up the name in the curves array\n\t\t\tlet curveName: EnvelopeCurveName;\n\t\t\tfor (curveName in EnvelopeCurves) {\n\t\t\t\tif (EnvelopeCurves[curveName][direction] === curve) {\n\t\t\t\t\treturn curveName;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// return the custom curve\n\t\t\treturn curve;\n\t\t}\n\t}\n\n\t/**\n\t * Assign a the curve to the given name using the direction\n\t * @param  name\n\t * @param  direction In/Out\n\t * @param  curve\n\t */\n\tprivate _setCurve(\n\t\tname: \"_attackCurve\" | \"_decayCurve\" | \"_releaseCurve\",\n\t\tdirection: EnvelopeDirection,\n\t\tcurve: EnvelopeCurve,\n\t): void {\n\t\t// check if it's a valid type\n\t\tif (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n\t\t\tconst curveDef = EnvelopeCurves[curve];\n\t\t\tif (isObject(curveDef)) {\n\t\t\t\tif (name !== \"_decayCurve\") {\n\t\t\t\t\tthis[name] = curveDef[direction];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis[name] = curveDef;\n\t\t\t}\n\t\t} else if (isArray(curve) && name !== \"_decayCurve\") {\n\t\t\tthis[name] = curve;\n\t\t} else {\n\t\t\tthrow new Error(\"Envelope: invalid curve: \" + curve);\n\t\t}\n\t}\n\n\t/**\n\t * The shape of the attack.\n\t * Can be any of these strings:\n\t * * \"linear\"\n\t * * \"exponential\"\n\t * * \"sine\"\n\t * * \"cosine\"\n\t * * \"bounce\"\n\t * * \"ripple\"\n\t * * \"step\"\n\t *\n\t * Can also be an array which describes the curve. Values\n\t * in the array are evenly subdivided and linearly\n\t * interpolated over the duration of the attack.\n\t * @example\n\t * env.attackCurve = \"linear\";\n\t * @example\n\t * //can also be an array\n\t * env.attackCurve = [0, 0.2, 0.3, 0.4, 1]\n\t */\n\tget attackCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._attackCurve, \"In\");\n\t}\n\tset attackCurve(curve) {\n\t\tthis._setCurve(\"_attackCurve\", \"In\", curve);\n\t}\n\n\t/**\n\t * The shape of the release. See the attack curve types.\n\t * @example\n\t * env.releaseCurve = \"linear\";\n\t */\n\tget releaseCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._releaseCurve, \"Out\");\n\t}\n\tset releaseCurve(curve) {\n\t\tthis._setCurve(\"_releaseCurve\", \"Out\", curve);\n\t}\n\n\t/**\n\t * The shape of the decay either \"linear\" or \"exponential\"\n\t * @example\n\t * env.decayCurve = \"linear\";\n\t */\n\tget decayCurve(): BasicEnvelopeCurve {\n\t\treturn this._decayCurve;\n\t}\n\tset decayCurve(curve) {\n\t\tthis.assert([\"linear\", \"exponential\"].some(c => c === curve), `Invalid envelope curve: ${curve}`);\n\t\tthis._decayCurve = curve;\n\t}\n\n\t/**\n\t * Trigger the attack/decay portion of the ADSR envelope.\n\t * @param  time When the attack should start.\n\t * @param velocity The velocity of the envelope scales the vales.\n\t *                             number between 0-1\n\t * @example\n\t * //trigger the attack 0.5 seconds from now with a velocity of 0.2\n\t * env.triggerAttack(\"+0.5\", 0.2);\n\t */\n\ttriggerAttack(time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", time, velocity);\n\t\ttime = this.toSeconds(time);\n\t\tconst originalAttack = this.toSeconds(this.attack);\n\t\tlet attack = originalAttack;\n\t\tconst decay = this.toSeconds(this.decay);\n\t\t// check if it's not a complete attack\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\t// subtract the current value from the attack time\n\t\t\tconst attackRate = 1 / attack;\n\t\t\tconst remainingDistance = 1 - currentValue;\n\t\t\t// the attack is now the remaining time\n\t\t\tattack = remainingDistance / attackRate;\n\t\t}\n\t\t// attack\n\t\tif (attack === 0) {\n\t\t\t// case where the attack time is 0 should set instantly\n\t\t\tthis._sig.setValueAtTime(velocity, time);\n\t\t} else if (this._attackCurve === \"linear\") {\n\t\t\tthis._sig.linearRampTo(velocity, attack, time);\n\t\t} else if (this._attackCurve === \"exponential\") {\n\t\t\tthis._sig.targetRampTo(velocity, attack, time);\n\t\t} else {\n\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\tlet curve = this._attackCurve;\n\t\t\t// find the starting position in the curve\n\t\t\tfor (let i = 1; i < curve.length; i++) {\n\t\t\t\t// the starting index is between the two values\n\t\t\t\tif (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n\t\t\t\t\tcurve = this._attackCurve.slice(i);\n\t\t\t\t\t// the first index is the current value\n\t\t\t\t\tcurve[0] = currentValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._sig.setValueCurveAtTime(curve, time, attack, velocity);\n\t\t}\n\t\t// decay\n\t\tif (decay) {\n\t\t\tconst decayValue = velocity * this.sustain;\n\t\t\tconst decayStart = time + attack;\n\t\t\tthis.log(\"decay\", decayStart);\n\t\t\tif (this._decayCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampTo(decayValue, decay, decayStart + this.sampleTime);\n\t\t\t} else {\n\t\t\t\tthis.assert(this._decayCurve === \"exponential\",\n\t\t\t\t\t`decayCurve can only be \"linear\" or \"exponential\", got ${this._decayCurve}`);\n\t\t\t\tthis._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Triggers the release of the envelope.\n\t * @param  time When the release portion of the envelope should start.\n\t * @example\n\t * //trigger release immediately\n\t * env.triggerRelease();\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\ttime = this.toSeconds(time);\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\tconst release = this.toSeconds(this.release);\n\t\t\tif (this._releaseCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampTo(0, release, time);\n\t\t\t} else if (this._releaseCurve === \"exponential\") {\n\t\t\t\tthis._sig.targetRampTo(0, release, time);\n\t\t\t} else {\n\t\t\t\tthis.assert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n\t\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\t\tthis._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the scheduled value at the given time. This will\n\t * return the unconverted (raw) value.\n\t */\n\tgetValueAtTime(time: Time): NormalRange {\n\t\treturn this._sig.getValueAtTime(time);\n\t}\n\n\t/**\n\t * triggerAttackRelease is shorthand for triggerAttack, then waiting\n\t * some duration, then triggerRelease.\n\t * @param duration The duration of the sustain.\n\t * @param time When the attack should be triggered.\n\t * @param velocity The velocity of the envelope.\n\t * @example\n\t * //trigger the attack and then the release after 0.6 seconds.\n\t * env.triggerAttackRelease(0.6);\n\t */\n\ttriggerAttackRelease(duration: Time, time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis.triggerAttack(time, velocity);\n\t\tthis.triggerRelease(time + this.toSeconds(duration));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancels all scheduled envelope changes after the given time.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._sig.cancelScheduledValues(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the envelope to a destination node.\n\t */\n\tconnect(destination: InputNode, outputNumber: number = 0, inputNumber: number = 0): this {\n\t\tconnectSignal(this, destination, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sig.dispose();\n\t\treturn this;\n\t}\n}\n\ninterface EnvelopeCurveObject {\n\tIn: number[];\n\tOut: number[];\n}\n\ntype EnvelopeDirection = keyof EnvelopeCurveObject;\n\ninterface EnvelopeCurveMap {\n\tlinear: \"linear\";\n\texponential: \"exponential\";\n\tbounce: EnvelopeCurveObject;\n\tcosine: EnvelopeCurveObject;\n\tsine: EnvelopeCurveObject;\n\tripple: EnvelopeCurveObject;\n\tstep: EnvelopeCurveObject;\n}\n\ntype EnvelopeCurveName = keyof EnvelopeCurveMap;\n\n/**\n * Generate some complex envelope curves.\n */\nconst EnvelopeCurves: EnvelopeCurveMap = (() => {\n\n\tconst curveLen = 128;\n\n\tlet i: number;\n\tlet k: number;\n\n\t// cosine curve\n\tconst cosineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tcosineCurve[i] = Math.sin((i / (curveLen - 1)) * (Math.PI / 2));\n\t}\n\n\t// ripple curve\n\tconst rippleCurve: number[] = [];\n\tconst rippleCurveFreq = 6.4;\n\tfor (i = 0; i < curveLen - 1; i++) {\n\t\tk = (i / (curveLen - 1));\n\t\tconst sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n\t\trippleCurve[i] = sineWave / 10 + k * 0.83;\n\t}\n\trippleCurve[curveLen - 1] = 1;\n\n\t// stairs curve\n\tconst stairsCurve: number[] = [];\n\tconst steps = 5;\n\tfor (i = 0; i < curveLen; i++) {\n\t\tstairsCurve[i] = Math.ceil((i / (curveLen - 1)) * steps) / steps;\n\t}\n\n\t// in-out easing curve\n\tconst sineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tsineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n\t}\n\n\t// a bounce curve\n\tconst bounceCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tconst freq = Math.pow(k, 3) * 4 + 0.2;\n\t\tconst val = Math.cos(freq * Math.PI * 2 * k);\n\t\tbounceCurve[i] = Math.abs(val * (1 - k));\n\t}\n\n\t/**\n\t * Invert a value curve to make it work for the release\n\t */\n\tfunction invertCurve(curve: number[]): number[] {\n\t\tconst out = new Array(curve.length);\n\t\tfor (let j = 0; j < curve.length; j++) {\n\t\t\tout[j] = 1 - curve[j];\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * reverse the curve\n\t */\n\tfunction reverseCurve(curve: number[]): number[] {\n\t\treturn curve.slice(0).reverse();\n\t}\n\n\t/**\n\t * attack and release curve arrays\n\t */\n\treturn {\n\t\tbounce: {\n\t\t\tIn: invertCurve(bounceCurve),\n\t\t\tOut: bounceCurve,\n\t\t},\n\t\tcosine: {\n\t\t\tIn: cosineCurve,\n\t\t\tOut: reverseCurve(cosineCurve),\n\t\t},\n\t\texponential: \"exponential\" as \"exponential\",\n\t\tlinear: \"linear\" as \"linear\",\n\t\tripple: {\n\t\t\tIn: rippleCurve,\n\t\t\tOut: invertCurve(rippleCurve),\n\t\t},\n\t\tsine: {\n\t\t\tIn: sineCurve,\n\t\t\tOut: invertCurve(sineCurve),\n\t\t},\n\t\tstep: {\n\t\t\tIn: stairsCurve,\n\t\t\tOut: invertCurve(stairsCurve),\n\t\t},\n\t};\n})();\n","import { Gain } from \"../../core/context/Gain\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Envelope, EnvelopeOptions } from \"./Envelope\";\n\n/**\n * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.\n * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts\n * an audio signal as the input and will apply the envelope to the amplitude\n * of the signal.\n * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n *\n * @example\n * var ampEnv = new AmplitudeEnvelope({\n * \t\"attack\": 0.1,\n * \t\"decay\": 0.2,\n * \t\"sustain\": 1.0,\n * \t\"release\": 0.8\n * }).toDestination();\n * //create an oscillator and connect it\n * var osc = new Tone.Oscillator().connect(ampEnv).start();\n * //trigger the envelopes attack and release \"8t\" apart\n * ampEnv.triggerAttackRelease(\"8t\");\n * @category Component\n */\nexport class AmplitudeEnvelope extends Envelope {\n\n\treadonly name: string = \"AmplitudeEnvelope\";\n\n\tprivate _gainNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\toutput: Gain = this._gainNode;\n\tinput: Gain = this._gainNode;\n\n\t/**\n\t * @param attack The amount of time it takes for the envelope to go from 0 to it's maximum value.\n\t * @param decay\tThe period of time after the attack that it takes for the envelope\n\t *                      \tto fall to the sustain value. Value must be greater than 0.\n\t * @param sustain\tThe percent of the maximum value that the envelope rests at until\n\t *                               \tthe release is triggered.\n\t * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n\t *                        \tValue must be greater than 0.\n\t */\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tthis._sig.connect(this._gainNode.gain);\n\t\tthis.output = this._gainNode;\n\t\tthis.input = this._gainNode;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.dispose();\n\t\treturn this;\n\t}\n}\n","import { Volume } from \"../component/channel/Volume\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels, Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface InstrumentOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n}\n\n/**\n * Base-class for all instruments\n */\nexport abstract class Instrument<Options extends InstrumentOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t * The output and volume triming node\n\t */\n\tprivate _volume: Volume;\n\toutput: OutputNode;\n\n\t/**\n\t * The instrument only has an output\n\t */\n\tinput: undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * source.volume.value = -6;\n\t */\n\tvolume: Param<Decibels>;\n\n\t/**\n\t * Keep track of all events scheduled to the transport\n\t * when the instrument is 'synced'\n\t */\n\tprivate _scheduledEvents: number[] = [];\n\n\t/**\n\t * If the instrument is currently synced\n\t */\n\tprivate _synced: boolean = false;\n\n\tconstructor(options?: Partial<InstrumentOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Instrument.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Instrument.getDefaults(), arguments);\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t}\n\n\tstatic getDefaults(): InstrumentOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Sync the instrument to the Transport. All subsequent calls of\n\t * [[triggerAttack]] and [[triggerRelease]]\n\t * will be scheduled along the transport.\n\t * @example\n\t * instrument.sync()\n\t * //schedule 3 notes when the transport first starts\n\t * instrument.triggerAttackRelease('C4', '8n', 0)\n\t * instrument.triggerAttackRelease('E4', '8n', '8n')\n\t * instrument.triggerAttackRelease('G4', '8n', '4n')\n\t * //start the transport to hear the notes\n\t * Transport.start()\n\t * @returns {Instrument} this\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 0);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Wrap the given method so that it can be synchronized\n\t * @param method Which method to wrap and sync\n\t * @param  timePosition What position the time argument appears in\n\t */\n\tprotected _syncMethod(method: string, timePosition: number): void {\n\t\tconst originalMethod = this[\"_original_\" + method] = this[method];\n\t\tthis[method] = (...args: any[]) => {\n\t\t\tconst time = args[timePosition];\n\t\t\tconst id = this.context.transport.schedule((t) => {\n\t\t\t\targs[timePosition] = t;\n\t\t\t\toriginalMethod.apply(this, args);\n\t\t\t}, time);\n\t\t\tthis._scheduledEvents.push(id);\n\t\t};\n\t}\n\n\t/**\n\t * Unsync the instrument from the Transport\n\t */\n\tunsync(): this {\n\t\tthis._scheduledEvents.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduledEvents = [];\n\t\tif (this._synced) {\n\t\t\tthis._synced = false;\n\t\t\tthis.triggerAttack = this._original_triggerAttack;\n\t\t\tthis.triggerRelease = this._original_triggerRelease;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and then the release after the duration.\n\t * @param  note     The note to trigger.\n\t * @param  duration How long the note should be held for before\n\t *                         triggering the release. This value must be greater than 0.\n\t * @param time  When the note should be triggered.\n\t * @param  velocity The velocity the note should be triggered at.\n\t * @example\n\t * //trigger \"C4\" for the duration of an 8th note\n\t * synth.triggerAttackRelease(\"C4\", \"8n\");\n\t */\n\ttriggerAttackRelease(note: Frequency, duration: Time, time?: Time, velocity?: NormalRange): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tthis.triggerAttack(note, computedTime, velocity);\n\t\tthis.triggerRelease(computedTime + computedDuration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the instrument's note.\n\t * @param note the note to trigger\n\t * @param time the time to trigger the ntoe\n\t * @param velocity the velocity to trigger the note (betwee 0-1)\n\t */\n\tabstract triggerAttack(note: Frequency, time?: Time, velocity?: NormalRange): this;\n\tprivate _original_triggerAttack = this.triggerAttack;\n\n\t/**\n\t * Trigger the release phase of the current note.\n\t * @param time when to trigger the release\n\t */\n\tabstract triggerRelease(...args: any[]): this;\n\tprivate _original_triggerRelease = this.triggerRelease;\n\n\t/**\n\t * clean up\n\t * @returns {Instrument} this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.unsync();\n\t\tthis._scheduledEvents = [];\n\t\treturn this;\n\t}\n}\n","import { Envelope } from \"../component/envelope/Envelope\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { Cents, Frequency, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { Signal } from \"../signal/Signal\";\n\ntype onSilenceCallback = (instrument: Monophonic<any>) => void;\n\nexport interface MonophonicOptions extends InstrumentOptions {\n\tportamento: Seconds;\n\tonsilence: onSilenceCallback;\n\tdetune: Cents;\n}\n\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport abstract class Monophonic<Options extends MonophonicOptions> extends Instrument<Options> {\n\n\t/**\n\t * The glide time between notes.\n\t */\n\tportamento: Seconds;\n\n\t/**\n\t * Invoked when the release has finished and the output is silent.\n\t */\n\tonsilence: onSilenceCallback;\n\n\t/**\n\t * The instrument's envelope\n\t */\n\tabstract envelope: Envelope;\n\n\t/**\n\t * The instrument's frequency signal.\n\t */\n\tabstract readonly frequency: Signal<Frequency>;\n\n\t/**\n\t * The instrument's detune control signal.\n\t */\n\tabstract readonly detune: Signal<Cents>;\n\n\tconstructor(options?: Partial<MonophonicOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Monophonic.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n\n\t\tthis.portamento = options.portamento;\n\t\tthis.onsilence = options.onsilence;\n\t}\n\n\tstatic getDefaults(): MonophonicOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tonsilence: noOp,\n\t\t\tportamento: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack of the note optionally with a given velocity.\n\t * @param  note The note to trigger.\n\t * @param  time When the note should start.\n\t * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n\t * @example\n\t * synth.triggerAttack(\"C4\");\n\t * @example\n\t * //trigger the note a half second from now at half velocity\n\t * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n\t */\n\ttriggerAttack(note: Frequency | FrequencyClass, time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", note, time, velocity);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeAttack(seconds, velocity);\n\t\tthis.setNote(note, seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release portion of the envelope\n\t * @param  time If no time is given, the release happens immediatly\n\t * @example\n\t * synth.triggerRelease();\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeRelease(seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal method which starts the envelope attack\n\t */\n\tprotected abstract _triggerEnvelopeAttack(time: Seconds, velocity: NormalRange): void;\n\n\t/**\n\t * Internal method which starts the envelope release\n\t */\n\tprotected abstract _triggerEnvelopeRelease(time: Seconds): void;\n\n\t/**\n\t * Get the level of the output at the given time. Measures\n\t * the envelope(s) value at the time.\n\t * @param time The time to query the envelope value\n\t * @return The output level between 0-1\n\t */\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Set the note at the given time. If no time is given, the note\n\t * will set immediately.\n\t * @param note The note to change to.\n\t * @param  time The time when the note should be set.\n\t * @example\n\t * //change to F#6 in one quarter note from now.\n\t * synth.setNote(\"F#6\", \"+4n\");\n\t * @example\n\t * //change to Bb4 right now\n\t * synth.setNote(\"Bb4\");\n\t */\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n\t\tif (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n\t\t\tconst portTime = this.toSeconds(this.portamento);\n\t\t\tthis.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n\t\t} else {\n\t\t\tthis.frequency.setValueAtTime(computedFrequency, computedTime);\n\t\t}\n\t\treturn this;\n\t}\n}\n","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Cents, Frequency, Seconds } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\nimport { Source } from \"../source/Source\";\nimport { Monophonic, MonophonicOptions } from \"./Monophonic\";\n\nexport interface SynthOptions extends MonophonicOptions {\n\toscillator: OmniOscillatorSynthOptions;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Synth is composed simply of a {@link OmniOscillator} routed through an {@link AmplitudeEnvelope}.\n * ```\n * +----------------+   +-------------------+\n * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output\n * +----------------+   +-------------------+\n * ```\n * @example\n * var synth = new Synth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport class Synth<Options extends SynthOptions = SynthOptions> extends Monophonic<Options> {\n\n\treadonly name: string = \"Synth\";\n\n\t/**\n\t * The oscillator.\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The frequency signal\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t * The detune signal\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t * The envelope\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\t/**\n\t * @param options the options available for the synth.\n\t */\n\tconstructor(options?: RecursivePartial<SynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Synth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Synth.getDefaults(), arguments);\n\n\t\tthis.oscillator = new OmniOscillator(Object.assign({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tonstop: () => this.onsilence(this),\n\t\t}, options.oscillator));\n\n\t\tthis.frequency = this.oscillator.frequency;\n\t\tthis.detune = this.oscillator.detune;\n\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.envelope));\n\n\t\t// connect the oscillators to the output\n\t\tthis.oscillator.chain(this.envelope, this.output);\n\t\treadOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): SynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.005,\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\trelease: 1,\n\t\t\t\t\tsustain: 0.3,\n\t\t\t\t},\n\t\t\t),\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"triangle\",\n\t\t\t\t},\n\t\t\t),\n\t\t});\n\t}\n\n\t/**\n\t * start the attack portion of the envelope\n\t * @param time the time the attack should start\n\t * @param velocity the velocity of the note (0-1)\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// the envelopes\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis.oscillator.start(time);\n\t\t// if there is no release portion, stop the oscillator\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tconst computedAttack = this.toSeconds(this.envelope.attack);\n\t\t\tconst computedDecay = this.toSeconds(this.envelope.decay);\n\t\t\tthis.oscillator.stop(time + computedAttack + computedDecay);\n\t\t}\n\t}\n\n\t/**\n\t * start the release portion of the envelope\n\t * @param time the time the release should start\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): void {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.oscillator.stop(time + this.toSeconds(this.envelope.release));\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.oscillator.dispose();\n\t\tthis.envelope.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { Frequency, Interval, MidiNote, NormalRange, Note, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { ToneBufferSource, ToneBufferSourceCurve } from \"../source/buffer/ToneBufferSource\";\n\ninterface SamplesMap {\n\t[note: string]: ToneAudioBuffer | AudioBuffer | string;\n\t[midi: number]: ToneAudioBuffer | AudioBuffer | string;\n}\n\nexport interface SamplerOptions extends InstrumentOptions {\n\tattack: Time;\n\trelease: Time;\n\tonload: () => void;\n\tbaseUrl: string;\n\tcurve: ToneBufferSourceCurve;\n\turls: SamplesMap;\n}\n\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * var sampler = new Sampler({\n * \t\"C3\" : \"path/to/C3.mp3\",\n * \t\"D#3\" : \"path/to/Dsharp3.mp3\",\n * \t\"F#3\" : \"path/to/Fsharp3.mp3\",\n * \t\"A3\" : \"path/to/A3.mp3\",\n * }, function(){\n * \t//sampler will repitch the closest sample\n * \tsampler.triggerAttack(\"D3\")\n * })\n * @category Instrument\n */\nexport class Sampler extends Instrument<SamplerOptions> {\n\n\treadonly name: string = \"Sampler\";\n\n\t/**\n\t * The stored and loaded buffers\n\t */\n\tprivate _buffers: ToneAudioBuffers;\n\n\t/**\n\t * The object of all currently playing BufferSources\n\t */\n\tprivate _activeSources: Map<MidiNote, ToneBufferSource[]> = new Map();\n\n\t/**\n\t * The envelope applied to the beginning of the sample.\n\t * @min 0\n\t * @max 1\n\t */\n\tattack: Time;\n\t\n\t/**\n\t * The envelope applied to the end of the envelope.\n\t * @min 0\n\t * @max 1\n\t */\n\trelease: Time;\n\n\t/**\n\t * The shape of the attack/release curve.\n\t * Either \"linear\" or \"exponential\"\n\t */\n\tcurve: ToneBufferSourceCurve;\n\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param onload The callback to invoke when all of the samples are loaded.\n\t * @param baseUrl The root URL of all of the samples, which is prepended to all the URLs.\n\t */\n\tconstructor(samples?: SamplesMap, onload?: () => void, baseUrl?: string);\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param options The remaining options associated with the sampler\n\t */\n\tconstructor(samples?: SamplesMap, options?: Partial<Omit<SamplerOptions, \"urls\">>);\n\tconstructor(options?: Partial<SamplerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n\t\tconst options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n\n\t\tconst urlMap = {};\n\t\tObject.keys(options.urls).forEach((note) => {\n\t\t\tconst noteNumber = parseInt(note, 10);\n\t\t\tthis.assert(isNote(note)\n\t\t\t\t|| (isNumber(noteNumber) && isFinite(noteNumber)), `url key is neither a note or midi pitch: ${note}`);\n\t\t\tif (isNote(note)) {\n\t\t\t\t// convert the note name to MIDI\n\t\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\t\turlMap[mid] = options.urls[note];\n\t\t\t} else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n\t\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\t\turlMap[noteNumber] = options.urls[noteNumber];\n\t\t\t}\n\t\t});\n\n\t\tthis._buffers = new ToneAudioBuffers(urlMap, options.onload, options.baseUrl);\n\t\tthis.attack = options.attack;\n\t\tthis.release = options.release;\n\t\tthis.curve = options.curve;\n\n\t\t// invoke the callback if it's already loaded\n\t\tif (this._buffers.loaded) {\n\t\t\t// invoke onload deferred\n\t\t\tPromise.resolve().then(options.onload);\n\t\t}\n\t}\n\n\tstatic getDefaults(): SamplerOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tattack: 0,\n\t\t\tbaseUrl: \"\",\n\t\t\tcurve: \"exponential\" as \"exponential\",\n\t\t\tonload: noOp,\n\t\t\trelease: 0.1,\n\t\t\turls: {},\n\t\t});\n\t}\n\n\t/**\n\t * Returns the difference in steps between the given midi note at the closets sample.\n\t */\n\tprivate _findClosest(midi: MidiNote): Interval {\n\t\t// searches within 8 octaves of the given midi note\n\t\tconst MAX_INTERVAL = 96;\n\t\tlet interval = 0;\n\t\twhile (interval < MAX_INTERVAL) {\n\t\t\t// check above and below\n\t\t\tif (this._buffers.has(midi + interval)) {\n\t\t\t\treturn -interval;\n\t\t\t} else if (this._buffers.has(midi - interval)) {\n\t\t\t\treturn interval;\n\t\t\t}\n\t\t\tinterval++;\n\t\t}\n\t\tthrow new Error(`No available buffers for note: ${midi}`);\n\t}\n\n\t/**\n\t * @param  notes\tThe note to play, or an array of notes.\n\t * @param  time     When to play the note\n\t * @param  velocity The velocity to play the sample back.\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", notes, time, velocity);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midi = new FrequencyClass(this.context, note).toMidi();\n\t\t\t// find the closest note pitch\n\t\t\tconst difference = this._findClosest(midi);\n\t\t\tconst closestNote = midi - difference;\n\t\t\tconst buffer = this._buffers.get(closestNote);\n\t\t\tconst playbackRate = intervalToFrequencyRatio(difference);\n\t\t\t// play that note\n\t\t\tconst source = new ToneBufferSource({\n\t\t\t\tbuffer,\n\t\t\t\tcontext: this.context,\n\t\t\t\tcurve: this.curve,\n\t\t\t\tfadeIn: this.attack,\n\t\t\t\tfadeOut: this.release,\n\t\t\t\tplaybackRate,\n\t\t\t}).connect(this.output);\n\t\t\tsource.start(time, 0, buffer.duration / playbackRate, velocity);\n\t\t\t// add it to the active sources\n\t\t\tif (!isArray(this._activeSources.get(midi))) {\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t\t(this._activeSources.get(midi) as ToneBufferSource[]).push(source);\n\n\t\t\t// remove it when it's done\n\t\t\tsource.onended = () => {\n\t\t\t\tif (this._activeSources && this._activeSources.has(midi)) {\n\t\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\t\tconst index = sources.indexOf(source);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tsources.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param  notes\tThe note to release, or an array of notes.\n\t * @param  time     \tWhen to release the note.\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tthis.log(\"triggerRelease\", notes, time);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midi = new FrequencyClass(this.context, note).toMidi();\n\t\t\t// find the note\n\t\t\tif (this._activeSources.has(midi) && (this._activeSources.get(midi) as ToneBufferSource[]).length) {\n\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\ttime = this.toSeconds(time);\n\t\t\t\tsources.forEach(source => {\n\t\t\t\t\tsource.stop(time);\n\t\t\t\t});\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Release all currently active notes.\n\t * @param  time     \tWhen to release the notes.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(sources => {\n\t\t\twhile (sources.length) {\n\t\t\t\tconst source = sources.shift() as ToneBufferSource;\n\t\t\t\tsource.stop(computedTime);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the instrument to the Transport. All subsequent calls of\n\t * [[triggerAttack]] and [[triggerRelease]]\n\t * will be scheduled along the transport.\n\t * @example\n\t * synth.sync()\n\t * //schedule 3 notes when the transport first starts\n\t * synth.triggerAttackRelease('8n', 0)\n\t * synth.triggerAttackRelease('8n', '8n')\n\t * synth.triggerAttackRelease('8n', '4n')\n\t * //start the transport to hear the notes\n\t * Transport.start()\n\t * @returns {Tone.Instrument} this\n\t */\n\tsync(): this {\n\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the attack phase, then after the duration, invoke the release.\n\t * @param  notes\tThe note to play and release, or an array of notes.\n\t * @param  duration The time the note should be held\n\t * @param  time     When to start the attack\n\t * @param  velocity The velocity of the attack\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency[] | Frequency,\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tthis.assert(isArray(notes), \"notes must be an array when duration is array\");\n\t\t\t(notes as Frequency[]).forEach((note, index) => {\n\t\t\t\tconst d = duration[Math.min(index, duration.length - 1)];\n\t\t\t\tthis.triggerRelease(note, computedTime + this.toSeconds(d));\n\t\t\t});\n\t\t} else {\n\t\t\tthis.triggerRelease(notes, computedTime + this.toSeconds(duration));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a note to the sampler.\n\t * @param  note      The buffer's pitch.\n\t * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(note: Note | MidiNote, url: string | ToneAudioBuffer | AudioBuffer, callback?: () => void): this {\n\t\tthis.assert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n\t\tif (isNote(note)) {\n\t\t\t// convert the note name to MIDI\n\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\tthis._buffers.add(mid, url, callback);\n\t\t} else {\n\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\tthis._buffers.add(note, url, callback);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffers.loaded;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.dispose();\n\t\tthis._activeSources.forEach(sources => {\n\t\t\tsources.forEach(source => source.dispose());\n\t\t});\n\t\tthis._activeSources.clear();\n\t\treturn this;\n\t}\n}\n","import { MidiClass } from \"../core/type/Midi\";\nimport { Frequency, MidiNote, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\nimport { MembraneSynth, MembraneSynthOptions } from \"./MembraneSynth\";\nimport { FMSynth, FMSynthOptions } from \"./FMSynth\";\nimport { MetalSynth, MetalSynthOptions } from \"./MetalSynth\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth, SynthOptions } from \"./Synth\";\nimport { warn } from \"../core/util/Debug\";\n\ntype VoiceConstructor<V> = {\n\tgetDefaults: () => VoiceOptions<V>;\n} & (new (...args: any[]) => V);\n\ntype OmitMonophonicOptions<T> = Omit<T, \"context\" | \"onsilence\">;\n\ntype VoiceOptions<T> =\n\tT extends MembraneSynth ? MembraneSynthOptions :\n\t\tT extends MetalSynth ? MetalSynthOptions :\n\t\t\tT extends FMSynth ? FMSynthOptions :\n\t\t\t\tT extends Synth ? SynthOptions :\n\t\t\t\t\tnever;\n\n/**\n * The settable synth options. excludes monophonic options.\n */\ntype PartialVoiceOptions<T> = RecursivePartial<OmitMonophonicOptions<VoiceOptions<T>>>;\n\nexport interface PolySynthOptions<Voice> extends InstrumentOptions {\n\tmaxPolyphony: number;\n\tvoice: VoiceConstructor<Voice>;\n\toptions: PartialVoiceOptions<Voice>;\n}\n\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * var synth = new PolySynth(Tone.Synth, {\n *   oscillator : {\n * \t\ttype : \"square\"\n * \t}\n * }).toMaster();\n * //set the attributes using the set interface\n * synth.set(\"detune\", -1200);\n * //play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], \"4n\");\n * @category Instrument\n */\nexport class PolySynth<Voice extends Monophonic<any> = Synth> extends Instrument<VoiceOptions<Voice>> {\n\n\treadonly name: string = \"PolySynth\";\n\n\t/**\n\t * The voices which are not currently in use\n\t */\n\tprivate _availableVoices: Voice[] = [];\n\n\t/**\n\t * The currently active voices\n\t */\n\tprivate _activeVoices: Array<{midi: MidiNote; voice: Voice}> = [];\n\n\t/**\n\t * All of the allocated voices for this synth.\n\t */\n\tprivate _voices: Voice[] = [];\n\n\t/**\n\t * The options that are set on the synth.\n\t */\n\tprivate options: VoiceOptions<Voice>;\n\n\t/**\n\t * The polyphony limit.\n\t */\n\tmaxPolyphony: number;\n\n\t/**\n\t * The voice constructor\n\t */\n\tprivate readonly voice: VoiceConstructor<Voice>;\n\n\t/**\n\t * The GC timeout. Held so that it could be cancelled when the node is disposed.\n\t */\n\tprivate _gcTimeout: number = -1;\n\n\t/**\n\t * A moving average of the number of active voices\n\t */\n\tprivate _averageActiveVoices: number = 0;\n\n\t/**\n\t * @param voice The constructor of the voices\n\t * @param options\tThe options object to set the synth voice\n\t */\n\tconstructor(\n\t\tvoice?: VoiceConstructor<Voice>,\n\t\toptions?: PartialVoiceOptions<Voice>,\n\t);\n\tconstructor(options?: Partial<PolySynthOptions<Voice>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n\t\tconst options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]);\n\n\t\t// check against the old API (pre 14.3.0)\n\t\tthis.assert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n\n\t\tconst defaults = options.voice.getDefaults();\n\t\tthis.options = Object.assign(defaults, options.options) as VoiceOptions<Voice>;\n\t\tthis.voice = options.voice as unknown as VoiceConstructor<Voice>;\n\t\tthis.maxPolyphony = options.maxPolyphony;\n\n\t\t// kick off the GC interval\n\t\tthis._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);\n\t}\n\n\tstatic getDefaults(): PolySynthOptions<Synth> {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tmaxPolyphony: 32,\n\t\t\toptions: {},\n\t\t\tvoice: Synth,\n\t\t});\n\t}\n\n\t/**\n\t * The number of active voices.\n\t */\n\tget activeVoices(): number {\n\t\treturn this._activeVoices.length;\n\t}\n\n\t/**\n\t * If there is a voice active on that note, return it\n\t */\n\tprivate _getActiveVoice(note: MidiNote): Voice | undefined {\n\t\tconst event = this._activeVoices.find(({ midi }) => midi === note);\n\t\tif (event) {\n\t\t\treturn event.voice;\n\t\t}\n\t}\n\n\t/**\n\t * Invoked when the source is done making sound, so that it can be\n\t * readded to the pool of available voices\n\t */\n\tprivate _makeVoiceAvailable(voice: Voice): void {\n\t\tthis._availableVoices.push(voice);\n\t\t// remove the midi note from 'active voices'\n\t\tconst activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);\n\t\tthis._activeVoices.splice(activeVoiceIndex, 1);\n\t}\n\n\t/**\n\t * Get an available voice from the pool of available voices.\n\t * If one is not available and the maxPolyphony limit is reached,\n\t * steal a voice, otherwise return null.\n\t */\n\tprivate _getNextAvailableVoice(): Voice | undefined {\n\t\t// if there are available voices, return the first one\n\t\tif (this._availableVoices.length) {\n\t\t\treturn this._availableVoices.shift();\n\t\t} else if (this._voices.length < this.maxPolyphony) {\n\t\t\t// otherwise if there is still more maxPolyphony, make a new voice\n\t\t\tconst voice = new this.voice(Object.assign(this.options, {\n\t\t\t\tcontext: this.context,\n\t\t\t\tonsilence: this._makeVoiceAvailable.bind(this),\n\t\t\t}));\n\t\t\tvoice.connect(this.output);\n\t\t\tthis._voices.push(voice);\n\t\t\treturn voice;\n\t\t} else {\n\t\t\twarn(\"Max polyphony exceeded. Note dropped.\");\n\t\t}\n\t}\n\n\t/**\n\t * Occasionally check if there are any allocated voices which can be cleaned up.\n\t */\n\tprivate _collectGarbage(): void {\n\t\tthis._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n\t\tif (this._availableVoices.length && this._voices.length > this._averageActiveVoices) {\n\t\t\t// take off an available note\n\t\t\tconst firstAvail = this._availableVoices.shift() as Voice;\n\t\t\tconst index = this._voices.indexOf(firstAvail);\n\t\t\tthis._voices.splice(index, 1);\n\t\t\tif (!this.context.isOffline) {\n\t\t\t\tfirstAvail.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Internal method which triggers the attack\n\t */\n\tprivate _triggerAttack(notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\t// let voice: Voice | undefined;\n\t\t\t// if there's already a note at that voice, reuse it\n\t\t\tlet voice = this._getActiveVoice(midiNote);\n\t\t\t// if it has a note, and that note is still active\n\t\t\tif (voice && voice.getLevelAtTime(time) > 0) {\n\t\t\t\tconst activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);\n\t\t\t\tthis._activeVoices.splice(activeVoiceIndex, 1);\n\t\t\t} else {\n\t\t\t\t// otherwise get the next available voice\n\t\t\t\tvoice = this._getNextAvailableVoice();\n\t\t\t}\n\t\t\tif (voice) {\n\t\t\t\tvoice.triggerAttack(note, time, velocity);\n\t\t\t\tthis._activeVoices.unshift({\n\t\t\t\t\tmidi: midiNote, voice,\n\t\t\t\t});\n\t\t\t\tthis.log(\"triggerAttack\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Internal method which triggers the release\n\t */\n\tprivate _triggerRelease(notes: Frequency[], time: Seconds): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst voice = this._getActiveVoice(midiNote);\n\t\t\tif (voice) {\n\t\t\t\t// trigger release on that note\n\t\t\t\tvoice.triggerRelease(time);\n\t\t\t\tthis.log(\"triggerRelease\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n\t * to wait for just-in-time scheduling\n\t */\n\tprivate _scheduleEvent(type: \"attack\" | \"release\", notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tthis.assert(!this.disposed, \"Synth was already disposed\");\n\t\t// if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\t\tif (time <= this.now()) {\n\t\t\t// do it immediately\n\t\t\tif (type === \"attack\") {\n\t\t\t\tthis._triggerAttack(notes, time, velocity);\n\t\t\t} else {\n\t\t\t\tthis._triggerRelease(notes, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// schedule it to start in the future\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tthis._scheduleEvent(type, notes, time, velocity);\n\t\t\t}, time - this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  The start time of the note.\n\t * @param velocity The velocity of the note.\n\t * @example\n\t * //trigger a chord immediately with a velocity of 0.2\n\t * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"], undefined, 0.2);\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity?: NormalRange): this {\n\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release of the note. Unlike monophonic instruments,\n\t * a note (or array of notes) needs to be passed in as the first argument.\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  When the release will be triggered.\n\t * @example\n\t * poly.triggerRelease([\"Ab3\", \"C4\", \"F5\"], \"+2n\");\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"release\", notes, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and release after the specified duration\n\t * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n\t * @param  duration the duration of the note\n\t * @param  time  if no time is given, defaults to now\n\t * @param  velocity the velocity of the attack (0-1)\n\t * @example\n\t * //trigger a chord for a duration of a half note\n\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"C5\"], \"2n\");\n\t * @example\n\t * //can pass in an array of durations as well\n\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"C5\"], [\"2n\", \"4n\", \"4n\"]);\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency | Frequency[],\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity?: NormalRange,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tthis.assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n\t\t\tnotes = notes as Frequency[];\n\t\t\tfor (let i = 0; i < notes.length; i++) {\n\t\t\t\tconst d = duration[Math.min(i, duration.length - 1)];\n\t\t\t\tconst durationSeconds = this.toSeconds(d);\n\t\t\t\tthis.assert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\t\tthis.triggerRelease(notes[i], computedTime + durationSeconds);\n\t\t\t}\n\t\t} else {\n\t\t\tconst durationSeconds = this.toSeconds(duration);\n\t\t\tthis.assert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\tthis.triggerRelease(notes, computedTime + durationSeconds);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the instrument to the Transport. All subsequent calls of\n\t * {@link triggerAttack} and {@link triggerRelease} will be scheduled along the transport.\n\t * @example\n\t * synth.sync()\n\t * //schedule 3 notes when the transport first starts\n\t * synth.triggerAttackRelease('8n', 0)\n\t * synth.triggerAttackRelease('8n', '8n')\n\t * synth.triggerAttackRelease('8n', '4n')\n\t * //start the transport to hear the notes\n\t * Transport.start()\n\t */\n\tsync(): this {\n\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a member/attribute of the voices\n\t * @example\n\t * poly.set({\n\t * \t\"filter\" : {\n\t * \t\t\"type\" : \"highpass\"\n\t * \t},\n\t * \t\"envelope\" : {\n\t * \t\t\"attack\" : 0.25\n\t * \t}\n\t * });\n\t */\n\tset(options: RecursivePartial<VoiceOptions<Voice>>): this {\n\t\tthis.options = deepMerge(this.options, options);\n\t\tthis._voices.forEach(voice => voice.set(this.options));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the synth's attributes.\n\t */\n\tget(): VoiceOptions<Voice> {\n\t\t// return a clone of the options\n\t\treturn Object.assign({}, this.options);\n\t}\n\n\t/**\n\t * Trigger the release portion of all the currently active voices immediately.\n\t * Useful for silencing the synth.\n\t */\n\treleaseAll(): this {\n\t\tconst now = this.now();\n\t\tthis._activeVoices.forEach(({ voice }) => {\n\t\t\tvoice.triggerRelease(now);\n\t\t});\n\t\tthis._activeVoices = [];\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._voices.forEach(v => v.dispose());\n\t\tthis._activeVoices = [];\n\t\tthis._availableVoices = [];\n\t\tthis.context.clearInterval(this._gcTimeout);\n\t\treturn this;\n\t}\n}\n","import { FrequencyClass } from \"../core/type/Frequency\";\nimport { Frequency, Positive, Time } from \"../core/type/Units\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth, SynthOptions } from \"./Synth\";\n\nexport interface MembraneSynthOptions extends SynthOptions {\n\tpitchDecay: Time;\n\toctaves: Positive;\n}\n\n/**\n * MembraneSynth makes kick and tom sounds using a single oscillator\n * with an amplitude envelope and frequency ramp. A Tone.OmniOscillator\n * is routed through a Tone.AmplitudeEnvelope to the output. The drum\n * quality of the sound comes from the frequency envelope applied\n * during MembraneSynth.triggerAttack(note). The frequency envelope\n * starts at <code>note * .octaves</code> and ramps to <code>note</code>\n * over the duration of <code>.pitchDecay</code>.\n * @example\n * var synth = new MembraneSynth().toMaster();\n * synth.triggerAttackRelease(\"C2\", \"8n\");\n * @category Instrument\n */\nexport class MembraneSynth extends Synth<MembraneSynthOptions> {\n\n\treadonly name: string = \"MembraneSynth\";\n\n\t/**\n\t * The number of octaves the pitch envelope ramps.\n\t * @min 0.5\n\t * @max 8\n\t */\n\toctaves: Positive;\n\n\t/**\n\t * The amount of time the frequency envelope takes.\n\t * @min 0\n\t * @max 0.5\n\t */\n\tpitchDecay: Time;\n\n\t/**\n\t * Portamento is ignored in this synth. use pitch decay instead.\n\t */\n\treadonly portamento = 0;\n\n\t/**\n\t * @param options the options available for the synth see defaults\n\t */\n\tconstructor(options?: RecursivePartial<MembraneSynthOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(MembraneSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(MembraneSynth.getDefaults(), arguments);\n\n\t\tthis.pitchDecay = options.pitchDecay;\n\t\tthis.octaves = options.octaves;\n\t\treadOnly(this, [\"oscillator\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): MembraneSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {\n\t\t\tenvelope: {\n\t\t\t\tattack: 0.001,\n\t\t\t\tattackCurve: \"exponential\",\n\t\t\t\tdecay: 0.4,\n\t\t\t\trelease: 1.4,\n\t\t\t\tsustain: 0.01,\n\t\t\t},\n\t\t\toctaves: 10,\n\t\t\toscillator: {\n\t\t\t\ttype: \"sine\",\n\t\t\t},\n\t\t\tpitchDecay: 0.05,\n\t\t});\n\t}\n\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst seconds = this.toSeconds(time);\n\t\tconst hertz = this.toFrequency(note instanceof FrequencyClass ? note.toFrequency() : note);\n\t\tconst maxNote = hertz * this.octaves;\n\t\tthis.oscillator.frequency.setValueAtTime(maxNote, seconds);\n\t\tthis.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Cents, Decibels, Frequency, GainFactor, Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { isNumber } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\n\nexport type FilterRollOff = -12 | -24 | -48 | -96;\n\nexport interface FilterOptions extends ToneAudioNodeOptions {\n\ttype: BiquadFilterType;\n\tfrequency: Frequency;\n\trolloff: FilterRollOff;\n\tQ: Positive;\n\tdetune: Cents;\n\tgain: GainFactor;\n}\n\n/**\n * Tone.Filter is a filter which allows for all of the same native methods\n * as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface).\n * Tone.Filter has the added ability to set the filter rolloff at -12\n * (default), -24 and -48.\n * @example\n * var filter = new Filter(200, \"highpass\");\n * @category Component\n */\nexport class Filter extends ToneAudioNode<FilterOptions> {\n\n\treadonly name: string = \"Filter\";\n\n\treadonly input = new Gain({ context: this.context });\n\treadonly output = new Gain({ context: this.context });\n\tprivate _filters: BiquadFilterNode[] = [];\n\n\t/**\n\t * the rolloff value of the filter\n\t */\n\tprivate _rolloff!: FilterRollOff;\n\tprivate _type: BiquadFilterType;\n\n\t/**\n\t * The Q or Quality of the filter\n\t */\n\treadonly Q: Signal<Positive>;\n\n\t/**\n\t * The cutoff frequency of the filter.\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t * The detune parameter\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t * The gain of the filter, only used in certain filter types\n\t */\n\treadonly gain: Signal<Decibels>;\n\n\t/**\n\t * @param frequency The cutoff frequency of the filter.\n\t * @param type The type of filter.\n\t * @param rolloff The drop in decibels per octave after the cutoff frequency\n\t */\n\tconstructor(frequency?: Frequency, type?: BiquadFilterType, rolloff?: FilterRollOff);\n\tconstructor(options?: Partial<FilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Filter.getDefaults(), arguments, [\"frequency\", \"type\", \"rolloff\"]));\n\t\tconst options = optionsFromArguments(Filter.getDefaults(), arguments, [\"frequency\", \"type\", \"rolloff\"]);\n\n\t\tthis._filters = [];\n\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.Q,\n\t\t});\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\tthis.gain = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"decibels\",\n\t\t\tvalue: options.gain,\n\t\t});\n\t\tthis._type = options.type;\n\t\tthis.rolloff = options.rolloff;\n\t\treadOnly(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): FilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\tdetune: 0,\n\t\t\tfrequency: 350,\n\t\t\tgain: 0,\n\t\t\trolloff: -12 as FilterRollOff,\n\t\t\ttype: \"lowpass\" as BiquadFilterType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the filter. Types: \"lowpass\", \"highpass\",\n\t * \"bandpass\", \"lowshelf\", \"highshelf\", \"notch\", \"allpass\", or \"peaking\".\n\t */\n\tget type(): BiquadFilterType {\n\t\treturn this._type;\n\t}\n\tset type(type: BiquadFilterType) {\n\t\tconst types: BiquadFilterType[] = [\"lowpass\", \"highpass\", \"bandpass\",\n\t\t\t\"lowshelf\", \"highshelf\", \"notch\", \"allpass\", \"peaking\"];\n\t\tthis.assert(types.indexOf(type) !== -1, `Invalid filter type: ${type}`);\n\t\tthis._type = type;\n\t\tthis._filters.forEach(filter => filter.type = type);\n\t}\n\n\t/**\n\t * The rolloff of the filter which is the drop in db\n\t * per octave. Implemented internally by cascading filters.\n\t * Only accepts the values -12, -24, -48 and -96.\n\t */\n\tget rolloff(): FilterRollOff {\n\t\treturn this._rolloff;\n\t}\n\tset rolloff(rolloff) {\n\t\tconst rolloffNum = isNumber(rolloff) ? rolloff : parseInt(rolloff, 10) as FilterRollOff;\n\t\tconst possibilities = [-12, -24, -48, -96];\n\t\tlet cascadingCount = possibilities.indexOf(rolloffNum);\n\t\t// check the rolloff is valid\n\t\tthis.assert(cascadingCount !== -1, `rolloff can only be ${possibilities.join(\", \")}`);\n\t\tcascadingCount += 1;\n\n\t\tthis._rolloff = rolloffNum;\n\t\tthis.input.disconnect();\n\t\tthis._filters.forEach(filter => filter.disconnect());\n\n\t\tthis._filters = new Array(cascadingCount);\n\t\tfor (let count = 0; count < cascadingCount; count++) {\n\t\t\tconst filter = this.context.createBiquadFilter();\n\t\t\tfilter.type = this._type;\n\t\t\tthis.frequency.connect(filter.frequency);\n\t\t\tthis.detune.connect(filter.detune);\n\t\t\tthis.Q.connect(filter.Q);\n\t\t\tthis.gain.connect(filter.gain);\n\t\t\tthis._filters[count] = filter;\n\t\t}\n\t\tthis._internalChannels = this._filters;\n\t\tconnectSeries(this.input, ...this._internalChannels, this.output);\n\t}\n\n\t/**\n\t * Get the frequency response curve. This curve represents how the filter\n\t * responses to frequencies between 20hz-20khz.\n\t * @param  len The number of values to return\n\t * @return The frequency response curve between 20-20kHz\n\t */\n\tgetFrequencyResponse(len: number = 128): Float32Array {\n\t\t// start with all 1s\n\t\tconst totalResponse = new Float32Array(len).map(() => 1);\n\t\tconst freqValues = new Float32Array(len);\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst norm = Math.pow(i / len, 2);\n\t\t\tconst freq = norm * (20000 - 20) + 20;\n\t\t\tfreqValues[i] = freq;\n\t\t}\n\t\tconst magValues = new Float32Array(len);\n\t\tconst phaseValues = new Float32Array(len);\n\t\tthis._filters.forEach(() => {\n\t\t\tconst filterClone = this.context.createBiquadFilter();\n\t\t\tfilterClone.type = this._type;\n\t\t\tfilterClone.Q.value = this.Q.value;\n\t\t\tfilterClone.frequency.value = this.frequency.value as number;\n\t\t\tfilterClone.gain.value = this.gain.value as number;\n\t\t\tfilterClone.getFrequencyResponse(freqValues, magValues, phaseValues);\n\t\t\tmagValues.forEach((val, i) => {\n\t\t\t\ttotalResponse[i] *= val;\n\t\t\t});\n\t\t});\n\t\treturn totalResponse;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._filters.forEach(filter => {\n\t\t\tfilter.disconnect();\n\t\t});\n\t\twritable(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n\t\tthis.frequency.dispose();\n\t\tthis.Q.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Add } from \"./Add\";\nimport { Multiply } from \"./Multiply\";\nimport { Signal } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n\nexport interface ScaleOptions extends ToneAudioNodeOptions {\n\tmin: number;\n\tmax: number;\n}\n\n/**\n * Performs a linear scaling on an input signal.\n * Scales a NormalRange input to between\n * outputMin and outputMax.\n *\n * @example\n * var scale = new Scale(50, 100);\n * var signal = new Signal(0.5).connect(scale);\n * //the output of scale equals 75\n * @category Signal\n */\nexport class Scale extends SignalOperator<ScaleOptions> {\n\n\treadonly name: string = \"Scale\";\n\n\treadonly input = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: 1,\n\t});\n\n\treadonly output = new Add({\n\t\tcontext: this.context,\n\t\tvalue: 0,\n\t});\n\n\tprivate _outputMin: number;\n\tprivate _outputMax: number;\n\n\t/**\n\t * @param min The output value when the input is 0.\n\t * @param max The output value when the input is 1.\n\t */\n\tconstructor(min?: number, max?: number);\n\tconstructor(options?: Partial<ScaleOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Scale.getDefaults(), arguments, [\"min\", \"max\"])));\n\n\t\tconst options = optionsFromArguments(Scale.getDefaults(), arguments, [\"min\", \"max\"]);\n\t\tthis._outputMin = options.min;\n\t\tthis._outputMax = options.max;\n\n\t\tthis.input.connect(this.output);\n\t\tthis._setRange();\n\t}\n\n\tstatic getDefaults(): ScaleOptions {\n\t\treturn Object.assign(SignalOperator.getDefaults(), {\n\t\t\tmax: 1,\n\t\t\tmin: 0,\n\t\t});\n\t}\n\n\t/**\n\t * The minimum output value. This number is output when the value input value is 0.\n\t */\n\tget min(): number {\n\t\treturn this._outputMin;\n\t}\n\tset min(min) {\n\t\tthis._outputMin = min;\n\t\tthis._setRange();\n\t}\n\n\t/**\n\t * The maximum output value. This number is output when  the value input value is 1.\n\t */\n\tget max(): number {\n\t\treturn this._outputMax;\n\t}\n\tset max(max) {\n\t\tthis._outputMax = max;\n\t\tthis._setRange();\n\t}\n\n\t/**\n\t * set the values\n\t */\n\tprivate _setRange(): void {\n\t\tthis.output.value = this._outputMin;\n\t\tthis.input.value = this._outputMax - this._outputMin;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\treturn this;\n\t}\n}\n","import { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { Filter } from \"../component/filter/Filter\";\nimport { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Cents, Frequency, NormalRange, Positive, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp, RecursivePartial } from \"../core/util/Interface\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Scale } from \"../signal/Scale\";\nimport { Signal } from \"../signal/Signal\";\nimport { FMOscillator } from \"../source/oscillator/FMOscillator\";\nimport { Monophonic, MonophonicOptions } from \"./Monophonic\";\n\nexport interface MetalSynthOptions extends MonophonicOptions {\n\tharmonicity: Positive;\n\tmodulationIndex: Positive;\n\toctaves: number;\n\tresonance: Frequency;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Inharmonic ratio of frequencies based on the Roland TR-808\n * Taken from https://ccrma.stanford.edu/papers/tr-808-cymbal-physically-informed-circuit-bendable-digital-model\n */\nconst inharmRatios: number[] = [1.0, 1.483, 1.932, 2.546, 2.630, 3.897];\n\n/**\n * A highly inharmonic and spectrally complex source with a highpass filter\n * and amplitude envelope which is good for making metallophone sounds.\n * Based on CymbalSynth by [@polyrhythmatic](https://github.com/polyrhythmatic).\n * Inspiration from [Sound on Sound](https://shorturl.at/rSZ12).\n * @category Instrument\n */\nexport class MetalSynth extends Monophonic<MetalSynthOptions> {\n\n\treadonly name: string = \"MetalSynth\";\n\n\t/**\n\t * The frequency of the cymbal\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t * The detune applied to the oscillators\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t * The array of FMOscillators\n\t */\n\tprivate _oscillators: FMOscillator[] = [];\n\n\t/**\n\t * The frequency multipliers\n\t */\n\tprivate _freqMultipliers: Multiply[] = [];\n\n\t/**\n\t * The gain node for the envelope.\n\t */\n\tprivate _amplitude: Gain;\n\n\t/**\n\t * Highpass the output\n\t */\n\tprivate _highpass: Filter;\n\n\t/**\n\t * The number of octaves the highpass\n\t * filter frequency ramps\n\t */\n\tprivate _octaves: number;\n\n\t/**\n\t * Scale the body envelope for the highpass filter\n\t */\n\tprivate _filterFreqScaler: Scale;\n\n\t/**\n\t * The envelope which is connected both to the\n\t * amplitude and a highpass filter's cutoff frequency.\n\t * The lower-limit of the filter is controlled by the [[resonance]]\n\t */\n\treadonly envelope: Envelope;\n\n\tconstructor(options?: RecursivePartial<MetalSynthOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MetalSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(MetalSynth.getDefaults(), arguments);\n\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t});\n\n\t\tthis._amplitude = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: 0,\n\t\t}).connect(this.output);\n\n\t\tthis._highpass = new Filter({\n\t\t\tQ: -3.0102999566398125,\n\t\t\tcontext: this.context,\n\t\t\ttype: \"highpass\",\n\t\t}).connect(this._amplitude);\n\n\t\tfor (let i = 0; i < inharmRatios.length; i++) {\n\t\t\tconst osc = new FMOscillator({\n\t\t\t\tcontext: this.context,\n\t\t\t\tharmonicity: options.harmonicity,\n\t\t\t\tmodulationIndex: options.modulationIndex,\n\t\t\t\tmodulationType: \"square\",\n\t\t\t\tonstop: i === 0 ? () => this.onsilence(this) : noOp,\n\t\t\t\ttype: \"square\",\n\t\t\t});\n\t\t\tosc.connect(this._highpass);\n\t\t\tthis._oscillators[i] = osc;\n\n\t\t\tconst mult = new Multiply({\n\t\t\t\tcontext: this.context,\n\t\t\t\tvalue: inharmRatios[i],\n\t\t\t});\n\t\t\tthis._freqMultipliers[i] = mult;\n\t\t\tthis.frequency.chain(mult, osc.frequency);\n\t\t\tthis.detune.connect(osc.detune);\n\t\t}\n\n\t\tthis._filterFreqScaler = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmax: 7000,\n\t\t\tmin: this.toFrequency(options.resonance),\n\t\t});\n\n\t\tthis.envelope = new Envelope({\n\t\t\tattack: options.envelope.attack,\n\t\t\tattackCurve: \"linear\",\n\t\t\tcontext: this.context,\n\t\t\tdecay: options.envelope.decay,\n\t\t\trelease: options.envelope.release,\n\t\t\tsustain: 0,\n\t\t});\n\n\t\tthis.envelope.chain(this._filterFreqScaler, this._highpass.frequency);\n\t\tthis.envelope.connect(this._amplitude.gain);\n\t\t// set the octaves\n\t\tthis._octaves = options.octaves;\n\t\tthis.octaves = options.octaves;\n\t}\n\n\tstatic getDefaults(): MetalSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.001,\n\t\t\t\t\tdecay: 1.4,\n\t\t\t\t\trelease: 0.2,\n\t\t\t\t},\n\t\t\t),\n\t\t\tharmonicity: 5.1,\n\t\t\tmodulationIndex: 32,\n\t\t\toctaves: 1.5,\n\t\t\tresonance: 4000,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack.\n\t * @param time When the attack should be triggered.\n\t * @param velocity The velocity that the envelope should be triggered at.\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: NormalRange = 1): this {\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis._oscillators.forEach(osc => osc.start(time));\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tthis._oscillators.forEach(osc => {\n\t\t\t\tosc.stop(time + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Trigger the release of the envelope.\n\t * @param time When the release should be triggered.\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): this {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis._oscillators.forEach(osc => osc.stop(time + this.toSeconds(this.envelope.release)));\n\t\treturn this;\n\t}\n\n\t/**\n\t * The modulationIndex of the oscillators which make up the source.\n\t * see [[FMOscillator.modulationIndex]]\n\t * @min 1\n\t * @max 100\n\t */\n\tget modulationIndex(): number {\n\t\treturn this._oscillators[0].modulationIndex.value;\n\t}\n\tset modulationIndex(val) {\n\t\tthis._oscillators.forEach(osc => (osc.modulationIndex.value = val));\n\t}\n\n\t/**\n\t * The harmonicity of the oscillators which make up the source.\n\t * see Tone.FMOscillator.harmonicity\n\t * @min 0.1\n\t * @max 10\n\t */\n\tget harmonicity(): number {\n\t\treturn this._oscillators[0].harmonicity.value;\n\t}\n\tset harmonicity(val) {\n\t\tthis._oscillators.forEach(osc => (osc.harmonicity.value = val));\n\t}\n\n\t/**\n\t * The lower level of the highpass filter which is attached to the envelope.\n\t * This value should be between [0, 7000]\n\t * @min 0\n\t * @max 7000\n\t */\n\tget resonance(): Frequency {\n\t\treturn this._filterFreqScaler.min;\n\t}\n\tset resonance(val) {\n\t\tthis._filterFreqScaler.min = this.toFrequency(val);\n\t\tthis.octaves = this._octaves;\n\t}\n\n\t/**\n\t * The number of octaves above the \"resonance\" frequency\n\t * that the filter ramps during the attack/decay envelope\n\t * @min 0\n\t * @max 8\n\t */\n\tget octaves(): number {\n\t\treturn this._octaves;\n\t}\n\tset octaves(val) {\n\t\tthis._octaves = val;\n\t\tthis._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, val);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._oscillators.forEach(osc => osc.dispose());\n\t\tthis._freqMultipliers.forEach(freqMult => freqMult.dispose());\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._filterFreqScaler.dispose();\n\t\tthis._amplitude.dispose();\n\t\tthis.envelope.dispose();\n\t\tthis._highpass.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\nexport type ToneAudioWorkletOptions = ToneAudioNodeOptions;\n\nexport abstract class ToneAudioWorklet<Options extends ToneAudioWorkletOptions> extends ToneAudioNode<Options> {\n\n\treadonly name: string = \"ToneAudioWorklet\";\n\n\t/**\n\t * The processing node\n\t */\n\tprotected _worklet!: AudioWorkletNode;\n\n\t/**\n\t * The constructor options for the node\n\t */\n\tprotected workletOptions: Partial<AudioWorkletNodeOptions> = {};\n\n\t/**\n\t * The code which is run in the worklet\n\t */\n\tprotected abstract _audioWorklet(): string;\n\n\t/**\n\t * Get the name of the audio worklet\n\t */\n\tprotected abstract _audioWorkletName(): string;\n\t\n\t/**\n\t * Invoked when the module is loaded and the node is created\n\t */\n\tprotected abstract onReady(node: AudioWorkletNode): void;\n\t\n\tconstructor(options: Options) {\n\t\tsuper(options);\n\n\t\tconst blobUrl = URL.createObjectURL(new Blob([this._audioWorklet()], { type: \"text/javascript\" }));\n\t\tconst name = this._audioWorkletName();\n\n\t\t// Register the processor\n\t\tthis.context.addAudioWorkletModule(blobUrl, name).then(() => {\n\t\t\t// create the worklet when it's read\n\t\t\tif (!this.disposed) {\n\t\t\t\tthis._worklet = this.context.createAudioWorkletNode(name, this.workletOptions);\n\t\t\t\tthis._worklet.onprocessorerror = e => {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tthrow e.error;\n\t\t\t\t};\n\t\t\t\tthis.onReady(this._worklet);\n\t\t\t}\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._worklet) {\n\t\t\tthis._worklet.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { connectSeries, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../../core/util/Interface\";\nimport { ToneAudioWorklet } from \"../../core/context/ToneAudioWorklet\";\n\nexport interface FeedbackCombFilterOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tresonance: NormalRange;\n}\n\n/**\n * Comb filters are basic building blocks for physical modeling. Read more\n * about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).\n * \n * This comb filter is implemented with the AudioWorkletNode which allows it to have feedback delays less than the \n * Web Audio processing block of 128 samples. There is a polyfill for browsers that don't yet support the \n * AudioWorkletNode, but it will add some latency and have slower performance than the AudioWorkletNode. \n * @category Component\n */\nexport class FeedbackCombFilter extends ToneAudioWorklet<FeedbackCombFilterOptions> {\n\t\n\treadonly name = \"FeedbackCombFilter\";\n\t\n\t/**\n\t * The amount of delay of the comb filter.\n\t */\n\treadonly delayTime: Param<Time>;\n\t\n\t/**\n\t * The amount of feedback of the delayed signal.\n\t */\n\treadonly resonance: Param<NormalRange>;\n\t\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * Default constructor options for the filter\n\t */\n\tprotected workletOptions: Partial<AudioWorkletNodeOptions> = {\n\t\tnumberOfInputs: 1,\n\t\tnumberOfOutputs: 1,\n\t}\n\t\n\t/**\n\t * @param delayTime The delay time of the filter.\n\t * @param resonance The amount of feedback the filter has.\n\t */\n\tconstructor(delayTime?: Time, resonance?: NormalRange);\n\tconstructor(options?: RecursivePartial<FeedbackCombFilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(FeedbackCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\"]));\n\t\tconst options = optionsFromArguments(FeedbackCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\"]);\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\n\t\tconst dummyGain = this.context.createGain();\n\n\t\tthis.delayTime = new Param<Time>({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.delayTime,\n\t\t\tunits: \"time\",\n\t\t\tminValue: 0,\n\t\t\tmaxValue: 1,\n\t\t\tparam: dummyGain.gain,\n\t\t\tswappable: true,\n\t\t});\n\t\t\n\t\tthis.resonance = new Param<NormalRange>({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.resonance,\n\t\t\tunits: \"normalRange\",\n\t\t\tparam: dummyGain.gain,\n\t\t\tswappable: true,\n\t\t});\n\n\t\treadOnly(this, [\"resonance\", \"delayTime\"]);\n\t}\n\n\tprotected _audioWorkletName(): string {\n\t\treturn \"feedback-comb-filter\";\n\t}\n\n\tprotected _audioWorklet(): string {\n\t\treturn /* javascript */` \n\t\t\tregisterProcessor(\"${this._audioWorkletName()}\", class extends AudioWorkletProcessor {\n\t\t\t\tstatic get parameterDescriptors() {\n\t\t\t\t\treturn [{\n\t\t\t\t\t\tname: \"delayTime\",\n\t\t\t\t\t\tdefaultValue: 0.1,\n\t\t\t\t\t\tminValue: 0,\n\t\t\t\t\t\tmaxValue: 1,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"feedback\",\n\t\t\t\t\t\tdefaultValue: 0.5,\n\t\t\t\t\t\tminValue: 0,\n\t\t\t\t\t\tmaxValue: 0.9999,\n\t\t\t\t\t}];\n\t\t\t\t}\n\t\t\t\n\t\t\t\tconstructor(options) {\n\t\t\t\t\tsuper(options);\n\t\t\t\t\tthis.delayBuffer = new Float32Array(sampleRate);\n\t\t\t\t\tthis.currentFrame = 0\n\t\t\t\t}\n\t\t\t\n\t\t\t\tgetParameter(name, index, parameters) {\n\t\t\t\t\tif (parameters[name].length > 1) {\n\t\t\t\t\t\treturn parameters[name][index];\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn parameters[name][0];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\tprocess(inputs, outputs, parameters) {\n\t\t\t\t\tconst input = inputs[0];\n\t\t\t\t\tconst output = outputs[0];\n\t\t\t\t\tthis.currentFrame += 128\n\t\t\t\t\tif (input && output) {\n\t\t\t\t\t\tconst delayLength = this.delayBuffer.length;\n\t\t\t\t\t\tinput.forEach((inputChannel, channelNum) => {\n\t\t\t\t\t\t\tinputChannel.forEach((value, index) => {\n\t\t\t\t\t\t\t\tconst delayTime = this.getParameter(\"delayTime\", index, parameters);\n\t\t\t\t\t\t\t\tconst feedback = this.getParameter(\"feedback\", index, parameters);\n\t\t\t\t\t\t\t\tconst delaySamples = Math.floor(delayTime * sampleRate);\n\t\t\t\t\t\t\t\tconst currentIndex = (this.currentFrame + index) % delayLength;\n\t\t\t\t\t\t\t\tconst delayedIndex = (this.currentFrame + index + delaySamples) % delayLength;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// the current value to output\n\t\t\t\t\t\t\t\tconst currentValue = this.delayBuffer[currentIndex];\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// write the current value to the delayBuffer in the future\n\t\t\t\t\t\t\t\tthis.delayBuffer[delayedIndex] = value + currentValue * feedback;\n\t\t\t\n\t\t\t\t\t\t\t\t// set all of the output channels to the same value\n\t\t\t\t\t\t\t\toutput[channelNum][index] = delaySamples > 0 ? currentValue : value;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t`;\n\t}\n\n\t/**\n\t * The default parameters\n\t */\n\tstatic getDefaults(): FeedbackCombFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime: 0.1,\n\t\t\tresonance: 0.5,\n\t\t});\n\t}\n\n\tonReady(node: AudioWorkletNode) {\n\t\tconnectSeries(this.input, node, this.output);\n\t\t// @ts-ignore\n\t\tconst delayTime = node.parameters.get(\"delayTime\");\n\t\tthis.delayTime.setParam(delayTime);\n\t\t// @ts-ignore\n\t\tconst feedback = node.parameters.get(\"feedback\");\n\t\tthis.resonance.setParam(feedback);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.delayTime.dispose();\n\t\tthis.resonance.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Frequency, NormalRange } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Gain } from \"../../core/context/Gain\";\n\nexport type OnePoleFilterType = \"highpass\" | \"lowpass\";\n\nexport interface OnePoleFilterOptions extends ToneAudioNodeOptions {\n\tfrequency: Frequency;\n\ttype: OnePoleFilterType;\n}\n\n/**\n * A one pole filter with 6db-per-octave rolloff. Either \"highpass\" or \"lowpass\". \n * Note that changing the type or frequency may result in a discontinuity which\n * can sound like a click or pop. \n * References: \n * * http://www.earlevel.com/main/2012/12/15/a-one-pole-filter/  \n * * http://www.dspguide.com/ch19/2.htm\n * * https://github.com/vitaliy-bobrov/js-rocks/blob/master/src/app/audio/effects/one-pole-filters.ts\n * @category Component\n */\nexport class OnePoleFilter extends ToneAudioNode<OnePoleFilterOptions> {\n\t\n\treadonly name: string = \"OnePoleFilter\";\n\n\t/**\n\t * Hold the current frequency\n\t */\n\tprivate _frequency: Frequency;\n\n\t/**\n\t * the current one pole type\n\t */\n\tprivate _type: OnePoleFilterType;\n\n\t/**\n\t * the current one pole filter\n\t */\n\tprivate _filter!: IIRFilterNode;\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param frequency The frequency\n\t * @param type The  filter type, either \"lowpass\" or \"highpass\"\n\t */\n\tconstructor(frequency?: Frequency, type?: OnePoleFilterType);\n\tconstructor(options?: Partial<OnePoleFilterOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(OnePoleFilter.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(OnePoleFilter.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis._frequency = options.frequency;\n\t\tthis._type = options.type;\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\t\tthis._createFilter();\n\t}\n\n\tstatic getDefaults(): OnePoleFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tfrequency: 0.5,\n\t\t\ttype: \"lowpass\" as OnePoleFilterType\n\t\t});\n\t}\n\n\t/**\n\t * Create a filter and dispose the old one\n\t */\n\tprivate _createFilter() {\n\t\tconst oldFilter = this._filter;\n\t\tconst freq = this.toFrequency(this._frequency);\n\t\tconst t = 1 / (2 * Math.PI * freq);\n\t\tif (this._type === \"lowpass\") {\n\t\t\tconst a0 = 1 / (t * this.context.sampleRate);\n\t\t\tconst b1 = a0 - 1;\n\t\t\tthis._filter = this.context.createIIRFilter([a0, 0], [1, b1]);\n\t\t} else {\n\t\t\tconst b1 = 1 / (t * this.context.sampleRate) - 1;\n\t\t\tthis._filter = this.context.createIIRFilter([1, -1], [1, b1]);\n\t\t}\n\t\t\n\t\tthis.input.chain(this._filter, this.output);\n\t\tif (oldFilter) {\n\t\t\t// dispose it on the next block\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tif (!this.disposed) {\n\t\t\t\t\tthis.input.disconnect(oldFilter);\n\t\t\t\t\toldFilter.disconnect();\n\t\t\t\t}\n\t\t\t}, this.blockTime);\n\t\t}\n\t}\n\n\t/**\n\t * The frequency value. \n\t */\n\tget frequency(): Frequency {\n\t\treturn this._frequency;\n\t}\n\tset frequency(fq) {\n\t\tthis._frequency = fq;\n\t\tthis._createFilter();\n\t}\n\t\n\t/**\n\t * The OnePole Filter type, either \"highpass\" or \"lowpass\"\n\t */\n\tget type(): OnePoleFilterType {\n\t\treturn this._type;\n\t}\n\tset type(t) {\n\t\tthis._type = t;\n\t\tthis._createFilter();\n\t}\n\n\t/**\n\t * Get the frequency response curve. This curve represents how the filter\n\t * responses to frequencies between 20hz-20khz.\n\t * @param  len The number of values to return\n\t * @return The frequency response curve between 20-20kHz\n\t */\n\tgetFrequencyResponse(len: number = 128): Float32Array {\n\t\tconst freqValues = new Float32Array(len);\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst norm = Math.pow(i / len, 2);\n\t\t\tconst freq = norm * (20000 - 20) + 20;\n\t\t\tfreqValues[i] = freq;\n\t\t}\n\t\tconst magValues = new Float32Array(len);\n\t\tconst phaseValues = new Float32Array(len);\n\t\tthis._filter.getFrequencyResponse(freqValues, magValues, phaseValues);\n\t\treturn magValues;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis._filter.disconnect();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Frequency, NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { RecursivePartial } from \"../../core/util/Interface\";\nimport { FeedbackCombFilter } from \"./FeedbackCombFilter\";\nimport { Filter } from \"./Filter\";\nimport { OnePoleFilter } from \"./OnePoleFilter\";\n\ninterface LowpassCombFilterOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tresonance: NormalRange;\n\tdampening: Frequency;\n}\n\n/**\n * A lowpass feedback comb filter. It is similar to\n * [[FeedbackCombFilter]], but includes a lowpass filter.\n * @category Component\n */\nexport class LowpassCombFilter extends ToneAudioNode<LowpassCombFilterOptions> {\n\n\treadonly name = \"LowpassCombFilter\";\n\n\t/**\n\t * The delay node\n\t */\n\tprivate _combFilter: FeedbackCombFilter;\n\n\t/**\n\t * The lowpass filter\n\t */\n\tprivate _lowpass: OnePoleFilter;\n\n\t/**\n\t * The delayTime of the comb filter.\n\t */\n\treadonly delayTime: Param<Time>;\n\n\t/**\n\t * The amount of feedback of the delayed signal.\n\t */\n\treadonly resonance: Param<NormalRange>;\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * @param delayTime The delay time of the comb filter\n\t * @param resonance The resonance (feedback) of the comb filter\n\t * @param dampening The cutoff of the lowpass filter dampens the signal as it is fedback.\n\t */\n\tconstructor(delayTime?: Time, resonance?: NormalRange, dampening?: Frequency);\n\tconstructor(options?: RecursivePartial<LowpassCombFilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(LowpassCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\", \"dampening\"]));\n\t\tconst options = optionsFromArguments(LowpassCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\", \"dampening\"]);\n\n\t\tthis._combFilter = this.output = new FeedbackCombFilter({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: options.delayTime,\n\t\t\tresonance: options.resonance,\n\t\t});\n\t\tthis.delayTime = this._combFilter.delayTime;\n\t\tthis.resonance = this._combFilter.resonance;\n\n\t\tthis._lowpass = this.input = new OnePoleFilter({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.dampening,\n\t\t\ttype: \"lowpass\",\n\t\t});\n\n\t\t// connections\n\t\tthis._lowpass.connect(this._combFilter);\n\t}\n\n\tstatic getDefaults(): LowpassCombFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdampening: 3000,\n\t\t\tdelayTime: 0.1,\n\t\t\tresonance: 0.5,\n\t\t});\n\t}\n\t\n\t/**\n\t * The dampening control of the feedback\n\t */\n\tget dampening(): Frequency {\n\t\treturn this._lowpass.frequency;\n\t}\n\tset dampening(fq) {\n\t\tthis._lowpass.frequency = fq;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._combFilter.dispose();\n\t\tthis._lowpass.dispose();\n\t\treturn this;\n\t}\n}\n","import { Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { LowpassCombFilter } from \"../component/filter/LowpassCombFilter\";\nimport { deepMerge } from \"../core/util/Defaults\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Noise } from \"../source/Noise\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\n\nexport interface PluckSynthOptions extends InstrumentOptions {\n\tattackNoise: number;\n\tdampening: Frequency;\n\tresonance: NormalRange;\n\trelease: Time;\n}\n\n/**\n * Karplus-String string synthesis.\n * @example\n * var plucky = new Tone.PluckSynth().toDestination();\n * plucky.triggerAttack(\"C4\");\n * @category Instrument\n */\nexport class PluckSynth extends Instrument<PluckSynthOptions> {\n\n\treadonly name = \"PluckSynth\";\n\n\t/**\n\t * Noise burst at the beginning\n\t */\n\tprivate _noise: Noise;\n\tprivate _lfcf: LowpassCombFilter;\n\n\t/**\n\t * The amount of noise at the attack.\n\t * Nominal range of [0.1, 20]\n\t * @min 0.1\n\t * @max 20\n\t */\n\tattackNoise: number;\n\n\t/**\n\t * The amount of resonance of the pluck. Also correlates to the sustain duration.\n\t */\n\tresonance: NormalRange;\n\n\t/**\n\t * The release time which corresponds to a resonance ramp down to 0\n\t */\n\trelease: Time;\n\n\tconstructor(options?: RecursivePartial<PluckSynthOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PluckSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(PluckSynth.getDefaults(), arguments);\n\n\t\tthis._noise = new Noise({\n\t\t\tcontext: this.context,\n\t\t\ttype: \"pink\"\n\t\t});\n\n\t\tthis.attackNoise = options.attackNoise;\n\n\t\tthis._lfcf = new LowpassCombFilter({\n\t\t\tcontext: this.context,\n\t\t\tdampening: options.dampening,\n\t\t\tresonance: options.resonance,\n\t\t});\n\n\t\tthis.resonance = options.resonance;\n\t\tthis.release = options.release;\n\n\t\tthis._noise.connect(this._lfcf);\n\t\tthis._lfcf.connect(this.output);\n\t}\n\n\tstatic getDefaults(): PluckSynthOptions {\n\t\treturn deepMerge(Instrument.getDefaults(), {\n\t\t\tattackNoise: 1,\n\t\t\tdampening: 4000,\n\t\t\tresonance: 0.7,\n\t\t\trelease: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The dampening control. i.e. the lowpass filter frequency of the comb filter\n\t * @min 0\n\t * @max 7000\n\t */\n\tget dampening(): Frequency {\n\t\treturn this._lfcf.dampening;\n\t}\n\tset dampening(fq) {\n\t\tthis._lfcf.dampening = fq;\n\t}\n\n\ttriggerAttack(note: Frequency, time?: Time): this {\n\t\tconst freq = this.toFrequency(note);\n\t\ttime = this.toSeconds(time);\n\t\tconst delayAmount = 1 / freq;\n\t\tthis._lfcf.delayTime.setValueAtTime(delayAmount, time);\n\t\tthis._noise.start(time);\n\t\tthis._noise.stop(time + delayAmount * this.attackNoise);\n\t\tthis._lfcf.resonance.cancelScheduledValues(time);\n\t\tthis._lfcf.resonance.setValueAtTime(this.resonance, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ramp down the [[resonance]] to 0 over the duration of the release time.\n\t */\n\ttriggerRelease(time?: Time): this{\n\t\tthis._lfcf.resonance.linearRampTo(0, this.release, time);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._noise.dispose();\n\t\tthis._lfcf.dispose();\n\t\treturn this;\n\t}\n}\n","import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Cents, Frequency, Positive, Seconds } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Signal } from \"../signal/Signal\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\nimport { Source } from \"../source/Source\";\nimport { Synth, SynthOptions } from \"./Synth\";\n\nexport interface FMSynthOptions extends SynthOptions {\n\tharmonicity: Positive;\n\tmodulationIndex: Positive;\n\tmodulationEnvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tmodulation: OmniOscillatorSynthOptions;\n}\n\n/**\n * FMSynth is composed of two Tone.Synths where one Tone.Synth modulates\n * the frequency of a second Tone.Synth. A lot of spectral content\n * can be explored using the modulationIndex parameter. Read more about\n * frequency modulation synthesis on Sound On Sound: [Part 1](https://web.archive.org/web/20160403123704/http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm), [Part 2](https://web.archive.org/web/20160403115835/http://www.soundonsound.com/sos/may00/articles/synth.htm).\n *\n *  @example\n * var fmSynth = new Tone.FMSynth().toMaster();\n * fmSynth.triggerAttackRelease(\"C5\", \"4n\");\n */\n\nexport class FMSynth extends Monophonic<FMSynthOptions> {\n\treadonly name: string = \"FMSynth\";\n\n\t/**\n\t * The carrier voice.\n\t */\n\tprivate _carrier: Synth;\n\n\t/**\n\t * The modulator voice.\n\t */\n\n\tprivate _modulator: Synth;\n\n\t/**\n\t * The carrier's oscillator\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The carrier's envelope\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\t/**\n\t * The modulator's oscillator which is applied to the amplitude of the oscillator\n\t */\n\treadonly modulation: OmniOscillator<any>;\n\n\t/**\n\t * The modulator's envelope\n\t */\n\treadonly modulationEnvelope: AmplitudeEnvelope;\n\n\t/**\n\t * The frequency control\n\t */\n\treadonly frequency: Signal<Frequency>;\n\n\t/**\n\t * The detune in cents\n\t */\n\treadonly detune: Signal<Cents>;\n\n\t/**\n\t * Harmonicity is the ratio between the two voices. A harmonicity of\n\t * 1 is no change. Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * // pitch voice1 an octave below voice0\n\t * synth.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Multiply;\n\n\t/**\n\t * The modulation index which essentially the depth or amount of the modulation. It is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Multiply;\n\n\t/**\n\t * The node where the modulation happens\n\t */\n\tprivate _modulationNode: Gain;\n\n\tconstructor(options?: RecursivePartial<FMSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(FMSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(FMSynth.getDefaults(), arguments);\n\n\t\tthis._carrier = new Synth({\n\t\t\tcontext: this.context,\n\t\t\toscillator: options.oscillator,\n\t\t\tenvelope: options.envelope,\n\t\t\tvolume: -10,\n\t\t});\n\t\tthis._modulator = new Synth({\n\t\t\tcontext: this.context,\n\t\t\toscillator: options.modulation,\n\t\t\tenvelope: options.modulationEnvelope,\n\t\t\tvolume: -10,\n\t\t});\n\t\t\n\t\tthis.oscillator = this._carrier.oscillator;\n\t\tthis.envelope = this._carrier.envelope;\n\t\tthis.modulation = this._modulator.oscillator;\n\t\tthis.modulationEnvelope = this._modulator.envelope;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.detune,\n\t\t\tunits: \"cents\"\n\t\t});\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\t\tthis.modulationIndex = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.modulationIndex,\n\t\t});\n\t\tthis._modulationNode = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: 0,\n\t\t});\n\n\t\t// control the two voices frequency\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis.detune.fan(this._carrier.detune, this._modulator.detune);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t}\n\n\tstatic getDefaults(): FMSynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tharmonicity: 3,\n\t\t\tmodulationIndex: 10,\n\t\t\tdetune: 0,\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [\n\t\t\t\t\t...Object.keys(Source.getDefaults()),\n\t\t\t\t\t\"frequency\",\n\t\t\t\t\t\"detune\"\n\t\t\t\t]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"sine\"\n\t\t\t\t}\n\t\t\t),\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tEnvelope.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.01,\n\t\t\t\t\tdecay: 0.01,\n\t\t\t\t\tsustain: 1,\n\t\t\t\t\trelease: 0.5\n\t\t\t\t}\n\t\t\t),\n\t\t\tmodulation: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [\n\t\t\t\t\t...Object.keys(Source.getDefaults()),\n\t\t\t\t\t\"frequency\",\n\t\t\t\t\t\"detune\"\n\t\t\t\t]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"square\"\n\t\t\t\t}\n\t\t\t),\n\t\t\tmodulationEnvelope: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tEnvelope.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.5,\n\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\tsustain: 1,\n\t\t\t\t\trelease: 0.5\n\t\t\t\t}\n\t\t\t)\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// @ts-ignore\n\t\tthis._carrier._triggerEnvelopeAttack(time, velocity);\n\t\t// @ts-ignore\n\t\tthis._modulator._triggerEnvelopeAttack(time, velocity);\n\t}\n\t\n\t/**\n\t * Trigger the release portion of the note\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds) {\n\t\t// @ts-ignore\n\t\tthis._carrier._triggerEnvelopeRelease(time);\n\t\t// @ts-ignore\n\t\tthis._modulator._triggerEnvelopeRelease(time);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._modulationNode.dispose();\n\t\treturn this;\n\t}\n}\n","import \"../core/clock/Transport\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../core/context/ToneWithContext\";\nimport { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline } from \"../core/util/StateTimeline\";\nimport { isBoolean, isNumber } from \"../core/util/TypeCheck\";\n\nexport type ToneEventCallback<T> = (time: Seconds, value: T) => void;\n\nexport interface ToneEventOptions<T> extends ToneWithContextOptions {\n\tcallback: ToneEventCallback<T>;\n\tloop: boolean | number;\n\tloopEnd: Time;\n\tloopStart: Time;\n\tplaybackRate: Positive;\n\tvalue?: T;\n\tprobability: NormalRange;\n\tmute: boolean;\n\thumanize: boolean | Time;\n}\n\n/**\n * ToneEvent abstracts away this.context.transport.schedule and provides a schedulable\n * callback for a single or repeatable events along the timeline.\n *\n * @example\n * var chord = new ToneEvent(function(time, chord){\n * \t//the chord as well as the exact time of the event\n * \t//are passed in as arguments to the callback function\n * }, [\"D4\", \"E4\", \"F4\"]);\n * //start the chord at the beginning of the transport timeline\n * chord.start();\n * //loop it every measure for 8 measures\n * chord.loop = 8;\n * chord.loopEnd = \"1m\";\n * @category Event\n */\nexport class ToneEvent<ValueType = any> extends ToneWithContext<ToneEventOptions<ValueType>> {\n\n\treadonly name: string = \"ToneEvent\";\n\n\t/**\n\t * Loop value\n\t */\n\tprotected _loop: boolean | number;\n\n\t/**\n\t * The callback to invoke.\n\t */\n\tcallback: ToneEventCallback<ValueType>;\n\n\t/**\n\t * The value which is passed to the\n\t * callback function.\n\t */\n\tvalue: ValueType;\n\n\t/**\n\t * When the note is scheduled to start.\n\t */\n\tprotected _loopStart: Ticks;\n\n\t/**\n\t * When the note is scheduled to start.\n\t */\n\tprotected _loopEnd: Ticks;\n\n\t/**\n\t * Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The playback speed of the note. A speed of 1\n\t * is no change.\n\t */\n\tprotected _playbackRate: Positive;\n\n\t/**\n\t * A delay time from when the event is scheduled to start\n\t */\n\tprotected _startOffset: Ticks = 0;\n\n\t/**\n\t * private holder of probability value\n\t */\n\tprotected _probability: NormalRange;\n\n\t/**\n\t * the amount of variation from the given time.\n\t */\n\tprotected _humanize: boolean | Time;\n\n\t/**\n\t * If mute is true, the callback won't be invoked.\n\t */\n\tmute: boolean;\n\n\t/**\n\t * @param callback The callback to invoke at the time.\n\t * @param value The value or values which should be passed to the callback function on invocation.\n\t */\n\tconstructor(callback?: ToneEventCallback<ValueType>, value?: ValueType);\n\tconstructor(options?: Partial<ToneEventOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]));\n\t\tconst options = optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]);\n\n\t\tthis._loop = options.loop;\n\t\tthis.callback = options.callback;\n\t\tthis.value = options.value;\n\t\tthis._loopStart = this.toTicks(options.loopStart);\n\t\tthis._loopEnd = this.toTicks(options.loopEnd);\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._probability = options.probability;\n\t\tthis._humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): ToneEventOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp,\n\t\t\thumanize: false,\n\t\t\tloop: false,\n\t\t\tloopEnd: \"1m\",\n\t\t\tloopStart: 0,\n\t\t\tmute: false,\n\t\t\tplaybackRate: 1,\n\t\t\tprobability: 1,\n\t\t\tvalue: null,\n\t\t});\n\t}\n\n\t/**\n\t * Reschedule all of the events along the timeline\n\t * with the updated values.\n\t * @param after Only reschedules events after the given time.\n\t */\n\tprivate _rescheduleEvents(after: Ticks = -1): void {\n\t\t// if no argument is given, schedules all of the events\n\t\tthis._state.forEachFrom(after, event => {\n\t\t\tlet duration;\n\t\t\tif (event.state === \"started\") {\n\t\t\t\tif (event.id !== -1) {\n\t\t\t\t\tthis.context.transport.clear(event.id);\n\t\t\t\t}\n\t\t\t\tconst startTick = event.time + Math.round(this.startOffset / this._playbackRate);\n\t\t\t\tif (this._loop === true || isNumber(this._loop) && this._loop > 1) {\n\t\t\t\t\tduration = Infinity;\n\t\t\t\t\tif (isNumber(this._loop)) {\n\t\t\t\t\t\tduration = (this._loop) * this._getLoopDuration();\n\t\t\t\t\t}\n\t\t\t\t\tconst nextEvent = this._state.getAfter(startTick);\n\t\t\t\t\tif (nextEvent !== null) {\n\t\t\t\t\t\tduration = Math.min(duration, nextEvent.time - startTick);\n\t\t\t\t\t}\n\t\t\t\t\tif (duration !== Infinity) {\n\t\t\t\t\t\t// schedule a stop since it's finite duration\n\t\t\t\t\t\tthis._state.setStateAtTime(\"stopped\", startTick + duration + 1, { id: -1 });\n\t\t\t\t\t\tduration = new TicksClass(this.context, duration);\n\t\t\t\t\t}\n\t\t\t\t\tconst interval = new TicksClass(this.context, this._getLoopDuration());\n\t\t\t\t\tevent.id = this.context.transport.scheduleRepeat(\n\t\t\t\t\t\tthis._tick.bind(this), interval, new TicksClass(this.context, startTick), duration);\n\t\t\t\t} else {\n\t\t\t\t\tevent.id = this.context.transport.schedule(this._tick.bind(this), new TicksClass(this.context, startTick));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the note, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._state.getValueAtTime(this.context.transport.ticks) as BasicPlaybackState;\n\t}\n\n\t/**\n\t * The start from the scheduled start time.\n\t */\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t}\n\n\t/**\n\t * The probability of the notes being triggered.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t}\n\n\t/**\n\t * If set to true, will apply small random variation\n\t * to the callback time. If the value is given as a time, it will randomize\n\t * by that amount.\n\t * @example\n\t * event.humanize = true;\n\t */\n\tget humanize(): Time | boolean {\n\t\treturn this._humanize;\n\t}\n\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t}\n\n\t/**\n\t * Start the note at the given time.\n\t * @param  time  When the event should start.\n\t */\n\tstart(time?: TransportTime | TransportTimeClass): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) === \"stopped\") {\n\t\t\tthis._state.add({\n\t\t\t\tid: -1,\n\t\t\t\tstate: \"started\",\n\t\t\t\ttime: ticks,\n\t\t\t});\n\t\t\tthis._rescheduleEvents(ticks);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the Event at the given time.\n\t * @param  time  When the event should stop.\n\t */\n\tstop(time?: TransportTime | TransportTimeClass): this {\n\t\tthis.cancel(time);\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"stopped\", ticks, { id: -1 });\n\t\t\tconst previousEvent = this._state.getBefore(ticks);\n\t\t\tlet reschedulTime = ticks;\n\t\t\tif (previousEvent !== null) {\n\t\t\t\treschedulTime = previousEvent.time;\n\t\t\t}\n\t\t\tthis._rescheduleEvents(reschedulTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel all scheduled events greater than or equal to the given time\n\t * @param  time  The time after which events will be cancel.\n\t */\n\tcancel(time?: TransportTime | TransportTimeClass): this {\n\t\ttime = defaultArg(time, -Infinity);\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.forEachFrom(ticks, event => {\n\t\t\tthis.context.transport.clear(event.id);\n\t\t});\n\t\tthis._state.cancel(ticks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The callback function invoker. Also\n\t * checks if the Event is done playing\n\t * @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tconst ticks = this.context.transport.getTicksAtTime(time);\n\t\tif (!this.mute && this._state.getValueAtTime(ticks) === \"started\") {\n\t\t\tif (this.probability < 1 && Math.random() > this.probability) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.humanize) {\n\t\t\t\tlet variation = 0.02;\n\t\t\t\tif (!isBoolean(this.humanize)) {\n\t\t\t\t\tvariation = this.toSeconds(this.humanize);\n\t\t\t\t}\n\t\t\t\ttime += (Math.random() * 2 - 1) * variation;\n\t\t\t}\n\t\t\tthis.callback(time, this.value);\n\t\t}\n\t}\n\n\t/**\n\t * Get the duration of the loop.\n\t */\n\tprotected _getLoopDuration(): Ticks {\n\t\treturn Math.round((this._loopEnd - this._loopStart) / this._playbackRate);\n\t}\n\n\t/**\n\t * If the note should loop or not\n\t * between ToneEvent.loopStart and\n\t * ToneEvent.loopEnd. If set to true,\n\t * the event will loop indefinitely,\n\t * if set to a number greater than 1\n\t * it will play a specific number of\n\t * times, if set to false, 0 or 1, the\n\t * part will only play once.\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t * The playback rate of the note. Defaults to 1.\n\t * @example\n\t * note.loop = true;\n\t * //repeat the note twice as fast\n\t * note.playbackRate = 2;\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t * The loopEnd point is the time the event will loop\n\t * if ToneEvent.loop is true.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t * The time when the loop should start.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t * The current progress of the loop interval.\n\t * Returns 0 if the event is not started yet or\n\t * it is not set to loop.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this._loop) {\n\t\t\tconst ticks = this.context.transport.ticks;\n\t\t\tconst lastEvent = this._state.get(ticks);\n\t\t\tif (lastEvent !== null && lastEvent.state === \"started\") {\n\t\t\t\tconst loopDuration = this._getLoopDuration();\n\t\t\t\tconst progress = (ticks - lastEvent.time) % loopDuration;\n\t\t\t\treturn progress / loopDuration;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.cancel();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n","import { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype CallbackType<T> =\n\tT extends {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t} ? T :\n\t\tT extends ArrayLike<any> ? T[1] :\n\t\t\tT extends Time ? null : never;\n\ninterface PartOptions<T> extends Omit<ToneEventOptions<CallbackType<T>>, \"value\"> {\n\tevents: T[];\n}\n\n/**\n * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n * @example\n * var part = new Part(function(time, note){\n * \t//the notes given as the second element in the array\n * \t//will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }, [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n * @example\n * //use an array of objects as long as the object has a \"time\" attribute\n * var part = new Part(function(time, value){\n * \t//the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }, [{\"time\" : 0, \"note\" : \"C3\", \"velocity\": 0.9},\n * {\"time\" : \"0:2\", \"note\" : \"C4\", \"velocity\": 0.5}\n * ]).start(0);\n * @category Event\n */\nexport class Part<ValueType = any> extends ToneEvent<ValueType> {\n\n\treadonly name: string = \"Part\";\n\n\t/**\n\t * Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number;\n\t\toffset: number;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The events that belong to this part\n\t */\n\tprivate _events: Set<ToneEvent> = new Set();\n\n\t/**\n\t * @param callback The callback to invoke on each event\n\t * @param events the array of events\n\t */\n\tconstructor(callback?: ToneEventCallback<CallbackType<ValueType>>, value?: ValueType[]);\n\tconstructor(options?: Partial<PartOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]));\n\t\tconst options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]);\n\n\t\t// add the events\n\t\toptions.events.forEach(event => {\n\t\t\tif (isArray(event)) {\n\t\t\t\tthis.add(event[0], event[1]);\n\t\t\t} else {\n\t\t\t\tthis.add(event);\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic getDefaults(): PartOptions<any> {\n\t\treturn Object.assign(ToneEvent.getDefaults(), {\n\t\t\tevents: [],\n\t\t});\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset from the start of the part to begin playing at.\n\t */\n\tstart(time?: TransportTime, offset?: Time): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) !== \"started\") {\n\t\t\toffset = defaultArg(offset, this._loop ? this._loopStart : 0);\n\t\t\tif (this._loop) {\n\t\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t\t} else {\n\t\t\t\toffset = defaultArg(offset, 0);\n\t\t\t}\n\t\t\tconst computedOffset = this.toTicks(offset);\n\t\t\tthis._state.add({\n\t\t\t\tid: -1,\n\t\t\t\toffset: computedOffset,\n\t\t\t\tstate: \"started\",\n\t\t\t\ttime: ticks,\n\t\t\t});\n\t\t\tthis._forEach(event => {\n\t\t\t\tthis._startNote(event, ticks, computedOffset);\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the event in the given event at the correct time given\n\t * the ticks and offset and looping.\n\t * @param  event\n\t * @param  ticks\n\t * @param  offset\n\t */\n\tprivate _startNote(event: ToneEvent, ticks: Ticks, offset: Ticks): void {\n\t\tticks -= offset;\n\t\tif (this._loop) {\n\t\t\tif (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n\t\t\t\tif (event.startOffset < offset) {\n\t\t\t\t\t// start it on the next loop\n\t\t\t\t\tticks += this._getLoopDuration();\n\t\t\t\t}\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t} else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n\t\t\t\tevent.loop = false;\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t}\n\t\t} else if (event.startOffset >= offset) {\n\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t\tthis._forEach(event => {\n\t\t\tevent.startOffset += this._startOffset;\n\t\t});\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.cancel(ticks);\n\t\tthis._state.setStateAtTime(\"stopped\", ticks);\n\t\tthis._forEach(event => {\n\t\t\tevent.stop(time);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get/Set an Event's value at the given time.\n\t * If a value is passed in and no event exists at\n\t * the given time, one will be created with that value.\n\t * If two events are at the same time, the first one will\n\t * be returned.\n\t * @example\n\t * part.at(\"1m\"); //returns the part at the first measure\n\t * part.at(\"2m\", \"C2\"); //set the value at \"2m\" to C2.\n\t * //if an event didn't exist at that time, it will be created.\n\t * @param time The time of the event to get or set.\n\t * @param value If a value is passed in, the value of the event at the given time will be set to it.\n\t */\n\tat(time: Time, value?: any): ToneEvent | null {\n\t\tconst timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n\t\tconst tickTime = new TicksClass(this.context, 1).toSeconds();\n\n\t\tconst iterator = this._events.values();\n\t\tlet result = iterator.next();\n\t\twhile (!result.done) {\n\t\t\tconst event = result.value;\n\t\t\tif (Math.abs(timeInTicks - event.startOffset) < tickTime) {\n\t\t\t\tif (isDefined(value)) {\n\t\t\t\t\tevent.value = value;\n\t\t\t\t}\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tresult = iterator.next();\n\t\t}\n\t\t// if there was no event at that time, create one\n\t\tif (isDefined(value)) {\n\t\t\tthis.add(time, value);\n\t\t\t// return the new event\n\t\t\treturn this.at(time);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Add a an event to the part.\n\t * @param time The time the note should start. If an object is passed in, it should\n\t * \t\thave a 'time' attribute and the rest of the object will be used as the 'value'.\n\t * @param  value\n\t * @example\n\t * part.add(\"1m\", \"C#+11\");\n\t * @example\n\t * part.add({\n\t * \ttime: \"1m\",\n\t * \tnote: \"C#11\"\n\t * });\n\t */\n\tadd(obj: {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t}): this;\n\tadd(time: Time, value?: any): this;\n\tadd(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (time instanceof Object && Reflect.has(time, \"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\tconst ticks = this.toTicks(time);\n\t\tlet event: ToneEvent;\n\t\tif (value instanceof ToneEvent) {\n\t\t\tevent = value;\n\t\t\tevent.callback = this._tick.bind(this);\n\t\t} else {\n\t\t\tevent = new ToneEvent({\n\t\t\t\tcallback: this._tick.bind(this),\n\t\t\t\tcontext: this.context,\n\t\t\t\tvalue,\n\t\t\t});\n\t\t}\n\t\t// the start offset\n\t\tevent.startOffset = ticks;\n\n\t\t// initialize the values\n\t\tevent.set({\n\t\t\thumanize: this.humanize,\n\t\t\tloop: this.loop,\n\t\t\tloopEnd: this.loopEnd,\n\t\t\tloopStart: this.loopStart,\n\t\t\tplaybackRate: this.playbackRate,\n\t\t\tprobability: this.probability,\n\t\t});\n\n\t\tthis._events.add(event);\n\n\t\t// start the note if it should be played right now\n\t\tthis._restartEvent(event);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restart the given event\n\t */\n\tprivate _restartEvent(event: ToneEvent): void {\n\t\tthis._state.forEach((stateEvent) => {\n\t\t\tif (stateEvent.state === \"started\") {\n\t\t\t\tthis._startNote(event, stateEvent.time, stateEvent.offset);\n\t\t\t} else {\n\t\t\t\t// stop the note\n\t\t\t\tevent.stop(new TicksClass(this.context, stateEvent.time));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Remove an event from the part. If the event at that time is a Part,\n\t * it will remove the entire part.\n\t * @param time The time of the event\n\t * @param value Optionally select only a specific event value\n\t */\n\tremove(obj: {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t}): this;\n\tremove(time: Time, value?: any): this;\n\tremove(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (isObject(time) && time.hasOwnProperty(\"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\ttime = this.toTicks(time);\n\t\tthis._events.forEach(event => {\n\t\t\tif (event.startOffset === time) {\n\t\t\t\tif (isUndef(value) || (isDefined(value) && event.value === value)) {\n\t\t\t\t\tthis._events.delete(event);\n\t\t\t\t\tevent.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove all of the notes from the group.\n\t */\n\tclear(): this {\n\t\tthis._forEach(event => event.dispose());\n\t\tthis._events.clear();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n\t * @param after The time after which to cancel the scheduled events.\n\t */\n\tcancel(after?: TransportTime | TransportTimeClass): this {\n\t\tthis._forEach(event => event.cancel(after));\n\t\tthis._state.cancel(this.toTicks(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over all of the events\n\t */\n\tprivate _forEach(callback: (event: ToneEvent) => void): this {\n\t\tif (this._events) {\n\t\t\tthis._events.forEach(event => {\n\t\t\t\tif (event instanceof Part) {\n\t\t\t\t\tevent._forEach(callback);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the attribute of all of the events\n\t * @param  attr  the attribute to set\n\t * @param  value      The value to set it to\n\t */\n\tprivate _setAll(attr: string, value: any): void {\n\t\tthis._forEach(event => {\n\t\t\tevent[attr] = value;\n\t\t});\n\t}\n\n\t/**\n\t * Internal tick method\n\t * @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds, value?: any): void {\n\t\tif (!this.mute) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the event should be currently looping\n\t * given the loop boundries of this Part.\n\t * @param  event  The event to test\n\t */\n\tprivate _testLoopBoundries(event: ToneEvent): void {\n\t\tif (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n\t\t\tevent.cancel(0);\n\t\t} else if (event.state === \"stopped\") {\n\t\t\t// reschedule it if it's stopped\n\t\t\tthis._restartEvent(event);\n\t\t}\n\t}\n\n\t/**\n\t * The probability of the notes being triggered.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t\tthis._setAll(\"probability\", prob);\n\t}\n\n\t/**\n\t * If set to true, will apply small random variation\n\t * to the callback time. If the value is given as a time, it will randomize\n\t * by that amount.\n\t * @example\n\t * event.humanize = true;\n\t */\n\tget humanize(): boolean | Time {\n\t\treturn this._humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t\tthis._setAll(\"humanize\", variation);\n\t}\n\n\t/**\n\t * If the part should loop or not\n\t * between Part.loopStart and\n\t * Part.loopEnd. If set to true,\n\t * the part will loop indefinitely,\n\t * if set to a number greater than 1\n\t * it will play a specific number of\n\t * times, if set to false, 0 or 1, the\n\t * part will only play once.\n\t * @example\n\t * //loop the part 8 times\n\t * part.loop = 8;\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._forEach(event => {\n\t\t\tevent.loopStart = this.loopStart;\n\t\t\tevent.loopEnd = this.loopEnd;\n\t\t\tevent.loop = loop;\n\t\t\tthis._testLoopBoundries(event);\n\t\t});\n\t}\n\n\t/**\n\t * The loopEnd point determines when it will\n\t * loop if Part.loop is true.\n\t * @memberOf Part#\n\t * @type {Time}\n\t * @name loopEnd\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopEnd = loopEnd;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * The loopStart point determines when it will\n\t * loop if Part.loop is true.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopStart = this.loopStart;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * The playback rate of the part\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._setAll(\"playbackRate\", rate);\n\t}\n\n\t/**\n\t * The number of scheduled notes in the part.\n\t */\n\tget length(): number {\n\t\treturn this._events.size;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.clear();\n\t\treturn this;\n\t}\n}\n","import { TicksClass } from \"../core/type/Ticks\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype SequenceEventDescription<T> = Array<T | T[]>;\n\ninterface SequenceOptions<T> extends Omit<ToneEventOptions<T>, \"value\"> {\n\tloopStart: number;\n\tloopEnd: number;\n\tsubdivision: Time;\n\tevents: SequenceEventDescription<T>;\n}\n\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * var seq = new Sequence(function(time, note){\n * \tconsole.log(note);\n * //straight quater notes\n * }, [\"C4\", \"E4\", \"G4\", \"A4\"], \"4n\");\n * @example\n * var seq = new Sequence(function(time, note){\n * \tconsole.log(note);\n * //subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]);\n * @category Event\n */\nexport class Sequence<ValueType = any> extends ToneEvent<ValueType> {\n\n\treadonly name: string = \"Sequence\";\n\n\t/**\n\t * The subdivison of each note\n\t */\n\tprivate _subdivision: Ticks;\n\n\t/**\n\t * The object responsible for scheduling all of the events\n\t */\n\tprivate _part: Part = new Part({\n\t\tcallback: this._seqCallback.bind(this),\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * private reference to all of the sequence proxies\n\t */\n\tprivate _events: ValueType[] = [];\n\n\t/**\n\t * The proxied array\n\t */\n\tprivate _eventsArray: ValueType[] = [];\n\n\t/**\n\t * @param  callback  The callback to invoke with every note\n\t * @param  sequence  The sequence\n\t * @param  subdivision  The subdivision between which events are placed.\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tevents?: SequenceEventDescription<ValueType>,\n\t\tsubdivision?: Time,\n\t);\n\tconstructor(options?: Partial<SequenceOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n\t\tconst options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n\n\t\tthis._subdivision = this.toTicks(options.subdivision);\n\n\t\tthis.events = options.events;\n\n\t\t// set all of the values\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.probability = options.probability;\n\t\tthis.humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): SequenceOptions<any> {\n\t\treturn Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n\t\t\tevents: [],\n\t\t\tloop: true,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tsubdivision: \"8n\",\n\t\t});\n\t}\n\n\t/**\n\t * The internal callback for when an event is invoked\n\t */\n\tprivate _seqCallback(time: Seconds, value: any): void {\n\t\tif (value !== null) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * The sequence\n\t */\n\tget events(): any[] {\n\t\treturn this._events;\n\t}\n\tset events(s) {\n\t\tthis.clear();\n\t\tthis._eventsArray = s;\n\t\tthis._events = this._createSequence(this._eventsArray);\n\t\tthis._eventsUpdated();\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset index to start at\n\t */\n\tstart(time?: TransportTime, offset?: number): this {\n\t\tthis._part.start(time, offset ? this._indexTime(offset) : offset);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._part.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The subdivision of the sequence. This can only be\n\t * set in the constructor. The subdivision is the\n\t * interval between successive steps.\n\t */\n\tget subdivision(): Seconds {\n\t\treturn new TicksClass(this.context, this._subdivision).toSeconds();\n\t}\n\n\t/**\n\t * Create a sequence proxy which can be monitored to create subsequences\n\t */\n\tprivate _createSequence(array: any[]): any[] {\n\t\treturn new Proxy(array, {\n\t\t\tget: (target: any[], property: PropertyKey): any => {\n\t\t\t\t// property is index in this case\n\t\t\t\treturn target[property];\n\t\t\t},\n\t\t\tset: (target: any[], property: PropertyKey, value: any): boolean => {\n\t\t\t\tif (isString(property) && isFinite(parseInt(property, 10))) {\n\t\t\t\t\tconst index = parseInt(property, 10);\n\t\t\t\t\tif (isArray(value)) {\n\t\t\t\t\t\ttarget[property] = this._createSequence(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttarget[property] = value;\n\t\t\t\t}\n\t\t\t\tthis._eventsUpdated();\n\t\t\t\t// return true to accept the changes\n\t\t\t\treturn true;\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * When the sequence has changed, all of the events need to be recreated\n\t */\n\tprivate _eventsUpdated(): void {\n\t\tthis._part.clear();\n\t\tthis._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);\n\t\t// update the loopEnd\n\t\tthis.loopEnd = this.loopEnd;\n\t}\n\n\t/**\n\t * reschedule all of the events that need to be rescheduled\n\t */\n\tprivate _rescheduleSequence(sequence: any[], subdivision: Ticks, startOffset: Ticks): void {\n\t\tsequence.forEach((value, index) => {\n\t\t\tconst eventOffset = index * (subdivision) + startOffset;\n\t\t\tif (isArray(value)) {\n\t\t\t\tthis._rescheduleSequence(value, subdivision / value.length, eventOffset);\n\t\t\t} else {\n\t\t\t\tconst startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n\t\t\t\tthis._part.add(startTime, value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get the time of the index given the Sequence's subdivision\n\t * @param  index\n\t * @return The time of that index\n\t */\n\tprivate _indexTime(index: number): Seconds {\n\t\treturn new TicksClass(this.context, index * (this._subdivision) + this.startOffset).toSeconds();\n\t}\n\n\t/**\n\t * Clear all of the events\n\t */\n\tclear(): this {\n\t\tthis._part.clear();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._part.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// PROXY CALLS\n\t//-------------------------------------\n\n\tget loop(): boolean | number {\n\t\treturn this._part.loop;\n\t}\n\tset loop(l) {\n\t\tif (this._part) {\n\t\t\tthis._part.loop = l;\n\t\t}\n\t}\n\n\t/**\n\t * The index at which the sequence should start looping\n\t */\n\tget loopStart(): number {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(index) {\n\t\tthis._loopStart = index;\n\t\tif (this._part) {\n\t\t\tthis._part.loopStart = this._indexTime(index);\n\t\t}\n\t}\n\n\t/**\n\t * The index at which the sequence should end looping\n\t */\n\tget loopEnd(): number {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(index) {\n\t\tthis._loopEnd = index;\n\t\tif (this._part) {\n\t\t\tif (index === 0) {\n\t\t\t\tthis._part.loopEnd = this._indexTime(this._eventsArray.length);\n\t\t\t} else {\n\t\t\t\tthis._part.loopEnd = this._indexTime(index);\n\t\t\t}\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._part.startOffset;\n\t}\n\tset startOffset(start) {\n\t\tif (this._part) {\n\t\t\tthis._part.startOffset = start;\n\t\t}\n\t}\n\n\tget playbackRate(): Positive {\n\t\treturn this._part.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tif (this._part) {\n\t\t\tthis._part.playbackRate = rate;\n\t\t}\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._part.probability;\n\t}\n\tset probability(prob) {\n\t\tif (this._part) {\n\t\t\tthis._part.probability = prob;\n\t\t}\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._part.humanize;\n\t}\n\tset humanize(variation) {\n\t\tif (this._part) {\n\t\t\tthis._part.humanize = variation;\n\t\t}\n\t}\n\n\t/**\n\t * The number of scheduled events\n\t */\n\tget length(): number {\n\t\treturn this._part.length;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { connect, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { GainToAudio } from \"../../signal/GainToAudio\";\nimport { Signal } from \"../../signal/Signal\";\n\ninterface CrossFadeOptions extends ToneAudioNodeOptions {\n\tfade: NormalRange;\n}\n\n/**\n * Tone.Crossfade provides equal power fading between two inputs.\n * More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).\n * ```\n *                                             +---------+\n *                                            +> input a +>--+\n * +-----------+   +---------------------+     |         |   |\n * | 1s signal +>--> stereoPannerNode  L +>----> gain    |   |\n * +-----------+   |                     |     +---------+   |\n *               +-> pan               R +>-+                |   +--------+\n *               | +---------------------+  |                +---> output +>\n *  +------+     |                          |  +---------+   |   +--------+\n *  | fade +>----+                          | +> input b +>--+\n *  +------+                                |  |         |\n *                                          +--> gain    |\n *                                             +---------+\n * ```\n * @example\n * var crossFade = new CrossFade(0.5);\n * //connect effect A to crossfade from\n * //effect output 0 to crossfade input 0\n * effectA.connect(crossFade.a);\n * //connect effect B to crossfade from\n * //effect output 0 to crossfade input 1\n * effectB.connect(crossFade.b);\n * crossFade.fade.value = 0;\n * // ^ only effectA is output\n * crossFade.fade.value = 1;\n * // ^ only effectB is output\n * crossFade.fade.value = 0.5;\n * // ^ the two signals are mixed equally.\n * @category Component\n */\nexport class CrossFade extends ToneAudioNode<CrossFadeOptions> {\n\n\treadonly name: string = \"CrossFade\";\n\n\t/**\n\t * The crossfading is done by a StereoPannerNode\n\t */\n\tprivate _panner: StereoPannerNode = this.context.createStereoPanner();\n\n\t/**\n\t * Split the output of the panner node into two values used to control the gains.\n\t */\n\tprivate _split: ChannelSplitterNode = this.context.createChannelSplitter(2);\n\n\t/**\n\t * Convert the fade value into an audio range value so it can be connected\n\t * to the panner.pan AudioParam\n\t */\n\tprivate _g2a: GainToAudio = new GainToAudio({ context: this.context });\n\n\t/**\n\t * The input which is at full level when fade = 0\n\t */\n\treadonly a: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The input which is at full level when fade = 1\n\t */\n\treadonly b: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The output is a mix between `a` and `b` at the ratio of `fade`\n\t */\n\treadonly output: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * CrossFade has no input, you must choose either `a` or `b`\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * The mix between the two inputs. A fade value of 0\n\t * will output 100% crossFade.a and\n\t * a value of 1 will output 100% crossFade.b.\n\t */\n\treadonly fade: Signal<NormalRange>;\n\n\tprotected _internalChannels = [this.a, this.b];\n\n\t/**\n\t * @param fade The initial fade value [0, 1].\n\t */\n\tconstructor(fade?: NormalRange);\n\tconstructor(options?: Partial<CrossFadeOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"])));\n\t\tconst options = optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"]);\n\n\t\tthis.fade = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"normalRange\",\n\t\t\tvalue: options.fade,\n\t\t});\n\t\treadOnly(this, \"fade\");\n\n\t\tthis.context.getConstant(1).connect(this._panner);\n\t\tthis._panner.connect(this._split);\n\t\t// this is necessary for standardized-audio-context\n\t\t// doesn't make any difference for the native AudioContext\n\t\t// https://github.com/chrisguttandin/standardized-audio-context/issues/647\n\t\tthis._panner.channelCount = 1;\n\t\tthis._panner.channelCountMode = \"explicit\";\n\t\tconnect(this._split, this.a.gain, 0);\n\t\tconnect(this._split, this.b.gain, 1);\n\n\t\tthis.fade.chain(this._g2a, this._panner.pan);\n\n\t\tthis.a.connect(this.output);\n\t\tthis.b.connect(this.output);\n\t}\n\n\tstatic getDefaults(): CrossFadeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tfade: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.a.dispose();\n\t\tthis.b.dispose();\n\t\tthis.output.dispose();\n\t\tthis.fade.dispose();\n\t\tthis._g2a.dispose();\n\t\tthis._panner.disconnect();\n\t\tthis._split.disconnect();\n\t\treturn this;\n\t}\n}\n","import { CrossFade } from \"../component/channel/CrossFade\";\nimport { Gain } from \"../core/context/Gain\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\n\nexport interface EffectOptions extends ToneAudioNodeOptions {\n\twet: NormalRange;\n}\n/**\n * Effect is the base class for effects. Connect the effect between\n * the effectSend and effectReturn GainNodes, then control the amount of\n * effect which goes to the output using the wet control.\n */\nexport abstract class Effect<Options extends EffectOptions>\n\textends ToneAudioNode<Options> {\n\n\treadonly name: string = \"Effect\";\n\n\t/**\n\t * the drywet knob to control the amount of effect\n\t */\n\tprivate _dryWet: CrossFade = new CrossFade({ context: this.context });\n\n\t/**\n\t * The wet control is how much of the effected\n\t * will pass through to the output. 1 = 100% effected\n\t * signal, 0 = 100% dry signal.\n\t */\n\twet: Signal<NormalRange> = this._dryWet.fade;\n\n\t/**\n\t * connect the effectSend to the input of hte effect\n\t */\n\tprotected effectSend: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * connect the output of the effect to the effectReturn\n\t */\n\tprotected effectReturn: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The effect input node\n\t */\n\tinput: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The effect output\n\t */\n\toutput = this._dryWet;\n\n\tconstructor(options: EffectOptions) {\n\t\tsuper(options);\n\n\t\t// connections\n\t\tthis.input.fan(this._dryWet.a, this.effectSend);\n\t\tthis.effectReturn.connect(this._dryWet.b);\n\t\tthis.wet.setValueAtTime(options.wet, 0);\n\t\tthis._internalChannels = [this.effectReturn, this.effectSend];\n\t\treadOnly(this, \"wet\");\n\t}\n\n\tstatic getDefaults(): EffectOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\twet: 1,\n\t\t});\n\t}\n\n\t/**\n\t * chains the effect in between the effectSend and effectReturn\n\t */\n\tprotected connectEffect(effect: ToneAudioNode | AudioNode): this {\n\t\t// add it to the internal channels\n\t\tthis._internalChannels.push(effect);\n\t\tthis.effectSend.chain(effect, this.effectReturn);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dryWet.dispose();\n\t\tthis.effectSend.dispose();\n\t\tthis.effectReturn.dispose();\n\t\tthis.wet.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\nexport interface FeedbackEffectOptions extends EffectOptions {\n\t/**\n\t * The feedback from the output back to the input\n\t * ```\n\t * +---<--------<---+\n\t * |                |\n\t * |  +----------+  |\n\t * +--> feedback +>-+\n\t *    +----------+\n\t * ```\n\t */\n\tfeedback: NormalRange;\n}\n\n/**\n * FeedbackEffect provides a loop between an audio source and its own output.\n * This is a base-class for feedback effects.\n */\nexport abstract class FeedbackEffect<Options extends FeedbackEffectOptions> extends Effect<Options> {\n\n\treadonly name: string = \"FeedbackEffect\";\n\n\t/**\n\t * the gain which controls the feedback\n\t */\n\tprivate _feedbackGain: Gain<NormalRange>;\n\n\t/**\n\t * The amount of signal which is fed back into the effect input.\n\t */\n\tfeedback: Param<NormalRange>;\n\n\tconstructor(options: FeedbackEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis._feedbackGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.feedback,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\n\t\tthis.feedback = this._feedbackGain.gain;\n\t\treadOnly(this, \"feedback\");\n\n\t\t// the feedback loop\n\t\tthis.effectReturn.chain(this._feedbackGain, this.effectSend);\n\t}\n\n\tstatic getDefaults(): FeedbackEffectOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfeedback: 0.125,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._feedbackGain.dispose();\n\t\tthis.feedback.dispose();\n\t\treturn this;\n\t}\n}\n","import { Delay } from \"../core/context/Delay\";\nimport { Param } from \"../core/context/Param\";\nimport { NormalRange, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { FeedbackEffect, FeedbackEffectOptions } from \"./FeedbackEffect\";\n\ninterface FeedbackDelayOptions extends FeedbackEffectOptions {\n\tdelayTime: Time;\n\tmaxDelay: Time;\n}\n\n/**\n * FeedbackDelay is a DelayNode in which part of output signal is fed back into the delay.\n *\n * @param delayTime The delay applied to the incoming signal.\n * @param feedback The amount of the effected signal which is fed back through the delay.\n * @example\n * var feedbackDelay = new FeedbackDelay(\"8n\", 0.5).toDestination();\n * var tom = new Tone.MembraneSynth({\n * \"octaves\" : 4,\n * \"pitchDecay\" : 0.1\n * }).connect(feedbackDelay);\n * tom.triggerAttackRelease(\"A2\",\"32n\");\n * @category Effect\n */\nexport class FeedbackDelay extends FeedbackEffect<FeedbackDelayOptions> {\n\n\treadonly name: string = \"FeedbackDelay\";\n\n\t/**\n\t * the delay node\n\t */\n\tprivate _delayNode: Delay;\n\n\t/**\n\t * The delayTime of the FeedbackDelay.\n\t */\n\treadonly delayTime: Param<Time>;\n\n\tconstructor(delayTime?: Time, feedback?: NormalRange);\n\tconstructor(options?: Partial<FeedbackDelayOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]));\n\t\tconst options = optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]);\n\n\t\tthis._delayNode = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: options.delayTime,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis.delayTime = this._delayNode.delayTime;\n\n\t\t// connect it up\n\t\tthis.connectEffect(this._delayNode);\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): FeedbackDelayOptions {\n\t\treturn Object.assign(FeedbackEffect.getDefaults(), {\n\t\t\tdelayTime: 0.25,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.dispose();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\ninterface ToneConvolverOptions extends EffectOptions {\n\tonload: () => void;\n\tnormalize: boolean;\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n}\n\n/**\n * Convolver is a wrapper around the Native Web Audio\n * [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).\n * Convolution is useful for reverb and filter emulation. Read more about convolution reverb on\n * [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).\n *\n * @example\n * //initializing the convolver with an impulse response\n * var convolver = new Convolver(\"./path/to/ir.wav\").toDestination();\n * @category Effect\n */\nexport class Convolver extends Effect<ToneConvolverOptions> {\n\n\treadonly name: string = \"Convolver\";\n\n\t/**\n\t * The native ConvolverNode\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The Buffer belonging to the convolver\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * @param url The URL of the impulse response or the ToneAudioBuffer containing the impulse response.\n\t * @param onload The callback to invoke when the url is loaded.\n\t */\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<ToneConvolverOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Convolver.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(Convolver.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis._buffer = new ToneAudioBuffer(options.url, buffer => {\n\t\t\tthis.buffer = buffer;\n\t\t\toptions.onload();\n\t\t});\n\n\t\t// set if it's already loaded\n\t\tif (this._buffer.loaded) {\n\t\t\tthis.buffer = this._buffer;\n\t\t}\n\n\t\t// initially set normalization\n\t\tthis.normalize = options.normalize;\n\n\t\t// connect it up\n\t\tthis.connectEffect(this._convolver);\n\t}\n\n\tstatic getDefaults(): ToneConvolverOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tnormalize: true,\n\t\t\tonload: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Load an impulse response url as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<void> {\n\t\tthis.buffer = await this._buffer.load(url);\n\t}\n\n\t/**\n\t * The convolver's buffer\n\t */\n\tget buffer(): ToneAudioBuffer | null {\n\t\tif (this._buffer.length) {\n\t\t\treturn this._buffer;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tset buffer(buffer) {\n\t\tif (buffer) {\n\t\t\tthis._buffer.set(buffer);\n\t\t}\n\t\t// if it's already got a buffer, create a new one\n\t\tif (this._convolver.buffer) {\n\t\t\t// disconnect the old one\n\t\t\tthis.effectSend.disconnect();\n\t\t\tthis._convolver.disconnect();\n\t\t\t// create and connect a new one\n\t\t\tthis._convolver = this.context.createConvolver();\n\t\t\tthis.connectEffect(this._convolver);\n\t\t}\n\t\tconst buff = this._buffer.get();\n\t\tthis._convolver.buffer = buff ? buff : null;\n\t}\n\n\t/**\n\t * The normalize property of the ConvolverNode interface is a boolean that\n\t * controls whether the impulse response from the buffer will be scaled by\n\t * an equal-power normalization when the buffer attribute is set, or not.\n\t */\n\tget normalize(): boolean {\n\t\treturn this._convolver.normalize;\n\t}\n\tset normalize(norm) {\n\t\tthis._convolver.normalize = norm;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\ninterface MergeOptions extends ToneAudioNodeOptions {\n\tchannels: Positive;\n}\n\n/**\n * Merge brings multiple mono input channels into a single multichannel output channel.\n *\n * @example\n * var merge = new Merge().toDestination();\n * //routing a sine tone in the left channel\n * //and noise in the right channel\n * var osc = new Tone.Oscillator().connect(merge.left);\n * var noise = new Tone.Noise().connect(merge.right);\n * //starting our oscillators\n * noise.start();\n * osc.start();\n * @category Component\n */\nexport class Merge extends ToneAudioNode<MergeOptions> {\n\n\treadonly name: string = \"Merge\";\n\n\t/**\n\t * The merger node for the two channels.\n\t */\n\tprivate _merger: ChannelMergerNode;\n\n\t/**\n\t * The output is the input channels combined into a sigle (multichannel) output\n\t */\n\treadonly output: ChannelMergerNode;\n\n\t/**\n\t * Multiple input connections combine into a single output.\n\t */\n\treadonly input: ChannelMergerNode;\n\n\t/**\n\t * @param channels The number of channels to merge.\n\t */\n\tconstructor(channels?: Positive);\n\tconstructor(options?: Partial<MergeOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]));\n\t\tconst options = optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]);\n\n\t\tthis._merger = this.output = this.input = this.context.createChannelMerger(options.channels);\n\t}\n\n\tstatic getDefaults(): MergeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannels: 2,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._merger.disconnect();\n\t\treturn this;\n\t}\n}\n","import { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Offline } from \"../core/context/Offline\";\nimport { Seconds } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\ninterface ReverbOptions extends EffectOptions {\n\tdecay: Seconds;\n\tpreDelay: Seconds;\n}\n\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * Note: the Reverb will not make any sound until [[generate]]\n * has been invoked and resolved.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n * \n * @category Effect\n */\nexport class Reverb extends Effect<ReverbOptions> {\n\n\treadonly name: string = \"Reverb\";\n\n\t/**\n\t * Convolver node\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The duration of the reverb.\n\t * [[generate]] must be called in order to update the values.\n\t */\n\tdecay: Seconds;\n\t\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t * [[generate]] must be called in order to update the values.\n\t */\n\tpreDelay: Seconds;\n\n\t/**\n\t * @param decay The amount of time it will reverberate for.\n\t */\n\tconstructor(decay?: Seconds);\n\tconstructor(options?: Partial<ReverbOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n\t\tconst options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n\n\t\tthis.decay = options.decay;\n\t\tthis.preDelay = options.preDelay;\n\n\t\tthis.connectEffect(this._convolver);\n\t}\n\n\tstatic getDefaults(): ReverbOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdecay: 1.5,\n\t\t\tpreDelay: 0.01,\n\t\t});\n\t}\n\n\t/**\n\t * Generate the Impulse Response. Returns a promise while the IR is being generated.\n\t * @return Promise which returns this object.\n\t */\n\tasync generate(): Promise<this> {\n\t\tconst buffer = await Offline((context) => {\n\t\t\t// create a noise burst which decays over the duration\n\t\t\tconst noiseL = new Noise({ context });\n\t\t\tconst noiseR = new Noise({ context });\n\t\t\tconst merge = new Merge({ context });\n\t\t\tnoiseL.connect(merge, 0, 0);\n\t\t\tnoiseR.connect(merge, 0, 1);\n\t\t\tconst gainNode = new Gain({ context }).toDestination();\n\t\t\tmerge.connect(gainNode);\n\t\t\tnoiseL.start(0);\n\t\t\tnoiseR.start(0);\n\t\t\t// predelay\n\t\t\tgainNode.gain.setValueAtTime(0, 0);\n\t\t\tgainNode.gain.setValueAtTime(1, this.preDelay);\n\t\t\t// decay\n\t\t\tgainNode.gain.exponentialApproachValueAtTime(0, this.preDelay, this.decay);\n\t\t}, this.decay + this.preDelay);\n\t\tthis._convolver.buffer = buffer.get() as AudioBuffer;\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n","import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, PowerOfTwo } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\nexport type AnalyserType = \"fft\" | \"waveform\";\n\nexport interface AnalyserOptions extends ToneAudioNodeOptions {\n\tsize: PowerOfTwo;\n\ttype: AnalyserType;\n\tsmoothing: NormalRange;\n}\n\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\nexport class Analyser extends ToneAudioNode<AnalyserOptions> {\n\n\treadonly name: string = \"Analyser\";\n\n\treadonly input: AnalyserNode;\n\treadonly output: AnalyserNode;\n\n\t/**\n\t * The analyser node.\n\t */\n\tprivate _analyser = this.context.createAnalyser();\n\n\t/**\n\t * The analysis type\n\t */\n\tprivate _type!: AnalyserType;\n\n\t/**\n\t * The buffer that the FFT data is written to\n\t */\n\tprivate _buffer!: Float32Array;\n\n\t/**\n\t * @param type The return type of the analysis, either \"fft\", or \"waveform\".\n\t * @param size The size of the FFT. This must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(type?: AnalyserType, size?: number);\n\tconstructor(options?: Partial<AnalyserOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]));\n\t\tconst options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n\t\t// set the values initially\n\t\tthis.size = options.size;\n\t\tthis.type = options.type;\n\t\tthis.input = this.output = this._analyser;\n\t}\n\n\tstatic getDefaults(): AnalyserOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsize: 1024,\n\t\t\tsmoothing: 0.8,\n\t\t\ttype: \"fft\" as AnalyserType,\n\t\t});\n\t}\n\n\t/**\n\t * Run the analysis given the current settings and return the\n\t */\n\tgetValue(): Float32Array {\n\t\tif (this._type === \"fft\") {\n\t\t\tthis._analyser.getFloatFrequencyData(this._buffer);\n\t\t} else if (this._type === \"waveform\") {\n\t\t\tthis._analyser.getFloatTimeDomainData(this._buffer);\n\t\t}\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analyser.frequencyBinCount;\n\t}\n\tset size(size: PowerOfTwo) {\n\t\tthis._analyser.fftSize = size * 2;\n\t\tthis._buffer = new Float32Array(size);\n\t}\n\n\t/**\n\t * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n\t */\n\tget type(): AnalyserType {\n\t\treturn this._type;\n\t}\n\tset type(type: AnalyserType) {\n\t\tthis.assert(type === \"waveform\" || type === \"fft\", `Analyser: invalid type: ${type}`);\n\t\tthis._type = type;\n\t}\n\n\t/**\n\t * 0 represents no time averaging with the last analysis frame.\n\t */\n\tget smoothing(): NormalRange {\n\t\treturn this._analyser.smoothingTimeConstant;\n\t}\n\n\tset smoothing(val: NormalRange) {\n\t\tthis._analyser.smoothingTimeConstant = val;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analyser.disconnect();\n\t\treturn this;\n\t}\n}\n","import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { AudioRange, NormalRange } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface TonePannerOptions extends ToneAudioNodeOptions {\n\tpan: AudioRange;\n}\n\n/**\n * Panner is an equal power Left/Right Panner. It is a wrapper around the StereoPannerNode.\n * @example\n * //pan the input signal hard right.\n * var panner = new Panner(1);\n * @category Component\n */\nexport class Panner extends ToneAudioNode<TonePannerOptions> {\n\n\treadonly name: string = \"Panner\";\n\n\t/**\n\t * the panner node\n\t */\n\tprivate _panner: StereoPannerNode = this.context.createStereoPanner();\n\treadonly input: StereoPannerNode = this._panner;\n\treadonly output: StereoPannerNode = this._panner;\n\n\t/**\n\t * The pan control. -1 = hard left, 1 = hard right.\n\t */\n\treadonly pan: Param<AudioRange>;\n\n\tconstructor(options?: Partial<TonePannerOptions>);\n\t/**\n\t * @param pan The initial panner value (Defaults to 0 = \"center\").\n\t */\n\tconstructor(pan?: AudioRange);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Panner.getDefaults(), arguments, [\"pan\"])));\n\t\tconst options = optionsFromArguments(Panner.getDefaults(), arguments, [\"pan\"]);\n\n\t\tthis.pan = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.pan,\n\t\t\tvalue: options.pan,\n\t\t});\n\n\t\t// this is necessary for standardized-audio-context\n\t\t// doesn't make any difference for the native AudioContext\n\t\t// https://github.com/chrisguttandin/standardized-audio-context/issues/647\n\t\tthis._panner.channelCount = 1;\n\t\tthis._panner.channelCountMode = \"explicit\";\n\n\t\t// initial value\n\t\treadOnly(this, \"pan\");\n\t}\n\n\tstatic getDefaults(): TonePannerOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tpan: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panner.disconnect();\n\t\tthis.pan.dispose();\n\t\treturn this;\n\t}\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Frequency, Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Filter } from \"../filter/Filter\";\n\ninterface MultibandSplitOptions extends ToneAudioNodeOptions {\n\tQ: Positive;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\n/**\n * Split the incoming signal into three bands (low, mid, high)\n * with two crossover frequency controls.\n * ```\n *            +----------------------+\n *          +-> input < lowFrequency +------------------> low\n *          | +----------------------+\n *          |\n *          | +--------------------------------------+\n * input ---+-> lowFrequency < input < highFrequency +--> mid\n *          | +--------------------------------------+\n *          |\n *          | +-----------------------+\n *          +-> highFrequency < input +-----------------> high\n *            +-----------------------+\n * ```\n * @category Component\n */\nexport class MultibandSplit extends ToneAudioNode<MultibandSplitOptions> {\n\n\treadonly name: string = \"MultibandSplit\";\n\n\t/**\n\t * the input\n\t */\n\treadonly input = new Gain({ context: this.context });\n\n\t/**\n\t * no output node, use either low, mid or high outputs\n\t */\n\treadonly output = undefined;\n\n\t/**\n\t * The low band.\n\t */\n\treadonly low = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"lowpass\",\n\t});\n\n\t/**\n\t * the lower filter of the mid band\n\t */\n\tprivate _lowMidFilter = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"highpass\",\n\t});\n\n\t/**\n\t * The mid band output.\n\t */\n\treadonly mid = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"lowpass\",\n\t});\n\n\t/**\n\t * The high band output.\n\t */\n\treadonly high = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"highpass\",\n\t});\n\n\t/**\n\t * The low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<Frequency>;\n\n\t/**\n\t * The mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<Frequency>;\n\n\tprotected _internalChannels = [this.low, this.mid, this.high];\n\n\t/**\n\t * The Q or Quality of the filter\n\t */\n\treadonly Q: Signal<Positive>;\n\n\t/**\n\t * @param lowFrequency the low/mid crossover frequency\n\t * @param highFrequency the mid/high crossover frequency\n\t */\n\tconstructor(lowFrequency?: Frequency, highFrequency?: Frequency);\n\tconstructor(options?: Partial<MultibandSplitOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MultibandSplit.getDefaults(), arguments, [\"lowFrequency\", \"highFrequency\"]));\n\t\tconst options = optionsFromArguments(MultibandSplit.getDefaults(), arguments, [\"lowFrequency\", \"highFrequency\"]);\n\n\t\tthis.lowFrequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.lowFrequency,\n\t\t});\n\n\t\tthis.highFrequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.highFrequency,\n\t\t});\n\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.Q,\n\t\t});\n\n\t\tthis.input.fan(this.low, this.high);\n\t\tthis.input.chain(this._lowMidFilter, this.mid);\n\t\t// the frequency control signal\n\t\tthis.lowFrequency.fan(this.low.frequency, this._lowMidFilter.frequency);\n\t\tthis.highFrequency.fan(this.mid.frequency, this.high.frequency);\n\t\t// the Q value\n\t\tthis.Q.connect(this.low.Q);\n\t\tthis.Q.connect(this._lowMidFilter.Q);\n\t\tthis.Q.connect(this.mid.Q);\n\t\tthis.Q.connect(this.high.Q);\n\n\t\treadOnly(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t}\n\n\tstatic getDefaults(): MultibandSplitOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\thighFrequency: 2500,\n\t\t\tlowFrequency: 400,\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\twritable(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t\tthis.low.dispose();\n\t\tthis._lowMidFilter.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.lowFrequency.dispose();\n\t\tthis.highFrequency.dispose();\n\t\tthis.Q.dispose();\n\t\treturn this;\n\t}\n\n}\n","import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Cents, Decibels, Frequency, GainFactor, Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { MultibandSplit } from \"../channel/MultibandSplit\";\n\ninterface EQ3Options extends ToneAudioNodeOptions {\n\tlow: Decibels;\n\tmid: Decibels;\n\thigh: Decibels;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\n/**\n * EQ3 provides 3 equalizer bins: Low/Mid/High. \n * @category Component\n */\nexport class EQ3 extends ToneAudioNode<EQ3Options> {\n\n\treadonly name: string = \"EQ3\";\n\n\t/**\n\t * the input\n\t */\n\treadonly input: MultibandSplit;\n\n\t/**\n\t * the output\n\t */\n\treadonly output = new Gain({ context: this.context });\n\n\t/**\n\t * Splits the input into three outputs\n\t */\n\tprivate _multibandSplit: MultibandSplit;\n\n\t/**\n\t * The gain for the lower signals\n\t */\n\tprivate _lowGain: Gain<Decibels>;\n\n\t/**\n\t * The gain for the mid signals\n\t */\n\tprivate _midGain: Gain<Decibels>;\n\n\t/**\n\t * The gain for the high signals\n\t */\n\tprivate _highGain: Gain<Decibels>;\n\n\t/**\n\t * The gain in decibels of the low part\n\t */\n\treadonly low: Param<Decibels>;\n\n\t/**\n\t * The gain in decibels of the mid part\n\t */\n\treadonly mid: Param<Decibels>;\n\n\t/**\n\t * The gain in decibels of the high part\n\t */\n\treadonly high: Param<Decibels>;\n\n\t/**\n\t * The Q value for all of the filters.\n\t */\n\treadonly Q: Signal<Positive>;\n\n\t/**\n\t * The low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<Frequency>;\n\n\t/**\n\t * The mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<Frequency>;\n\n\tprotected _internalChannels: ToneAudioNode[] = [];\n\n\tconstructor(lowLevel?: Decibels, midLevel?: Decibels, highLevel?: Decibels);\n\tconstructor(options: Partial<EQ3Options>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(EQ3.getDefaults(), arguments, [\"low\", \"mid\", \"high\"]));\n\t\tconst options = optionsFromArguments(EQ3.getDefaults(), arguments, [\"low\", \"mid\", \"high\"]);\n\n\t\tthis.input = this._multibandSplit = new MultibandSplit({\n\t\t\tcontext: this.context,\n\t\t\thighFrequency: options.highFrequency,\n\t\t\tlowFrequency: options.lowFrequency,\n\t\t});\n\n\t\tthis._lowGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.low,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis._midGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.mid,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis._highGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.high,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis.low = this._lowGain.gain;\n\t\tthis.mid = this._midGain.gain;\n\t\tthis.high = this._highGain.gain;\n\t\tthis.Q = this._multibandSplit.Q;\n\t\tthis.lowFrequency = this._multibandSplit.lowFrequency;\n\t\tthis.highFrequency\t= this._multibandSplit.highFrequency;\n\n\t\t// the frequency bands\n\t\tthis._multibandSplit.low.chain(this._lowGain, this.output);\n\t\tthis._multibandSplit.mid.chain(this._midGain, this.output);\n\t\tthis._multibandSplit.high.chain(this._highGain, this.output);\n\n\t\treadOnly(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n\t\tthis._internalChannels = [this._multibandSplit];\n\t}\n\n\tstatic getDefaults(): EQ3Options {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\thigh: 0,\n\t\t\thighFrequency: 2500,\n\t\t\tlow: 0,\n\t\t\tlowFrequency: 400,\n\t\t\tmid: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\twritable(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n\t\tthis._multibandSplit.dispose();\n\t\tthis.lowFrequency.dispose();\n\t\tthis.highFrequency.dispose();\n\t\tthis._lowGain.dispose();\n\t\tthis._midGain.dispose();\n\t\tthis._highGain.dispose();\n\t\tthis.low.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.Q.dispose();\n\t\treturn this;\n\t}\n\n}\n","import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels, Positive, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface CompressorOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tknee: Decibels;\n\tratio: Positive;\n\trelease: Time;\n\tthreshold: Decibels;\n}\n\n/**\n * Compressor is a thin wrapper around the Web Audio\n * [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).\n * Compression reduces the volume of loud sounds or amplifies quiet sounds\n * by narrowing or \"compressing\" an audio signal's dynamic range.\n * Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).\n * @example\n * var comp = new Compressor(-30, 3);\n * @category Component\n */\nexport class Compressor extends ToneAudioNode<CompressorOptions> {\n\n\treadonly name: string = \"Compressor\";\n\n\t/**\n\t * the compressor node\n\t */\n\tprivate _compressor: DynamicsCompressorNode = this.context.createDynamicsCompressor();\n\treadonly input = this._compressor;\n\treadonly output = this._compressor;\n\n\t/**\n\t * The decibel value above which the compression will start taking effect.\n\t */\n\treadonly threshold: Param<Decibels>;\n\n\t/**\n\t * The amount of time (in seconds) to reduce the gain by 10dB.\n\t * @min 0\n\t * @max 1\n\t */\n\treadonly attack: Param<Time>;\n\t\n\t/**\n\t * The amount of time (in seconds) to increase the gain by 10dB.\n\t * @min 0\n\t * @max 1\n\t */\n\treadonly release: Param<Time>;\n\n\t/**\n\t * A decibel value representing the range above the threshold where the\n\t * curve smoothly transitions to the \"ratio\" portion.\n\t * @min 0\n\t * @max 40\n\t */\n\treadonly knee: Param<Decibels>;\n\n\t/**\n\t * The amount of dB change in input for a 1 dB change in output.\n\t * @min 1\n\t * @max 20\n\t */\n\treadonly ratio: Param<Positive>;\n\n\t/**\n\t * @param threshold The value above which the compression starts to be applied.\n\t * @param ratio The gain reduction ratio.\n\t */\n\tconstructor(threshold?: Decibels, ratio?: Positive);\n\tconstructor(options?: Partial<CompressorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Compressor.getDefaults(), arguments, [\"threshold\", \"ratio\"]));\n\t\tconst options = optionsFromArguments(Compressor.getDefaults(), arguments, [\"threshold\", \"ratio\"]);\n\n\t\tthis.threshold = new Param({\n\t\t\tminValue: this._compressor.threshold.minValue,\n\t\t\tmaxValue: this._compressor.threshold.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tconvert: false,\n\t\t\tparam: this._compressor.threshold,\n\t\t\tunits: \"decibels\",\n\t\t\tvalue: options.threshold,\n\t\t});\n\t\t\n\t\tthis.attack = new Param({\n\t\t\tminValue: this._compressor.attack.minValue,\n\t\t\tmaxValue: this._compressor.attack.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tparam: this._compressor.attack,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.attack,\n\t\t});\n\t\t\n\t\tthis.release = new Param({\n\t\t\tminValue: this._compressor.release.minValue,\n\t\t\tmaxValue: this._compressor.release.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tparam: this._compressor.release,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.release,\n\t\t});\n\t\t\n\t\tthis.knee = new Param({\n\t\t\tminValue: this._compressor.knee.minValue,\n\t\t\tmaxValue: this._compressor.knee.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tconvert: false,\n\t\t\tparam: this._compressor.knee,\n\t\t\tunits: \"decibels\",\n\t\t\tvalue: options.knee,\n\t\t});\n\t\t\n\t\tthis.ratio = new Param({\n\t\t\tminValue: this._compressor.ratio.minValue,\n\t\t\tmaxValue: this._compressor.ratio.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tconvert: false,\n\t\t\tparam: this._compressor.ratio,\n\t\t\tunits: \"number\",\n\t\t\tvalue: options.ratio,\n\t\t});\n\n\t\t// set the defaults\n\t\treadOnly(this, [\"knee\", \"release\", \"attack\", \"ratio\", \"threshold\"]);\n\t}\n\n\tstatic getDefaults(): CompressorOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack: 0.003,\n\t\t\tknee: 30,\n\t\t\tratio: 12,\n\t\t\trelease: 0.25,\n\t\t\tthreshold: -24,\n\t\t});\n\t}\n\n\t/**\n\t * A read-only decibel value for metering purposes, representing the current amount of gain\n\t * reduction that the compressor is applying to the signal. If fed no signal the value will be 0 (no gain reduction).\n\t */\n\tget reduction(): number {\n\t\treturn this._compressor.reduction;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._compressor.disconnect();\n\t\tthis.attack.dispose();\n\t\tthis.release.dispose();\n\t\tthis.threshold.dispose();\n\t\tthis.ratio.dispose();\n\t\tthis.knee.dispose();\n\t\treturn this;\n\t}\n}\n","export { getContext, setContext } from \"./core/Global\";\nexport * from \"./classes\";\nimport { getContext } from \"./core/Global\";\nexport { start } from \"./core/Global\";\n\n/**\n * The current audio context time\n * @Category Core\n */\nexport function now(): import(\"./core/type/Units\").Seconds {\n\treturn getContext().now();\n}\n\n/**\n * The Transport object belonging to the global Tone.js Context\n * @Category Core\n */\nexport const Transport = getContext().transport;\n\n/**\n * The Destination (output) belonging to the global Tone.js Context\n * @Category Core\n */\nexport const Destination = getContext().destination;\n"],"sourceRoot":""}