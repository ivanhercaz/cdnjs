"use strict";const i=exports,weCareAbout=e=>null!==e&&(Array.isArray(e)||isObjectLike(e)),isObjectLike=e=>"object"==typeof e&&e.constructor===Object&&Object.getPrototypeOf(e)===Object.prototype,clone=e=>Array.isArray(e)?[...e]:Object.assign({},e),freezeIfNeeded=e=>weCareAbout(e)&&!Object.isFrozen(e)&&"production"!==process.env.NODE_ENV?baseFreeze(e,[]):e,_freeze=e=>"production"===process.env.NODE_ENV?e:"object"==typeof e?Object.freeze(e):e,baseFreeze=(e,r)=>{if(r.some(r=>r===e))throw new Error("object has a reference cycle");return Object.freeze(e),r.push(e),Object.keys(e).forEach(t=>{const s=e[t];weCareAbout(s)&&baseFreeze(s,r)}),r.pop(),e};function baseGet(e,r){return(r||[]).reduce((e,r)=>{if(e)return e[r]},e)}function singleAssign(e,r){return Object.keys(r).reduce((e,t)=>i.assoc(e,t,r[t]),e)}function merge(e,r,t){return null==e||null==r?e:Object.keys(r).reduce((e,s)=>{const o=r[s],n=e[s],c=t?t(n,o,s):o;return weCareAbout(o)&&weCareAbout(n)?(Object.isFrozen(c)&&Object.isFrozen(n)||"production"===process.env.NODE_ENV)&&c===n?e:Array.isArray(o)?i.assoc(e,s,c):assocIfDifferent(e,s,merge(n,c,t)):assocIfDifferent(e,s,c)},e)}function assocIfDifferent(e,r,t){return e[r]===t?e:i.assoc(e,r,t)}exports.freeze=function(e){return"production"===process.env.NODE_ENV?e:baseFreeze(e,[])},exports.thaw=function e(r){if(weCareAbout(r)&&Object.isFrozen(r)){const t=clone(r);return Object.keys(t).forEach(r=>{t[r]=e(t[r])}),t}return r},exports.assoc=function(e,r,t){if(e[r]===t)return _freeze(e);const s=clone(e);return s[r]=freezeIfNeeded(t),_freeze(s)},exports.set=exports.assoc,exports.dissoc=function(e,r){const t=clone(e);return delete t[r],_freeze(t)},exports.unset=exports.dissoc,exports.assocIn=function e(r,t,s){const o=t[0];return 1===t.length?i.assoc(r,o,s):i.assoc(r,o,e(r[o]||{},t.slice(1),s))},exports.setIn=exports.assocIn,exports.getIn=baseGet,exports.updateIn=function(e,r,t){const s=baseGet(e,r);return i.assocIn(e,r,t(s))},["push","unshift","pop","shift","reverse","sort"].forEach(e=>{exports[e]=function(r,t){const s=[...r];return s[e](freezeIfNeeded(t)),_freeze(s)},exports[e].displayName="icepick."+e}),exports.splice=function(e,...r){const t=[...e],s=r.map(freezeIfNeeded);return t.splice.apply(t,s),_freeze(t)},exports.slice=function(e,r,t){const s=e.slice(r,t);return _freeze(s)},["map","filter"].forEach(e=>{exports[e]=function(r,t){const s=t[e](r);return _freeze(s)},exports[e].displayName="icepick."+e}),exports.extend=exports.assign=function(e,...r){const t=r.reduce(singleAssign,e);return _freeze(t)},exports.merge=merge;const chainProto={value:function(){return this.val},thru:function(e){return this.val=freezeIfNeeded(e(this.val)),this}};Object.keys(exports).forEach(e=>{chainProto[e]=function(...r){return r.unshift(this.val),this.val=exports[e].apply(null,r),this}}),exports.chain=function(e){const r=Object.create(chainProto);return r.val=e,r},exports._weCareAbout=weCareAbout;