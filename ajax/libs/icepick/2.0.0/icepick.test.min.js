const expect=require("expect.js"),i=require("../icepick");describe("icepick",function(){"use strict";describe("freeze",function(){it("should work",function(){const e=i.freeze({asdf:"foo",zxcv:{asdf:"bar"}});expect(e.asdf).to.equal("foo"),expect(Object.isFrozen(e)).to.equal(!0),expect(function(){e.asdf="bar"}).to.throwError(),expect(function(){e.zxcv.asdf="qux"}).to.throwError(),expect(function(){e.qwer="bar"}).to.throwError()}),it("should not work with cyclical objects",function(){let e={};e.a=e,expect(i.freeze).withArgs(e).to.throwError(),(e={b:{}}).b.a=e,expect(i.freeze).withArgs(e).to.throwError()})}),describe("thaw",function(){it("should thaw objects",function(){const e=i.freeze({a:{},b:1,c:new function(){},d:[{e:1}]}),t=i.thaw(e);expect(t).to.eql(e),expect(Object.isFrozen(t)).to.be(!1),expect(Object.isFrozen(t.a)).to.be(!1),expect(e.a).to.not.equal(t.a),expect(e.d).to.not.equal(t.d),expect(e.d[0]).to.not.equal(t.d[0]),expect(e.c).to.equal(t.c)})}),describe("assoc",function(){it("should work with objects",function(){const e=i.freeze({a:1,b:2,c:3});let t=i.assoc(e,"b",4);expect(t).to.eql({a:1,b:4,c:3}),t=i.assoc(e,"d",4),expect(t).to.eql({a:1,b:2,c:3,d:4})}),it("should freeze objects you assoc",function(){const e=i.freeze({a:1,b:2,c:3}),t=i.assoc(e,"b",{d:5});expect(t).to.eql({a:1,b:{d:5},c:3}),expect(Object.isFrozen(t.b)).to.be.ok()}),it("should work with arrays",function(){const e=i.freeze([1,2,3]);let t=i.assoc(e,1,4);expect(t).to.eql([1,4,3]),t=i.assoc(e,"1",4),expect(t).to.eql([1,4,3]),t=i.assoc(e,3,4),expect(t).to.eql([1,2,3,4])}),it("should freeze arrays you assoc",function(){const e=i.freeze({a:1,b:2,c:3}),t=i.assoc(e,"b",[1,2]);expect(t).to.eql({a:1,b:[1,2],c:3}),expect(Object.isFrozen(t.b)).to.be.ok()}),it("should return a frozen copy",function(){const e=i.freeze({a:1,b:2,c:3}),t=i.assoc(e,"b",4);expect(t).to.not.equal(e),expect(Object.isFrozen(t)).to.be.ok()}),it("should not modify child objects",function(){const e=i.freeze({a:1,b:2,c:{a:4}}),t=i.assoc(e,"b",4);expect(t.c).to.equal(e.c)}),it("should keep references the same if nothing changes",function(){const e=i.freeze({a:1}),t=i.assoc(e,"a",1);expect(t).to.equal(e)}),it("should be aliased as set",function(){expect(i.set).to.equal(i.assoc)})}),describe("dissoc",function(){it("should work with objecs",function(){const e=i.freeze({a:1,b:2,c:3}),t=i.dissoc(e,"b");expect(t).to.eql({a:1,c:3})}),it("should work with arrays (poorly)",function(){const e=i.freeze([1,2,3]),t=i.dissoc(e,1);expect(Object.keys(t)).to.eql([0,2]),expect(t[0]).to.equal(1),expect(t[1]).to.equal(void 0),expect(t[2]).to.equal(3)}),it("should be aliased as unset",function(){expect(i.unset).to.equal(i.dissoc)})}),describe("assocIn",function(){it("should work recursively",function(){const e=i.freeze({a:1,b:2,c:{a:4}}),t=i.assocIn(e,["c","a"],5);expect(t).to.eql({a:1,b:2,c:{a:5}})}),it("should work recursively (deeper)",function(){const e=i.freeze({a:1,b:{a:2},c:[{a:3,b:4},{a:4}]}),t=i.assocIn(e,["c",0,"a"],8);expect(t.c[0].a).to.equal(8),expect(t).to.not.equal(e),expect(t.b).to.equal(e.b),expect(t.c).to.not.equal(e.c),expect(t.c[0]).to.not.equal(e.c[0]),expect(t.c[0].b).to.equal(e.c[0].b),expect(t.c[1]).to.equal(e.c[1])}),it("should create collections if they don't exist",function(){const e=i.assocIn({},["a","b","c"],1);expect(e).to.eql({a:{b:{c:1}}})}),it("should be aliased as setIn",function(){expect(i.setIn).to.equal(i.assocIn)}),it("should keep references the same if nothing changes",function(){const e=i.freeze({a:{b:1}}),t=i.assocIn(e,["a","b"],1);expect(t).to.equal(e)})}),describe("getIn",function(){it("should work",function(){const e=i.freeze({a:0,b:{a:2},c:[{a:3,b:4},{a:4}]});expect(i.getIn(e,["c",0,"b"])).to.equal(4),expect(i.getIn(e,["a"])).to.equal(0)}),it("should work without a path",function(){const e=i.freeze({a:{b:1}});expect(i.getIn(e)).to.equal(e)}),it("should return undefined for a non-existant path",function(){const e=i.freeze({a:1,b:{a:2},c:[{a:3,b:4},{a:4}]});expect(i.getIn(e,["q"])).to.equal(void 0),expect(i.getIn(e,["a","s","d"])).to.equal(void 0)}),it("should return undefined for a non-existant path (null)",function(){const e=i.freeze({a:null});expect(i.getIn(e,["a","b"])).to.equal(void 0)})}),describe("updateIn",function(){it("should work",function(){const e=i.freeze({a:1,b:2,c:{a:4}}),t=i.updateIn(e,["c","a"],function(e){return 2*e});expect(t).to.eql({a:1,b:2,c:{a:8}})}),it("should create collections if they don't exist",function(){const e=i.updateIn({},["a",1,"c"],function(e){return expect(e).to.be(void 0),1});expect(e).to.eql({a:{1:{c:1}}})}),it("should keep references the same if nothing changes",function(){const e=i.freeze({a:1}),t=i.updateIn(e,["a","b"],function(e){return e});expect(t).to.equal(e)})}),describe("Array methods",function(){it("push",function(){const e=i.freeze([1,2]),t=i.push(e,3);expect(t).to.eql([1,2,3]),expect(Object.isFrozen(t)).to.be.ok()}),it("push (with object)",function(){const e=i.freeze([1,2]),t=i.push(e,{b:1});expect(t).to.eql([1,2,{b:1}]),expect(Object.isFrozen(t)).to.be.ok(),expect(Object.isFrozen(t[2])).to.be.ok()}),it("unshift",function(){const e=i.freeze([1,2]),t=i.unshift(e,3);expect(t).to.eql([3,1,2]),expect(Object.isFrozen(t)).to.be.ok()}),it("unshift (with object)",function(){const e=i.freeze([1,2]),t=i.unshift(e,[0]);expect(t).to.eql([[0],1,2]),expect(Object.isFrozen(t)).to.be.ok(),expect(Object.isFrozen(t[0])).to.be.ok()}),it("pop",function(){const e=i.freeze([1,2]),t=i.pop(e);expect(t).to.eql([1]),expect(Object.isFrozen(t)).to.be.ok()}),it("shift",function(){const e=i.freeze([1,2]),t=i.shift(e);expect(t).to.eql([2]),expect(Object.isFrozen(t)).to.be.ok()}),it("reverse",function(){const e=i.freeze([1,2,3]),t=i.reverse(e);expect(t).to.eql([3,2,1]),expect(Object.isFrozen(t)).to.be.ok()}),it("sort",function(){const e=i.freeze([4,1,2,3]),t=i.sort(e);expect(t).to.eql([1,2,3,4]),expect(Object.isFrozen(t)).to.be.ok()}),it("splice",function(){const e=i.freeze([1,2,3]),t=i.splice(e,1,1,4);expect(t).to.eql([1,4,3]),expect(Object.isFrozen(t)).to.be.ok()}),it("splice (with object)",function(){const e=i.freeze([1,2,3]),t=i.splice(e,1,1,{b:1},{b:2});expect(t).to.eql([1,{b:1},{b:2},3]),expect(Object.isFrozen(t)).to.be.ok(),expect(Object.isFrozen(t[1])).to.be.ok(),expect(Object.isFrozen(t[2])).to.be.ok()}),it("slice",function(){const e=i.freeze([1,2,3]),t=i.slice(e,1,2);expect(t).to.eql([2]),expect(Object.isFrozen(t)).to.be.ok()}),it("map",function(){const e=i.freeze([1,2,3]),t=i.map(function(e){return 2*e},e);expect(t).to.eql([2,4,6]),expect(Object.isFrozen(t)).to.be.ok()}),it("filter",function(){const e=i.freeze([1,2,3]),t=i.filter(function(e){return e%2},e);expect(t).to.eql([1,3]),expect(Object.isFrozen(t)).to.be.ok()})}),describe("assign",function(){it("should work",function(){const e=i.freeze({a:1,b:2,c:3});let t=i.assign(e,{b:3,c:4});expect(t).to.eql({a:1,b:3,c:4}),expect(t).to.not.equal(e),t=i.assign(e,{d:4}),expect(t).to.eql({a:1,b:2,c:3,d:4})}),it("should work with multiple args",function(){const e=i.freeze({a:1,b:2,c:3}),t=i.assign(e,{b:3,c:4},{d:4});expect(t).to.eql({a:1,b:3,c:4,d:4})}),it("should keep references the same if nothing changes",function(){const e=i.freeze({a:1}),t=i.assign(e,{a:1});expect(t).to.equal(e)})}),describe("merge",function(){it("should merge nested objects",function(){const e=i.freeze({a:1,b:{c:1,d:1}}),t=i.freeze({a:1,b:{c:2},e:2}),o=i.merge(e,t);expect(o).to.eql({a:1,b:{c:2,d:1},e:2})}),it("should replace arrays",function(){const e=i.freeze({a:1,b:{c:[1,1]},d:1}),t=i.freeze({a:2,b:{c:[2]}}),o=i.merge(e,t);expect(o).to.eql({a:2,b:{c:[2]},d:1})}),it("should overwrite with nulls",function(){const e=i.freeze({a:1,b:{c:[1,1]}}),t=i.freeze({a:2,b:{c:null}}),o=i.merge(e,t);expect(o).to.eql({a:2,b:{c:null}})}),it("should overwrite primitives with objects",function(){const e=i.freeze({a:1,b:1}),t=i.freeze({a:2,b:{c:2}}),o=i.merge(e,t);expect(o).to.eql({a:2,b:{c:2}})}),it("should overwrite objects with primitives",function(){const e=i.freeze({a:1,b:{c:2}}),t=i.freeze({a:1,b:2}),o=i.merge(e,t);expect(o).to.eql({a:1,b:2})}),it("should keep references the same if nothing changes",function(){const e=i.freeze({a:1,b:{c:1,d:1,e:[1]}}),t=i.freeze({a:1,b:{c:1,d:1,e:e.b.e}}),o=i.merge(e,t);expect(o).to.equal(e),expect(o.b).to.equal(e.b)}),it("should handle undefined parameters",function(){expect(i.merge({},void 0)).to.eql({}),expect(i.merge(void 0,{})).to.eql(void 0)}),describe("custom associator",function(){it("should use the custom associator",function(){const e=i.freeze({a:1,b:{c:[1,1]},d:1}),t=i.freeze({a:2,b:{c:[2]}});const o=i.merge(e,t,function(e,t){return Array.isArray(e)&&t?e.concat(t):t});expect(o).to.eql({a:2,b:{c:[1,1,2]},d:1})})})})}),describe("chain",function(){it("should wrap and unwrap a value",function(){const e=[1,2,3],t=i.chain(e).value();expect(t).to.eql(e)}),it("should work with a simple operation",function(){const e=[1,2,3],t=i.chain(e).assoc(1,4).value();expect(t).to.eql([1,4,3]),expect(t).to.not.equal(e),expect(Object.isFrozen(t)).to.be.ok()}),it("should work with multiple operations",function(){const e=[1,2,3],t=i.chain(e).assoc(1,4).reverse().pop().push(5).value();expect(t).to.eql([3,4,5]),expect(t).to.not.equal(e),expect(Object.isFrozen(t)).to.be.ok()}),it("should work with multiple operations (more complicated)",function(){const e={a:[1,2,3],b:{c:1},d:4},t=i.chain(e).assocIn(["a",2],4).merge({b:{c:2,c2:3}}).assoc("e",2).dissoc("d").value();expect(t).to.eql({a:[1,2,4],b:{c:2,c2:3},e:2}),expect(t).to.not.equal(e),expect(Object.isFrozen(t)).to.be.ok()}),it("should have a thru method",function(){const e=i.chain([1,2]).push(3).thru(function(e){return[0].concat(e)}).value();expect(Object.isFrozen(e)).to.be.ok(),expect(e).to.eql([0,1,2,3])})}),describe("production mode",function(){let e;before(function(){e=process.env.NODE_ENV,process.env.NODE_ENV="production"}),after(function(){process.env.NODE_ENV=e}),it("should not freeze objects",function(){const e=i.freeze({});expect(Object.isFrozen(e)).to.be(!1)}),it("should not freeze objects that are assoc'd",function(){const e=i.assoc({},"a",{});expect(Object.isFrozen(e)).to.be(!1),expect(Object.isFrozen(e.a)).to.be(!1)}),it("merge should keep references the same if nothing changes",function(){const e=i.freeze({a:1,b:{c:1,d:1,e:[1]}}),t=i.freeze({a:1,b:{c:1,d:1,e:e.b.e}}),o=i.merge(e,t);expect(o).to.equal(e),expect(o.b).to.equal(e.b)})}),describe("internals",function(){describe("_weCareAbout",function(){function e(){}it("should care about objects",function(){expect(i._weCareAbout({})).to.equal(!0)}),it("should care about arrays",function(){expect(i._weCareAbout([])).to.equal(!0)}),it("should not care about dates",function(){expect(i._weCareAbout(new Date)).to.equal(!1)}),it("should not care about null",function(){expect(i._weCareAbout(null)).to.equal(!1)}),it("should not care about undefined",function(){expect(i._weCareAbout(void 0)).to.equal(!1)}),it("should not care about class instances",function(){expect(i._weCareAbout(new e)).to.equal(!1)}),it("should not care about objects created with Object.create()",function(){expect(i._weCareAbout(Object.create(e.prototype))).to.equal(!1)}),it("should not care about objects created with Object.create({})",function(){expect(i._weCareAbout(Object.create({foo:function(){}}))).to.equal(!1)})})});