const i=require("./icepick"),tap=require("tap");function test(e,s){tap.test(e,e=>{s(e),e.end()})}test("icepick",e=>{"use strict";test("freeze",e=>{test("should work",e=>{const s=i.freeze({asdf:"foo",zxcv:{asdf:"bar"}});e.equal(s.asdf,"foo"),e.equal(Object.isFrozen(s),!0),e.throws(function(){s.asdf="bar"}),e.throws(function(){s.zxcv.asdf="qux"}),e.throws(function(){s.qwer="bar"})}),test("should not work with cyclical objects",e=>{let s={};s.a=s,e.throws(()=>i.freeze(s)),(s={b:{}}).b.a=s,e.throws(()=>i.freeze(s))})}),test("thaw",e=>{test("should thaw objects",e=>{const s=i.freeze({a:{},b:1,c:new function(){},d:[{e:1}]}),t=i.thaw(s);e.same(t,s),e.equal(Object.isFrozen(t),!1),e.equal(Object.isFrozen(t.a),!1),e.notEqual(s.a,t.a),e.notEqual(s.d,t.d),e.notEqual(s.d[0],t.d[0]),e.equal(s.c,t.c)})}),test("assoc",e=>{test("should work with objects",e=>{const s=i.freeze({a:1,b:2,c:3});let t=i.assoc(s,"b",4);e.same(t,{a:1,b:4,c:3}),t=i.assoc(s,"d",4),e.same(t,{a:1,b:2,c:3,d:4})}),test("should freeze objects you assoc",e=>{const s=i.freeze({a:1,b:2,c:3}),t=i.assoc(s,"b",{d:5});e.same(t,{a:1,b:{d:5},c:3}),e.ok(Object.isFrozen(t.b))}),test("should work with arrays",e=>{const s=i.freeze([1,2,3]);let t=i.assoc(s,1,4);e.same(t,[1,4,3]),t=i.assoc(s,"1",4),e.same(t,[1,4,3]),t=i.assoc(s,3,4),e.same(t,[1,2,3,4])}),test("should freeze arrays you assoc",e=>{const s=i.freeze({a:1,b:2,c:3}),t=i.assoc(s,"b",[1,2]);e.same(t,{a:1,b:[1,2],c:3}),e.ok(Object.isFrozen(t.b))}),test("should return a frozen copy",e=>{const s=i.freeze({a:1,b:2,c:3}),t=i.assoc(s,"b",4);e.notEqual(t,s),e.ok(Object.isFrozen(t))}),test("should not modify child objects",e=>{const s=i.freeze({a:1,b:2,c:{a:4}}),t=i.assoc(s,"b",4);e.equal(t.c,s.c)}),test("should keep references the same if nothing changes",e=>{const s=i.freeze({a:1}),t=i.assoc(s,"a",1);e.equal(t,s)}),test("should be aliased as set",e=>{e.equal(i.set,i.assoc)})}),test("dissoc",e=>{test("should work with objecs",e=>{const s=i.freeze({a:1,b:2,c:3}),t=i.dissoc(s,"b");e.same(t,{a:1,c:3})}),test("should work with arrays (poorly)",e=>{const s=i.freeze([1,2,3]),t=i.dissoc(s,1);e.same(Object.keys(t),[0,2]),e.equal(t[0],1),e.equal(t[1],void 0),e.equal(t[2],3)}),test("should be aliased as unset",e=>{e.equal(i.unset,i.dissoc)})}),test("assocIn",e=>{test("should work recursively",e=>{const s=i.freeze({a:1,b:2,c:{a:4}}),t=i.assocIn(s,["c","a"],5);e.same(t,{a:1,b:2,c:{a:5}})}),test("should work recursively (deeper)",e=>{const s=i.freeze({a:1,b:{a:2},c:[{a:3,b:4},{a:4}]}),t=i.assocIn(s,["c",0,"a"],8);e.equal(t.c[0].a,8),e.notEqual(t,s),e.equal(t.b,s.b),e.notEqual(t.c,s.c),e.notEqual(t.c[0],s.c[0]),e.equal(t.c[0].b,s.c[0].b),e.equal(t.c[1],s.c[1])}),test("should create collections if they don't exist",e=>{const s=i.assocIn({},["a","b","c"],1);e.same(s,{a:{b:{c:1}}})}),test("should be aliased as setIn",e=>{e.equal(i.setIn,i.assocIn)}),test("should keep references the same if nothing changes",e=>{const s=i.freeze({a:{b:1}}),t=i.assocIn(s,["a","b"],1);e.equal(t,s)})}),test("dissocIn",e=>{test("should work recursively",e=>{const s=i.freeze({a:1,b:2,c:{a:4}}),t=i.dissocIn(s,["c","a"]);e.same(t,{a:1,b:2,c:{}})}),test("should work recursively (deeper)",e=>{const s=i.freeze({a:1,b:{a:2},c:[{a:3,b:4},{a:4}]}),t=i.dissocIn(s,["c",0,"a"]);e.equal(t.c[0].a,void 0),e.notEqual(t,s),e.equal(t.b,s.b),e.notEqual(t.c,s.c),e.notEqual(t.c[0],s.c[0]),e.equal(t.c[0].b,s.c[0].b),e.equal(t.c[1],s.c[1])}),test("should not create collections if they don't exist",e=>{const s=i.dissocIn({},["a","b","c"]);e.same(s,{})}),test("should be aliased as unsetIn",e=>{e.equal(i.unsetIn,i.dissocIn)}),test("should keep references the same if nothing changes",e=>{const s=i.freeze({a:{b:1}}),t=i.dissocIn(s,["a","b","c"]);e.equal(t,s)})}),test("getIn",e=>{test("should work",e=>{const s=i.freeze({a:0,b:{a:2},c:[{a:3,b:4},{a:4}]});e.equal(i.getIn(s,["c",0,"b"]),4),e.equal(i.getIn(s,["a"]),0)}),test("should work without a path",e=>{const s=i.freeze({a:{b:1}});e.equal(i.getIn(s),s)}),test("should return undefined for a non-existant path",e=>{const s=i.freeze({a:1,b:{a:2},c:[{a:3,b:4},{a:4}]});e.equal(i.getIn(s,["q"]),void 0),e.equal(i.getIn(s,["a","s","d"]),void 0)}),test("should return undefined for a non-existant path (null)",e=>{const s=i.freeze({a:null});e.equal(i.getIn(s,["a","b"]),void 0)})}),test("updateIn",e=>{test("should work",e=>{const s=i.freeze({a:1,b:2,c:{a:4}}),t=i.updateIn(s,["c","a"],function(e){return 2*e});e.same(t,{a:1,b:2,c:{a:8}})}),test("should create collections if they don't exist",e=>{const s=i.updateIn({},["a",1,"c"],function(s){return e.equal(s,void 0),1});e.same(s,{a:{1:{c:1}}})}),test("should keep references the same if nothing changes",e=>{const s=i.freeze({a:1}),t=i.updateIn(s,["a","b"],function(e){return e});e.equal(t,s)})}),test("Array methods",e=>{test("push",e=>{const s=i.freeze([1,2]),t=i.push(s,3);e.same(t,[1,2,3]),e.ok(Object.isFrozen(t))}),test("push (with object)",e=>{const s=i.freeze([1,2]),t=i.push(s,{b:1});e.same(t,[1,2,{b:1}]),e.ok(Object.isFrozen(t)),e.ok(Object.isFrozen(t[2]))}),test("unshift",e=>{const s=i.freeze([1,2]),t=i.unshift(s,3);e.same(t,[3,1,2]),e.ok(Object.isFrozen(t))}),test("unshift (with object)",e=>{const s=i.freeze([1,2]),t=i.unshift(s,[0]);e.same(t,[[0],1,2]),e.ok(Object.isFrozen(t)),e.ok(Object.isFrozen(t[0]))}),test("pop",e=>{const s=i.freeze([1,2]),t=i.pop(s);e.same(t,[1]),e.ok(Object.isFrozen(t))}),test("shift",e=>{const s=i.freeze([1,2]),t=i.shift(s);e.same(t,[2]),e.ok(Object.isFrozen(t))}),test("reverse",e=>{const s=i.freeze([1,2,3]),t=i.reverse(s);e.same(t,[3,2,1]),e.ok(Object.isFrozen(t))}),test("sort",e=>{const s=i.freeze([4,1,2,3]),t=i.sort(s);e.same(t,[1,2,3,4]),e.ok(Object.isFrozen(t))}),test("splice",e=>{const s=i.freeze([1,2,3]),t=i.splice(s,1,1,4);e.same(t,[1,4,3]),e.ok(Object.isFrozen(t))}),test("splice (with object)",e=>{const s=i.freeze([1,2,3]),t=i.splice(s,1,1,{b:1},{b:2});e.same(t,[1,{b:1},{b:2},3]),e.ok(Object.isFrozen(t)),e.ok(Object.isFrozen(t[1])),e.ok(Object.isFrozen(t[2]))}),test("slice",e=>{const s=i.freeze([1,2,3]),t=i.slice(s,1,2);e.same(t,[2]),e.ok(Object.isFrozen(t))}),test("map",e=>{const s=i.freeze([1,2,3]),t=i.map(function(e){return 2*e},s);e.same(t,[2,4,6]),e.ok(Object.isFrozen(t))}),test("filter",e=>{const s=i.freeze([1,2,3]),t=i.filter(function(e){return e%2},s);e.same(t,[1,3]),e.ok(Object.isFrozen(t))})}),test("assign",e=>{test("should work",e=>{const s=i.freeze({a:1,b:2,c:3});let t=i.assign(s,{b:3,c:4});e.same(t,{a:1,b:3,c:4}),e.notEqual(t,s),t=i.assign(s,{d:4}),e.same(t,{a:1,b:2,c:3,d:4})}),test("should work with multiple args",e=>{const s=i.freeze({a:1,b:2,c:3}),t=i.assign(s,{b:3,c:4},{d:4});e.same(t,{a:1,b:3,c:4,d:4})}),test("should keep references the same if nothing changes",e=>{const s=i.freeze({a:1}),t=i.assign(s,{a:1});e.equal(t,s)})}),test("merge",e=>{test("should merge nested objects",e=>{const s=i.freeze({a:1,b:{c:1,d:1}}),t=i.freeze({a:1,b:{c:2},e:2}),a=i.merge(s,t);e.same(a,{a:1,b:{c:2,d:1},e:2})}),test("should replace arrays",e=>{const s=i.freeze({a:1,b:{c:[1,1]},d:1}),t=i.freeze({a:2,b:{c:[2]}}),a=i.merge(s,t);e.same(a,{a:2,b:{c:[2]},d:1})}),test("should overwrite with nulls",e=>{const s=i.freeze({a:1,b:{c:[1,1]}}),t=i.freeze({a:2,b:{c:null}}),a=i.merge(s,t);e.same(a,{a:2,b:{c:null}})}),test("should overwrite primitives with objects",e=>{const s=i.freeze({a:1,b:1}),t=i.freeze({a:2,b:{c:2}}),a=i.merge(s,t);e.same(a,{a:2,b:{c:2}})}),test("should overwrite objects with primitives",e=>{const s=i.freeze({a:1,b:{c:2}}),t=i.freeze({a:1,b:2}),a=i.merge(s,t);e.same(a,{a:1,b:2})}),test("should keep references the same if nothing changes",e=>{const s=i.freeze({a:1,b:{c:1,d:1,e:[1]}}),t=i.freeze({a:1,b:{c:1,d:1,e:s.b.e}}),a=i.merge(s,t);e.equal(a,s),e.equal(a.b,s.b)}),test("should handle undefined parameters",e=>{e.same(i.merge({},void 0),{}),e.same(i.merge(void 0,{}),void 0)}),test("custom associator",e=>{test("should use the custom associator",e=>{const s=i.freeze({a:1,b:{c:[1,1]},d:1}),t=i.freeze({a:2,b:{c:[2]}});const a=i.merge(s,t,function(e,s){return Array.isArray(e)&&s?e.concat(s):s});e.same(a,{a:2,b:{c:[1,1,2]},d:1})})})})}),test("chain",e=>{test("should wrap and unwrap a value",e=>{const s=[1,2,3],t=i.chain(s).value();e.same(t,s)}),test("should work with a simple operation",e=>{const s=[1,2,3],t=i.chain(s).assoc(1,4).value();e.same(t,[1,4,3]),e.notEqual(t,s),e.ok(Object.isFrozen(t))}),test("should work with multiple operations",e=>{const s=[1,2,3],t=i.chain(s).assoc(1,4).reverse().pop().push(5).value();e.same(t,[3,4,5]),e.notEqual(t,s),e.ok(Object.isFrozen(t))}),test("should work with multiple operations (more complicated)",e=>{const s={a:[1,2,3],b:{c:1},d:4},t=i.chain(s).assocIn(["a",2],4).merge({b:{c:2,c2:3}}).assoc("e",2).dissoc("d").value();e.same(t,{a:[1,2,4],b:{c:2,c2:3},e:2}),e.notEqual(t,s),e.ok(Object.isFrozen(t))}),test("should have a thru method",e=>{const s=i.chain([1,2]).push(3).thru(function(e){return[0].concat(e)}).value();e.ok(Object.isFrozen(s)),e.same(s,[0,1,2,3])}),test("should work with map and filter",e=>{const s=i.chain([1,2,3]).map(e=>2*e).filter(e=>e>2).value();e.ok(Object.isFrozen(s)),e.same(s,[4,6])})}),test("production mode",e=>{let s;s=process.env.NODE_ENV,process.env.NODE_ENV="production",delete require.cache[require.resolve("./icepick")];const t=require("./icepick");e.tearDown(function(){process.env.NODE_ENV=s}),test("should not freeze objects",e=>{const s=t.freeze({});e.equal(Object.isFrozen(s),!1)}),test("should not freeze objects that are assoc'd",e=>{const s=t.assoc({},"a",{});e.equal(Object.isFrozen(s),!1),e.equal(Object.isFrozen(s.a),!1)}),test("merge should keep references the same if nothing changes",e=>{const s=t.freeze({a:1,b:{c:1,d:1,e:[1]}}),a=t.freeze({a:1,b:{c:1,d:1,e:s.b.e}}),o=t.merge(s,a);e.equal(o,s),e.equal(o.b,s.b)})}),test("internals",e=>{test("_weCareAbout",e=>{function s(){}test("should care about objects",e=>{e.equal(i._weCareAbout({}),!0)}),test("should care about arrays",e=>{e.equal(i._weCareAbout([]),!0)}),test("should not care about dates",e=>{e.equal(i._weCareAbout(new Date),!1)}),test("should not care about null",e=>{e.equal(i._weCareAbout(null),!1)}),test("should not care about undefined",e=>{e.equal(i._weCareAbout(void 0),!1)}),test("should not care about class instances",e=>{e.equal(i._weCareAbout(new s),!1)}),test("should not care about class instances (2)",e=>{e.equal(i._weCareAbout(new class{}),!1)}),test("should not care about objects created with Object.create()",e=>{e.equal(i._weCareAbout(Object.create(s.prototype)),!1)}),test("should not care about objects created with Object.create({})",e=>{e.equal(i._weCareAbout(Object.create({foo:function(){}})),!1)})})});