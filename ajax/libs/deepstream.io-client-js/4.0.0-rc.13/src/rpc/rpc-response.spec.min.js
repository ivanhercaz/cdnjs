"use strict";var __awaiter=this&&this.__awaiter||function(o,r,a,i){return new(a=a||Promise)(function(e,t){function n(e){try{c(i.next(e))}catch(e){t(e)}}function s(e){try{c(i.throw(e))}catch(e){t(e)}}function c(t){t.done?e(t.value):new a(function(e){e(t.value)}).then(n,s)}c((i=i.apply(o,r||[])).next())})},__generator=this&&this.__generator||function(n,s){var c,o,r,e,a={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return e={next:t(0),throw:t(1),return:t(2)},"function"==typeof Symbol&&(e[Symbol.iterator]=function(){return this}),e;function t(t){return function(e){return function(t){if(c)throw new TypeError("Generator is already executing.");for(;a;)try{if(c=1,o&&(r=2&t[0]?o.return:t[0]?o.throw||((r=o.return)&&r.call(o),0):o.next)&&!(r=r.call(o,t[1])).done)return r;switch(o=0,r&&(t=[2&t[0],r.value]),t[0]){case 0:case 1:r=t;break;case 4:return a.label++,{value:t[1],done:!1};case 5:a.label++,o=t[1],t=[0];continue;case 7:t=a.ops.pop(),a.trys.pop();continue;default:if(!(r=0<(r=a.trys).length&&r[r.length-1])&&(6===t[0]||2===t[0])){a=0;continue}if(3===t[0]&&(!r||t[1]>r[0]&&t[1]<r[3])){a.label=t[1];break}if(6===t[0]&&a.label<r[1]){a.label=r[1],r=t;break}if(r&&a.label<r[2]){a.label=r[2],a.ops.push(t);break}r[2]&&a.ops.pop(),a.trys.pop();continue}t=s.call(n,a)}catch(e){t=[6,e],o=0}finally{c=r=0}if(5&t[0])throw t[1];return{value:t[0]?t[1]:void 0,done:!0}}([t,e])}}},_this=this;Object.defineProperty(exports,"__esModule",{value:!0});var chai_1=require("chai"),mocks_1=require("../test/mocks"),message_constants_1=require("../../binary-protocol/src/message-constants"),client_options_1=require("../client-options"),rpc_response_1=require("./rpc-response"),bluebird_1=require("bluebird");describe("RPC response",function(){var t,n,s="myRPC",c="correlationId";beforeEach(function(){t=mocks_1.getServicesMock(),(n=new rpc_response_1.RPCResponse({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST,name:s,correlationId:c},client_options_1.DefaultOptions,t)).autoAccept=!1}),afterEach(function(){t.connectionMock.verify()}),it("doesn't accept automatically when autoAccept == false",function(){return __awaiter(_this,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return t.connectionMock.expects("sendMessage").never(),[4,bluebird_1.Promise.delay(2)];case 1:return e.sent(),[2]}})})}),it("sends an accept message automatically when autoAccept == true ",function(){return __awaiter(_this,void 0,void 0,function(){return __generator(this,function(e){switch(e.label){case 0:return t.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:s,correlationId:c}),n.autoAccept=!0,[4,bluebird_1.Promise.delay(2)];case 1:return e.sent(),[2]}})})}),it("sends an accept message manually",function(){t.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:s,correlationId:c}),n.accept()}),it("sends the response message but accepts the rpc before when it is not accepted yet",function(){var e={foo:"bar"};t.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:s,correlationId:c}),t.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.RESPONSE,name:s,correlationId:c,parsedData:e}),n.send(e)}),it("throws when trying to send a completed response",function(){var e={foo:"bar"};t.connectionMock.expects("sendMessage").twice(),n.send(e),chai_1.expect(n.send.bind(n,e)).to.throw("Rpc myRPC already completed")}),it("doesn't send multiple accept messages",function(){t.connectionMock.expects("sendMessage").once(),n.accept(),n.accept()}),it("sends reject message",function(){t.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REJECT,name:s,correlationId:c}),n.reject()}),it("doesn't send reject message twice and throws error",function(){t.connectionMock.expects("sendMessage").once(),n.reject(),chai_1.expect(n.reject.bind(n)).to.throw("Rpc myRPC already completed")}),it("sends error message",function(){var e="error";t.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST_ERROR,name:s,correlationId:c,parsedData:e}),n.error(e)}),it("doesn't send error message twice and throws error",function(){var e="error";t.connectionMock.expects("sendMessage").once(),n.error(e),chai_1.expect(n.error.bind(n,e)).to.throw("Rpc myRPC already completed")})});