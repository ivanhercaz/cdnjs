"use strict";var __awaiter=this&&this.__awaiter||function(e,s,n,t){return new(n||(n=Promise))(function(a,o){function i(e){try{r(t.next(e))}catch(e){o(e)}}function c(e){try{r(t.throw(e))}catch(e){o(e)}}function r(e){e.done?a(e.value):new n(function(s){s(e.value)}).then(i,c)}r((t=t.apply(e,s||[])).next())})};Object.defineProperty(exports,"__esModule",{value:!0});const bluebird_1=require("bluebird"),chai_1=require("chai"),sinon=require("sinon"),mocks_1=require("../mocks"),constants_1=require("../../src/constants"),message_constants_1=require("../../binary-protocol/src/message-constants"),client_options_1=require("../../src/client-options"),rpc_handler_1=require("../../src/rpc/rpc-handler"),rpc_response_1=require("../../src/rpc/rpc-response"),timeout_registry_1=require("../../src/util/timeout-registry");describe("RPC handler",()=>{let e,s,n,t,a;const o="myRpc",i=Object.assign({},client_options_1.DefaultOptions,{rpcAcceptTimeout:3,rpcResponseTimeout:10});beforeEach(()=>{e=mocks_1.getServicesMock(),s=new rpc_handler_1.RPCHandler(e,i),n=e.getHandle(),t=sinon.spy(),a={foo:"bar"}}),afterEach(()=>{e.connectionMock.verify(),e.timeoutRegistryMock.verify(),e.loggerMock.verify()}),it("validates parameters on provide, unprovide and make",()=>{chai_1.expect(s.provide.bind(s,"",()=>{})).to.throw(),chai_1.expect(s.provide.bind(s,123,()=>{})).to.throw(),chai_1.expect(s.provide.bind(s,null,()=>{})).to.throw(),chai_1.expect(s.provide.bind(s,o,null)).to.throw(),chai_1.expect(s.provide.bind(s,o,123)).to.throw(),chai_1.expect(s.unprovide.bind(s,"")).to.throw(),chai_1.expect(s.unprovide.bind(s,123)).to.throw(),chai_1.expect(s.unprovide.bind(s,null)).to.throw(),chai_1.expect(s.unprovide.bind(s)).to.throw(),chai_1.expect(s.make.bind(s,"")).to.throw(),chai_1.expect(s.make.bind(s,123)).to.throw(),chai_1.expect(s.make.bind(s,null)).to.throw(),chai_1.expect(s.make.bind(s,o,{},{})).to.throw(),chai_1.expect(s.make.bind(s,o,{},123)).to.throw(),chai_1.expect(s.make.bind(s)).to.throw()}),it("registers a provider",()=>{const n={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.PROVIDE,name:o};e.connectionMock.expects("sendMessage").once().withExactArgs(n),e.timeoutRegistryMock.expects("add").once().withExactArgs({message:n}),s.provide(o,t),sinon.assert.notCalled(t)}),it("reregisters a provider after a connection reconnection",()=>{const n={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.PROVIDE,name:o};e.connectionMock.expects("sendMessage").twice().withExactArgs(n),e.timeoutRegistryMock.expects("add").twice().withExactArgs({message:n}),s.provide(o,t),e.simulateConnectionReestablished(),sinon.assert.notCalled(t)}),it("sends rpc request message on make",()=>{e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST,name:o,parsedData:a,correlationId:sinon.match.any}),s.make(o,a,()=>{})}),it("returns promise on make when no callback is passed",()=>{e.connectionMock.expects("sendMessage").once();const n=s.make(o,a);chai_1.expect(n).to.be.a("promise")}),it("cant't make requests when client is offline",()=>__awaiter(this,void 0,void 0,function*(){const n=sinon.spy(),t=sinon.spy(),i=sinon.spy();e.connection.isConnected=!1,e.connectionMock.expects("sendMessage").never(),s.make(o,a,n),s.make(o,a).then(i).catch(t),yield bluebird_1.Promise.delay(0),sinon.assert.calledOnce(n),sinon.assert.calledWithExactly(n,constants_1.EVENT.CLIENT_OFFLINE),sinon.assert.notCalled(i),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,constants_1.EVENT.CLIENT_OFFLINE)})),it("doesn't reply rpc and sends rejection if no provider exists",()=>{e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REJECT,name:o,correlationId:"123"}),e.timeoutRegistryMock.expects("add").never(),n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST,name:o,parsedData:a,correlationId:"123"})}),it("handles ack messages",()=>{const s={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.PROVIDE_ACK,name:o,isAck:!0};e.timeoutRegistryMock.expects("remove").once().withExactArgs(s),n(s)}),it("handles permission and message denied errors for provide and unprovide",()=>{const s=s=>{e.timeoutRegistryMock.expects("remove").once().withExactArgs(s),e.loggerMock.expects("error").once().withExactArgs(s)},t={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.MESSAGE_PERMISSION_ERROR,name:o,originalAction:message_constants_1.RPC_ACTIONS.PROVIDE},a={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.MESSAGE_PERMISSION_ERROR,name:o,originalAction:message_constants_1.RPC_ACTIONS.UNPROVIDE},i={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.MESSAGE_DENIED,name:o,originalAction:message_constants_1.RPC_ACTIONS.PROVIDE},c={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.MESSAGE_DENIED,name:o,originalAction:message_constants_1.RPC_ACTIONS.UNPROVIDE};s(t),s(a),s(i),s(c),n(t),n(a),n(i),n(c)}),it("logs unknown correlation error when handling unknown rpc response",()=>{const s={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:o,correlationId:"123abc"};e.loggerMock.expects("error").once().withExactArgs(s,constants_1.EVENT.UNKNOWN_CORRELATION_ID),n(s)}),describe("when providing",()=>{beforeEach(()=>{s.provide(o,t)}),it("doesn't register provider twice",()=>{e.connectionMock.expects("sendMessage").never(),e.timeoutRegistryMock.expects("add").never(),chai_1.expect(s.provide.bind(s,o,t)).to.throw("RPC myRpc already registered")}),it("triggers rpc provider callback in a new request",()=>{const s={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST,name:o,parsedData:a,correlationId:"123"},c=new rpc_response_1.RPCResponse(s,i,e);n(s),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,a,c)}),it("deregisters providers",()=>{const n={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.UNPROVIDE,name:o};e.connectionMock.expects("sendMessage").once().withExactArgs(n),e.timeoutRegistryMock.expects("add").once().withExactArgs({message:n}),s.unprovide(o)}),it("doesn't send deregister provider message twice",()=>{e.connectionMock.expects("sendMessage").once(),e.timeoutRegistryMock.expects("add").once(),e.loggerMock.expects("warn").once(),s.unprovide(o),s.unprovide(o)})}),describe("when making",()=>{let t,c,r,_,l,d;beforeEach(()=>{e.timeoutRegistry=new timeout_registry_1.TimeoutRegistry(e,i),t=sinon.spy(),s.make(o,a,t),l=mocks_1.getLastMessageSent().correlationId,r=sinon.spy(),_=sinon.spy(),(c=s.make(o,a)).then(r).catch(_),d=mocks_1.getLastMessageSent().correlationId}),it("handles permission errors",()=>__awaiter(this,void 0,void 0,function*(){const e=message_constants_1.RPC_ACTIONS.MESSAGE_PERMISSION_ERROR,s=s=>n({topic:message_constants_1.TOPIC.RPC,action:e,name:o,originalAction:message_constants_1.RPC_ACTIONS.REQUEST,correlationId:s});s(l),s(d),yield bluebird_1.Promise.delay(6),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,message_constants_1.RPC_ACTIONS[e]),sinon.assert.notCalled(r),sinon.assert.calledOnce(_),sinon.assert.calledWithExactly(_,message_constants_1.RPC_ACTIONS[e])})),it("handles message denied errors",()=>__awaiter(this,void 0,void 0,function*(){const e=message_constants_1.RPC_ACTIONS.MESSAGE_DENIED,s=s=>n({topic:message_constants_1.TOPIC.RPC,action:e,name:o,originalAction:message_constants_1.RPC_ACTIONS.REQUEST,correlationId:s});s(l),s(d),yield bluebird_1.Promise.delay(6),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,message_constants_1.RPC_ACTIONS[e]),sinon.assert.notCalled(r),sinon.assert.calledOnce(_),sinon.assert.calledWithExactly(_,message_constants_1.RPC_ACTIONS[e])})),it("responds rpc with error when request is not accepted in time",()=>__awaiter(this,void 0,void 0,function*(){yield bluebird_1.Promise.delay(6),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,message_constants_1.RPC_ACTIONS[message_constants_1.RPC_ACTIONS.ACCEPT_TIMEOUT]),sinon.assert.notCalled(r),sinon.assert.calledOnce(_),sinon.assert.calledWithExactly(_,message_constants_1.RPC_ACTIONS[message_constants_1.RPC_ACTIONS.ACCEPT_TIMEOUT])})),it("handles the rpc response accepted message",()=>__awaiter(this,void 0,void 0,function*(){const e=e=>n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:o,correlationId:e});e(l),e(d),yield bluebird_1.Promise.delay(6),sinon.assert.notCalled(t),sinon.assert.notCalled(_),sinon.assert.notCalled(r)})),it("calls rpcResponse with error when response is not sent in time",()=>__awaiter(this,void 0,void 0,function*(){const e=e=>n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:o,correlationId:e});e(l),e(d),yield bluebird_1.Promise.delay(20),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,message_constants_1.RPC_ACTIONS[message_constants_1.RPC_ACTIONS.RESPONSE_TIMEOUT]),sinon.assert.notCalled(r),sinon.assert.calledOnce(_),sinon.assert.calledWithExactly(_,message_constants_1.RPC_ACTIONS[message_constants_1.RPC_ACTIONS.RESPONSE_TIMEOUT])})),it("calls rpcResponse with error when no rpc provider is returned",()=>__awaiter(this,void 0,void 0,function*(){const e=e=>n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:o,correlationId:e});e(l),e(d),n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER,name:o,correlationId:l}),n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER,name:o,correlationId:d}),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,message_constants_1.RPC_ACTIONS[message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER]),yield bluebird_1.Promise.delay(0),sinon.assert.notCalled(r),sinon.assert.calledOnce(_),sinon.assert.calledWithExactly(_,message_constants_1.RPC_ACTIONS[message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER])})),it("handles the rpc response RESPONSE message",()=>__awaiter(this,void 0,void 0,function*(){const e=e=>n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.RESPONSE,name:o,correlationId:e,parsedData:a});e(l),e(d),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,null,a),yield bluebird_1.Promise.delay(0),sinon.assert.notCalled(_),sinon.assert.calledOnce(r),sinon.assert.calledWithExactly(r,a)})),it("doesn't call rpc response callback twice when handling response message",()=>__awaiter(this,void 0,void 0,function*(){const e=e=>n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.RESPONSE,name:o,correlationId:e,parsedData:a});e(l),e(l),e(d),e(d),yield bluebird_1.Promise.delay(20),sinon.assert.calledOnce(t),sinon.assert.notCalled(_),sinon.assert.calledOnce(r)})),it("handles the rpc response error message",()=>__awaiter(this,void 0,void 0,function*(){const e=e=>n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST_ERROR,name:o,correlationId:e,parsedData:"ERROR"});e(l),e(d),yield bluebird_1.Promise.delay(20),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,"ERROR"),sinon.assert.notCalled(r),sinon.assert.calledOnce(_),sinon.assert.calledWithExactly(_,"ERROR")})),it("doesn't call rpc response callback twice when handling error message",()=>__awaiter(this,void 0,void 0,function*(){const e=e=>n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST_ERROR,name:o,correlationId:e,parsedData:"ERROR"});e(l),e(l),e(d),e(d),yield bluebird_1.Promise.delay(20),sinon.assert.calledOnce(t),sinon.assert.notCalled(r),sinon.assert.calledOnce(_)})),it("responds with error when onConnectionLost",()=>__awaiter(this,void 0,void 0,function*(){e.simulateConnectionLost(),yield bluebird_1.Promise.delay(1),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,constants_1.EVENT.CLIENT_OFFLINE),sinon.assert.notCalled(r),sinon.assert.calledOnce(_),sinon.assert.calledWithExactly(_,constants_1.EVENT.CLIENT_OFFLINE)}))})});