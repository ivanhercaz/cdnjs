"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const chai_1=require("chai"),mocks_1=require("../mocks"),message_constants_1=require("../../binary-protocol/src/message-constants"),client_options_1=require("../../src/client-options"),rpc_response_1=require("../../src/rpc/rpc-response");describe("RPC response",()=>{let e,s;const t="myRPC";beforeEach(()=>{e=mocks_1.getServicesMock(),(s=new rpc_response_1.RPCResponse({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST,name:t,correlationId:"correlationId"},client_options_1.DefaultOptions,e)).autoAccept=!1}),afterEach(()=>{e.connectionMock.verify()}),it("doesn't accept automatically when autoAccept == false",s=>{e.connectionMock.expects("sendMessage").never(),process.nextTick(s)}),it("sends an accept message automatically when autoAccept == true ",c=>{e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:t,correlationId:"correlationId"}),s.autoAccept=!0,process.nextTick(c)}),it("sends an accept message manually",()=>{e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:t,correlationId:"correlationId"}),s.accept()}),it("sends the response message but accepts the rpc before when it is not accepted yet",()=>{const c={foo:"bar"};e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:t,correlationId:"correlationId"}),e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.RESPONSE,name:t,correlationId:"correlationId",parsedData:c}),s.send(c)}),it("throws when trying to send a completed response",()=>{const t={foo:"bar"};e.connectionMock.expects("sendMessage").twice(),s.send(t),chai_1.expect(s.send.bind(s,t)).to.throw("Rpc myRPC already completed")}),it("doesn't send multiple accept messages",()=>{e.connectionMock.expects("sendMessage").once(),s.accept(),s.accept()}),it("sends reject message",()=>{e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REJECT,name:t,correlationId:"correlationId"}),s.reject()}),it("doesn't send reject message twice and throws error",()=>{e.connectionMock.expects("sendMessage").once(),s.reject(),chai_1.expect(s.reject.bind(s)).to.throw("Rpc myRPC already completed")}),it("sends error message",()=>{e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST_ERROR,name:t,correlationId:"correlationId",parsedData:"error"}),s.error("error")}),it("doesn't send error message twice and throws error",()=>{e.connectionMock.expects("sendMessage").once(),s.error("error"),chai_1.expect(s.error.bind(s,"error")).to.throw("Rpc myRPC already completed")})});