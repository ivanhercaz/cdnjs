"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const chai_1=require("chai"),sinon=require("sinon"),mocks_1=require("../mocks"),message_constants_1=require("../../binary-protocol/src/message-constants"),constants_1=require("../../src/constants"),listener_1=require("../../src/util/listener");describe("listener",()=>{let e,s,t;beforeEach(()=>{t=sinon.stub(),e=mocks_1.getServicesMock(),s=new listener_1.Listener(message_constants_1.TOPIC.EVENT,e)}),afterEach(()=>{e.connectionMock.verify(),e.loggerMock.verify(),e.timeoutRegistryMock.verify()}),it("validates parameters on listen and unlisten",()=>{chai_1.expect(s.listen.bind(s,"",t)).to.throw(),chai_1.expect(s.listen.bind(s,1,t)).to.throw(),chai_1.expect(s.listen.bind(s,".*",null)).to.throw(),chai_1.expect(s.unlisten.bind(s,"")).to.throw(),chai_1.expect(s.unlisten.bind(s,1)).to.throw()}),it("sends event listen message",()=>{const n={topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.LISTEN,name:".*"};e.connectionMock.expects("sendMessage").once().withExactArgs(n),e.timeoutRegistryMock.expects("add").once().withExactArgs({message:n}),s.listen(".*",t)}),it("sends record listen message",()=>{s=new listener_1.Listener(message_constants_1.TOPIC.RECORD,e);const n={topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.LISTEN,name:".*"};e.connectionMock.expects("sendMessage").once().withExactArgs(n),e.timeoutRegistryMock.expects("add").once().withExactArgs({message:n}),s.listen(".*",t)}),it("resubscribes all patterns when connection reestablished",()=>{s=new listener_1.Listener(message_constants_1.TOPIC.RECORD,e);const n={topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.LISTEN,name:".*"};e.connectionMock.expects("sendMessage").twice().withExactArgs(n),e.timeoutRegistryMock.expects("add").twice().withExactArgs({message:n}),s.listen(".*",t),e.simulateConnectionReestablished()}),describe("when a pattern is listened to",()=>{beforeEach(()=>{s.listen(".*",t),e.connectionMock.restore(),e.timeoutRegistryMock.restore()}),it("warns if listen invoked more than once",()=>{e.loggerMock.expects("warn").once().withExactArgs({topic:message_constants_1.TOPIC.EVENT,action:constants_1.EVENT.LISTENER_EXISTS,name:".*"}),s.listen(".*",t)}),it("sends unlisten message when unlistened",()=>{const t={topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.UNLISTEN,name:".*"};e.connectionMock.expects("sendMessage").once().withExactArgs(t),e.timeoutRegistryMock.expects("add").once().withExactArgs({message:t}),s.unlisten(".*")}),it("warns if unlisten invoked more than once",()=>{e.loggerMock.expects("warn").once().withExactArgs({topic:message_constants_1.TOPIC.EVENT,action:constants_1.EVENT.NOT_LISTENING,name:".*"}),s.unlisten(".*"),s.unlisten(".*")}),it("logs unsolicited message if an unknown message is recieved",()=>{const t={topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.EMIT,name:".*",subscription:"subscription"};e.loggerMock.expects("error").once().withExactArgs(t,constants_1.EVENT.UNSOLICITED_MESSAGE),s.handle(t)}),describe("gets a subscription for pattern found",()=>{let n;beforeEach(()=>{s.handle({topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND,name:".*",subscription:"subscription"}),n=t.lastCall.args[1]}),it("calls the listen callback",()=>{sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,"subscription",sinon.match.any)}),it("responds with accept",()=>{e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.LISTEN_ACCEPT,name:".*",subscription:"subscription"}),n.accept()}),it("responds with reject",()=>{e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.LISTEN_REJECT,name:".*",subscription:"subscription"}),n.reject()}),it("calls onStop subscription for pattern removed",()=>{const e=sinon.spy();n.onStop(e),n.accept(),s.handle({topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED,name:".*",subscription:"subscription"}),sinon.assert.calledOnce(e),sinon.assert.calledWithExactly(e,"subscription")}),it("deletes onStop callback once called",()=>{const e=sinon.spy();n.onStop(e),n.accept(),s.handle({topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED,name:".*",subscription:"subscription"}),sinon.assert.calledOnce(e),sinon.assert.calledWithExactly(e,"subscription")}),it("triggers all stop callbacks when connection lost",()=>{const s=sinon.spy();n.onStop(s),n.accept(),e.simulateConnectionLost(),sinon.assert.calledOnce(s),sinon.assert.calledWithExactly(s,"subscription")})})})});