"use strict";var __awaiter=this&&this.__awaiter||function(e,s,t,n){return new(t||(t=Promise))(function(i,o){function a(e){try{r(n.next(e))}catch(e){o(e)}}function c(e){try{r(n.throw(e))}catch(e){o(e)}}function r(e){e.done?i(e.value):new t(function(s){s(e.value)}).then(a,c)}r((n=n.apply(e,s||[])).next())})};Object.defineProperty(exports,"__esModule",{value:!0});const bluebird_1=require("bluebird"),sinon_1=require("sinon"),mocks_1=require("../mocks"),constants_1=require("../../src/constants"),message_constants_1=require("../../binary-protocol/src/message-constants"),single_notifier_1=require("../../src/record/single-notifier");describe("Single Notifier",()=>{const e=message_constants_1.TOPIC.RECORD,s=message_constants_1.RECORD_ACTIONS.READ,t="name";let n,i,o,a,c;beforeEach(()=>{n=mocks_1.getServicesMock(),i=new single_notifier_1.SingleNotifier(n,e,s,10),o=sinon_1.spy(),a=sinon_1.spy(),c=sinon_1.spy()}),afterEach(()=>{n.verify()}),it("requests with correct topic and action",()=>{const a={topic:e,action:s,name:t};n.connectionMock.expects("sendMessage").once().withExactArgs(a),n.timeoutRegistryMock.expects("add").once().withExactArgs({message:a}),i.request(t,{callback:o})}),it("doesn't send message twice and updates the timeout when requesting twice",()=>{const a={topic:e,action:s,name:t};n.connectionMock.expects("sendMessage").once().withExactArgs(a),n.timeoutRegistryMock.expects("add").twice().withExactArgs({message:a}),i.request(t,{callback:o}),i.request(t,{callback:o})}),it("cant't query request when client is offline",()=>__awaiter(this,void 0,void 0,function*(){n.connection.isConnected=!1,n.connectionMock.expects("sendMessage").never(),n.timeoutRegistryMock.expects("add").never(),i.request(t,{callback:o}),i.request(t,{resolve:a,reject:c}),yield bluebird_1.Promise.delay(1),sinon_1.assert.calledOnce(o),sinon_1.assert.calledWithExactly(o,constants_1.EVENT.CLIENT_OFFLINE),sinon_1.assert.notCalled(a),sinon_1.assert.calledOnce(c),sinon_1.assert.calledWithExactly(c,constants_1.EVENT.CLIENT_OFFLINE)})),describe("requesting",()=>__awaiter(this,void 0,void 0,function*(){beforeEach(()=>{i.request(t,{callback:o}),i.request(t,{resolve:a,reject:c})}),it("doesn't respond unknown requests",()=>__awaiter(this,void 0,void 0,function*(){const s={topic:e,action:message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED,name:"something",isError:!0};i.recieve(s,message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED],void 0),sinon_1.assert.notCalled(o),sinon_1.assert.notCalled(a),sinon_1.assert.notCalled(c),yield bluebird_1.Promise.delay(1)})),it("responds callback and promise requests with success response",()=>__awaiter(this,void 0,void 0,function*(){const n={some:"data"};i.recieve({topic:e,action:s,name:t,isError:!1,parsedData:n},void 0,n),sinon_1.assert.calledOnce(o),sinon_1.assert.calledWithExactly(o,void 0,n),sinon_1.assert.calledOnce(a),sinon_1.assert.calledWithExactly(a,n),sinon_1.assert.notCalled(c),yield bluebird_1.Promise.delay(1)})),it("responds callback and promise requests with error response",()=>__awaiter(this,void 0,void 0,function*(){i.recieve({topic:e,action:message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED,name:t,isError:!0},message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED],void 0),sinon_1.assert.calledOnce(o),sinon_1.assert.calledWithExactly(o,message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED],void 0),sinon_1.assert.notCalled(a),sinon_1.assert.calledOnce(c),sinon_1.assert.calledWithExactly(c,message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED]),yield bluebird_1.Promise.delay(1)})),it("responds with error on connection lost",()=>__awaiter(this,void 0,void 0,function*(){n.simulateConnectionLost(),yield bluebird_1.Promise.delay(1),sinon_1.assert.calledOnce(o),sinon_1.assert.calledWithExactly(o,constants_1.EVENT.CLIENT_OFFLINE),sinon_1.assert.notCalled(a),sinon_1.assert.calledOnce(c),sinon_1.assert.calledWithExactly(c,constants_1.EVENT.CLIENT_OFFLINE)}))}))});