"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const message_constants_1=require("../../binary-protocol/src/message-constants"),constants_1=require("../../src/constants");class Listener{constructor(s,t){this.topic=s,this.services=t,this.listeners=new Map,this.stopCallbacks=new Map,s===message_constants_1.TOPIC.RECORD?this.actions=message_constants_1.RECORD_ACTIONS:s===message_constants_1.TOPIC.EVENT&&(this.actions=message_constants_1.EVENT_ACTIONS),this.services.connection.onLost(this.onConnectionLost.bind(this)),this.services.connection.onReestablished(this.onConnectionReestablished.bind(this))}listen(s,t){if("string"!=typeof s||0===s.length)throw new Error("invalid argument pattern");if("function"!=typeof t)throw new Error("invalid argument callback");this.listeners.has(s)?this.services.logger.warn({topic:this.topic,action:constants_1.EVENT.LISTENER_EXISTS,name:s}):(this.listeners.set(s,t),this.sendListen(s))}unlisten(s){if("string"!=typeof s||0===s.length)throw new Error("invalid argument pattern");this.listeners.has(s)?(this.listeners.delete(s),this.sendUnlisten(s)):this.services.logger.warn({topic:this.topic,action:constants_1.EVENT.NOT_LISTENING,name:s})}accept(s,t){this.services.connection.sendMessage({topic:this.topic,action:this.actions.LISTEN_ACCEPT,name:s,subscription:t})}reject(s,t){this.services.connection.sendMessage({topic:this.topic,action:this.actions.LISTEN_REJECT,name:s,subscription:t})}stop(s,t){this.stopCallbacks.set(s,t)}handle(s){if(s.action!==this.actions.SUBSCRIPTION_FOR_PATTERN_FOUND)if(s.action!==this.actions.SUBSCRIPTION_FOR_PATTERN_REMOVED)this.services.logger.error(s,constants_1.EVENT.UNSOLICITED_MESSAGE);else{const t=this.stopCallbacks.get(s.subscription);t&&(t(s.subscription),this.stopCallbacks.delete(s.subscription))}else{const t=this.listeners.get(s.name);t&&t(s.subscription,{accept:this.accept.bind(this,s.name,s.subscription),reject:this.reject.bind(this,s.name,s.subscription),onStop:this.stop.bind(this,s.subscription)})}}onConnectionLost(){this.stopCallbacks.forEach((s,t)=>{s(t)}),this.stopCallbacks.clear()}onConnectionReestablished(){this.listeners.forEach((s,t)=>{this.sendListen(t)})}sendListen(s){const t={topic:this.topic,action:this.actions.LISTEN,name:s};this.services.timeoutRegistry.add({message:t}),this.services.connection.sendMessage(t)}sendUnlisten(s){const t={topic:this.topic,action:this.actions.UNLISTEN,name:s};this.services.timeoutRegistry.add({message:t}),this.services.connection.sendMessage(t)}}exports.Listener=Listener;