"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const message_constants_1=require("../../binary-protocol/src/message-constants"),constants_1=require("../constants"),rpc_1=require("../rpc/rpc"),rpc_response_1=require("../rpc/rpc-response"),utils_1=require("../util/utils");class RPCHandler{constructor(s,e){this.services=s,this.options=e,this.rpcs=new Map,this.providers=new Map,this.services.connection.registerHandler(message_constants_1.TOPIC.RPC,this.handle.bind(this)),this.services.connection.onReestablished(this.reprovide.bind(this)),this.services.connection.onLost(this.onConnectionLost.bind(this))}provide(s,e){if("string"!=typeof s||0===s.length)throw new Error("invalid argument name");if(this.providers.has(s))throw new Error(`RPC ${s} already registered`);if("function"!=typeof e)throw new Error("invalid argument callback");this.providers.set(s,e),this.services.connection.isConnected&&this.sendProvide(s)}unprovide(s){if("string"!=typeof s||0===s.length)throw new Error("invalid argument name");if(this.providers.has(s)){if(this.providers.delete(s),this.services.connection.isConnected){const e={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.UNPROVIDE,name:s};return this.services.timeoutRegistry.add({message:e}),void this.services.connection.sendMessage(e)}}else this.services.logger.warn({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.NOT_PROVIDED,name:s})}make(s,e,t){if("string"!=typeof s||0===s.length)throw new Error("invalid argument name");if(t&&"function"!=typeof t)throw new Error("invalid argument callback");if(!1===this.services.connection.isConnected)return t?void this.services.timerRegistry.requestIdleCallback(t.bind(this,constants_1.EVENT.CLIENT_OFFLINE)):Promise.reject(constants_1.EVENT.CLIENT_OFFLINE);const n=utils_1.getUid();if(this.services.connection.sendMessage({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST,correlationId:n,name:s,parsedData:e}),!t)return new Promise((e,t)=>{this.rpcs.set(n,new rpc_1.RPC(s,n,(s,n)=>{s?t(s):e(n)},this.options,this.services))});this.rpcs.set(n,new rpc_1.RPC(s,n,t,this.options,this.services))}respondToRpc(s){const e=this.providers.get(s.name);e?e(s.parsedData,new rpc_response_1.RPCResponse(s,this.options,this.services)):this.services.connection.sendMessage({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REJECT,name:s.name,correlationId:s.correlationId})}handle(s){if(s.action===message_constants_1.RPC_ACTIONS.REQUEST)return void this.respondToRpc(s);if(s.isAck)return void this.services.timeoutRegistry.remove(s);if(s.action===message_constants_1.RPC_ACTIONS.MESSAGE_PERMISSION_ERROR||s.action===message_constants_1.RPC_ACTIONS.MESSAGE_DENIED){if(s.originalAction===message_constants_1.RPC_ACTIONS.PROVIDE||s.originalAction===message_constants_1.RPC_ACTIONS.UNPROVIDE)return this.services.timeoutRegistry.remove(s),this.providers.delete(s.name),void this.services.logger.error(s);if(s.originalAction===message_constants_1.RPC_ACTIONS.REQUEST){const e=this.getRPC(s);if(e)return e.error(message_constants_1.RPC_ACTIONS[s.action]),void this.rpcs.delete(s.correlationId)}}const e=this.getRPC(s);if(e){if(s.action===message_constants_1.RPC_ACTIONS.ACCEPT)return void e.accept();s.action===message_constants_1.RPC_ACTIONS.RESPONSE?e.respond(s.parsedData):s.action===message_constants_1.RPC_ACTIONS.REQUEST_ERROR?e.error(s.parsedData):s.action!==message_constants_1.RPC_ACTIONS.RESPONSE_TIMEOUT&&s.action!==message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER||e.error(message_constants_1.RPC_ACTIONS[s.action]),this.rpcs.delete(s.correlationId)}}getRPC(s){const e=this.rpcs.get(s.correlationId);return void 0===e&&this.services.logger.error(s,constants_1.EVENT.UNKNOWN_CORRELATION_ID),e}reprovide(){for(const[s,e]of this.providers)this.sendProvide(s)}sendProvide(s){const e={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.PROVIDE,name:s};this.services.timeoutRegistry.add({message:e}),this.services.connection.sendMessage(e)}onConnectionLost(){this.rpcs.forEach(s=>{s.error(constants_1.EVENT.CLIENT_OFFLINE)}),this.rpcs.clear()}}exports.RPCHandler=RPCHandler;