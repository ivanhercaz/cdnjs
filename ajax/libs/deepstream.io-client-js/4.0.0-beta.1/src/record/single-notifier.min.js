"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const client_1=require("../client");class SingleNotifier{constructor(e,t,s,i){this.services=e,this.topic=t,this.action=s,this.timeoutDuration=i,this.requests=new Map,this.internalRequests=new Map,this.services.connection.onLost(this.onConnectionLost.bind(this))}request(e,t){if(!1===this.services.connection.isConnected)return void(t.callback?this.services.timerRegistry.requestIdleCallback(t.callback.bind(this,client_1.EVENT.CLIENT_OFFLINE)):t.reject&&t.reject(client_1.EVENT.CLIENT_OFFLINE));const s={topic:this.topic,action:this.action,name:e};this.services.timeoutRegistry.add({message:s});const i=this.requests.get(e);void 0===i?(this.requests.set(e,[t]),this.services.connection.sendMessage(s)):i.push(t)}register(e,t){const s=this.internalRequests.get(e);s?s.push(t):this.internalRequests.set(e,[t])}recieve(e,t,s){this.services.timeoutRegistry.remove(e);const i=e.name,c=this.requests.get(i)||[],n=this.internalRequests.get(i)||[];if(c||n){for(let t=0;t<n.length;t++)n[t](e);this.internalRequests.delete(i);for(let e=0;e<c.length;e++){const i=c[e];i.callback?i.callback(t,s):t&&i.reject?i.reject(t):i.resolve&&i.resolve(s)}this.requests.delete(i)}}onConnectionLost(){this.requests.forEach(e=>{e.forEach(e=>{e.callback?e.callback(client_1.EVENT.CLIENT_OFFLINE):e.reject&&e.reject(client_1.EVENT.CLIENT_OFFLINE)})}),this.requests.clear()}}exports.SingleNotifier=SingleNotifier;