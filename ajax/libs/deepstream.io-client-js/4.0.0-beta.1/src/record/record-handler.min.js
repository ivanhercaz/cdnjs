"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const utils=require("../util/utils"),constants_1=require("../constants"),message_constants_1=require("../../binary-protocol/src/message-constants"),utils_1=require("../../binary-protocol/src/utils"),record_core_1=require("./record-core"),record_1=require("./record"),anonymous_record_1=require("./anonymous-record"),list_1=require("./list"),listener_1=require("../util/listener"),single_notifier_1=require("./single-notifier"),write_ack_service_1=require("./write-ack-service"),Emitter=require("component-emitter2");class RecordHandler{constructor(e,r,t){this.services=e,this.options=r,this.emitter=new Emitter,this.listener=t||new listener_1.Listener(message_constants_1.TOPIC.RECORD,this.services),this.recordCores=new Map,this.recordServices={writeAckService:new write_ack_service_1.WriteAcknowledgementService(e),readRegistry:new single_notifier_1.SingleNotifier(e,message_constants_1.TOPIC.RECORD,message_constants_1.RECORD_ACTIONS.READ,r.recordReadTimeout),headRegistry:new single_notifier_1.SingleNotifier(e,message_constants_1.TOPIC.RECORD,message_constants_1.RECORD_ACTIONS.HEAD,r.recordReadTimeout)},this.getRecordCore=this.getRecordCore.bind(this),this.services.connection.registerHandler(message_constants_1.TOPIC.RECORD,this.handle.bind(this))}getRecord(e){return new record_1.Record(this.getRecordCore(e))}getList(e){return new list_1.List(this.getRecordCore(e))}getAnonymousRecord(){return new anonymous_record_1.AnonymousRecord(this.getRecordCore)}listen(e,r){this.listener.listen(e,r)}unlisten(e){this.listener.unlisten(e)}snapshot(e,r){if("string"!=typeof e||0===e.length)throw new Error("invalid argument: name");if(void 0!==r&&"function"!=typeof r)throw new Error("invalid argument: callback");const t=this.recordCores.get(e);return t?r?void t.whenReady(null,()=>{r(null,t.get())}):new Promise((e,r)=>{t.whenReady(null,()=>{e(t.get())})}):r?void this.recordServices.readRegistry.request(e,{callback:r}):new Promise((r,t)=>{this.recordServices.readRegistry.request(e,{resolve:r,reject:t})})}has(e,r){if("string"!=typeof e||0===e.length)throw new Error("invalid argument: name");if(void 0!==r&&"function"!=typeof r)throw new Error("invalid argument: callback");let t;if(!r)return new Promise((r,s)=>{t=((e,t)=>e?s(e):r(-1!==t)),this.head(e,t)});t=((e,t)=>e?r(e,null):r(null,-1!==t)),this.head(e,t)}head(e,r){if("string"!=typeof e||0===e.length)throw new Error("invalid argument: name");if(void 0!==r&&"function"!=typeof r)throw new Error("invalid argument: callback");const t=this.recordCores.get(e);return t?r?void t.whenReady(null,()=>{r(null,t.version)}):new Promise((e,r)=>{t.whenReady(null,()=>{e(t.version)})}):r?void this.recordServices.headRegistry.request(e,{callback:r}):new Promise((r,t)=>{this.recordServices.headRegistry.request(e,{resolve:r,reject:t})})}setDataWithAck(e,...r){const t=utils.normalizeSetArguments(arguments,1);if(!t.callback)return new Promise((r,s)=>{t.callback=(e=>null===e?r():s(e)),this.sendSetData(e,t)});this.sendSetData(e,t)}setData(e){const r=utils.normalizeSetArguments(arguments,1);this.sendSetData(e,r)}sendSetData(e,r){const{path:t,data:s,callback:i}=r;if(!e||"string"!=typeof e||0===e.length)throw new Error("invalid argument: recordName must be an non empty string");if(!t&&(null===s||"object"!=typeof s))throw new Error("invalid argument: data must be an object when no path is provided");const n=this.recordCores.get(e);if(n)return void n.set({path:t,data:s,callback:i});let o;o=t?void 0===s?message_constants_1.RECORD_ACTIONS.ERASE:message_constants_1.RECORD_ACTIONS.CREATEANDPATCH:message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE;const c={topic:message_constants_1.TOPIC.RECORD,action:o,name:e,path:t,version:-1,parsedData:s};i?this.recordServices.writeAckService.send(c,i):this.services.connection.sendMessage(c)}handle(e){if(e.action===message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND||e.action===message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED)return void this.listener.handle(e);if(utils_1.isWriteAck(e.action)||utils_1.isWriteAck(e.originalAction))return void this.recordServices.writeAckService.recieve(e);if(e.action===message_constants_1.RECORD_ACTIONS.READ_RESPONSE||e.originalAction===message_constants_1.RECORD_ACTIONS.READ)return void(e.isError?this.recordServices.readRegistry.recieve(e,message_constants_1.RECORD_ACTIONS[e.action]):this.recordServices.readRegistry.recieve(e,null,e.parsedData));e.action!==message_constants_1.RECORD_ACTIONS.HEAD_RESPONSE&&e.originalAction!==message_constants_1.RECORD_ACTIONS.HEAD||(e.isError?this.recordServices.headRegistry.recieve(e,message_constants_1.RECORD_ACTIONS[e.action]):this.recordServices.headRegistry.recieve(e,null,e.version));const r=this.recordCores.get(e.name);r?r.handle(e):e.action!==message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_PROVIDER&&e.action!==message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_NO_PROVIDER&&(e.isError?this.services.logger.error(e):this.services.logger.error(e,constants_1.EVENT.UNSOLICITED_MESSAGE))}removeRecord(e){this.recordCores.delete(e)}getRecordCore(e){let r=this.recordCores.get(e);return r?r.usages++:(r=new record_core_1.RecordCore(e,this.services,this.options,this.recordServices,this.removeRecord.bind(this)),this.recordCores.set(e,r)),r}}exports.RecordHandler=RecordHandler;