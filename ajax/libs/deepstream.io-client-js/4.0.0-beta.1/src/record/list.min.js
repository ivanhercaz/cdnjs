"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const utils=require("../util/utils"),constants_1=require("../constants"),Emitter=require("component-emitter2");class List extends Emitter{constructor(t){super(),this.record=t,this.originalApplyUpdate=this.record.applyUpdate.bind(this.record),this.record.applyUpdate=this.applyUpdate.bind(this),this.wrappedFunctions=new Map}get name(){return this.record.name}get isReady(){return this.record.isReady}get version(){return this.record.version}whenReady(t){return this.record.whenReady(this,t)}getEntries(){const t=this.record.get();return t instanceof Array?t:[]}isEmpty(){return 0===this.getEntries().length}setEntriesWithAck(t,e){if(!e)return new Promise((e,r)=>{this.setEntries(t,t=>{t?r(t):e()})});this.setEntries(t,e)}setEntries(t,e){const r="entries must be an array of record names";let s;if(!(t instanceof Array))throw new Error(r);for(s=0;s<t.length;s++)if("string"!=typeof t[s])throw new Error(r);!1===this.record.isReady||(this.beforeChange(),this.record.set({data:t,callback:e}),this.afterChange())}removeEntry(t,e,r){if(!1===this.record.isReady)return;const s=this.record.get(),i=this.hasIndex(e),n=[];let h;for(h=0;h<s.length;h++)(s[h]!==t||i&&e!==h)&&n.push(s[h]);this.beforeChange(),this.record.set({data:n,callback:r}),this.afterChange()}addEntry(t,e,r){if("string"!=typeof t)throw new Error("Entry must be a recordName");if(!1===this.record.isReady)return;const s=this.hasIndex(e),i=this.getEntries();s?i.splice(e,0,t):i.push(t),this.beforeChange(),this.record.set({data:i,callback:r}),this.afterChange()}subscribe(t){const e=utils.normalizeArguments(arguments);if(e.path)throw new Error("path is not supported for List.subscribe");const r=function(t){t(this.getEntries())}.bind(this,e.callback);this.wrappedFunctions.set(e.callback,r),e.callback=r,this.record.subscribe(e)}unsubscribe(t){const e=utils.normalizeArguments(arguments);if(e.path)throw new Error("path is not supported for List.unsubscribe");const r=this.wrappedFunctions.get(e.callback);e.callback=r,this.record.unsubscribe(e),this.wrappedFunctions.delete(e.callback)}applyUpdate(t){t.parsedData instanceof Array||(t.parsedData=[]),this.beforeChange(),this.originalApplyUpdate(t),this.afterChange()}hasIndex(t){let e=!1;const r=this.getEntries();if(void 0!==t){if(isNaN(t))throw new Error("Index must be a number");if(t!==r.length&&(t>=r.length||t<0))throw new Error("Index must be within current entries");e=!0}return e}beforeChange(){this.hasAddListener=this.listeners(constants_1.EVENT.ENTRY_ADDED_EVENT).length>0,this.hasRemoveListener=this.listeners(constants_1.EVENT.ENTRY_REMOVED_EVENT).length>0,this.hasMoveListener=this.listeners(constants_1.EVENT.ENTRY_MOVED_EVENT).length>0,this.hasAddListener||this.hasRemoveListener||this.hasMoveListener?this.beforeStructure=this.getStructure():this.beforeStructure=null}afterChange(){if(null===this.beforeStructure)return;const t=this.getStructure(),e=this.beforeStructure;let r,s;if(this.hasRemoveListener)for(r in e)for(s=0;s<e[r].length;s++)void 0!==t[r]&&void 0!==t[r][s]||this.emit(constants_1.EVENT.ENTRY_REMOVED_EVENT,r,e[r][s]);if(this.hasAddListener||this.hasMoveListener)for(r in t)if(void 0===e[r])for(s=0;s<t[r].length;s++)this.emit(constants_1.EVENT.ENTRY_ADDED_EVENT,r,t[r][s]);else for(s=0;s<t[r].length;s++)e[r][s]!==t[r][s]&&(void 0===e[r][s]?this.emit(constants_1.EVENT.ENTRY_ADDED_EVENT,r,t[r][s]):this.emit(constants_1.EVENT.ENTRY_MOVED_EVENT,r,t[r][s]))}getStructure(){const t={};let e;const r=this.record.get();for(e=0;e<r.length;e++)void 0===t[r[e]]?t[r[e]]=[e]:t[r[e]].push(e);return t}}exports.List=List;