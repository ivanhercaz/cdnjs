"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const client_1=require("../client"),message_constants_1=require("../../binary-protocol/src/message-constants"),Emitter=require("component-emitter2"),ONLY_EVENT="OE";function validateQueryArguments(s){let e=null,t=null;if(1===s.length)if(Array.isArray(s[0]))e=s[0];else{if("function"!=typeof s[0])throw new Error('invalid argument: "callback"');t=s[0]}else if(2===s.length&&(e=s[0],t=s[1],!Array.isArray(e)||"function"!=typeof t))throw new Error('invalid argument: "users" or "callback"');return{users:e,callback:t}}class PresenceHandler{constructor(s,e){this.services=s,this.options=e,this.subscriptionEmitter=new Emitter,this.globalSubscriptionEmitter=new Emitter,this.queryEmitter=new Emitter,this.queryAllEmitter=new Emitter,this.resubscribe=this.resubscribe.bind(this),this.services.connection.registerHandler(message_constants_1.TOPIC.PRESENCE,this.handle.bind(this)),this.services.connection.onReestablished(this.resubscribe.bind(this)),this.services.connection.onLost(this.onConnectionLost.bind(this)),this.counter=0,this.pendingSubscribes=new Set,this.pendingUnsubscribes=new Set}subscribe(s,e){if("string"==typeof s&&s.length>0&&"function"==typeof e){const t=s;return this.subscriptionEmitter.hasListeners(t)||this.pendingSubscribes.add(t),this.subscriptionEmitter.on(t,e),this.pendingUnsubscribes.delete(t),void this.registerFlushTimeout()}if("function"==typeof s&&void 0===e)return this.subscriptionEmitter.hasListeners(ONLY_EVENT)||this.subscribeToAllChanges(),void this.globalSubscriptionEmitter.on(ONLY_EVENT,s);throw new Error('invalid arguments: "user" or "callback"')}unsubscribe(s,e){if(!(s&&"string"==typeof s&&s.length>0)){if(s&&"function"==typeof s)return e=s,this.globalSubscriptionEmitter.off(ONLY_EVENT,e),void(this.subscriptionEmitter.hasListeners(ONLY_EVENT)||this.unsubscribeToAllChanges());if(void 0===s&&void 0===e){this.subscriptionEmitter.off(),this.globalSubscriptionEmitter.off(),this.pendingSubscribes.clear();const s=this.subscriptionEmitter.eventNames();for(let e=0;e<s.length;e++)this.pendingUnsubscribes.add(s[e]);return this.registerFlushTimeout(),void this.unsubscribeToAllChanges()}throw new Error('invalid argument: "user" or "callback"')}{const t=s;if(e){if("function"!=typeof e)throw new Error('invalid argument: "callback"');this.subscriptionEmitter.off(t,e)}else this.subscriptionEmitter.off(t);this.subscriptionEmitter.hasListeners(t)||(this.pendingSubscribes.delete(t),this.pendingUnsubscribes.add(t),this.registerFlushTimeout())}}getAll(...s){const{callback:e,users:t}=validateQueryArguments(s);if(!this.services.connection.isConnected)return e?void this.services.timerRegistry.requestIdleCallback(e.bind(this,client_1.EVENT.CLIENT_OFFLINE)):Promise.reject(client_1.EVENT.CLIENT_OFFLINE);let i,n,r;if(t){const s=(this.counter++).toString();i={topic:message_constants_1.TOPIC.PRESENCE,action:message_constants_1.PRESENCE_ACTIONS.QUERY,correlationId:s,names:t},n=this.queryEmitter,r=s}else i={topic:message_constants_1.TOPIC.PRESENCE,action:message_constants_1.PRESENCE_ACTIONS.QUERY_ALL},n=this.queryAllEmitter,r=ONLY_EVENT;if(this.services.connection.sendMessage(i),this.services.timeoutRegistry.add({message:i}),!e)return new Promise((s,e)=>{n.once(r,(t,i)=>{t?e(t):s(i)})});n.once(r,e)}handle(s){if(s.isAck)this.services.timeoutRegistry.remove(s);else{if(s.action===message_constants_1.PRESENCE_ACTIONS.QUERY_ALL_RESPONSE)return this.queryAllEmitter.emit(ONLY_EVENT,null,s.names),void this.services.timeoutRegistry.remove(Object.assign({},s,{action:message_constants_1.PRESENCE_ACTIONS.QUERY_ALL}));if(s.action===message_constants_1.PRESENCE_ACTIONS.QUERY_RESPONSE)return this.queryEmitter.emit(s.correlationId,null,s.parsedData),void this.services.timeoutRegistry.remove(Object.assign({},s,{action:message_constants_1.PRESENCE_ACTIONS.QUERY}));if(s.action!==message_constants_1.PRESENCE_ACTIONS.PRESENCE_JOIN)if(s.action!==message_constants_1.PRESENCE_ACTIONS.PRESENCE_JOIN_ALL)if(s.action!==message_constants_1.PRESENCE_ACTIONS.PRESENCE_LEAVE){if(s.action!==message_constants_1.PRESENCE_ACTIONS.PRESENCE_LEAVE_ALL)return s.isError?(this.services.timeoutRegistry.remove(s),void(s.originalAction===message_constants_1.PRESENCE_ACTIONS.QUERY?this.queryEmitter.emit(s.correlationId,message_constants_1.PRESENCE_ACTIONS[s.action]):s.originalAction===message_constants_1.PRESENCE_ACTIONS.QUERY_ALL?this.queryAllEmitter.emit(ONLY_EVENT,message_constants_1.PRESENCE_ACTIONS[s.action]):this.services.logger.error(s))):void this.services.logger.error(s,client_1.EVENT.UNSOLICITED_MESSAGE);this.globalSubscriptionEmitter.emit(ONLY_EVENT,s.name,!1)}else this.subscriptionEmitter.emit(s.name,s.name,!1);else this.globalSubscriptionEmitter.emit(ONLY_EVENT,s.name,!0);else this.subscriptionEmitter.emit(s.name,s.name,!0)}}flush(){if(!this.services.connection.isConnected)return;const s=Array.from(this.pendingSubscribes.keys());s.length>0&&(this.bulkSubscription(message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE,s),this.pendingSubscribes.clear());const e=Array.from(this.pendingUnsubscribes.keys());e.length>0&&(this.bulkSubscription(message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE,e),this.pendingUnsubscribes.clear()),this.flushTimeout=null}resubscribe(){const s=this.subscriptionEmitter.eventNames();s.length>0&&this.bulkSubscription(message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE,s),this.globalSubscriptionEmitter.hasListeners(ONLY_EVENT)&&this.subscribeToAllChanges()}bulkSubscription(s,e){const t=this.counter++,i={topic:message_constants_1.TOPIC.PRESENCE,action:s,correlationId:t.toString(),names:e};this.services.timeoutRegistry.add({message:i}),this.services.connection.sendMessage(i)}subscribeToAllChanges(){if(!this.services.connection.isConnected)return;const s={topic:message_constants_1.TOPIC.PRESENCE,action:message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_ALL};this.services.timeoutRegistry.add({message:s}),this.services.connection.sendMessage(s)}unsubscribeToAllChanges(){if(!this.services.connection.isConnected)return;const s={topic:message_constants_1.TOPIC.PRESENCE,action:message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_ALL};this.services.timeoutRegistry.add({message:s}),this.services.connection.sendMessage(s)}registerFlushTimeout(){this.flushTimeout||(this.flushTimeout=this.services.timerRegistry.add({duration:0,context:this,callback:this.flush}))}onConnectionLost(){this.queryEmitter.eventNames().forEach(s=>{this.queryEmitter.emit(s,client_1.EVENT.CLIENT_OFFLINE)}),this.queryAllEmitter.emit(ONLY_EVENT,client_1.EVENT.CLIENT_OFFLINE)}}exports.PresenceHandler=PresenceHandler;