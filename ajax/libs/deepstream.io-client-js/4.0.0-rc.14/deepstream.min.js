!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define("deepstream",[],n):"object"==typeof exports?exports.deepstream=n():e.deepstream=n()}(window,function(){return d={"./binary-protocol/src/constants.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.HEADER_LENGTH = 8;\nexports.META_PAYLOAD_OVERFLOW_LENGTH = Math.pow(2, 24) - 1;\n\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/constants.ts?')},"./binary-protocol/src/message-builder.ts":function(module,exports,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(Buffer) {\n/**\n * Functions for handling (de)serialization of the deepstream binary realtime protocol.\n *\n * In brief, a message is a variable length binary blob with the following structure:\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-------------+-+-------------+-------------------------------+\n * |F|  Message    |A|  Message    |             Meta              |\n * |I|   Topic     |C|  Action     |            Length             |\n * |N|    (7)      |K|   (7)       |             (24)              |\n * +-+-------------+-+-------------+-------------------------------+\n * | Meta Cont.    |              Payload Length (24)              |\n * +---------------+-----------------------------------------------+\n * :                     Meta Data (Meta Length * 8)               :\n * + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n * |                  Payload Data (Payload Length * 8)            :\n * +---------------------------------------------------------------+\n *\n * The first 6 bytes of the message are the header, and the rest of the message is the payload.\n *\n * CONT (1 bit): The continuation bit. If this is set, the following payload of the following\n *                message must be appended to this one. If this is not set, parsing may finish\n *                after the payload is read.\n * RSV{0..3} (1 bit): Reserved for extension.\n * Meta Length (24 bits, unsigned big-endian): The total length of Meta Data in bytes.\n *                If Meta Data can be no longer than 16 MB.\n * Payload Length (24 bits, unsigned big-endian): The total length of Payload in bytes.\n *                If Payload is longer than 16 MB, it must be split into chunks of\n *                less than 2^24 bytes with identical topic and action, setting the CONT bit\n *                in all but the final chunk.\n *\n */\n/* tslint:disable:no-bitwise */\nObject.defineProperty(exports, "__esModule", { value: true });\nvar message_constants_1 = __webpack_require__(/*! ./message-constants */ "./binary-protocol/src/message-constants.ts");\nvar utils_1 = __webpack_require__(/*! ./utils */ "./binary-protocol/src/utils.ts");\nvar constants_1 = __webpack_require__(/*! ./constants */ "./binary-protocol/src/constants.ts");\nvar message_validator_1 = __webpack_require__(/*! ./message-validator */ "./binary-protocol/src/message-validator.ts");\nfunction getMessage(msg, isAck) {\n    var message = msg;\n    var action = message.action;\n    // convert action to write ack if necessary\n    if (message.isWriteAck && !utils_1.isWriteAck(message.action)) {\n        action = utils_1.ACTION_TO_WRITE_ACK[message.action];\n    }\n    if (message.isAck || isAck) {\n        action |= 0x80;\n        if (message_constants_1.ACTIONS[message.topic][message.action] === undefined) {\n            throw new Error("message " + message_constants_1.TOPIC[message.topic] + " " + message.action + " should not have an ack");\n        }\n    }\n    var meta = {\n        n: message.name,\n        m: message.names,\n        c: message.correlationId,\n        s: message.subscription,\n        v: message.version,\n        p: message.path,\n        r: message.reason,\n        u: message.url,\n        t: message.originalTopic,\n        a: message.originalAction,\n        x: message.protocolVersion,\n        rn: message.requestorName,\n        rd: message.requestorData,\n        ts: message.trustedSender,\n        rt: message.registryTopic\n    };\n    if (message.payloadEncoding && message.payloadEncoding !== message_constants_1.PAYLOAD_ENCODING.JSON) {\n        meta[message_constants_1.META_KEYS.payloadEncoding] = message.payloadEncoding;\n    }\n    var metaError = message_validator_1.validateMeta(message.topic, action, meta);\n    if (metaError) {\n        throw new Error("invalid " + message_constants_1.TOPIC[message.topic] + " " + (message_constants_1.ACTIONS[message.topic][action] || action) + ": " + metaError);\n    }\n    var metaStr = JSON.stringify(meta);\n    var metaBuff = metaStr === \'{}\' ? null : Buffer.from(metaStr, \'utf8\');\n    var payloadBuff;\n    if (message.data instanceof Buffer) {\n        payloadBuff = message.data;\n    }\n    else if (message.data !== undefined || message.parsedData !== undefined) {\n        var payloadStr = message.data;\n        if (payloadStr === undefined) {\n            payloadStr = JSON.stringify(message.parsedData);\n        }\n        payloadBuff = Buffer.from(payloadStr, \'utf8\');\n    }\n    else {\n        payloadBuff = null;\n    }\n    if (payloadBuff && !message_validator_1.hasPayload(message.topic, action)) {\n        console.error("invalid message " + message_constants_1.TOPIC[message.topic] + " " + message.action + ": should not have payload");\n    }\n    var metaBuffLength = metaBuff ? metaBuff.length : 0;\n    var payloadBuffLength = payloadBuff ? payloadBuff.length : 0;\n    if (metaBuffLength <= constants_1.META_PAYLOAD_OVERFLOW_LENGTH\n        && payloadBuffLength <= constants_1.META_PAYLOAD_OVERFLOW_LENGTH) {\n        return buildRaw(true, message.topic, action, metaBuff, payloadBuff);\n    }\n    else {\n        return buildMultipart(message.topic, action, metaBuff, payloadBuff);\n    }\n}\nexports.getMessage = getMessage;\nfunction buildMultipart(topic, action, meta, payload) {\n    var metaLength = meta ? meta.length : 0;\n    var payloadLength = payload ? payload.length : 0;\n    var messageParts = [];\n    var metaSectionOffset = 0;\n    var payloadSectionOffset = 0;\n    var fin;\n    do {\n        var metaSectionLength = Math.min(metaLength - metaSectionOffset, constants_1.META_PAYLOAD_OVERFLOW_LENGTH);\n        var payloadSectionLength = Math.min(payloadLength - payloadSectionOffset, constants_1.META_PAYLOAD_OVERFLOW_LENGTH);\n        var metaSection = meta && meta.slice(metaSectionOffset, metaSectionOffset + metaSectionLength);\n        var payloadSection = payload && payload.slice(payloadSectionOffset, payloadSectionOffset + payloadSectionLength);\n        metaSectionOffset += metaSectionLength;\n        payloadSectionOffset += payloadSectionLength;\n        fin = metaSectionOffset === metaLength && payloadSectionOffset === payloadLength;\n        messageParts.push(buildRaw(fin, topic, action, metaSection, payloadSection));\n    } while (!fin);\n    return Buffer.concat(messageParts);\n}\nfunction buildRaw(fin, topic, action, meta, payload) {\n    var metaLength = meta ? meta.length : 0;\n    var payloadLength = payload ? payload.length : 0;\n    var messageBufferLength = constants_1.HEADER_LENGTH + metaLength + payloadLength;\n    var messageBuffer = Buffer.allocUnsafe(messageBufferLength);\n    messageBuffer[0] = (fin ? 0x80 : 0x00) | topic;\n    messageBuffer[1] = action;\n    messageBuffer.writeUIntBE(metaLength, 2, 3);\n    messageBuffer.writeUIntBE(payloadLength, 5, 3);\n    if (meta) {\n        meta.copy(messageBuffer, constants_1.HEADER_LENGTH);\n    }\n    if (payload) {\n        payload.copy(messageBuffer, constants_1.HEADER_LENGTH + metaLength);\n    }\n    return messageBuffer;\n}\nfunction combineMultipleMessages(messages) {\n    return Buffer.concat(messages);\n}\nexports.combineMultipleMessages = combineMultipleMessages;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/buffer/index.js */ "./node_modules/buffer/index.js").Buffer))\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/message-builder.ts?')},"./binary-protocol/src/message-constants.ts":function(module,exports,__webpack_require__){"use strict";eval('\n// tslint:disable no-bitwise\nObject.defineProperty(exports, "__esModule", { value: true });\nvar _a;\nvar META_KEYS;\n(function (META_KEYS) {\n    META_KEYS["payloadEncoding"] = "e";\n    META_KEYS["name"] = "n";\n    META_KEYS["names"] = "m";\n    META_KEYS["subscription"] = "s";\n    META_KEYS["correlationId"] = "c";\n    META_KEYS["version"] = "v";\n    META_KEYS["path"] = "p";\n    META_KEYS["reason"] = "r";\n    META_KEYS["url"] = "u";\n    META_KEYS["originalTopic"] = "t";\n    META_KEYS["originalAction"] = "a";\n    META_KEYS["protocolVersion"] = "x";\n    META_KEYS["requestorName"] = "rn";\n    META_KEYS["requestorData"] = "rd";\n    META_KEYS["trustedSender"] = "ts";\n    META_KEYS["registryTopic"] = "rt";\n})(META_KEYS = exports.META_KEYS || (exports.META_KEYS = {}));\nvar PAYLOAD_ENCODING;\n(function (PAYLOAD_ENCODING) {\n    PAYLOAD_ENCODING["JSON"] = "j";\n    PAYLOAD_ENCODING["BINARY"] = "b";\n})(PAYLOAD_ENCODING = exports.PAYLOAD_ENCODING || (exports.PAYLOAD_ENCODING = {}));\nvar TOPIC;\n(function (TOPIC) {\n    TOPIC[TOPIC["ERROR"] = 0] = "ERROR";\n    TOPIC[TOPIC["PARSER"] = 1] = "PARSER";\n    TOPIC[TOPIC["CONNECTION"] = 2] = "CONNECTION";\n    TOPIC[TOPIC["AUTH"] = 3] = "AUTH";\n    TOPIC[TOPIC["EVENT"] = 4] = "EVENT";\n    TOPIC[TOPIC["RECORD"] = 5] = "RECORD";\n    TOPIC[TOPIC["RPC"] = 6] = "RPC";\n    TOPIC[TOPIC["PRESENCE"] = 7] = "PRESENCE";\n    TOPIC[TOPIC["SUBSCRIPTIONS"] = 16] = "SUBSCRIPTIONS";\n    TOPIC[TOPIC["ONLINE_USERS"] = 17] = "ONLINE_USERS";\n    TOPIC[TOPIC["EVENT_SUBSCRIPTIONS"] = 32] = "EVENT_SUBSCRIPTIONS";\n    TOPIC[TOPIC["RECORD_SUBSCRIPTIONS"] = 33] = "RECORD_SUBSCRIPTIONS";\n    TOPIC[TOPIC["RPC_SUBSCRIPTIONS"] = 34] = "RPC_SUBSCRIPTIONS";\n    TOPIC[TOPIC["PRESENCE_SUBSCRIPTIONS"] = 35] = "PRESENCE_SUBSCRIPTIONS";\n    TOPIC[TOPIC["RECORD_LISTEN_PATTERNS"] = 36] = "RECORD_LISTEN_PATTERNS";\n    TOPIC[TOPIC["EVENT_LISTEN_PATTERNS"] = 37] = "EVENT_LISTEN_PATTERNS";\n    TOPIC[TOPIC["RECORD_PUBLISHED_SUBSCRIPTIONS"] = 38] = "RECORD_PUBLISHED_SUBSCRIPTIONS";\n    TOPIC[TOPIC["EVENT_PUBLISHED_SUBSCRIPTIONS"] = 39] = "EVENT_PUBLISHED_SUBSCRIPTIONS";\n    TOPIC[TOPIC["RECORD_LISTENING"] = 40] = "RECORD_LISTENING";\n    TOPIC[TOPIC["EVENT_LISTENING"] = 41] = "EVENT_LISTENING";\n    TOPIC[TOPIC["STATE_REGISTRY"] = 48] = "STATE_REGISTRY";\n    TOPIC[TOPIC["CLUSTER"] = 49] = "CLUSTER";\n    TOPIC[TOPIC["LOCK"] = 50] = "LOCK";\n})(TOPIC = exports.TOPIC || (exports.TOPIC = {}));\nvar PARSER_ACTIONS;\n(function (PARSER_ACTIONS) {\n    PARSER_ACTIONS[PARSER_ACTIONS["UNKNOWN_TOPIC"] = 80] = "UNKNOWN_TOPIC";\n    PARSER_ACTIONS[PARSER_ACTIONS["UNKNOWN_ACTION"] = 81] = "UNKNOWN_ACTION";\n    PARSER_ACTIONS[PARSER_ACTIONS["INVALID_MESSAGE"] = 82] = "INVALID_MESSAGE";\n    PARSER_ACTIONS[PARSER_ACTIONS["MESSAGE_PARSE_ERROR"] = 83] = "MESSAGE_PARSE_ERROR";\n    PARSER_ACTIONS[PARSER_ACTIONS["MAXIMUM_MESSAGE_SIZE_EXCEEDED"] = 84] = "MAXIMUM_MESSAGE_SIZE_EXCEEDED";\n    PARSER_ACTIONS[PARSER_ACTIONS["ERROR"] = 85] = "ERROR";\n    PARSER_ACTIONS[PARSER_ACTIONS["INVALID_META_PARAMS"] = 86] = "INVALID_META_PARAMS";\n})(PARSER_ACTIONS = exports.PARSER_ACTIONS || (exports.PARSER_ACTIONS = {}));\nvar CONNECTION_ACTIONS;\n(function (CONNECTION_ACTIONS) {\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["ERROR"] = 0] = "ERROR";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["PING"] = 1] = "PING";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["PONG"] = 2] = "PONG";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["ACCEPT"] = 3] = "ACCEPT";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["CHALLENGE"] = 4] = "CHALLENGE";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["REJECT"] = 6] = "REJECT";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["REDIRECT"] = 7] = "REDIRECT";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["CLOSING"] = 8] = "CLOSING";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["CLOSED"] = 9] = "CLOSED";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["AUTHENTICATION_TIMEOUT"] = 80] = "AUTHENTICATION_TIMEOUT";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["INVALID_MESSAGE"] = 82] = "INVALID_MESSAGE";\n})(CONNECTION_ACTIONS = exports.CONNECTION_ACTIONS || (exports.CONNECTION_ACTIONS = {}));\nvar AUTH_ACTIONS;\n(function (AUTH_ACTIONS) {\n    AUTH_ACTIONS[AUTH_ACTIONS["ERROR"] = 0] = "ERROR";\n    AUTH_ACTIONS[AUTH_ACTIONS["REQUEST"] = 1] = "REQUEST";\n    AUTH_ACTIONS[AUTH_ACTIONS["AUTH_SUCCESSFUL"] = 2] = "AUTH_SUCCESSFUL";\n    AUTH_ACTIONS[AUTH_ACTIONS["AUTH_UNSUCCESSFUL"] = 3] = "AUTH_UNSUCCESSFUL";\n    AUTH_ACTIONS[AUTH_ACTIONS["TOO_MANY_AUTH_ATTEMPTS"] = 80] = "TOO_MANY_AUTH_ATTEMPTS";\n    AUTH_ACTIONS[AUTH_ACTIONS["INVALID_MESSAGE"] = 82] = "INVALID_MESSAGE";\n    AUTH_ACTIONS[AUTH_ACTIONS["INVALID_MESSAGE_DATA"] = 98] = "INVALID_MESSAGE_DATA";\n})(AUTH_ACTIONS = exports.AUTH_ACTIONS || (exports.AUTH_ACTIONS = {}));\nvar EVENT_ACTIONS;\n(function (EVENT_ACTIONS) {\n    EVENT_ACTIONS[EVENT_ACTIONS["ERROR"] = 0] = "ERROR";\n    EVENT_ACTIONS[EVENT_ACTIONS["EMIT"] = 1] = "EMIT";\n    EVENT_ACTIONS[EVENT_ACTIONS["SUBSCRIBE"] = 2] = "SUBSCRIBE";\n    EVENT_ACTIONS[EVENT_ACTIONS["SUBSCRIBE_ACK"] = 130] = "SUBSCRIBE_ACK";\n    EVENT_ACTIONS[EVENT_ACTIONS["UNSUBSCRIBE"] = 3] = "UNSUBSCRIBE";\n    EVENT_ACTIONS[EVENT_ACTIONS["UNSUBSCRIBE_ACK"] = 131] = "UNSUBSCRIBE_ACK";\n    EVENT_ACTIONS[EVENT_ACTIONS["SUBSCRIBE_BULK"] = 16] = "SUBSCRIBE_BULK";\n    EVENT_ACTIONS[EVENT_ACTIONS["SUBSCRIBE_BULK_ACK"] = 144] = "SUBSCRIBE_BULK_ACK";\n    EVENT_ACTIONS[EVENT_ACTIONS["UNSUBSCRIBE_BULK"] = 17] = "UNSUBSCRIBE_BULK";\n    EVENT_ACTIONS[EVENT_ACTIONS["UNSUBSCRIBE_BULK_ACK"] = 145] = "UNSUBSCRIBE_BULK_ACK";\n    EVENT_ACTIONS[EVENT_ACTIONS["LISTEN"] = 4] = "LISTEN";\n    EVENT_ACTIONS[EVENT_ACTIONS["LISTEN_ACK"] = 132] = "LISTEN_ACK";\n    EVENT_ACTIONS[EVENT_ACTIONS["UNLISTEN"] = 5] = "UNLISTEN";\n    EVENT_ACTIONS[EVENT_ACTIONS["UNLISTEN_ACK"] = 133] = "UNLISTEN_ACK";\n    EVENT_ACTIONS[EVENT_ACTIONS["LISTEN_ACCEPT"] = 6] = "LISTEN_ACCEPT";\n    EVENT_ACTIONS[EVENT_ACTIONS["LISTEN_REJECT"] = 7] = "LISTEN_REJECT";\n    EVENT_ACTIONS[EVENT_ACTIONS["SUBSCRIPTION_FOR_PATTERN_FOUND"] = 8] = "SUBSCRIPTION_FOR_PATTERN_FOUND";\n    EVENT_ACTIONS[EVENT_ACTIONS["SUBSCRIPTION_FOR_PATTERN_REMOVED"] = 9] = "SUBSCRIPTION_FOR_PATTERN_REMOVED";\n    EVENT_ACTIONS[EVENT_ACTIONS["INVALID_LISTEN_REGEX"] = 80] = "INVALID_LISTEN_REGEX";\n    EVENT_ACTIONS[EVENT_ACTIONS["MESSAGE_PERMISSION_ERROR"] = 96] = "MESSAGE_PERMISSION_ERROR";\n    EVENT_ACTIONS[EVENT_ACTIONS["MESSAGE_DENIED"] = 97] = "MESSAGE_DENIED";\n    EVENT_ACTIONS[EVENT_ACTIONS["INVALID_MESSAGE_DATA"] = 98] = "INVALID_MESSAGE_DATA";\n    EVENT_ACTIONS[EVENT_ACTIONS["MULTIPLE_SUBSCRIPTIONS"] = 99] = "MULTIPLE_SUBSCRIPTIONS";\n    EVENT_ACTIONS[EVENT_ACTIONS["NOT_SUBSCRIBED"] = 100] = "NOT_SUBSCRIBED";\n})(EVENT_ACTIONS = exports.EVENT_ACTIONS || (exports.EVENT_ACTIONS = {}));\nvar RECORD_ACTIONS;\n(function (RECORD_ACTIONS) {\n    RECORD_ACTIONS[RECORD_ACTIONS["ERROR"] = 0] = "ERROR";\n    RECORD_ACTIONS[RECORD_ACTIONS["READ"] = 1] = "READ";\n    RECORD_ACTIONS[RECORD_ACTIONS["READ_RESPONSE"] = 2] = "READ_RESPONSE";\n    RECORD_ACTIONS[RECORD_ACTIONS["HEAD"] = 3] = "HEAD";\n    RECORD_ACTIONS[RECORD_ACTIONS["HEAD_RESPONSE"] = 4] = "HEAD_RESPONSE";\n    RECORD_ACTIONS[RECORD_ACTIONS["DELETE"] = 5] = "DELETE";\n    RECORD_ACTIONS[RECORD_ACTIONS["DELETE_SUCCESS"] = 6] = "DELETE_SUCCESS";\n    RECORD_ACTIONS[RECORD_ACTIONS["DELETED"] = 8] = "DELETED";\n    RECORD_ACTIONS[RECORD_ACTIONS["WRITE_ACKNOWLEDGEMENT"] = 9] = "WRITE_ACKNOWLEDGEMENT";\n    RECORD_ACTIONS[RECORD_ACTIONS["CREATE"] = 16] = "CREATE";\n    RECORD_ACTIONS[RECORD_ACTIONS["CREATEANDUPDATE"] = 17] = "CREATEANDUPDATE";\n    RECORD_ACTIONS[RECORD_ACTIONS["CREATEANDUPDATE_WITH_WRITE_ACK"] = 18] = "CREATEANDUPDATE_WITH_WRITE_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["CREATEANDPATCH"] = 19] = "CREATEANDPATCH";\n    RECORD_ACTIONS[RECORD_ACTIONS["CREATEANDPATCH_WITH_WRITE_ACK"] = 20] = "CREATEANDPATCH_WITH_WRITE_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["UPDATE"] = 21] = "UPDATE";\n    RECORD_ACTIONS[RECORD_ACTIONS["UPDATE_WITH_WRITE_ACK"] = 22] = "UPDATE_WITH_WRITE_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["PATCH"] = 23] = "PATCH";\n    RECORD_ACTIONS[RECORD_ACTIONS["PATCH_WITH_WRITE_ACK"] = 24] = "PATCH_WITH_WRITE_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["ERASE"] = 25] = "ERASE";\n    RECORD_ACTIONS[RECORD_ACTIONS["ERASE_WITH_WRITE_ACK"] = 26] = "ERASE_WITH_WRITE_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBEANDHEAD"] = 32] = "SUBSCRIBEANDHEAD";\n    // SUBSCRIBEANDHEAD_RESPONSE = 0x21,\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBEANDHEAD_BULK"] = 112] = "SUBSCRIBEANDHEAD_BULK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBEANDHEAD_BULK_ACK"] = 240] = "SUBSCRIBEANDHEAD_BULK_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBEANDREAD"] = 34] = "SUBSCRIBEANDREAD";\n    // SUBSCRIBEANDREAD_RESPONSE = 0x23,\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBEANDREAD_BULK"] = 35] = "SUBSCRIBEANDREAD_BULK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBEANDREAD_BULK_ACK"] = 163] = "SUBSCRIBEANDREAD_BULK_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBECREATEANDREAD"] = 36] = "SUBSCRIBECREATEANDREAD";\n    // SUBSCRIBECREATEANDREAD_RESPONSE = 0x25,\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBECREATEANDREAD_BULK"] = 37] = "SUBSCRIBECREATEANDREAD_BULK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBECREATEANDREAD_BULK_ACK"] = 165] = "SUBSCRIBECREATEANDREAD_BULK_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBECREATEANDUPDATE"] = 38] = "SUBSCRIBECREATEANDUPDATE";\n    // SUBSCRIBECREATEANDUPDATE_RESPONSE = 0x27,\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBECREATEANDUPDATE_BULK"] = 38] = "SUBSCRIBECREATEANDUPDATE_BULK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBE"] = 40] = "SUBSCRIBE";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBE_ACK"] = 168] = "SUBSCRIBE_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBE_BULK"] = 120] = "SUBSCRIBE_BULK";\n    RECORD_ACTIONS[RECORD_ACTIONS["UNSUBSCRIBE"] = 41] = "UNSUBSCRIBE";\n    RECORD_ACTIONS[RECORD_ACTIONS["UNSUBSCRIBE_BULK"] = 57] = "UNSUBSCRIBE_BULK";\n    RECORD_ACTIONS[RECORD_ACTIONS["UNSUBSCRIBE_ACK"] = 169] = "UNSUBSCRIBE_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["LISTEN"] = 48] = "LISTEN";\n    RECORD_ACTIONS[RECORD_ACTIONS["LISTEN_ACK"] = 176] = "LISTEN_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["UNLISTEN"] = 49] = "UNLISTEN";\n    RECORD_ACTIONS[RECORD_ACTIONS["UNLISTEN_ACK"] = 177] = "UNLISTEN_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["LISTEN_ACCEPT"] = 50] = "LISTEN_ACCEPT";\n    RECORD_ACTIONS[RECORD_ACTIONS["LISTEN_REJECT"] = 51] = "LISTEN_REJECT";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIPTION_HAS_PROVIDER"] = 52] = "SUBSCRIPTION_HAS_PROVIDER";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIPTION_HAS_NO_PROVIDER"] = 53] = "SUBSCRIPTION_HAS_NO_PROVIDER";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIPTION_FOR_PATTERN_FOUND"] = 54] = "SUBSCRIPTION_FOR_PATTERN_FOUND";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIPTION_FOR_PATTERN_REMOVED"] = 55] = "SUBSCRIPTION_FOR_PATTERN_REMOVED";\n    RECORD_ACTIONS[RECORD_ACTIONS["CACHE_RETRIEVAL_TIMEOUT"] = 80] = "CACHE_RETRIEVAL_TIMEOUT";\n    RECORD_ACTIONS[RECORD_ACTIONS["STORAGE_RETRIEVAL_TIMEOUT"] = 81] = "STORAGE_RETRIEVAL_TIMEOUT";\n    RECORD_ACTIONS[RECORD_ACTIONS["VERSION_EXISTS"] = 82] = "VERSION_EXISTS";\n    RECORD_ACTIONS[RECORD_ACTIONS["RECORD_LOAD_ERROR"] = 83] = "RECORD_LOAD_ERROR";\n    RECORD_ACTIONS[RECORD_ACTIONS["RECORD_CREATE_ERROR"] = 84] = "RECORD_CREATE_ERROR";\n    RECORD_ACTIONS[RECORD_ACTIONS["RECORD_UPDATE_ERROR"] = 85] = "RECORD_UPDATE_ERROR";\n    RECORD_ACTIONS[RECORD_ACTIONS["RECORD_DELETE_ERROR"] = 86] = "RECORD_DELETE_ERROR";\n    RECORD_ACTIONS[RECORD_ACTIONS["RECORD_NOT_FOUND"] = 88] = "RECORD_NOT_FOUND";\n    RECORD_ACTIONS[RECORD_ACTIONS["INVALID_VERSION"] = 89] = "INVALID_VERSION";\n    RECORD_ACTIONS[RECORD_ACTIONS["INVALID_PATCH_ON_HOTPATH"] = 90] = "INVALID_PATCH_ON_HOTPATH";\n    RECORD_ACTIONS[RECORD_ACTIONS["INVALID_LISTEN_REGEX"] = 91] = "INVALID_LISTEN_REGEX";\n    RECORD_ACTIONS[RECORD_ACTIONS["MESSAGE_PERMISSION_ERROR"] = 96] = "MESSAGE_PERMISSION_ERROR";\n    RECORD_ACTIONS[RECORD_ACTIONS["MESSAGE_DENIED"] = 97] = "MESSAGE_DENIED";\n    RECORD_ACTIONS[RECORD_ACTIONS["INVALID_MESSAGE_DATA"] = 98] = "INVALID_MESSAGE_DATA";\n    RECORD_ACTIONS[RECORD_ACTIONS["MULTIPLE_SUBSCRIPTIONS"] = 99] = "MULTIPLE_SUBSCRIPTIONS";\n    RECORD_ACTIONS[RECORD_ACTIONS["NOT_SUBSCRIBED"] = 100] = "NOT_SUBSCRIBED";\n})(RECORD_ACTIONS = exports.RECORD_ACTIONS || (exports.RECORD_ACTIONS = {}));\nvar RPC_ACTIONS;\n(function (RPC_ACTIONS) {\n    RPC_ACTIONS[RPC_ACTIONS["ERROR"] = 0] = "ERROR";\n    RPC_ACTIONS[RPC_ACTIONS["REQUEST"] = 1] = "REQUEST";\n    RPC_ACTIONS[RPC_ACTIONS["ACCEPT"] = 2] = "ACCEPT";\n    RPC_ACTIONS[RPC_ACTIONS["RESPONSE"] = 3] = "RESPONSE";\n    RPC_ACTIONS[RPC_ACTIONS["REJECT"] = 4] = "REJECT";\n    RPC_ACTIONS[RPC_ACTIONS["REQUEST_ERROR"] = 5] = "REQUEST_ERROR";\n    RPC_ACTIONS[RPC_ACTIONS["PROVIDE"] = 6] = "PROVIDE";\n    RPC_ACTIONS[RPC_ACTIONS["PROVIDE_ACK"] = 134] = "PROVIDE_ACK";\n    RPC_ACTIONS[RPC_ACTIONS["UNPROVIDE"] = 7] = "UNPROVIDE";\n    RPC_ACTIONS[RPC_ACTIONS["UNPROVIDE_ACK"] = 135] = "UNPROVIDE_ACK";\n    RPC_ACTIONS[RPC_ACTIONS["NO_RPC_PROVIDER"] = 80] = "NO_RPC_PROVIDER";\n    RPC_ACTIONS[RPC_ACTIONS["ACCEPT_TIMEOUT"] = 82] = "ACCEPT_TIMEOUT";\n    RPC_ACTIONS[RPC_ACTIONS["MULTIPLE_ACCEPT"] = 83] = "MULTIPLE_ACCEPT";\n    RPC_ACTIONS[RPC_ACTIONS["INVALID_RPC_CORRELATION_ID"] = 84] = "INVALID_RPC_CORRELATION_ID";\n    RPC_ACTIONS[RPC_ACTIONS["RESPONSE_TIMEOUT"] = 85] = "RESPONSE_TIMEOUT";\n    RPC_ACTIONS[RPC_ACTIONS["MULTIPLE_RESPONSE"] = 86] = "MULTIPLE_RESPONSE";\n    RPC_ACTIONS[RPC_ACTIONS["MESSAGE_PERMISSION_ERROR"] = 96] = "MESSAGE_PERMISSION_ERROR";\n    RPC_ACTIONS[RPC_ACTIONS["MESSAGE_DENIED"] = 97] = "MESSAGE_DENIED";\n    RPC_ACTIONS[RPC_ACTIONS["INVALID_MESSAGE_DATA"] = 98] = "INVALID_MESSAGE_DATA";\n    RPC_ACTIONS[RPC_ACTIONS["MULTIPLE_PROVIDERS"] = 99] = "MULTIPLE_PROVIDERS";\n    RPC_ACTIONS[RPC_ACTIONS["NOT_PROVIDED"] = 100] = "NOT_PROVIDED";\n})(RPC_ACTIONS = exports.RPC_ACTIONS || (exports.RPC_ACTIONS = {}));\nvar PRESENCE_ACTIONS;\n(function (PRESENCE_ACTIONS) {\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["ERROR"] = 0] = "ERROR";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["QUERY_ALL"] = 1] = "QUERY_ALL";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["QUERY_ALL_RESPONSE"] = 2] = "QUERY_ALL_RESPONSE";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["QUERY"] = 3] = "QUERY";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["QUERY_RESPONSE"] = 4] = "QUERY_RESPONSE";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["PRESENCE_JOIN"] = 5] = "PRESENCE_JOIN";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["PRESENCE_JOIN_ALL"] = 6] = "PRESENCE_JOIN_ALL";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["PRESENCE_LEAVE"] = 7] = "PRESENCE_LEAVE";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["PRESENCE_LEAVE_ALL"] = 8] = "PRESENCE_LEAVE_ALL";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["SUBSCRIBE_BULK"] = 9] = "SUBSCRIBE_BULK";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["SUBSCRIBE_BULK_ACK"] = 137] = "SUBSCRIBE_BULK_ACK";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["UNSUBSCRIBE_BULK"] = 10] = "UNSUBSCRIBE_BULK";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["UNSUBSCRIBE_BULK_ACK"] = 138] = "UNSUBSCRIBE_BULK_ACK";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["SUBSCRIBE_ALL"] = 11] = "SUBSCRIBE_ALL";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["SUBSCRIBE_ALL_ACK"] = 139] = "SUBSCRIBE_ALL_ACK";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["UNSUBSCRIBE_ALL"] = 12] = "UNSUBSCRIBE_ALL";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["UNSUBSCRIBE_ALL_ACK"] = 140] = "UNSUBSCRIBE_ALL_ACK";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["SUBSCRIBE"] = 153] = "SUBSCRIBE";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["UNSUBSCRIBE"] = 152] = "UNSUBSCRIBE";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["INVALID_PRESENCE_USERS"] = 80] = "INVALID_PRESENCE_USERS";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["MESSAGE_PERMISSION_ERROR"] = 96] = "MESSAGE_PERMISSION_ERROR";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["MESSAGE_DENIED"] = 97] = "MESSAGE_DENIED";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["MULTIPLE_SUBSCRIPTIONS"] = 99] = "MULTIPLE_SUBSCRIPTIONS";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["NOT_SUBSCRIBED"] = 100] = "NOT_SUBSCRIBED";\n})(PRESENCE_ACTIONS = exports.PRESENCE_ACTIONS || (exports.PRESENCE_ACTIONS = {}));\nvar LOCK_ACTIONS;\n(function (LOCK_ACTIONS) {\n    LOCK_ACTIONS[LOCK_ACTIONS["ERROR"] = 0] = "ERROR";\n    LOCK_ACTIONS[LOCK_ACTIONS["REQUEST"] = 1] = "REQUEST";\n    LOCK_ACTIONS[LOCK_ACTIONS["RESPONSE"] = 2] = "RESPONSE";\n    LOCK_ACTIONS[LOCK_ACTIONS["RELEASE"] = 3] = "RELEASE";\n})(LOCK_ACTIONS = exports.LOCK_ACTIONS || (exports.LOCK_ACTIONS = {}));\nvar STATE_ACTIONS;\n(function (STATE_ACTIONS) {\n    STATE_ACTIONS[STATE_ACTIONS["ERROR"] = 0] = "ERROR";\n    STATE_ACTIONS[STATE_ACTIONS["ADD"] = 1] = "ADD";\n    STATE_ACTIONS[STATE_ACTIONS["REMOVE"] = 2] = "REMOVE";\n    STATE_ACTIONS[STATE_ACTIONS["REQUEST_FULL_STATE"] = 3] = "REQUEST_FULL_STATE";\n    STATE_ACTIONS[STATE_ACTIONS["FULL_STATE"] = 4] = "FULL_STATE";\n})(STATE_ACTIONS = exports.STATE_ACTIONS || (exports.STATE_ACTIONS = {}));\nvar CLUSTER_ACTIONS;\n(function (CLUSTER_ACTIONS) {\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["PING"] = 0] = "PING";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["PONG"] = 1] = "PONG";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["CLOSE"] = 2] = "CLOSE";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["REJECT"] = 3] = "REJECT";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["REJECT_DUPLICATE"] = 4] = "REJECT_DUPLICATE";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["IDENTIFICATION_REQUEST"] = 5] = "IDENTIFICATION_REQUEST";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["IDENTIFICATION_RESPONSE"] = 6] = "IDENTIFICATION_RESPONSE";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["KNOWN_PEERS"] = 7] = "KNOWN_PEERS";\n})(CLUSTER_ACTIONS = exports.CLUSTER_ACTIONS || (exports.CLUSTER_ACTIONS = {}));\nexports.ACTIONS = (_a = {},\n    _a[TOPIC.PARSER] = PARSER_ACTIONS,\n    _a[TOPIC.CONNECTION] = CONNECTION_ACTIONS,\n    _a[TOPIC.AUTH] = AUTH_ACTIONS,\n    _a[TOPIC.EVENT] = EVENT_ACTIONS,\n    _a[TOPIC.RECORD] = RECORD_ACTIONS,\n    _a[TOPIC.RPC] = RPC_ACTIONS,\n    _a[TOPIC.PRESENCE] = PRESENCE_ACTIONS,\n    _a[TOPIC.LOCK] = LOCK_ACTIONS,\n    _a[TOPIC.STATE_REGISTRY] = STATE_ACTIONS,\n    _a[TOPIC.CLUSTER] = CLUSTER_ACTIONS,\n    _a);\n\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/message-constants.ts?')},"./binary-protocol/src/message-parser.ts":function(module,exports,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(Buffer) {\n/* tslint:disable:no-bitwise */\nObject.defineProperty(exports, "__esModule", { value: true });\nvar _a, _b, _c;\nvar message_constants_1 = __webpack_require__(/*! ./message-constants */ "./binary-protocol/src/message-constants.ts");\nvar constants_1 = __webpack_require__(/*! ./constants */ "./binary-protocol/src/constants.ts");\nvar utils_1 = __webpack_require__(/*! ./utils */ "./binary-protocol/src/utils.ts");\nvar message_validator_1 = __webpack_require__(/*! ./message-validator */ "./binary-protocol/src/message-validator.ts");\nfunction isError(message) {\n    return (message.action >= 0x50 && message.action < 0x70) || message.topic === message_constants_1.TOPIC.PARSER;\n}\nexports.isError = isError;\nvar BULK_ACTIONS = (_a = {},\n    _a[message_constants_1.TOPIC.RECORD] = (_b = {},\n        _b[message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD_BULK] = message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD,\n        _b[message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD_BULK] = message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD,\n        _b[message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD_BULK] = message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD,\n        _b),\n    _a[message_constants_1.TOPIC.EVENT] = (_c = {},\n        _c[message_constants_1.EVENT_ACTIONS.SUBSCRIBE_BULK] = message_constants_1.EVENT_ACTIONS.SUBSCRIBE,\n        _c[message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE_BULK] = message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE,\n        _c),\n    _a);\nvar uuid = 0;\nfunction parse(buffer, queue) {\n    if (queue === void 0) { queue = []; }\n    var offset = 0;\n    var messages = [];\n    var _loop_1 = function () {\n        var _a = readBinary(buffer, offset), bytesConsumed = _a.bytesConsumed, rawMessage = _a.rawMessage;\n        if (!rawMessage) {\n            return "break";\n        }\n        queue.push(rawMessage);\n        offset += bytesConsumed;\n        if (rawMessage.fin) {\n            var joinedMessage = joinMessages(queue);\n            var message_1 = parseMessage(joinedMessage);\n            // @ts-ignore\n            if (message_1.parseError === undefined && !message_1.isAck && BULK_ACTIONS[message_1.topic] && BULK_ACTIONS[message_1.topic][message_1.action]) {\n                // @ts-ignore\n                var action_1 = BULK_ACTIONS[message_1.topic][message_1.action];\n                uuid++;\n                message_1.names.forEach(function (name) {\n                    messages.push({\n                        topic: message_1.topic,\n                        action: action_1,\n                        name: name,\n                        correlationId: message_1.correlationId,\n                        isBulk: true,\n                        bulkId: uuid,\n                        bulkAction: message_1.action\n                    });\n                });\n            }\n            else {\n                messages.push(message_1);\n            }\n            queue.length = 0;\n        }\n    };\n    do {\n        var state_1 = _loop_1();\n        if (state_1 === "break")\n            break;\n    } while (offset < buffer.length);\n    return messages;\n}\nexports.parse = parse;\nfunction parseData(message) {\n    if (message.parsedData !== undefined || message.data === undefined) {\n        return true;\n    }\n    if (message.payloadEncoding && message.payloadEncoding !== message_constants_1.PAYLOAD_ENCODING.JSON) {\n        return new Error("unable to parse data of type \'" + message.payloadEncoding + "\'");\n    }\n    if (typeof message.data === \'string\') {\n        return new Error(\'tried to parse string data with binary parser\');\n    }\n    message.parsedData = parseJSON(message.data);\n    if (message.parsedData === undefined) {\n        return new Error("unable to parse data " + message.data);\n    }\n    return true;\n}\nexports.parseData = parseData;\nfunction readBinary(buff, offset) {\n    if (buff.length < (offset + constants_1.HEADER_LENGTH)) {\n        return { bytesConsumed: 0 };\n    }\n    var fin = !!(buff[offset] & 0x80);\n    var topic = buff[offset] & 0x7F;\n    var action = buff[offset + 1];\n    var metaLength = buff.readUIntBE(offset + 2, 3);\n    var payloadLength = buff.readUIntBE(offset + 5, 3);\n    var messageLength = constants_1.HEADER_LENGTH + metaLength + payloadLength;\n    if (buff.length < (offset + messageLength)) {\n        return { bytesConsumed: 0 };\n    }\n    var rawHeader = buff.slice(offset, offset + constants_1.HEADER_LENGTH);\n    var rawMessage = { fin: fin, topic: topic, action: action, rawHeader: rawHeader };\n    if (metaLength > 0) {\n        rawMessage.meta = buff.slice(offset + constants_1.HEADER_LENGTH, offset + constants_1.HEADER_LENGTH + metaLength);\n    }\n    if (payloadLength > 0) {\n        rawMessage.payload = buff.slice(offset + constants_1.HEADER_LENGTH + metaLength, offset + messageLength);\n    }\n    return {\n        bytesConsumed: messageLength,\n        rawMessage: rawMessage,\n    };\n}\nfunction joinMessages(rawMessages) {\n    if (rawMessages.length === 0) {\n        throw new Error(\'parseMessage must not be called with an empty message queue\');\n    }\n    if (rawMessages.length === 1) {\n        return rawMessages[0];\n    }\n    var _a = rawMessages[0], topic = _a.topic, action = _a.action, rawHeader = _a.rawHeader;\n    var payloadSections = [];\n    var metaSections = [];\n    rawMessages.forEach(function (_a) {\n        var payloadSection = _a.payload, metaSection = _a.meta;\n        if (payloadSection) {\n            payloadSections.push(payloadSection);\n        }\n        if (metaSection) {\n            metaSections.push(metaSection);\n        }\n    });\n    var payload = Buffer.concat(payloadSections);\n    var meta = Buffer.concat(metaSections);\n    return { fin: true, topic: topic, action: action, rawHeader: rawHeader, meta: meta, payload: payload };\n}\nfunction parseMessage(rawMessage) {\n    var rawTopic = rawMessage.topic, rawAction = rawMessage.action, rawHeader = rawMessage.rawHeader;\n    if (message_constants_1.TOPIC[rawTopic] === undefined) {\n        return {\n            parseError: true,\n            action: message_constants_1.PARSER_ACTIONS.UNKNOWN_TOPIC,\n            parsedMessage: {\n                topic: rawTopic,\n                action: rawAction\n            },\n            description: "unknown topic " + rawTopic,\n            raw: rawHeader\n        };\n    }\n    var topic = rawTopic;\n    if (message_constants_1.ACTIONS[topic][rawAction] === undefined) {\n        return {\n            parseError: true,\n            action: message_constants_1.PARSER_ACTIONS.UNKNOWN_ACTION,\n            parsedMessage: {\n                topic: topic,\n                action: rawAction\n            },\n            description: "unknown " + message_constants_1.TOPIC[topic] + " action " + rawAction,\n            raw: rawHeader\n        };\n    }\n    // mask out uppermost bit(ACK)\n    var action = rawAction & 0x7F;\n    var message = { topic: topic, action: action };\n    if (rawMessage.meta && rawMessage.meta.length > 0) {\n        var meta = parseJSON(rawMessage.meta);\n        if (!meta || typeof meta !== \'object\') {\n            return {\n                parseError: true,\n                action: message_constants_1.PARSER_ACTIONS.MESSAGE_PARSE_ERROR,\n                parsedMessage: message,\n                description: "invalid meta field " + rawMessage.meta.toString(),\n                raw: rawHeader\n            };\n        }\n        var metaError = message_validator_1.validateMeta(topic, rawAction, meta);\n        if (metaError) {\n            throw new Error("invalid meta " + message_constants_1.TOPIC[message.topic] + " " + message_constants_1.ACTIONS[message.topic][message.action] + ": " + metaError);\n            // return {\n            //   parseError: true,\n            //   action: PARSER_ACTIONS.INVALID_META_PARAMS,\n            //   parsedMessage: message,\n            //   description: \'invalid ack\'\n            // }\n        }\n        addMetadataToMessage(meta, message);\n    }\n    if (rawMessage.payload !== undefined) {\n        if (!message_validator_1.hasPayload(message.topic, rawAction)) {\n            return {\n                parseError: true,\n                action: message_constants_1.PARSER_ACTIONS.INVALID_MESSAGE,\n                parsedMessage: message,\n                description: \'should not have a payload\'\n            };\n        }\n        if (!message.payloadEncoding && topic === message_constants_1.TOPIC.PARSER) {\n            message.payloadEncoding = message_constants_1.PAYLOAD_ENCODING.BINARY;\n        }\n        message.data = rawMessage.payload;\n    }\n    // if (rawMessage.payload && rawMessage.payload.length > 0) {\n    //   const payload = parseJSON(rawMessage.payload)\n    //   if (payload === undefined) {\n    //     return {\n    //       parseError: true,\n    //       description: `invalid message data ${rawMessage.payload.toString()}`,\n    //       parsedMessage: message,\n    //       raw: rawHeader\n    //     }\n    //   }\n    //   message.data = payload\n    // }\n    message.isAck = rawAction >= 0x80;\n    if (!message.isAck && rawAction >= 0x70) {\n        // Only add onto message if it\'s true\n        message.isBulk = true;\n    }\n    message.isError = isError(message);\n    if (message.topic === message_constants_1.TOPIC.RECORD && utils_1.isWriteAck(rawAction)) {\n        message.isWriteAck = true;\n    }\n    return message;\n}\nfunction addMetadataToMessage(meta, message) {\n    for (var key in message_constants_1.META_KEYS) {\n        var value = meta[message_constants_1.META_KEYS[key]];\n        if (value !== undefined) {\n            message[key] = value;\n        }\n    }\n}\nfunction parseJSON(buff) {\n    try {\n        return JSON.parse(buff.toString());\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nexports.parseJSON = parseJSON;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/buffer/index.js */ "./node_modules/buffer/index.js").Buffer))\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/message-parser.ts?')},"./binary-protocol/src/message-validator.ts":function(module,exports,__webpack_require__){"use strict";eval('\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\nvar message_constants_1 = __webpack_require__(/*! ./message-constants */ "./binary-protocol/src/message-constants.ts");\n/*\n * Specification of  fields within Meta Params used for message validation\n * (see `validateMeta`)\n *\n * META_PARAMS_SPEC[topic][action] => [required, optional]\n * The keys in `required` must be present in all instances of the message\n * The keys in `optional` may be present in some instances of the message\n */\nexports.META_PARAMS_SPEC = (_a = {},\n    _a[message_constants_1.TOPIC.PARSER] = (_b = {},\n        _b[message_constants_1.PARSER_ACTIONS.UNKNOWN_TOPIC] = [[message_constants_1.META_KEYS.originalTopic], []],\n        _b[message_constants_1.PARSER_ACTIONS.UNKNOWN_ACTION] = [[message_constants_1.META_KEYS.originalTopic, message_constants_1.META_KEYS.originalAction], []],\n        _b[message_constants_1.PARSER_ACTIONS.INVALID_MESSAGE] = [[], []],\n        _b[message_constants_1.PARSER_ACTIONS.INVALID_META_PARAMS] = [[message_constants_1.META_KEYS.originalTopic, message_constants_1.META_KEYS.originalAction], []],\n        _b),\n    _a[message_constants_1.TOPIC.CONNECTION] = (_c = {},\n        _c[message_constants_1.CONNECTION_ACTIONS.PING] = [[], []],\n        _c[message_constants_1.CONNECTION_ACTIONS.PONG] = [[], []],\n        _c[message_constants_1.CONNECTION_ACTIONS.CHALLENGE] = [[message_constants_1.META_KEYS.url, message_constants_1.META_KEYS.protocolVersion], []],\n        _c[message_constants_1.CONNECTION_ACTIONS.ACCEPT] = [[], []],\n        _c[message_constants_1.CONNECTION_ACTIONS.REJECT] = [[], []],\n        _c[message_constants_1.CONNECTION_ACTIONS.REDIRECT] = [[message_constants_1.META_KEYS.url], []],\n        _c[message_constants_1.CONNECTION_ACTIONS.CLOSING] = [[], []],\n        _c[message_constants_1.CONNECTION_ACTIONS.CLOSED] = [[], []],\n        _c[message_constants_1.CONNECTION_ACTIONS.ERROR] = [[], []],\n        _c[message_constants_1.CONNECTION_ACTIONS.AUTHENTICATION_TIMEOUT] = [[], []],\n        _c[message_constants_1.CONNECTION_ACTIONS.INVALID_MESSAGE] = [[message_constants_1.META_KEYS.originalTopic, message_constants_1.META_KEYS.originalAction], []],\n        _c),\n    _a[message_constants_1.TOPIC.AUTH] = (_d = {},\n        _d[message_constants_1.AUTH_ACTIONS.REQUEST] = [[], []],\n        _d[message_constants_1.AUTH_ACTIONS.AUTH_SUCCESSFUL] = [[], []],\n        _d[message_constants_1.AUTH_ACTIONS.AUTH_UNSUCCESSFUL] = [[], []],\n        _d[message_constants_1.AUTH_ACTIONS.TOO_MANY_AUTH_ATTEMPTS] = [[], []],\n        _d[message_constants_1.AUTH_ACTIONS.INVALID_MESSAGE] = [[message_constants_1.META_KEYS.originalTopic, message_constants_1.META_KEYS.originalAction], []],\n        _d[message_constants_1.AUTH_ACTIONS.INVALID_MESSAGE_DATA] = [[message_constants_1.META_KEYS.originalAction], []],\n        _d),\n    _a[message_constants_1.TOPIC.RECORD] = (_e = {},\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIBE] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIBE_BULK] = [[message_constants_1.META_KEYS.names], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIBE_ACK] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE_ACK] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.MULTIPLE_SUBSCRIPTIONS] = [[message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.originalAction]],\n        _e[message_constants_1.RECORD_ACTIONS.NOT_SUBSCRIBED] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.HEAD] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD_BULK] = [[message_constants_1.META_KEYS.names], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD_BULK_ACK] = [[message_constants_1.META_KEYS.correlationId], []],\n        _e[message_constants_1.RECORD_ACTIONS.HEAD_RESPONSE] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], []],\n        _e[message_constants_1.RECORD_ACTIONS.READ] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD_BULK] = [[message_constants_1.META_KEYS.names], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD_BULK_ACK] = [[message_constants_1.META_KEYS.correlationId], []],\n        _e[message_constants_1.RECORD_ACTIONS.READ_RESPONSE] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], []],\n        _e[message_constants_1.RECORD_ACTIONS.UPDATE] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], []],\n        _e[message_constants_1.RECORD_ACTIONS.UPDATE_WITH_WRITE_ACK] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.correlationId], []],\n        _e[message_constants_1.RECORD_ACTIONS.PATCH] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path], []],\n        _e[message_constants_1.RECORD_ACTIONS.PATCH_WITH_WRITE_ACK] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path, message_constants_1.META_KEYS.correlationId], []],\n        _e[message_constants_1.RECORD_ACTIONS.ERASE] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path], []],\n        _e[message_constants_1.RECORD_ACTIONS.ERASE_WITH_WRITE_ACK] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path, message_constants_1.META_KEYS.correlationId], []],\n        _e[message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDUPDATE] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], []],\n        _e[message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE_WITH_WRITE_ACK] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.correlationId], []],\n        _e[message_constants_1.RECORD_ACTIONS.CREATEANDPATCH] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path], []],\n        _e[message_constants_1.RECORD_ACTIONS.CREATEANDPATCH_WITH_WRITE_ACK] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path, message_constants_1.META_KEYS.correlationId], []],\n        _e[message_constants_1.RECORD_ACTIONS.DELETE] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.DELETED] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD_BULK] = [[message_constants_1.META_KEYS.names], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD_BULK_ACK] = [[message_constants_1.META_KEYS.correlationId], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_PROVIDER] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_NO_PROVIDER] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.WRITE_ACKNOWLEDGEMENT] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        _e[message_constants_1.RECORD_ACTIONS.VERSION_EXISTS] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], [message_constants_1.META_KEYS.originalAction]],\n        _e[message_constants_1.RECORD_ACTIONS.CACHE_RETRIEVAL_TIMEOUT] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.STORAGE_RETRIEVAL_TIMEOUT] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.RECORD_LOAD_ERROR] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.RECORD_CREATE_ERROR] = [[message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.originalAction]],\n        _e[message_constants_1.RECORD_ACTIONS.RECORD_UPDATE_ERROR] = [[message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.originalAction]],\n        _e[message_constants_1.RECORD_ACTIONS.RECORD_DELETE_ERROR] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.RECORD_NOT_FOUND] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.originalAction], []],\n        _e[message_constants_1.RECORD_ACTIONS.INVALID_VERSION] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.correlationId]],\n        _e[message_constants_1.RECORD_ACTIONS.INVALID_PATCH_ON_HOTPATH] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.correlationId]],\n        _e[message_constants_1.RECORD_ACTIONS.LISTEN] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.LISTEN_ACK] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.UNLISTEN] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.UNLISTEN_ACK] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        _e[message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        _e[message_constants_1.RECORD_ACTIONS.LISTEN_ACCEPT] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        _e[message_constants_1.RECORD_ACTIONS.LISTEN_REJECT] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        _e[message_constants_1.RECORD_ACTIONS.INVALID_LISTEN_REGEX] = [[message_constants_1.META_KEYS.name], []],\n        _e[message_constants_1.RECORD_ACTIONS.MESSAGE_PERMISSION_ERROR] = [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId]],\n        _e[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED] = [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId]],\n        _e[message_constants_1.RECORD_ACTIONS.INVALID_MESSAGE_DATA] = [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId]],\n        _e),\n    _a[message_constants_1.TOPIC.RPC] = (_f = {},\n        _f[message_constants_1.RPC_ACTIONS.REQUEST_ERROR] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], [message_constants_1.META_KEYS.reason]],\n        _f[message_constants_1.RPC_ACTIONS.REQUEST] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], [message_constants_1.META_KEYS.requestorName, message_constants_1.META_KEYS.requestorData, message_constants_1.META_KEYS.trustedSender]],\n        _f[message_constants_1.RPC_ACTIONS.ACCEPT] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        _f[message_constants_1.RPC_ACTIONS.REJECT] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        _f[message_constants_1.RPC_ACTIONS.RESPONSE] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        _f[message_constants_1.RPC_ACTIONS.PROVIDE] = [[message_constants_1.META_KEYS.name], []],\n        _f[message_constants_1.RPC_ACTIONS.PROVIDE_ACK] = [[message_constants_1.META_KEYS.name], []],\n        _f[message_constants_1.RPC_ACTIONS.UNPROVIDE] = [[message_constants_1.META_KEYS.name], []],\n        _f[message_constants_1.RPC_ACTIONS.UNPROVIDE_ACK] = [[message_constants_1.META_KEYS.name], []],\n        _f[message_constants_1.RPC_ACTIONS.MULTIPLE_PROVIDERS] = [[message_constants_1.META_KEYS.correlationId], []],\n        _f[message_constants_1.RPC_ACTIONS.NOT_PROVIDED] = [[message_constants_1.META_KEYS.correlationId], []],\n        _f[message_constants_1.RPC_ACTIONS.MULTIPLE_RESPONSE] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        _f[message_constants_1.RPC_ACTIONS.RESPONSE_TIMEOUT] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        _f[message_constants_1.RPC_ACTIONS.INVALID_RPC_CORRELATION_ID] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.originalAction], []],\n        _f[message_constants_1.RPC_ACTIONS.MULTIPLE_ACCEPT] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        _f[message_constants_1.RPC_ACTIONS.ACCEPT_TIMEOUT] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        _f[message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        _f[message_constants_1.RPC_ACTIONS.MESSAGE_PERMISSION_ERROR] = [[message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId]],\n        _f[message_constants_1.RPC_ACTIONS.MESSAGE_DENIED] = [[message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId]],\n        _f[message_constants_1.RPC_ACTIONS.INVALID_MESSAGE_DATA] = [[message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId]],\n        _f),\n    _a[message_constants_1.TOPIC.EVENT] = (_g = {},\n        _g[message_constants_1.EVENT_ACTIONS.EMIT] = [[message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.SUBSCRIBE] = [[message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.SUBSCRIBE_ACK] = [[message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.SUBSCRIBE_BULK] = [[message_constants_1.META_KEYS.names, message_constants_1.META_KEYS.correlationId], []],\n        _g[message_constants_1.EVENT_ACTIONS.SUBSCRIBE_BULK_ACK] = [[message_constants_1.META_KEYS.correlationId], []],\n        _g[message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE] = [[message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE_ACK] = [[message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE_BULK] = [[message_constants_1.META_KEYS.names, message_constants_1.META_KEYS.correlationId], []],\n        _g[message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE_BULK_ACK] = [[message_constants_1.META_KEYS.correlationId], []],\n        _g[message_constants_1.EVENT_ACTIONS.MULTIPLE_SUBSCRIPTIONS] = [[message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.NOT_SUBSCRIBED] = [[message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.MESSAGE_PERMISSION_ERROR] = [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.MESSAGE_DENIED] = [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.LISTEN] = [[message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.LISTEN_ACK] = [[message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.UNLISTEN] = [[message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.UNLISTEN_ACK] = [[message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        _g[message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        _g[message_constants_1.EVENT_ACTIONS.LISTEN_ACCEPT] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        _g[message_constants_1.EVENT_ACTIONS.LISTEN_REJECT] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        _g[message_constants_1.EVENT_ACTIONS.INVALID_LISTEN_REGEX] = [[message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.MESSAGE_PERMISSION_ERROR] = [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.MESSAGE_DENIED] = [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], []],\n        _g[message_constants_1.EVENT_ACTIONS.INVALID_MESSAGE_DATA] = [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.originalAction], []],\n        _g),\n    _a[message_constants_1.TOPIC.PRESENCE] = (_h = {},\n        _h[message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_BULK] = [[message_constants_1.META_KEYS.names, message_constants_1.META_KEYS.correlationId], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_BULK_ACK] = [[message_constants_1.META_KEYS.correlationId], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_ALL] = [[], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_ALL_ACK] = [[], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_BULK] = [[message_constants_1.META_KEYS.names, message_constants_1.META_KEYS.correlationId], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_BULK_ACK] = [[message_constants_1.META_KEYS.correlationId], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_ALL] = [[message_constants_1.META_KEYS.correlationId], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_ALL_ACK] = [[message_constants_1.META_KEYS.correlationId], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.NOT_SUBSCRIBED] = [[], [message_constants_1.META_KEYS.correlationId]],\n        _h[message_constants_1.PRESENCE_ACTIONS.MULTIPLE_SUBSCRIPTIONS] = [[], [message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.originalAction]],\n        _h[message_constants_1.PRESENCE_ACTIONS.QUERY] = [[message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.names], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.QUERY_RESPONSE] = [[message_constants_1.META_KEYS.correlationId], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.QUERY_ALL] = [[], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.QUERY_ALL_RESPONSE] = [[message_constants_1.META_KEYS.names], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.PRESENCE_JOIN] = [[message_constants_1.META_KEYS.name], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.PRESENCE_LEAVE] = [[message_constants_1.META_KEYS.name], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.PRESENCE_JOIN_ALL] = [[message_constants_1.META_KEYS.name], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.PRESENCE_LEAVE_ALL] = [[message_constants_1.META_KEYS.name], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.INVALID_PRESENCE_USERS] = [[], []],\n        _h[message_constants_1.PRESENCE_ACTIONS.MESSAGE_PERMISSION_ERROR] = [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId]],\n        _h[message_constants_1.PRESENCE_ACTIONS.MESSAGE_DENIED] = [[message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.name]],\n        _h),\n    _a[message_constants_1.TOPIC.CLUSTER] = (_j = {},\n        _j[message_constants_1.CLUSTER_ACTIONS.CLOSE] = [[], []],\n        _j[message_constants_1.CLUSTER_ACTIONS.IDENTIFICATION_REQUEST] = [[], []],\n        _j[message_constants_1.CLUSTER_ACTIONS.IDENTIFICATION_RESPONSE] = [[], []],\n        _j[message_constants_1.CLUSTER_ACTIONS.KNOWN_PEERS] = [[], []],\n        _j[message_constants_1.CLUSTER_ACTIONS.PING] = [[], []],\n        _j[message_constants_1.CLUSTER_ACTIONS.PONG] = [[], []],\n        _j[message_constants_1.CLUSTER_ACTIONS.REJECT] = [[], []],\n        _j[message_constants_1.CLUSTER_ACTIONS.REJECT_DUPLICATE] = [[], []],\n        _j),\n    _a[message_constants_1.TOPIC.STATE_REGISTRY] = (_k = {},\n        _k[message_constants_1.STATE_ACTIONS.ERROR] = [[message_constants_1.META_KEYS.registryTopic], []],\n        _k[message_constants_1.STATE_ACTIONS.ADD] = [[message_constants_1.META_KEYS.registryTopic], []],\n        _k[message_constants_1.STATE_ACTIONS.REMOVE] = [[message_constants_1.META_KEYS.registryTopic], []],\n        _k[message_constants_1.STATE_ACTIONS.REQUEST_FULL_STATE] = [[message_constants_1.META_KEYS.registryTopic], []],\n        _k[message_constants_1.STATE_ACTIONS.FULL_STATE] = [[message_constants_1.META_KEYS.registryTopic], []],\n        _k),\n    _a[message_constants_1.TOPIC.LOCK] = {},\n    _a);\nvar payloadMap = (_l = {},\n    _l[message_constants_1.TOPIC.PARSER] = [\n        message_constants_1.PARSER_ACTIONS.MESSAGE_PARSE_ERROR,\n        message_constants_1.PARSER_ACTIONS.INVALID_META_PARAMS,\n    ],\n    _l[message_constants_1.TOPIC.AUTH] = [\n        message_constants_1.AUTH_ACTIONS.REQUEST,\n        message_constants_1.AUTH_ACTIONS.AUTH_SUCCESSFUL,\n        message_constants_1.AUTH_ACTIONS.AUTH_UNSUCCESSFUL,\n    ],\n    _l[message_constants_1.TOPIC.RECORD] = [\n        message_constants_1.RECORD_ACTIONS.READ_RESPONSE,\n        message_constants_1.RECORD_ACTIONS.UPDATE,\n        message_constants_1.RECORD_ACTIONS.UPDATE_WITH_WRITE_ACK,\n        message_constants_1.RECORD_ACTIONS.PATCH,\n        message_constants_1.RECORD_ACTIONS.PATCH_WITH_WRITE_ACK,\n        message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE,\n        message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE_WITH_WRITE_ACK,\n        message_constants_1.RECORD_ACTIONS.CREATEANDPATCH,\n        message_constants_1.RECORD_ACTIONS.CREATEANDPATCH_WITH_WRITE_ACK,\n        message_constants_1.RECORD_ACTIONS.VERSION_EXISTS,\n    ],\n    _l[message_constants_1.TOPIC.RPC] = [\n        message_constants_1.RPC_ACTIONS.REQUEST,\n        message_constants_1.RPC_ACTIONS.RESPONSE,\n        message_constants_1.RPC_ACTIONS.REQUEST_ERROR\n    ],\n    _l[message_constants_1.TOPIC.EVENT] = [\n        message_constants_1.EVENT_ACTIONS.EMIT,\n    ],\n    _l[message_constants_1.TOPIC.PRESENCE] = [\n        message_constants_1.PRESENCE_ACTIONS.QUERY_RESPONSE,\n    ],\n    _l[message_constants_1.TOPIC.CLUSTER] = [\n        message_constants_1.CLUSTER_ACTIONS.IDENTIFICATION_REQUEST,\n        message_constants_1.CLUSTER_ACTIONS.IDENTIFICATION_RESPONSE,\n        message_constants_1.CLUSTER_ACTIONS.KNOWN_PEERS\n    ],\n    _l[message_constants_1.TOPIC.STATE_REGISTRY] = [\n        message_constants_1.STATE_ACTIONS.FULL_STATE\n    ],\n    _l[message_constants_1.TOPIC.LOCK] = [],\n    _l);\nfunction mapOfArraysHas(map, topic, action) {\n    var actions = map[topic];\n    if (!actions) {\n        return false;\n    }\n    return actions.indexOf(action) !== -1;\n}\nexports.hasPayload = function (topic, action) {\n    return mapOfArraysHas(payloadMap, topic, action);\n};\nfunction validateUnkownMeta(topic, action, meta) {\n    var spec = exports.META_PARAMS_SPEC[topic][action];\n    if (!spec) {\n        return \'no meta spec\';\n    }\n    var _a = __read(spec, 2), required = _a[0], optional = _a[1];\n    for (var key in meta) {\n        if (meta[key] !== undefined\n            && required.indexOf(key) === -1\n            && optional.indexOf(key) === -1) {\n            return "meta object has unknown key " + key;\n        }\n    }\n    return;\n}\nexports.validateUnkownMeta = validateUnkownMeta;\nfunction validateMeta(topic, action, meta) {\n    var e_1, _a;\n    var spec = exports.META_PARAMS_SPEC[topic][action];\n    if (!spec) {\n        return \'no meta spec\';\n    }\n    var _b = __read(spec, 1), required = _b[0];\n    try {\n        for (var required_1 = __values(required), required_1_1 = required_1.next(); !required_1_1.done; required_1_1 = required_1.next()) {\n            var req = required_1_1.value;\n            if (meta[req] === undefined) {\n                return "meta object does not have required key " + req;\n            }\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (required_1_1 && !required_1_1.done && (_a = required_1.return)) _a.call(required_1);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return;\n}\nexports.validateMeta = validateMeta;\nfunction hasCorrelationId(topic, action) {\n    var spec = exports.META_PARAMS_SPEC[topic][action];\n    if (!spec) {\n        return;\n    }\n    var _a = __read(spec, 2), required = _a[0], optional = _a[1];\n    return (required.indexOf(message_constants_1.META_KEYS.correlationId) !== -1) || (optional.indexOf(message_constants_1.META_KEYS.correlationId) !== -1);\n}\nexports.hasCorrelationId = hasCorrelationId;\n\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/message-validator.ts?')},"./binary-protocol/src/utils.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar _a, _b, _c, _d, _e;\nvar message_constants_1 = __webpack_require__(/*! ./message-constants */ "./binary-protocol/src/message-constants.ts");\nfunction isWriteAck(action) {\n    return action === message_constants_1.RECORD_ACTIONS.CREATEANDPATCH_WITH_WRITE_ACK\n        || action === message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE_WITH_WRITE_ACK\n        || action === message_constants_1.RECORD_ACTIONS.PATCH_WITH_WRITE_ACK\n        || action === message_constants_1.RECORD_ACTIONS.UPDATE_WITH_WRITE_ACK\n        || action === message_constants_1.RECORD_ACTIONS.ERASE_WITH_WRITE_ACK\n        || action === message_constants_1.RECORD_ACTIONS.WRITE_ACKNOWLEDGEMENT;\n}\nexports.isWriteAck = isWriteAck;\nexports.ACTION_TO_WRITE_ACK = (_a = {},\n    _a[message_constants_1.RECORD_ACTIONS.CREATEANDPATCH] = message_constants_1.RECORD_ACTIONS.CREATEANDPATCH_WITH_WRITE_ACK,\n    _a[message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE] = message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE_WITH_WRITE_ACK,\n    _a[message_constants_1.RECORD_ACTIONS.PATCH] = message_constants_1.RECORD_ACTIONS.PATCH_WITH_WRITE_ACK,\n    _a[message_constants_1.RECORD_ACTIONS.UPDATE] = message_constants_1.RECORD_ACTIONS.UPDATE_WITH_WRITE_ACK,\n    _a[message_constants_1.RECORD_ACTIONS.ERASE] = message_constants_1.RECORD_ACTIONS.ERASE_WITH_WRITE_ACK,\n    _a);\n/**\n * Like reverseMap but the values will be cast using Number(k)\n */\nfunction reverseMapNumeric(map) {\n    var reversedMap = {};\n    for (var key in map) {\n        reversedMap[map[key]] = Number(key);\n    }\n    return reversedMap;\n}\nexports.reverseMapNumeric = reverseMapNumeric;\nexports.WRITE_ACK_TO_ACTION = reverseMapNumeric(exports.ACTION_TO_WRITE_ACK);\nexports.RESPONSE_TO_REQUEST = (_b = {},\n    _b[message_constants_1.TOPIC.RECORD] = (_c = {},\n        _c[message_constants_1.RECORD_ACTIONS.HEAD_RESPONSE] = message_constants_1.RECORD_ACTIONS.HEAD,\n        _c[message_constants_1.RECORD_ACTIONS.READ_RESPONSE] = message_constants_1.RECORD_ACTIONS.READ,\n        _c[message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS] = message_constants_1.RECORD_ACTIONS.DELETE,\n        _c),\n    _b[message_constants_1.TOPIC.PRESENCE] = (_d = {},\n        _d[message_constants_1.PRESENCE_ACTIONS.QUERY_RESPONSE] = message_constants_1.PRESENCE_ACTIONS.QUERY,\n        _d[message_constants_1.PRESENCE_ACTIONS.QUERY_ALL_RESPONSE] = message_constants_1.PRESENCE_ACTIONS.QUERY_ALL,\n        _d),\n    _b[message_constants_1.TOPIC.RPC] = (_e = {},\n        _e[message_constants_1.RPC_ACTIONS.ACCEPT] = message_constants_1.RPC_ACTIONS.REQUEST,\n        _e[message_constants_1.RPC_ACTIONS.ERROR] = message_constants_1.RPC_ACTIONS.REQUEST,\n        _e),\n    _b[message_constants_1.TOPIC.EVENT] = {},\n    _b);\n\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/utils.ts?')},"./node_modules/base64-js/index.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://deepstream/./node_modules/base64-js/index.js?")},"./node_modules/buffer/index.js":function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/buffer/node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://deepstream/./node_modules/buffer/index.js?")},"./node_modules/buffer/node_modules/isarray/index.js":function(module,exports){eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack://deepstream/./node_modules/buffer/node_modules/isarray/index.js?")},"./node_modules/component-emitter2/index.js":function(module,exports,__webpack_require__){eval("\n/**\n * Expose `Emitter`.\n */\n\nif (true) {\n  module.exports = Emitter;\n}\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || Object.create(null);\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || Object.create(null);\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = Object.create(null);\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n\n  // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n  if (callbacks.length === 0) {\n    delete this._callbacks[event];\n  }\n\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || Object.create(null);\n\n  var args = new Array(arguments.length - 1)\n    , callbacks = this._callbacks[event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || Object.create(null);\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n/**\n * Returns an array listing the events for which the emitter has registered listeners.\n *\n * @return {Array}\n * @api public\n */\nEmitter.prototype.eventNames = function(){\n  return this._callbacks ? Object.keys(this._callbacks) : [];\n}\n\n\n//# sourceURL=webpack://deepstream/./node_modules/component-emitter2/index.js?")},"./node_modules/ieee754/index.js":function(module,exports){eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://deepstream/./node_modules/ieee754/index.js?")},"./node_modules/webpack/buildin/global.js":function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://deepstream/(webpack)/buildin/global.js?')},"./src/client-options.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar merge_strategy_1 = __webpack_require__(/*! ./record/merge-strategy */ \"./src/record/merge-strategy.ts\");\nexports.DefaultOptions = {\n    timerResolution: 50,\n    subscriptionInterval: 100,\n    offlineEnabled: true,\n    heartbeatInterval: 30000,\n    reconnectIntervalIncrement: 4000,\n    maxReconnectInterval: 180000,\n    maxReconnectAttempts: 5,\n    rpcAcceptTimeout: 6000,\n    rpcResponseTimeout: 10000,\n    subscriptionTimeout: 2000,\n    recordReadAckTimeout: 15000,\n    recordReadTimeout: 15000,\n    recordDeleteTimeout: 15000,\n    offlineBufferTimeout: 2000,\n    discardTimeout: 5000,\n    path: '/deepstream',\n    mergeStrategy: merge_strategy_1.REMOTE_WINS,\n    recordDeepCopy: true,\n    socketOptions: null,\n    dirtyStorageName: '__ds__dirty_records',\n    nodeStoragePath: './local-storage',\n    indexdb: {\n        dbVersion: 2,\n        storageDatabaseName: 'deepstream',\n        defaultObjectStoreName: 'records',\n        objectStoreNames: ['one', 'two', 'three'],\n        flushTimeout: 50\n    },\n    nodeStorageSize: 5,\n    lazyConnect: false,\n};\n\n\n//# sourceURL=webpack://deepstream/./src/client-options.ts?")},"./src/client.ts":function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar client_options_1 = __webpack_require__(/*! ./client-options */ "./src/client-options.ts");\nvar logger_1 = __webpack_require__(/*! ./util/logger */ "./src/util/logger.ts");\nvar timeout_registry_1 = __webpack_require__(/*! ./util/timeout-registry */ "./src/util/timeout-registry.ts");\nvar timer_registry_1 = __webpack_require__(/*! ./util/timer-registry */ "./src/util/timer-registry.ts");\nvar connection_1 = __webpack_require__(/*! ./connection/connection */ "./src/connection/connection.ts");\nvar socket_factory_1 = __webpack_require__(/*! ./connection/socket-factory */ "./src/connection/socket-factory.ts");\nvar event_handler_1 = __webpack_require__(/*! ./event/event-handler */ "./src/event/event-handler.ts");\nvar rpc_handler_1 = __webpack_require__(/*! ./rpc/rpc-handler */ "./src/rpc/rpc-handler.ts");\nvar record_handler_1 = __webpack_require__(/*! ./record/record-handler */ "./src/record/record-handler.ts");\nvar presence_handler_1 = __webpack_require__(/*! ./presence/presence-handler */ "./src/presence/presence-handler.ts");\nvar EventEmitter = __webpack_require__(/*! component-emitter2 */ "./node_modules/component-emitter2/index.js");\nvar indexdb_storage_service_1 = __webpack_require__(/*! ./storage/indexdb-storage-service */ "./src/storage/indexdb-storage-service.ts");\nvar noop_storage_service_1 = __webpack_require__(/*! ./storage/noop-storage-service */ "./src/storage/noop-storage-service.ts");\nvar Client = /** @class */ (function (_super) {\n    __extends(Client, _super);\n    function Client(url, options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        _this.options = __assign({}, client_options_1.DefaultOptions, options);\n        // @ts-ignore\n        var services = {};\n        services.logger = new logger_1.Logger(_this);\n        services.timerRegistry = new timer_registry_1.TimerRegistry(_this.options.timerResolution);\n        services.timeoutRegistry = new timeout_registry_1.TimeoutRegistry(services, _this.options);\n        services.socketFactory = _this.options.socketFactory || socket_factory_1.socketFactory;\n        services.connection = new connection_1.Connection(services, _this.options, url, _this);\n        if (_this.options.offlineEnabled) {\n            services.storage = _this.options.storage || new indexdb_storage_service_1.Storage(_this.options);\n        }\n        else {\n            services.storage = new noop_storage_service_1.NoopStorage();\n        }\n        _this.services = services;\n        _this.services.connection.onLost(services.timeoutRegistry.onConnectionLost.bind(services.timeoutRegistry));\n        _this.event = new event_handler_1.EventHandler(_this.services, _this.options);\n        _this.rpc = new rpc_handler_1.RPCHandler(_this.services, _this.options);\n        _this.record = new record_handler_1.RecordHandler(_this.services, _this.options);\n        _this.presence = new presence_handler_1.PresenceHandler(_this.services, _this.options);\n        return _this;\n    }\n    Client.prototype.login = function (detailsOrCallback, callback) {\n        var _this = this;\n        if (detailsOrCallback && typeof detailsOrCallback === \'object\') {\n            if (callback) {\n                this.services.connection.authenticate(detailsOrCallback, callback);\n            }\n            else {\n                return new Promise(function (resolve, reject) {\n                    _this.services.connection.authenticate(detailsOrCallback, function (success, data) {\n                        success ? resolve(data) : reject(data);\n                    });\n                });\n            }\n        }\n        else {\n            if (typeof detailsOrCallback === \'function\') {\n                this.services.connection.authenticate({}, detailsOrCallback);\n            }\n            else {\n                return new Promise(function (resolve, reject) {\n                    _this.services.connection.authenticate({}, function (success, data) {\n                        success ? resolve(data) : reject(data);\n                    });\n                });\n            }\n        }\n    };\n    Client.prototype.getConnectionState = function () {\n        return this.services.connection.getConnectionState();\n    };\n    Client.prototype.close = function () {\n        this.services.connection.close();\n    };\n    Client.prototype.pause = function () {\n        this.services.connection.pause();\n    };\n    Client.prototype.resume = function (callback) {\n        var _this = this;\n        if (callback) {\n            this.services.connection.resume(callback);\n            return;\n        }\n        return new Promise(function (resolve, reject) {\n            _this.services.connection.resume(function (error) {\n                error ? reject(error) : resolve();\n            });\n        });\n    };\n    /**\n    * Returns a random string. The first block of characters\n    * is a timestamp, in order to allow databases to optimize for semi-\n    * sequential numberings\n    */\n    Client.prototype.getUid = function () {\n        var timestamp = (new Date()).getTime().toString(36);\n        var randomString = (Math.random() * 10000000000000000).toString(36).replace(\'.\', \'\');\n        return timestamp + "-" + randomString;\n    };\n    return Client;\n}(EventEmitter));\nexports.Client = Client;\n\n\n//# sourceURL=webpack://deepstream/./src/client.ts?')},"./src/connection/connection.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\nvar message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nvar message_parser_1 = __webpack_require__(/*! ../../binary-protocol/src/message-parser */ "./binary-protocol/src/message-parser.ts");\nvar state_machine_1 = __webpack_require__(/*! ../util/state-machine */ "./src/util/state-machine.ts");\nvar utils = __webpack_require__(/*! ../util/utils */ "./src/util/utils.ts");\nvar Emitter = __webpack_require__(/*! component-emitter2 */ "./node_modules/component-emitter2/index.js");\nvar Connection = /** @class */ (function () {\n    function Connection(services, options, url, emitter) {\n        var _this = this;\n        this.services = services;\n        this.options = options;\n        this.reconnectTimeout = -1;\n        this.authParams = null;\n        this.handlers = new Map();\n        this.authCallback = null;\n        this.resumeCallback = null;\n        this.emitter = emitter;\n        this.internalEmitter = new Emitter();\n        this.isInLimbo = true;\n        this.clientData = null;\n        this.heartbeatIntervalTimeout = null;\n        this.endpoint = null;\n        this.reconnectionAttempt = 0;\n        this.limboTimeout = null;\n        var isReconnecting = false;\n        var firstOpen = true;\n        this.stateMachine = new state_machine_1.StateMachine(this.services.logger, {\n            init: constants_1.CONNECTION_STATE.CLOSED,\n            onStateChanged: function (newState, oldState) {\n                if (newState === oldState) {\n                    return;\n                }\n                emitter.emit(constants_1.EVENT.CONNECTION_STATE_CHANGED, newState);\n                if (newState === constants_1.CONNECTION_STATE.RECONNECTING) {\n                    _this.isInLimbo = true;\n                    isReconnecting = true;\n                    if (oldState !== constants_1.CONNECTION_STATE.CLOSED) {\n                        _this.internalEmitter.emit(constants_1.EVENT.CONNECTION_LOST);\n                        _this.limboTimeout = _this.services.timerRegistry.add({\n                            duration: _this.options.offlineBufferTimeout,\n                            context: _this,\n                            callback: function () {\n                                _this.isInLimbo = false;\n                                _this.internalEmitter.emit(constants_1.EVENT.EXIT_LIMBO);\n                            }\n                        });\n                    }\n                }\n                else if (newState === constants_1.CONNECTION_STATE.OPEN && (isReconnecting || firstOpen)) {\n                    firstOpen = false;\n                    _this.isInLimbo = false;\n                    _this.internalEmitter.emit(constants_1.EVENT.CONNECTION_REESTABLISHED);\n                    _this.services.timerRegistry.remove(_this.limboTimeout);\n                }\n            },\n            transitions: [\n                { name: "initialised" /* INITIALISED */, from: constants_1.CONNECTION_STATE.CLOSED, to: constants_1.CONNECTION_STATE.INITIALISING },\n                { name: "connected" /* CONNECTED */, from: constants_1.CONNECTION_STATE.INITIALISING, to: constants_1.CONNECTION_STATE.AWAITING_CONNECTION },\n                { name: "connected" /* CONNECTED */, from: constants_1.CONNECTION_STATE.REDIRECTING, to: constants_1.CONNECTION_STATE.AWAITING_CONNECTION },\n                { name: "connected" /* CONNECTED */, from: constants_1.CONNECTION_STATE.RECONNECTING, to: constants_1.CONNECTION_STATE.AWAITING_CONNECTION },\n                { name: "challenge" /* CHALLENGE */, from: constants_1.CONNECTION_STATE.AWAITING_CONNECTION, to: constants_1.CONNECTION_STATE.CHALLENGING },\n                { name: "redirected" /* CONNECTION_REDIRECTED */, from: constants_1.CONNECTION_STATE.CHALLENGING, to: constants_1.CONNECTION_STATE.REDIRECTING },\n                { name: "challenge-denied" /* CHALLENGE_DENIED */, from: constants_1.CONNECTION_STATE.CHALLENGING, to: constants_1.CONNECTION_STATE.CHALLENGE_DENIED },\n                { name: "accepted" /* CHALLENGE_ACCEPTED */, from: constants_1.CONNECTION_STATE.CHALLENGING, to: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION, handler: this.onAwaitingAuthentication.bind(this) },\n                { name: "authentication-timeout" /* AUTHENTICATION_TIMEOUT */, from: constants_1.CONNECTION_STATE.AWAITING_CONNECTION, to: constants_1.CONNECTION_STATE.AUTHENTICATION_TIMEOUT },\n                { name: "authentication-timeout" /* AUTHENTICATION_TIMEOUT */, from: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION, to: constants_1.CONNECTION_STATE.AUTHENTICATION_TIMEOUT },\n                { name: "authenticate" /* AUTHENTICATE */, from: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION, to: constants_1.CONNECTION_STATE.AUTHENTICATING },\n                { name: "unsuccesful-login" /* UNSUCCESFUL_LOGIN */, from: constants_1.CONNECTION_STATE.AUTHENTICATING, to: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION },\n                { name: "succesful-login" /* SUCCESFUL_LOGIN */, from: constants_1.CONNECTION_STATE.AUTHENTICATING, to: constants_1.CONNECTION_STATE.OPEN },\n                { name: "too-many-auth-attempts" /* TOO_MANY_AUTH_ATTEMPTS */, from: constants_1.CONNECTION_STATE.AUTHENTICATING, to: constants_1.CONNECTION_STATE.TOO_MANY_AUTH_ATTEMPTS },\n                { name: "too-many-auth-attempts" /* TOO_MANY_AUTH_ATTEMPTS */, from: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION, to: constants_1.CONNECTION_STATE.TOO_MANY_AUTH_ATTEMPTS },\n                { name: "authentication-timeout" /* AUTHENTICATION_TIMEOUT */, from: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION, to: constants_1.CONNECTION_STATE.AUTHENTICATION_TIMEOUT },\n                { name: "reconnect" /* RECONNECT */, from: constants_1.CONNECTION_STATE.RECONNECTING, to: constants_1.CONNECTION_STATE.RECONNECTING },\n                { name: "closed" /* CLOSED */, from: constants_1.CONNECTION_STATE.CLOSING, to: constants_1.CONNECTION_STATE.CLOSED },\n                { name: "offline" /* OFFLINE */, from: constants_1.CONNECTION_STATE.PAUSING, to: constants_1.CONNECTION_STATE.OFFLINE },\n                { name: "error" /* ERROR */, to: constants_1.CONNECTION_STATE.RECONNECTING },\n                { name: "connection-lost" /* LOST */, to: constants_1.CONNECTION_STATE.RECONNECTING },\n                { name: "resume" /* RESUME */, to: constants_1.CONNECTION_STATE.RECONNECTING },\n                { name: "pause" /* PAUSE */, to: constants_1.CONNECTION_STATE.PAUSING },\n                { name: "close" /* CLOSE */, to: constants_1.CONNECTION_STATE.CLOSING },\n            ]\n        });\n        this.stateMachine.transition("initialised" /* INITIALISED */);\n        this.originalUrl = utils.parseUrl(url, this.options.path);\n        this.url = this.originalUrl;\n        if (!options.lazyConnect) {\n            this.createEndpoint();\n        }\n    }\n    Object.defineProperty(Connection.prototype, "isConnected", {\n        get: function () {\n            return this.stateMachine.state === constants_1.CONNECTION_STATE.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Connection.prototype.onLost = function (callback) {\n        this.internalEmitter.on(constants_1.EVENT.CONNECTION_LOST, callback);\n    };\n    Connection.prototype.removeOnLost = function (callback) {\n        this.internalEmitter.off(constants_1.EVENT.CONNECTION_LOST, callback);\n    };\n    Connection.prototype.onReestablished = function (callback) {\n        this.internalEmitter.on(constants_1.EVENT.CONNECTION_REESTABLISHED, callback);\n    };\n    Connection.prototype.removeOnReestablished = function (callback) {\n        this.internalEmitter.off(constants_1.EVENT.CONNECTION_REESTABLISHED, callback);\n    };\n    Connection.prototype.onExitLimbo = function (callback) {\n        this.internalEmitter.on(constants_1.EVENT.EXIT_LIMBO, callback);\n    };\n    Connection.prototype.registerHandler = function (topic, callback) {\n        this.handlers.set(topic, callback);\n    };\n    Connection.prototype.sendMessage = function (message) {\n        if (!this.isOpen()) {\n            this.services.logger.error(message, constants_1.EVENT.IS_CLOSED);\n            return;\n        }\n        if (this.endpoint) {\n            this.endpoint.sendParsedMessage(message);\n        }\n    };\n    Connection.prototype.authenticate = function (authParamsOrCallback, callback) {\n        if (authParamsOrCallback &&\n            typeof authParamsOrCallback !== \'object\' &&\n            typeof authParamsOrCallback !== \'function\') {\n            throw new Error(\'invalid argument authParamsOrCallback\');\n        }\n        if (callback && typeof callback !== \'function\') {\n            throw new Error(\'invalid argument callback\');\n        }\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.CHALLENGE_DENIED ||\n            this.stateMachine.state === constants_1.CONNECTION_STATE.TOO_MANY_AUTH_ATTEMPTS ||\n            this.stateMachine.state === constants_1.CONNECTION_STATE.AUTHENTICATION_TIMEOUT) {\n            this.services.logger.error({ topic: message_constants_1.TOPIC.CONNECTION }, constants_1.EVENT.IS_CLOSED);\n            return;\n        }\n        if (authParamsOrCallback) {\n            // @ts-ignore\n            this.authParams = typeof authParamsOrCallback === \'object\' ? authParamsOrCallback : {};\n        }\n        if (authParamsOrCallback && typeof authParamsOrCallback === \'function\') {\n            this.authCallback = authParamsOrCallback;\n        }\n        else if (callback) {\n            this.authCallback = callback;\n        }\n        else {\n            this.authCallback = function () { };\n        }\n        // if (this.stateMachine.state === CONNECTION_STATE.CLOSED && !this.endpoint) {\n        //   this.createEndpoint()\n        //   return\n        // }\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION && this.authParams) {\n            this.sendAuthParams();\n        }\n        if (!this.endpoint) {\n            this.createEndpoint();\n        }\n    };\n    /*\n    * Returns the current connection state.\n    */\n    Connection.prototype.getConnectionState = function () {\n        return this.stateMachine.state;\n    };\n    Connection.prototype.isOpen = function () {\n        var connState = this.getConnectionState();\n        return connState !== constants_1.CONNECTION_STATE.CLOSED\n            && connState !== constants_1.CONNECTION_STATE.ERROR\n            && connState !== constants_1.CONNECTION_STATE.CLOSING;\n    };\n    /**\n     * Closes the connection. Using this method\n     * will prevent the client from reconnecting.\n     */\n    Connection.prototype.close = function () {\n        this.services.timerRegistry.remove(this.heartbeatIntervalTimeout);\n        this.sendMessage({\n            topic: message_constants_1.TOPIC.CONNECTION,\n            action: message_constants_1.CONNECTION_ACTIONS.CLOSING\n        });\n        this.stateMachine.transition("close" /* CLOSE */);\n    };\n    Connection.prototype.pause = function () {\n        this.stateMachine.transition("pause" /* PAUSE */);\n        this.services.timerRegistry.remove(this.heartbeatIntervalTimeout);\n        if (this.endpoint) {\n            this.endpoint.close();\n        }\n    };\n    Connection.prototype.resume = function (callback) {\n        this.stateMachine.transition("resume" /* RESUME */);\n        this.resumeCallback = callback;\n        this.tryReconnect();\n    };\n    /**\n     * Creates the endpoint to connect to using the url deepstream\n     * was initialised with.\n     */\n    Connection.prototype.createEndpoint = function () {\n        this.endpoint = this.services.socketFactory(this.url, this.options.socketOptions, this.options.heartbeatInterval);\n        this.endpoint.onopened = this.onOpen.bind(this);\n        this.endpoint.onerror = this.onError.bind(this);\n        this.endpoint.onclosed = this.onClose.bind(this);\n        this.endpoint.onparsedmessages = this.onMessages.bind(this);\n    };\n    /********************************\n    ****** Endpoint Callbacks ******\n    /********************************/\n    /**\n    * Will be invoked once the connection is established. The client\n    * can\'t send messages yet, and needs to get a connection ACK or REDIRECT\n    * from the server before authenticating\n    */\n    Connection.prototype.onOpen = function () {\n        this.clearReconnect();\n        this.checkHeartBeat();\n        this.stateMachine.transition("connected" /* CONNECTED */);\n        this.sendMessage({\n            topic: message_constants_1.TOPIC.CONNECTION,\n            action: message_constants_1.CONNECTION_ACTIONS.CHALLENGE,\n            url: this.originalUrl,\n            protocolVersion: \'0.1a\'\n        });\n        this.stateMachine.transition("challenge" /* CHALLENGE */);\n    };\n    /**\n     * Callback for generic connection errors. Forwards\n     * the error to the client.\n     *\n     * The connection is considered broken once this method has been\n     * invoked.\n     */\n    Connection.prototype.onError = function (error) {\n        var _this = this;\n        /*\n         * If the implementation isn\'t listening on the error event this will throw\n         * an error. So let\'s defer it to allow the reconnection to kick in.\n         */\n        setTimeout(function () {\n            var msg;\n            if (error.code === \'ECONNRESET\' || error.code === \'ECONNREFUSED\') {\n                msg = "Can\'t connect! Deepstream server unreachable on " + _this.originalUrl;\n            }\n            else {\n                try {\n                    msg = JSON.stringify(error);\n                }\n                catch (e) {\n                    msg = error.toString();\n                }\n            }\n            _this.services.logger.error({ topic: message_constants_1.TOPIC.CONNECTION }, constants_1.EVENT.CONNECTION_ERROR, msg);\n        }, 1);\n        this.services.timerRegistry.remove(this.heartbeatIntervalTimeout);\n        this.stateMachine.transition("error" /* ERROR */);\n        this.tryReconnect();\n    };\n    /**\n     * Callback when the connection closes. This might have been a deliberate\n     * close triggered by the client or the result of the connection getting\n     * lost.\n     *\n     * In the latter case the client will try to reconnect using the configured\n     * strategy.\n     */\n    Connection.prototype.onClose = function () {\n        this.services.timerRegistry.remove(this.heartbeatIntervalTimeout);\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.REDIRECTING) {\n            this.createEndpoint();\n            return;\n        }\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.CHALLENGE_DENIED ||\n            this.stateMachine.state === constants_1.CONNECTION_STATE.TOO_MANY_AUTH_ATTEMPTS ||\n            this.stateMachine.state === constants_1.CONNECTION_STATE.AUTHENTICATION_TIMEOUT) {\n            return;\n        }\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.CLOSING) {\n            this.stateMachine.transition("closed" /* CLOSED */);\n            return;\n        }\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.PAUSING) {\n            this.stateMachine.transition("offline" /* OFFLINE */);\n            return;\n        }\n        this.stateMachine.transition("connection-lost" /* LOST */);\n        this.tryReconnect();\n    };\n    /**\n     * Callback for messages received on the connection.\n     */\n    Connection.prototype.onMessages = function (parseResults) {\n        var _this = this;\n        parseResults.forEach(function (parseResult) {\n            if (parseResult.parseError) {\n                _this.services.logger.error({ topic: message_constants_1.TOPIC.PARSER }, parseResult.action, parseResult.raw && parseResult.raw.toString());\n                return;\n            }\n            var message = parseResult;\n            var res = message_parser_1.parseData(message);\n            if (res !== true) {\n                _this.services.logger.error({ topic: message_constants_1.TOPIC.PARSER }, message_constants_1.PARSER_ACTIONS.INVALID_MESSAGE, res);\n            }\n            if (message === null) {\n                return;\n            }\n            if (message.topic === message_constants_1.TOPIC.CONNECTION) {\n                _this.handleConnectionResponse(message);\n                return;\n            }\n            if (message.topic === message_constants_1.TOPIC.AUTH) {\n                _this.handleAuthResponse(message);\n                return;\n            }\n            var handler = _this.handlers.get(message.topic);\n            if (!handler) {\n                // this should never happen\n                return;\n            }\n            handler(message);\n        });\n    };\n    /**\n    * Sends authentication params to the server. Please note, this\n    * doesn\'t use the queued message mechanism, but rather sends the message directly\n    */\n    Connection.prototype.sendAuthParams = function () {\n        this.stateMachine.transition("authenticate" /* AUTHENTICATE */);\n        this.sendMessage({\n            topic: message_constants_1.TOPIC.AUTH,\n            action: message_constants_1.AUTH_ACTIONS.REQUEST,\n            parsedData: this.authParams\n        });\n    };\n    /**\n    * Ensures that a heartbeat was not missed more than once, otherwise it considers the connection\n    * to have been lost and closes it for reconnection.\n    */\n    Connection.prototype.checkHeartBeat = function () {\n        var heartBeatTolerance = this.options.heartbeatInterval * 2;\n        if (!this.endpoint) {\n            return;\n        }\n        if (this.endpoint.getTimeSinceLastMessage() > heartBeatTolerance) {\n            this.services.timerRegistry.remove(this.heartbeatIntervalTimeout);\n            this.services.logger.error({ topic: message_constants_1.TOPIC.CONNECTION }, constants_1.EVENT.HEARTBEAT_TIMEOUT);\n            this.endpoint.close();\n            return;\n        }\n        this.heartbeatIntervalTimeout = this.services.timerRegistry.add({\n            duration: this.options.heartbeatInterval,\n            callback: this.checkHeartBeat,\n            context: this\n        });\n    };\n    /**\n    * If the connection drops or is closed in error this\n    * method schedules increasing reconnection intervals\n    *\n    * If the number of failed reconnection attempts exceeds\n    * options.maxReconnectAttempts the connection is closed\n    */\n    Connection.prototype.tryReconnect = function () {\n        if (this.reconnectTimeout !== null) {\n            return;\n        }\n        if (this.reconnectionAttempt < this.options.maxReconnectAttempts) {\n            this.stateMachine.transition("reconnect" /* RECONNECT */);\n            this.reconnectTimeout = this.services.timerRegistry.add({\n                callback: this.tryOpen,\n                context: this,\n                duration: Math.min(this.options.maxReconnectInterval, this.options.reconnectIntervalIncrement * this.reconnectionAttempt)\n            });\n            this.reconnectionAttempt++;\n            return;\n        }\n        this.emitter.emit(constants_1.EVENT[constants_1.EVENT.MAX_RECONNECTION_ATTEMPTS_REACHED], this.reconnectionAttempt);\n        this.clearReconnect();\n        this.close();\n    };\n    /**\n     * Attempts to open a errourosly closed connection\n     */\n    Connection.prototype.tryOpen = function () {\n        if (this.stateMachine.state !== constants_1.CONNECTION_STATE.REDIRECTING) {\n            this.url = this.originalUrl;\n        }\n        this.createEndpoint();\n        this.reconnectTimeout = null;\n    };\n    /**\n     * Stops all further reconnection attempts,\n     * either because the connection is open again\n     * or because the maximal number of reconnection\n     * attempts has been exceeded\n     */\n    Connection.prototype.clearReconnect = function () {\n        this.services.timerRegistry.remove(this.reconnectTimeout);\n        this.reconnectTimeout = null;\n        this.reconnectionAttempt = 0;\n    };\n    /**\n     * The connection response will indicate whether the deepstream connection\n     * can be used or if it should be forwarded to another instance. This\n     * allows us to introduce load-balancing if needed.\n     *\n     * If authentication parameters are already provided this will kick of\n     * authentication immediately. The actual \'open\' event won\'t be emitted\n     * by the client until the authentication is successful.\n     *\n     * If a challenge is recieved, the user will send the url to the server\n     * in response to get the appropriate redirect. If the URL is invalid the\n     * server will respond with a REJECTION resulting in the client connection\n     * being permanently closed.\n     *\n     * If a redirect is recieved, this connection is closed and updated with\n     * a connection to the url supplied in the message.\n     */\n    Connection.prototype.handleConnectionResponse = function (message) {\n        if (message.action === message_constants_1.CONNECTION_ACTIONS.ACCEPT) {\n            this.stateMachine.transition("accepted" /* CHALLENGE_ACCEPTED */);\n            return;\n        }\n        if (message.action === message_constants_1.CONNECTION_ACTIONS.REJECT) {\n            this.stateMachine.transition("challenge-denied" /* CHALLENGE_DENIED */);\n            if (this.endpoint) {\n                this.endpoint.close();\n            }\n            return;\n        }\n        if (message.action === message_constants_1.CONNECTION_ACTIONS.REDIRECT) {\n            this.url = message.url;\n            this.stateMachine.transition("redirected" /* CONNECTION_REDIRECTED */);\n            if (this.endpoint) {\n                this.endpoint.close();\n            }\n            return;\n        }\n        if (message.action === message_constants_1.CONNECTION_ACTIONS.AUTHENTICATION_TIMEOUT) {\n            this.stateMachine.transition("authentication-timeout" /* AUTHENTICATION_TIMEOUT */);\n            this.services.logger.error(message);\n        }\n    };\n    /**\n     * Callback for messages received for the AUTH topic. If\n     * the authentication was successful this method will\n     * open the connection and send all messages that the client\n     * tried to send so far.\n     */\n    Connection.prototype.handleAuthResponse = function (message) {\n        if (message.action === message_constants_1.AUTH_ACTIONS.TOO_MANY_AUTH_ATTEMPTS) {\n            this.stateMachine.transition("too-many-auth-attempts" /* TOO_MANY_AUTH_ATTEMPTS */);\n            this.services.logger.error(message);\n            return;\n        }\n        if (message.action === message_constants_1.AUTH_ACTIONS.AUTH_UNSUCCESSFUL) {\n            this.stateMachine.transition("unsuccesful-login" /* UNSUCCESFUL_LOGIN */);\n            this.onAuthUnSuccessful();\n            return;\n        }\n        if (message.action === message_constants_1.AUTH_ACTIONS.AUTH_SUCCESSFUL) {\n            this.stateMachine.transition("succesful-login" /* SUCCESFUL_LOGIN */);\n            this.onAuthSuccessful(message.parsedData);\n            return;\n        }\n    };\n    Connection.prototype.onAwaitingAuthentication = function () {\n        if (this.authParams) {\n            this.sendAuthParams();\n        }\n    };\n    Connection.prototype.onAuthSuccessful = function (clientData) {\n        this.updateClientData(clientData);\n        if (this.resumeCallback) {\n            this.resumeCallback();\n            this.resumeCallback = null;\n        }\n        if (this.authCallback === null) {\n            return;\n        }\n        this.authCallback(true, this.clientData);\n        this.authCallback = null;\n    };\n    Connection.prototype.onAuthUnSuccessful = function () {\n        var reason = { reason: constants_1.EVENT[constants_1.EVENT.INVALID_AUTHENTICATION_DETAILS] };\n        if (this.resumeCallback) {\n            this.resumeCallback(reason);\n            this.resumeCallback = null;\n        }\n        if (this.authCallback === null) {\n            this.emitter.emit(constants_1.EVENT.REAUTHENTICATION_FAILURE, reason);\n            return;\n        }\n        this.authCallback(false, reason);\n        this.authCallback = null;\n    };\n    Connection.prototype.updateClientData = function (data) {\n        var newClientData = data || null;\n        if (this.clientData === null &&\n            (newClientData === null || Object.keys(newClientData).length === 0)) {\n            return;\n        }\n        if (!utils.deepEquals(this.clientData, data)) {\n            this.emitter.emit(constants_1.EVENT.CLIENT_DATA_CHANGED, Object.assign({}, newClientData));\n            this.clientData = newClientData;\n        }\n    };\n    return Connection;\n}());\nexports.Connection = Connection;\n\n\n//# sourceURL=webpack://deepstream/./src/connection/connection.ts?')},"./src/connection/socket-factory.ts":function(module,exports,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(global, Buffer) {\nObject.defineProperty(exports, "__esModule", { value: true });\nvar message_parser_1 = __webpack_require__(/*! ../../binary-protocol/src/message-parser */ "./binary-protocol/src/message-parser.ts");\nvar message_builder_1 = __webpack_require__(/*! ../../binary-protocol/src/message-builder */ "./binary-protocol/src/message-builder.ts");\nvar message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nvar BrowserWebsocket = (global.WebSocket || global.MozWebSocket);\nexports.socketFactory = function (url, options, heartBeatInterval) {\n    var socket = BrowserWebsocket\n        ? new BrowserWebsocket(url, [], options)\n        : new (__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \'ws\'"); e.code = \'MODULE_NOT_FOUND\'; throw e; }())))(url, options);\n    if (BrowserWebsocket) {\n        socket.binaryType = \'arraybuffer\';\n    }\n    var pingMessage = message_builder_1.getMessage({ topic: message_constants_1.TOPIC.CONNECTION, action: message_constants_1.CONNECTION_ACTIONS.PING }, false);\n    var pingInterval = null;\n    var lastRecievedMessageTimestamp = -1;\n    // tslint:disable-next-line:no-empty\n    socket.onparsedmessage = function () { };\n    socket.onmessage = function (raw) {\n        lastRecievedMessageTimestamp = Date.now();\n        var parseResults = message_parser_1.parse(BrowserWebsocket ? new Buffer(new Uint8Array(raw.data)) : raw.data);\n        socket.onparsedmessages(parseResults);\n    };\n    socket.getTimeSinceLastMessage = function () {\n        return 0;\n        // return Date.now() - lastRecievedMessageTimestamp\n    };\n    socket.sendParsedMessage = function (message) {\n        if (message.topic === message_constants_1.TOPIC.CONNECTION && message.action === message_constants_1.CONNECTION_ACTIONS.CLOSING) {\n            socket.onparsedmessages([{ topic: message_constants_1.TOPIC.CONNECTION, action: message_constants_1.CONNECTION_ACTIONS.CLOSED }]);\n            socket.close();\n            return;\n        }\n        message.data = JSON.stringify(message.parsedData);\n        // if (message.action !== CONNECTION_ACTIONS.PONG && message.action !== CONNECTION_ACTIONS.PING) {\n        //     console.log(\'>>>\', TOPIC[message.topic], (ACTIONS as any)[message.topic][message.action], message.parsedData, message.data, message.name)\n        // }\n        socket.send(message_builder_1.getMessage(message, false));\n    };\n    socket.onclosed = null;\n    socket.onclose = function () {\n        clearInterval(pingInterval);\n        socket.onclosed();\n    };\n    socket.onopened = null;\n    socket.onopen = function () {\n        pingInterval = setInterval(function () {\n            if (Date.now() - lastRecievedMessageTimestamp > heartBeatInterval) {\n                try {\n                    socket.send(pingMessage);\n                }\n                catch (e) {\n                    clearTimeout(pingInterval);\n                }\n            }\n        }, heartBeatInterval);\n        socket.onopened();\n    };\n    return socket;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../node_modules/buffer/index.js */ "./node_modules/buffer/index.js").Buffer))\n\n//# sourceURL=webpack://deepstream/./src/connection/socket-factory.ts?')},"./src/constants.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar EVENT;\n(function (EVENT) {\n    EVENT[EVENT["UNSOLICITED_MESSAGE"] = 0] = "UNSOLICITED_MESSAGE";\n    EVENT[EVENT["IS_CLOSED"] = 1] = "IS_CLOSED";\n    EVENT[EVENT["MAX_RECONNECTION_ATTEMPTS_REACHED"] = 2] = "MAX_RECONNECTION_ATTEMPTS_REACHED";\n    EVENT[EVENT["CONNECTION_ERROR"] = 3] = "CONNECTION_ERROR";\n    EVENT[EVENT["ACK_TIMEOUT"] = 4] = "ACK_TIMEOUT";\n    EVENT[EVENT["UNKNOWN_CORRELATION_ID"] = 5] = "UNKNOWN_CORRELATION_ID";\n    EVENT[EVENT["HEARTBEAT_TIMEOUT"] = 6] = "HEARTBEAT_TIMEOUT";\n    EVENT[EVENT["LISTENER_EXISTS"] = 7] = "LISTENER_EXISTS";\n    EVENT[EVENT["NOT_LISTENING"] = 8] = "NOT_LISTENING";\n    EVENT[EVENT["RECORD_ALREADY_DESTROYED"] = 9] = "RECORD_ALREADY_DESTROYED";\n    EVENT[EVENT["RECORD_DELETE_TIMEOUT"] = 10] = "RECORD_DELETE_TIMEOUT";\n    EVENT["CLIENT_OFFLINE"] = "client offline";\n    EVENT["INVALID_AUTHENTICATION_DETAILS"] = "INVALID_AUTHENTICATION_DETAILS";\n    EVENT["CONNECTION_LOST"] = "connectionLost";\n    EVENT["CONNECTION_REESTABLISHED"] = "connectionReestablished";\n    EVENT["EXIT_LIMBO"] = "exitLimbo";\n    EVENT["CONNECTION_STATE_CHANGED"] = "connectionStateChanged";\n    EVENT["CLIENT_DATA_CHANGED"] = "clientDataChanged";\n    EVENT["REAUTHENTICATION_FAILURE"] = "reauthenticationFailure";\n    EVENT["AUTHENTICATION_TIMEOUT"] = "AUTHENTICATION_TIMEOUT";\n    EVENT["RECORD_ERROR"] = "error";\n    EVENT["RECORD_READY"] = "ready";\n    EVENT["RECORD_DELETED"] = "delete";\n    EVENT["RECORD_DISCARDED"] = "discard";\n    EVENT["RECORD_VERSION_EXISTS"] = "versionExists";\n    EVENT["RECORD_HAS_PROVIDER_CHANGED"] = "hasProviderChanged";\n    EVENT["RECORD_STATE_CHANGED"] = "onRecordStateChanged";\n    EVENT["ENTRY_ADDED_EVENT"] = "entry-added";\n    EVENT["ENTRY_REMOVED_EVENT"] = "entry-removed";\n    EVENT["ENTRY_MOVED_EVENT"] = "entry-moved";\n})(EVENT = exports.EVENT || (exports.EVENT = {}));\nvar CONNECTION_STATE;\n(function (CONNECTION_STATE) {\n    CONNECTION_STATE["CLOSING"] = "CLOSING";\n    CONNECTION_STATE["CLOSED"] = "CLOSED";\n    CONNECTION_STATE["INITIALISING"] = "INITIALISING";\n    CONNECTION_STATE["AWAITING_CONNECTION"] = "AWAITING_CONNECTION";\n    CONNECTION_STATE["CHALLENGING"] = "CHALLENGING";\n    CONNECTION_STATE["AWAITING_AUTHENTICATION"] = "AWAITING_AUTHENTICATION";\n    CONNECTION_STATE["AUTHENTICATING"] = "AUTHENTICATING";\n    CONNECTION_STATE["OPEN"] = "OPEN";\n    CONNECTION_STATE["ERROR"] = "ERROR";\n    CONNECTION_STATE["RECONNECTING"] = "RECONNECTING";\n    CONNECTION_STATE["REDIRECTING"] = "REDIRECTING";\n    CONNECTION_STATE["CHALLENGE_DENIED"] = "CHALLENGE_DENIED";\n    CONNECTION_STATE["TOO_MANY_AUTH_ATTEMPTS"] = "TOO_MANY_AUTH_ATTEMPTS";\n    CONNECTION_STATE["AUTHENTICATION_TIMEOUT"] = "AUTHENTICATION_TIMEOUT";\n    CONNECTION_STATE["PAUSING"] = "PAUSING";\n    CONNECTION_STATE["OFFLINE"] = "OFFLINE";\n})(CONNECTION_STATE = exports.CONNECTION_STATE || (exports.CONNECTION_STATE = {}));\n\n\n//# sourceURL=webpack://deepstream/./src/constants.ts?')},"./src/deepstream.ts":function(module,exports,__webpack_require__){"use strict";eval('\nvar client_1 = __webpack_require__(/*! ./client */ "./src/client.ts");\nvar constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");\nvar C = __webpack_require__(/*! ../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nvar client = function (url, options) {\n    return new client_1.Client(url, options);\n};\nmodule.exports = Object.assign(client, {\n    CONNECTION_STATE: constants_1.CONNECTION_STATE,\n    C: C,\n    EVENT: constants_1.EVENT,\n    deepstream: client\n});\n\n\n//# sourceURL=webpack://deepstream/./src/deepstream.ts?')},"./src/event/event-handler.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nvar constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nvar listener_1 = __webpack_require__(/*! ../util/listener */ \"./src/util/listener.ts\");\nvar Emitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\nvar bulk_subscription_service_1 = __webpack_require__(/*! ../util/bulk-subscription-service */ \"./src/util/bulk-subscription-service.ts\");\nvar EventHandler = /** @class */ (function () {\n    function EventHandler(services, options, listeners) {\n        this.services = services;\n        this.emitter = new Emitter();\n        this.limboQueue = [];\n        this.bulkSubscription = new bulk_subscription_service_1.BulkSubscriptionService(this.services, options.subscriptionInterval, message_constants_1.TOPIC.EVENT, message_constants_1.EVENT_ACTIONS.SUBSCRIBE_BULK, message_constants_1.EVENT_ACTIONS.SUBSCRIBE, message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE_BULK, message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE, this.onBulkSubscriptionSent.bind(this));\n        this.listeners = listeners || new listener_1.Listener(message_constants_1.TOPIC.EVENT, services);\n        this.services.connection.registerHandler(message_constants_1.TOPIC.EVENT, this.handle.bind(this));\n        this.services.connection.onExitLimbo(this.onExitLimbo.bind(this));\n        this.services.connection.onReestablished(this.onConnectionReestablished.bind(this));\n    }\n    /**\n    * Subscribe to an event. This will receive both locally emitted events\n    * as well as events emitted by other connected clients.\n    */\n    EventHandler.prototype.subscribe = function (name, callback) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        if (typeof callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        if (!this.emitter.hasListeners(name)) {\n            if (this.services.connection.isConnected) {\n                this.bulkSubscription.subscribe(name);\n            }\n        }\n        this.emitter.on(name, callback);\n    };\n    /**\n     * Removes a callback for a specified event. If all callbacks\n     * for an event have been removed, the server will be notified\n     * that the client is unsubscribed as a listener\n     */\n    EventHandler.prototype.unsubscribe = function (name, callback) {\n        if (!name || typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        if (callback !== undefined && typeof callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        if (!this.emitter.hasListeners(name)) {\n            this.services.logger.warn({\n                topic: message_constants_1.TOPIC.EVENT,\n                action: message_constants_1.EVENT_ACTIONS.NOT_SUBSCRIBED,\n                name: name\n            });\n            return;\n        }\n        this.emitter.off(name, callback);\n        if (!this.emitter.hasListeners(name)) {\n            this.bulkSubscription.unsubscribe(name);\n        }\n    };\n    /**\n     * Emits an event locally and sends a message to the server to\n     * broadcast the event to the other connected clients\n     */\n    EventHandler.prototype.emit = function (name, data) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        var message = {\n            topic: message_constants_1.TOPIC.EVENT,\n            action: message_constants_1.EVENT_ACTIONS.EMIT,\n            name: name,\n            parsedData: data\n        };\n        if (this.services.connection.isConnected) {\n            this.services.connection.sendMessage(message);\n        }\n        else if (this.services.connection.isInLimbo) {\n            this.limboQueue.push(message);\n        }\n        this.emitter.emit(name, data);\n    };\n    /**\n   * Allows to listen for event subscriptions made by this or other clients. This\n   * is useful to create \"active\" data providers, e.g. providers that only provide\n   * data for a particular event if a user is actually interested in it\n   */\n    EventHandler.prototype.listen = function (pattern, callback) {\n        this.listeners.listen(pattern, callback);\n    };\n    /**\n     * Removes a listener that was previously registered\n     */\n    EventHandler.prototype.unlisten = function (pattern) {\n        this.listeners.unlisten(pattern);\n    };\n    /**\n   * Handles incoming messages from the server\n   */\n    EventHandler.prototype.handle = function (message) {\n        if (message.isAck) {\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.EMIT) {\n            if (message.parsedData !== undefined) {\n                this.emitter.emit(message.name, message.parsedData);\n            }\n            else {\n                this.emitter.emit(message.name, undefined);\n            }\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.MESSAGE_DENIED) {\n            this.services.logger.error({ topic: message_constants_1.TOPIC.EVENT }, message_constants_1.EVENT_ACTIONS.MESSAGE_DENIED);\n            this.services.timeoutRegistry.remove(message);\n            if (message.originalAction === message_constants_1.EVENT_ACTIONS.SUBSCRIBE) {\n                this.emitter.off(message.name);\n            }\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.MULTIPLE_SUBSCRIPTIONS) {\n            this.services.timeoutRegistry.remove(Object.assign({}, message, {\n                action: message_constants_1.EVENT_ACTIONS.SUBSCRIBE\n            }));\n            this.services.logger.warn(message);\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.NOT_SUBSCRIBED) {\n            this.services.timeoutRegistry.remove(Object.assign({}, message, {\n                action: message_constants_1.EVENT_ACTIONS.SUBSCRIBE\n            }));\n            this.services.logger.warn(message);\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND ||\n            message.action === message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED) {\n            this.listeners.handle(message);\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.INVALID_LISTEN_REGEX) {\n            this.services.logger.error(message);\n            return;\n        }\n        this.services.logger.error(message, constants_1.EVENT.UNSOLICITED_MESSAGE);\n    };\n    /**\n     * Resubscribes to events when connection is lost\n     */\n    EventHandler.prototype.onConnectionReestablished = function () {\n        this.bulkSubscription.subscribeList(this.emitter.eventNames());\n        for (var i = 0; i < this.limboQueue.length; i++) {\n            this.services.connection.sendMessage(this.limboQueue[i]);\n        }\n        this.limboQueue = [];\n    };\n    EventHandler.prototype.onExitLimbo = function () {\n        this.limboQueue = [];\n    };\n    EventHandler.prototype.onBulkSubscriptionSent = function (message) {\n        if (!message.names) {\n            this.services.timeoutRegistry.add({ message: message });\n        }\n    };\n    return EventHandler;\n}());\nexports.EventHandler = EventHandler;\n\n\n//# sourceURL=webpack://deepstream/./src/event/event-handler.ts?")},"./src/presence/presence-handler.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nvar message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nvar Emitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\nvar bulk_subscription_service_1 = __webpack_require__(/*! ../util/bulk-subscription-service */ \"./src/util/bulk-subscription-service.ts\");\nvar ONLY_EVENT = 'OE';\nfunction validateQueryArguments(rest) {\n    var users = null;\n    var callback = null;\n    if (rest.length === 1) {\n        if (Array.isArray(rest[0])) {\n            users = rest[0];\n        }\n        else {\n            if (typeof rest[0] !== 'function') {\n                throw new Error('invalid argument: \"callback\"');\n            }\n            callback = rest[0];\n        }\n    }\n    else if (rest.length === 2) {\n        users = rest[0];\n        callback = rest[1];\n        if (!Array.isArray(users) || typeof callback !== 'function') {\n            throw new Error('invalid argument: \"users\" or \"callback\"');\n        }\n    }\n    return { users: users, callback: callback };\n}\nvar PresenceHandler = /** @class */ (function () {\n    function PresenceHandler(services, options) {\n        this.services = services;\n        this.globalSubscriptionEmitter = new Emitter();\n        this.subscriptionEmitter = new Emitter();\n        this.queryEmitter = new Emitter();\n        this.queryAllEmitter = new Emitter();\n        this.counter = 0;\n        this.limboQueue = [];\n        this.bulkSubscription = new bulk_subscription_service_1.BulkSubscriptionService(this.services, options.subscriptionInterval, message_constants_1.TOPIC.PRESENCE, message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_BULK, null, message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_BULK, null, this.onBulkSubscriptionSent.bind(this));\n        this.services.connection.registerHandler(message_constants_1.TOPIC.PRESENCE, this.handle.bind(this));\n        this.services.connection.onExitLimbo(this.onExitLimbo.bind(this));\n        this.services.connection.onLost(this.onExitLimbo.bind(this));\n        this.services.connection.onReestablished(this.onConnectionReestablished.bind(this));\n    }\n    PresenceHandler.prototype.subscribe = function (userOrCallback, callback) {\n        if (typeof userOrCallback === 'string' && userOrCallback.length > 0 && typeof callback === 'function') {\n            var user = userOrCallback;\n            if (!this.subscriptionEmitter.hasListeners(user)) {\n                this.bulkSubscription.subscribe(user);\n            }\n            this.subscriptionEmitter.on(user, callback);\n            return;\n        }\n        if (typeof userOrCallback === 'function' && typeof callback === 'undefined') {\n            if (!this.globalSubscriptionEmitter.hasListeners(ONLY_EVENT)) {\n                this.subscribeToAllChanges();\n            }\n            this.globalSubscriptionEmitter.on(ONLY_EVENT, userOrCallback);\n            return;\n        }\n        throw new Error('invalid arguments: \"user\" or \"callback\"');\n    };\n    PresenceHandler.prototype.unsubscribe = function (userOrCallback, callback) {\n        if (userOrCallback && typeof userOrCallback === 'string' && userOrCallback.length > 0) {\n            var user = userOrCallback;\n            if (callback) {\n                if (typeof callback !== 'function') {\n                    throw new Error('invalid argument: \"callback\"');\n                }\n                this.subscriptionEmitter.off(user, callback);\n            }\n            else {\n                this.subscriptionEmitter.off(user);\n            }\n            if (!this.subscriptionEmitter.hasListeners(user)) {\n                this.bulkSubscription.unsubscribe(user);\n                return;\n            }\n        }\n        if (userOrCallback && typeof userOrCallback === 'function') {\n            callback = userOrCallback;\n            this.globalSubscriptionEmitter.off(ONLY_EVENT, callback);\n            if (!this.globalSubscriptionEmitter.hasListeners(ONLY_EVENT)) {\n                this.unsubscribeToAllChanges();\n            }\n            return;\n        }\n        if (typeof userOrCallback === 'undefined' && typeof callback === 'undefined') {\n            this.subscriptionEmitter.off();\n            this.globalSubscriptionEmitter.off();\n            this.bulkSubscription.unsubscribeList(this.subscriptionEmitter.eventNames());\n            this.unsubscribeToAllChanges();\n            return;\n        }\n        throw new Error('invalid argument: \"user\" or \"callback\"');\n    };\n    PresenceHandler.prototype.getAll = function () {\n        var rest = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            rest[_i] = arguments[_i];\n        }\n        var _a = validateQueryArguments(rest), callback = _a.callback, users = _a.users;\n        var message;\n        var emitter;\n        var emitterAction;\n        if (users) {\n            var queryId = (this.counter++).toString();\n            message = {\n                topic: message_constants_1.TOPIC.PRESENCE,\n                action: message_constants_1.PRESENCE_ACTIONS.QUERY,\n                correlationId: queryId,\n                names: users\n            };\n            emitter = this.queryEmitter;\n            emitterAction = queryId;\n        }\n        else {\n            message = {\n                topic: message_constants_1.TOPIC.PRESENCE,\n                action: message_constants_1.PRESENCE_ACTIONS.QUERY_ALL\n            };\n            emitter = this.queryAllEmitter;\n            emitterAction = ONLY_EVENT;\n        }\n        if (this.services.connection.isConnected) {\n            this.sendQuery(message);\n        }\n        else if (this.services.connection.isInLimbo) {\n            this.limboQueue.push(message);\n        }\n        else {\n            this.services.timerRegistry.requestIdleCallback(function () {\n                emitter.emit(emitterAction, constants_1.EVENT.CLIENT_OFFLINE);\n            });\n        }\n        if (callback) {\n            emitter.once(emitterAction, callback);\n            return;\n        }\n        return new Promise(function (resolve, reject) {\n            emitter.once(emitterAction, function (error, results) { return error ? reject(error) : resolve(results); });\n        });\n    };\n    PresenceHandler.prototype.handle = function (message) {\n        if (message.isAck) {\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.QUERY_ALL_RESPONSE) {\n            this.queryAllEmitter.emit(ONLY_EVENT, null, message.names);\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.QUERY_RESPONSE) {\n            this.queryEmitter.emit(message.correlationId, null, message.parsedData);\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.PRESENCE_JOIN) {\n            this.subscriptionEmitter.emit(message.name, message.name, true);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.PRESENCE_JOIN_ALL) {\n            this.globalSubscriptionEmitter.emit(ONLY_EVENT, message.name, true);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.PRESENCE_LEAVE) {\n            this.subscriptionEmitter.emit(message.name, message.name, false);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.PRESENCE_LEAVE_ALL) {\n            this.globalSubscriptionEmitter.emit(ONLY_EVENT, message.name, false);\n            return;\n        }\n        if (message.isError) {\n            this.services.timeoutRegistry.remove(message);\n            if (message.originalAction === message_constants_1.PRESENCE_ACTIONS.QUERY) {\n                this.queryEmitter.emit(message.correlationId, message_constants_1.PRESENCE_ACTIONS[message.action]);\n            }\n            else if (message.originalAction === message_constants_1.PRESENCE_ACTIONS.QUERY_ALL) {\n                this.queryAllEmitter.emit(ONLY_EVENT, message_constants_1.PRESENCE_ACTIONS[message.action]);\n            }\n            else {\n                this.services.logger.error(message);\n            }\n            return;\n        }\n        this.services.logger.error(message, constants_1.EVENT.UNSOLICITED_MESSAGE);\n    };\n    PresenceHandler.prototype.sendQuery = function (message) {\n        this.services.connection.sendMessage(message);\n        this.services.timeoutRegistry.add({ message: message });\n    };\n    PresenceHandler.prototype.subscribeToAllChanges = function () {\n        if (!this.services.connection.isConnected) {\n            return;\n        }\n        var message = { topic: message_constants_1.TOPIC.PRESENCE, action: message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_ALL };\n        this.services.timeoutRegistry.add({ message: message });\n        this.services.connection.sendMessage(message);\n    };\n    PresenceHandler.prototype.unsubscribeToAllChanges = function () {\n        if (!this.services.connection.isConnected) {\n            return;\n        }\n        var message = { topic: message_constants_1.TOPIC.PRESENCE, action: message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_ALL };\n        this.services.timeoutRegistry.add({ message: message });\n        this.services.connection.sendMessage(message);\n    };\n    PresenceHandler.prototype.onConnectionReestablished = function () {\n        var keys = this.subscriptionEmitter.eventNames();\n        if (keys.length > 0) {\n            this.bulkSubscription.subscribeList(keys);\n        }\n        var hasGlobalSubscription = this.globalSubscriptionEmitter.hasListeners(ONLY_EVENT);\n        if (hasGlobalSubscription) {\n            this.subscribeToAllChanges();\n        }\n        for (var i = 0; i < this.limboQueue.length; i++) {\n            this.sendQuery(this.limboQueue[i]);\n        }\n        this.limboQueue = [];\n    };\n    PresenceHandler.prototype.onExitLimbo = function () {\n        var _this = this;\n        this.queryEmitter.eventNames().forEach(function (correlationId) {\n            _this.queryEmitter.emit(correlationId, constants_1.EVENT.CLIENT_OFFLINE);\n        });\n        this.queryAllEmitter.emit(ONLY_EVENT, constants_1.EVENT.CLIENT_OFFLINE);\n        this.limboQueue = [];\n        this.queryAllEmitter.off();\n        this.queryEmitter.off();\n    };\n    PresenceHandler.prototype.onBulkSubscriptionSent = function (message) {\n        this.services.timeoutRegistry.add({ message: message });\n    };\n    return PresenceHandler;\n}());\nexports.PresenceHandler = PresenceHandler;\n\n\n//# sourceURL=webpack://deepstream/./src/presence/presence-handler.ts?")},"./src/record/anonymous-record.ts":function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, "__esModule", { value: true });\nvar utils = __webpack_require__(/*! ../util/utils */ "./src/util/utils.ts");\nvar Emitter = __webpack_require__(/*! component-emitter2 */ "./node_modules/component-emitter2/index.js");\nvar AnonymousRecord = /** @class */ (function (_super) {\n    __extends(AnonymousRecord, _super);\n    function AnonymousRecord(getRecordCore) {\n        var _this = _super.call(this) || this;\n        _this.record = null;\n        _this.subscriptions = [];\n        _this.getRecordCore = getRecordCore;\n        return _this;\n    }\n    Object.defineProperty(AnonymousRecord.prototype, "name", {\n        get: function () {\n            if (!this.record) {\n                return \'\';\n            }\n            return this.record.name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnonymousRecord.prototype, "isReady", {\n        get: function () {\n            if (!this.record) {\n                return false;\n            }\n            return this.record.isReady;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnonymousRecord.prototype, "version", {\n        get: function () {\n            if (!this.record) {\n                return -1;\n            }\n            return this.record.version;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AnonymousRecord.prototype.whenReady = function (callback) {\n        if (this.record) {\n            if (callback) {\n                this.record.whenReady(this, callback);\n            }\n            else {\n                return this.record.whenReady(this);\n            }\n        }\n    };\n    AnonymousRecord.prototype.setName = function (recordName, callback) {\n        if (this.name === recordName) {\n            return;\n        }\n        this.discard();\n        this.record = this.getRecordCore(recordName);\n        this.record.addReference(this);\n        for (var i = 0; i < this.subscriptions.length; i++) {\n            this.record.subscribe(this.subscriptions[i]);\n        }\n        this.emit(\'nameChanged\', recordName);\n        if (callback) {\n            this.record.whenReady(this, callback);\n        }\n        else {\n            return this.record.whenReady(this);\n        }\n    };\n    AnonymousRecord.prototype.get = function (path) {\n        if (this.record) {\n            return this.record.get(path);\n        }\n    };\n    AnonymousRecord.prototype.set = function (path, data, callback) {\n        if (this.record) {\n            return this.record.set(utils.normalizeSetArguments(arguments));\n        }\n    };\n    AnonymousRecord.prototype.setWithAck = function (path, data, callback) {\n        if (this.record) {\n            return this.record.setWithAck(utils.normalizeSetArguments(arguments));\n        }\n    };\n    AnonymousRecord.prototype.erase = function (path) {\n        if (this.record) {\n            return this.record.set(utils.normalizeSetArguments(arguments));\n        }\n    };\n    AnonymousRecord.prototype.eraseWithAck = function (path, callback) {\n        if (this.record) {\n            return this.record.setWithAck(utils.normalizeSetArguments(arguments));\n        }\n    };\n    AnonymousRecord.prototype.subscribe = function (path, callback, triggerNow) {\n        var parameters = utils.normalizeArguments(arguments);\n        this.subscriptions.push(parameters);\n        if (this.record) {\n            this.record.subscribe(parameters);\n        }\n    };\n    AnonymousRecord.prototype.unsubscribe = function (path, callback) {\n        var parameters = utils.normalizeArguments(arguments);\n        this.subscriptions = this.subscriptions.filter(function (subscription) {\n            return (subscription.path !== parameters.path ||\n                subscription.callback !== parameters.callback);\n        });\n        if (this.record) {\n            this.record.unsubscribe(parameters);\n        }\n    };\n    AnonymousRecord.prototype.discard = function () {\n        if (this.record) {\n            for (var i = 0; i < this.subscriptions.length; i++) {\n                this.record.unsubscribe(this.subscriptions[i]);\n            }\n            return this.record.removeReference(this);\n        }\n    };\n    AnonymousRecord.prototype.delete = function (callback) {\n        if (this.record) {\n            return this.record.delete(callback);\n        }\n    };\n    AnonymousRecord.prototype.setMergeStrategy = function (mergeStrategy) {\n        if (this.record) {\n            this.record.setMergeStrategy(mergeStrategy);\n        }\n    };\n    return AnonymousRecord;\n}(Emitter));\nexports.AnonymousRecord = AnonymousRecord;\n\n\n//# sourceURL=webpack://deepstream/./src/record/anonymous-record.ts?')},"./src/record/dirty-service.ts":function(module,exports,__webpack_require__){"use strict";eval('\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar DirtyService = /** @class */ (function () {\n    function DirtyService(storage, dirtyStorageName) {\n        this.storage = storage;\n        this.dirtyStorageName = dirtyStorageName;\n        this.dirtyRecords = new Map();\n        this.loadedCallback = [];\n        this.flushTimeout = null;\n        this.loaded = false;\n        this.save = this.save.bind(this);\n        this.load();\n    }\n    DirtyService.prototype.isDirty = function (recordName) {\n        return this.dirtyRecords.has(recordName);\n    };\n    DirtyService.prototype.setDirty = function (recordName, isDirty) {\n        if (isDirty) {\n            this.dirtyRecords.set(recordName, true);\n        }\n        else {\n            this.dirtyRecords.delete(recordName);\n        }\n        if (!this.flushTimeout) {\n            this.flushTimeout = setTimeout(this.save, 1000);\n        }\n    };\n    DirtyService.prototype.save = function () {\n        this.storage.set(this.dirtyStorageName, 1, __spread(this.dirtyRecords), function () { });\n        if (this.flushTimeout) {\n            clearTimeout(this.flushTimeout);\n        }\n        this.flushTimeout = null;\n    };\n    DirtyService.prototype.whenLoaded = function (context, callback) {\n        if (this.loaded) {\n            callback.call(context);\n            return;\n        }\n        this.loadedCallback.push({ callback: callback, context: context });\n    };\n    DirtyService.prototype.getAll = function () {\n        return this.dirtyRecords;\n    };\n    DirtyService.prototype.load = function () {\n        var _this = this;\n        if (this.loaded) {\n            return;\n        }\n        this.storage.get(this.dirtyStorageName, function (recordName, version, data) {\n            _this.dirtyRecords = data ? new Map(data) : new Map();\n            _this.loaded = true;\n            _this.loadedCallback.forEach(function (_a) {\n                var callback = _a.callback, context = _a.context;\n                return callback.call(context);\n            });\n        });\n    };\n    return DirtyService;\n}());\nexports.DirtyService = DirtyService;\n\n\n//# sourceURL=webpack://deepstream/./src/record/dirty-service.ts?')},"./src/record/json-path.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = __webpack_require__(/*! ../util/utils */ \"./src/util/utils.ts\");\nvar SPLIT_REG_EXP = /[[\\]]/g;\n/**\n* Returns the value of the path or\n* undefined if the path can't be resolved\n*/\nfunction get(data, path, deepCopy) {\n    var tokens = tokenize(path);\n    var value = data;\n    for (var i = 0; i < tokens.length; i++) {\n        if (value === undefined) {\n            return undefined;\n        }\n        if (typeof value !== 'object') {\n            throw new Error('invalid data or path');\n        }\n        value = value[tokens[i]];\n    }\n    return deepCopy !== false ? utils.deepCopy(value) : value;\n}\nexports.get = get;\n/**\n * This class allows to set or get specific\n * values within a json data structure using\n * string-based paths\n */\nfunction setValue(root, path, value) {\n    if (path === null) {\n        return value;\n    }\n    var tokens = tokenize(path);\n    var rootCopy = utils.deepCopy(root);\n    var valueCopy = utils.deepCopy(value);\n    var node = rootCopy;\n    var i;\n    for (i = 0; i < tokens.length - 1; i++) {\n        var token = tokens[i];\n        if (node[token] !== undefined && node[token] !== null && typeof node[token] === 'object') {\n            node = node[token];\n        }\n        else if (typeof tokens[i + 1] === 'number') {\n            var array = new Array(tokens[i + 1]);\n            array.fill(null);\n            node = node[token] = array;\n        }\n        else {\n            node = node[token] = {};\n        }\n    }\n    if (value === undefined) {\n        delete node[tokens[i]];\n    }\n    else {\n        node[tokens[i]] = valueCopy;\n    }\n    return rootCopy;\n}\nexports.setValue = setValue;\n/**\n * Parses the path. Splits it into\n * keys for objects and indices for arrays.\n */\nfunction tokenize(path) {\n    if (path === null) {\n        return [];\n    }\n    var tokens = [];\n    var parts = path.split('.');\n    for (var i = 0; i < parts.length; i++) {\n        var part = parts[i].trim();\n        if (part.length === 0) {\n            continue;\n        }\n        var arrayIndexes = part.split(SPLIT_REG_EXP);\n        if (arrayIndexes.length === 0) {\n            // TODO\n            continue;\n        }\n        tokens.push(arrayIndexes[0]);\n        for (var j = 1; j < arrayIndexes.length; j++) {\n            if (arrayIndexes[j].length === 0) {\n                continue;\n            }\n            tokens.push(Number(arrayIndexes[j]));\n        }\n    }\n    return tokens;\n}\n\n\n//# sourceURL=webpack://deepstream/./src/record/json-path.ts?")},"./src/record/list.ts":function(module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = __webpack_require__(/*! ../util/utils */ \"./src/util/utils.ts\");\nvar constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nvar Emitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\nvar List = /** @class */ (function (_super) {\n    __extends(List, _super);\n    function List(record) {\n        var _this = _super.call(this) || this;\n        _this.record = record;\n        _this.originalApplyUpdate = _this.record.applyUpdate.bind(_this.record);\n        _this.record.applyUpdate = _this.applyUpdate.bind(_this);\n        _this.wrappedFunctions = new Map();\n        _this.hasAddListener = false;\n        _this.hasRemoveListener = false;\n        _this.hasMoveListener = false;\n        _this.subscriptions = [];\n        _this.record.addReference(_this);\n        return _this;\n    }\n    Object.defineProperty(List.prototype, \"name\", {\n        get: function () {\n            return this.record.name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(List.prototype, \"isReady\", {\n        get: function () {\n            return this.record.isReady;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(List.prototype, \"version\", {\n        get: function () {\n            return this.record.version;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    List.prototype.whenReady = function (callback) {\n        if (callback) {\n            this.record.whenReady(this, callback);\n        }\n        else {\n            return this.record.whenReady(this);\n        }\n    };\n    List.prototype.discard = function () {\n        this.destroy();\n        this.record.removeReference(this);\n    };\n    List.prototype.delete = function (callback) {\n        this.destroy();\n        return this.record.delete(callback);\n    };\n    /**\n     * Returns the array of list entries or an\n     * empty array if the list hasn't been populated yet.\n     */\n    List.prototype.getEntries = function () {\n        var entries = this.record.get();\n        if (!(entries instanceof Array)) {\n            return [];\n        }\n        return entries;\n    };\n    /**\n   * Returns true if the list is empty\n   */\n    List.prototype.isEmpty = function () {\n        return this.getEntries().length === 0;\n    };\n    List.prototype.setEntriesWithAck = function (entries, callback) {\n        var _this = this;\n        if (!callback) {\n            return new Promise(function (resolve, reject) {\n                _this.setEntries(entries, function (error) {\n                    if (error) {\n                        reject(error);\n                    }\n                    else {\n                        resolve();\n                    }\n                });\n            });\n        }\n        this.setEntries(entries, callback);\n    };\n    /**\n    * Updates the list with a new set of entries\n    */\n    List.prototype.setEntries = function (entries, callback) {\n        var errorMsg = 'entries must be an array of record names';\n        var i;\n        if (!(entries instanceof Array)) {\n            throw new Error(errorMsg);\n        }\n        for (i = 0; i < entries.length; i++) {\n            if (typeof entries[i] !== 'string') {\n                throw new Error(errorMsg);\n            }\n        }\n        if (this.record.isReady === false) {\n            // ...\n        }\n        else {\n            this.beforeChange();\n            this.record.set({ data: entries, callback: callback });\n            this.afterChange();\n        }\n    };\n    /**\n     * Removes an entry from the list\n     *\n     * @param {String} entry\n     * @param {Number} [index]\n     */\n    List.prototype.removeEntry = function (entry, index, callback) {\n        if (this.record.isReady === false) {\n            // ...\n            return;\n        }\n        // @ts-ignore\n        var currentEntries = this.record.get();\n        var hasIndex = this.hasIndex(index);\n        var entries = [];\n        var i;\n        for (i = 0; i < currentEntries.length; i++) {\n            if (currentEntries[i] !== entry || (hasIndex && index !== i)) {\n                entries.push(currentEntries[i]);\n            }\n        }\n        this.beforeChange();\n        this.record.set({ data: entries, callback: callback });\n        this.afterChange();\n    };\n    /**\n   * Adds an entry to the list\n   *\n   * @param {String} entry\n   * @param {Number} [index]\n   */\n    List.prototype.addEntry = function (entry, index, callback) {\n        if (typeof entry !== 'string') {\n            throw new Error('Entry must be a recordName');\n        }\n        if (this.record.isReady === false) {\n            // ..\n            return;\n        }\n        var hasIndex = this.hasIndex(index);\n        var entries = this.getEntries();\n        if (hasIndex) {\n            entries.splice(index, 0, entry);\n        }\n        else {\n            entries.push(entry);\n        }\n        this.beforeChange();\n        this.record.set({ data: entries, callback: callback });\n        this.afterChange();\n    };\n    /**\n   * Proxies the underlying Record's subscribe method. Makes sure\n   * that no path is provided\n   */\n    List.prototype.subscribe = function (callback) {\n        var parameters = utils.normalizeArguments(arguments);\n        if (parameters.path) {\n            throw new Error('path is not supported for List.subscribe');\n        }\n        // Make sure the callback is invoked with an empty array for new records\n        var listCallback = function (scope, cb) {\n            cb(scope.getEntries());\n        }.bind(this, this, parameters.callback);\n        /**\n        * Adding a property onto a function directly is terrible practice,\n        * and we will change this as soon as we have a more seperate approach\n        * of creating lists that doesn't have records default state.\n        *\n        * The reason we are holding a referencing to wrapped array is so that\n        * on unsubscribe it can provide a reference to the actual method the\n        * record is subscribed too.\n        **/\n        this.wrappedFunctions.set(parameters.callback, listCallback);\n        parameters.callback = listCallback;\n        this.subscriptions.push(parameters);\n        this.record.subscribe(parameters);\n    };\n    /**\n   * Proxies the underlying Record's unsubscribe method. Makes sure\n   * that no path is provided\n   */\n    List.prototype.unsubscribe = function (callback) {\n        var parameters = utils.normalizeArguments(arguments);\n        if (parameters.path) {\n            throw new Error('path is not supported for List.unsubscribe');\n        }\n        var listenCallback = this.wrappedFunctions.get(parameters.callback);\n        parameters.callback = listenCallback;\n        this.record.unsubscribe(parameters);\n        this.wrappedFunctions.delete(parameters.callback);\n    };\n    /**\n     * Proxies the underlying Record's _update method. Set's\n     * data to an empty array if no data is provided.\n     */\n    List.prototype.applyUpdate = function (message) {\n        if (!(message.parsedData instanceof Array)) {\n            message.parsedData = [];\n        }\n        this.beforeChange();\n        this.originalApplyUpdate(message);\n        this.afterChange();\n    };\n    /**\n     * Validates that the index provided is within the current set of entries.\n     */\n    List.prototype.hasIndex = function (index) {\n        var hasIndex = false;\n        var entries = this.getEntries();\n        if (index !== undefined) {\n            if (isNaN(index)) {\n                throw new Error('Index must be a number');\n            }\n            if (index !== entries.length && (index >= entries.length || index < 0)) {\n                throw new Error('Index must be within current entries');\n            }\n            hasIndex = true;\n        }\n        return hasIndex;\n    };\n    /**\n     * Establishes the current structure of the list, provided the client has attached any\n     * add / move / remove listener\n     *\n     * This will be called before any change to the list, regardsless if the change was triggered\n     * by an incoming message from the server or by the client\n     */\n    List.prototype.beforeChange = function () {\n        this.hasAddListener = this.listeners(constants_1.EVENT.ENTRY_ADDED_EVENT).length > 0;\n        this.hasRemoveListener = this.listeners(constants_1.EVENT.ENTRY_REMOVED_EVENT).length > 0;\n        this.hasMoveListener = this.listeners(constants_1.EVENT.ENTRY_MOVED_EVENT).length > 0;\n        if (this.hasAddListener || this.hasRemoveListener || this.hasMoveListener) {\n            this.beforeStructure = this.getStructure();\n        }\n        else {\n            this.beforeStructure = null;\n        }\n    };\n    /**\n     * Compares the structure of the list after a change to its previous structure and notifies\n     * any add / move / remove listener. Won't do anything if no listeners are attached.\n     */\n    List.prototype.afterChange = function () {\n        if (this.beforeStructure === null) {\n            return;\n        }\n        var after = this.getStructure();\n        var before = this.beforeStructure;\n        var entry;\n        var i;\n        if (this.hasRemoveListener) {\n            for (entry in before) {\n                for (i = 0; i < before[entry].length; i++) {\n                    if (after[entry] === undefined || after[entry][i] === undefined) {\n                        this.emit(constants_1.EVENT.ENTRY_REMOVED_EVENT, entry, before[entry][i]);\n                    }\n                }\n            }\n        }\n        if (this.hasAddListener || this.hasMoveListener) {\n            for (entry in after) {\n                if (before[entry] === undefined) {\n                    for (i = 0; i < after[entry].length; i++) {\n                        this.emit(constants_1.EVENT.ENTRY_ADDED_EVENT, entry, after[entry][i]);\n                    }\n                }\n                else {\n                    for (i = 0; i < after[entry].length; i++) {\n                        if (before[entry][i] !== after[entry][i]) {\n                            if (before[entry][i] === undefined) {\n                                this.emit(constants_1.EVENT.ENTRY_ADDED_EVENT, entry, after[entry][i]);\n                            }\n                            else {\n                                this.emit(constants_1.EVENT.ENTRY_MOVED_EVENT, entry, after[entry][i]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * Iterates through the list and creates a map with the entry as a key\n     * and an array of its position(s) within the list as a value, e.g.\n     *\n     * {\n     *   'recordA': [ 0, 3 ],\n     *   'recordB': [ 1 ],\n     *   'recordC': [ 2 ]\n     * }\n     */\n    List.prototype.getStructure = function () {\n        var structure = {};\n        var i;\n        var entries = this.getEntries();\n        for (i = 0; i < entries.length; i++) {\n            if (structure[entries[i]] === undefined) {\n                structure[entries[i]] = [i];\n            }\n            else {\n                structure[entries[i]].push(i);\n            }\n        }\n        return structure;\n    };\n    List.prototype.destroy = function () {\n        for (var i = 0; i < this.subscriptions.length; i++) {\n            this.record.unsubscribe(this.subscriptions[i]);\n        }\n        this.wrappedFunctions.clear();\n    };\n    return List;\n}(Emitter));\nexports.List = List;\n\n\n//# sourceURL=webpack://deepstream/./src/record/list.ts?")},"./src/record/merge-strategy-service.ts":function(module,exports,__webpack_require__){"use strict";eval('\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\nvar message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nvar MergeStrategyService = /** @class */ (function () {\n    function MergeStrategyService(services, defaultStrategy) {\n        this.services = services;\n        this.defaultStrategy = defaultStrategy;\n        this.strategiesByRecord = new Map();\n        this.strategiesByPattern = new Map();\n    }\n    MergeStrategyService.prototype.setMergeStrategyByName = function (recordName, strategy) {\n        this.strategiesByRecord.set(recordName, strategy);\n    };\n    MergeStrategyService.prototype.setMergeStrategyByPattern = function (pattern, strategy) {\n        this.strategiesByPattern.set(pattern, strategy);\n    };\n    MergeStrategyService.prototype.merge = function (recordName, localVersion, localData, remoteVersion, remoteData, callback, context) {\n        var e_1, _a;\n        var exactMergeStrategy = this.strategiesByRecord.get(recordName);\n        if (exactMergeStrategy) {\n            exactMergeStrategy(localData, localVersion, remoteData, remoteVersion, function (error, data) {\n                callback.call(context, error, recordName, data, remoteVersion, remoteData, localVersion, localData);\n            });\n            return;\n        }\n        try {\n            for (var _b = __values(this.strategiesByPattern), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _d = __read(_c.value, 2), pattern = _d[0], patternMergeStrategy = _d[1];\n                if (pattern.test(recordName)) {\n                    patternMergeStrategy(localData, localVersion, remoteData, remoteVersion, function (error, data) {\n                        callback.call(context, error, recordName, data, remoteVersion, remoteData, localVersion, localData);\n                    });\n                    return;\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        if (this.defaultStrategy) {\n            this.defaultStrategy(localData, localVersion, remoteData, remoteVersion, function (error, data) {\n                callback.call(context, error, recordName, data, remoteVersion, remoteData, localVersion, localData);\n            });\n            return;\n        }\n        this.services.logger.error({ topic: message_constants_1.TOPIC.RECORD }, constants_1.EVENT.RECORD_VERSION_EXISTS, { remoteVersion: remoteVersion, recordName: recordName });\n    };\n    return MergeStrategyService;\n}());\nexports.MergeStrategyService = MergeStrategyService;\n\n\n//# sourceURL=webpack://deepstream/./src/record/merge-strategy-service.ts?')},"./src/record/merge-strategy.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n *  Choose the server's state over the client's\n**/\nexports.REMOTE_WINS = function (localValue, localVersion, remoteValue, remoteVersion, callback) {\n    callback(null, remoteValue);\n};\n/**\n *  Choose the local state over the server's\n**/\nexports.LOCAL_WINS = function (localValue, localVersion, remoteValue, remoteVersion, callback) {\n    callback(null, localValue);\n};\n\n\n//# sourceURL=webpack://deepstream/./src/record/merge-strategy.ts?")},"./src/record/record-core.ts":function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\nvar message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nvar json_path_1 = __webpack_require__(/*! ./json-path */ "./src/record/json-path.ts");\nvar Emitter = __webpack_require__(/*! component-emitter2 */ "./node_modules/component-emitter2/index.js");\nvar utils = __webpack_require__(/*! ../util/utils */ "./src/util/utils.ts");\nvar state_machine_1 = __webpack_require__(/*! ../util/state-machine */ "./src/util/state-machine.ts");\nvar RecordCore = /** @class */ (function (_super) {\n    __extends(RecordCore, _super);\n    function RecordCore(name, services, options, recordServices, whenComplete) {\n        var _this = _super.call(this) || this;\n        _this.name = name;\n        _this.services = services;\n        _this.options = options;\n        _this.recordServices = recordServices;\n        _this.whenComplete = whenComplete;\n        _this.references = new Set();\n        _this.readyCallbacks = [];\n        _this.emitter = new Emitter();\n        _this.data = Object.create(null);\n        _this.hasProvider = false;\n        _this.pendingWrites = [];\n        _this.isReady = false;\n        _this.offlineLoadingAborted = false;\n        _this.version = null;\n        _this.responseTimeout = null;\n        _this.discardTimeout = null;\n        _this.deletedTimeout = null;\n        _this.readyTimer = -1;\n        _this.deleteResponse = null;\n        if (typeof name !== \'string\' || name.length === 0) {\n            throw new Error(\'invalid argument name\');\n        }\n        _this.onConnectionLost = _this.onConnectionLost.bind(_this);\n        _this.onConnectionReestablished = _this.onConnectionReestablished.bind(_this);\n        _this.stateMachine = new state_machine_1.StateMachine(_this.services.logger, {\n            init: "INITIAL" /* INITIAL */,\n            context: _this,\n            onStateChanged: _this.onStateChanged,\n            transitions: recordStateTransitions\n        });\n        _this.recordServices.dirtyService.whenLoaded(_this, _this.onDirtyServiceLoaded);\n        return _this;\n    }\n    Object.defineProperty(RecordCore.prototype, "recordState", {\n        get: function () {\n            return this.stateMachine.state;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    RecordCore.prototype.addReference = function (ref) {\n        if (this.references.size === 0 && this.isReady) {\n            this.services.timeoutRegistry.clear(this.discardTimeout);\n            this.services.timerRegistry.remove(this.readyTimer);\n            this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.SUBSCRIBE);\n        }\n        this.references.add(ref);\n    };\n    /**\n    * Removes all change listeners and notifies the server that the client is\n    * no longer interested in updates for this record\n    */\n    RecordCore.prototype.removeReference = function (ref) {\n        var _this = this;\n        if (this.checkDestroyed(\'discard\')) {\n            return;\n        }\n        this.whenReadyInternal(null, function () {\n            _this.references.delete(ref);\n            if (_this.references.size === 0) {\n                _this.readyTimer = _this.services.timerRegistry.add({\n                    duration: _this.options.recordReadTimeout,\n                    callback: _this.stateMachine.transition,\n                    context: _this.stateMachine,\n                    data: message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE_ACK\n                });\n            }\n        });\n        this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE);\n    };\n    RecordCore.prototype.onDirtyServiceLoaded = function () {\n        var _this = this;\n        if (this.services.connection.isConnected) {\n            this.services.storage.get(this.name, function (recordName, version, data) {\n                if (version === -1 && !_this.recordServices.dirtyService.isDirty(_this.name)) {\n                    /**\n                     * Record has never been created before\n                     */\n                    _this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD);\n                }\n                else {\n                    _this.version = version;\n                    _this.data = data;\n                    _this.stateMachine.transition("RESUBSCRIBE" /* RESUBSCRIBE */);\n                }\n            });\n        }\n        else {\n            this.stateMachine.transition("LOAD" /* LOAD */);\n        }\n        this.services.connection.onReestablished(this.onConnectionReestablished);\n        this.services.connection.onLost(this.onConnectionLost);\n    };\n    RecordCore.prototype.onStateChanged = function (newState, oldState) {\n        this.emitter.emit(constants_1.EVENT.RECORD_STATE_CHANGED, newState);\n    };\n    RecordCore.prototype.whenReady = function (context, callback) {\n        var _this = this;\n        if (callback) {\n            this.whenReadyInternal(context, function (realContext) {\n                callback(realContext);\n            });\n            return;\n        }\n        return new Promise(function (resolve) { return _this.whenReadyInternal(context, function () { return resolve(context); }); });\n    };\n    /**\n   */\n    RecordCore.prototype.whenReadyInternal = function (context, callback) {\n        if (this.isReady === true) {\n            callback(context);\n            return;\n        }\n        if (callback) {\n            this.readyCallbacks.push({ callback: callback, context: context });\n        }\n    };\n    /**\n   * Sets the value of either the entire dataset\n   * or of a specific path within the record\n   * and submits the changes to the server\n   *\n   * If the new data is equal to the current data, nothing will happen\n   *\n   * @param {[String|Object]} pathOrData Either a JSON path when called with\n   *                                     two arguments or the data itself\n   * @param {Object} data     The data that should be stored in the record\n   */\n    RecordCore.prototype.set = function (_a) {\n        var _this = this;\n        var path = _a.path, data = _a.data, callback = _a.callback;\n        if (!path && (data === null || typeof data !== \'object\')) {\n            throw new Error(\'invalid arguments, scalar values cannot be set without path\');\n        }\n        if (this.checkDestroyed(\'set\')) {\n            return;\n        }\n        if (this.isReady === false) {\n            this.pendingWrites.push({ path: path, data: data, callback: callback });\n            return;\n        }\n        var oldValue = this.data;\n        var newValue = json_path_1.setValue(oldValue, path || null, data);\n        if (oldValue === newValue) {\n            if (callback) {\n                this.services.timerRegistry.requestIdleCallback(function () { return callback(null, _this.name); });\n            }\n            return;\n        }\n        this.applyChange(newValue);\n        if (this.services.connection.isConnected) {\n            this.sendUpdate(path, data, callback);\n        }\n        else {\n            if (callback) {\n                callback(constants_1.EVENT.CLIENT_OFFLINE, this.name);\n            }\n            this.saveUpdate();\n        }\n    };\n    /**\n     * Wrapper function around the record.set that returns a promise\n     * if no callback is supplied.\n     * @returns {Promise} if a callback is omitted a Promise is returned with the result of the write\n     */\n    RecordCore.prototype.setWithAck = function (args) {\n        var _this = this;\n        if (args.callback) {\n            this.set(args);\n            return;\n        }\n        return new Promise(function (resolve, reject) {\n            args.callback = function (error) { return error === null ? resolve() : reject(error); };\n            _this.set(args);\n        });\n    };\n    /**\n   * Returns a copy of either the entire dataset of the record\n   * or - if called with a path - the value of that path within\n   * the record\'s dataset.\n   *\n   * Returning a copy rather than the actual value helps to prevent\n   * the record getting out of sync due to unintentional changes to\n   * its data\n   */\n    RecordCore.prototype.get = function (path) {\n        return json_path_1.get(this.data, path || null, this.options.recordDeepCopy);\n    };\n    /**\n   * Subscribes to changes to the records dataset.\n   *\n   * Callback is the only mandatory argument.\n   *\n   * When called with a path, it will only subscribe to updates\n   * to that path, rather than the entire record\n   *\n   * If called with true for triggerNow, the callback will\n   * be called immediatly with the current value\n   */\n    RecordCore.prototype.subscribe = function (args) {\n        var _this = this;\n        if (args.path !== undefined && (typeof args.path !== \'string\' || args.path.length === 0)) {\n            throw new Error(\'invalid argument path\');\n        }\n        if (typeof args.callback !== \'function\') {\n            throw new Error(\'invalid argument callback\');\n        }\n        if (this.checkDestroyed(\'subscribe\')) {\n            return;\n        }\n        if (args.triggerNow) {\n            this.whenReadyInternal(null, function () {\n                _this.emitter.on(args.path || \'\', args.callback);\n                args.callback(_this.get(args.path));\n            });\n        }\n        else {\n            this.emitter.on(args.path || \'\', args.callback);\n        }\n    };\n    /**\n     * Removes a subscription that was previously made using record.subscribe()\n     *\n     * Can be called with a path to remove the callback for this specific\n     * path or only with a callback which removes it from the generic subscriptions\n     *\n     * Please Note: unsubscribe is a purely client side operation. If the app is no longer\n     * interested in receiving updates for this record from the server it needs to call\n     * discard instead\n     *\n     * @param   {String}           path  A JSON path\n     * @param   {Function}         callback     The callback method. Please note, if a bound\n     *                                          method was passed to subscribe, the same method\n     *                                          must be passed to unsubscribe as well.\n     */\n    RecordCore.prototype.unsubscribe = function (args) {\n        if (args.path !== undefined && (typeof args.path !== \'string\' || args.path.length === 0)) {\n            throw new Error(\'invalid argument path\');\n        }\n        if (args.callback !== undefined && typeof args.callback !== \'function\') {\n            throw new Error(\'invalid argument callback\');\n        }\n        if (this.checkDestroyed(\'unsubscribe\')) {\n            return;\n        }\n        this.emitter.off(args.path || \'\', args.callback);\n    };\n    /**\n     * Deletes the record on the server.\n     */\n    RecordCore.prototype.delete = function (callback) {\n        var _this = this;\n        if (!this.services.connection.isConnected) {\n            // this.services.logger.warn({ topic: TOPIC.RECORD }, RA.DELETE, \'Deleting while offline is not supported\')\n            if (callback) {\n                this.services.timerRegistry.requestIdleCallback(function () {\n                    callback(\'Deleting while offline is not supported\');\n                });\n                return;\n            }\n            return Promise.reject(\'Deleting while offline is not supported\');\n        }\n        if (this.checkDestroyed(\'delete\')) {\n            return;\n        }\n        this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.DELETE);\n        if (callback && typeof callback === \'function\') {\n            this.deleteResponse = { callback: callback };\n            this.sendDelete();\n        }\n        else {\n            return new Promise(function (resolve, reject) {\n                _this.deleteResponse = { resolve: resolve, reject: reject };\n                _this.sendDelete();\n            });\n        }\n    };\n    /**\n     * Set a merge strategy to resolve any merge conflicts that may occur due\n     * to offline work or write conflicts. The function will be called with the\n     * local record, the remote version/data and a callback to call once the merge has\n     * completed or if an error occurs ( which leaves it in an inconsistent state until\n     * the next update merge attempt ).\n     */\n    RecordCore.prototype.setMergeStrategy = function (mergeStrategy) {\n        this.recordServices.mergeStrategy.setMergeStrategyByName(this.name, mergeStrategy);\n    };\n    RecordCore.prototype.saveRecordToOffline = function () {\n        this.services.storage.set(this.name, this.version, this.data, function () { });\n    };\n    /**\n     * Transition States\n     */\n    RecordCore.prototype.onSubscribing = function () {\n        this.recordServices.readRegistry.register(this.name, this, this.handleReadResponse);\n        this.responseTimeout = this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RECORD,\n                action: message_constants_1.RECORD_ACTIONS.READ_RESPONSE,\n                name: this.name\n            }\n        });\n        this.recordServices.bulkSubscriptionService[message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD_BULK].subscribe(this.name);\n    };\n    RecordCore.prototype.onResubscribing = function () {\n        this.services.timerRegistry.remove(this.readyTimer);\n        this.recordServices.headRegistry.register(this.name, this, this.handleHeadResponse);\n        this.responseTimeout = this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RECORD,\n                action: message_constants_1.RECORD_ACTIONS.HEAD,\n                name: this.name\n            }\n        });\n        this.recordServices.bulkSubscriptionService[message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD_BULK].subscribe(this.name);\n    };\n    RecordCore.prototype.onOfflineLoading = function () {\n        var _this = this;\n        this.services.storage.get(this.name, function (recordName, version, data) {\n            if (version === -1) {\n                if (_this.offlineLoadingAborted) {\n                    // This occurred since we got a connection to the server\n                    // meaning we no longer care about current state currently\n                    _this.offlineLoadingAborted = false;\n                    return;\n                }\n                _this.data = {};\n                _this.version = 1;\n                // We do this sync in order to avoid the possibility of a race condition\n                // where connection is established while we are saving. We could introduce\n                // another transition but its probably overkill since we only set this\n                // in order to allow the possibility of this record being retrieved in the\n                // future to know its been created\n                _this.services.storage.set(_this.name, _this.version, _this.data, function (error) { });\n                _this.stateMachine.transition("LOADED" /* LOADED */);\n            }\n            else {\n                _this.data = data;\n                _this.version = version;\n                _this.stateMachine.transition("LOADED" /* LOADED */);\n            }\n        });\n    };\n    RecordCore.prototype.abortOfflineLoading = function () {\n        this.offlineLoadingAborted = true;\n        this.onResubscribing();\n    };\n    RecordCore.prototype.onReady = function () {\n        this.services.timeoutRegistry.clear(this.responseTimeout);\n        this.applyPendingWrites();\n        this.isReady = true;\n        this.readyCallbacks.forEach(function (_a) {\n            var context = _a.context, callback = _a.callback;\n            callback.call(context, context);\n        });\n    };\n    RecordCore.prototype.applyPendingWrites = function () {\n        var _this = this;\n        var writeCallbacks = [];\n        var oldData = this.data;\n        var newData = oldData;\n        for (var i = 0; i < this.pendingWrites.length; i++) {\n            var _a = this.pendingWrites[i], callback = _a.callback, path = _a.path, data = _a.data;\n            if (callback) {\n                writeCallbacks.push(callback);\n            }\n            newData = json_path_1.setValue(newData, path || null, data);\n        }\n        this.pendingWrites = [];\n        this.applyChange(newData);\n        var runFns = function (err) {\n            for (var i = 0; i < writeCallbacks.length; i++) {\n                writeCallbacks[i](err, _this.name);\n            }\n        };\n        if (utils.deepEquals(oldData, newData)) {\n            runFns(null);\n            return;\n        }\n        if (this.services.connection.isConnected) {\n            this.sendUpdate(null, newData, runFns);\n        }\n        else {\n            runFns(constants_1.EVENT.CLIENT_OFFLINE);\n            this.saveUpdate();\n        }\n    };\n    RecordCore.prototype.onUnsubscribed = function () {\n        if (this.services.connection.isConnected) {\n            var message = {\n                topic: message_constants_1.TOPIC.RECORD,\n                action: message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE,\n                name: this.name\n            };\n            this.discardTimeout = this.services.timeoutRegistry.add({ message: message });\n            this.services.connection.sendMessage(message);\n        }\n        this.emit(constants_1.EVENT.RECORD_DISCARDED);\n        this.destroy();\n    };\n    RecordCore.prototype.onDeleted = function () {\n        this.emit(constants_1.EVENT.RECORD_DELETED);\n        this.destroy();\n    };\n    RecordCore.prototype.handle = function (message) {\n        if (message.action === message_constants_1.RECORD_ACTIONS.PATCH || message.action === message_constants_1.RECORD_ACTIONS.UPDATE || message.action === message_constants_1.RECORD_ACTIONS.ERASE) {\n            if (this.stateMachine.state === "MERGING" /* MERGING */) {\n                // The scenario this covers is when a read is requested because the head doesn\'t match\n                // but an updated comes in because we subscribed. In that scenario we just ignore the update\n                // and wait for the read response. Hopefully the messages don\'t cross on the wire in which case\n                // it might result in another merge conflict.\n                return;\n            }\n            this.applyUpdate(message);\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS) {\n            this.services.timeoutRegistry.clear(this.deletedTimeout);\n            this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS);\n            if (this.deleteResponse.callback) {\n                this.deleteResponse.callback(null);\n            }\n            else if (this.deleteResponse.resolve) {\n                this.deleteResponse.resolve();\n            }\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.DELETED) {\n            this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.DELETED);\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.VERSION_EXISTS) {\n            // what kind of message is version exists?\n            // this.recoverRecord(message)\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED ||\n            message.action === message_constants_1.RECORD_ACTIONS.MESSAGE_PERMISSION_ERROR) {\n            if (message.originalAction === message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD ||\n                message.originalAction === message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD ||\n                message.originalAction === message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD) {\n                var subscribeMsg = __assign({}, message, { originalAction: message_constants_1.RECORD_ACTIONS.SUBSCRIBE });\n                var actionMsg = __assign({}, message, { originalAction: message.originalAction === message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD ? message_constants_1.RECORD_ACTIONS.READ_RESPONSE : message_constants_1.RECORD_ACTIONS.HEAD_RESPONSE });\n                this.services.timeoutRegistry.remove(subscribeMsg); // TODO: This doesn\'t contain correlationIds\n                this.services.timeoutRegistry.remove(actionMsg);\n            }\n            this.emit(constants_1.EVENT.RECORD_ERROR, message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED], message_constants_1.RECORD_ACTIONS[message.originalAction]);\n            if (message.originalAction === message_constants_1.RECORD_ACTIONS.DELETE) {\n                if (this.deleteResponse.callback) {\n                    this.deleteResponse.callback(message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED]);\n                }\n                else if (this.deleteResponse.reject) {\n                    this.deleteResponse.reject(message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED]);\n                }\n            }\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_PROVIDER ||\n            message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_NO_PROVIDER) {\n            this.hasProvider = message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_PROVIDER;\n            this.emit(constants_1.EVENT.RECORD_HAS_PROVIDER_CHANGED, this.hasProvider);\n            return;\n        }\n    };\n    RecordCore.prototype.handleReadResponse = function (message) {\n        if (this.stateMachine.state === "MERGING" /* MERGING */) {\n            this.recoverRecord(message.version, message.parsedData, message);\n            this.recordServices.dirtyService.setDirty(this.name, false);\n            return;\n        }\n        this.version = message.version;\n        this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.READ_RESPONSE);\n        this.applyChange(json_path_1.setValue(this.data, null, message.parsedData));\n    };\n    RecordCore.prototype.handleHeadResponse = function (message) {\n        var remoteVersion = message.version;\n        if (this.recordServices.dirtyService.isDirty(this.name)) {\n            if (remoteVersion === -1 && this.version === 1) {\n                /**\n                 * Record created while offline\n                 */\n                this.stateMachine.transition("SUBSCRIBED" /* SUBSCRIBED */);\n                this.sendCreateUpdate(this.data);\n            }\n            else if (this.version === remoteVersion + 1) {\n                /**\n                 * record updated by client while offline\n                */\n                this.stateMachine.transition("RESUBSCRIBED" /* RESUBSCRIBED */);\n                this.sendUpdate(null, this.data);\n            }\n            else {\n                /**\n                 * record updated by server when offline, get latest data\n                 */\n                this.stateMachine.transition("INVALID_VERSION" /* INVALID_VERSION */);\n                this.sendRead();\n                this.recordServices.readRegistry.register(this.name, this, this.handleReadResponse);\n            }\n        }\n        else {\n            if (this.version === remoteVersion) {\n                this.stateMachine.transition("RESUBSCRIBED" /* RESUBSCRIBED */);\n            }\n            else {\n                if (remoteVersion < this.version) {\n                    /**\n                     *  deleted and created again remotely, up to merge conflict I guess\n                     */\n                }\n                this.stateMachine.transition("INVALID_VERSION" /* INVALID_VERSION */);\n                this.sendRead();\n                this.recordServices.readRegistry.register(this.name, this, this.handleReadResponse);\n            }\n        }\n    };\n    RecordCore.prototype.sendRead = function () {\n        this.services.connection.sendMessage({\n            topic: message_constants_1.TOPIC.RECORD,\n            action: message_constants_1.RECORD_ACTIONS.READ,\n            name: this.name\n        });\n    };\n    RecordCore.prototype.saveUpdate = function () {\n        if (!this.recordServices.dirtyService.isDirty(this.name)) {\n            this.version++;\n            this.recordServices.dirtyService.setDirty(this.name, true);\n        }\n        this.saveRecordToOffline();\n    };\n    RecordCore.prototype.sendUpdate = function (path, data, callback) {\n        if (path === void 0) { path = null; }\n        if (this.recordServices.dirtyService.isDirty(this.name)) {\n            this.recordServices.dirtyService.setDirty(this.name, false);\n        }\n        else {\n            this.version++;\n        }\n        var message = {\n            topic: message_constants_1.TOPIC.RECORD,\n            version: this.version,\n            name: this.name\n        };\n        if (path) {\n            if (data === undefined) {\n                Object.assign(message, { action: message_constants_1.RECORD_ACTIONS.ERASE, path: path });\n            }\n            else {\n                Object.assign(message, { action: message_constants_1.RECORD_ACTIONS.PATCH, path: path, parsedData: data });\n            }\n        }\n        else {\n            Object.assign(message, { action: message_constants_1.RECORD_ACTIONS.UPDATE, parsedData: data });\n        }\n        if (callback) {\n            this.recordServices.writeAckService.send(message, callback);\n        }\n        else {\n            this.services.connection.sendMessage(message);\n        }\n    };\n    RecordCore.prototype.sendCreateUpdate = function (data) {\n        this.services.connection.sendMessage({\n            name: this.name,\n            topic: message_constants_1.TOPIC.RECORD,\n            action: message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE,\n            version: 1,\n            parsedData: data\n        });\n        this.recordServices.dirtyService.setDirty(this.name, false);\n    };\n    /**\n     * Applies incoming updates and patches to the record\'s dataset\n     */\n    RecordCore.prototype.applyUpdate = function (message) {\n        var version = message.version;\n        var data = message.parsedData;\n        if (this.version === null) {\n            this.version = version;\n        }\n        else if (this.version + 1 !== version) {\n            this.stateMachine.transition("INVALID_VERSION" /* INVALID_VERSION */);\n            if (message.action === message_constants_1.RECORD_ACTIONS.PATCH) {\n                /**\n                * Request a snapshot so that a merge can be done with the read reply which contains\n                * the full state of the record\n                **/\n                this.sendRead();\n            }\n            else {\n                // @ts-ignore\n                this.recoverRecord(message.version, data, message);\n            }\n            return;\n        }\n        this.version = version;\n        var newData;\n        if (message.action === message_constants_1.RECORD_ACTIONS.PATCH) {\n            newData = json_path_1.setValue(this.data, message.path, data);\n        }\n        else if (message.action === message_constants_1.RECORD_ACTIONS.ERASE) {\n            newData = json_path_1.setValue(this.data, message.path, undefined);\n        }\n        else {\n            newData = json_path_1.setValue(this.data, null, data);\n        }\n        this.applyChange(newData);\n    };\n    /**\n     * Compares the new values for every path with the previously stored ones and\n     * updates the subscribers if the value has changed\n     */\n    RecordCore.prototype.applyChange = function (newData) {\n        if (this.stateMachine.inEndState) {\n            return;\n        }\n        var oldData = this.data;\n        this.data = newData;\n        var paths = this.emitter.eventNames();\n        for (var i = 0; i < paths.length; i++) {\n            var newValue = json_path_1.get(newData, paths[i], false);\n            var oldValue = json_path_1.get(oldData, paths[i], false);\n            if (newValue !== oldValue) {\n                this.emitter.emit(paths[i], this.get(paths[i]));\n            }\n        }\n    };\n    /**\n     * If connected sends the delete message to server, otherwise\n     * we delete in local storage and transition to delete success.\n     */\n    RecordCore.prototype.sendDelete = function () {\n        var _this = this;\n        this.whenReadyInternal(null, function () {\n            if (_this.services.connection.isConnected) {\n                var message = {\n                    topic: message_constants_1.TOPIC.RECORD,\n                    action: message_constants_1.RECORD_ACTIONS.DELETE,\n                    name: _this.name\n                };\n                _this.deletedTimeout = _this.services.timeoutRegistry.add({\n                    message: message,\n                    event: constants_1.EVENT.RECORD_DELETE_TIMEOUT,\n                    duration: _this.options.recordDeleteTimeout\n                });\n                _this.services.connection.sendMessage(message);\n            }\n            else {\n                _this.services.storage.delete(_this.name, function () {\n                    _this.services.timerRegistry.requestIdleCallback(function () {\n                        _this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS);\n                    });\n                });\n            }\n        });\n    };\n    /**\n     * Called when a merge conflict is detected by a VERSION_EXISTS error or if an update recieved\n     * is directly after the clients. If no merge strategy is configure it will emit a VERSION_EXISTS\n     * error and the record will remain in an inconsistent state.\n     *\n     * @param   {Number} remoteVersion The remote version number\n     * @param   {Object} remoteData The remote object data\n     * @param   {Object} message parsed and validated deepstream message\n     */\n    RecordCore.prototype.recoverRecord = function (remoteVersion, remoteData, message) {\n        this.recordServices.mergeStrategy.merge(this.name, this.version, this.get(), remoteVersion, remoteData, this.onRecordRecovered, this);\n    };\n    /**\n   * Callback once the record merge has completed. If successful it will set the\n   * record state, else emit and error and the record will remain in an\n   * inconsistent state until the next update.\n   */\n    RecordCore.prototype.onRecordRecovered = function (error, recordName, mergedData, remoteVersion, remoteData) {\n        if (error) {\n            this.services.logger.error({ topic: message_constants_1.TOPIC.RECORD }, constants_1.EVENT.RECORD_VERSION_EXISTS);\n        }\n        this.version = remoteVersion;\n        var oldValue = this.data;\n        if (utils.deepEquals(oldValue, remoteData)) {\n            this.stateMachine.transition("MERGED" /* MERGED */);\n            return;\n        }\n        var newValue = json_path_1.setValue(oldValue, null, mergedData);\n        this.stateMachine.transition("MERGED" /* MERGED */);\n        if (utils.deepEquals(mergedData, remoteData)) {\n            this.applyChange(mergedData);\n            // const callback = this.writeCallbacks.get(remoteVersion)\n            // if (callback !== undefined) {\n            //   callback(null)\n            //   this.writeCallbacks.delete(remoteVersion)\n            // }\n        }\n        else {\n            this.applyChange(newValue);\n            // this.sendUpdate(null, data, message.isWriteAck)\n        }\n    };\n    /**\n   * A quick check that\'s carried out by most methods that interact with the record\n   * to make sure it hasn\'t been destroyed yet - and to handle it gracefully if it has.\n   */\n    RecordCore.prototype.checkDestroyed = function (methodName) {\n        if (this.stateMachine.inEndState) {\n            this.services.logger.error({ topic: message_constants_1.TOPIC.RECORD }, constants_1.EVENT.RECORD_ALREADY_DESTROYED, { methodName: methodName });\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Destroys the record and nulls all\n     * its dependencies\n     */\n    RecordCore.prototype.destroy = function () {\n        this.services.timerRegistry.remove(this.readyTimer);\n        this.services.timeoutRegistry.clear(this.responseTimeout);\n        this.services.timeoutRegistry.clear(this.deletedTimeout);\n        this.services.timeoutRegistry.clear(this.discardTimeout);\n        this.services.connection.removeOnReestablished(this.onConnectionReestablished);\n        this.services.connection.removeOnLost(this.onConnectionLost);\n        this.emitter.off();\n        this.isReady = false;\n        this.whenComplete(this.name);\n    };\n    RecordCore.prototype.onConnectionReestablished = function () {\n        this.stateMachine.transition("RESUBSCRIBE" /* RESUBSCRIBE */);\n    };\n    RecordCore.prototype.onConnectionLost = function () {\n        this.saveRecordToOffline();\n    };\n    return RecordCore;\n}(Emitter));\nexports.RecordCore = RecordCore;\nvar recordStateTransitions = [\n    { name: message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD, from: "INITIAL" /* INITIAL */, to: "SUBSCRIBING" /* SUBSCRIBING */, handler: RecordCore.prototype.onSubscribing },\n    { name: "LOAD" /* LOAD */, from: "INITIAL" /* INITIAL */, to: "LOADING_OFFLINE" /* LOADING_OFFLINE */, handler: RecordCore.prototype.onOfflineLoading },\n    { name: "LOADED" /* LOADED */, from: "LOADING_OFFLINE" /* LOADING_OFFLINE */, to: "READY" /* READY */, handler: RecordCore.prototype.onReady },\n    { name: "RESUBSCRIBE" /* RESUBSCRIBE */, from: "LOADING_OFFLINE" /* LOADING_OFFLINE */, to: "RESUBSCRIBING" /* RESUBSCRIBING */, handler: RecordCore.prototype.abortOfflineLoading },\n    { name: message_constants_1.RECORD_ACTIONS.READ_RESPONSE, from: "SUBSCRIBING" /* SUBSCRIBING */, to: "READY" /* READY */, handler: RecordCore.prototype.onReady },\n    { name: "SUBSCRIBED" /* SUBSCRIBED */, from: "RESUBSCRIBING" /* RESUBSCRIBING */, to: "READY" /* READY */ },\n    { name: "RESUBSCRIBE" /* RESUBSCRIBE */, from: "INITIAL" /* INITIAL */, to: "RESUBSCRIBING" /* RESUBSCRIBING */, handler: RecordCore.prototype.onResubscribing },\n    { name: "RESUBSCRIBE" /* RESUBSCRIBE */, from: "READY" /* READY */, to: "RESUBSCRIBING" /* RESUBSCRIBING */, handler: RecordCore.prototype.onResubscribing },\n    { name: "RESUBSCRIBE" /* RESUBSCRIBE */, from: "UNSUBSCRIBING" /* UNSUBSCRIBING */, to: "RESUBSCRIBING" /* RESUBSCRIBING */, handler: RecordCore.prototype.onResubscribing },\n    { name: "RESUBSCRIBED" /* RESUBSCRIBED */, from: "RESUBSCRIBING" /* RESUBSCRIBING */, to: "READY" /* READY */ },\n    { name: "INVALID_VERSION" /* INVALID_VERSION */, from: "RESUBSCRIBING" /* RESUBSCRIBING */, to: "MERGING" /* MERGING */ },\n    { name: "MERGED" /* MERGED */, from: "MERGING" /* MERGING */, to: "READY" /* READY */ },\n    { name: message_constants_1.RECORD_ACTIONS.DELETE, from: "READY" /* READY */, to: "DELETING" /* DELETING */ },\n    { name: message_constants_1.RECORD_ACTIONS.DELETED, from: "READY" /* READY */, to: "DELETED" /* DELETED */, handler: RecordCore.prototype.onDeleted },\n    { name: message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS, from: "DELETING" /* DELETING */, to: "DELETED" /* DELETED */, handler: RecordCore.prototype.onDeleted },\n    { name: message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE, from: "READY" /* READY */, to: "UNSUBSCRIBING" /* UNSUBSCRIBING */ },\n    { name: message_constants_1.RECORD_ACTIONS.SUBSCRIBE, from: "UNSUBSCRIBING" /* UNSUBSCRIBING */, to: "READY" /* READY */ },\n    { name: message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE_ACK, from: "UNSUBSCRIBING" /* UNSUBSCRIBING */, to: "UNSUBSCRIBED" /* UNSUBSCRIBED */, handler: RecordCore.prototype.onUnsubscribed },\n    { name: "INVALID_VERSION" /* INVALID_VERSION */, from: "READY" /* READY */, to: "MERGING" /* MERGING */ },\n];\n\n\n//# sourceURL=webpack://deepstream/./src/record/record-core.ts?')},"./src/record/record-handler.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils = __webpack_require__(/*! ../util/utils */ \"./src/util/utils.ts\");\nvar constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nvar message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nvar utils_1 = __webpack_require__(/*! ../../binary-protocol/src/utils */ \"./binary-protocol/src/utils.ts\");\nvar record_core_1 = __webpack_require__(/*! ./record-core */ \"./src/record/record-core.ts\");\nvar record_1 = __webpack_require__(/*! ./record */ \"./src/record/record.ts\");\nvar anonymous_record_1 = __webpack_require__(/*! ./anonymous-record */ \"./src/record/anonymous-record.ts\");\nvar list_1 = __webpack_require__(/*! ./list */ \"./src/record/list.ts\");\nvar listener_1 = __webpack_require__(/*! ../util/listener */ \"./src/util/listener.ts\");\nvar single_notifier_1 = __webpack_require__(/*! ./single-notifier */ \"./src/record/single-notifier.ts\");\nvar write_ack_service_1 = __webpack_require__(/*! ./write-ack-service */ \"./src/record/write-ack-service.ts\");\nvar dirty_service_1 = __webpack_require__(/*! ./dirty-service */ \"./src/record/dirty-service.ts\");\nvar merge_strategy_service_1 = __webpack_require__(/*! ./merge-strategy-service */ \"./src/record/merge-strategy-service.ts\");\nvar bulk_subscription_service_1 = __webpack_require__(/*! ../util/bulk-subscription-service */ \"./src/util/bulk-subscription-service.ts\");\nvar RecordHandler = /** @class */ (function () {\n    function RecordHandler(services, options, recordServices, listener) {\n        var _a;\n        this.services = services;\n        this.options = options;\n        this.listener = listener || new listener_1.Listener(message_constants_1.TOPIC.RECORD, this.services);\n        this.recordCores = new Map();\n        this.recordServices = recordServices || {\n            bulkSubscriptionService: (_a = {},\n                _a[message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD_BULK] = this.getBulkSubscriptionService(message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD_BULK, message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD),\n                _a[message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD_BULK] = this.getBulkSubscriptionService(message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD_BULK, message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD),\n                _a[message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD_BULK] = this.getBulkSubscriptionService(message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD_BULK, message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD),\n                _a),\n            writeAckService: new write_ack_service_1.WriteAcknowledgementService(services),\n            readRegistry: new single_notifier_1.SingleNotifier(services, message_constants_1.RECORD_ACTIONS.READ, options.recordReadTimeout),\n            headRegistry: new single_notifier_1.SingleNotifier(services, message_constants_1.RECORD_ACTIONS.HEAD, options.recordReadTimeout),\n            dirtyService: new dirty_service_1.DirtyService(services.storage, options.dirtyStorageName),\n            mergeStrategy: new merge_strategy_service_1.MergeStrategyService(services, options.mergeStrategy)\n        };\n        this.dirtyService = this.recordServices.dirtyService;\n        this.sendUpdatedData = this.sendUpdatedData.bind(this);\n        this.onRecordUpdated = this.onRecordUpdated.bind(this);\n        this.onMergeCompleted = this.onMergeCompleted.bind(this);\n        this.getRecordCore = this.getRecordCore.bind(this);\n        this.removeRecord = this.removeRecord.bind(this);\n        this.onBulkSubscriptionSent = this.onBulkSubscriptionSent.bind(this);\n        this.services.connection.registerHandler(message_constants_1.TOPIC.RECORD, this.handle.bind(this));\n        this.services.connection.onReestablished(this.syncDirtyRecords.bind(this));\n        if (this.services.connection.isConnected) {\n            this.syncDirtyRecords();\n        }\n    }\n    RecordHandler.prototype.setMergeStrategy = function (recordName, mergeStrategy) {\n        if (typeof mergeStrategy === 'function') {\n            this.recordServices.mergeStrategy.setMergeStrategyByName(recordName, mergeStrategy);\n        }\n        else {\n            throw new Error('Invalid merge strategy: Must be a Function');\n        }\n    };\n    RecordHandler.prototype.setMergeStrategyRegExp = function (regexp, mergeStrategy) {\n        if (typeof mergeStrategy === 'function') {\n            this.recordServices.mergeStrategy.setMergeStrategyByPattern(regexp, mergeStrategy);\n        }\n        else {\n            throw new Error('Invalid merge strategy: Must be a Function');\n        }\n    };\n    /**\n   * Returns an existing record or creates a new one.\n   *\n   * @param   {String} name              the unique name of the record\n   */\n    RecordHandler.prototype.getRecord = function (name) {\n        return new record_1.Record(this.getRecordCore(name));\n    };\n    /**\n     * Returns an existing List or creates a new one. A list is a specialised\n     * type of record that holds an array of recordNames.\n     *\n     * @param   {String} name       the unique name of the list\n     */\n    RecordHandler.prototype.getList = function (name) {\n        return new list_1.List(this.getRecordCore(name));\n    };\n    /**\n     * Returns an anonymous record. A anonymous record is effectively\n     * a wrapper that mimicks the API of a record, but allows for the\n     * underlying record to be swapped without loosing subscriptions etc.\n     *\n     * This is particularly useful when selecting from a number of similarly\n     * structured records. E.g. a list of users that can be choosen from a list\n     *\n     * The only API difference to a normal record is an additional setName( name ) method.\n     */\n    RecordHandler.prototype.getAnonymousRecord = function () {\n        return new anonymous_record_1.AnonymousRecord(this.getRecordCore);\n    };\n    /**\n     * Allows to listen for record subscriptions made by this or other clients. This\n     * is useful to create \"active\" data providers, e.g. providers that only provide\n     * data for a particular record if a user is actually interested in it\n     *\n     * @param   {String}   pattern  A combination of alpha numeric characters and wildcards( * )\n     * @param   {Function} callback\n     */\n    RecordHandler.prototype.listen = function (pattern, callback) {\n        this.listener.listen(pattern, callback);\n    };\n    /**\n     * Removes a listener that was previously registered with listenForSubscriptions\n     *\n     * @param   {String}   pattern  A combination of alpha numeric characters and wildcards( * )\n     */\n    RecordHandler.prototype.unlisten = function (pattern) {\n        this.listener.unlisten(pattern);\n    };\n    RecordHandler.prototype.snapshot = function (name, callback) {\n        var _this = this;\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument: name');\n        }\n        if (callback !== undefined && typeof callback !== 'function') {\n            throw new Error('invalid argument: callback');\n        }\n        var recordCore = this.recordCores.get(name);\n        if (recordCore) {\n            if (callback) {\n                recordCore.whenReady(null, function () {\n                    callback(null, recordCore.get());\n                });\n            }\n            else {\n                return new Promise(function (resolve, reject) {\n                    recordCore.whenReady(null, function () {\n                        resolve(recordCore.get());\n                    });\n                });\n            }\n            return;\n        }\n        if (callback) {\n            this.recordServices.readRegistry.request(name, callback);\n        }\n        else {\n            return new Promise(function (resolve, reject) {\n                _this.recordServices.readRegistry.request(name, function (error, data) { return error ? reject(error) : resolve(data); });\n            });\n        }\n    };\n    RecordHandler.prototype.has = function (name, callback) {\n        var _this = this;\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument: name');\n        }\n        if (callback !== undefined && typeof callback !== 'function') {\n            throw new Error('invalid argument: callback');\n        }\n        var cb;\n        if (!callback) {\n            return new Promise(function (resolve, reject) {\n                cb = function (error, version) { return error ? reject(error) : resolve(version !== -1); };\n                _this.head(name, cb);\n            });\n        }\n        cb = function (error, version) { return error ? callback(error, null) : callback(null, version !== -1); };\n        this.head(name, cb);\n    };\n    RecordHandler.prototype.head = function (name, callback) {\n        var _this = this;\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument: name');\n        }\n        if (callback !== undefined && typeof callback !== 'function') {\n            throw new Error('invalid argument: callback');\n        }\n        var recordCore = this.recordCores.get(name);\n        if (recordCore) {\n            if (callback) {\n                recordCore.whenReady(null, function () {\n                    callback(null, recordCore.version);\n                });\n            }\n            else {\n                return new Promise(function (resolve, reject) {\n                    recordCore.whenReady(null, function () {\n                        resolve(recordCore.version);\n                    });\n                });\n            }\n            return;\n        }\n        if (callback) {\n            this.recordServices.headRegistry.request(name, callback);\n        }\n        else {\n            return new Promise(function (resolve, reject) {\n                _this.recordServices.headRegistry.request(name, function (error, data) { return error ? reject(error) : resolve(data); });\n            });\n        }\n    };\n    RecordHandler.prototype.setDataWithAck = function (recordName) {\n        var _this = this;\n        var rest = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            rest[_i - 1] = arguments[_i];\n        }\n        var args = utils.normalizeSetArguments(arguments, 1);\n        if (!args.callback) {\n            return new Promise(function (resolve, reject) {\n                args.callback = function (error) { return error === null ? resolve() : reject(error); };\n                _this.sendSetData(recordName, -1, args);\n            });\n        }\n        this.sendSetData(recordName, -1, args);\n    };\n    RecordHandler.prototype.setData = function (recordName) {\n        var args = utils.normalizeSetArguments(arguments, 1);\n        this.sendSetData(recordName, -1, args);\n    };\n    RecordHandler.prototype.sendSetData = function (recordName, version, args) {\n        var path = args.path, data = args.data, callback = args.callback;\n        if (!recordName || typeof recordName !== 'string' || recordName.length === 0) {\n            throw new Error('invalid argument: recordName must be an non empty string');\n        }\n        if (!path && (data === null || typeof data !== 'object')) {\n            throw new Error('invalid argument: data must be an object when no path is provided');\n        }\n        var recordCores = this.recordCores.get(recordName);\n        if (recordCores) {\n            recordCores.set({ path: path, data: data, callback: callback });\n            return;\n        }\n        var action;\n        if (path) {\n            if (data === undefined) {\n                action = message_constants_1.RECORD_ACTIONS.ERASE;\n            }\n            else {\n                action = message_constants_1.RECORD_ACTIONS.CREATEANDPATCH;\n            }\n        }\n        else {\n            action = message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE;\n        }\n        var message = {\n            topic: message_constants_1.TOPIC.RECORD,\n            action: action,\n            name: recordName,\n            path: path,\n            version: version,\n            parsedData: data\n        };\n        if (callback) {\n            this.recordServices.writeAckService.send(message, callback);\n        }\n        else {\n            this.services.connection.sendMessage(message);\n        }\n    };\n    /**\n     * Will be called by the client for incoming messages on the RECORD topic\n     *\n     * @param   {Object} message parsed and validated deepstream message\n     */\n    RecordHandler.prototype.handle = function (message) {\n        if (message.isAck) {\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND ||\n            message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED ||\n            message.action === message_constants_1.RECORD_ACTIONS.LISTEN ||\n            message.action === message_constants_1.RECORD_ACTIONS.UNLISTEN) {\n            this.listener.handle(message);\n            return;\n        }\n        if (utils_1.isWriteAck(message.action) || utils_1.isWriteAck(message.originalAction)) {\n            this.recordServices.writeAckService.recieve(message);\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.READ_RESPONSE || message.originalAction === message_constants_1.RECORD_ACTIONS.READ) {\n            if (message.isError) {\n                this.recordServices.readRegistry.recieve(message, message_constants_1.RECORD_ACTIONS[message.action]);\n            }\n            else {\n                this.recordServices.readRegistry.recieve(message, null, message.parsedData);\n            }\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.HEAD_RESPONSE ||\n            message.originalAction === message_constants_1.RECORD_ACTIONS.HEAD) {\n            if (message.isError) {\n                this.recordServices.headRegistry.recieve(message, message_constants_1.RECORD_ACTIONS[message.action]);\n            }\n            else {\n                this.recordServices.headRegistry.recieve(message, null, message.version);\n            }\n        }\n        var recordCore = this.recordCores.get(message.name);\n        if (recordCore) {\n            recordCore.handle(message);\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.VERSION_EXISTS) {\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_PROVIDER ||\n            message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_NO_PROVIDER) {\n            // record can receive a HAS_PROVIDER after discarding the record\n            return;\n        }\n        if (message.isError) {\n            this.services.logger.error(message);\n            return;\n        }\n        this.services.logger.error(message, constants_1.EVENT.UNSOLICITED_MESSAGE);\n    };\n    /**\n     * Callback for 'deleted' and 'discard' events from a record. Removes the record from\n     * the registry\n     */\n    RecordHandler.prototype.removeRecord = function (recordName) {\n        this.recordCores.delete(recordName);\n    };\n    RecordHandler.prototype.getRecordCore = function (recordName) {\n        var recordCore = this.recordCores.get(recordName);\n        if (!recordCore) {\n            recordCore = new record_core_1.RecordCore(recordName, this.services, this.options, this.recordServices, this.removeRecord);\n            this.recordCores.set(recordName, recordCore);\n        }\n        return recordCore;\n    };\n    RecordHandler.prototype.syncDirtyRecords = function () {\n        this.dirtyService.whenLoaded(this, this._syncDirtyRecords);\n    };\n    // TODO: Expose issues here, as there isn't a reason why a record core needs to exist in\n    // order to sync up\n    RecordHandler.prototype._syncDirtyRecords = function () {\n        var dirtyRecords = this.dirtyService.getAll();\n        for (var recordName in dirtyRecords) {\n            var recordCore = this.recordCores.get(recordName);\n            if (recordCore && recordCore.references.size > 0) {\n                // if it isn't zero.. problem.\n                continue;\n            }\n            this.services.storage.get(recordName, this.sendUpdatedData);\n        }\n    };\n    RecordHandler.prototype.sendUpdatedData = function (recordName, version, data) {\n        this.sendSetData(recordName, version, { data: data, callback: this.onRecordUpdated });\n    };\n    RecordHandler.prototype.onRecordUpdated = function (error, recordName) {\n        if (!error) {\n            this.dirtyService.setDirty(recordName, false);\n        }\n    };\n    /**\n    * Callback once the record merge has completed. If successful it will set the\n    * record state, else emit and error and the record will remain in an\n    * inconsistent state until the next update.\n    */\n    // private onMergeConflict (message: RecordWriteMessage): void {\n    //   this.services.storage.get(message.name, (recordName: string, version: number, data: RecordData) => {\n    //     this.recordServices.mergeStrategy.merge(\n    //       message.name,\n    //       version,\n    //       data,\n    //       message.version,\n    //       message.parsedData,\n    //       this.onMergeCompleted\n    //     )\n    //   })\n    // }\n    RecordHandler.prototype.onMergeCompleted = function (error, recordName, mergeData, remoteVersion, remoteData) {\n        this.sendSetData(recordName, remoteVersion + 1, { data: mergeData });\n    };\n    RecordHandler.prototype.getBulkSubscriptionService = function (bulkSubscribe, subscribe) {\n        return new bulk_subscription_service_1.BulkSubscriptionService(this.services, this.options.subscriptionInterval, message_constants_1.TOPIC.RECORD, bulkSubscribe, subscribe, message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE_BULK, message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE, this.onBulkSubscriptionSent);\n    };\n    RecordHandler.prototype.onBulkSubscriptionSent = function (message) {\n        if (!message.names) {\n            this.services.timeoutRegistry.add({ message: message });\n        }\n    };\n    return RecordHandler;\n}());\nexports.RecordHandler = RecordHandler;\n\n\n//# sourceURL=webpack://deepstream/./src/record/record-handler.ts?")},"./src/record/record.ts":function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, "__esModule", { value: true });\nvar utils = __webpack_require__(/*! ../util/utils */ "./src/util/utils.ts");\nvar constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\nvar Emitter = __webpack_require__(/*! component-emitter2 */ "./node_modules/component-emitter2/index.js");\nvar Record = /** @class */ (function (_super) {\n    __extends(Record, _super);\n    function Record(record) {\n        var _this = _super.call(this) || this;\n        _this.record = record;\n        _this.subscriptions = [];\n        _this.record.on(constants_1.EVENT.RECORD_READY, _this.emit.bind(_this, constants_1.EVENT.RECORD_READY, _this));\n        _this.record.on(constants_1.EVENT.RECORD_DISCARDED, _this.emit.bind(_this, constants_1.EVENT.RECORD_DISCARDED));\n        _this.record.on(constants_1.EVENT.RECORD_DELETED, _this.emit.bind(_this, constants_1.EVENT.RECORD_DELETED));\n        _this.record.on(constants_1.EVENT.RECORD_ERROR, _this.emit.bind(_this, constants_1.EVENT.RECORD_ERROR));\n        _this.record.addReference(_this);\n        return _this;\n    }\n    Object.defineProperty(Record.prototype, "name", {\n        get: function () {\n            return this.record.name;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Record.prototype, "isReady", {\n        get: function () {\n            return this.record.isReady;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Record.prototype, "version", {\n        get: function () {\n            return this.record.version;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Record.prototype, "hasProvider", {\n        get: function () {\n            return this.record.hasProvider;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Record.prototype.whenReady = function (callback) {\n        if (callback) {\n            this.record.whenReady(this, callback);\n        }\n        else {\n            return this.record.whenReady(this);\n        }\n    };\n    Record.prototype.get = function (path) {\n        return this.record.get(path);\n    };\n    Record.prototype.set = function (dataOrPath, dataOrCallback, callback) {\n        return this.record.set(utils.normalizeSetArguments(arguments));\n    };\n    Record.prototype.setWithAck = function (pathOrData, dataOrCallback, callback) {\n        return this.record.setWithAck(utils.normalizeSetArguments(arguments));\n    };\n    /**\n     * Deletes a path from the record. Equivalent to doing `record.set(path, undefined)`\n     *\n     * @param {String} path The path to be deleted\n     */\n    Record.prototype.erase = function (path) {\n        if (!path) {\n            throw new Error(\'unable to erase record data without path, consider using `delete`\');\n        }\n        this.set(path, undefined);\n    };\n    Record.prototype.eraseWithAck = function (path, callback) {\n        if (!path) {\n            throw new Error(\'unable to erase record data without path, consider using `delete`\');\n        }\n        if (callback) {\n            this.setWithAck(path, undefined, callback);\n        }\n        else {\n            return this.setWithAck(path, undefined);\n        }\n    };\n    Record.prototype.subscribe = function (path, callback, triggerNow) {\n        var parameters = utils.normalizeArguments(arguments);\n        this.subscriptions.push(parameters);\n        this.record.subscribe(parameters);\n    };\n    Record.prototype.unsubscribe = function (path, callback) {\n        var parameters = utils.normalizeArguments(arguments);\n        this.subscriptions = this.subscriptions.filter(function (subscription) {\n            return (subscription.path !== parameters.path ||\n                subscription.callback !== parameters.callback);\n        });\n        this.record.unsubscribe(parameters);\n    };\n    Record.prototype.discard = function () {\n        for (var i = 0; i < this.subscriptions.length; i++) {\n            this.record.unsubscribe(this.subscriptions[i]);\n        }\n        return this.record.removeReference(this);\n    };\n    Record.prototype.delete = function (callback) {\n        return this.record.delete(callback);\n    };\n    Record.prototype.setMergeStrategy = function (mergeStrategy) {\n        this.record.setMergeStrategy(mergeStrategy);\n    };\n    return Record;\n}(Emitter));\nexports.Record = Record;\n\n\n//# sourceURL=webpack://deepstream/./src/record/record.ts?')},"./src/record/single-notifier.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nvar constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\n/**\n * Provides a scaffold for subscriptionless requests to deepstream, such as the SNAPSHOT\n * and HAS functionality. The SingleNotifier multiplexes all the client requests so\n * that they can can be notified at once, and also includes reconnection funcionality\n * incase the connection drops.\n *\n * @param {Services} services          The deepstream client\n * @param {Options} options     Function to call to allow resubscribing\n *\n * @constructor\n */\nvar SingleNotifier = /** @class */ (function () {\n    function SingleNotifier(services, action, timeoutDuration) {\n        this.services = services;\n        this.action = action;\n        this.requests = new Map();\n        this.internalRequests = new Map();\n        this.limboQueue = [];\n        this.services.connection.onLost(this.onConnectionLost.bind(this));\n        this.services.connection.onExitLimbo(this.onExitLimbo.bind(this));\n        this.services.connection.onReestablished(this.onConnectionReestablished.bind(this));\n    }\n    /**\n     * Add a request. If one has already been made it will skip the server request\n     * and multiplex the response\n     *\n     * @param {String} name An identifier for the request, e.g. a record name\n     * @param {Object} response An object with property `callback` or `resolve` and `reject`\n     *\n     * @public\n     * @returns {void}\n     */\n    SingleNotifier.prototype.request = function (name, callback) {\n        var req = this.requests.get(name);\n        if (req) {\n            req.push(callback);\n            return;\n        }\n        this.requests.set(name, [callback]);\n        var message = {\n            topic: message_constants_1.TOPIC.RECORD,\n            action: this.action,\n            name: name\n        };\n        if (this.services.connection.isConnected) {\n            this.services.connection.sendMessage(message);\n            this.services.timeoutRegistry.add({ message: message });\n        }\n        else if (this.services.connection.isInLimbo) {\n            this.limboQueue.push(message);\n        }\n        else {\n            callback(constants_1.EVENT.CLIENT_OFFLINE);\n        }\n    };\n    /**\n     * Adds a callback to a (possibly) inflight request that will be called\n     * on the response.\n     */\n    SingleNotifier.prototype.register = function (name, context, callback) {\n        var request = this.internalRequests.get(name);\n        if (!request) {\n            this.internalRequests.set(name, [{ callback: callback, context: context }]);\n        }\n        else {\n            request.push({ callback: callback, context: context });\n        }\n    };\n    SingleNotifier.prototype.recieve = function (message, error, data) {\n        this.services.timeoutRegistry.remove(message);\n        var name = message.name;\n        var responses = this.requests.get(name) || [];\n        var internalResponses = this.internalRequests.get(name) || [];\n        if (!responses && !internalResponses) {\n            return;\n        }\n        for (var i = 0; i < internalResponses.length; i++) {\n            internalResponses[i].callback.call(internalResponses[i].context, message);\n        }\n        this.internalRequests.delete(name);\n        // todo we can clean this up and do cb = (error, data) => error ? reject(error) : resolve()\n        for (var i = 0; i < responses.length; i++) {\n            responses[i](error, data);\n        }\n        this.requests.delete(name);\n        return;\n    };\n    SingleNotifier.prototype.onConnectionLost = function () {\n        this.requests.forEach(function (responses) {\n            responses.forEach(function (response) { return response(constants_1.EVENT.CLIENT_OFFLINE); });\n        });\n        this.requests.clear();\n    };\n    SingleNotifier.prototype.onExitLimbo = function () {\n        for (var i = 0; i < this.limboQueue.length; i++) {\n            var message = this.limboQueue[i];\n            var requests = this.requests.get(message.name);\n            if (requests) {\n                requests.forEach(function (cb) { return cb(constants_1.EVENT.CLIENT_OFFLINE); });\n            }\n        }\n        this.requests.clear();\n        this.limboQueue = [];\n    };\n    SingleNotifier.prototype.onConnectionReestablished = function () {\n        for (var i = 0; i < this.limboQueue.length; i++) {\n            var message = this.limboQueue[i];\n            this.services.connection.sendMessage(message);\n            this.services.timeoutRegistry.add({ message: message });\n        }\n    };\n    return SingleNotifier;\n}());\nexports.SingleNotifier = SingleNotifier;\n\n\n//# sourceURL=webpack://deepstream/./src/record/single-notifier.ts?')},"./src/record/write-ack-service.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nvar utils_1 = __webpack_require__(/*! ../../binary-protocol/src/utils */ "./binary-protocol/src/utils.ts");\nvar constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\nvar WriteAcknowledgementService = /** @class */ (function () {\n    function WriteAcknowledgementService(services) {\n        this.services = services;\n        this.responses = new Map();\n        this.count = 1;\n        this.services.connection.onLost(this.onConnectionLost.bind(this));\n    }\n    /**\n     * Send message with write ack callback.\n     */\n    WriteAcknowledgementService.prototype.send = function (message, callback) {\n        if (this.services.connection.isConnected === false) {\n            this.services.timerRegistry.requestIdleCallback(callback.bind(this, constants_1.EVENT.CLIENT_OFFLINE));\n            return;\n        }\n        var correlationId = this.count.toString();\n        this.responses.set(correlationId, callback);\n        this.services.connection.sendMessage(Object.assign({}, message, { correlationId: correlationId, action: utils_1.ACTION_TO_WRITE_ACK[message.action] }));\n        this.count++;\n    };\n    WriteAcknowledgementService.prototype.recieve = function (message) {\n        var id = message.correlationId;\n        var response = this.responses.get(id);\n        if (!response ||\n            (message.action !== message_constants_1.RECORD_ACTIONS.WRITE_ACKNOWLEDGEMENT && !message.isError)) {\n            return;\n        }\n        message.isError\n            ? response(message_constants_1.RECORD_ACTIONS[message.action])\n            : response(null);\n        this.responses.delete(id);\n    };\n    WriteAcknowledgementService.prototype.onConnectionLost = function () {\n        this.responses.forEach(function (response) { return response(constants_1.EVENT.CLIENT_OFFLINE); });\n        this.responses.clear();\n    };\n    return WriteAcknowledgementService;\n}());\nexports.WriteAcknowledgementService = WriteAcknowledgementService;\n\n\n//# sourceURL=webpack://deepstream/./src/record/write-ack-service.ts?')},"./src/rpc/rpc-handler.ts":function(module,exports,__webpack_require__){"use strict";eval('\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nvar constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\nvar rpc_1 = __webpack_require__(/*! ../rpc/rpc */ "./src/rpc/rpc.ts");\nvar rpc_response_1 = __webpack_require__(/*! ../rpc/rpc-response */ "./src/rpc/rpc-response.ts");\nvar utils_1 = __webpack_require__(/*! ../util/utils */ "./src/util/utils.ts");\nvar RPCHandler = /** @class */ (function () {\n    function RPCHandler(services, options) {\n        this.services = services;\n        this.options = options;\n        this.rpcs = new Map();\n        this.providers = new Map();\n        this.limboQueue = [];\n        this.services.connection.registerHandler(message_constants_1.TOPIC.RPC, this.handle.bind(this));\n        this.services.connection.onReestablished(this.onConnectionReestablished.bind(this));\n        this.services.connection.onExitLimbo(this.onExitLimbo.bind(this));\n        this.services.connection.onLost(this.onConnectionLost.bind(this));\n    }\n    /**\n     * Registers a callback function as a RPC provider. If another connected client calls\n     * client.rpc.make() the request will be routed to this method\n     *\n     * The callback will be invoked with two arguments:\n     *     {Mixed} data The data passed to the client.rpc.make function\n     *     {RpcResponse} rpcResponse An object with methods to response,\n     *                               acknowledge or reject the request\n     *\n     * Only one callback can be registered for a RPC at a time\n     *\n     * Please note: Deepstream tries to deliver data in its original format.\n     * Data passed to client.rpc.make as a String will arrive as a String,\n     * numbers or implicitly JSON serialized objects will arrive in their\n     * respective format as well\n     */\n    RPCHandler.prototype.provide = function (name, callback) {\n        if (typeof name !== \'string\' || name.length === 0) {\n            throw new Error(\'invalid argument name\');\n        }\n        if (this.providers.has(name)) {\n            throw new Error("RPC " + name + " already registered");\n        }\n        if (typeof callback !== \'function\') {\n            throw new Error(\'invalid argument callback\');\n        }\n        this.providers.set(name, callback);\n        if (this.services.connection.isConnected) {\n            this.sendProvide(name);\n        }\n    };\n    /**\n     * Unregisters this client as a provider for a remote procedure call\n     */\n    RPCHandler.prototype.unprovide = function (name) {\n        if (typeof name !== \'string\' || name.length === 0) {\n            throw new Error(\'invalid argument name\');\n        }\n        if (!this.providers.has(name)) {\n            this.services.logger.warn({\n                topic: message_constants_1.TOPIC.RPC,\n                action: message_constants_1.RPC_ACTIONS.NOT_PROVIDED,\n                name: name\n            });\n            return;\n        }\n        this.providers.delete(name);\n        if (this.services.connection.isConnected) {\n            var message = { topic: message_constants_1.TOPIC.RPC, action: message_constants_1.RPC_ACTIONS.UNPROVIDE, name: name };\n            this.services.timeoutRegistry.add({ message: message });\n            this.services.connection.sendMessage(message);\n            return;\n        }\n    };\n    RPCHandler.prototype.make = function (name, data, callback) {\n        var _this = this;\n        if (typeof name !== \'string\' || name.length === 0) {\n            throw new Error(\'invalid argument name\');\n        }\n        if (callback && typeof callback !== \'function\') {\n            throw new Error(\'invalid argument callback\');\n        }\n        var correlationId = utils_1.getUid();\n        if (this.services.connection.isConnected) {\n            if (callback) {\n                this.rpcs.set(correlationId, new rpc_1.RPC(name, correlationId, data, callback, this.options, this.services));\n                return;\n            }\n            return new Promise(function (resolve, reject) {\n                _this.rpcs.set(correlationId, new rpc_1.RPC(name, correlationId, data, function (error, result) { return error ? reject(error) : resolve(result); }, _this.options, _this.services));\n            });\n        }\n        else if (this.services.connection.isInLimbo) {\n            if (callback) {\n                this.limboQueue.push({ correlationId: correlationId, name: name, data: data, callback: callback });\n            }\n            else {\n                return new Promise(function (resolve, reject) {\n                    _this.limboQueue.push({ correlationId: correlationId, name: name, data: data, callback: function (error, result) { return error ? reject(error) : resolve(result); } });\n                });\n            }\n        }\n        else {\n            if (callback) {\n                callback(constants_1.EVENT.CLIENT_OFFLINE);\n            }\n            else {\n                return Promise.reject(constants_1.EVENT.CLIENT_OFFLINE);\n            }\n        }\n    };\n    /**\n     * Handles incoming rpc REQUEST messages. Instantiates a new response object\n     * and invokes the provider callback or rejects the request if no rpc provider\n     * is present (which shouldn\'t really happen, but might be the result of a race condition\n     * if this client sends a unprovide message whilst an incoming request is already in flight)\n     */\n    RPCHandler.prototype.respondToRpc = function (message) {\n        var provider = this.providers.get(message.name);\n        if (provider) {\n            provider(message.parsedData, new rpc_response_1.RPCResponse(message, this.options, this.services));\n        }\n        else {\n            this.services.connection.sendMessage({\n                topic: message_constants_1.TOPIC.RPC,\n                action: message_constants_1.RPC_ACTIONS.REJECT,\n                name: message.name,\n                correlationId: message.correlationId\n            });\n        }\n    };\n    /**\n     * Distributes incoming messages from the server\n     * based on their action\n     */\n    RPCHandler.prototype.handle = function (message) {\n        // RPC Requests\n        if (message.action === message_constants_1.RPC_ACTIONS.REQUEST) {\n            this.respondToRpc(message);\n            return;\n        }\n        // RPC subscription Acks\n        if (message.isAck) {\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        // handle auth/denied subscription errors\n        if (message.action === message_constants_1.RPC_ACTIONS.MESSAGE_PERMISSION_ERROR || message.action === message_constants_1.RPC_ACTIONS.MESSAGE_DENIED) {\n            if (message.originalAction === message_constants_1.RPC_ACTIONS.PROVIDE || message.originalAction === message_constants_1.RPC_ACTIONS.UNPROVIDE) {\n                this.services.timeoutRegistry.remove(message);\n                this.providers.delete(message.name);\n                this.services.logger.error(message);\n                return;\n            }\n            if (message.originalAction === message_constants_1.RPC_ACTIONS.REQUEST) {\n                var invalidRPC = this.getRPC(message);\n                if (invalidRPC) {\n                    invalidRPC.error(message_constants_1.RPC_ACTIONS[message.action]);\n                    this.rpcs.delete(message.correlationId);\n                    return;\n                }\n            }\n        }\n        // RPC Responses\n        var rpc = this.getRPC(message);\n        if (rpc) {\n            if (message.action === message_constants_1.RPC_ACTIONS.ACCEPT) {\n                rpc.accept();\n                return;\n            }\n            if (message.action === message_constants_1.RPC_ACTIONS.RESPONSE) {\n                rpc.respond(message.parsedData);\n            }\n            else if (message.action === message_constants_1.RPC_ACTIONS.REQUEST_ERROR) {\n                rpc.error(message.parsedData);\n            }\n            else if (message.action === message_constants_1.RPC_ACTIONS.RESPONSE_TIMEOUT ||\n                message.action === message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER) {\n                rpc.error(message_constants_1.RPC_ACTIONS[message.action]);\n            }\n            this.rpcs.delete(message.correlationId);\n        }\n    };\n    RPCHandler.prototype.getRPC = function (message) {\n        var rpc = this.rpcs.get(message.correlationId);\n        if (rpc === undefined) {\n            this.services.logger.error(message, constants_1.EVENT.UNKNOWN_CORRELATION_ID);\n        }\n        return rpc;\n    };\n    RPCHandler.prototype.sendProvide = function (name) {\n        var message = {\n            topic: message_constants_1.TOPIC.RPC,\n            action: message_constants_1.RPC_ACTIONS.PROVIDE,\n            name: name\n        };\n        this.services.timeoutRegistry.add({ message: message });\n        this.services.connection.sendMessage(message);\n    };\n    RPCHandler.prototype.onConnectionReestablished = function () {\n        var e_1, _a;\n        try {\n            for (var _b = __values(this.providers), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _d = __read(_c.value, 1), name_1 = _d[0];\n                this.sendProvide(name_1);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        for (var i = 0; i < this.limboQueue.length; i++) {\n            var _e = this.limboQueue[i], correlationId = _e.correlationId, name_2 = _e.name, data = _e.data, callback = _e.callback;\n            this.rpcs.set(correlationId, new rpc_1.RPC(name_2, correlationId, data, callback, this.options, this.services));\n        }\n        this.limboQueue = [];\n    };\n    RPCHandler.prototype.onExitLimbo = function () {\n        for (var i = 0; i < this.limboQueue.length; i++) {\n            this.limboQueue[i].callback(constants_1.EVENT.CLIENT_OFFLINE);\n        }\n        this.limboQueue = [];\n    };\n    RPCHandler.prototype.onConnectionLost = function () {\n        this.rpcs.forEach(function (rpc) {\n            rpc.error(constants_1.EVENT.CLIENT_OFFLINE);\n        });\n        this.rpcs.clear();\n    };\n    return RPCHandler;\n}());\nexports.RPCHandler = RPCHandler;\n\n\n//# sourceURL=webpack://deepstream/./src/rpc/rpc-handler.ts?')},"./src/rpc/rpc-response.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\n/**\n * This class represents a single remote procedure\n * call made from the client to the server. It\'s main function\n * is to encapsulate the logic around timeouts and to convert the\n * incoming response data\n */\nvar RPCResponse = /** @class */ (function () {\n    function RPCResponse(message, options, services) {\n        this.name = message.name;\n        this.correlationId = message.correlationId;\n        this.services = services;\n        this.isAccepted = false;\n        this.isComplete = false;\n        this.autoAccept = true;\n        this.services.timerRegistry.requestIdleCallback(this.performAutoAck.bind(this));\n    }\n    /**\n     * Acknowledges the receipt of the request. This\n     * will happen implicitly unless the request callback\n     * explicitly sets autoAck to false\n     */\n    RPCResponse.prototype.accept = function () {\n        if (this.isAccepted === false) {\n            this.services.connection.sendMessage({\n                topic: message_constants_1.TOPIC.RPC,\n                action: message_constants_1.RPC_ACTIONS.ACCEPT,\n                name: this.name,\n                correlationId: this.correlationId\n            });\n            this.isAccepted = true;\n        }\n    };\n    /**\n     * Reject the request. This might be necessary if the client\n     * is already processing a large number of requests. If deepstream\n     * receives a rejection message it will try to route the request to\n     * another provider - or return a NO_RPC_PROVIDER error if there are no\n     * providers left\n     */\n    RPCResponse.prototype.reject = function () {\n        if (this.isComplete === true) {\n            throw new Error("Rpc " + this.name + " already completed");\n        }\n        this.autoAccept = false;\n        this.isComplete = true;\n        this.isAccepted = true;\n        this.services.connection.sendMessage({\n            topic: message_constants_1.TOPIC.RPC,\n            action: message_constants_1.RPC_ACTIONS.REJECT,\n            name: this.name,\n            correlationId: this.correlationId\n        });\n    };\n    /**\n     * Notifies the server that an error has occured while trying to process the request.\n     * This will complete the rpc.\n     */\n    RPCResponse.prototype.error = function (error) {\n        if (this.isComplete === true) {\n            throw new Error("Rpc " + this.name + " already completed");\n        }\n        this.autoAccept = false;\n        this.isComplete = true;\n        this.isAccepted = true;\n        this.services.connection.sendMessage({\n            topic: message_constants_1.TOPIC.RPC,\n            action: message_constants_1.RPC_ACTIONS.REQUEST_ERROR,\n            name: this.name,\n            correlationId: this.correlationId,\n            parsedData: error\n        });\n    };\n    /**\n     * Completes the request by sending the response data\n     * to the server. If data is an array or object it will\n     * automatically be serialised.\n     * If autoAck is disabled and the response is sent before\n     * the ack message the request will still be completed and the\n     * ack message ignored\n     */\n    RPCResponse.prototype.send = function (data) {\n        if (this.isComplete === true) {\n            throw new Error("Rpc " + this.name + " already completed");\n        }\n        this.accept();\n        this.services.connection.sendMessage({\n            topic: message_constants_1.TOPIC.RPC,\n            action: message_constants_1.RPC_ACTIONS.RESPONSE,\n            name: this.name,\n            correlationId: this.correlationId,\n            parsedData: data\n        });\n        this.isComplete = true;\n    };\n    /**\n     * Callback for the autoAck timeout. Executes ack\n     * if autoAck is not disabled\n     */\n    RPCResponse.prototype.performAutoAck = function () {\n        if (this.autoAccept === true) {\n            this.accept();\n        }\n    };\n    return RPCResponse;\n}());\nexports.RPCResponse = RPCResponse;\n\n\n//# sourceURL=webpack://deepstream/./src/rpc/rpc-response.ts?')},"./src/rpc/rpc.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\n/**\n * This class represents a single remote procedure\n * call made from the client to the server. It\'s main function\n * is to encapsulate the logic around timeouts and to convert the\n * incoming response data\n */\nvar RPC = /** @class */ (function () {\n    function RPC(name, correlationId, data, response, options, services) {\n        this.name = name;\n        this.correlationId = correlationId;\n        this.response = response;\n        this.options = options;\n        this.services = services;\n        this.onTimeout = this.onTimeout.bind(this);\n        var message = {\n            topic: message_constants_1.TOPIC.RPC,\n            action: message_constants_1.RPC_ACTIONS.REQUEST,\n            correlationId: correlationId,\n            name: name,\n            parsedData: data\n        };\n        this.acceptTimeout = this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RPC,\n                action: message_constants_1.RPC_ACTIONS.ACCEPT,\n                name: this.name,\n                correlationId: this.correlationId\n            },\n            event: message_constants_1.RPC_ACTIONS.ACCEPT_TIMEOUT,\n            duration: this.options.rpcAcceptTimeout,\n            callback: this.onTimeout\n        });\n        this.responseTimeout = this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RPC,\n                action: message_constants_1.RPC_ACTIONS.REQUEST,\n                name: this.name,\n                correlationId: this.correlationId\n            },\n            event: message_constants_1.RPC_ACTIONS.RESPONSE_TIMEOUT,\n            duration: this.options.rpcResponseTimeout,\n            callback: this.onTimeout\n        });\n        this.services.connection.sendMessage(message);\n    }\n    /**\n     * Called once an ack message is received from the server\n     */\n    RPC.prototype.accept = function () {\n        this.services.timeoutRegistry.clear(this.acceptTimeout);\n    };\n    /**\n     * Called once a response message is received from the server.\n     */\n    RPC.prototype.respond = function (data) {\n        this.response(null, data);\n        this.complete();\n    };\n    /**\n     * Called once an error is received from the server.\n     */\n    RPC.prototype.error = function (data) {\n        this.response(data);\n        this.complete();\n    };\n    /**\n     * Callback for error messages received from the server. Once\n     * an error is received the request is considered completed. Even\n     * if a response arrives later on it will be ignored / cause an\n     * UNSOLICITED_MESSAGE error\n     */\n    RPC.prototype.onTimeout = function (event, message) {\n        this.response(message_constants_1.RPC_ACTIONS[event]);\n        this.complete();\n    };\n    /**\n     * Called after either an error or a response\n     * was received\n    */\n    RPC.prototype.complete = function () {\n        this.services.timeoutRegistry.clear(this.acceptTimeout);\n        this.services.timeoutRegistry.clear(this.responseTimeout);\n    };\n    return RPC;\n}());\nexports.RPC = RPC;\n\n\n//# sourceURL=webpack://deepstream/./src/rpc/rpc.ts?')},"./src/storage/indexdb-storage-service.ts":function(module,exports,__webpack_require__){"use strict";eval('\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar Operation;\n(function (Operation) {\n    Operation[Operation["GET"] = 0] = "GET";\n    Operation[Operation["SET"] = 1] = "SET";\n    Operation[Operation["DELETE"] = 2] = "DELETE";\n})(Operation || (Operation = {}));\nvar Storage = /** @class */ (function () {\n    function Storage(options) {\n        var _this = this;\n        this.options = options;\n        this.isReady = false;\n        this.queuedRequests = new Map();\n        this.flushTimeout = null;\n        if (typeof indexedDB === \'undefined\' || indexedDB === null) {\n            throw new Error(\'IndexDB currently not supported when deepstream in node\');\n        }\n        this.flush = this.flush.bind(this);\n        var request = indexedDB.open(options.indexdb.storageDatabaseName, options.indexdb.dbVersion);\n        request.onerror = function (event) {\n            // TODO: Workflow for lack of permissions to use indexDB\n        };\n        request.onsuccess = function (event) {\n            _this.db = event.target.result;\n            _this.onReady();\n        };\n        request.onupgradeneeded = function () {\n            var db = request.result;\n            if (options.indexdb.objectStoreNames.indexOf(options.indexdb.defaultObjectStoreName) === -1) {\n                options.indexdb.objectStoreNames.push(options.indexdb.defaultObjectStoreName);\n            }\n            options.indexdb.objectStoreNames.forEach(function (objectStoreName) {\n                if (!db.objectStoreNames.contains(objectStoreName)) {\n                    db.createObjectStore(objectStoreName, { keyPath: \'name\' });\n                }\n            });\n        };\n    }\n    Storage.prototype.get = function (recordName, callback) {\n        this.insertRequest({ recordName: recordName, callback: callback, operation: Operation.GET });\n    };\n    Storage.prototype.set = function (recordName, version, data, callback) {\n        this.insertRequest({ recordName: recordName, version: version, callback: callback, data: data, operation: Operation.SET });\n    };\n    Storage.prototype.delete = function (recordName, callback) {\n        this.insertRequest({ recordName: recordName, callback: callback, operation: Operation.DELETE });\n    };\n    Storage.prototype.registerFlush = function () {\n        if (this.isReady && !this.flushTimeout) {\n            this.flushTimeout = setTimeout(this.flush, this.options.indexdb.flushTimeout);\n        }\n    };\n    Storage.prototype.flush = function () {\n        var e_1, _a;\n        var transaction = this.db.transaction(this.queuedRequests.keys(), \'readwrite\');\n        var _loop_1 = function (key, queuedRequests) {\n            var objectStore = transaction.objectStore(key);\n            queuedRequests.forEach(function (_a) {\n                var operation = _a.operation, recordName = _a.recordName, version = _a.version, data = _a.data, callback = _a.callback;\n                switch (operation) {\n                    case Operation.GET: {\n                        var request_1 = objectStore.get(recordName);\n                        // The api doesn\'t support get errors yet!\n                        request_1.onerror = function (event) {\n                            throw new Error("Requesting record " + recordName + " failed");\n                        };\n                        request_1.onsuccess = function () {\n                            if (request_1.result) {\n                                callback(request_1.result.name, request_1.result.version, request_1.result.data);\n                            }\n                            else {\n                                callback(recordName, -1, null);\n                            }\n                        };\n                        break;\n                    }\n                    case Operation.DELETE: {\n                        var request = objectStore.delete(recordName);\n                        request.onsuccess = function () { return callback(null); };\n                        request.onerror = function (event) { return callback(event.errorCode); };\n                        break;\n                    }\n                    case Operation.SET: {\n                        var request = objectStore.put({ name: recordName, version: version, data: data });\n                        request.onsuccess = function () { return callback(null); };\n                        request.onerror = function (event) { return callback(event.errorCode); };\n                        break;\n                    }\n                }\n            });\n        };\n        try {\n            for (var _b = __values(this.queuedRequests), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _d = __read(_c.value, 2), key = _d[0], queuedRequests = _d[1];\n                _loop_1(key, queuedRequests);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        this.queuedRequests.clear();\n        this.flushTimeout = null;\n    };\n    Storage.prototype.onReady = function () {\n        this.isReady = true;\n        this.flush();\n    };\n    Storage.prototype.insertRequest = function (request) {\n        var firstSlashIndex = request.recordName.indexOf(\'/\');\n        var objectStoreName;\n        if (firstSlashIndex > -1) {\n            objectStoreName = request.recordName.substring(0, firstSlashIndex);\n            if (this.options.indexdb.objectStoreNames.indexOf(objectStoreName) === -1) {\n                console.error("Object store names need to be predefined, missing " + objectStoreName + ". Using default objectStore instead.");\n                objectStoreName = this.options.indexdb.defaultObjectStoreName;\n            }\n            else {\n                request.recordName = request.recordName.substring(firstSlashIndex + 1, request.recordName.length);\n            }\n        }\n        else {\n            objectStoreName = this.options.indexdb.defaultObjectStoreName;\n        }\n        var requests = this.queuedRequests.get(objectStoreName);\n        if (requests === undefined) {\n            this.queuedRequests.set(objectStoreName, [request]);\n        }\n        else {\n            requests.push(request);\n        }\n        this.registerFlush();\n    };\n    return Storage;\n}());\nexports.Storage = Storage;\n\n\n//# sourceURL=webpack://deepstream/./src/storage/indexdb-storage-service.ts?')},"./src/storage/noop-storage-service.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar NoopStorage = /** @class */ (function () {\n    function NoopStorage() {\n        this.isReady = true;\n    }\n    NoopStorage.prototype.get = function (recordName, callback) {\n        setTimeout(callback.bind(this, recordName, -1, null), 0);\n    };\n    NoopStorage.prototype.set = function (recordName, version, data, callback) {\n        setTimeout(callback, 0);\n    };\n    NoopStorage.prototype.delete = function (recordName, callback) {\n        setTimeout(callback, 0);\n    };\n    return NoopStorage;\n}());\nexports.NoopStorage = NoopStorage;\n\n\n//# sourceURL=webpack://deepstream/./src/storage/noop-storage-service.ts?')},"./src/util/bulk-subscription-service.ts":function(module,exports,__webpack_require__){"use strict";eval('\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar BulkSubscriptionService = /** @class */ (function () {\n    function BulkSubscriptionService(services, subscriptionInterval, topic, subscribeBulkAction, subscribeOriginalAction, unsubscribeBulkAction, unsubscribeOriginalAction, onSubscriptionSent) {\n        if (onSubscriptionSent === void 0) { onSubscriptionSent = (function () { }); }\n        this.services = services;\n        this.subscriptionInterval = subscriptionInterval;\n        this.topic = topic;\n        this.subscribeBulkAction = subscribeBulkAction;\n        this.subscribeOriginalAction = subscribeOriginalAction;\n        this.unsubscribeBulkAction = unsubscribeBulkAction;\n        this.unsubscribeOriginalAction = unsubscribeOriginalAction;\n        this.onSubscriptionSent = onSubscriptionSent;\n        this.subscribeNames = new Set();\n        this.unsubscribeNames = new Set();\n        this.timerRef = -1;\n        this.correlationId = 0;\n        this.services.connection.onLost(this.onLost.bind(this));\n    }\n    BulkSubscriptionService.prototype.subscribe = function (name) {\n        if (this.subscriptionInterval > 0 || !this.subscribeOriginalAction) {\n            if (this.unsubscribeNames.has(name)) {\n                this.unsubscribeNames.delete(name);\n            }\n            else {\n                this.subscribeNames.add(name);\n                this.registerFlush();\n            }\n            return;\n        }\n        var message = {\n            topic: this.topic,\n            action: this.subscribeOriginalAction,\n            name: name\n        };\n        this.services.connection.sendMessage(message);\n        this.onSubscriptionSent(message);\n    };\n    BulkSubscriptionService.prototype.subscribeList = function (users) {\n        users.forEach(this.subscribe.bind(this));\n    };\n    BulkSubscriptionService.prototype.unsubscribe = function (name) {\n        if (this.subscriptionInterval > 0 || !this.unsubscribeOriginalAction) {\n            if (this.subscribeNames.has(name)) {\n                this.subscribeNames.delete(name);\n            }\n            else {\n                this.unsubscribeNames.add(name);\n                this.registerFlush();\n            }\n            return;\n        }\n        var message = {\n            topic: this.topic,\n            action: this.unsubscribeOriginalAction,\n            name: name\n        };\n        this.services.connection.sendMessage(message);\n        this.onSubscriptionSent(message);\n    };\n    BulkSubscriptionService.prototype.unsubscribeList = function (users) {\n        users.forEach(this.unsubscribe.bind(this));\n    };\n    BulkSubscriptionService.prototype.registerFlush = function () {\n        if (!this.services.timerRegistry.has(this.timerRef)) {\n            this.timerRef = this.services.timerRegistry.add({\n                callback: this.sendMessages,\n                context: this,\n                duration: this.subscriptionInterval\n            });\n        }\n    };\n    BulkSubscriptionService.prototype.sendMessages = function () {\n        if (!this.services.connection.isConnected) {\n            this.onLost();\n            return;\n        }\n        if (this.subscribeNames.size > 0) {\n            var message = {\n                topic: this.topic,\n                action: this.subscribeBulkAction,\n                names: __spread(this.subscribeNames),\n                correlationId: (this.correlationId++).toString()\n            };\n            this.services.connection.sendMessage(message);\n            this.onSubscriptionSent(message);\n            this.subscribeNames.clear();\n        }\n        if (this.unsubscribeNames.size > 0) {\n            var message = {\n                topic: this.topic,\n                action: this.unsubscribeBulkAction,\n                names: __spread(this.unsubscribeNames),\n                correlationId: (this.correlationId++).toString()\n            };\n            this.services.connection.sendMessage(message);\n            this.onSubscriptionSent(message);\n            this.unsubscribeNames.clear();\n        }\n    };\n    BulkSubscriptionService.prototype.onLost = function () {\n        this.services.timerRegistry.remove(this.timerRef);\n        this.subscribeNames.clear();\n        this.unsubscribeNames.clear();\n    };\n    return BulkSubscriptionService;\n}());\nexports.BulkSubscriptionService = BulkSubscriptionService;\n\n\n//# sourceURL=webpack://deepstream/./src/util/bulk-subscription-service.ts?')},"./src/util/listener.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nvar constants_1 = __webpack_require__(/*! ../../src/constants */ \"./src/constants.ts\");\nvar Listener = /** @class */ (function () {\n    function Listener(topic, services) {\n        this.topic = topic;\n        this.services = services;\n        this.listeners = new Map();\n        this.stopCallbacks = new Map();\n        if (topic === message_constants_1.TOPIC.RECORD) {\n            this.actions = message_constants_1.RECORD_ACTIONS;\n        }\n        else if (topic === message_constants_1.TOPIC.EVENT) {\n            this.actions = message_constants_1.EVENT_ACTIONS;\n        }\n        this.services.connection.onLost(this.onConnectionLost.bind(this));\n        this.services.connection.onReestablished(this.onConnectionReestablished.bind(this));\n    }\n    Listener.prototype.listen = function (pattern, callback) {\n        if (typeof pattern !== 'string' || pattern.length === 0) {\n            throw new Error('invalid argument pattern');\n        }\n        if (typeof callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        if (this.listeners.has(pattern)) {\n            this.services.logger.warn({\n                topic: this.topic,\n                action: constants_1.EVENT.LISTENER_EXISTS,\n                name: pattern\n            });\n            return;\n        }\n        this.listeners.set(pattern, callback);\n        this.sendListen(pattern);\n    };\n    Listener.prototype.unlisten = function (pattern) {\n        if (typeof pattern !== 'string' || pattern.length === 0) {\n            throw new Error('invalid argument pattern');\n        }\n        if (!this.listeners.has(pattern)) {\n            this.services.logger.warn({\n                topic: this.topic,\n                action: constants_1.EVENT.NOT_LISTENING,\n                name: pattern\n            });\n            return;\n        }\n        this.listeners.delete(pattern);\n        this.sendUnlisten(pattern);\n    };\n    /*\n   * Accepting a listener request informs deepstream that the current provider is willing to\n   * provide the record or event matching the subscriptionName . This will establish the current\n   * provider as the only publisher for the actual subscription with the deepstream cluster.\n   * Either accept or reject needs to be called by the listener\n   */\n    Listener.prototype.accept = function (pattern, subscription) {\n        this.services.connection.sendMessage({\n            topic: this.topic,\n            action: this.actions.LISTEN_ACCEPT,\n            name: pattern,\n            subscription: subscription\n        });\n    };\n    /*\n    * Rejecting a listener request informs deepstream that the current provider is not willing\n    * to provide the record or event matching the subscriptionName . This will result in deepstream\n    * requesting another provider to do so instead. If no other provider accepts or exists, the\n    * resource will remain unprovided.\n    * Either accept or reject needs to be called by the listener\n    */\n    Listener.prototype.reject = function (pattern, subscription) {\n        this.services.connection.sendMessage({\n            topic: this.topic,\n            action: this.actions.LISTEN_REJECT,\n            name: pattern,\n            subscription: subscription\n        });\n    };\n    Listener.prototype.stop = function (subscription, callback) {\n        this.stopCallbacks.set(subscription, callback);\n    };\n    Listener.prototype.handle = function (message) {\n        if (message.isAck) {\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === this.actions.SUBSCRIPTION_FOR_PATTERN_FOUND) {\n            var listener = this.listeners.get(message.name);\n            if (listener) {\n                listener(message.subscription, {\n                    accept: this.accept.bind(this, message.name, message.subscription),\n                    reject: this.reject.bind(this, message.name, message.subscription),\n                    onStop: this.stop.bind(this, message.subscription)\n                });\n            }\n            return;\n        }\n        if (message.action === this.actions.SUBSCRIPTION_FOR_PATTERN_REMOVED) {\n            var stopCallback = this.stopCallbacks.get(message.subscription);\n            if (stopCallback) {\n                stopCallback(message.subscription);\n                this.stopCallbacks.delete(message.subscription);\n            }\n            return;\n        }\n        this.services.logger.error(message, constants_1.EVENT.UNSOLICITED_MESSAGE);\n    };\n    Listener.prototype.onConnectionLost = function () {\n        this.stopCallbacks.forEach(function (callback, subscription) {\n            callback(subscription);\n        });\n        this.stopCallbacks.clear();\n    };\n    Listener.prototype.onConnectionReestablished = function () {\n        var _this = this;\n        this.listeners.forEach(function (callback, pattern) {\n            _this.sendListen(pattern);\n        });\n    };\n    /*\n    * Sends a C.ACTIONS.LISTEN to deepstream.\n    */\n    Listener.prototype.sendListen = function (pattern) {\n        var message = {\n            topic: this.topic,\n            action: this.actions.LISTEN,\n            name: pattern\n        };\n        this.services.timeoutRegistry.add({ message: message });\n        this.services.connection.sendMessage(message);\n    };\n    Listener.prototype.sendUnlisten = function (pattern) {\n        var message = {\n            topic: this.topic,\n            action: this.actions.UNLISTEN,\n            name: pattern\n        };\n        this.services.timeoutRegistry.add({ message: message });\n        this.services.connection.sendMessage(message);\n    };\n    return Listener;\n}());\nexports.Listener = Listener;\n\n\n//# sourceURL=webpack://deepstream/./src/util/listener.ts?")},"./src/util/logger.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\nvar message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nfunction isEvent(action) {\n    // @ts-ignore\n    return constants_1.EVENT[action] !== undefined;\n}\nvar Logger = /** @class */ (function () {\n    function Logger(emitter) {\n        this.emitter = emitter;\n    }\n    Logger.prototype.warn = function (message, event, meta) {\n        var warnMessage = "Warning: " + message_constants_1.TOPIC[message.topic];\n        var action = message.action;\n        if (action) {\n            warnMessage += " (" + message_constants_1.ACTIONS[message.topic][action] + ")";\n        }\n        if (event) {\n            warnMessage += ": " + constants_1.EVENT[event];\n        }\n        if (meta) {\n            warnMessage += " \\u2013 " + (typeof meta === \'string\' ? meta : JSON.stringify(meta));\n        }\n        // tslint:disable-next-line:no-console\n        console.warn(warnMessage);\n    };\n    Logger.prototype.error = function (message, event, meta) {\n        if (isEvent(event)) {\n            if (event === constants_1.EVENT.IS_CLOSED) {\n                this.emitter.emit(\'error\', meta, constants_1.EVENT[event], message_constants_1.TOPIC[message_constants_1.TOPIC.CONNECTION]);\n            }\n            else if (event === constants_1.EVENT.CONNECTION_ERROR) {\n                this.emitter.emit(\'error\', meta, constants_1.EVENT[event], message_constants_1.TOPIC[message_constants_1.TOPIC.CONNECTION]);\n            }\n        }\n        else {\n            var action = event ? event : message.action;\n            this.emitter.emit(\'error\', meta, message_constants_1.ACTIONS[message.topic][action], message_constants_1.TOPIC[message.topic]);\n        }\n    };\n    return Logger;\n}());\nexports.Logger = Logger;\n\n\n//# sourceURL=webpack://deepstream/./src/util/logger.ts?')},"./src/util/state-machine.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar StateMachine = /** @class */ (function () {\n    function StateMachine(logger, stateMachine) {\n        this.stateMachine = stateMachine;\n        this.inEndState = false;\n        this.transitions = stateMachine.transitions;\n        this.state = stateMachine.init;\n        this.context = stateMachine.context;\n        this.history = [{ oldState: \'-\', newState: this.state, transitionName: \'-\' }];\n    }\n    /**\n     * Try to perform a state change\n     */\n    StateMachine.prototype.transition = function (transitionName) {\n        var transition;\n        for (var i = 0; i < this.transitions.length; i++) {\n            transition = this.transitions[i];\n            if (transitionName === transition.name && (this.state === transition.from || transition.from === undefined)) {\n                this.history.push({ oldState: this.state, transitionName: transitionName, newState: transition.to });\n                var oldState = this.state;\n                this.state = transition.to;\n                if (this.stateMachine.onStateChanged) {\n                    this.stateMachine.onStateChanged.call(this.context, this.state, oldState);\n                }\n                if (transition.handler) {\n                    transition.handler.call(this.context);\n                }\n                return;\n            }\n        }\n        var details = JSON.stringify({ transition: transitionName, state: this.state });\n        var debugHistory = this.history.reduce(function (result, entry) {\n            return result += "\\n\\tFrom " + entry.oldState + " to " + entry.newState + " via " + entry.transitionName;\n        }, \'\');\n        throw new Error("Invalid state transition.\\nDetails: " + details + " \\nHistory: " + debugHistory);\n    };\n    return StateMachine;\n}());\nexports.StateMachine = StateMachine;\n\n\n//# sourceURL=webpack://deepstream/./src/util/state-machine.ts?')},"./src/util/timeout-registry.ts":function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\nvar utils_1 = __webpack_require__(/*! ../../binary-protocol/src/utils */ "./binary-protocol/src/utils.ts");\nvar EventEmitter = __webpack_require__(/*! component-emitter2 */ "./node_modules/component-emitter2/index.js");\n/**\n * Subscriptions to events are in a pending state until deepstream acknowledges\n * them. This is a pattern that\'s used by numerour classes. This registry aims\n * to centralise the functionality necessary to keep track of subscriptions and\n * their respective timeouts.\n */\nvar TimeoutRegistry = /** @class */ (function (_super) {\n    __extends(TimeoutRegistry, _super);\n    function TimeoutRegistry(services, options) {\n        var _this = _super.call(this) || this;\n        _this.services = services;\n        _this.options = options;\n        _this.register = new Map();\n        return _this;\n    }\n    /**\n     * Add an entry\n     */\n    TimeoutRegistry.prototype.add = function (timeout) {\n        if (timeout.duration === undefined) {\n            timeout.duration = this.options.subscriptionTimeout;\n        }\n        if (timeout.event === undefined) {\n            timeout.event = constants_1.EVENT.ACK_TIMEOUT;\n        }\n        /*\n        if (timeout.duration < 1) {\n          should we throw an error?\n          return -1\n        }\n        */\n        if (!this.services.connection.isConnected) {\n            return null;\n        }\n        this.remove(timeout.message);\n        var internalTimeout = {\n            timerId: -1,\n            uniqueName: this.getUniqueName(timeout.message),\n            // event: timeout.event,\n            timeout: timeout\n        };\n        internalTimeout.timerId = this.services.timerRegistry.add({\n            context: this,\n            callback: this.onTimeout,\n            duration: timeout.duration,\n            data: internalTimeout\n        });\n        this.register.set(internalTimeout.uniqueName, internalTimeout);\n        return internalTimeout.uniqueName;\n    };\n    /**\n     * Remove an entry\n     */\n    TimeoutRegistry.prototype.remove = function (message) {\n        var requestMsg;\n        var action = utils_1.RESPONSE_TO_REQUEST[message.topic][message.action];\n        if (!action) {\n            requestMsg = message;\n        }\n        else {\n            requestMsg = __assign({}, message, { action: action });\n        }\n        var uniqueName = this.getUniqueName(requestMsg);\n        this.clear(uniqueName);\n    };\n    /**\n     * Processes an incoming ACK-message and removes the corresponding subscription\n     */\n    TimeoutRegistry.prototype.clear = function (uniqueName) {\n        var timeout = this.register.get(uniqueName);\n        if (timeout) {\n            this.register.delete(uniqueName);\n            this.services.timerRegistry.remove(timeout.timerId);\n        }\n    };\n    /**\n     * Will be invoked if the timeout has occured before the ack message was received\n     */\n    TimeoutRegistry.prototype.onTimeout = function (internalTimeout) {\n        this.register.delete(internalTimeout.uniqueName);\n        var timeout = internalTimeout.timeout;\n        if (timeout.callback) {\n            timeout.callback(timeout.event, timeout.message);\n        }\n        else {\n            this.services.logger.warn(timeout.message, timeout.event);\n        }\n    };\n    /**\n     * Returns a unique name from the timeout\n     */\n    TimeoutRegistry.prototype.getUniqueName = function (message) {\n        var action = message.originalAction || message.action;\n        var name = "" + message.topic + action + "_";\n        if (message.correlationId) {\n            name += message.correlationId;\n        }\n        else if (message.name) {\n            name += message.name;\n        }\n        return name;\n    };\n    /**\n     * Remote all timeouts when connection disconnects\n     */\n    TimeoutRegistry.prototype.onConnectionLost = function () {\n        var e_1, _a;\n        try {\n            for (var _b = __values(this.register), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _d = __read(_c.value, 2), uniqueName = _d[0], timeout = _d[1];\n                this.services.timerRegistry.remove(timeout.timerId);\n                this.register.delete(uniqueName);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    return TimeoutRegistry;\n}(EventEmitter));\nexports.TimeoutRegistry = TimeoutRegistry;\n\n\n//# sourceURL=webpack://deepstream/./src/util/timeout-registry.ts?')},"./src/util/timer-registry.ts":function(module,exports,__webpack_require__){"use strict";eval('\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i["return"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar TimerRegistry = /** @class */ (function () {\n    function TimerRegistry(timerResolution) {\n        this.registry = new Map();\n        this.timerIdCounter = 0;\n        setInterval(this.triggerTimeouts.bind(this), timerResolution);\n    }\n    TimerRegistry.prototype.triggerTimeouts = function () {\n        var e_1, _a;\n        var now = Date.now();\n        try {\n            for (var _b = __values(this.registry), _c = _b.next(); !_c.done; _c = _b.next()) {\n                var _d = __read(_c.value, 2), timerId = _d[0], timeout = _d[1];\n                if (now - timeout.created > timeout.duration) {\n                    timeout.callback.call(timeout.context, timeout.data);\n                    this.registry.delete(timerId);\n                }\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n    };\n    TimerRegistry.prototype.has = function (timerId) {\n        return this.registry.has(timerId);\n    };\n    TimerRegistry.prototype.add = function (timeout) {\n        this.timerIdCounter++;\n        timeout.created = Date.now();\n        this.registry.set(this.timerIdCounter, timeout);\n        return this.timerIdCounter;\n    };\n    TimerRegistry.prototype.remove = function (timerId) {\n        return this.registry.delete(timerId);\n    };\n    TimerRegistry.prototype.requestIdleCallback = function (callback) {\n        setTimeout(callback, 0);\n    };\n    return TimerRegistry;\n}());\nexports.TimerRegistry = TimerRegistry;\n\n\n//# sourceURL=webpack://deepstream/./src/util/timer-registry.ts?')},"./src/util/utils.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar UniformResourceLocator;\nif (typeof URL === 'undefined') {\n    UniformResourceLocator = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'url'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())).URL;\n}\nelse {\n    UniformResourceLocator = URL;\n}\n/**\n * Compares two objects for deep (recoursive) equality\n *\n * This used to be a significantly more complex custom implementation,\n * but JSON.stringify has gotten so fast that it now outperforms the custom\n * way by a factor of 1.5 to 3.\n *\n * In IE11 / Edge the custom implementation is still slightly faster, but for\n * consistencies sake and the upsides of leaving edge-case handling to the native\n * browser / node implementation we'll go for JSON.stringify from here on.\n *\n * Please find performance test results here\n *\n * http://jsperf.com/deep-equals-code-vs-json\n */\nexports.deepEquals = function (objA, objB) {\n    if (objA === objB) {\n        return true;\n    }\n    else if (typeof objA !== 'object' || typeof objB !== 'object') {\n        return false;\n    }\n    return JSON.stringify(objA) === JSON.stringify(objB);\n};\n/**\n * Similar to deepEquals above, tests have shown that JSON stringify outperforms any attempt of\n * a code based implementation by 50% - 100% whilst also handling edge-cases and keeping\n * implementation complexity low.\n *\n * If ES6/7 ever decides to implement deep copying natively (what happened to Object.clone?\n * that was briefly a thing...), let's switch it for the native implementation. For now though,\n * even Object.assign({}, obj) only provides a shallow copy.\n *\n * Please find performance test results backing these statements here:\n *\n * http://jsperf.com/object-deep-copy-assign\n */\nexports.deepCopy = function (obj) {\n    if (typeof obj === 'object') {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    return obj;\n};\n/**\n * Copy the top level of items, but do not copy its items recourisvely. This\n * is much quicker than deepCopy does not guarantee the object items are new/unique.\n * Mainly used to change the reference to the actual object itself, but not its children.\n */\nexports.shallowCopy = function (obj) {\n    if (Array.isArray(obj)) {\n        return obj.slice(0);\n    }\n    else if (typeof obj === 'object') {\n        var copy = Object.create(null);\n        var props = Object.keys(obj);\n        for (var i = 0; i < props.length; i++) {\n            copy[props[i]] = obj[props[i]];\n        }\n        return copy;\n    }\n    return obj;\n};\n/**\n * Used to see if a protocol is specified within the url\n * @type {RegExp}\n */\nvar hasUrlProtocol = /^wss:|^ws:|^\\/\\//;\n/**\n * Used to see if the protocol contains any unsupported protocols\n * @type {RegExp}\n */\nvar unsupportedProtocol = /^http:|^https:/;\n/**\n * Take the url passed when creating the client and ensure the correct\n * protocol is provided\n * @param  {String} url Url passed in by client\n * @return {String} Url with supported protocol\n */\nexports.parseUrl = function (initialURl, defaultPath) {\n    var url = initialURl;\n    if (unsupportedProtocol.test(url)) {\n        throw new Error('Only ws and wss are supported');\n    }\n    if (!hasUrlProtocol.test(url)) {\n        url = \"ws://\" + url;\n    }\n    else if (url.indexOf('//') === 0) {\n        url = \"ws:\" + url;\n    }\n    var serverUrl = new UniformResourceLocator(url);\n    if (!serverUrl.host) {\n        throw new Error('invalid url, missing host');\n    }\n    serverUrl.protocol = serverUrl.protocol ? serverUrl.protocol : 'ws:';\n    serverUrl.pathname = serverUrl.pathname && serverUrl.pathname !== '/' ? serverUrl.pathname : defaultPath;\n    return serverUrl.href;\n};\n/**\n* Returns a random string. The first block of characters\n* is a timestamp, in order to allow databases to optimize for semi-\n* sequentuel numberings\n*/\nexports.getUid = function () {\n    var timestamp = (new Date()).getTime().toString(36);\n    var randomString = (Math.random() * 10000000000000000).toString(36).replace('.', '');\n    return timestamp + \"-\" + randomString;\n};\n/**\n * Creates a map based on the types of the provided arguments\n */\nexports.normalizeSetArguments = function (args, startIndex) {\n    if (startIndex === void 0) { startIndex = 0; }\n    var result;\n    var isRootData = function (data) { return data !== undefined && typeof data === 'object'; };\n    var isNestedData = function (data) { return typeof data !== 'function'; };\n    var isPath = function (path) { return path !== undefined && typeof path === 'string'; };\n    var isCallback = function (callback) { return typeof callback === 'function'; };\n    if (args.length === startIndex + 1) {\n        result = {\n            path: undefined,\n            data: isRootData(args[startIndex]) ? args[startIndex] : undefined,\n            callback: undefined\n        };\n    }\n    if (args.length === startIndex + 2) {\n        result = { path: undefined, data: undefined, callback: undefined };\n        if (!isCallback(args[startIndex]) && isNestedData(args[startIndex])) {\n            result.path = isPath(args[startIndex]) ? args[startIndex] : undefined;\n        }\n        if (isPath(args[startIndex])) {\n            result.data = isNestedData(args[startIndex + 1]) ? args[startIndex + 1] : undefined;\n        }\n        else {\n            result.data = isRootData(args[startIndex]) ? args[startIndex] : undefined;\n        }\n        if (!isPath(args[startIndex])) {\n            result.callback = isCallback(args[startIndex + 1]) ? args[startIndex + 1] : false;\n        }\n    }\n    if (args.length === startIndex + 3) {\n        result = {\n            path: isPath(args[startIndex]) ? args[startIndex] : undefined,\n            data: isNestedData(args[startIndex + 1]) ? args[startIndex + 1] : undefined,\n            callback: isCallback(args[startIndex + 2]) ? args[startIndex + 2] : undefined\n        };\n    }\n    if (result) {\n        if (result.path !== undefined && result.path.length === 0 ||\n            (result.path === undefined && !result.data)) {\n            throw Error('Invalid set path argument');\n        }\n        if (result.data === undefined && result.path === undefined) {\n            throw Error('Invalid set data argument');\n        }\n        if (result.callback !== undefined && result.callback === false ||\n            result.callback === undefined && args.length === startIndex + 3) {\n            throw Error('Invalid set callback argument');\n        }\n        return result;\n    }\n    throw Error('Invalid set arguments');\n};\n/**\n * Creates a map based on the types of the provided arguments\n */\nexports.normalizeArguments = function (args) {\n    // If arguments is already a map of normalized parameters\n    // (e.g. when called by AnonymousRecord), just return it.\n    if (args.length === 1 && typeof args[0] === 'object') {\n        return args[0];\n    }\n    var result = Object.create(null);\n    for (var i = 0; i < args.length; i++) {\n        if (typeof args[i] === 'string') {\n            result.path = args[i];\n        }\n        else if (typeof args[i] === 'function') {\n            result.callback = args[i];\n        }\n        else if (typeof args[i] === 'boolean') {\n            result.triggerNow = args[i];\n        }\n    }\n    return result;\n};\n\n\n//# sourceURL=webpack://deepstream/./src/util/utils.ts?")},0:function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__(/*! ./src/deepstream.ts */"./src/deepstream.ts");\n\n\n//# sourceURL=webpack://deepstream/multi_./src/deepstream.ts?')}},e={},f.m=d,f.c=e,f.d=function(e,n,t){f.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},f.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},f.t=function(n,e){if(1&e&&(n=f(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(f.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var s in n)f.d(t,s,function(e){return n[e]}.bind(null,s));return t},f.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return f.d(n,"a",n),n},f.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},f.p="",f(f.s=0);function f(n){if(e[n])return e[n].exports;var t=e[n]={i:n,l:!1,exports:{}};return d[n].call(t.exports,t,t.exports,f),t.l=!0,t.exports}var d,e});