"use strict";var __awaiter=this&&this.__awaiter||function(e,t,s,c){return new(s||(s=Promise))(function(n,o){function a(e){try{i(c.next(e))}catch(e){o(e)}}function r(e){try{i(c.throw(e))}catch(e){o(e)}}function i(e){e.done?n(e.value):new s(function(t){t(e.value)}).then(a,r)}i((c=c.apply(e,t||[])).next())})};Object.defineProperty(exports,"__esModule",{value:!0});const chai_1=require("chai"),mocks_1=require("../test/mocks"),message_constants_1=require("../../binary-protocol/src/message-constants"),client_options_1=require("../client-options"),rpc_response_1=require("./rpc-response"),bluebird_1=require("bluebird");describe("RPC response",()=>{let e,t;const s="myRPC";beforeEach(()=>{e=mocks_1.getServicesMock(),(t=new rpc_response_1.RPCResponse({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST,name:s,correlationId:"correlationId"},client_options_1.DefaultOptions,e)).autoAccept=!1}),afterEach(()=>{e.connectionMock.verify()}),it("doesn't accept automatically when autoAccept == false",()=>__awaiter(this,void 0,void 0,function*(){e.connectionMock.expects("sendMessage").never(),yield bluebird_1.Promise.delay(2)})),it("sends an accept message automatically when autoAccept == true ",()=>__awaiter(this,void 0,void 0,function*(){e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:s,correlationId:"correlationId"}),t.autoAccept=!0,yield bluebird_1.Promise.delay(2)})),it("sends an accept message manually",()=>{e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:s,correlationId:"correlationId"}),t.accept()}),it("sends the response message but accepts the rpc before when it is not accepted yet",()=>{const c={foo:"bar"};e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:s,correlationId:"correlationId"}),e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.RESPONSE,name:s,correlationId:"correlationId",parsedData:c}),t.send(c)}),it("throws when trying to send a completed response",()=>{const s={foo:"bar"};e.connectionMock.expects("sendMessage").twice(),t.send(s),chai_1.expect(t.send.bind(t,s)).to.throw("Rpc myRPC already completed")}),it("doesn't send multiple accept messages",()=>{e.connectionMock.expects("sendMessage").once(),t.accept(),t.accept()}),it("sends reject message",()=>{e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REJECT,name:s,correlationId:"correlationId"}),t.reject()}),it("doesn't send reject message twice and throws error",()=>{e.connectionMock.expects("sendMessage").once(),t.reject(),chai_1.expect(t.reject.bind(t)).to.throw("Rpc myRPC already completed")}),it("sends error message",()=>{e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST_ERROR,name:s,correlationId:"correlationId",parsedData:"error"}),t.error("error")}),it("doesn't send error message twice and throws error",()=>{e.connectionMock.expects("sendMessage").once(),t.error("error"),chai_1.expect(t.error.bind(t,"error")).to.throw("Rpc myRPC already completed")})});