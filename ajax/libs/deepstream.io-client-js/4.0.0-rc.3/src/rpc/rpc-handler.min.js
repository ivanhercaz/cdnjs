"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const message_constants_1=require("../../binary-protocol/src/message-constants"),constants_1=require("../constants"),rpc_1=require("../rpc/rpc"),rpc_response_1=require("../rpc/rpc-response"),utils_1=require("../util/utils");class RPCHandler{constructor(e,s){this.services=e,this.options=s,this.rpcs=new Map,this.providers=new Map,this.limboQueue=[],this.services.connection.registerHandler(message_constants_1.TOPIC.RPC,this.handle.bind(this)),this.services.connection.onReestablished(this.onConnectionReestablished.bind(this)),this.services.connection.onExitLimbo(this.onExitLimbo.bind(this)),this.services.connection.onLost(this.onConnectionLost.bind(this))}provide(e,s){if("string"!=typeof e||0===e.length)throw new Error("invalid argument name");if(this.providers.has(e))throw new Error(`RPC ${e} already registered`);if("function"!=typeof s)throw new Error("invalid argument callback");this.providers.set(e,s),this.services.connection.isConnected&&this.sendProvide(e)}unprovide(e){if("string"!=typeof e||0===e.length)throw new Error("invalid argument name");if(this.providers.has(e)){if(this.providers.delete(e),this.services.connection.isConnected){const s={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.UNPROVIDE,name:e};return this.services.timeoutRegistry.add({message:s}),void this.services.connection.sendMessage(s)}}else this.services.logger.warn({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.NOT_PROVIDED,name:e})}make(e,s,t){if("string"!=typeof e||0===e.length)throw new Error("invalid argument name");if(t&&"function"!=typeof t)throw new Error("invalid argument callback");const i=utils_1.getUid();if(this.services.connection.isConnected)return t?void this.rpcs.set(i,new rpc_1.RPC(e,i,s,t,this.options,this.services)):new Promise((t,n)=>{this.rpcs.set(i,new rpc_1.RPC(e,i,s,(e,s)=>e?n(e):t(s),this.options,this.services))});if(this.services.connection.isInLimbo){if(!t)return new Promise((t,n)=>{this.limboQueue.push({correlationId:i,name:e,data:s,callback:(e,s)=>e?n(e):t(s)})});this.limboQueue.push({correlationId:i,name:e,data:s,callback:t})}else{if(!t)return Promise.reject(constants_1.EVENT.CLIENT_OFFLINE);t(constants_1.EVENT.CLIENT_OFFLINE)}}respondToRpc(e){const s=this.providers.get(e.name);s?s(e.parsedData,new rpc_response_1.RPCResponse(e,this.options,this.services)):this.services.connection.sendMessage({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REJECT,name:e.name,correlationId:e.correlationId})}handle(e){if(e.action===message_constants_1.RPC_ACTIONS.REQUEST)return void this.respondToRpc(e);if(e.isAck)return void this.services.timeoutRegistry.remove(e);if(e.action===message_constants_1.RPC_ACTIONS.MESSAGE_PERMISSION_ERROR||e.action===message_constants_1.RPC_ACTIONS.MESSAGE_DENIED){if(e.originalAction===message_constants_1.RPC_ACTIONS.PROVIDE||e.originalAction===message_constants_1.RPC_ACTIONS.UNPROVIDE)return this.services.timeoutRegistry.remove(e),this.providers.delete(e.name),void this.services.logger.error(e);if(e.originalAction===message_constants_1.RPC_ACTIONS.REQUEST){const s=this.getRPC(e);if(s)return s.error(message_constants_1.RPC_ACTIONS[e.action]),void this.rpcs.delete(e.correlationId)}}const s=this.getRPC(e);if(s){if(e.action===message_constants_1.RPC_ACTIONS.ACCEPT)return void s.accept();e.action===message_constants_1.RPC_ACTIONS.RESPONSE?s.respond(e.parsedData):e.action===message_constants_1.RPC_ACTIONS.REQUEST_ERROR?s.error(e.parsedData):e.action!==message_constants_1.RPC_ACTIONS.RESPONSE_TIMEOUT&&e.action!==message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER||s.error(message_constants_1.RPC_ACTIONS[e.action]),this.rpcs.delete(e.correlationId)}}getRPC(e){const s=this.rpcs.get(e.correlationId);return void 0===s&&this.services.logger.error(e,constants_1.EVENT.UNKNOWN_CORRELATION_ID),s}sendProvide(e){const s={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.PROVIDE,name:e};this.services.timeoutRegistry.add({message:s}),this.services.connection.sendMessage(s)}onConnectionReestablished(){for(const[e]of this.providers)this.sendProvide(e);for(let e=0;e<this.limboQueue.length;e++){const{correlationId:s,name:t,data:i,callback:n}=this.limboQueue[e];this.rpcs.set(s,new rpc_1.RPC(t,s,i,n,this.options,this.services))}this.limboQueue=[]}onExitLimbo(){for(let e=0;e<this.limboQueue.length;e++)this.limboQueue[e].callback(constants_1.EVENT.CLIENT_OFFLINE);this.limboQueue=[]}onConnectionLost(){this.rpcs.forEach(e=>{e.error(constants_1.EVENT.CLIENT_OFFLINE)}),this.rpcs.clear()}}exports.RPCHandler=RPCHandler;