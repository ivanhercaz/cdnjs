"use strict";var __awaiter=this&&this.__awaiter||function(e,s,n,t){return new(n||(n=Promise))(function(a,o){function i(e){try{r(t.next(e))}catch(e){o(e)}}function c(e){try{r(t.throw(e))}catch(e){o(e)}}function r(e){e.done?a(e.value):new n(function(s){s(e.value)}).then(i,c)}r((t=t.apply(e,s||[])).next())})};Object.defineProperty(exports,"__esModule",{value:!0});const bluebird_1=require("bluebird"),chai_1=require("chai"),sinon=require("sinon"),mocks_1=require("../test/mocks"),constants_1=require("../constants"),message_constants_1=require("../../binary-protocol/src/message-constants"),client_options_1=require("../client-options"),rpc_handler_1=require("./rpc-handler"),rpc_response_1=require("./rpc-response"),timeout_registry_1=require("../util/timeout-registry");describe("RPC handler",()=>{let e,s,n,t,a,o;const i="myRpc",c=Object.assign({},client_options_1.DefaultOptions,{rpcAcceptTimeout:10,rpcResponseTimeout:30});beforeEach(()=>{e=mocks_1.getServicesMock(),s=new rpc_handler_1.RPCHandler(e,c),n=e.getHandle(),t=sinon.spy(),a=sinon.spy(),o={foo:"bar"}}),afterEach(()=>{e.connectionMock.verify(),e.timeoutRegistryMock.verify(),e.loggerMock.verify()}),it("validates parameters on provide, unprovide and make",()=>{chai_1.expect(s.provide.bind(s,"",()=>{})).to.throw(),chai_1.expect(s.unprovide.bind(s,"")).to.throw(),chai_1.expect(s.unprovide.bind(s)).to.throw(),chai_1.expect(s.make.bind(s,"")).to.throw(),chai_1.expect(s.make.bind(s)).to.throw()}),it("registers a provider",()=>{const n={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.PROVIDE,name:i};e.connectionMock.expects("sendMessage").once().withExactArgs(n),e.timeoutRegistryMock.expects("add").once().withExactArgs({message:n}),s.provide(i,t),sinon.assert.notCalled(t)}),it("reregisters a provider after a connection reconnection",()=>{const n={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.PROVIDE,name:i};e.connectionMock.expects("sendMessage").twice().withExactArgs(n),e.timeoutRegistryMock.expects("add").twice().withExactArgs({message:n}),s.provide(i,t),e.simulateConnectionReestablished(),sinon.assert.notCalled(t)}),it("sends rpc request message on make",()=>{e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST,name:i,parsedData:o,correlationId:sinon.match.any}),s.make(i,o,()=>{})}),it("returns promise on make when no callback is passed",()=>{e.connectionMock.expects("sendMessage").once();const n=s.make(i,o);chai_1.expect(n).to.be.a("promise")}),it("cant't make requests when client is offline",()=>__awaiter(this,void 0,void 0,function*(){const n=sinon.spy(),t=sinon.spy(),a=sinon.spy();e.connection.isConnected=!1,s.make(i,o,n),s.make(i,o).then(a).catch(t),yield bluebird_1.Promise.delay(1),sinon.assert.calledOnce(n),sinon.assert.calledWithExactly(n,constants_1.EVENT.CLIENT_OFFLINE),sinon.assert.notCalled(a),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,constants_1.EVENT.CLIENT_OFFLINE)})),it("doesn't reply rpc and sends rejection if no provider exists",()=>{e.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REJECT,name:i,correlationId:"123"}),e.timeoutRegistryMock.expects("add").never(),n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST,name:i,parsedData:o,correlationId:"123"})}),it("handles ack messages",()=>{const s={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.PROVIDE_ACK,name:i,isAck:!0};e.timeoutRegistryMock.expects("remove").once().withExactArgs(s),n(s)}),it("handles permission and message denied errors for provide and unprovide",()=>{const s=s=>{e.timeoutRegistryMock.expects("remove").once().withExactArgs(s),e.loggerMock.expects("error").once().withExactArgs(s)},t={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.MESSAGE_PERMISSION_ERROR,name:i,originalAction:message_constants_1.RPC_ACTIONS.PROVIDE},a={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.MESSAGE_PERMISSION_ERROR,name:i,originalAction:message_constants_1.RPC_ACTIONS.UNPROVIDE},o={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.MESSAGE_DENIED,name:i,originalAction:message_constants_1.RPC_ACTIONS.PROVIDE},c={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.MESSAGE_DENIED,name:i,originalAction:message_constants_1.RPC_ACTIONS.UNPROVIDE};s(t),s(a),s(o),s(c),n(t),n(a),n(o),n(c)}),it("logs unknown correlation error when handling unknown rpc response",()=>{const s={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:i,correlationId:"123abc"};e.loggerMock.expects("error").once().withExactArgs(s,constants_1.EVENT.UNKNOWN_CORRELATION_ID),n(s)}),describe("when providing",()=>{beforeEach(()=>{s.provide(i,t)}),it("doesn't register provider twice",()=>{e.connectionMock.expects("sendMessage").never(),e.timeoutRegistryMock.expects("add").never(),chai_1.expect(s.provide.bind(s,i,t)).to.throw("RPC myRpc already registered")}),it("triggers rpc provider callback in a new request",()=>{const s={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST,name:i,parsedData:o,correlationId:"123"},a=new rpc_response_1.RPCResponse(s,c,e);n(s),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,o,a)}),it("deregisters providers",()=>{const n={topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.UNPROVIDE,name:i};e.connectionMock.expects("sendMessage").once().withExactArgs(n),e.timeoutRegistryMock.expects("add").once().withExactArgs({message:n}),s.unprovide(i)}),it("doesn't send deregister provider message twice",()=>{e.connectionMock.expects("sendMessage").once(),e.timeoutRegistryMock.expects("add").once(),e.loggerMock.expects("warn").once(),s.unprovide(i),s.unprovide(i)})}),describe("when making",()=>{let t,a,r,_,l,d;beforeEach(()=>{e.timeoutRegistry=new timeout_registry_1.TimeoutRegistry(e,c),t=sinon.spy(),s.make(i,o,t),l=mocks_1.getLastMessageSent().correlationId,r=sinon.spy(),_=sinon.spy(),(a=s.make(i,o)).then(r).catch(_),d=mocks_1.getLastMessageSent().correlationId}),it("handles permission errors",()=>__awaiter(this,void 0,void 0,function*(){const e=message_constants_1.RPC_ACTIONS.MESSAGE_PERMISSION_ERROR,s=s=>n({topic:message_constants_1.TOPIC.RPC,action:e,name:i,originalAction:message_constants_1.RPC_ACTIONS.REQUEST,correlationId:s});s(l),s(d),yield bluebird_1.Promise.delay(20),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,message_constants_1.RPC_ACTIONS[e]),sinon.assert.notCalled(r),sinon.assert.calledOnce(_),sinon.assert.calledWithExactly(_,message_constants_1.RPC_ACTIONS[e])})),it("handles message denied errors",()=>__awaiter(this,void 0,void 0,function*(){const e=message_constants_1.RPC_ACTIONS.MESSAGE_DENIED,s=s=>n({topic:message_constants_1.TOPIC.RPC,action:e,name:i,originalAction:message_constants_1.RPC_ACTIONS.REQUEST,correlationId:s});s(l),s(d),yield bluebird_1.Promise.delay(20),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,message_constants_1.RPC_ACTIONS[e]),sinon.assert.notCalled(r),sinon.assert.calledOnce(_),sinon.assert.calledWithExactly(_,message_constants_1.RPC_ACTIONS[e])})),it("responds rpc with error when request is not accepted in time",()=>__awaiter(this,void 0,void 0,function*(){yield bluebird_1.Promise.delay(20),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,message_constants_1.RPC_ACTIONS[message_constants_1.RPC_ACTIONS.ACCEPT_TIMEOUT]),sinon.assert.notCalled(r),sinon.assert.calledOnce(_),sinon.assert.calledWithExactly(_,message_constants_1.RPC_ACTIONS[message_constants_1.RPC_ACTIONS.ACCEPT_TIMEOUT])})),it("handles the rpc response accepted message",()=>__awaiter(this,void 0,void 0,function*(){const e=e=>n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:i,correlationId:e});e(l),e(d),yield bluebird_1.Promise.delay(20),sinon.assert.notCalled(t),sinon.assert.notCalled(_),sinon.assert.notCalled(r)})),it("calls rpcResponse with error when response is not sent in time",()=>__awaiter(this,void 0,void 0,function*(){const e=e=>n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:i,correlationId:e});e(l),e(d),yield bluebird_1.Promise.delay(60),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,message_constants_1.RPC_ACTIONS[message_constants_1.RPC_ACTIONS.RESPONSE_TIMEOUT]),sinon.assert.notCalled(r),sinon.assert.calledOnce(_),sinon.assert.calledWithExactly(_,message_constants_1.RPC_ACTIONS[message_constants_1.RPC_ACTIONS.RESPONSE_TIMEOUT])})),it("calls rpcResponse with error when no rpc provider is returned",()=>__awaiter(this,void 0,void 0,function*(){const e=e=>n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.ACCEPT,name:i,correlationId:e});e(l),e(d),n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER,name:i,correlationId:l}),n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER,name:i,correlationId:d}),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,message_constants_1.RPC_ACTIONS[message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER]),yield bluebird_1.Promise.delay(0),sinon.assert.notCalled(r),sinon.assert.calledOnce(_),sinon.assert.calledWithExactly(_,message_constants_1.RPC_ACTIONS[message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER])})),it("handles the rpc response RESPONSE message",()=>__awaiter(this,void 0,void 0,function*(){const e=e=>n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.RESPONSE,name:i,correlationId:e,parsedData:o});e(l),e(d),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,null,o),yield bluebird_1.Promise.delay(0),sinon.assert.notCalled(_),sinon.assert.calledOnce(r),sinon.assert.calledWithExactly(r,o)})),it("doesn't call rpc response callback twice when handling response message",()=>__awaiter(this,void 0,void 0,function*(){const e=e=>n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.RESPONSE,name:i,correlationId:e,parsedData:o});e(l),e(l),e(d),e(d),yield bluebird_1.Promise.delay(60),sinon.assert.calledOnce(t),sinon.assert.notCalled(_),sinon.assert.calledOnce(r)})),it("handles the rpc response error message",()=>__awaiter(this,void 0,void 0,function*(){const e=e=>n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST_ERROR,name:i,correlationId:e,parsedData:"ERROR"});e(l),e(d),yield bluebird_1.Promise.delay(60),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,"ERROR"),sinon.assert.notCalled(r),sinon.assert.calledOnce(_),sinon.assert.calledWithExactly(_,"ERROR")})),it("doesn't call rpc response callback twice when handling error message",()=>__awaiter(this,void 0,void 0,function*(){const e=e=>n({topic:message_constants_1.TOPIC.RPC,action:message_constants_1.RPC_ACTIONS.REQUEST_ERROR,name:i,correlationId:e,parsedData:"ERROR"});e(l),e(l),e(d),e(d),yield bluebird_1.Promise.delay(60),sinon.assert.calledOnce(t),sinon.assert.notCalled(r),sinon.assert.calledOnce(_)})),it("responds with error when onConnectionLost",()=>__awaiter(this,void 0,void 0,function*(){e.simulateConnectionLost(),yield bluebird_1.Promise.delay(1),sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,constants_1.EVENT.CLIENT_OFFLINE),sinon.assert.notCalled(r),sinon.assert.calledOnce(_),sinon.assert.calledWithExactly(_,constants_1.EVENT.CLIENT_OFFLINE)}))}),describe("limbo",()=>{beforeEach(()=>{e.connection.isConnected=!1,e.connection.isInLimbo=!0}),it("returns client offline error once limbo state over",()=>__awaiter(this,void 0,void 0,function*(){s.make(i,o,a),e.simulateExitLimbo(),yield bluebird_1.Promise.delay(1),sinon.assert.calledOnce(a),sinon.assert.calledWithExactly(a,constants_1.EVENT.CLIENT_OFFLINE)})),it("sends messages once re-established if in limbo",()=>__awaiter(this,void 0,void 0,function*(){s.make(i,o,a),e.connectionMock.expects("sendMessage").once(),e.timeoutRegistryMock.expects("add").twice(),e.simulateConnectionReestablished(),yield bluebird_1.Promise.delay(1)}))})});