"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const utils=require("../util/utils"),constants_1=require("../constants"),Emitter=require("component-emitter2");class List extends Emitter{constructor(t){super(),this.record=t,this.originalApplyUpdate=this.record.applyUpdate.bind(this.record),this.record.applyUpdate=this.applyUpdate.bind(this),this.wrappedFunctions=new Map,this.hasAddListener=!1,this.hasRemoveListener=!1,this.hasMoveListener=!1}get name(){return this.record.name}get isReady(){return this.record.isReady}get version(){return this.record.version}whenReady(t){if(!t)return this.record.whenReady(this);this.record.whenReady(this,t)}getEntries(){const t=this.record.get();return t instanceof Array?t:[]}isEmpty(){return 0===this.getEntries().length}setEntriesWithAck(t,e){if(!e)return new Promise((e,s)=>{this.setEntries(t,t=>{t?s(t):e()})});this.setEntries(t,e)}setEntries(t,e){const s="entries must be an array of record names";let r;if(!(t instanceof Array))throw new Error(s);for(r=0;r<t.length;r++)if("string"!=typeof t[r])throw new Error(s);!1===this.record.isReady||(this.beforeChange(),this.record.set({data:t,callback:e}),this.afterChange())}removeEntry(t,e,s){if(!1===this.record.isReady)return;const r=this.record.get(),i=this.hasIndex(e),n=[];let h;for(h=0;h<r.length;h++)(r[h]!==t||i&&e!==h)&&n.push(r[h]);this.beforeChange(),this.record.set({data:n,callback:s}),this.afterChange()}addEntry(t,e,s){if("string"!=typeof t)throw new Error("Entry must be a recordName");if(!1===this.record.isReady)return;const r=this.hasIndex(e),i=this.getEntries();r?i.splice(e,0,t):i.push(t),this.beforeChange(),this.record.set({data:i,callback:s}),this.afterChange()}subscribe(t){const e=utils.normalizeArguments(arguments);if(e.path)throw new Error("path is not supported for List.subscribe");const s=function(t,e){e(t.getEntries())}.bind(this,this,e.callback);this.wrappedFunctions.set(e.callback,s),e.callback=s,this.record.subscribe(e)}unsubscribe(t){const e=utils.normalizeArguments(arguments);if(e.path)throw new Error("path is not supported for List.unsubscribe");const s=this.wrappedFunctions.get(e.callback);e.callback=s,this.record.unsubscribe(e),this.wrappedFunctions.delete(e.callback)}applyUpdate(t){t.parsedData instanceof Array||(t.parsedData=[]),this.beforeChange(),this.originalApplyUpdate(t),this.afterChange()}hasIndex(t){let e=!1;const s=this.getEntries();if(void 0!==t){if(isNaN(t))throw new Error("Index must be a number");if(t!==s.length&&(t>=s.length||t<0))throw new Error("Index must be within current entries");e=!0}return e}beforeChange(){this.hasAddListener=this.listeners(constants_1.EVENT.ENTRY_ADDED_EVENT).length>0,this.hasRemoveListener=this.listeners(constants_1.EVENT.ENTRY_REMOVED_EVENT).length>0,this.hasMoveListener=this.listeners(constants_1.EVENT.ENTRY_MOVED_EVENT).length>0,this.hasAddListener||this.hasRemoveListener||this.hasMoveListener?this.beforeStructure=this.getStructure():this.beforeStructure=null}afterChange(){if(null===this.beforeStructure)return;const t=this.getStructure(),e=this.beforeStructure;let s,r;if(this.hasRemoveListener)for(s in e)for(r=0;r<e[s].length;r++)void 0!==t[s]&&void 0!==t[s][r]||this.emit(constants_1.EVENT.ENTRY_REMOVED_EVENT,s,e[s][r]);if(this.hasAddListener||this.hasMoveListener)for(s in t)if(void 0===e[s])for(r=0;r<t[s].length;r++)this.emit(constants_1.EVENT.ENTRY_ADDED_EVENT,s,t[s][r]);else for(r=0;r<t[s].length;r++)e[s][r]!==t[s][r]&&(void 0===e[s][r]?this.emit(constants_1.EVENT.ENTRY_ADDED_EVENT,s,t[s][r]):this.emit(constants_1.EVENT.ENTRY_MOVED_EVENT,s,t[s][r]))}getStructure(){const t={};let e;const s=this.getEntries();for(e=0;e<s.length;e++)void 0===t[s[e]]?t[s[e]]=[e]:t[s[e]].push(e);return t}}exports.List=List;