"use strict";var __awaiter=this&&this.__awaiter||function(e,n,s,t){return new(s||(s=Promise))(function(i,c){function o(e){try{r(t.next(e))}catch(e){c(e)}}function a(e){try{r(t.throw(e))}catch(e){c(e)}}function r(e){e.done?i(e.value):new s(function(n){n(e.value)}).then(o,a)}r((t=t.apply(e,n||[])).next())})};Object.defineProperty(exports,"__esModule",{value:!0});const bluebird_1=require("bluebird"),sinon_1=require("sinon"),mocks_1=require("../test/mocks"),constants_1=require("../constants"),message_constants_1=require("../../binary-protocol/src/message-constants"),write_ack_service_1=require("./write-ack-service");describe("Write Ack Notifier",()=>{const e=message_constants_1.TOPIC.RECORD,n=message_constants_1.RECORD_ACTIONS.CREATEANDPATCH,s=message_constants_1.RECORD_ACTIONS.CREATEANDPATCH_WITH_WRITE_ACK,t="record";let i,c,o;beforeEach(()=>{i=mocks_1.getServicesMock(),c=new write_ack_service_1.WriteAcknowledgementService(i),o=sinon_1.spy()}),afterEach(()=>{i.verify()}),it("cant't send request when client is offline",()=>__awaiter(this,void 0,void 0,function*(){i.connection.isConnected=!1,i.connectionMock.expects("sendMessage").never(),c.send({topic:e,action:n,name:t},o),yield bluebird_1.Promise.delay(1),sinon_1.assert.calledOnce(o),sinon_1.assert.calledWithExactly(o,constants_1.EVENT.CLIENT_OFFLINE)})),it("calls callbacks with error message when connection is lost",()=>__awaiter(this,void 0,void 0,function*(){const s={topic:e,action:n,name:t};c.send(s,o),c.send(s,o),i.simulateConnectionLost(),yield bluebird_1.Promise.delay(1),sinon_1.assert.calledTwice(o),sinon_1.assert.calledWithExactly(o,constants_1.EVENT.CLIENT_OFFLINE)})),it("sends correct messages with different correlationsId for each call",()=>{const o={topic:e,action:n,name:t};i.connectionMock.expects("sendMessage").once().withExactArgs(Object.assign({},o,{action:s,correlationId:"1"})),i.connectionMock.expects("sendMessage").once().withExactArgs(Object.assign({},o,{action:s,correlationId:"2"})),c.send(o,()=>{}),c.send(o,()=>{})}),describe("receiving",()=>{let s;beforeEach(()=>{s={topic:e,action:n,name:t},c.send(Object.assign({},s),o)}),it("logs error for unknown acknowledgements",()=>__awaiter(this,void 0,void 0,function*(){const s={topic:e,action:n,name:t,correlationId:"123"};c.recieve(s),yield bluebird_1.Promise.delay(1),sinon_1.assert.notCalled(o)})),it("calls ack callback when server sends ack message",()=>__awaiter(this,void 0,void 0,function*(){c.recieve({topic:e,action:message_constants_1.RECORD_ACTIONS.WRITE_ACKNOWLEDGEMENT,correlationId:"1",originalAction:message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE_WITH_WRITE_ACK}),yield bluebird_1.Promise.delay(1),sinon_1.assert.calledOnce(o),sinon_1.assert.calledWith(o)})),it("doesn't call callback twice",()=>__awaiter(this,void 0,void 0,function*(){const n={topic:e,action:message_constants_1.RECORD_ACTIONS.WRITE_ACKNOWLEDGEMENT,correlationId:"1",originalAction:message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE_WITH_WRITE_ACK};c.recieve(n),c.recieve(n),yield bluebird_1.Promise.delay(1),sinon_1.assert.calledOnce(o),sinon_1.assert.calledWith(o)})),it("calls ack callback with error when server sends error message",()=>__awaiter(this,void 0,void 0,function*(){const n=message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED;c.recieve({topic:e,action:n,correlationId:"1",originalAction:message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE_WITH_WRITE_ACK,isError:!0}),yield bluebird_1.Promise.delay(1),sinon_1.assert.calledOnce(o),sinon_1.assert.calledWith(o,message_constants_1.RECORD_ACTIONS[n])}))})});