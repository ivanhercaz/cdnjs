"use strict";var __awaiter=this&&this.__awaiter||function(e,s,t,n){return new(t||(t=Promise))(function(i,o){function a(e){try{r(n.next(e))}catch(e){o(e)}}function c(e){try{r(n.throw(e))}catch(e){o(e)}}function r(e){e.done?i(e.value):new t(function(s){s(e.value)}).then(a,c)}r((n=n.apply(e,s||[])).next())})};Object.defineProperty(exports,"__esModule",{value:!0});const bluebird_1=require("bluebird"),sinon_1=require("sinon"),mocks_1=require("../test/mocks"),constants_1=require("../constants"),message_constants_1=require("../../binary-protocol/src/message-constants"),single_notifier_1=require("./single-notifier");describe("Single Notifier",()=>{const e=message_constants_1.RECORD_ACTIONS.READ,s="name",t=message_constants_1.TOPIC.RECORD;let n,i,o;beforeEach(()=>{n=mocks_1.getServicesMock(),i=new single_notifier_1.SingleNotifier(n,e,10),o=sinon_1.spy()}),afterEach(()=>{n.verify()}),it("requests with correct topic and action",()=>{const a={topic:t,action:e,name:s};n.connectionMock.expects("sendMessage").once().withExactArgs(a),n.timeoutRegistryMock.expects("add").once().withExactArgs({message:a}),i.request(s,o)}),it("doesn't send message twice and updates the timeout when requesting twice",()=>{const a={topic:t,action:e,name:s};n.connectionMock.expects("sendMessage").once().withExactArgs(a),n.timeoutRegistryMock.expects("add").once().withExactArgs({message:a}),i.request(s,o),i.request(s,o)}),it("cant't query request when client is offline",()=>__awaiter(this,void 0,void 0,function*(){n.connection.isConnected=!1,i.request(s,o),yield bluebird_1.Promise.delay(1),sinon_1.assert.calledOnce(o),sinon_1.assert.calledWithExactly(o,constants_1.EVENT.CLIENT_OFFLINE)})),describe("requesting",()=>__awaiter(this,void 0,void 0,function*(){beforeEach(()=>{i.request(s,o)}),it("doesn't respond unknown requests",()=>__awaiter(this,void 0,void 0,function*(){const e={topic:t,action:message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED,name:"something",isError:!0};i.recieve(e,message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED],void 0),sinon_1.assert.notCalled(o),yield bluebird_1.Promise.delay(1)})),it("responds callback and promise requests with success response",()=>__awaiter(this,void 0,void 0,function*(){const n={some:"data"};i.recieve({topic:t,action:e,name:s,isError:!1,parsedData:n},void 0,n),sinon_1.assert.calledOnce(o),sinon_1.assert.calledWithExactly(o,void 0,n),yield bluebird_1.Promise.delay(1)})),it("responds callback and promise requests with error response",()=>__awaiter(this,void 0,void 0,function*(){i.recieve({topic:t,action:message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED,name:s,isError:!0},message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED],void 0),sinon_1.assert.calledOnce(o),sinon_1.assert.calledWithExactly(o,message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED],void 0),yield bluebird_1.Promise.delay(1)})),it("responds with error on connection lost",()=>__awaiter(this,void 0,void 0,function*(){n.simulateConnectionLost(),yield bluebird_1.Promise.delay(1),sinon_1.assert.calledOnce(o),sinon_1.assert.calledWithExactly(o,constants_1.EVENT.CLIENT_OFFLINE)}))}))});