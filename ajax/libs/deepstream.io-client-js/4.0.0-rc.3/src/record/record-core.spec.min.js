"use strict";var __awaiter=this&&this.__awaiter||function(e,s,t,a){return new(t||(t=Promise))(function(n,c){function o(e){try{r(a.next(e))}catch(e){c(e)}}function i(e){try{r(a.throw(e))}catch(e){c(e)}}function r(e){e.done?n(e.value):new t(function(s){s(e.value)}).then(o,i)}r((a=a.apply(e,s||[])).next())})};Object.defineProperty(exports,"__esModule",{value:!0});const BBPromise=require("bluebird"),chai_1=require("chai"),mocks_1=require("../test/mocks"),message_constants_1=require("../../binary-protocol/src/message-constants"),client_options_1=require("../client-options"),record_core_1=require("./record-core"),sinon_1=require("sinon"),constants_1=require("../constants");describe("record core",()=>{describe("online",()=>{let e,s,t,a,n;beforeEach(()=>{e=sinon_1.spy(),a=mocks_1.getServicesMock(),n=mocks_1.getRecordServices(a),t=Object.assign({},client_options_1.DefaultOptions,{discardTimeout:20,recordReadTimeout:20}),a.connection.isConnected=!0,s=new record_core_1.RecordCore(name,a,t,n,e),a.connectionMock.restore()}),afterEach(()=>{a.verify()}),it("sends a subscribe create and read message if online when created",()=>{a.connection.isConnected=!0,a.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD,name:name}),s=new record_core_1.RecordCore(name,a,t,n,e)}),it("doesn`t send updates before ready",()=>{a.connectionMock.expects("sendMessage").never(),s.set({data:{firstname:"Wolfram"}})}),it("doesn`t send patches before ready",()=>{a.connectionMock.expects("sendMessage").never(),s.set({path:"firstname",data:"Wolfram"})}),it("triggers ready callback on read response",()=>{const e={},t=sinon_1.spy();s.whenReady(e,t),n.readRegistry.recieve(READ_RESPONSE),sinon_1.assert.calledOnce(t),sinon_1.assert.calledWithExactly(t,e)}),it("triggers ready promise on read response",()=>__awaiter(this,void 0,void 0,function*(){const e={};let t=null;s.whenReady(e).then(e=>t=e),n.readRegistry.recieve(READ_RESPONSE),yield BBPromise.delay(0),chai_1.expect(t).to.equal(e)})),it("sends update messages for updates after when ready",()=>{n.readRegistry.recieve(READ_RESPONSE),a.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.UPDATE,name:name,parsedData:{firstname:"Bob"},version:2}),s.set({data:{firstname:"Bob"}})}),it("sends patch messages for path changes after when ready",()=>{n.readRegistry.recieve(READ_RESPONSE),a.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.PATCH,name:name,path:"firstname",parsedData:"Bob",version:2}),s.set({path:"firstname",data:"Bob"})}),it("sends update messages for updates write ack after when ready",()=>{n.readRegistry.recieve(READ_RESPONSE),a.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.UPDATE_WITH_WRITE_ACK,name:name,parsedData:{firstname:"Bob"},correlationId:"1",version:2}),s.set({data:{firstname:"Bob"},callback:()=>{}})}),it("sends patch messages for path changes after when ready",()=>{n.readRegistry.recieve(READ_RESPONSE),a.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.PATCH_WITH_WRITE_ACK,name:name,path:"firstname",parsedData:"Bob",correlationId:"1",version:2}),s.set({path:"firstname",data:"Bob",callback:()=>{}})}),it("sends erase messages for erase after when ready",()=>{n.readRegistry.recieve(READ_RESPONSE),a.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.ERASE,name:name,path:"firstname",version:2}),s.set({path:"firstname"})}),it("sends erase write ack messages for erase after when ready",()=>{n.readRegistry.recieve(READ_RESPONSE),a.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.ERASE_WITH_WRITE_ACK,name:name,path:"firstname",correlationId:"1",version:2}),s.set({path:"firstname",callback:()=>{}})}),it("queues discarding record when no longer needed",()=>{n.readRegistry.recieve(READ_RESPONSE),s.discard(),chai_1.expect(s.recordState).to.equal("UNSUBSCRIBING"),chai_1.expect(s.isReady).to.equal(!0)}),it("removes pending discard when usages increases",()=>__awaiter(this,void 0,void 0,function*(){n.readRegistry.recieve(READ_RESPONSE),s.discard(),s.usages=1,yield BBPromise.delay(30),chai_1.expect(s.recordState).to.equal("READY"),chai_1.expect(s.isReady).to.equal(!0)})),it("sends discard when unsubscribe timeout completed",()=>__awaiter(this,void 0,void 0,function*(){n.readRegistry.recieve(READ_RESPONSE),s.discard(),a.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE,name:name}),yield BBPromise.delay(30),chai_1.expect(s.recordState).to.equal("UNSUBSCRIBED"),sinon_1.assert.calledOnce(e),sinon_1.assert.calledWithExactly(e,name),chai_1.expect(s.isReady).to.equal(!1)})),it("sends delete when ready",()=>__awaiter(this,void 0,void 0,function*(){n.readRegistry.recieve(READ_RESPONSE),a.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.DELETE,name:name}),s.delete(),chai_1.expect(s.recordState).to.equal("DELETING"),sinon_1.assert.notCalled(e),chai_1.expect(s.isReady).to.equal(!0)})),it("calls delete when delete is confirmed",()=>__awaiter(this,void 0,void 0,function*(){n.readRegistry.recieve(READ_RESPONSE),a.connectionMock.expects("sendMessage").once(),s.delete(),s.handle({topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS,name:name}),chai_1.expect(s.recordState).to.equal("DELETED"),sinon_1.assert.calledOnce(e),sinon_1.assert.calledWithExactly(e,name),chai_1.expect(s.isReady).to.equal(!1)})),it("calls delete when delete happens remotely",()=>__awaiter(this,void 0,void 0,function*(){n.readRegistry.recieve(READ_RESPONSE),s.handle({topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.DELETED,name:name}),chai_1.expect(s.recordState).to.equal("DELETED"),sinon_1.assert.calledOnce(e),sinon_1.assert.calledWithExactly(e,name),chai_1.expect(s.isReady).to.equal(!1)}))}),describe("record core offline",()=>{let e,s,t,a,n;beforeEach(()=>{e=sinon_1.spy(),a=mocks_1.getServicesMock(),n=mocks_1.getRecordServices(a),t=Object.assign({},client_options_1.DefaultOptions,{discardTimeout:20,recordReadTimeout:20}),a.connectionMock.expects("sendMessage").never(),a.storageMock.expects("get").once().callsArgWith(1,name,1,{firstname:"wolfram"}),a.connection.isConnected=!1,s=new record_core_1.RecordCore(name,a,t,n,e)}),afterEach(()=>{a.verify(),n.verify()}),it("triggers ready callback on load",()=>{const e={},t=sinon_1.spy();s.whenReady(e,t),sinon_1.assert.calledOnce(t),sinon_1.assert.calledWithExactly(t,e)}),it("sets update messages for updates after when ready",()=>{a.storageMock.expects("set").once().withExactArgs(name,2,{firstname:"Bob"},sinon_1.match.func),s.set({data:{firstname:"Bob"}})}),it("sends patch messages for path changes after when ready",()=>{a.storageMock.expects("set").once().withExactArgs(name,2,{firstname:"Bob"},sinon_1.match.func),s.set({path:"firstname",data:"Bob"})}),it("responds to update write acks with an offline error",()=>__awaiter(this,void 0,void 0,function*(){const e=sinon_1.spy();a.storageMock.expects("set").once().withExactArgs(name,2,{firstname:"Bob"},sinon_1.match.func),s.set({data:{firstname:"Bob"},callback:e}),yield BBPromise.delay(0),sinon_1.assert.calledOnce(e),sinon_1.assert.calledWithExactly(e,constants_1.EVENT.CLIENT_OFFLINE,name)})),it("sends patch messages for path changes after when ready",()=>__awaiter(this,void 0,void 0,function*(){const e=sinon_1.spy();a.storageMock.expects("set").once().withExactArgs(name,2,{firstname:"Bob"},sinon_1.match.func),s.set({path:"firstname",data:"Bob",callback:e}),yield BBPromise.delay(0),sinon_1.assert.calledOnce(e),sinon_1.assert.calledWithExactly(e,constants_1.EVENT.CLIENT_OFFLINE,name)})),it("sends erase messages for erase after when ready",()=>{a.storageMock.expects("set").once().withExactArgs(name,2,{},sinon_1.match.func),s.set({path:"firstname"})}),it("sends erase write ack messages for erase after when ready",()=>__awaiter(this,void 0,void 0,function*(){const e=sinon_1.spy();a.storageMock.expects("set").once().withExactArgs(name,2,{},sinon_1.match.func),s.set({path:"firstname",callback:e}),yield BBPromise.delay(0),sinon_1.assert.calledOnce(e),sinon_1.assert.calledWithExactly(e,constants_1.EVENT.CLIENT_OFFLINE,name)})),it("queues discarding record when no longer needed",()=>{s.discard(),chai_1.expect(s.recordState).to.equal("UNSUBSCRIBING"),chai_1.expect(s.isReady).to.equal(!0)}),it("removes pending discard when usages increases",()=>__awaiter(this,void 0,void 0,function*(){s.discard(),s.usages++,yield BBPromise.delay(30),chai_1.expect(s.recordState).to.equal("READY"),chai_1.expect(s.isReady).to.equal(!0)})),it("removes record when completed",()=>__awaiter(this,void 0,void 0,function*(){s.discard(),yield BBPromise.delay(40),chai_1.expect(s.recordState).to.equal("UNSUBSCRIBED"),sinon_1.assert.calledOnce(e),sinon_1.assert.calledWithExactly(e,name),chai_1.expect(s.isReady).to.equal(!1)})),it.skip("sends delete when ready",()=>__awaiter(this,void 0,void 0,function*(){a.storageMock.expects("delete").once().withExactArgs(name,sinon_1.match.func),s.delete(),chai_1.expect(s.recordState).to.equal("DELETING"),sinon_1.assert.notCalled(e),chai_1.expect(s.isReady).to.equal(!0)})),it.skip("calls delete when delete is confirmed",()=>__awaiter(this,void 0,void 0,function*(){a.storageMock.expects("delete").once().withExactArgs(name,sinon_1.match.func).callsArgWith(1,name),s.delete(),yield BBPromise.delay(0),chai_1.expect(s.recordState).to.equal("DELETED"),sinon_1.assert.calledOnce(e),sinon_1.assert.calledWithExactly(e,name),chai_1.expect(s.isReady).to.equal(!1)}))})});const name="recordA",READ_RESPONSE={topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.READ_RESPONSE,name:name,parsedData:{},version:1};