"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const chai_1=require("chai"),sinon=require("sinon"),mocks_1=require("../test/mocks"),message_constants_1=require("../../binary-protocol/src/message-constants"),constants_1=require("../constants"),listener_1=require("./listener");describe("listener",()=>{let s,e,t;beforeEach(()=>{t=sinon.stub(),s=mocks_1.getServicesMock(),e=new listener_1.Listener(message_constants_1.TOPIC.EVENT,s)}),afterEach(()=>{s.connectionMock.verify(),s.loggerMock.verify(),s.timeoutRegistryMock.verify()}),it("validates parameters on listen and unlisten",()=>{chai_1.expect(e.listen.bind(e,"",t)).to.throw(),chai_1.expect(e.unlisten.bind(e,"")).to.throw()}),it("sends event listen message",()=>{const n={topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.LISTEN,name:".*"};s.connectionMock.expects("sendMessage").once().withExactArgs(n),s.timeoutRegistryMock.expects("add").once().withExactArgs({message:n}),e.listen(".*",t)}),it("sends record listen message",()=>{e=new listener_1.Listener(message_constants_1.TOPIC.RECORD,s);const n={topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.LISTEN,name:".*"};s.connectionMock.expects("sendMessage").once().withExactArgs(n),s.timeoutRegistryMock.expects("add").once().withExactArgs({message:n}),e.listen(".*",t)}),it("resubscribes all patterns when connection reestablished",()=>{e=new listener_1.Listener(message_constants_1.TOPIC.RECORD,s);const n={topic:message_constants_1.TOPIC.RECORD,action:message_constants_1.RECORD_ACTIONS.LISTEN,name:".*"};s.connectionMock.expects("sendMessage").twice().withExactArgs(n),s.timeoutRegistryMock.expects("add").twice().withExactArgs({message:n}),e.listen(".*",t),s.simulateConnectionReestablished()}),describe("when a pattern is listened to",()=>{beforeEach(()=>{e.listen(".*",t),s.connectionMock.restore(),s.timeoutRegistryMock.restore()}),it("warns if listen invoked more than once",()=>{s.loggerMock.expects("warn").once().withExactArgs({topic:message_constants_1.TOPIC.EVENT,action:constants_1.EVENT.LISTENER_EXISTS,name:".*"}),e.listen(".*",t)}),it("sends unlisten message when unlistened",()=>{const t={topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.UNLISTEN,name:".*"};s.connectionMock.expects("sendMessage").once().withExactArgs(t),s.timeoutRegistryMock.expects("add").once().withExactArgs({message:t}),e.unlisten(".*")}),it("warns if unlisten invoked more than once",()=>{s.loggerMock.expects("warn").once().withExactArgs({topic:message_constants_1.TOPIC.EVENT,action:constants_1.EVENT.NOT_LISTENING,name:".*"}),e.unlisten(".*"),e.unlisten(".*")}),it("logs unsolicited message if an unknown message is recieved",()=>{const t={topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.EMIT,name:".*",subscription:"subscription"};s.loggerMock.expects("error").once().withExactArgs(t,constants_1.EVENT.UNSOLICITED_MESSAGE),e.handle(t)}),describe("gets a subscription for pattern found",()=>{let n;beforeEach(()=>{e.handle({topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND,name:".*",subscription:"subscription"}),n=t.lastCall.args[1]}),it("calls the listen callback",()=>{sinon.assert.calledOnce(t),sinon.assert.calledWithExactly(t,"subscription",sinon.match.any)}),it("responds with accept",()=>{s.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.LISTEN_ACCEPT,name:".*",subscription:"subscription"}),n.accept()}),it("responds with reject",()=>{s.connectionMock.expects("sendMessage").once().withExactArgs({topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.LISTEN_REJECT,name:".*",subscription:"subscription"}),n.reject()}),it("calls onStop subscription for pattern removed",()=>{const s=sinon.spy();n.onStop(s),n.accept(),e.handle({topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED,name:".*",subscription:"subscription"}),sinon.assert.calledOnce(s),sinon.assert.calledWithExactly(s,"subscription")}),it("deletes onStop callback once called",()=>{const s=sinon.spy();n.onStop(s),n.accept(),e.handle({topic:message_constants_1.TOPIC.EVENT,action:message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED,name:".*",subscription:"subscription"}),sinon.assert.calledOnce(s),sinon.assert.calledWithExactly(s,"subscription")}),it("triggers all stop callbacks when connection lost",()=>{const e=sinon.spy();n.onStop(e),n.accept(),s.simulateConnectionLost(),sinon.assert.calledOnce(e),sinon.assert.calledWithExactly(e,"subscription")})})})});