"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const constants_1=require("../constants"),utils_1=require("../../binary-protocol/src/utils"),EventEmitter=require("component-emitter2");class TimeoutRegistry extends EventEmitter{constructor(e,t){super(),this.services=e,this.options=t,this.register=new Map}add(e){if(void 0===e.duration&&(e.duration=this.options.subscriptionTimeout),void 0===e.event&&(e.event=constants_1.EVENT.ACK_TIMEOUT),!this.services.connection.isConnected)return null;this.remove(e.message);const t={timerId:-1,uniqueName:this.getUniqueName(e.message),timeout:e};return t.timerId=this.services.timerRegistry.add({context:this,callback:this.onTimeout,duration:e.duration,data:t}),this.register.set(t.uniqueName,t),t.uniqueName}remove(e){let t;const i=utils_1.RESPONSE_TO_REQUEST[e.topic][e.action];t=i?Object.assign({},e,{action:i}):e;const s=this.getUniqueName(t);this.clear(s)}clear(e){const t=this.register.get(e);t&&(this.register.delete(e),this.services.timerRegistry.remove(t.timerId))}onTimeout(e){this.register.delete(e.uniqueName);const t=e.timeout;t.callback?t.callback(t.event,t.message):this.services.logger.warn(t.message,t.event)}getUniqueName(e){const t=e.originalAction||e.action;let i=`${e.topic}${t}_`;return e.correlationId?i+=e.correlationId:e.name&&(i+=e.name),i}onConnectionLost(){for(const[e,t]of this.register)this.services.timerRegistry.remove(t.timerId),this.register.delete(e)}}exports.TimeoutRegistry=TimeoutRegistry;