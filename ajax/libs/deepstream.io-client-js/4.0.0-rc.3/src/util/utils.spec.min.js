"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const utils=require("./utils"),chai_1=require("chai");describe("deepEquals",()=>{it("compares two primitive values",()=>{chai_1.expect(utils.deepEquals("A","B")).to.equal(!1),chai_1.expect(utils.deepEquals("A","A")).to.equal(!0),chai_1.expect(utils.deepEquals(1,2)).to.equal(!1),chai_1.expect(utils.deepEquals(1,1)).to.equal(!0),chai_1.expect(utils.deepEquals(1.2,2.1)).to.equal(!1),chai_1.expect(utils.deepEquals(2.1,2.1)).to.equal(!0)}),it("compares two different simple objects",()=>{chai_1.expect(utils.deepEquals({name:"Wolfram"},{name:"Egon"})).to.equal(!1)}),it("compares two equal simple objects",()=>{chai_1.expect(utils.deepEquals({name:"Wolfram"},{name:"Wolfram"})).to.equal(!0)}),it("compares two different arrays",()=>{chai_1.expect(utils.deepEquals(["a","b"],["a","c"])).to.equal(!1)}),it("compares two equal arrays",()=>{chai_1.expect(utils.deepEquals(["a","b"],["a","b"])).to.equal(!0)}),it("compares two different complex objects",()=>{chai_1.expect(utils.deepEquals({x:"y",a:["b",{q:"f"}]},{x:"y",a:["b",{q:"x"}]})).to.equal(!1)}),it("compares two equal complex objects",()=>{chai_1.expect(utils.deepEquals({x:"y",a:["b",{q:"f"}]},{x:"y",a:["b",{q:"f"}]})).to.equal(!0)}),it("a complex object and a primitive",()=>{const e={x:"y",a:["b",{q:"f"}]};chai_1.expect(utils.deepEquals(e,44)).to.equal(!1),chai_1.expect(utils.deepEquals(e,!1)).to.equal(!1),chai_1.expect(utils.deepEquals(e,44.44)).to.equal(!1),chai_1.expect(utils.deepEquals(e,"primitive")).to.equal(!1)}),it("handles undefined",()=>{chai_1.expect(utils.deepEquals({x:"y",a:["b",{q:"f"}]},void 0)).to.be.equal(!1)}),it("handles empty objects",()=>{chai_1.expect(utils.deepEquals({firstname:"Wolfram"},{})).to.equal(!1)}),it("finds additional paths on objB",()=>{process.stdout.write(`${utils.deepEquals({a:"b"},{a:"b",c:"d"})}`),chai_1.expect(!1).to.equal(!1)})}),describe("deepCopy",()=>{it("copies primitives",()=>{chai_1.expect(utils.deepCopy("bla")).to.equal("bla"),chai_1.expect(utils.deepCopy(42)).to.equal(42)}),it("copies arrays",()=>{const e=["a","b",2],t=utils.deepCopy(e);chai_1.expect(t).to.deep.equal(e)}),it("copies objects",()=>{const e={firstname:"Wolfram",lastname:" Hempel"},t=utils.deepCopy(e);chai_1.expect(t).to.deep.equal(e)}),it("copies objects with null values",()=>{const e={firstname:"Wolfram",lastname:null},t=utils.deepCopy(e);chai_1.expect(t).to.deep.equal(e)}),it("copies null values",()=>{chai_1.expect(utils.deepCopy(null)).to.be.a("null")}),it("copies nested values",()=>{const e={a:{b:"c",d:4}},t=utils.deepCopy(e);chai_1.expect(e).to.deep.equal(t),chai_1.expect(e.a).to.deep.equal(t.a)}),it("copies nested arrays",()=>{const e={a:{b:"c",d:["a",{x:"y"}]}},t=utils.deepCopy(e);chai_1.expect(e).to.deep.equal(t),chai_1.expect(e.a.d).to.deep.equal(t.a.d),chai_1.expect(Array.isArray(t.a.d)).to.equal(!0),chai_1.expect(t.a.d[1]).to.deep.equal({x:"y"}),chai_1.expect(e.a.d[1]===t.a.d[1]).to.equal(!1)}),it("converts undefined",()=>{let e=utils.deepCopy([void 0]);chai_1.expect(e[0]).to.be.a("null"),e=utils.deepCopy({x:void 0}),chai_1.expect(e).to.deep.equal({})})}),describe("shallowCopy",()=>{it("copies primitives",()=>{chai_1.expect(utils.shallowCopy("bla")).to.equal("bla"),chai_1.expect(utils.shallowCopy(42)).to.equal(42)}),it("copies arrays",()=>{const e=["a","b",2],t=utils.shallowCopy(e);chai_1.expect(t).to.deep.equal(e)}),it("copies objects",()=>{const e={firstname:"Wolfram",lastname:" Hempel"},t=utils.shallowCopy(e);chai_1.expect(t).to.deep.equal(e)}),it("copies objects with null values",()=>{const e={firstname:"Wolfram",lastname:null},t=utils.shallowCopy(e);chai_1.expect(t).to.deep.equal(e)}),it("handles empty objects",()=>{const e=utils.shallowCopy({});chai_1.expect(e).to.deep.equal({})}),it("throws error on null values",()=>{chai_1.expect(()=>{utils.shallowCopy(null)}).to.throw("Cannot convert undefined or null to object")})}),describe("trim",()=>{it("removes various kinds of whitespace from Strings having String.prototype.trim polyfill",()=>{chai_1.expect(utils.trim("a    ")).to.equal("a"),chai_1.expect(utils.trim("   b    ")).to.equal("b"),chai_1.expect(utils.trim("   c d    ")).to.equal("c d")}),it("removes various kinds of whitespace from string having no String.prototype.trim polyfill",()=>{delete String.prototype.trim,chai_1.expect(utils.trim("a    ")).to.equal("a"),chai_1.expect(utils.trim("   b    ")).to.equal("b"),chai_1.expect(utils.trim("   c d    ")).to.equal("c d")})}),describe("normalizeSetArguments",()=>{it("normalizes argument list containing only a data argument as object",()=>{const e=utils.normalizeSetArguments([{title:"awesome post"}]);chai_1.expect(e).to.deep.equal({path:void 0,data:{title:"awesome post"},callback:void 0})}),it("normalizes argument list containing only a data argument as array",()=>{const e=utils.normalizeSetArguments([[1,2,3,4]]);chai_1.expect(e).to.deep.equal({path:void 0,data:[1,2,3,4],callback:void 0})}),it("normalizes argument list containing only a data and a callback argument",()=>{const e=utils.normalizeSetArguments([{title:"awesome post"},()=>{}]);chai_1.expect(e).to.have.property("path").to.equal(void 0),chai_1.expect(e).to.have.property("data").to.deep.equal({title:"awesome post"}),chai_1.expect(e).to.have.property("callback").to.be.a("function")}),it("normalizes argument list containing only a path and a data argument as primitive",()=>{let e=utils.normalizeSetArguments(["title","awesome post"]);chai_1.expect(e).to.deep.equal({path:"title",data:"awesome post",callback:void 0}),e=utils.normalizeSetArguments(["version",123]),chai_1.expect(e).to.deep.equal({path:"version",data:123,callback:void 0}),e=utils.normalizeSetArguments(["liked",!0]),chai_1.expect(e).to.deep.equal({path:"liked",data:!0,callback:void 0})}),it("normalizes argument list contaning a path, a data and a callback argument",()=>{const e=utils.normalizeSetArguments(["post",{title:"awesome post"},()=>{}]);chai_1.expect(e).to.have.property("path").to.equal("post"),chai_1.expect(e).to.have.property("data").to.deep.equal({title:"awesome post"}),chai_1.expect(e).to.have.property("callback").to.be.a("function")}),it("normalizes argument list contaning a path, a data and a callback argument with a start index",()=>{const e=utils.normalizeSetArguments([{},"post",{title:"awesome post"},()=>{}],1);chai_1.expect(e).to.have.property("path").to.equal("post"),chai_1.expect(e).to.have.property("data").to.deep.equal({title:"awesome post"}),chai_1.expect(e).to.have.property("callback").to.be.a("function")}),it("throws error on an empty argument list",()=>{chai_1.expect(()=>{utils.normalizeSetArguments([])}).to.throw("Invalid set arguments")}),it.skip("throws error on an argument list containing an invalid data argument",()=>{chai_1.expect(()=>{utils.normalizeSetArguments([void 0])}).to.throw("Invalid set data argument"),chai_1.expect(()=>{utils.normalizeSetArguments([()=>{}])}).to.throw("Invalid set data argument"),chai_1.expect(()=>{utils.normalizeSetArguments(["data",()=>{}])}).to.throw("Invalid set data argument"),chai_1.expect(()=>{utils.normalizeSetArguments([134,()=>{}])}).to.throw("Invalid set data argument"),chai_1.expect(()=>{utils.normalizeSetArguments(["path",()=>{},()=>{}])}).to.throw("Invalid set data argument")}),it.skip("throws error on an argument list contaning an invalid path argument",()=>{chai_1.expect(()=>{utils.normalizeSetArguments([void 0,{title:"awesome post"}])}).to.throw("Invalid set path argument"),chai_1.expect(()=>{utils.normalizeSetArguments(["",{title:"awesome post"}])}).to.throw("Invalid set path argument"),chai_1.expect(()=>{utils.normalizeSetArguments([null,{title:"awesome post"}])}).to.throw("Invalid set path argument"),chai_1.expect(()=>{utils.normalizeSetArguments([!0,{title:"awesome post"},()=>{}])}).to.throw("Invalid set path argument")}),it("throws error on an argument list containing an invalid callback argument",()=>{chai_1.expect(()=>{utils.normalizeSetArguments(["title","awesome post",null])}).to.throw("Invalid set callback argument"),chai_1.expect(()=>{utils.normalizeSetArguments(["title","awesome post",{}])}).to.throw("Invalid set callback argument"),chai_1.expect(()=>{utils.normalizeSetArguments(["title","awesome post",[]])}).to.throw("Invalid set callback argument"),chai_1.expect(()=>{utils.normalizeSetArguments(["title","awesome post",1])}).to.throw("Invalid set callback argument"),chai_1.expect(()=>{utils.normalizeSetArguments(["title","awesome post",!1])}).to.throw("Invalid set callback argument")})}),describe("normalizeArguments",()=>{it("normalizes argument list contaning an object",()=>{const e=utils.normalizeArguments([{path:"title",callback:()=>{},triggerNow:!1}]);chai_1.expect(e).to.have.property("path").to.equal("title"),chai_1.expect(e).to.have.property("callback").to.be.a("function"),chai_1.expect(e).to.have.property("triggerNow").to.equal(!1)}),it("normalizes argument list contaning path, callback and triggerNow arguments",()=>{const e=utils.normalizeArguments([!0,()=>{},"title"]);chai_1.expect(e).to.have.property("path").to.equal("title"),chai_1.expect(e).to.have.property("callback").to.be.a("function"),chai_1.expect(e).to.have.property("triggerNow").to.equal(!0)}),it("handles an empty arguments list",()=>{const e=utils.normalizeArguments([]);chai_1.expect(e).to.deep.equal({})})}),describe("parseUrl adds all missing parts of the url",()=>{it("accepts no protocol and default to ws",()=>{chai_1.expect(utils.parseUrl("localhost","/deepstream")).to.equal("ws://localhost/deepstream")}),it("accepts // as protocol",()=>{chai_1.expect(utils.parseUrl("//localhost:6020","/deepstream")).to.equal("ws://localhost:6020/deepstream")}),it("accepts ws protocols",()=>{chai_1.expect(utils.parseUrl("ws://localhost:6020","/deepstream")).to.equal("ws://localhost:6020/deepstream"),chai_1.expect(utils.parseUrl("wss://localhost:6020","/deepstream")).to.equal("wss://localhost:6020/deepstream")}),it("rejects http protocols",()=>{chai_1.expect(utils.parseUrl.bind(utils,"http://localhost:6020","/deepstream")).to.throw("Only ws and wss are supported"),chai_1.expect(utils.parseUrl.bind(utils,"https://localhost:6020","/deepstream")).to.throw("Only ws and wss are supported")}),it("accepts full url with protocol and path and doesn't change it",()=>{chai_1.expect(utils.parseUrl("ws://localhost:6020/anotherdeepstream","")).to.equal("ws://localhost:6020/anotherdeepstream")}),it("respects queries and hash",()=>{chai_1.expect(utils.parseUrl("localhost?query=value#login","/deepstream")).to.equal("ws://localhost/deepstream?query=value#login")}),it("rejects urls with no host",()=>{chai_1.expect(utils.parseUrl.bind(utils,"","/deepstream")).to.throw("Invalid URL: ws://")})});