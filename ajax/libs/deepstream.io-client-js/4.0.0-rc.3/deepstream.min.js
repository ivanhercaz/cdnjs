!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define("deepstream",[],n):"object"==typeof exports?exports.deepstream=n():e.deepstream=n()}(window,function(){return d={"./binary-protocol/src/constants.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.HEADER_LENGTH = 8;\nexports.META_PAYLOAD_OVERFLOW_LENGTH = Math.pow(2, 24) - 1;\n\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/constants.ts?')},"./binary-protocol/src/message-builder.ts":function(module,exports,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(Buffer) {\n/**\n * Functions for handling (de)serialization of the deepstream binary realtime protocol.\n *\n * In brief, a message is a variable length binary blob with the following structure:\n *\n *  0                   1                   2                   3\n *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n * +-+-------------+-+-------------+-------------------------------+\n * |F|  Message    |A|  Message    |             Meta              |\n * |I|   Topic     |C|  Action     |            Length             |\n * |N|    (7)      |K|   (7)       |             (24)              |\n * +-+-------------+-+-------------+-------------------------------+\n * | Meta Cont.    |              Payload Length (24)              |\n * +---------------+-----------------------------------------------+\n * :                     Meta Data (Meta Length * 8)               :\n * + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n * |                  Payload Data (Payload Length * 8)            :\n * +---------------------------------------------------------------+\n *\n * The first 6 bytes of the message are the header, and the rest of the message is the payload.\n *\n * CONT (1 bit): The continuation bit. If this is set, the following payload of the following\n *                message must be appended to this one. If this is not set, parsing may finish\n *                after the payload is read.\n * RSV{0..3} (1 bit): Reserved for extension.\n * Meta Length (24 bits, unsigned big-endian): The total length of Meta Data in bytes.\n *                If Meta Data can be no longer than 16 MB.\n * Payload Length (24 bits, unsigned big-endian): The total length of Payload in bytes.\n *                If Payload is longer than 16 MB, it must be split into chunks of\n *                less than 2^24 bytes with identical topic and action, setting the CONT bit\n *                in all but the final chunk.\n *\n */\n/* tslint:disable:no-bitwise */\nObject.defineProperty(exports, "__esModule", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ./message-constants */ "./binary-protocol/src/message-constants.ts");\nconst utils_1 = __webpack_require__(/*! ./utils */ "./binary-protocol/src/utils.ts");\nconst constants_1 = __webpack_require__(/*! ./constants */ "./binary-protocol/src/constants.ts");\nconst message_validator_1 = __webpack_require__(/*! ./message-validator */ "./binary-protocol/src/message-validator.ts");\nfunction getMessage(msg, isAck) {\n    const message = msg;\n    let action = message.action;\n    // convert action to write ack if necessary\n    if (message.isWriteAck && !utils_1.isWriteAck(message.action)) {\n        action = utils_1.ACTION_TO_WRITE_ACK[message.action];\n    }\n    if (message.isAck || isAck) {\n        action |= 0x80;\n        if (message_constants_1.ACTIONS[message.topic][message.action] === undefined) {\n            throw new Error(`message ${message_constants_1.TOPIC[message.topic]} ${message.action} should not have an ack`);\n        }\n    }\n    const meta = {\n        n: message.name,\n        m: message.names,\n        c: message.correlationId,\n        s: message.subscription,\n        v: message.version,\n        p: message.path,\n        r: message.reason,\n        u: message.url,\n        t: message.originalTopic,\n        a: message.originalAction,\n        x: message.protocolVersion,\n        rn: message.requestorName,\n        rd: message.requestorData,\n        ts: message.trustedSender,\n        rt: message.registryTopic\n    };\n    if (message.payloadEncoding && message.payloadEncoding !== message_constants_1.PAYLOAD_ENCODING.JSON) {\n        meta[message_constants_1.META_KEYS.payloadEncoding] = message.payloadEncoding;\n    }\n    const metaError = message_validator_1.validateMeta(message.topic, action, meta);\n    if (metaError) {\n        throw new Error(`invalid ${message_constants_1.TOPIC[message.topic]} ${message_constants_1.ACTIONS[message.topic][action] || action}: ${metaError}`);\n    }\n    const metaStr = JSON.stringify(meta);\n    const metaBuff = metaStr === \'{}\' ? null : Buffer.from(metaStr, \'utf8\');\n    let payloadBuff;\n    if (message.data instanceof Buffer) {\n        payloadBuff = message.data;\n    }\n    else if (message.data !== undefined || message.parsedData !== undefined) {\n        let payloadStr = message.data;\n        if (payloadStr === undefined) {\n            payloadStr = JSON.stringify(message.parsedData);\n        }\n        payloadBuff = Buffer.from(payloadStr, \'utf8\');\n    }\n    else {\n        payloadBuff = null;\n    }\n    if (payloadBuff && !message_validator_1.hasPayload(message.topic, action)) {\n        console.error(`invalid message ${message_constants_1.TOPIC[message.topic]} ${message.action}: should not have payload`);\n    }\n    const metaBuffLength = metaBuff ? metaBuff.length : 0;\n    const payloadBuffLength = payloadBuff ? payloadBuff.length : 0;\n    if (metaBuffLength <= constants_1.META_PAYLOAD_OVERFLOW_LENGTH\n        && payloadBuffLength <= constants_1.META_PAYLOAD_OVERFLOW_LENGTH) {\n        return buildRaw(true, message.topic, action, metaBuff, payloadBuff);\n    }\n    else {\n        return buildMultipart(message.topic, action, metaBuff, payloadBuff);\n    }\n}\nexports.getMessage = getMessage;\nfunction buildMultipart(topic, action, meta, payload) {\n    const metaLength = meta ? meta.length : 0;\n    const payloadLength = payload ? payload.length : 0;\n    const messageParts = [];\n    let metaSectionOffset = 0;\n    let payloadSectionOffset = 0;\n    let fin;\n    do {\n        const metaSectionLength = Math.min(metaLength - metaSectionOffset, constants_1.META_PAYLOAD_OVERFLOW_LENGTH);\n        const payloadSectionLength = Math.min(payloadLength - payloadSectionOffset, constants_1.META_PAYLOAD_OVERFLOW_LENGTH);\n        const metaSection = meta && meta.slice(metaSectionOffset, metaSectionOffset + metaSectionLength);\n        const payloadSection = payload && payload.slice(payloadSectionOffset, payloadSectionOffset + payloadSectionLength);\n        metaSectionOffset += metaSectionLength;\n        payloadSectionOffset += payloadSectionLength;\n        fin = metaSectionOffset === metaLength && payloadSectionOffset === payloadLength;\n        messageParts.push(buildRaw(fin, topic, action, metaSection, payloadSection));\n    } while (!fin);\n    return Buffer.concat(messageParts);\n}\nfunction buildRaw(fin, topic, action, meta, payload) {\n    const metaLength = meta ? meta.length : 0;\n    const payloadLength = payload ? payload.length : 0;\n    const messageBufferLength = constants_1.HEADER_LENGTH + metaLength + payloadLength;\n    const messageBuffer = Buffer.allocUnsafe(messageBufferLength);\n    messageBuffer[0] = (fin ? 0x80 : 0x00) | topic;\n    messageBuffer[1] = action;\n    messageBuffer.writeUIntBE(metaLength, 2, 3);\n    messageBuffer.writeUIntBE(payloadLength, 5, 3);\n    if (meta) {\n        meta.copy(messageBuffer, constants_1.HEADER_LENGTH);\n    }\n    if (payload) {\n        payload.copy(messageBuffer, constants_1.HEADER_LENGTH + metaLength);\n    }\n    return messageBuffer;\n}\nfunction combineMultipleMessages(messages) {\n    return Buffer.concat(messages);\n}\nexports.combineMultipleMessages = combineMultipleMessages;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/buffer/index.js */ "./node_modules/buffer/index.js").Buffer))\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/message-builder.ts?')},"./binary-protocol/src/message-constants.ts":function(module,exports,__webpack_require__){"use strict";eval('\n// tslint:disable no-bitwise\nObject.defineProperty(exports, "__esModule", { value: true });\nvar META_KEYS;\n(function (META_KEYS) {\n    META_KEYS["payloadEncoding"] = "e";\n    META_KEYS["name"] = "n";\n    META_KEYS["names"] = "m";\n    META_KEYS["subscription"] = "s";\n    META_KEYS["correlationId"] = "c";\n    META_KEYS["version"] = "v";\n    META_KEYS["path"] = "p";\n    META_KEYS["reason"] = "r";\n    META_KEYS["url"] = "u";\n    META_KEYS["originalTopic"] = "t";\n    META_KEYS["originalAction"] = "a";\n    META_KEYS["protocolVersion"] = "x";\n    META_KEYS["requestorName"] = "rn";\n    META_KEYS["requestorData"] = "rd";\n    META_KEYS["trustedSender"] = "ts";\n    META_KEYS["registryTopic"] = "rt";\n})(META_KEYS = exports.META_KEYS || (exports.META_KEYS = {}));\nvar PAYLOAD_ENCODING;\n(function (PAYLOAD_ENCODING) {\n    PAYLOAD_ENCODING["JSON"] = "j";\n    PAYLOAD_ENCODING["BINARY"] = "b";\n})(PAYLOAD_ENCODING = exports.PAYLOAD_ENCODING || (exports.PAYLOAD_ENCODING = {}));\nvar TOPIC;\n(function (TOPIC) {\n    TOPIC[TOPIC["ERROR"] = 0] = "ERROR";\n    TOPIC[TOPIC["PARSER"] = 1] = "PARSER";\n    TOPIC[TOPIC["CONNECTION"] = 2] = "CONNECTION";\n    TOPIC[TOPIC["AUTH"] = 3] = "AUTH";\n    TOPIC[TOPIC["EVENT"] = 4] = "EVENT";\n    TOPIC[TOPIC["RECORD"] = 5] = "RECORD";\n    TOPIC[TOPIC["RPC"] = 6] = "RPC";\n    TOPIC[TOPIC["PRESENCE"] = 7] = "PRESENCE";\n    TOPIC[TOPIC["SUBSCRIPTIONS"] = 16] = "SUBSCRIPTIONS";\n    TOPIC[TOPIC["ONLINE_USERS"] = 17] = "ONLINE_USERS";\n    TOPIC[TOPIC["EVENT_SUBSCRIPTIONS"] = 32] = "EVENT_SUBSCRIPTIONS";\n    TOPIC[TOPIC["RECORD_SUBSCRIPTIONS"] = 33] = "RECORD_SUBSCRIPTIONS";\n    TOPIC[TOPIC["RPC_SUBSCRIPTIONS"] = 34] = "RPC_SUBSCRIPTIONS";\n    TOPIC[TOPIC["PRESENCE_SUBSCRIPTIONS"] = 35] = "PRESENCE_SUBSCRIPTIONS";\n    TOPIC[TOPIC["RECORD_LISTEN_PATTERNS"] = 36] = "RECORD_LISTEN_PATTERNS";\n    TOPIC[TOPIC["EVENT_LISTEN_PATTERNS"] = 37] = "EVENT_LISTEN_PATTERNS";\n    TOPIC[TOPIC["RECORD_PUBLISHED_SUBSCRIPTIONS"] = 38] = "RECORD_PUBLISHED_SUBSCRIPTIONS";\n    TOPIC[TOPIC["EVENT_PUBLISHED_SUBSCRIPTIONS"] = 39] = "EVENT_PUBLISHED_SUBSCRIPTIONS";\n    TOPIC[TOPIC["RECORD_LISTENING"] = 40] = "RECORD_LISTENING";\n    TOPIC[TOPIC["EVENT_LISTENING"] = 41] = "EVENT_LISTENING";\n    TOPIC[TOPIC["STATE_REGISTRY"] = 48] = "STATE_REGISTRY";\n    TOPIC[TOPIC["CLUSTER"] = 49] = "CLUSTER";\n    TOPIC[TOPIC["LOCK"] = 50] = "LOCK";\n})(TOPIC = exports.TOPIC || (exports.TOPIC = {}));\nvar PARSER_ACTIONS;\n(function (PARSER_ACTIONS) {\n    PARSER_ACTIONS[PARSER_ACTIONS["UNKNOWN_TOPIC"] = 80] = "UNKNOWN_TOPIC";\n    PARSER_ACTIONS[PARSER_ACTIONS["UNKNOWN_ACTION"] = 81] = "UNKNOWN_ACTION";\n    PARSER_ACTIONS[PARSER_ACTIONS["INVALID_MESSAGE"] = 82] = "INVALID_MESSAGE";\n    PARSER_ACTIONS[PARSER_ACTIONS["MESSAGE_PARSE_ERROR"] = 83] = "MESSAGE_PARSE_ERROR";\n    PARSER_ACTIONS[PARSER_ACTIONS["MAXIMUM_MESSAGE_SIZE_EXCEEDED"] = 84] = "MAXIMUM_MESSAGE_SIZE_EXCEEDED";\n    PARSER_ACTIONS[PARSER_ACTIONS["ERROR"] = 85] = "ERROR";\n    PARSER_ACTIONS[PARSER_ACTIONS["INVALID_META_PARAMS"] = 86] = "INVALID_META_PARAMS";\n})(PARSER_ACTIONS = exports.PARSER_ACTIONS || (exports.PARSER_ACTIONS = {}));\nvar CONNECTION_ACTIONS;\n(function (CONNECTION_ACTIONS) {\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["ERROR"] = 0] = "ERROR";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["PING"] = 1] = "PING";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["PONG"] = 2] = "PONG";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["ACCEPT"] = 3] = "ACCEPT";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["CHALLENGE"] = 4] = "CHALLENGE";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["REJECT"] = 6] = "REJECT";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["REDIRECT"] = 7] = "REDIRECT";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["CLOSING"] = 8] = "CLOSING";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["CLOSED"] = 9] = "CLOSED";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["AUTHENTICATION_TIMEOUT"] = 80] = "AUTHENTICATION_TIMEOUT";\n    CONNECTION_ACTIONS[CONNECTION_ACTIONS["INVALID_MESSAGE"] = 82] = "INVALID_MESSAGE";\n})(CONNECTION_ACTIONS = exports.CONNECTION_ACTIONS || (exports.CONNECTION_ACTIONS = {}));\nvar AUTH_ACTIONS;\n(function (AUTH_ACTIONS) {\n    AUTH_ACTIONS[AUTH_ACTIONS["ERROR"] = 0] = "ERROR";\n    AUTH_ACTIONS[AUTH_ACTIONS["REQUEST"] = 1] = "REQUEST";\n    AUTH_ACTIONS[AUTH_ACTIONS["AUTH_SUCCESSFUL"] = 2] = "AUTH_SUCCESSFUL";\n    AUTH_ACTIONS[AUTH_ACTIONS["AUTH_UNSUCCESSFUL"] = 3] = "AUTH_UNSUCCESSFUL";\n    AUTH_ACTIONS[AUTH_ACTIONS["TOO_MANY_AUTH_ATTEMPTS"] = 80] = "TOO_MANY_AUTH_ATTEMPTS";\n    AUTH_ACTIONS[AUTH_ACTIONS["INVALID_MESSAGE"] = 82] = "INVALID_MESSAGE";\n    AUTH_ACTIONS[AUTH_ACTIONS["INVALID_MESSAGE_DATA"] = 98] = "INVALID_MESSAGE_DATA";\n})(AUTH_ACTIONS = exports.AUTH_ACTIONS || (exports.AUTH_ACTIONS = {}));\nvar EVENT_ACTIONS;\n(function (EVENT_ACTIONS) {\n    EVENT_ACTIONS[EVENT_ACTIONS["ERROR"] = 0] = "ERROR";\n    EVENT_ACTIONS[EVENT_ACTIONS["EMIT"] = 1] = "EMIT";\n    EVENT_ACTIONS[EVENT_ACTIONS["SUBSCRIBE"] = 2] = "SUBSCRIBE";\n    EVENT_ACTIONS[EVENT_ACTIONS["SUBSCRIBE_ACK"] = 130] = "SUBSCRIBE_ACK";\n    EVENT_ACTIONS[EVENT_ACTIONS["UNSUBSCRIBE"] = 3] = "UNSUBSCRIBE";\n    EVENT_ACTIONS[EVENT_ACTIONS["UNSUBSCRIBE_ACK"] = 131] = "UNSUBSCRIBE_ACK";\n    EVENT_ACTIONS[EVENT_ACTIONS["SUBSCRIBE_BULK"] = 16] = "SUBSCRIBE_BULK";\n    EVENT_ACTIONS[EVENT_ACTIONS["SUBSCRIBE_BULK_ACK"] = 144] = "SUBSCRIBE_BULK_ACK";\n    EVENT_ACTIONS[EVENT_ACTIONS["UNSUBSCRIBE_BULK"] = 17] = "UNSUBSCRIBE_BULK";\n    EVENT_ACTIONS[EVENT_ACTIONS["UNSUBSCRIBE_BULK_ACK"] = 145] = "UNSUBSCRIBE_BULK_ACK";\n    EVENT_ACTIONS[EVENT_ACTIONS["LISTEN"] = 4] = "LISTEN";\n    EVENT_ACTIONS[EVENT_ACTIONS["LISTEN_ACK"] = 132] = "LISTEN_ACK";\n    EVENT_ACTIONS[EVENT_ACTIONS["UNLISTEN"] = 5] = "UNLISTEN";\n    EVENT_ACTIONS[EVENT_ACTIONS["UNLISTEN_ACK"] = 133] = "UNLISTEN_ACK";\n    EVENT_ACTIONS[EVENT_ACTIONS["LISTEN_ACCEPT"] = 6] = "LISTEN_ACCEPT";\n    EVENT_ACTIONS[EVENT_ACTIONS["LISTEN_REJECT"] = 7] = "LISTEN_REJECT";\n    EVENT_ACTIONS[EVENT_ACTIONS["SUBSCRIPTION_FOR_PATTERN_FOUND"] = 8] = "SUBSCRIPTION_FOR_PATTERN_FOUND";\n    EVENT_ACTIONS[EVENT_ACTIONS["SUBSCRIPTION_FOR_PATTERN_REMOVED"] = 9] = "SUBSCRIPTION_FOR_PATTERN_REMOVED";\n    EVENT_ACTIONS[EVENT_ACTIONS["INVALID_LISTEN_REGEX"] = 80] = "INVALID_LISTEN_REGEX";\n    EVENT_ACTIONS[EVENT_ACTIONS["MESSAGE_PERMISSION_ERROR"] = 96] = "MESSAGE_PERMISSION_ERROR";\n    EVENT_ACTIONS[EVENT_ACTIONS["MESSAGE_DENIED"] = 97] = "MESSAGE_DENIED";\n    EVENT_ACTIONS[EVENT_ACTIONS["INVALID_MESSAGE_DATA"] = 98] = "INVALID_MESSAGE_DATA";\n    EVENT_ACTIONS[EVENT_ACTIONS["MULTIPLE_SUBSCRIPTIONS"] = 99] = "MULTIPLE_SUBSCRIPTIONS";\n    EVENT_ACTIONS[EVENT_ACTIONS["NOT_SUBSCRIBED"] = 100] = "NOT_SUBSCRIBED";\n})(EVENT_ACTIONS = exports.EVENT_ACTIONS || (exports.EVENT_ACTIONS = {}));\nvar RECORD_ACTIONS;\n(function (RECORD_ACTIONS) {\n    RECORD_ACTIONS[RECORD_ACTIONS["ERROR"] = 0] = "ERROR";\n    RECORD_ACTIONS[RECORD_ACTIONS["READ"] = 1] = "READ";\n    RECORD_ACTIONS[RECORD_ACTIONS["READ_RESPONSE"] = 2] = "READ_RESPONSE";\n    RECORD_ACTIONS[RECORD_ACTIONS["HEAD"] = 3] = "HEAD";\n    RECORD_ACTIONS[RECORD_ACTIONS["HEAD_RESPONSE"] = 4] = "HEAD_RESPONSE";\n    RECORD_ACTIONS[RECORD_ACTIONS["DELETE"] = 5] = "DELETE";\n    RECORD_ACTIONS[RECORD_ACTIONS["DELETE_SUCCESS"] = 6] = "DELETE_SUCCESS";\n    RECORD_ACTIONS[RECORD_ACTIONS["DELETED"] = 8] = "DELETED";\n    RECORD_ACTIONS[RECORD_ACTIONS["WRITE_ACKNOWLEDGEMENT"] = 9] = "WRITE_ACKNOWLEDGEMENT";\n    RECORD_ACTIONS[RECORD_ACTIONS["CREATE"] = 16] = "CREATE";\n    RECORD_ACTIONS[RECORD_ACTIONS["CREATEANDUPDATE"] = 17] = "CREATEANDUPDATE";\n    RECORD_ACTIONS[RECORD_ACTIONS["CREATEANDUPDATE_WITH_WRITE_ACK"] = 18] = "CREATEANDUPDATE_WITH_WRITE_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["CREATEANDPATCH"] = 19] = "CREATEANDPATCH";\n    RECORD_ACTIONS[RECORD_ACTIONS["CREATEANDPATCH_WITH_WRITE_ACK"] = 20] = "CREATEANDPATCH_WITH_WRITE_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["UPDATE"] = 21] = "UPDATE";\n    RECORD_ACTIONS[RECORD_ACTIONS["UPDATE_WITH_WRITE_ACK"] = 22] = "UPDATE_WITH_WRITE_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["PATCH"] = 23] = "PATCH";\n    RECORD_ACTIONS[RECORD_ACTIONS["PATCH_WITH_WRITE_ACK"] = 24] = "PATCH_WITH_WRITE_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["ERASE"] = 25] = "ERASE";\n    RECORD_ACTIONS[RECORD_ACTIONS["ERASE_WITH_WRITE_ACK"] = 26] = "ERASE_WITH_WRITE_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBEANDHEAD"] = 32] = "SUBSCRIBEANDHEAD";\n    // SUBSCRIBEANDHEAD_RESPONSE = 0x21,\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBEANDHEAD_BULK"] = 112] = "SUBSCRIBEANDHEAD_BULK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBEANDHEAD_BULK_ACK"] = 240] = "SUBSCRIBEANDHEAD_BULK_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBEANDREAD"] = 34] = "SUBSCRIBEANDREAD";\n    // SUBSCRIBEANDREAD_RESPONSE = 0x23,\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBEANDREAD_BULK"] = 35] = "SUBSCRIBEANDREAD_BULK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBEANDREAD_BULK_ACK"] = 163] = "SUBSCRIBEANDREAD_BULK_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBECREATEANDREAD"] = 36] = "SUBSCRIBECREATEANDREAD";\n    // SUBSCRIBECREATEANDREAD_RESPONSE = 0x25,\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBECREATEANDREAD_BULK"] = 37] = "SUBSCRIBECREATEANDREAD_BULK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBECREATEANDREAD_BULK_ACK"] = 165] = "SUBSCRIBECREATEANDREAD_BULK_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBECREATEANDUPDATE"] = 38] = "SUBSCRIBECREATEANDUPDATE";\n    // SUBSCRIBECREATEANDUPDATE_RESPONSE = 0x27,\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBECREATEANDUPDATE_BULK"] = 38] = "SUBSCRIBECREATEANDUPDATE_BULK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBE"] = 40] = "SUBSCRIBE";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBE_ACK"] = 168] = "SUBSCRIBE_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIBE_BULK"] = 120] = "SUBSCRIBE_BULK";\n    RECORD_ACTIONS[RECORD_ACTIONS["UNSUBSCRIBE"] = 41] = "UNSUBSCRIBE";\n    RECORD_ACTIONS[RECORD_ACTIONS["UNSUBSCRIBE_BULK"] = 57] = "UNSUBSCRIBE_BULK";\n    RECORD_ACTIONS[RECORD_ACTIONS["UNSUBSCRIBE_ACK"] = 169] = "UNSUBSCRIBE_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["LISTEN"] = 48] = "LISTEN";\n    RECORD_ACTIONS[RECORD_ACTIONS["LISTEN_ACK"] = 176] = "LISTEN_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["UNLISTEN"] = 49] = "UNLISTEN";\n    RECORD_ACTIONS[RECORD_ACTIONS["UNLISTEN_ACK"] = 177] = "UNLISTEN_ACK";\n    RECORD_ACTIONS[RECORD_ACTIONS["LISTEN_ACCEPT"] = 50] = "LISTEN_ACCEPT";\n    RECORD_ACTIONS[RECORD_ACTIONS["LISTEN_REJECT"] = 51] = "LISTEN_REJECT";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIPTION_HAS_PROVIDER"] = 52] = "SUBSCRIPTION_HAS_PROVIDER";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIPTION_HAS_NO_PROVIDER"] = 53] = "SUBSCRIPTION_HAS_NO_PROVIDER";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIPTION_FOR_PATTERN_FOUND"] = 54] = "SUBSCRIPTION_FOR_PATTERN_FOUND";\n    RECORD_ACTIONS[RECORD_ACTIONS["SUBSCRIPTION_FOR_PATTERN_REMOVED"] = 55] = "SUBSCRIPTION_FOR_PATTERN_REMOVED";\n    RECORD_ACTIONS[RECORD_ACTIONS["CACHE_RETRIEVAL_TIMEOUT"] = 80] = "CACHE_RETRIEVAL_TIMEOUT";\n    RECORD_ACTIONS[RECORD_ACTIONS["STORAGE_RETRIEVAL_TIMEOUT"] = 81] = "STORAGE_RETRIEVAL_TIMEOUT";\n    RECORD_ACTIONS[RECORD_ACTIONS["VERSION_EXISTS"] = 82] = "VERSION_EXISTS";\n    RECORD_ACTIONS[RECORD_ACTIONS["RECORD_LOAD_ERROR"] = 83] = "RECORD_LOAD_ERROR";\n    RECORD_ACTIONS[RECORD_ACTIONS["RECORD_CREATE_ERROR"] = 84] = "RECORD_CREATE_ERROR";\n    RECORD_ACTIONS[RECORD_ACTIONS["RECORD_UPDATE_ERROR"] = 85] = "RECORD_UPDATE_ERROR";\n    RECORD_ACTIONS[RECORD_ACTIONS["RECORD_DELETE_ERROR"] = 86] = "RECORD_DELETE_ERROR";\n    RECORD_ACTIONS[RECORD_ACTIONS["RECORD_NOT_FOUND"] = 88] = "RECORD_NOT_FOUND";\n    RECORD_ACTIONS[RECORD_ACTIONS["INVALID_VERSION"] = 89] = "INVALID_VERSION";\n    RECORD_ACTIONS[RECORD_ACTIONS["INVALID_PATCH_ON_HOTPATH"] = 90] = "INVALID_PATCH_ON_HOTPATH";\n    RECORD_ACTIONS[RECORD_ACTIONS["INVALID_LISTEN_REGEX"] = 91] = "INVALID_LISTEN_REGEX";\n    RECORD_ACTIONS[RECORD_ACTIONS["MESSAGE_PERMISSION_ERROR"] = 96] = "MESSAGE_PERMISSION_ERROR";\n    RECORD_ACTIONS[RECORD_ACTIONS["MESSAGE_DENIED"] = 97] = "MESSAGE_DENIED";\n    RECORD_ACTIONS[RECORD_ACTIONS["INVALID_MESSAGE_DATA"] = 98] = "INVALID_MESSAGE_DATA";\n    RECORD_ACTIONS[RECORD_ACTIONS["MULTIPLE_SUBSCRIPTIONS"] = 99] = "MULTIPLE_SUBSCRIPTIONS";\n    RECORD_ACTIONS[RECORD_ACTIONS["NOT_SUBSCRIBED"] = 100] = "NOT_SUBSCRIBED";\n})(RECORD_ACTIONS = exports.RECORD_ACTIONS || (exports.RECORD_ACTIONS = {}));\nvar RPC_ACTIONS;\n(function (RPC_ACTIONS) {\n    RPC_ACTIONS[RPC_ACTIONS["ERROR"] = 0] = "ERROR";\n    RPC_ACTIONS[RPC_ACTIONS["REQUEST"] = 1] = "REQUEST";\n    RPC_ACTIONS[RPC_ACTIONS["ACCEPT"] = 2] = "ACCEPT";\n    RPC_ACTIONS[RPC_ACTIONS["RESPONSE"] = 3] = "RESPONSE";\n    RPC_ACTIONS[RPC_ACTIONS["REJECT"] = 4] = "REJECT";\n    RPC_ACTIONS[RPC_ACTIONS["REQUEST_ERROR"] = 5] = "REQUEST_ERROR";\n    RPC_ACTIONS[RPC_ACTIONS["PROVIDE"] = 6] = "PROVIDE";\n    RPC_ACTIONS[RPC_ACTIONS["PROVIDE_ACK"] = 134] = "PROVIDE_ACK";\n    RPC_ACTIONS[RPC_ACTIONS["UNPROVIDE"] = 7] = "UNPROVIDE";\n    RPC_ACTIONS[RPC_ACTIONS["UNPROVIDE_ACK"] = 135] = "UNPROVIDE_ACK";\n    RPC_ACTIONS[RPC_ACTIONS["NO_RPC_PROVIDER"] = 80] = "NO_RPC_PROVIDER";\n    RPC_ACTIONS[RPC_ACTIONS["ACCEPT_TIMEOUT"] = 82] = "ACCEPT_TIMEOUT";\n    RPC_ACTIONS[RPC_ACTIONS["MULTIPLE_ACCEPT"] = 83] = "MULTIPLE_ACCEPT";\n    RPC_ACTIONS[RPC_ACTIONS["INVALID_RPC_CORRELATION_ID"] = 84] = "INVALID_RPC_CORRELATION_ID";\n    RPC_ACTIONS[RPC_ACTIONS["RESPONSE_TIMEOUT"] = 85] = "RESPONSE_TIMEOUT";\n    RPC_ACTIONS[RPC_ACTIONS["MULTIPLE_RESPONSE"] = 86] = "MULTIPLE_RESPONSE";\n    RPC_ACTIONS[RPC_ACTIONS["MESSAGE_PERMISSION_ERROR"] = 96] = "MESSAGE_PERMISSION_ERROR";\n    RPC_ACTIONS[RPC_ACTIONS["MESSAGE_DENIED"] = 97] = "MESSAGE_DENIED";\n    RPC_ACTIONS[RPC_ACTIONS["INVALID_MESSAGE_DATA"] = 98] = "INVALID_MESSAGE_DATA";\n    RPC_ACTIONS[RPC_ACTIONS["MULTIPLE_PROVIDERS"] = 99] = "MULTIPLE_PROVIDERS";\n    RPC_ACTIONS[RPC_ACTIONS["NOT_PROVIDED"] = 100] = "NOT_PROVIDED";\n})(RPC_ACTIONS = exports.RPC_ACTIONS || (exports.RPC_ACTIONS = {}));\nvar PRESENCE_ACTIONS;\n(function (PRESENCE_ACTIONS) {\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["ERROR"] = 0] = "ERROR";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["QUERY_ALL"] = 1] = "QUERY_ALL";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["QUERY_ALL_RESPONSE"] = 2] = "QUERY_ALL_RESPONSE";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["QUERY"] = 3] = "QUERY";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["QUERY_RESPONSE"] = 4] = "QUERY_RESPONSE";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["PRESENCE_JOIN"] = 5] = "PRESENCE_JOIN";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["PRESENCE_JOIN_ALL"] = 6] = "PRESENCE_JOIN_ALL";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["PRESENCE_LEAVE"] = 7] = "PRESENCE_LEAVE";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["PRESENCE_LEAVE_ALL"] = 8] = "PRESENCE_LEAVE_ALL";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["SUBSCRIBE_BULK"] = 9] = "SUBSCRIBE_BULK";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["SUBSCRIBE_BULK_ACK"] = 137] = "SUBSCRIBE_BULK_ACK";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["UNSUBSCRIBE_BULK"] = 10] = "UNSUBSCRIBE_BULK";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["UNSUBSCRIBE_BULK_ACK"] = 138] = "UNSUBSCRIBE_BULK_ACK";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["SUBSCRIBE_ALL"] = 11] = "SUBSCRIBE_ALL";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["SUBSCRIBE_ALL_ACK"] = 139] = "SUBSCRIBE_ALL_ACK";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["UNSUBSCRIBE_ALL"] = 12] = "UNSUBSCRIBE_ALL";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["UNSUBSCRIBE_ALL_ACK"] = 140] = "UNSUBSCRIBE_ALL_ACK";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["SUBSCRIBE"] = 153] = "SUBSCRIBE";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["UNSUBSCRIBE"] = 152] = "UNSUBSCRIBE";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["INVALID_PRESENCE_USERS"] = 80] = "INVALID_PRESENCE_USERS";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["MESSAGE_PERMISSION_ERROR"] = 96] = "MESSAGE_PERMISSION_ERROR";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["MESSAGE_DENIED"] = 97] = "MESSAGE_DENIED";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["MULTIPLE_SUBSCRIPTIONS"] = 99] = "MULTIPLE_SUBSCRIPTIONS";\n    PRESENCE_ACTIONS[PRESENCE_ACTIONS["NOT_SUBSCRIBED"] = 100] = "NOT_SUBSCRIBED";\n})(PRESENCE_ACTIONS = exports.PRESENCE_ACTIONS || (exports.PRESENCE_ACTIONS = {}));\nvar LOCK_ACTIONS;\n(function (LOCK_ACTIONS) {\n    LOCK_ACTIONS[LOCK_ACTIONS["ERROR"] = 0] = "ERROR";\n    LOCK_ACTIONS[LOCK_ACTIONS["REQUEST"] = 1] = "REQUEST";\n    LOCK_ACTIONS[LOCK_ACTIONS["RESPONSE"] = 2] = "RESPONSE";\n    LOCK_ACTIONS[LOCK_ACTIONS["RELEASE"] = 3] = "RELEASE";\n})(LOCK_ACTIONS = exports.LOCK_ACTIONS || (exports.LOCK_ACTIONS = {}));\nvar STATE_ACTIONS;\n(function (STATE_ACTIONS) {\n    STATE_ACTIONS[STATE_ACTIONS["ERROR"] = 0] = "ERROR";\n    STATE_ACTIONS[STATE_ACTIONS["ADD"] = 1] = "ADD";\n    STATE_ACTIONS[STATE_ACTIONS["REMOVE"] = 2] = "REMOVE";\n    STATE_ACTIONS[STATE_ACTIONS["REQUEST_FULL_STATE"] = 3] = "REQUEST_FULL_STATE";\n    STATE_ACTIONS[STATE_ACTIONS["FULL_STATE"] = 4] = "FULL_STATE";\n})(STATE_ACTIONS = exports.STATE_ACTIONS || (exports.STATE_ACTIONS = {}));\nvar CLUSTER_ACTIONS;\n(function (CLUSTER_ACTIONS) {\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["PING"] = 0] = "PING";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["PONG"] = 1] = "PONG";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["CLOSE"] = 2] = "CLOSE";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["REJECT"] = 3] = "REJECT";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["REJECT_DUPLICATE"] = 4] = "REJECT_DUPLICATE";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["IDENTIFICATION_REQUEST"] = 5] = "IDENTIFICATION_REQUEST";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["IDENTIFICATION_RESPONSE"] = 6] = "IDENTIFICATION_RESPONSE";\n    CLUSTER_ACTIONS[CLUSTER_ACTIONS["KNOWN_PEERS"] = 7] = "KNOWN_PEERS";\n})(CLUSTER_ACTIONS = exports.CLUSTER_ACTIONS || (exports.CLUSTER_ACTIONS = {}));\nexports.ACTIONS = {\n    [TOPIC.PARSER]: PARSER_ACTIONS,\n    [TOPIC.CONNECTION]: CONNECTION_ACTIONS,\n    [TOPIC.AUTH]: AUTH_ACTIONS,\n    [TOPIC.EVENT]: EVENT_ACTIONS,\n    [TOPIC.RECORD]: RECORD_ACTIONS,\n    [TOPIC.RPC]: RPC_ACTIONS,\n    [TOPIC.PRESENCE]: PRESENCE_ACTIONS,\n    [TOPIC.LOCK]: LOCK_ACTIONS,\n    [TOPIC.STATE_REGISTRY]: STATE_ACTIONS,\n    [TOPIC.CLUSTER]: CLUSTER_ACTIONS\n};\n\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/message-constants.ts?')},"./binary-protocol/src/message-parser.ts":function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n/* tslint:disable:no-bitwise */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ./message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"./binary-protocol/src/constants.ts\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./binary-protocol/src/utils.ts\");\nconst message_validator_1 = __webpack_require__(/*! ./message-validator */ \"./binary-protocol/src/message-validator.ts\");\nfunction isError(message) {\n    return (message.action >= 0x50 && message.action < 0x70) || message.topic === message_constants_1.TOPIC.PARSER;\n}\nexports.isError = isError;\nconst BULK_ACTIONS = {\n    [message_constants_1.TOPIC.RECORD]: {\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD_BULK]: message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD,\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD_BULK]: message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD,\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD_BULK]: message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD,\n    },\n    [message_constants_1.TOPIC.EVENT]: {\n        [message_constants_1.EVENT_ACTIONS.SUBSCRIBE_BULK]: message_constants_1.EVENT_ACTIONS.SUBSCRIBE,\n        [message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE_BULK]: message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE,\n    }\n};\nlet uuid = 0;\nfunction parse(buffer, queue = []) {\n    let offset = 0;\n    const messages = [];\n    do {\n        const { bytesConsumed, rawMessage } = readBinary(buffer, offset);\n        if (!rawMessage) {\n            break;\n        }\n        queue.push(rawMessage);\n        offset += bytesConsumed;\n        if (rawMessage.fin) {\n            const joinedMessage = joinMessages(queue);\n            const message = parseMessage(joinedMessage);\n            // @ts-ignore\n            if (message.parseError === undefined && !message.isAck && BULK_ACTIONS[message.topic] && BULK_ACTIONS[message.topic][message.action]) {\n                // @ts-ignore\n                const action = BULK_ACTIONS[message.topic][message.action];\n                uuid++;\n                message.names.forEach(name => {\n                    messages.push({\n                        topic: message.topic,\n                        action,\n                        name,\n                        correlationId: message.correlationId,\n                        isBulk: true,\n                        bulkId: uuid,\n                        bulkAction: message.action\n                    });\n                });\n            }\n            else {\n                messages.push(message);\n            }\n            queue.length = 0;\n        }\n    } while (offset < buffer.length);\n    return messages;\n}\nexports.parse = parse;\nfunction parseData(message) {\n    if (message.parsedData !== undefined || message.data === undefined) {\n        return true;\n    }\n    if (message.payloadEncoding && message.payloadEncoding !== message_constants_1.PAYLOAD_ENCODING.JSON) {\n        return new Error(`unable to parse data of type '${message.payloadEncoding}'`);\n    }\n    if (typeof message.data === 'string') {\n        return new Error('tried to parse string data with binary parser');\n    }\n    message.parsedData = parseJSON(message.data);\n    if (message.parsedData === undefined) {\n        return new Error(`unable to parse data ${message.data}`);\n    }\n    return true;\n}\nexports.parseData = parseData;\nfunction readBinary(buff, offset) {\n    if (buff.length < (offset + constants_1.HEADER_LENGTH)) {\n        return { bytesConsumed: 0 };\n    }\n    const fin = !!(buff[offset] & 0x80);\n    const topic = buff[offset] & 0x7F;\n    const action = buff[offset + 1];\n    const metaLength = buff.readUIntBE(offset + 2, 3);\n    const payloadLength = buff.readUIntBE(offset + 5, 3);\n    const messageLength = constants_1.HEADER_LENGTH + metaLength + payloadLength;\n    if (buff.length < (offset + messageLength)) {\n        return { bytesConsumed: 0 };\n    }\n    const rawHeader = buff.slice(offset, offset + constants_1.HEADER_LENGTH);\n    const rawMessage = { fin, topic, action, rawHeader };\n    if (metaLength > 0) {\n        rawMessage.meta = buff.slice(offset + constants_1.HEADER_LENGTH, offset + constants_1.HEADER_LENGTH + metaLength);\n    }\n    if (payloadLength > 0) {\n        rawMessage.payload = buff.slice(offset + constants_1.HEADER_LENGTH + metaLength, offset + messageLength);\n    }\n    return {\n        bytesConsumed: messageLength,\n        rawMessage,\n    };\n}\nfunction joinMessages(rawMessages) {\n    if (rawMessages.length === 0) {\n        throw new Error('parseMessage must not be called with an empty message queue');\n    }\n    if (rawMessages.length === 1) {\n        return rawMessages[0];\n    }\n    const { topic, action, rawHeader } = rawMessages[0];\n    const payloadSections = [];\n    const metaSections = [];\n    rawMessages.forEach(({ payload: payloadSection, meta: metaSection }) => {\n        if (payloadSection) {\n            payloadSections.push(payloadSection);\n        }\n        if (metaSection) {\n            metaSections.push(metaSection);\n        }\n    });\n    const payload = Buffer.concat(payloadSections);\n    const meta = Buffer.concat(metaSections);\n    return { fin: true, topic, action, rawHeader, meta, payload };\n}\nfunction parseMessage(rawMessage) {\n    const { topic: rawTopic, action: rawAction, rawHeader } = rawMessage;\n    if (message_constants_1.TOPIC[rawTopic] === undefined) {\n        return {\n            parseError: true,\n            action: message_constants_1.PARSER_ACTIONS.UNKNOWN_TOPIC,\n            parsedMessage: {\n                topic: rawTopic,\n                action: rawAction\n            },\n            description: `unknown topic ${rawTopic}`,\n            raw: rawHeader\n        };\n    }\n    const topic = rawTopic;\n    if (message_constants_1.ACTIONS[topic][rawAction] === undefined) {\n        return {\n            parseError: true,\n            action: message_constants_1.PARSER_ACTIONS.UNKNOWN_ACTION,\n            parsedMessage: {\n                topic,\n                action: rawAction\n            },\n            description: `unknown ${message_constants_1.TOPIC[topic]} action ${rawAction}`,\n            raw: rawHeader\n        };\n    }\n    // mask out uppermost bit(ACK)\n    const action = rawAction & 0x7F;\n    const message = { topic, action };\n    if (rawMessage.meta && rawMessage.meta.length > 0) {\n        const meta = parseJSON(rawMessage.meta);\n        if (!meta || typeof meta !== 'object') {\n            return {\n                parseError: true,\n                action: message_constants_1.PARSER_ACTIONS.MESSAGE_PARSE_ERROR,\n                parsedMessage: message,\n                description: `invalid meta field ${rawMessage.meta.toString()}`,\n                raw: rawHeader\n            };\n        }\n        const metaError = message_validator_1.validateMeta(topic, rawAction, meta);\n        if (metaError) {\n            throw new Error(`invalid meta ${message_constants_1.TOPIC[message.topic]} ${message_constants_1.ACTIONS[message.topic][message.action]}: ${metaError}`);\n            // return {\n            //   parseError: true,\n            //   action: PARSER_ACTIONS.INVALID_META_PARAMS,\n            //   parsedMessage: message,\n            //   description: 'invalid ack'\n            // }\n        }\n        addMetadataToMessage(meta, message);\n    }\n    if (rawMessage.payload !== undefined) {\n        if (!message_validator_1.hasPayload(message.topic, rawAction)) {\n            return {\n                parseError: true,\n                action: message_constants_1.PARSER_ACTIONS.INVALID_MESSAGE,\n                parsedMessage: message,\n                description: 'should not have a payload'\n            };\n        }\n        if (!message.payloadEncoding && topic === message_constants_1.TOPIC.PARSER) {\n            message.payloadEncoding = message_constants_1.PAYLOAD_ENCODING.BINARY;\n        }\n        message.data = rawMessage.payload;\n    }\n    // if (rawMessage.payload && rawMessage.payload.length > 0) {\n    //   const payload = parseJSON(rawMessage.payload)\n    //   if (payload === undefined) {\n    //     return {\n    //       parseError: true,\n    //       description: `invalid message data ${rawMessage.payload.toString()}`,\n    //       parsedMessage: message,\n    //       raw: rawHeader\n    //     }\n    //   }\n    //   message.data = payload\n    // }\n    message.isAck = rawAction >= 0x80;\n    if (!message.isAck && rawAction >= 0x70) {\n        // Only add onto message if it's true\n        message.isBulk = true;\n    }\n    message.isError = isError(message);\n    if (message.topic === message_constants_1.TOPIC.RECORD && utils_1.isWriteAck(rawAction)) {\n        message.isWriteAck = true;\n    }\n    return message;\n}\nfunction addMetadataToMessage(meta, message) {\n    for (const key in message_constants_1.META_KEYS) {\n        const value = meta[message_constants_1.META_KEYS[key]];\n        if (value !== undefined) {\n            message[key] = value;\n        }\n    }\n}\nfunction parseJSON(buff) {\n    try {\n        return JSON.parse(buff.toString());\n    }\n    catch (err) {\n        return undefined;\n    }\n}\nexports.parseJSON = parseJSON;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/message-parser.ts?")},"./binary-protocol/src/message-validator.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ./message-constants */ \"./binary-protocol/src/message-constants.ts\");\n/*\n * Specification of  fields within Meta Params used for message validation\n * (see `validateMeta`)\n *\n * META_PARAMS_SPEC[topic][action] => [required, optional]\n * The keys in `required` must be present in all instances of the message\n * The keys in `optional` may be present in some instances of the message\n */\nexports.META_PARAMS_SPEC = {\n    [message_constants_1.TOPIC.PARSER]: {\n        [message_constants_1.PARSER_ACTIONS.UNKNOWN_TOPIC]: [[message_constants_1.META_KEYS.originalTopic], []],\n        [message_constants_1.PARSER_ACTIONS.UNKNOWN_ACTION]: [[message_constants_1.META_KEYS.originalTopic, message_constants_1.META_KEYS.originalAction], []],\n        [message_constants_1.PARSER_ACTIONS.INVALID_MESSAGE]: [[], []],\n        [message_constants_1.PARSER_ACTIONS.INVALID_META_PARAMS]: [[message_constants_1.META_KEYS.originalTopic, message_constants_1.META_KEYS.originalAction], []],\n    },\n    [message_constants_1.TOPIC.CONNECTION]: {\n        [message_constants_1.CONNECTION_ACTIONS.PING]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.PONG]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.CHALLENGE]: [[message_constants_1.META_KEYS.url, message_constants_1.META_KEYS.protocolVersion], []],\n        [message_constants_1.CONNECTION_ACTIONS.ACCEPT]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.REJECT]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.REDIRECT]: [[message_constants_1.META_KEYS.url], []],\n        [message_constants_1.CONNECTION_ACTIONS.CLOSING]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.CLOSED]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.ERROR]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.AUTHENTICATION_TIMEOUT]: [[], []],\n        [message_constants_1.CONNECTION_ACTIONS.INVALID_MESSAGE]: [[message_constants_1.META_KEYS.originalTopic, message_constants_1.META_KEYS.originalAction], []],\n    },\n    [message_constants_1.TOPIC.AUTH]: {\n        [message_constants_1.AUTH_ACTIONS.REQUEST]: [[], []],\n        [message_constants_1.AUTH_ACTIONS.AUTH_SUCCESSFUL]: [[], []],\n        [message_constants_1.AUTH_ACTIONS.AUTH_UNSUCCESSFUL]: [[], []],\n        [message_constants_1.AUTH_ACTIONS.TOO_MANY_AUTH_ATTEMPTS]: [[], []],\n        [message_constants_1.AUTH_ACTIONS.INVALID_MESSAGE]: [[message_constants_1.META_KEYS.originalTopic, message_constants_1.META_KEYS.originalAction], []],\n        [message_constants_1.AUTH_ACTIONS.INVALID_MESSAGE_DATA]: [[message_constants_1.META_KEYS.originalAction], []],\n    },\n    [message_constants_1.TOPIC.RECORD]: {\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBE_BULK]: [[message_constants_1.META_KEYS.names], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBE_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.MULTIPLE_SUBSCRIPTIONS]: [[message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.originalAction]],\n        [message_constants_1.RECORD_ACTIONS.NOT_SUBSCRIBED]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.HEAD]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD_BULK]: [[message_constants_1.META_KEYS.names], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD_BULK_ACK]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RECORD_ACTIONS.HEAD_RESPONSE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], []],\n        [message_constants_1.RECORD_ACTIONS.READ]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD_BULK]: [[message_constants_1.META_KEYS.names], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD_BULK_ACK]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RECORD_ACTIONS.READ_RESPONSE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], []],\n        [message_constants_1.RECORD_ACTIONS.UPDATE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], []],\n        [message_constants_1.RECORD_ACTIONS.UPDATE_WITH_WRITE_ACK]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RECORD_ACTIONS.PATCH]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path], []],\n        [message_constants_1.RECORD_ACTIONS.PATCH_WITH_WRITE_ACK]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RECORD_ACTIONS.ERASE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path], []],\n        [message_constants_1.RECORD_ACTIONS.ERASE_WITH_WRITE_ACK]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDUPDATE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], []],\n        [message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE_WITH_WRITE_ACK]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RECORD_ACTIONS.CREATEANDPATCH]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path], []],\n        [message_constants_1.RECORD_ACTIONS.CREATEANDPATCH_WITH_WRITE_ACK]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version, message_constants_1.META_KEYS.path, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RECORD_ACTIONS.DELETE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.DELETED]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD_BULK]: [[message_constants_1.META_KEYS.names], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD_BULK_ACK]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_PROVIDER]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_NO_PROVIDER]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.WRITE_ACKNOWLEDGEMENT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RECORD_ACTIONS.VERSION_EXISTS]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.version], [message_constants_1.META_KEYS.originalAction]],\n        [message_constants_1.RECORD_ACTIONS.CACHE_RETRIEVAL_TIMEOUT]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.STORAGE_RETRIEVAL_TIMEOUT]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.RECORD_LOAD_ERROR]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.RECORD_CREATE_ERROR]: [[message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.originalAction]],\n        [message_constants_1.RECORD_ACTIONS.RECORD_UPDATE_ERROR]: [[message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.originalAction]],\n        [message_constants_1.RECORD_ACTIONS.RECORD_DELETE_ERROR]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.RECORD_NOT_FOUND]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.originalAction], []],\n        [message_constants_1.RECORD_ACTIONS.INVALID_VERSION]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.RECORD_ACTIONS.INVALID_PATCH_ON_HOTPATH]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.RECORD_ACTIONS.LISTEN]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.LISTEN_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.UNLISTEN]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.UNLISTEN_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.RECORD_ACTIONS.LISTEN_ACCEPT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.RECORD_ACTIONS.LISTEN_REJECT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.RECORD_ACTIONS.INVALID_LISTEN_REGEX]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RECORD_ACTIONS.MESSAGE_PERMISSION_ERROR]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.RECORD_ACTIONS.INVALID_MESSAGE_DATA]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId]],\n    },\n    [message_constants_1.TOPIC.RPC]: {\n        [message_constants_1.RPC_ACTIONS.REQUEST_ERROR]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], [message_constants_1.META_KEYS.reason]],\n        [message_constants_1.RPC_ACTIONS.REQUEST]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], [message_constants_1.META_KEYS.requestorName, message_constants_1.META_KEYS.requestorData, message_constants_1.META_KEYS.trustedSender]],\n        [message_constants_1.RPC_ACTIONS.ACCEPT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.REJECT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.RESPONSE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.PROVIDE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RPC_ACTIONS.PROVIDE_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RPC_ACTIONS.UNPROVIDE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RPC_ACTIONS.UNPROVIDE_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.RPC_ACTIONS.MULTIPLE_PROVIDERS]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.NOT_PROVIDED]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.MULTIPLE_RESPONSE]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.RESPONSE_TIMEOUT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.INVALID_RPC_CORRELATION_ID]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.originalAction], []],\n        [message_constants_1.RPC_ACTIONS.MULTIPLE_ACCEPT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.ACCEPT_TIMEOUT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.RPC_ACTIONS.MESSAGE_PERMISSION_ERROR]: [[message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.RPC_ACTIONS.MESSAGE_DENIED]: [[message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.RPC_ACTIONS.INVALID_MESSAGE_DATA]: [[message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.correlationId]],\n    },\n    [message_constants_1.TOPIC.EVENT]: {\n        [message_constants_1.EVENT_ACTIONS.EMIT]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.SUBSCRIBE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.SUBSCRIBE_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.SUBSCRIBE_BULK]: [[message_constants_1.META_KEYS.names, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.EVENT_ACTIONS.SUBSCRIBE_BULK_ACK]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE_BULK]: [[message_constants_1.META_KEYS.names, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE_BULK_ACK]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.EVENT_ACTIONS.MULTIPLE_SUBSCRIPTIONS]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.NOT_SUBSCRIBED]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.MESSAGE_PERMISSION_ERROR]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.MESSAGE_DENIED]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.LISTEN]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.LISTEN_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.UNLISTEN]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.UNLISTEN_ACK]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.EVENT_ACTIONS.LISTEN_ACCEPT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.EVENT_ACTIONS.LISTEN_REJECT]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.subscription], []],\n        [message_constants_1.EVENT_ACTIONS.INVALID_LISTEN_REGEX]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.MESSAGE_PERMISSION_ERROR]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.MESSAGE_DENIED]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], []],\n        [message_constants_1.EVENT_ACTIONS.INVALID_MESSAGE_DATA]: [[message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.originalAction], []],\n    },\n    [message_constants_1.TOPIC.PRESENCE]: {\n        [message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_BULK]: [[message_constants_1.META_KEYS.names, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_BULK_ACK]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_ALL]: [[], []],\n        [message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_ALL_ACK]: [[], []],\n        [message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_BULK]: [[message_constants_1.META_KEYS.names, message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_BULK_ACK]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_ALL]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_ALL_ACK]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.PRESENCE_ACTIONS.NOT_SUBSCRIBED]: [[], [message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.PRESENCE_ACTIONS.MULTIPLE_SUBSCRIPTIONS]: [[], [message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.name, message_constants_1.META_KEYS.originalAction]],\n        [message_constants_1.PRESENCE_ACTIONS.QUERY]: [[message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.names], []],\n        [message_constants_1.PRESENCE_ACTIONS.QUERY_RESPONSE]: [[message_constants_1.META_KEYS.correlationId], []],\n        [message_constants_1.PRESENCE_ACTIONS.QUERY_ALL]: [[], []],\n        [message_constants_1.PRESENCE_ACTIONS.QUERY_ALL_RESPONSE]: [[message_constants_1.META_KEYS.names], []],\n        [message_constants_1.PRESENCE_ACTIONS.PRESENCE_JOIN]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.PRESENCE_ACTIONS.PRESENCE_LEAVE]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.PRESENCE_ACTIONS.PRESENCE_JOIN_ALL]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.PRESENCE_ACTIONS.PRESENCE_LEAVE_ALL]: [[message_constants_1.META_KEYS.name], []],\n        [message_constants_1.PRESENCE_ACTIONS.INVALID_PRESENCE_USERS]: [[], []],\n        [message_constants_1.PRESENCE_ACTIONS.MESSAGE_PERMISSION_ERROR]: [[message_constants_1.META_KEYS.originalAction, message_constants_1.META_KEYS.name], [message_constants_1.META_KEYS.correlationId]],\n        [message_constants_1.PRESENCE_ACTIONS.MESSAGE_DENIED]: [[message_constants_1.META_KEYS.originalAction], [message_constants_1.META_KEYS.correlationId, message_constants_1.META_KEYS.name]],\n    },\n    [message_constants_1.TOPIC.CLUSTER]: {\n        [message_constants_1.CLUSTER_ACTIONS.CLOSE]: [[], []],\n        [message_constants_1.CLUSTER_ACTIONS.IDENTIFICATION_REQUEST]: [[], []],\n        [message_constants_1.CLUSTER_ACTIONS.IDENTIFICATION_RESPONSE]: [[], []],\n        [message_constants_1.CLUSTER_ACTIONS.KNOWN_PEERS]: [[], []],\n        [message_constants_1.CLUSTER_ACTIONS.PING]: [[], []],\n        [message_constants_1.CLUSTER_ACTIONS.PONG]: [[], []],\n        [message_constants_1.CLUSTER_ACTIONS.REJECT]: [[], []],\n        [message_constants_1.CLUSTER_ACTIONS.REJECT_DUPLICATE]: [[], []]\n    },\n    [message_constants_1.TOPIC.STATE_REGISTRY]: {\n        [message_constants_1.STATE_ACTIONS.ERROR]: [[message_constants_1.META_KEYS.registryTopic], []],\n        [message_constants_1.STATE_ACTIONS.ADD]: [[message_constants_1.META_KEYS.registryTopic], []],\n        [message_constants_1.STATE_ACTIONS.REMOVE]: [[message_constants_1.META_KEYS.registryTopic], []],\n        [message_constants_1.STATE_ACTIONS.REQUEST_FULL_STATE]: [[message_constants_1.META_KEYS.registryTopic], []],\n        [message_constants_1.STATE_ACTIONS.FULL_STATE]: [[message_constants_1.META_KEYS.registryTopic], []]\n    },\n    [message_constants_1.TOPIC.LOCK]: {}\n};\nconst payloadMap = {\n    [message_constants_1.TOPIC.PARSER]: [\n        message_constants_1.PARSER_ACTIONS.MESSAGE_PARSE_ERROR,\n        message_constants_1.PARSER_ACTIONS.INVALID_META_PARAMS,\n    ],\n    [message_constants_1.TOPIC.AUTH]: [\n        message_constants_1.AUTH_ACTIONS.REQUEST,\n        message_constants_1.AUTH_ACTIONS.AUTH_SUCCESSFUL,\n        message_constants_1.AUTH_ACTIONS.AUTH_UNSUCCESSFUL,\n    ],\n    [message_constants_1.TOPIC.RECORD]: [\n        message_constants_1.RECORD_ACTIONS.READ_RESPONSE,\n        message_constants_1.RECORD_ACTIONS.UPDATE,\n        message_constants_1.RECORD_ACTIONS.UPDATE_WITH_WRITE_ACK,\n        message_constants_1.RECORD_ACTIONS.PATCH,\n        message_constants_1.RECORD_ACTIONS.PATCH_WITH_WRITE_ACK,\n        message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE,\n        message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE_WITH_WRITE_ACK,\n        message_constants_1.RECORD_ACTIONS.CREATEANDPATCH,\n        message_constants_1.RECORD_ACTIONS.CREATEANDPATCH_WITH_WRITE_ACK,\n        message_constants_1.RECORD_ACTIONS.VERSION_EXISTS,\n    ],\n    [message_constants_1.TOPIC.RPC]: [\n        message_constants_1.RPC_ACTIONS.REQUEST,\n        message_constants_1.RPC_ACTIONS.RESPONSE,\n        message_constants_1.RPC_ACTIONS.REQUEST_ERROR\n    ],\n    [message_constants_1.TOPIC.EVENT]: [\n        message_constants_1.EVENT_ACTIONS.EMIT,\n    ],\n    [message_constants_1.TOPIC.PRESENCE]: [\n        message_constants_1.PRESENCE_ACTIONS.QUERY_RESPONSE,\n    ],\n    [message_constants_1.TOPIC.CLUSTER]: [\n        message_constants_1.CLUSTER_ACTIONS.IDENTIFICATION_REQUEST,\n        message_constants_1.CLUSTER_ACTIONS.IDENTIFICATION_RESPONSE,\n        message_constants_1.CLUSTER_ACTIONS.KNOWN_PEERS\n    ],\n    [message_constants_1.TOPIC.STATE_REGISTRY]: [\n        message_constants_1.STATE_ACTIONS.FULL_STATE\n    ],\n    [message_constants_1.TOPIC.LOCK]: []\n};\nfunction mapOfArraysHas(map, topic, action) {\n    const actions = map[topic];\n    if (!actions) {\n        return false;\n    }\n    return actions.indexOf(action) !== -1;\n}\nexports.hasPayload = (topic, action) => mapOfArraysHas(payloadMap, topic, action);\nfunction validateUnkownMeta(topic, action, meta) {\n    const spec = exports.META_PARAMS_SPEC[topic][action];\n    if (!spec) {\n        return 'no meta spec';\n    }\n    const [required, optional] = spec;\n    for (const key in meta) {\n        if (meta[key] !== undefined\n            && required.indexOf(key) === -1\n            && optional.indexOf(key) === -1) {\n            return `meta object has unknown key ${key}`;\n        }\n    }\n    return;\n}\nexports.validateUnkownMeta = validateUnkownMeta;\nfunction validateMeta(topic, action, meta) {\n    const spec = exports.META_PARAMS_SPEC[topic][action];\n    if (!spec) {\n        return 'no meta spec';\n    }\n    const [required,] = spec;\n    for (const req of required) {\n        if (meta[req] === undefined) {\n            return `meta object does not have required key ${req}`;\n        }\n    }\n    return;\n}\nexports.validateMeta = validateMeta;\nfunction hasCorrelationId(topic, action) {\n    const spec = exports.META_PARAMS_SPEC[topic][action];\n    if (!spec) {\n        return;\n    }\n    const [required, optional] = spec;\n    return (required.indexOf(message_constants_1.META_KEYS.correlationId) !== -1) || (optional.indexOf(message_constants_1.META_KEYS.correlationId) !== -1);\n}\nexports.hasCorrelationId = hasCorrelationId;\n\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/message-validator.ts?")},"./binary-protocol/src/utils.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ./message-constants */ "./binary-protocol/src/message-constants.ts");\nfunction isWriteAck(action) {\n    return action === message_constants_1.RECORD_ACTIONS.CREATEANDPATCH_WITH_WRITE_ACK\n        || action === message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE_WITH_WRITE_ACK\n        || action === message_constants_1.RECORD_ACTIONS.PATCH_WITH_WRITE_ACK\n        || action === message_constants_1.RECORD_ACTIONS.UPDATE_WITH_WRITE_ACK\n        || action === message_constants_1.RECORD_ACTIONS.ERASE_WITH_WRITE_ACK\n        || action === message_constants_1.RECORD_ACTIONS.WRITE_ACKNOWLEDGEMENT;\n}\nexports.isWriteAck = isWriteAck;\nexports.ACTION_TO_WRITE_ACK = {\n    [message_constants_1.RECORD_ACTIONS.CREATEANDPATCH]: message_constants_1.RECORD_ACTIONS.CREATEANDPATCH_WITH_WRITE_ACK,\n    [message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE]: message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE_WITH_WRITE_ACK,\n    [message_constants_1.RECORD_ACTIONS.PATCH]: message_constants_1.RECORD_ACTIONS.PATCH_WITH_WRITE_ACK,\n    [message_constants_1.RECORD_ACTIONS.UPDATE]: message_constants_1.RECORD_ACTIONS.UPDATE_WITH_WRITE_ACK,\n    [message_constants_1.RECORD_ACTIONS.ERASE]: message_constants_1.RECORD_ACTIONS.ERASE_WITH_WRITE_ACK,\n};\n/**\n * Like reverseMap but the values will be cast using Number(k)\n */\nfunction reverseMapNumeric(map) {\n    const reversedMap = {};\n    for (const key in map) {\n        reversedMap[map[key]] = Number(key);\n    }\n    return reversedMap;\n}\nexports.reverseMapNumeric = reverseMapNumeric;\nexports.WRITE_ACK_TO_ACTION = reverseMapNumeric(exports.ACTION_TO_WRITE_ACK);\nexports.RESPONSE_TO_REQUEST = {\n    [message_constants_1.TOPIC.RECORD]: {\n        [message_constants_1.RECORD_ACTIONS.HEAD_RESPONSE]: message_constants_1.RECORD_ACTIONS.HEAD,\n        [message_constants_1.RECORD_ACTIONS.READ_RESPONSE]: message_constants_1.RECORD_ACTIONS.READ,\n        [message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS]: message_constants_1.RECORD_ACTIONS.DELETE,\n    },\n    [message_constants_1.TOPIC.PRESENCE]: {\n        [message_constants_1.PRESENCE_ACTIONS.QUERY_RESPONSE]: message_constants_1.PRESENCE_ACTIONS.QUERY,\n        [message_constants_1.PRESENCE_ACTIONS.QUERY_ALL_RESPONSE]: message_constants_1.PRESENCE_ACTIONS.QUERY_ALL\n    },\n    [message_constants_1.TOPIC.RPC]: {\n        [message_constants_1.RPC_ACTIONS.ACCEPT]: message_constants_1.RPC_ACTIONS.REQUEST,\n        [message_constants_1.RPC_ACTIONS.ERROR]: message_constants_1.RPC_ACTIONS.REQUEST\n    },\n    [message_constants_1.TOPIC.EVENT]: {}\n};\n\n\n//# sourceURL=webpack://deepstream/./binary-protocol/src/utils.ts?')},"./node_modules/base64-js/index.js":function(module,exports,__webpack_require__){"use strict";eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://deepstream/./node_modules/base64-js/index.js?")},"./node_modules/buffer/index.js":function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/buffer/node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://deepstream/./node_modules/buffer/index.js?")},"./node_modules/buffer/node_modules/isarray/index.js":function(module,exports){eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack://deepstream/./node_modules/buffer/node_modules/isarray/index.js?")},"./node_modules/component-emitter2/index.js":function(module,exports,__webpack_require__){eval("\n/**\n * Expose `Emitter`.\n */\n\nif (true) {\n  module.exports = Emitter;\n}\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || Object.create(null);\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || Object.create(null);\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = Object.create(null);\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n\n  // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n  if (callbacks.length === 0) {\n    delete this._callbacks[event];\n  }\n\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || Object.create(null);\n\n  var args = new Array(arguments.length - 1)\n    , callbacks = this._callbacks[event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || Object.create(null);\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n/**\n * Returns an array listing the events for which the emitter has registered listeners.\n *\n * @return {Array}\n * @api public\n */\nEmitter.prototype.eventNames = function(){\n  return this._callbacks ? Object.keys(this._callbacks) : [];\n}\n\n\n//# sourceURL=webpack://deepstream/./node_modules/component-emitter2/index.js?")},"./node_modules/ieee754/index.js":function(module,exports){eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://deepstream/./node_modules/ieee754/index.js?")},"./node_modules/webpack/buildin/global.js":function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://deepstream/(webpack)/buildin/global.js?')},"./src/client-options.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst merge_strategy_1 = __webpack_require__(/*! ./record/merge-strategy */ \"./src/record/merge-strategy.ts\");\nexports.DefaultOptions = {\n    timerResolution: 50,\n    subscriptionInterval: 100,\n    offlineEnabled: true,\n    heartbeatInterval: 30000,\n    reconnectIntervalIncrement: 4000,\n    maxReconnectInterval: 180000,\n    maxReconnectAttempts: 5,\n    rpcAcceptTimeout: 6000,\n    rpcResponseTimeout: 10000,\n    subscriptionTimeout: 2000,\n    recordReadAckTimeout: 15000,\n    recordReadTimeout: 15000,\n    recordDeleteTimeout: 15000,\n    offlineBufferTimeout: 2000,\n    discardTimeout: 5000,\n    path: '/deepstream',\n    mergeStrategy: merge_strategy_1.REMOTE_WINS,\n    recordDeepCopy: true,\n    socketOptions: null,\n    dirtyStorageName: '__ds__dirty_records',\n    nodeStoragePath: './local-storage',\n    nodeStorageSize: 5,\n    lazyConnect: false\n};\n\n\n//# sourceURL=webpack://deepstream/./src/client-options.ts?")},"./src/client.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst client_options_1 = __webpack_require__(/*! ./client-options */ "./src/client-options.ts");\nconst logger_1 = __webpack_require__(/*! ./util/logger */ "./src/util/logger.ts");\nconst timeout_registry_1 = __webpack_require__(/*! ./util/timeout-registry */ "./src/util/timeout-registry.ts");\nconst timer_registry_1 = __webpack_require__(/*! ./util/timer-registry */ "./src/util/timer-registry.ts");\nconst connection_1 = __webpack_require__(/*! ./connection/connection */ "./src/connection/connection.ts");\nconst socket_factory_1 = __webpack_require__(/*! ./connection/socket-factory */ "./src/connection/socket-factory.ts");\nconst event_handler_1 = __webpack_require__(/*! ./event/event-handler */ "./src/event/event-handler.ts");\nconst rpc_handler_1 = __webpack_require__(/*! ./rpc/rpc-handler */ "./src/rpc/rpc-handler.ts");\nconst record_handler_1 = __webpack_require__(/*! ./record/record-handler */ "./src/record/record-handler.ts");\nconst storage_service_1 = __webpack_require__(/*! ./record/storage-service */ "./src/record/storage-service.ts");\nconst presence_handler_1 = __webpack_require__(/*! ./presence/presence-handler */ "./src/presence/presence-handler.ts");\nconst EventEmitter = __webpack_require__(/*! component-emitter2 */ "./node_modules/component-emitter2/index.js");\nconst noop_storage_service_1 = __webpack_require__(/*! ./record/noop-storage-service */ "./src/record/noop-storage-service.ts");\nclass Client extends EventEmitter {\n    constructor(url, options = {}) {\n        super();\n        this.options = Object.assign({}, client_options_1.DefaultOptions, options);\n        // @ts-ignore\n        const services = {};\n        services.logger = new logger_1.Logger(this);\n        services.timerRegistry = new timer_registry_1.TimerRegistry(this.options.timerResolution);\n        services.timeoutRegistry = new timeout_registry_1.TimeoutRegistry(services, this.options);\n        services.socketFactory = this.options.socketFactory || socket_factory_1.socketFactory;\n        services.connection = new connection_1.Connection(services, this.options, url, this);\n        if (this.options.offlineEnabled) {\n            services.storage = this.options.storage || new storage_service_1.Storage(this.options);\n        }\n        else {\n            services.storage = new noop_storage_service_1.NoopStorage();\n        }\n        this.services = services;\n        this.services.connection.onLost(services.timeoutRegistry.onConnectionLost.bind(services.timeoutRegistry));\n        this.event = new event_handler_1.EventHandler(this.services, this.options);\n        this.rpc = new rpc_handler_1.RPCHandler(this.services, this.options);\n        this.record = new record_handler_1.RecordHandler(this.services, this.options);\n        this.presence = new presence_handler_1.PresenceHandler(this.services, this.options);\n    }\n    login(detailsOrCallback, callback) {\n        if (detailsOrCallback && typeof detailsOrCallback === \'object\') {\n            if (callback) {\n                this.services.connection.authenticate(detailsOrCallback, callback);\n            }\n            else {\n                return new Promise((resolve, reject) => {\n                    this.services.connection.authenticate(detailsOrCallback, (success, data) => {\n                        success ? resolve(data) : reject(data);\n                    });\n                });\n            }\n        }\n        else {\n            if (typeof detailsOrCallback === \'function\') {\n                this.services.connection.authenticate({}, detailsOrCallback);\n            }\n            else {\n                return new Promise((resolve, reject) => {\n                    this.services.connection.authenticate({}, (success, data) => {\n                        success ? resolve(data) : reject(data);\n                    });\n                });\n            }\n        }\n    }\n    getConnectionState() {\n        return this.services.connection.getConnectionState();\n    }\n    close() {\n        this.services.connection.close();\n    }\n    pause() {\n        this.services.connection.pause();\n    }\n    resume(callback) {\n        if (callback) {\n            this.services.connection.resume(callback);\n            return;\n        }\n        return new Promise((resolve, reject) => {\n            this.services.connection.resume(error => {\n                error ? reject(error) : resolve();\n            });\n        });\n    }\n    /**\n    * Returns a random string. The first block of characters\n    * is a timestamp, in order to allow databases to optimize for semi-\n    * sequential numberings\n    */\n    getUid() {\n        const timestamp = (new Date()).getTime().toString(36);\n        const randomString = (Math.random() * 10000000000000000).toString(36).replace(\'.\', \'\');\n        return `${timestamp}-${randomString}`;\n    }\n}\nexports.Client = Client;\n\n\n//# sourceURL=webpack://deepstream/./src/client.ts?')},"./src/connection/connection.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nconst message_parser_1 = __webpack_require__(/*! ../../binary-protocol/src/message-parser */ "./binary-protocol/src/message-parser.ts");\nconst state_machine_1 = __webpack_require__(/*! ../util/state-machine */ "./src/util/state-machine.ts");\nconst utils = __webpack_require__(/*! ../util/utils */ "./src/util/utils.ts");\nconst Emitter = __webpack_require__(/*! component-emitter2 */ "./node_modules/component-emitter2/index.js");\nclass Connection {\n    constructor(services, options, url, emitter) {\n        this.services = services;\n        this.options = options;\n        this.reconnectTimeout = -1;\n        this.authParams = null;\n        this.handlers = new Map();\n        this.authCallback = null;\n        this.resumeCallback = null;\n        this.emitter = emitter;\n        this.internalEmitter = new Emitter();\n        this.isInLimbo = true;\n        this.clientData = null;\n        this.heartbeatIntervalTimeout = null;\n        this.endpoint = null;\n        this.reconnectionAttempt = 0;\n        this.limboTimeout = null;\n        let isReconnecting = false;\n        let firstOpen = true;\n        this.stateMachine = new state_machine_1.StateMachine(this.services.logger, {\n            init: constants_1.CONNECTION_STATE.CLOSED,\n            onStateChanged: (newState, oldState) => {\n                if (newState === oldState) {\n                    return;\n                }\n                emitter.emit(constants_1.EVENT.CONNECTION_STATE_CHANGED, newState);\n                if (newState === constants_1.CONNECTION_STATE.RECONNECTING) {\n                    this.isInLimbo = true;\n                    isReconnecting = true;\n                    if (oldState !== constants_1.CONNECTION_STATE.CLOSED) {\n                        this.internalEmitter.emit(constants_1.EVENT.CONNECTION_LOST);\n                        this.limboTimeout = this.services.timerRegistry.add({\n                            duration: this.options.offlineBufferTimeout,\n                            context: this,\n                            callback: () => {\n                                this.isInLimbo = false;\n                                this.internalEmitter.emit(constants_1.EVENT.EXIT_LIMBO);\n                            }\n                        });\n                    }\n                }\n                else if (newState === constants_1.CONNECTION_STATE.OPEN && (isReconnecting || firstOpen)) {\n                    firstOpen = false;\n                    this.isInLimbo = false;\n                    this.internalEmitter.emit(constants_1.EVENT.CONNECTION_REESTABLISHED);\n                    this.services.timerRegistry.remove(this.limboTimeout);\n                }\n            },\n            transitions: [\n                { name: "initialised" /* INITIALISED */, from: constants_1.CONNECTION_STATE.CLOSED, to: constants_1.CONNECTION_STATE.INITIALISING },\n                { name: "connected" /* CONNECTED */, from: constants_1.CONNECTION_STATE.INITIALISING, to: constants_1.CONNECTION_STATE.AWAITING_CONNECTION },\n                { name: "connected" /* CONNECTED */, from: constants_1.CONNECTION_STATE.REDIRECTING, to: constants_1.CONNECTION_STATE.AWAITING_CONNECTION },\n                { name: "connected" /* CONNECTED */, from: constants_1.CONNECTION_STATE.RECONNECTING, to: constants_1.CONNECTION_STATE.AWAITING_CONNECTION },\n                { name: "challenge" /* CHALLENGE */, from: constants_1.CONNECTION_STATE.AWAITING_CONNECTION, to: constants_1.CONNECTION_STATE.CHALLENGING },\n                { name: "redirected" /* CONNECTION_REDIRECTED */, from: constants_1.CONNECTION_STATE.CHALLENGING, to: constants_1.CONNECTION_STATE.REDIRECTING },\n                { name: "challenge-denied" /* CHALLENGE_DENIED */, from: constants_1.CONNECTION_STATE.CHALLENGING, to: constants_1.CONNECTION_STATE.CHALLENGE_DENIED },\n                { name: "accepted" /* CHALLENGE_ACCEPTED */, from: constants_1.CONNECTION_STATE.CHALLENGING, to: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION, handler: this.onAwaitingAuthentication.bind(this) },\n                { name: "authentication-timeout" /* AUTHENTICATION_TIMEOUT */, from: constants_1.CONNECTION_STATE.AWAITING_CONNECTION, to: constants_1.CONNECTION_STATE.AUTHENTICATION_TIMEOUT },\n                { name: "authentication-timeout" /* AUTHENTICATION_TIMEOUT */, from: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION, to: constants_1.CONNECTION_STATE.AUTHENTICATION_TIMEOUT },\n                { name: "authenticate" /* AUTHENTICATE */, from: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION, to: constants_1.CONNECTION_STATE.AUTHENTICATING },\n                { name: "unsuccesful-login" /* UNSUCCESFUL_LOGIN */, from: constants_1.CONNECTION_STATE.AUTHENTICATING, to: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION },\n                { name: "succesful-login" /* SUCCESFUL_LOGIN */, from: constants_1.CONNECTION_STATE.AUTHENTICATING, to: constants_1.CONNECTION_STATE.OPEN },\n                { name: "too-many-auth-attempts" /* TOO_MANY_AUTH_ATTEMPTS */, from: constants_1.CONNECTION_STATE.AUTHENTICATING, to: constants_1.CONNECTION_STATE.TOO_MANY_AUTH_ATTEMPTS },\n                { name: "too-many-auth-attempts" /* TOO_MANY_AUTH_ATTEMPTS */, from: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION, to: constants_1.CONNECTION_STATE.TOO_MANY_AUTH_ATTEMPTS },\n                { name: "authentication-timeout" /* AUTHENTICATION_TIMEOUT */, from: constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION, to: constants_1.CONNECTION_STATE.AUTHENTICATION_TIMEOUT },\n                { name: "reconnect" /* RECONNECT */, from: constants_1.CONNECTION_STATE.RECONNECTING, to: constants_1.CONNECTION_STATE.RECONNECTING },\n                { name: "closed" /* CLOSED */, from: constants_1.CONNECTION_STATE.CLOSING, to: constants_1.CONNECTION_STATE.CLOSED },\n                { name: "offline" /* OFFLINE */, from: constants_1.CONNECTION_STATE.PAUSING, to: constants_1.CONNECTION_STATE.OFFLINE },\n                { name: "error" /* ERROR */, to: constants_1.CONNECTION_STATE.RECONNECTING },\n                { name: "connection-lost" /* LOST */, to: constants_1.CONNECTION_STATE.RECONNECTING },\n                { name: "resume" /* RESUME */, to: constants_1.CONNECTION_STATE.RECONNECTING },\n                { name: "pause" /* PAUSE */, to: constants_1.CONNECTION_STATE.PAUSING },\n                { name: "close" /* CLOSE */, to: constants_1.CONNECTION_STATE.CLOSING },\n            ]\n        });\n        this.stateMachine.transition("initialised" /* INITIALISED */);\n        this.originalUrl = utils.parseUrl(url, this.options.path);\n        this.url = this.originalUrl;\n        if (!options.lazyConnect) {\n            this.createEndpoint();\n        }\n    }\n    get isConnected() {\n        return this.stateMachine.state === constants_1.CONNECTION_STATE.OPEN;\n    }\n    onLost(callback) {\n        this.internalEmitter.on(constants_1.EVENT.CONNECTION_LOST, callback);\n    }\n    removeOnLost(callback) {\n        this.internalEmitter.off(constants_1.EVENT.CONNECTION_LOST, callback);\n    }\n    onReestablished(callback) {\n        this.internalEmitter.on(constants_1.EVENT.CONNECTION_REESTABLISHED, callback);\n    }\n    removeOnReestablished(callback) {\n        this.internalEmitter.off(constants_1.EVENT.CONNECTION_REESTABLISHED, callback);\n    }\n    onExitLimbo(callback) {\n        this.internalEmitter.on(constants_1.EVENT.EXIT_LIMBO, callback);\n    }\n    registerHandler(topic, callback) {\n        this.handlers.set(topic, callback);\n    }\n    sendMessage(message) {\n        if (!this.isOpen()) {\n            this.services.logger.error(message, constants_1.EVENT.IS_CLOSED);\n            return;\n        }\n        if (this.endpoint) {\n            this.endpoint.sendParsedMessage(message);\n        }\n    }\n    authenticate(authParamsOrCallback, callback) {\n        if (authParamsOrCallback &&\n            typeof authParamsOrCallback !== \'object\' &&\n            typeof authParamsOrCallback !== \'function\') {\n            throw new Error(\'invalid argument authParamsOrCallback\');\n        }\n        if (callback && typeof callback !== \'function\') {\n            throw new Error(\'invalid argument callback\');\n        }\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.CHALLENGE_DENIED ||\n            this.stateMachine.state === constants_1.CONNECTION_STATE.TOO_MANY_AUTH_ATTEMPTS ||\n            this.stateMachine.state === constants_1.CONNECTION_STATE.AUTHENTICATION_TIMEOUT) {\n            this.services.logger.error({ topic: message_constants_1.TOPIC.CONNECTION }, constants_1.EVENT.IS_CLOSED);\n            return;\n        }\n        if (authParamsOrCallback) {\n            // @ts-ignore\n            this.authParams = typeof authParamsOrCallback === \'object\' ? authParamsOrCallback : {};\n        }\n        if (authParamsOrCallback && typeof authParamsOrCallback === \'function\') {\n            this.authCallback = authParamsOrCallback;\n        }\n        else if (callback) {\n            this.authCallback = callback;\n        }\n        else {\n            this.authCallback = () => { };\n        }\n        // if (this.stateMachine.state === CONNECTION_STATE.CLOSED && !this.endpoint) {\n        //   this.createEndpoint()\n        //   return\n        // }\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.AWAITING_AUTHENTICATION && this.authParams) {\n            this.sendAuthParams();\n        }\n        if (!this.endpoint) {\n            this.createEndpoint();\n        }\n    }\n    /*\n    * Returns the current connection state.\n    */\n    getConnectionState() {\n        return this.stateMachine.state;\n    }\n    isOpen() {\n        const connState = this.getConnectionState();\n        return connState !== constants_1.CONNECTION_STATE.CLOSED\n            && connState !== constants_1.CONNECTION_STATE.ERROR\n            && connState !== constants_1.CONNECTION_STATE.CLOSING;\n    }\n    /**\n     * Closes the connection. Using this method\n     * will prevent the client from reconnecting.\n     */\n    close() {\n        this.services.timerRegistry.remove(this.heartbeatIntervalTimeout);\n        this.sendMessage({\n            topic: message_constants_1.TOPIC.CONNECTION,\n            action: message_constants_1.CONNECTION_ACTIONS.CLOSING\n        });\n        this.stateMachine.transition("close" /* CLOSE */);\n    }\n    pause() {\n        this.stateMachine.transition("pause" /* PAUSE */);\n        this.services.timerRegistry.remove(this.heartbeatIntervalTimeout);\n        if (this.endpoint) {\n            this.endpoint.close();\n        }\n    }\n    resume(callback) {\n        this.stateMachine.transition("resume" /* RESUME */);\n        this.resumeCallback = callback;\n        this.tryReconnect();\n    }\n    /**\n     * Creates the endpoint to connect to using the url deepstream\n     * was initialised with.\n     */\n    createEndpoint() {\n        this.endpoint = this.services.socketFactory(this.url, this.options.socketOptions, this.options.heartbeatInterval);\n        this.endpoint.onopen = this.onOpen.bind(this);\n        this.endpoint.onerror = this.onError.bind(this);\n        this.endpoint.onclose = this.onClose.bind(this);\n        this.endpoint.onparsedmessages = this.onMessages.bind(this);\n    }\n    /********************************\n    ****** Endpoint Callbacks ******\n    /********************************/\n    /**\n    * Will be invoked once the connection is established. The client\n    * can\'t send messages yet, and needs to get a connection ACK or REDIRECT\n    * from the server before authenticating\n    */\n    onOpen() {\n        this.clearReconnect();\n        this.checkHeartBeat();\n        this.stateMachine.transition("connected" /* CONNECTED */);\n        this.sendMessage({\n            topic: message_constants_1.TOPIC.CONNECTION,\n            action: message_constants_1.CONNECTION_ACTIONS.CHALLENGE,\n            url: this.originalUrl,\n            protocolVersion: \'0.1a\'\n        });\n        this.stateMachine.transition("challenge" /* CHALLENGE */);\n    }\n    /**\n     * Callback for generic connection errors. Forwards\n     * the error to the client.\n     *\n     * The connection is considered broken once this method has been\n     * invoked.\n     */\n    onError(error) {\n        /*\n         * If the implementation isn\'t listening on the error event this will throw\n         * an error. So let\'s defer it to allow the reconnection to kick in.\n         */\n        setTimeout(() => {\n            let msg;\n            if (error.code === \'ECONNRESET\' || error.code === \'ECONNREFUSED\') {\n                msg = `Can\'t connect! Deepstream server unreachable on ${this.originalUrl}`;\n            }\n            else {\n                try {\n                    msg = JSON.stringify(error);\n                }\n                catch (e) {\n                    msg = error.toString();\n                }\n            }\n            this.services.logger.error({ topic: message_constants_1.TOPIC.CONNECTION }, constants_1.EVENT.CONNECTION_ERROR, msg);\n        }, 1);\n        this.services.timerRegistry.remove(this.heartbeatIntervalTimeout);\n        this.stateMachine.transition("error" /* ERROR */);\n        this.tryReconnect();\n    }\n    /**\n     * Callback when the connection closes. This might have been a deliberate\n     * close triggered by the client or the result of the connection getting\n     * lost.\n     *\n     * In the latter case the client will try to reconnect using the configured\n     * strategy.\n     */\n    onClose() {\n        this.services.timerRegistry.remove(this.heartbeatIntervalTimeout);\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.REDIRECTING) {\n            this.createEndpoint();\n            return;\n        }\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.CHALLENGE_DENIED ||\n            this.stateMachine.state === constants_1.CONNECTION_STATE.TOO_MANY_AUTH_ATTEMPTS ||\n            this.stateMachine.state === constants_1.CONNECTION_STATE.AUTHENTICATION_TIMEOUT) {\n            return;\n        }\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.CLOSING) {\n            this.stateMachine.transition("closed" /* CLOSED */);\n            return;\n        }\n        if (this.stateMachine.state === constants_1.CONNECTION_STATE.PAUSING) {\n            this.stateMachine.transition("offline" /* OFFLINE */);\n            return;\n        }\n        this.stateMachine.transition("connection-lost" /* LOST */);\n        this.tryReconnect();\n    }\n    /**\n     * Callback for messages received on the connection.\n     */\n    onMessages(parseResults) {\n        parseResults.forEach(parseResult => {\n            if (parseResult.parseError) {\n                this.services.logger.error({ topic: message_constants_1.TOPIC.PARSER }, parseResult.action, parseResult.raw && parseResult.raw.toString());\n                return;\n            }\n            const message = parseResult;\n            const res = message_parser_1.parseData(message);\n            if (res !== true) {\n                this.services.logger.error({ topic: message_constants_1.TOPIC.PARSER }, message_constants_1.PARSER_ACTIONS.INVALID_MESSAGE, res);\n            }\n            if (message === null) {\n                return;\n            }\n            if (message.topic === message_constants_1.TOPIC.CONNECTION) {\n                this.handleConnectionResponse(message);\n                return;\n            }\n            if (message.topic === message_constants_1.TOPIC.AUTH) {\n                this.handleAuthResponse(message);\n                return;\n            }\n            const handler = this.handlers.get(message.topic);\n            if (!handler) {\n                // this should never happen\n                return;\n            }\n            handler(message);\n        });\n    }\n    /**\n    * Sends authentication params to the server. Please note, this\n    * doesn\'t use the queued message mechanism, but rather sends the message directly\n    */\n    sendAuthParams() {\n        this.stateMachine.transition("authenticate" /* AUTHENTICATE */);\n        this.sendMessage({\n            topic: message_constants_1.TOPIC.AUTH,\n            action: message_constants_1.AUTH_ACTIONS.REQUEST,\n            parsedData: this.authParams\n        });\n    }\n    /**\n    * Ensures that a heartbeat was not missed more than once, otherwise it considers the connection\n    * to have been lost and closes it for reconnection.\n    */\n    checkHeartBeat() {\n        const heartBeatTolerance = this.options.heartbeatInterval * 2;\n        if (!this.endpoint) {\n            return;\n        }\n        if (this.endpoint.getTimeSinceLastMessage() > heartBeatTolerance) {\n            this.services.timerRegistry.remove(this.heartbeatIntervalTimeout);\n            this.services.logger.error({ topic: message_constants_1.TOPIC.CONNECTION }, constants_1.EVENT.HEARTBEAT_TIMEOUT);\n            this.endpoint.close();\n            return;\n        }\n        this.heartbeatIntervalTimeout = this.services.timerRegistry.add({\n            duration: this.options.heartbeatInterval,\n            callback: this.checkHeartBeat,\n            context: this\n        });\n    }\n    /**\n    * If the connection drops or is closed in error this\n    * method schedules increasing reconnection intervals\n    *\n    * If the number of failed reconnection attempts exceeds\n    * options.maxReconnectAttempts the connection is closed\n    */\n    tryReconnect() {\n        if (this.reconnectTimeout !== null) {\n            return;\n        }\n        if (this.reconnectionAttempt < this.options.maxReconnectAttempts) {\n            this.stateMachine.transition("reconnect" /* RECONNECT */);\n            this.reconnectTimeout = this.services.timerRegistry.add({\n                callback: this.tryOpen,\n                context: this,\n                duration: Math.min(this.options.maxReconnectInterval, this.options.reconnectIntervalIncrement * this.reconnectionAttempt)\n            });\n            this.reconnectionAttempt++;\n            return;\n        }\n        this.emitter.emit(constants_1.EVENT[constants_1.EVENT.MAX_RECONNECTION_ATTEMPTS_REACHED], this.reconnectionAttempt);\n        this.clearReconnect();\n        this.close();\n    }\n    /**\n     * Attempts to open a errourosly closed connection\n     */\n    tryOpen() {\n        if (this.stateMachine.state !== constants_1.CONNECTION_STATE.REDIRECTING) {\n            this.url = this.originalUrl;\n        }\n        this.createEndpoint();\n        this.reconnectTimeout = null;\n    }\n    /**\n     * Stops all further reconnection attempts,\n     * either because the connection is open again\n     * or because the maximal number of reconnection\n     * attempts has been exceeded\n     */\n    clearReconnect() {\n        this.services.timerRegistry.remove(this.reconnectTimeout);\n        this.reconnectTimeout = null;\n        this.reconnectionAttempt = 0;\n    }\n    /**\n     * The connection response will indicate whether the deepstream connection\n     * can be used or if it should be forwarded to another instance. This\n     * allows us to introduce load-balancing if needed.\n     *\n     * If authentication parameters are already provided this will kick of\n     * authentication immediately. The actual \'open\' event won\'t be emitted\n     * by the client until the authentication is successful.\n     *\n     * If a challenge is recieved, the user will send the url to the server\n     * in response to get the appropriate redirect. If the URL is invalid the\n     * server will respond with a REJECTION resulting in the client connection\n     * being permanently closed.\n     *\n     * If a redirect is recieved, this connection is closed and updated with\n     * a connection to the url supplied in the message.\n     */\n    handleConnectionResponse(message) {\n        if (message.action === message_constants_1.CONNECTION_ACTIONS.ACCEPT) {\n            this.stateMachine.transition("accepted" /* CHALLENGE_ACCEPTED */);\n            return;\n        }\n        if (message.action === message_constants_1.CONNECTION_ACTIONS.REJECT) {\n            this.stateMachine.transition("challenge-denied" /* CHALLENGE_DENIED */);\n            if (this.endpoint) {\n                this.endpoint.close();\n            }\n            return;\n        }\n        if (message.action === message_constants_1.CONNECTION_ACTIONS.REDIRECT) {\n            this.url = message.url;\n            this.stateMachine.transition("redirected" /* CONNECTION_REDIRECTED */);\n            if (this.endpoint) {\n                this.endpoint.close();\n            }\n            return;\n        }\n        if (message.action === message_constants_1.CONNECTION_ACTIONS.AUTHENTICATION_TIMEOUT) {\n            this.stateMachine.transition("authentication-timeout" /* AUTHENTICATION_TIMEOUT */);\n            this.services.logger.error(message);\n        }\n    }\n    /**\n     * Callback for messages received for the AUTH topic. If\n     * the authentication was successful this method will\n     * open the connection and send all messages that the client\n     * tried to send so far.\n     */\n    handleAuthResponse(message) {\n        if (message.action === message_constants_1.AUTH_ACTIONS.TOO_MANY_AUTH_ATTEMPTS) {\n            this.stateMachine.transition("too-many-auth-attempts" /* TOO_MANY_AUTH_ATTEMPTS */);\n            this.services.logger.error(message);\n            return;\n        }\n        if (message.action === message_constants_1.AUTH_ACTIONS.AUTH_UNSUCCESSFUL) {\n            this.stateMachine.transition("unsuccesful-login" /* UNSUCCESFUL_LOGIN */);\n            this.onAuthUnSuccessful();\n            return;\n        }\n        if (message.action === message_constants_1.AUTH_ACTIONS.AUTH_SUCCESSFUL) {\n            this.stateMachine.transition("succesful-login" /* SUCCESFUL_LOGIN */);\n            this.onAuthSuccessful(message.parsedData);\n            return;\n        }\n    }\n    onAwaitingAuthentication() {\n        if (this.authParams) {\n            this.sendAuthParams();\n        }\n    }\n    onAuthSuccessful(clientData) {\n        this.updateClientData(clientData);\n        if (this.resumeCallback) {\n            this.resumeCallback();\n            this.resumeCallback = null;\n        }\n        if (this.authCallback === null) {\n            return;\n        }\n        this.authCallback(true, this.clientData);\n        this.authCallback = null;\n    }\n    onAuthUnSuccessful() {\n        const reason = { reason: constants_1.EVENT[constants_1.EVENT.INVALID_AUTHENTICATION_DETAILS] };\n        if (this.resumeCallback) {\n            this.resumeCallback(reason);\n            this.resumeCallback = null;\n        }\n        if (this.authCallback === null) {\n            this.emitter.emit(constants_1.EVENT.REAUTHENTICATION_FAILURE, reason);\n            return;\n        }\n        this.authCallback(false, reason);\n        this.authCallback = null;\n    }\n    updateClientData(data) {\n        const newClientData = data || null;\n        if (this.clientData === null &&\n            (newClientData === null || Object.keys(newClientData).length === 0)) {\n            return;\n        }\n        if (!utils.deepEquals(this.clientData, data)) {\n            this.emitter.emit(constants_1.EVENT.CLIENT_DATA_CHANGED, Object.assign({}, newClientData));\n            this.clientData = newClientData;\n        }\n    }\n}\nexports.Connection = Connection;\n\n\n//# sourceURL=webpack://deepstream/./src/connection/connection.ts?')},"./src/connection/socket-factory.ts":function(module,exports,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(global, Buffer) {\nObject.defineProperty(exports, "__esModule", { value: true });\nconst message_parser_1 = __webpack_require__(/*! ../../binary-protocol/src/message-parser */ "./binary-protocol/src/message-parser.ts");\nconst message_builder_1 = __webpack_require__(/*! ../../binary-protocol/src/message-builder */ "./binary-protocol/src/message-builder.ts");\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nconst BrowserWebsocket = (global.WebSocket || global.MozWebSocket);\nexports.socketFactory = (url, options, heartBeatInterval) => {\n    const socket = BrowserWebsocket\n        ? new BrowserWebsocket(url, [], options)\n        : new (__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \'ws\'"); e.code = \'MODULE_NOT_FOUND\'; throw e; }())))(url, options);\n    if (BrowserWebsocket) {\n        socket.binaryType = \'arraybuffer\';\n    }\n    let lastRecievedMessageTimestamp = -1;\n    // tslint:disable-next-line:no-empty\n    socket.onparsedmessage = () => { };\n    socket.onmessage = (raw) => {\n        lastRecievedMessageTimestamp = Date.now();\n        const parseResults = message_parser_1.parse(BrowserWebsocket ? new Buffer(new Uint8Array(raw.data)) : raw.data);\n        socket.onparsedmessages(parseResults);\n    };\n    socket.getTimeSinceLastMessage = () => {\n        return 0;\n        // return Date.now() - lastRecievedMessageTimestamp\n    };\n    socket.sendParsedMessage = (message) => {\n        if (message.topic === message_constants_1.TOPIC.CONNECTION && message.action === message_constants_1.CONNECTION_ACTIONS.CLOSING) {\n            socket.onparsedmessages([{ topic: message_constants_1.TOPIC.CONNECTION, action: message_constants_1.CONNECTION_ACTIONS.CLOSED }]);\n            socket.close();\n            return;\n        }\n        message.data = JSON.stringify(message.parsedData);\n        // if (message.action !== CONNECTION_ACTIONS.PONG && message.action !== CONNECTION_ACTIONS.PING) {\n        //     console.log(\'>>>\', TOPIC[message.topic], (ACTIONS as any)[message.topic][message.action], message.parsedData, message.data, message.name)\n        // }\n        socket.send(message_builder_1.getMessage(message, false));\n    };\n    const pingMessage = message_builder_1.getMessage({ topic: message_constants_1.TOPIC.CONNECTION, action: message_constants_1.CONNECTION_ACTIONS.PING }, false);\n    const pingInterval = setInterval(() => {\n        if (Date.now() - lastRecievedMessageTimestamp > heartBeatInterval) {\n            try {\n                socket.send(pingMessage);\n            }\n            catch (e) {\n                clearTimeout(pingInterval);\n            }\n        }\n    }, heartBeatInterval);\n    return socket;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../node_modules/buffer/index.js */ "./node_modules/buffer/index.js").Buffer))\n\n//# sourceURL=webpack://deepstream/./src/connection/socket-factory.ts?')},"./src/constants.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar EVENT;\n(function (EVENT) {\n    EVENT[EVENT["UNSOLICITED_MESSAGE"] = 0] = "UNSOLICITED_MESSAGE";\n    EVENT[EVENT["IS_CLOSED"] = 1] = "IS_CLOSED";\n    EVENT[EVENT["MAX_RECONNECTION_ATTEMPTS_REACHED"] = 2] = "MAX_RECONNECTION_ATTEMPTS_REACHED";\n    EVENT[EVENT["CONNECTION_ERROR"] = 3] = "CONNECTION_ERROR";\n    EVENT[EVENT["ACK_TIMEOUT"] = 4] = "ACK_TIMEOUT";\n    EVENT[EVENT["UNKNOWN_CORRELATION_ID"] = 5] = "UNKNOWN_CORRELATION_ID";\n    EVENT[EVENT["HEARTBEAT_TIMEOUT"] = 6] = "HEARTBEAT_TIMEOUT";\n    EVENT[EVENT["LISTENER_EXISTS"] = 7] = "LISTENER_EXISTS";\n    EVENT[EVENT["NOT_LISTENING"] = 8] = "NOT_LISTENING";\n    EVENT[EVENT["RECORD_ALREADY_DESTROYED"] = 9] = "RECORD_ALREADY_DESTROYED";\n    EVENT[EVENT["RECORD_DELETE_TIMEOUT"] = 10] = "RECORD_DELETE_TIMEOUT";\n    EVENT["CLIENT_OFFLINE"] = "client offline";\n    EVENT["INVALID_AUTHENTICATION_DETAILS"] = "INVALID_AUTHENTICATION_DETAILS";\n    EVENT["CONNECTION_LOST"] = "connectionLost";\n    EVENT["CONNECTION_REESTABLISHED"] = "connectionReestablished";\n    EVENT["EXIT_LIMBO"] = "exitLimbo";\n    EVENT["CONNECTION_STATE_CHANGED"] = "connectionStateChanged";\n    EVENT["CLIENT_DATA_CHANGED"] = "clientDataChanged";\n    EVENT["REAUTHENTICATION_FAILURE"] = "reauthenticationFailure";\n    EVENT["AUTHENTICATION_TIMEOUT"] = "AUTHENTICATION_TIMEOUT";\n    EVENT["RECORD_ERROR"] = "error";\n    EVENT["RECORD_READY"] = "ready";\n    EVENT["RECORD_DELETED"] = "delete";\n    EVENT["RECORD_DISCARDED"] = "discard";\n    EVENT["RECORD_VERSION_EXISTS"] = "versionExists";\n    EVENT["RECORD_HAS_PROVIDER_CHANGED"] = "hasProviderChanged";\n    EVENT["RECORD_STATE_CHANGED"] = "onRecordStateChanged";\n    EVENT["ENTRY_ADDED_EVENT"] = "entry-added";\n    EVENT["ENTRY_REMOVED_EVENT"] = "entry-removed";\n    EVENT["ENTRY_MOVED_EVENT"] = "entry-moved";\n})(EVENT = exports.EVENT || (exports.EVENT = {}));\nvar CONNECTION_STATE;\n(function (CONNECTION_STATE) {\n    CONNECTION_STATE["CLOSING"] = "CLOSING";\n    CONNECTION_STATE["CLOSED"] = "CLOSED";\n    CONNECTION_STATE["INITIALISING"] = "INITIALISING";\n    CONNECTION_STATE["AWAITING_CONNECTION"] = "AWAITING_CONNECTION";\n    CONNECTION_STATE["CHALLENGING"] = "CHALLENGING";\n    CONNECTION_STATE["AWAITING_AUTHENTICATION"] = "AWAITING_AUTHENTICATION";\n    CONNECTION_STATE["AUTHENTICATING"] = "AUTHENTICATING";\n    CONNECTION_STATE["OPEN"] = "OPEN";\n    CONNECTION_STATE["ERROR"] = "ERROR";\n    CONNECTION_STATE["RECONNECTING"] = "RECONNECTING";\n    CONNECTION_STATE["REDIRECTING"] = "REDIRECTING";\n    CONNECTION_STATE["CHALLENGE_DENIED"] = "CHALLENGE_DENIED";\n    CONNECTION_STATE["TOO_MANY_AUTH_ATTEMPTS"] = "TOO_MANY_AUTH_ATTEMPTS";\n    CONNECTION_STATE["AUTHENTICATION_TIMEOUT"] = "AUTHENTICATION_TIMEOUT";\n    CONNECTION_STATE["PAUSING"] = "PAUSING";\n    CONNECTION_STATE["OFFLINE"] = "OFFLINE";\n})(CONNECTION_STATE = exports.CONNECTION_STATE || (exports.CONNECTION_STATE = {}));\n\n\n//# sourceURL=webpack://deepstream/./src/constants.ts?')},"./src/deepstream.ts":function(module,exports,__webpack_require__){"use strict";eval('\nconst client_1 = __webpack_require__(/*! ./client */ "./src/client.ts");\nconst constants_1 = __webpack_require__(/*! ./constants */ "./src/constants.ts");\nconst C = __webpack_require__(/*! ../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nconst client = (url, options) => {\n    return new client_1.Client(url, options);\n};\nmodule.exports = Object.assign(client, {\n    CONNECTION_STATE: constants_1.CONNECTION_STATE,\n    C,\n    EVENT: constants_1.EVENT,\n    deepstream: client\n});\n\n\n//# sourceURL=webpack://deepstream/./src/deepstream.ts?')},"./src/event/event-handler.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst listener_1 = __webpack_require__(/*! ../util/listener */ \"./src/util/listener.ts\");\nconst Emitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\nconst bulk_subscription_service_1 = __webpack_require__(/*! ../util/bulk-subscription-service */ \"./src/util/bulk-subscription-service.ts\");\nclass EventHandler {\n    constructor(services, options, listeners) {\n        this.services = services;\n        this.emitter = new Emitter();\n        this.limboQueue = [];\n        this.bulkSubscription = new bulk_subscription_service_1.BulkSubscriptionService(this.services, options.subscriptionInterval, message_constants_1.TOPIC.EVENT, message_constants_1.EVENT_ACTIONS.SUBSCRIBE_BULK, message_constants_1.EVENT_ACTIONS.SUBSCRIBE, message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE_BULK, message_constants_1.EVENT_ACTIONS.UNSUBSCRIBE, this.onBulkSubscriptionSent.bind(this));\n        this.listeners = listeners || new listener_1.Listener(message_constants_1.TOPIC.EVENT, services);\n        this.services.connection.registerHandler(message_constants_1.TOPIC.EVENT, this.handle.bind(this));\n        this.services.connection.onExitLimbo(this.onExitLimbo.bind(this));\n        this.services.connection.onReestablished(this.onConnectionReestablished.bind(this));\n    }\n    /**\n    * Subscribe to an event. This will receive both locally emitted events\n    * as well as events emitted by other connected clients.\n    */\n    subscribe(name, callback) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        if (typeof callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        if (!this.emitter.hasListeners(name)) {\n            if (this.services.connection.isConnected) {\n                this.bulkSubscription.subscribe(name);\n            }\n        }\n        this.emitter.on(name, callback);\n    }\n    /**\n     * Removes a callback for a specified event. If all callbacks\n     * for an event have been removed, the server will be notified\n     * that the client is unsubscribed as a listener\n     */\n    unsubscribe(name, callback) {\n        if (!name || typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        if (callback !== undefined && typeof callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        if (!this.emitter.hasListeners(name)) {\n            this.services.logger.warn({\n                topic: message_constants_1.TOPIC.EVENT,\n                action: message_constants_1.EVENT_ACTIONS.NOT_SUBSCRIBED,\n                name\n            });\n            return;\n        }\n        this.emitter.off(name, callback);\n        if (!this.emitter.hasListeners(name)) {\n            this.bulkSubscription.unsubscribe(name);\n        }\n    }\n    /**\n     * Emits an event locally and sends a message to the server to\n     * broadcast the event to the other connected clients\n     */\n    emit(name, data) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        const message = {\n            topic: message_constants_1.TOPIC.EVENT,\n            action: message_constants_1.EVENT_ACTIONS.EMIT,\n            name,\n            parsedData: data\n        };\n        if (this.services.connection.isConnected) {\n            this.services.connection.sendMessage(message);\n        }\n        else if (this.services.connection.isInLimbo) {\n            this.limboQueue.push(message);\n        }\n        this.emitter.emit(name, data);\n    }\n    /**\n   * Allows to listen for event subscriptions made by this or other clients. This\n   * is useful to create \"active\" data providers, e.g. providers that only provide\n   * data for a particular event if a user is actually interested in it\n   */\n    listen(pattern, callback) {\n        this.listeners.listen(pattern, callback);\n    }\n    /**\n     * Removes a listener that was previously registered\n     */\n    unlisten(pattern) {\n        this.listeners.unlisten(pattern);\n    }\n    /**\n   * Handles incoming messages from the server\n   */\n    handle(message) {\n        if (message.isAck) {\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.EMIT) {\n            if (message.parsedData !== undefined) {\n                this.emitter.emit(message.name, message.parsedData);\n            }\n            else {\n                this.emitter.emit(message.name, undefined);\n            }\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.MESSAGE_DENIED) {\n            this.services.logger.error({ topic: message_constants_1.TOPIC.EVENT }, message_constants_1.EVENT_ACTIONS.MESSAGE_DENIED);\n            this.services.timeoutRegistry.remove(message);\n            if (message.originalAction === message_constants_1.EVENT_ACTIONS.SUBSCRIBE) {\n                this.emitter.off(message.name);\n            }\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.MULTIPLE_SUBSCRIPTIONS) {\n            this.services.timeoutRegistry.remove(Object.assign({}, message, {\n                action: message_constants_1.EVENT_ACTIONS.SUBSCRIBE\n            }));\n            this.services.logger.warn(message);\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.NOT_SUBSCRIBED) {\n            this.services.timeoutRegistry.remove(Object.assign({}, message, {\n                action: message_constants_1.EVENT_ACTIONS.SUBSCRIBE\n            }));\n            this.services.logger.warn(message);\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND ||\n            message.action === message_constants_1.EVENT_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED) {\n            this.listeners.handle(message);\n            return;\n        }\n        if (message.action === message_constants_1.EVENT_ACTIONS.INVALID_LISTEN_REGEX) {\n            this.services.logger.error(message);\n            return;\n        }\n        this.services.logger.error(message, constants_1.EVENT.UNSOLICITED_MESSAGE);\n    }\n    /**\n     * Resubscribes to events when connection is lost\n     */\n    onConnectionReestablished() {\n        this.bulkSubscription.subscribeList(this.emitter.eventNames());\n        for (let i = 0; i < this.limboQueue.length; i++) {\n            this.services.connection.sendMessage(this.limboQueue[i]);\n        }\n        this.limboQueue = [];\n    }\n    onExitLimbo() {\n        this.limboQueue = [];\n    }\n    onBulkSubscriptionSent(message) {\n        if (!message.names) {\n            this.services.timeoutRegistry.add({ message });\n        }\n    }\n}\nexports.EventHandler = EventHandler;\n\n\n//# sourceURL=webpack://deepstream/./src/event/event-handler.ts?")},"./src/presence/presence-handler.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst Emitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\nconst bulk_subscription_service_1 = __webpack_require__(/*! ../util/bulk-subscription-service */ \"./src/util/bulk-subscription-service.ts\");\nconst ONLY_EVENT = 'OE';\nfunction validateQueryArguments(rest) {\n    let users = null;\n    let callback = null;\n    if (rest.length === 1) {\n        if (Array.isArray(rest[0])) {\n            users = rest[0];\n        }\n        else {\n            if (typeof rest[0] !== 'function') {\n                throw new Error('invalid argument: \"callback\"');\n            }\n            callback = rest[0];\n        }\n    }\n    else if (rest.length === 2) {\n        users = rest[0];\n        callback = rest[1];\n        if (!Array.isArray(users) || typeof callback !== 'function') {\n            throw new Error('invalid argument: \"users\" or \"callback\"');\n        }\n    }\n    return { users, callback };\n}\nclass PresenceHandler {\n    constructor(services, options) {\n        this.services = services;\n        this.globalSubscriptionEmitter = new Emitter();\n        this.subscriptionEmitter = new Emitter();\n        this.queryEmitter = new Emitter();\n        this.queryAllEmitter = new Emitter();\n        this.counter = 0;\n        this.limboQueue = [];\n        this.bulkSubscription = new bulk_subscription_service_1.BulkSubscriptionService(this.services, options.subscriptionInterval, message_constants_1.TOPIC.PRESENCE, message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_BULK, null, message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_BULK, null, this.onBulkSubscriptionSent.bind(this));\n        this.services.connection.registerHandler(message_constants_1.TOPIC.PRESENCE, this.handle.bind(this));\n        this.services.connection.onExitLimbo(this.onExitLimbo.bind(this));\n        this.services.connection.onLost(this.onExitLimbo.bind(this));\n        this.services.connection.onReestablished(this.onConnectionReestablished.bind(this));\n    }\n    subscribe(userOrCallback, callback) {\n        if (typeof userOrCallback === 'string' && userOrCallback.length > 0 && typeof callback === 'function') {\n            const user = userOrCallback;\n            if (!this.subscriptionEmitter.hasListeners(user)) {\n                this.bulkSubscription.subscribe(user);\n            }\n            this.subscriptionEmitter.on(user, callback);\n            return;\n        }\n        if (typeof userOrCallback === 'function' && typeof callback === 'undefined') {\n            if (!this.globalSubscriptionEmitter.hasListeners(ONLY_EVENT)) {\n                this.subscribeToAllChanges();\n            }\n            this.globalSubscriptionEmitter.on(ONLY_EVENT, userOrCallback);\n            return;\n        }\n        throw new Error('invalid arguments: \"user\" or \"callback\"');\n    }\n    unsubscribe(userOrCallback, callback) {\n        if (userOrCallback && typeof userOrCallback === 'string' && userOrCallback.length > 0) {\n            const user = userOrCallback;\n            if (callback) {\n                if (typeof callback !== 'function') {\n                    throw new Error('invalid argument: \"callback\"');\n                }\n                this.subscriptionEmitter.off(user, callback);\n            }\n            else {\n                this.subscriptionEmitter.off(user);\n            }\n            if (!this.subscriptionEmitter.hasListeners(user)) {\n                this.bulkSubscription.unsubscribe(user);\n                return;\n            }\n        }\n        if (userOrCallback && typeof userOrCallback === 'function') {\n            callback = userOrCallback;\n            this.globalSubscriptionEmitter.off(ONLY_EVENT, callback);\n            if (!this.globalSubscriptionEmitter.hasListeners(ONLY_EVENT)) {\n                this.unsubscribeToAllChanges();\n            }\n            return;\n        }\n        if (typeof userOrCallback === 'undefined' && typeof callback === 'undefined') {\n            this.subscriptionEmitter.off();\n            this.globalSubscriptionEmitter.off();\n            this.bulkSubscription.unsubscribeList(this.subscriptionEmitter.eventNames());\n            this.unsubscribeToAllChanges();\n            return;\n        }\n        throw new Error('invalid argument: \"user\" or \"callback\"');\n    }\n    getAll(...rest) {\n        const { callback, users } = validateQueryArguments(rest);\n        let message;\n        let emitter;\n        let emitterAction;\n        if (users) {\n            const queryId = (this.counter++).toString();\n            message = {\n                topic: message_constants_1.TOPIC.PRESENCE,\n                action: message_constants_1.PRESENCE_ACTIONS.QUERY,\n                correlationId: queryId,\n                names: users\n            };\n            emitter = this.queryEmitter;\n            emitterAction = queryId;\n        }\n        else {\n            message = {\n                topic: message_constants_1.TOPIC.PRESENCE,\n                action: message_constants_1.PRESENCE_ACTIONS.QUERY_ALL\n            };\n            emitter = this.queryAllEmitter;\n            emitterAction = ONLY_EVENT;\n        }\n        if (this.services.connection.isConnected) {\n            this.sendQuery(message);\n        }\n        else if (this.services.connection.isInLimbo) {\n            this.limboQueue.push(message);\n        }\n        else {\n            this.services.timerRegistry.requestIdleCallback(() => {\n                emitter.emit(emitterAction, constants_1.EVENT.CLIENT_OFFLINE);\n            });\n        }\n        if (callback) {\n            emitter.once(emitterAction, callback);\n            return;\n        }\n        return new Promise((resolve, reject) => {\n            emitter.once(emitterAction, (error, results) => error ? reject(error) : resolve(results));\n        });\n    }\n    handle(message) {\n        if (message.isAck) {\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.QUERY_ALL_RESPONSE) {\n            this.queryAllEmitter.emit(ONLY_EVENT, null, message.names);\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.QUERY_RESPONSE) {\n            this.queryEmitter.emit(message.correlationId, null, message.parsedData);\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.PRESENCE_JOIN) {\n            this.subscriptionEmitter.emit(message.name, message.name, true);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.PRESENCE_JOIN_ALL) {\n            this.globalSubscriptionEmitter.emit(ONLY_EVENT, message.name, true);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.PRESENCE_LEAVE) {\n            this.subscriptionEmitter.emit(message.name, message.name, false);\n            return;\n        }\n        if (message.action === message_constants_1.PRESENCE_ACTIONS.PRESENCE_LEAVE_ALL) {\n            this.globalSubscriptionEmitter.emit(ONLY_EVENT, message.name, false);\n            return;\n        }\n        if (message.isError) {\n            this.services.timeoutRegistry.remove(message);\n            if (message.originalAction === message_constants_1.PRESENCE_ACTIONS.QUERY) {\n                this.queryEmitter.emit(message.correlationId, message_constants_1.PRESENCE_ACTIONS[message.action]);\n            }\n            else if (message.originalAction === message_constants_1.PRESENCE_ACTIONS.QUERY_ALL) {\n                this.queryAllEmitter.emit(ONLY_EVENT, message_constants_1.PRESENCE_ACTIONS[message.action]);\n            }\n            else {\n                this.services.logger.error(message);\n            }\n            return;\n        }\n        this.services.logger.error(message, constants_1.EVENT.UNSOLICITED_MESSAGE);\n    }\n    sendQuery(message) {\n        this.services.connection.sendMessage(message);\n        this.services.timeoutRegistry.add({ message });\n    }\n    subscribeToAllChanges() {\n        if (!this.services.connection.isConnected) {\n            return;\n        }\n        const message = { topic: message_constants_1.TOPIC.PRESENCE, action: message_constants_1.PRESENCE_ACTIONS.SUBSCRIBE_ALL };\n        this.services.timeoutRegistry.add({ message });\n        this.services.connection.sendMessage(message);\n    }\n    unsubscribeToAllChanges() {\n        if (!this.services.connection.isConnected) {\n            return;\n        }\n        const message = { topic: message_constants_1.TOPIC.PRESENCE, action: message_constants_1.PRESENCE_ACTIONS.UNSUBSCRIBE_ALL };\n        this.services.timeoutRegistry.add({ message });\n        this.services.connection.sendMessage(message);\n    }\n    onConnectionReestablished() {\n        const keys = this.subscriptionEmitter.eventNames();\n        if (keys.length > 0) {\n            this.bulkSubscription.subscribeList(keys);\n        }\n        const hasGlobalSubscription = this.globalSubscriptionEmitter.hasListeners(ONLY_EVENT);\n        if (hasGlobalSubscription) {\n            this.subscribeToAllChanges();\n        }\n        for (let i = 0; i < this.limboQueue.length; i++) {\n            this.sendQuery(this.limboQueue[i]);\n        }\n        this.limboQueue = [];\n    }\n    onExitLimbo() {\n        this.queryEmitter.eventNames().forEach(correlationId => {\n            this.queryEmitter.emit(correlationId, constants_1.EVENT.CLIENT_OFFLINE);\n        });\n        this.queryAllEmitter.emit(ONLY_EVENT, constants_1.EVENT.CLIENT_OFFLINE);\n        this.limboQueue = [];\n        this.queryAllEmitter.off();\n        this.queryEmitter.off();\n    }\n    onBulkSubscriptionSent(message) {\n        this.services.timeoutRegistry.add({ message });\n    }\n}\nexports.PresenceHandler = PresenceHandler;\n\n\n//# sourceURL=webpack://deepstream/./src/presence/presence-handler.ts?")},"./src/record/anonymous-record.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst utils = __webpack_require__(/*! ../util/utils */ "./src/util/utils.ts");\nconst Emitter = __webpack_require__(/*! component-emitter2 */ "./node_modules/component-emitter2/index.js");\nclass AnonymousRecord extends Emitter {\n    constructor(getRecordCore) {\n        super();\n        this.record = null;\n        this.subscriptions = [];\n        this.getRecordCore = getRecordCore;\n    }\n    get name() {\n        if (!this.record) {\n            return \'\';\n        }\n        return this.record.name;\n    }\n    get isReady() {\n        if (!this.record) {\n            return false;\n        }\n        return this.record.isReady;\n    }\n    get version() {\n        if (!this.record) {\n            return -1;\n        }\n        return this.record.version;\n    }\n    whenReady(callback) {\n        if (this.record) {\n            if (callback) {\n                this.record.whenReady(this, callback);\n            }\n            else {\n                return this.record.whenReady(this);\n            }\n        }\n    }\n    setName(recordName, callback) {\n        if (this.name === recordName) {\n            return;\n        }\n        this.discard();\n        this.record = this.getRecordCore(recordName);\n        for (let i = 0; i < this.subscriptions.length; i++) {\n            this.record.subscribe(this.subscriptions[i]);\n        }\n        this.emit(\'nameChanged\', recordName);\n        if (callback) {\n            this.record.whenReady(this, callback);\n        }\n        else {\n            return this.record.whenReady(this);\n        }\n    }\n    get(path) {\n        if (this.record) {\n            return this.record.get(path);\n        }\n    }\n    set(path, data, callback) {\n        if (this.record) {\n            return this.record.set(utils.normalizeSetArguments(arguments));\n        }\n    }\n    setWithAck(path, data, callback) {\n        if (this.record) {\n            return this.record.setWithAck(utils.normalizeSetArguments(arguments));\n        }\n    }\n    erase(path) {\n        if (this.record) {\n            return this.record.set(utils.normalizeSetArguments(arguments));\n        }\n    }\n    eraseWithAck(path, callback) {\n        if (this.record) {\n            return this.record.setWithAck(utils.normalizeSetArguments(arguments));\n        }\n    }\n    subscribe(path, callback, triggerNow) {\n        const parameters = utils.normalizeArguments(arguments);\n        this.subscriptions.push(parameters);\n        if (this.record) {\n            this.record.subscribe(parameters);\n        }\n    }\n    unsubscribe(path, callback) {\n        const parameters = utils.normalizeArguments(arguments);\n        this.subscriptions = this.subscriptions.filter(subscription => {\n            return (subscription.path !== parameters.path ||\n                subscription.callback !== parameters.callback);\n        });\n        if (this.record) {\n            this.record.unsubscribe(parameters);\n        }\n    }\n    discard() {\n        if (this.record) {\n            for (let i = 0; i < this.subscriptions.length; i++) {\n                this.record.unsubscribe(this.subscriptions[i]);\n            }\n            return this.record.discard();\n        }\n    }\n    delete(callback) {\n        if (this.record) {\n            return this.record.delete(callback);\n        }\n    }\n    setMergeStrategy(mergeStrategy) {\n        if (this.record) {\n            this.record.setMergeStrategy(mergeStrategy);\n        }\n    }\n}\nexports.AnonymousRecord = AnonymousRecord;\n\n\n//# sourceURL=webpack://deepstream/./src/record/anonymous-record.ts?')},"./src/record/dirty-service.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nclass DirtyService {\n    constructor(storage, dirtyStorageName) {\n        this.storage = storage;\n        this.dirtyStorageName = dirtyStorageName;\n        this.dirtyRecords = new Map();\n        this.loadedCallback = [];\n        this.loaded = false;\n        this.load();\n    }\n    isDirty(recordName) {\n        return this.dirtyRecords.has(recordName);\n    }\n    setDirty(recordName, isDirty) {\n        if (isDirty) {\n            this.dirtyRecords.set(recordName, true);\n        }\n        else {\n            this.dirtyRecords.delete(recordName);\n        }\n        this.storage.set(this.dirtyStorageName, 1, [...this.dirtyRecords], () => { });\n    }\n    whenLoaded(context, callback) {\n        if (this.loaded) {\n            callback.call(context);\n            return;\n        }\n        this.loadedCallback.push({ callback, context });\n    }\n    getAll() {\n        return this.dirtyRecords;\n    }\n    load() {\n        if (this.loaded) {\n            return;\n        }\n        this.storage.get(this.dirtyStorageName, (recordName, version, data) => {\n            this.dirtyRecords = data ? new Map(data) : new Map();\n            this.loaded = true;\n            this.loadedCallback.forEach(({ callback, context }) => callback.call(context));\n        });\n    }\n}\nexports.DirtyService = DirtyService;\n\n\n//# sourceURL=webpack://deepstream/./src/record/dirty-service.ts?')},"./src/record/json-path.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils = __webpack_require__(/*! ../util/utils */ \"./src/util/utils.ts\");\nconst SPLIT_REG_EXP = /[[\\]]/g;\n/**\n* Returns the value of the path or\n* undefined if the path can't be resolved\n*/\nfunction get(data, path, deepCopy) {\n    const tokens = tokenize(path);\n    let value = data;\n    for (let i = 0; i < tokens.length; i++) {\n        if (value === undefined) {\n            return undefined;\n        }\n        if (typeof value !== 'object') {\n            throw new Error('invalid data or path');\n        }\n        value = value[tokens[i]];\n    }\n    return deepCopy !== false ? utils.deepCopy(value) : value;\n}\nexports.get = get;\n/**\n * This class allows to set or get specific\n * values within a json data structure using\n * string-based paths\n */\nfunction setValue(root, path, value) {\n    if (path === null) {\n        return value;\n    }\n    const tokens = tokenize(path);\n    const rootCopy = utils.deepCopy(root);\n    const valueCopy = utils.deepCopy(value);\n    let node = rootCopy;\n    let i;\n    for (i = 0; i < tokens.length - 1; i++) {\n        const token = tokens[i];\n        if (node[token] !== undefined && node[token] !== null && typeof node[token] === 'object') {\n            node = node[token];\n        }\n        else if (typeof tokens[i + 1] === 'number') {\n            const array = new Array(tokens[i + 1]);\n            array.fill(null);\n            node = node[token] = array;\n        }\n        else {\n            node = node[token] = {};\n        }\n    }\n    if (value === undefined) {\n        delete node[tokens[i]];\n    }\n    else {\n        node[tokens[i]] = valueCopy;\n    }\n    return rootCopy;\n}\nexports.setValue = setValue;\n/**\n * Parses the path. Splits it into\n * keys for objects and indices for arrays.\n */\nfunction tokenize(path) {\n    if (path === null) {\n        return [];\n    }\n    const tokens = [];\n    const parts = path.split('.');\n    for (let i = 0; i < parts.length; i++) {\n        const part = parts[i].trim();\n        if (part.length === 0) {\n            continue;\n        }\n        const arrayIndexes = part.split(SPLIT_REG_EXP);\n        if (arrayIndexes.length === 0) {\n            // TODO\n            continue;\n        }\n        tokens.push(arrayIndexes[0]);\n        for (let j = 1; j < arrayIndexes.length; j++) {\n            if (arrayIndexes[j].length === 0) {\n                continue;\n            }\n            tokens.push(Number(arrayIndexes[j]));\n        }\n    }\n    return tokens;\n}\n\n\n//# sourceURL=webpack://deepstream/./src/record/json-path.ts?")},"./src/record/list.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils = __webpack_require__(/*! ../util/utils */ \"./src/util/utils.ts\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst Emitter = __webpack_require__(/*! component-emitter2 */ \"./node_modules/component-emitter2/index.js\");\nclass List extends Emitter {\n    constructor(record) {\n        super();\n        this.record = record;\n        this.originalApplyUpdate = this.record.applyUpdate.bind(this.record);\n        this.record.applyUpdate = this.applyUpdate.bind(this);\n        this.wrappedFunctions = new Map();\n        this.hasAddListener = false;\n        this.hasRemoveListener = false;\n        this.hasMoveListener = false;\n    }\n    get name() {\n        return this.record.name;\n    }\n    get isReady() {\n        return this.record.isReady;\n    }\n    get version() {\n        return this.record.version;\n    }\n    whenReady(callback) {\n        if (callback) {\n            this.record.whenReady(this, callback);\n        }\n        else {\n            return this.record.whenReady(this);\n        }\n    }\n    /**\n     * Returns the array of list entries or an\n     * empty array if the list hasn't been populated yet.\n     */\n    getEntries() {\n        const entries = this.record.get();\n        if (!(entries instanceof Array)) {\n            return [];\n        }\n        return entries;\n    }\n    /**\n   * Returns true if the list is empty\n   */\n    isEmpty() {\n        return this.getEntries().length === 0;\n    }\n    setEntriesWithAck(entries, callback) {\n        if (!callback) {\n            return new Promise((resolve, reject) => {\n                this.setEntries(entries, (error) => {\n                    if (error) {\n                        reject(error);\n                    }\n                    else {\n                        resolve();\n                    }\n                });\n            });\n        }\n        this.setEntries(entries, callback);\n    }\n    /**\n    * Updates the list with a new set of entries\n    */\n    setEntries(entries, callback) {\n        const errorMsg = 'entries must be an array of record names';\n        let i;\n        if (!(entries instanceof Array)) {\n            throw new Error(errorMsg);\n        }\n        for (i = 0; i < entries.length; i++) {\n            if (typeof entries[i] !== 'string') {\n                throw new Error(errorMsg);\n            }\n        }\n        if (this.record.isReady === false) {\n            // ...\n        }\n        else {\n            this.beforeChange();\n            this.record.set({ data: entries, callback });\n            this.afterChange();\n        }\n    }\n    /**\n     * Removes an entry from the list\n     *\n     * @param {String} entry\n     * @param {Number} [index]\n     */\n    removeEntry(entry, index, callback) {\n        if (this.record.isReady === false) {\n            // ...\n            return;\n        }\n        // @ts-ignore\n        const currentEntries = this.record.get();\n        const hasIndex = this.hasIndex(index);\n        const entries = [];\n        let i;\n        for (i = 0; i < currentEntries.length; i++) {\n            if (currentEntries[i] !== entry || (hasIndex && index !== i)) {\n                entries.push(currentEntries[i]);\n            }\n        }\n        this.beforeChange();\n        this.record.set({ data: entries, callback });\n        this.afterChange();\n    }\n    /**\n   * Adds an entry to the list\n   *\n   * @param {String} entry\n   * @param {Number} [index]\n   */\n    addEntry(entry, index, callback) {\n        if (typeof entry !== 'string') {\n            throw new Error('Entry must be a recordName');\n        }\n        if (this.record.isReady === false) {\n            // ..\n            return;\n        }\n        const hasIndex = this.hasIndex(index);\n        const entries = this.getEntries();\n        if (hasIndex) {\n            entries.splice(index, 0, entry);\n        }\n        else {\n            entries.push(entry);\n        }\n        this.beforeChange();\n        this.record.set({ data: entries, callback });\n        this.afterChange();\n    }\n    /**\n   * Proxies the underlying Record's subscribe method. Makes sure\n   * that no path is provided\n   */\n    subscribe(callback) {\n        const parameters = utils.normalizeArguments(arguments);\n        if (parameters.path) {\n            throw new Error('path is not supported for List.subscribe');\n        }\n        // Make sure the callback is invoked with an empty array for new records\n        const listCallback = function (scope, cb) {\n            cb(scope.getEntries());\n        }.bind(this, this, parameters.callback);\n        /**\n        * Adding a property onto a function directly is terrible practice,\n        * and we will change this as soon as we have a more seperate approach\n        * of creating lists that doesn't have records default state.\n        *\n        * The reason we are holding a referencing to wrapped array is so that\n        * on unsubscribe it can provide a reference to the actual method the\n        * record is subscribed too.\n        **/\n        this.wrappedFunctions.set(parameters.callback, listCallback);\n        parameters.callback = listCallback;\n        this.record.subscribe(parameters);\n    }\n    /**\n   * Proxies the underlying Record's unsubscribe method. Makes sure\n   * that no path is provided\n   */\n    unsubscribe(callback) {\n        const parameters = utils.normalizeArguments(arguments);\n        if (parameters.path) {\n            throw new Error('path is not supported for List.unsubscribe');\n        }\n        const listenCallback = this.wrappedFunctions.get(parameters.callback);\n        parameters.callback = listenCallback;\n        this.record.unsubscribe(parameters);\n        this.wrappedFunctions.delete(parameters.callback);\n    }\n    /**\n     * Proxies the underlying Record's _update method. Set's\n     * data to an empty array if no data is provided.\n     */\n    applyUpdate(message) {\n        if (!(message.parsedData instanceof Array)) {\n            message.parsedData = [];\n        }\n        this.beforeChange();\n        this.originalApplyUpdate(message);\n        this.afterChange();\n    }\n    /**\n     * Validates that the index provided is within the current set of entries.\n     */\n    hasIndex(index) {\n        let hasIndex = false;\n        const entries = this.getEntries();\n        if (index !== undefined) {\n            if (isNaN(index)) {\n                throw new Error('Index must be a number');\n            }\n            if (index !== entries.length && (index >= entries.length || index < 0)) {\n                throw new Error('Index must be within current entries');\n            }\n            hasIndex = true;\n        }\n        return hasIndex;\n    }\n    /**\n     * Establishes the current structure of the list, provided the client has attached any\n     * add / move / remove listener\n     *\n     * This will be called before any change to the list, regardsless if the change was triggered\n     * by an incoming message from the server or by the client\n     */\n    beforeChange() {\n        this.hasAddListener = this.listeners(constants_1.EVENT.ENTRY_ADDED_EVENT).length > 0;\n        this.hasRemoveListener = this.listeners(constants_1.EVENT.ENTRY_REMOVED_EVENT).length > 0;\n        this.hasMoveListener = this.listeners(constants_1.EVENT.ENTRY_MOVED_EVENT).length > 0;\n        if (this.hasAddListener || this.hasRemoveListener || this.hasMoveListener) {\n            this.beforeStructure = this.getStructure();\n        }\n        else {\n            this.beforeStructure = null;\n        }\n    }\n    /**\n     * Compares the structure of the list after a change to its previous structure and notifies\n     * any add / move / remove listener. Won't do anything if no listeners are attached.\n     */\n    afterChange() {\n        if (this.beforeStructure === null) {\n            return;\n        }\n        const after = this.getStructure();\n        const before = this.beforeStructure;\n        let entry;\n        let i;\n        if (this.hasRemoveListener) {\n            for (entry in before) {\n                for (i = 0; i < before[entry].length; i++) {\n                    if (after[entry] === undefined || after[entry][i] === undefined) {\n                        this.emit(constants_1.EVENT.ENTRY_REMOVED_EVENT, entry, before[entry][i]);\n                    }\n                }\n            }\n        }\n        if (this.hasAddListener || this.hasMoveListener) {\n            for (entry in after) {\n                if (before[entry] === undefined) {\n                    for (i = 0; i < after[entry].length; i++) {\n                        this.emit(constants_1.EVENT.ENTRY_ADDED_EVENT, entry, after[entry][i]);\n                    }\n                }\n                else {\n                    for (i = 0; i < after[entry].length; i++) {\n                        if (before[entry][i] !== after[entry][i]) {\n                            if (before[entry][i] === undefined) {\n                                this.emit(constants_1.EVENT.ENTRY_ADDED_EVENT, entry, after[entry][i]);\n                            }\n                            else {\n                                this.emit(constants_1.EVENT.ENTRY_MOVED_EVENT, entry, after[entry][i]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Iterates through the list and creates a map with the entry as a key\n     * and an array of its position(s) within the list as a value, e.g.\n     *\n     * {\n     *   'recordA': [ 0, 3 ],\n     *   'recordB': [ 1 ],\n     *   'recordC': [ 2 ]\n     * }\n     */\n    getStructure() {\n        const structure = {};\n        let i;\n        const entries = this.getEntries();\n        for (i = 0; i < entries.length; i++) {\n            if (structure[entries[i]] === undefined) {\n                structure[entries[i]] = [i];\n            }\n            else {\n                structure[entries[i]].push(i);\n            }\n        }\n        return structure;\n    }\n}\nexports.List = List;\n\n\n//# sourceURL=webpack://deepstream/./src/record/list.ts?")},"./src/record/merge-strategy-service.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nclass MergeStrategyService {\n    constructor(services, defaultStrategy) {\n        this.services = services;\n        this.defaultStrategy = defaultStrategy;\n        this.strategiesByRecord = new Map();\n        this.strategiesByPattern = new Map();\n    }\n    setMergeStrategyByName(recordName, strategy) {\n        this.strategiesByRecord.set(recordName, strategy);\n    }\n    setMergeStrategyByPattern(pattern, strategy) {\n        this.strategiesByPattern.set(pattern, strategy);\n    }\n    merge(recordName, localVersion, localData, remoteVersion, remoteData, callback, context) {\n        const exactMergeStrategy = this.strategiesByRecord.get(recordName);\n        if (exactMergeStrategy) {\n            exactMergeStrategy(localData, localVersion, remoteData, remoteVersion, (error, data) => {\n                callback.call(context, error, recordName, data, remoteVersion, remoteData, localVersion, localData);\n            });\n            return;\n        }\n        for (const [pattern, patternMergeStrategy] of this.strategiesByPattern) {\n            if (pattern.test(recordName)) {\n                patternMergeStrategy(localData, localVersion, remoteData, remoteVersion, (error, data) => {\n                    callback.call(context, error, recordName, data, remoteVersion, remoteData, localVersion, localData);\n                });\n                return;\n            }\n        }\n        if (this.defaultStrategy) {\n            this.defaultStrategy(localData, localVersion, remoteData, remoteVersion, (error, data) => {\n                callback.call(context, error, recordName, data, remoteVersion, remoteData, localVersion, localData);\n            });\n        }\n        this.services.logger.error({ topic: message_constants_1.TOPIC.RECORD }, constants_1.EVENT.RECORD_VERSION_EXISTS, { remoteVersion, recordName });\n    }\n}\nexports.MergeStrategyService = MergeStrategyService;\n\n\n//# sourceURL=webpack://deepstream/./src/record/merge-strategy-service.ts?')},"./src/record/merge-strategy.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n *  Choose the server's state over the client's\n**/\nexports.REMOTE_WINS = (localValue, localVersion, remoteValue, remoteVersion, callback) => {\n    callback(null, remoteValue);\n};\n/**\n *  Choose the local state over the server's\n**/\nexports.LOCAL_WINS = (localValue, localVersion, remoteValue, remoteVersion, callback) => {\n    callback(null, localValue);\n};\n\n\n//# sourceURL=webpack://deepstream/./src/record/merge-strategy.ts?")},"./src/record/noop-storage-service.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nclass NoopStorage {\n    get(recordName, callback) {\n        setTimeout(callback.bind(this, recordName, -1, null), 0);\n    }\n    set(recordName, version, data, callback) {\n        setTimeout(callback, 0);\n    }\n    delete(recordName, callback) {\n        setTimeout(callback, 0);\n    }\n}\nexports.NoopStorage = NoopStorage;\n\n\n//# sourceURL=webpack://deepstream/./src/record/noop-storage-service.ts?')},"./src/record/record-core.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nconst json_path_1 = __webpack_require__(/*! ./json-path */ "./src/record/json-path.ts");\nconst Emitter = __webpack_require__(/*! component-emitter2 */ "./node_modules/component-emitter2/index.js");\nconst utils = __webpack_require__(/*! ../util/utils */ "./src/util/utils.ts");\nconst state_machine_1 = __webpack_require__(/*! ../util/state-machine */ "./src/util/state-machine.ts");\nclass RecordCore extends Emitter {\n    constructor(name, services, options, recordServices, whenComplete) {\n        super();\n        this.name = name;\n        this.services = services;\n        this.options = options;\n        this.recordServices = recordServices;\n        this.whenComplete = whenComplete;\n        this.readyCallbacks = [];\n        this.emitter = new Emitter();\n        this.data = Object.create(null);\n        this.references = 1;\n        this.hasProvider = false;\n        this.pendingWrites = [];\n        this.isReady = false;\n        this.offlineLoadingAborted = false;\n        this.version = null;\n        this.responseTimeout = null;\n        this.discardTimeout = null;\n        this.deletedTimeout = null;\n        this.readyTimer = -1;\n        this.deleteResponse = null;\n        if (typeof name !== \'string\' || name.length === 0) {\n            throw new Error(\'invalid argument name\');\n        }\n        this.onConnectionLost = this.onConnectionLost.bind(this);\n        this.onConnectionReestablished = this.onConnectionReestablished.bind(this);\n        this.stateMachine = new state_machine_1.StateMachine(this.services.logger, {\n            init: "INITIAL" /* INITIAL */,\n            context: this,\n            onStateChanged: this.onStateChanged,\n            transitions: recordStateTransitions\n        });\n        this.recordServices.dirtyService.whenLoaded(this, this.onRecordLoadedFromStorage);\n    }\n    get recordState() {\n        return this.stateMachine.state;\n    }\n    set usages(usages) {\n        this.references = usages;\n        if (this.references === 1) {\n            this.services.timeoutRegistry.clear(this.discardTimeout);\n            this.services.timerRegistry.remove(this.readyTimer);\n            this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.SUBSCRIBE);\n        }\n    }\n    get usages() {\n        return this.references;\n    }\n    onRecordLoadedFromStorage() {\n        if (this.services.connection.isConnected) {\n            if (!this.recordServices.dirtyService.isDirty(this.name)) {\n                this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.SUBSCRIBE);\n            }\n            else {\n                this.services.storage.get(this.name, (recordName, version, data) => {\n                    this.version = version;\n                    this.data = data;\n                    this.stateMachine.transition("RESUBSCRIBE" /* RESUBSCRIBE */);\n                });\n            }\n        }\n        else {\n            this.stateMachine.transition("LOAD" /* LOAD */);\n        }\n        this.services.connection.onReestablished(this.onConnectionReestablished);\n        this.services.connection.onLost(this.onConnectionLost);\n    }\n    onStateChanged(newState, oldState) {\n        this.emitter.emit(constants_1.EVENT.RECORD_STATE_CHANGED, newState);\n    }\n    whenReady(context, callback) {\n        if (callback) {\n            this.whenReadyInternal(context, (realContext) => {\n                callback(realContext);\n            });\n            return;\n        }\n        return new Promise(resolve => this.whenReadyInternal(context, () => resolve(context)));\n    }\n    /**\n   */\n    whenReadyInternal(context, callback) {\n        if (this.isReady === true) {\n            callback(context);\n            return;\n        }\n        if (callback) {\n            this.readyCallbacks.push({ callback, context });\n        }\n    }\n    /**\n   * Sets the value of either the entire dataset\n   * or of a specific path within the record\n   * and submits the changes to the server\n   *\n   * If the new data is equal to the current data, nothing will happen\n   *\n   * @param {[String|Object]} pathOrData Either a JSON path when called with\n   *                                     two arguments or the data itself\n   * @param {Object} data     The data that should be stored in the record\n   */\n    set({ path, data, callback }) {\n        if (!path && (data === null || typeof data !== \'object\')) {\n            throw new Error(\'invalid arguments, scalar values cannot be set without path\');\n        }\n        if (this.checkDestroyed(\'set\')) {\n            return;\n        }\n        if (this.isReady === false) {\n            this.pendingWrites.push({ path, data, callback });\n            return;\n        }\n        const oldValue = this.data;\n        const newValue = json_path_1.setValue(oldValue, path || null, data);\n        if (oldValue === newValue) {\n            if (callback) {\n                this.services.timerRegistry.requestIdleCallback(() => callback(null, this.name));\n            }\n            return;\n        }\n        this.applyChange(newValue);\n        if (this.services.connection.isConnected) {\n            this.sendUpdate(path, data, callback);\n        }\n        else {\n            if (callback) {\n                callback(constants_1.EVENT.CLIENT_OFFLINE, this.name);\n            }\n            this.saveUpdate();\n        }\n    }\n    /**\n     * Wrapper function around the record.set that returns a promise\n     * if no callback is supplied.\n     * @returns {Promise} if a callback is omitted a Promise is returned with the result of the write\n     */\n    setWithAck(args) {\n        if (args.callback) {\n            this.set(args);\n            return;\n        }\n        return new Promise((resolve, reject) => {\n            args.callback = error => error === null ? resolve() : reject(error);\n            this.set(args);\n        });\n    }\n    /**\n   * Returns a copy of either the entire dataset of the record\n   * or - if called with a path - the value of that path within\n   * the record\'s dataset.\n   *\n   * Returning a copy rather than the actual value helps to prevent\n   * the record getting out of sync due to unintentional changes to\n   * its data\n   */\n    get(path) {\n        return json_path_1.get(this.data, path || null, this.options.recordDeepCopy);\n    }\n    /**\n   * Subscribes to changes to the records dataset.\n   *\n   * Callback is the only mandatory argument.\n   *\n   * When called with a path, it will only subscribe to updates\n   * to that path, rather than the entire record\n   *\n   * If called with true for triggerNow, the callback will\n   * be called immediatly with the current value\n   */\n    subscribe(args) {\n        if (args.path !== undefined && (typeof args.path !== \'string\' || args.path.length === 0)) {\n            throw new Error(\'invalid argument path\');\n        }\n        if (typeof args.callback !== \'function\') {\n            throw new Error(\'invalid argument callback\');\n        }\n        if (this.checkDestroyed(\'subscribe\')) {\n            return;\n        }\n        if (args.triggerNow) {\n            this.whenReadyInternal(null, () => {\n                this.emitter.on(args.path || \'\', args.callback);\n                args.callback(this.get(args.path));\n            });\n        }\n        else {\n            this.emitter.on(args.path || \'\', args.callback);\n        }\n    }\n    /**\n     * Removes a subscription that was previously made using record.subscribe()\n     *\n     * Can be called with a path to remove the callback for this specific\n     * path or only with a callback which removes it from the generic subscriptions\n     *\n     * Please Note: unsubscribe is a purely client side operation. If the app is no longer\n     * interested in receiving updates for this record from the server it needs to call\n     * discard instead\n     *\n     * @param   {String}           path  A JSON path\n     * @param   {Function}         callback     The callback method. Please note, if a bound\n     *                                          method was passed to subscribe, the same method\n     *                                          must be passed to unsubscribe as well.\n     */\n    unsubscribe(args) {\n        if (args.path !== undefined && (typeof args.path !== \'string\' || args.path.length === 0)) {\n            throw new Error(\'invalid argument path\');\n        }\n        if (args.callback !== undefined && typeof args.callback !== \'function\') {\n            throw new Error(\'invalid argument callback\');\n        }\n        if (this.checkDestroyed(\'unsubscribe\')) {\n            return;\n        }\n        this.emitter.off(args.path || \'\', args.callback);\n    }\n    /**\n    * Removes all change listeners and notifies the server that the client is\n    * no longer interested in updates for this record\n    */\n    discard() {\n        if (this.checkDestroyed(\'discard\')) {\n            return;\n        }\n        this.whenReadyInternal(null, () => {\n            this.references--;\n            if (this.references <= 0) {\n                this.readyTimer = this.services.timerRegistry.add({\n                    duration: this.options.recordReadTimeout,\n                    callback: this.stateMachine.transition,\n                    context: this.stateMachine,\n                    data: message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE_ACK\n                });\n            }\n        });\n        this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE);\n    }\n    /**\n     * Deletes the record on the server.\n     */\n    delete(callback) {\n        if (!this.services.connection.isConnected) {\n            // this.services.logger.warn({ topic: TOPIC.RECORD }, RA.DELETE, \'Deleting while offline is not supported\')\n            if (callback) {\n                this.services.timerRegistry.requestIdleCallback(() => {\n                    callback(\'Deleting while offline is not supported\');\n                });\n                return;\n            }\n            return Promise.reject(\'Deleting while offline is not supported\');\n        }\n        if (this.checkDestroyed(\'delete\')) {\n            return;\n        }\n        this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.DELETE);\n        if (callback && typeof callback === \'function\') {\n            this.deleteResponse = { callback };\n            this.sendDelete();\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                this.deleteResponse = { resolve, reject };\n                this.sendDelete();\n            });\n        }\n    }\n    /**\n     * Set a merge strategy to resolve any merge conflicts that may occur due\n     * to offline work or write conflicts. The function will be called with the\n     * local record, the remote version/data and a callback to call once the merge has\n     * completed or if an error occurs ( which leaves it in an inconsistent state until\n     * the next update merge attempt ).\n     */\n    setMergeStrategy(mergeStrategy) {\n        this.recordServices.mergeStrategy.setMergeStrategyByName(this.name, mergeStrategy);\n    }\n    saveRecordToOffline() {\n        this.services.storage.set(this.name, this.version, this.data, () => { });\n    }\n    /**\n     * Transition States\n     */\n    onSubscribing() {\n        this.recordServices.readRegistry.register(this.name, this, this.handleReadResponse);\n        this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RECORD,\n                action: message_constants_1.RECORD_ACTIONS.SUBSCRIBE,\n                name: this.name,\n            }\n        });\n        this.responseTimeout = this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RECORD,\n                action: message_constants_1.RECORD_ACTIONS.READ_RESPONSE,\n                name: this.name\n            }\n        });\n        this.recordServices.bulkSubscriptionService[message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD_BULK].subscribe(this.name);\n    }\n    onResubscribing() {\n        this.services.timerRegistry.remove(this.readyTimer);\n        this.recordServices.headRegistry.register(this.name, this, this.handleHeadResponse);\n        this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RECORD,\n                action: message_constants_1.RECORD_ACTIONS.SUBSCRIBE,\n                name: this.name,\n            }\n        });\n        this.responseTimeout = this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RECORD,\n                action: message_constants_1.RECORD_ACTIONS.HEAD,\n                name: this.name\n            }\n        });\n        this.recordServices.bulkSubscriptionService[message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD_BULK].subscribe(this.name);\n    }\n    onOfflineLoading() {\n        this.services.storage.get(this.name, (recordName, version, data) => {\n            if (version === -1) {\n                if (this.offlineLoadingAborted) {\n                    // This occurred since we got a connection to the server\n                    // meaning we no longer care about current state currently\n                    this.offlineLoadingAborted = false;\n                    return;\n                }\n                this.data = {};\n                this.version = 1;\n                this.recordServices.dirtyService.setDirty(this.name, true);\n                this.services.storage.set(this.name, this.version, this.data, error => {\n                    this.stateMachine.transition("LOADED" /* LOADED */);\n                });\n            }\n            else {\n                this.data = data;\n                this.version = version;\n                this.stateMachine.transition("LOADED" /* LOADED */);\n            }\n        });\n    }\n    abortOfflineLoading() {\n        this.offlineLoadingAborted = true;\n        this.onResubscribing();\n    }\n    onReady() {\n        this.services.timeoutRegistry.clear(this.responseTimeout);\n        this.applyPendingWrites();\n        this.isReady = true;\n        this.readyCallbacks.forEach(({ context, callback }) => {\n            callback.call(context, context);\n        });\n    }\n    applyPendingWrites() {\n        const writeCallbacks = [];\n        const oldData = this.data;\n        let newData = oldData;\n        for (let i = 0; i < this.pendingWrites.length; i++) {\n            const { callback, path, data } = this.pendingWrites[i];\n            if (callback) {\n                writeCallbacks.push(callback);\n            }\n            newData = json_path_1.setValue(newData, path || null, data);\n        }\n        this.pendingWrites = [];\n        this.applyChange(newData);\n        const runFns = (err) => {\n            for (let i = 0; i < writeCallbacks.length; i++) {\n                writeCallbacks[i](err, this.name);\n            }\n        };\n        if (utils.deepEquals(oldData, newData)) {\n            runFns(null);\n            return;\n        }\n        if (this.services.connection.isConnected) {\n            this.sendUpdate(null, newData, runFns);\n        }\n        else {\n            runFns(constants_1.EVENT.CLIENT_OFFLINE);\n            this.saveUpdate();\n        }\n    }\n    onUnsubscribed() {\n        if (this.services.connection.isConnected) {\n            const message = {\n                topic: message_constants_1.TOPIC.RECORD,\n                action: message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE,\n                name: this.name\n            };\n            this.discardTimeout = this.services.timeoutRegistry.add({ message });\n            this.services.connection.sendMessage(message);\n        }\n        this.emit(constants_1.EVENT.RECORD_DISCARDED);\n        this.destroy();\n    }\n    onDeleted() {\n        this.emit(constants_1.EVENT.RECORD_DELETED);\n        this.destroy();\n    }\n    handle(message) {\n        if (message.isAck) {\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.PATCH || message.action === message_constants_1.RECORD_ACTIONS.UPDATE || message.action === message_constants_1.RECORD_ACTIONS.ERASE) {\n            if (this.stateMachine.state === "MERGING" /* MERGING */) {\n                // The scenario this covers is when a read is requested because the head doesn\'t match\n                // but an updated comes in because we subscribed. In that scenario we just ignore the update\n                // and wait for the read response. Hopefully the messages don\'t cross on the wire in which case\n                // it might result in another merge conflict.\n                return;\n            }\n            this.applyUpdate(message);\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS) {\n            this.services.timeoutRegistry.clear(this.deletedTimeout);\n            this.stateMachine.transition(message.action);\n            if (this.deleteResponse.callback) {\n                this.deleteResponse.callback(null);\n            }\n            else if (this.deleteResponse.resolve) {\n                this.deleteResponse.resolve();\n            }\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.DELETED) {\n            this.stateMachine.transition(message.action);\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.VERSION_EXISTS) {\n            // what kind of message is version exists?\n            // this.recoverRecord(message)\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED ||\n            message.action === message_constants_1.RECORD_ACTIONS.MESSAGE_PERMISSION_ERROR) {\n            if (message.originalAction === message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD ||\n                message.originalAction === message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD ||\n                message.originalAction === message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD) {\n                const subscribeMsg = Object.assign({}, message, { originalAction: message_constants_1.RECORD_ACTIONS.SUBSCRIBE });\n                const actionMsg = Object.assign({}, message, { originalAction: message.originalAction === message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD ? message_constants_1.RECORD_ACTIONS.READ_RESPONSE : message_constants_1.RECORD_ACTIONS.HEAD_RESPONSE });\n                this.services.timeoutRegistry.remove(subscribeMsg);\n                this.services.timeoutRegistry.remove(actionMsg);\n            }\n            this.emit(constants_1.EVENT.RECORD_ERROR, message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED], message_constants_1.RECORD_ACTIONS[message.originalAction]);\n            if (message.originalAction === message_constants_1.RECORD_ACTIONS.DELETE) {\n                if (this.deleteResponse.callback) {\n                    this.deleteResponse.callback(message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED]);\n                }\n                else if (this.deleteResponse.reject) {\n                    this.deleteResponse.reject(message_constants_1.RECORD_ACTIONS[message_constants_1.RECORD_ACTIONS.MESSAGE_DENIED]);\n                }\n            }\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_PROVIDER ||\n            message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_NO_PROVIDER) {\n            this.hasProvider = message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_PROVIDER;\n            this.emit(constants_1.EVENT.RECORD_HAS_PROVIDER_CHANGED, this.hasProvider);\n            return;\n        }\n    }\n    handleReadResponse(message) {\n        if (this.stateMachine.state === "MERGING" /* MERGING */) {\n            this.recoverRecord(message.version, message.parsedData, message);\n            this.recordServices.dirtyService.setDirty(this.name, false);\n            return;\n        }\n        this.version = message.version;\n        this.applyChange(json_path_1.setValue(this.data, null, message.parsedData));\n        this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.READ_RESPONSE);\n    }\n    handleHeadResponse(message) {\n        const remoteVersion = message.version;\n        if (this.recordServices.dirtyService.isDirty(this.name)) {\n            if (remoteVersion === -1 && this.version === 1) {\n                /**\n                 * Record created while offline\n                 */\n                this.stateMachine.transition("SUBSCRIBED" /* SUBSCRIBED */);\n                this.sendCreateUpdate(this.data);\n            }\n            else if (this.version === remoteVersion + 1) {\n                /**\n                 * record updated by client while offline\n                */\n                this.sendUpdate(null, this.data);\n                this.stateMachine.transition("RESUBSCRIBED" /* RESUBSCRIBED */);\n            }\n            else {\n                /**\n                 * record updated by server when offline, get latest data\n                 */\n                this.stateMachine.transition("INVALID_VERSION" /* INVALID_VERSION */);\n                this.sendRead();\n                this.recordServices.readRegistry.register(this.name, this, this.handleReadResponse);\n            }\n        }\n        else {\n            if (remoteVersion < this.version) {\n                /**\n                 *  deleted and created again remotely\n                */\n            }\n            else if (this.version === remoteVersion) {\n                this.stateMachine.transition("RESUBSCRIBED" /* RESUBSCRIBED */);\n            }\n            else {\n                this.stateMachine.transition("INVALID_VERSION" /* INVALID_VERSION */);\n                this.sendRead();\n                this.recordServices.readRegistry.register(this.name, this, this.handleReadResponse);\n            }\n        }\n    }\n    sendRead() {\n        this.services.connection.sendMessage({\n            topic: message_constants_1.TOPIC.RECORD,\n            action: message_constants_1.RECORD_ACTIONS.READ,\n            name: this.name\n        });\n    }\n    saveUpdate() {\n        if (!this.recordServices.dirtyService.isDirty(this.name)) {\n            this.version++;\n            this.recordServices.dirtyService.setDirty(this.name, true);\n        }\n        this.saveRecordToOffline();\n    }\n    sendUpdate(path = null, data, callback) {\n        if (this.recordServices.dirtyService.isDirty(this.name)) {\n            this.recordServices.dirtyService.setDirty(this.name, false);\n        }\n        else {\n            this.version++;\n        }\n        const message = {\n            topic: message_constants_1.TOPIC.RECORD,\n            version: this.version,\n            name: this.name\n        };\n        if (path) {\n            if (data === undefined) {\n                Object.assign(message, { action: message_constants_1.RECORD_ACTIONS.ERASE, path });\n            }\n            else {\n                Object.assign(message, { action: message_constants_1.RECORD_ACTIONS.PATCH, path, parsedData: data });\n            }\n        }\n        else {\n            Object.assign(message, { action: message_constants_1.RECORD_ACTIONS.UPDATE, parsedData: data });\n        }\n        if (callback) {\n            this.recordServices.writeAckService.send(message, callback);\n        }\n        else {\n            this.services.connection.sendMessage(message);\n        }\n    }\n    sendCreateUpdate(data) {\n        this.services.connection.sendMessage({\n            name: this.name,\n            topic: message_constants_1.TOPIC.RECORD,\n            action: message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE,\n            version: 1,\n            parsedData: data\n        });\n        this.recordServices.dirtyService.setDirty(this.name, false);\n    }\n    /**\n     * Applies incoming updates and patches to the record\'s dataset\n     */\n    applyUpdate(message) {\n        const version = message.version;\n        const data = message.parsedData;\n        if (this.version === null) {\n            this.version = version;\n        }\n        else if (this.version + 1 !== version) {\n            this.stateMachine.transition("INVALID_VERSION" /* INVALID_VERSION */);\n            if (message.action === message_constants_1.RECORD_ACTIONS.PATCH) {\n                /**\n                * Request a snapshot so that a merge can be done with the read reply which contains\n                * the full state of the record\n                **/\n                this.sendRead();\n            }\n            else {\n                // @ts-ignore\n                this.recoverRecord(message.version, data, message);\n            }\n            return;\n        }\n        this.version = version;\n        let newData;\n        if (message.action === message_constants_1.RECORD_ACTIONS.PATCH) {\n            newData = json_path_1.setValue(this.data, message.path, data);\n        }\n        else if (message.action === message_constants_1.RECORD_ACTIONS.ERASE) {\n            newData = json_path_1.setValue(this.data, message.path, undefined);\n        }\n        else {\n            newData = json_path_1.setValue(this.data, null, data);\n        }\n        this.applyChange(newData);\n    }\n    /**\n     * Compares the new values for every path with the previously stored ones and\n     * updates the subscribers if the value has changed\n     */\n    applyChange(newData) {\n        if (this.stateMachine.inEndState) {\n            return;\n        }\n        const oldData = this.data;\n        this.data = newData;\n        const paths = this.emitter.eventNames();\n        for (let i = 0; i < paths.length; i++) {\n            const newValue = json_path_1.get(newData, paths[i], false);\n            const oldValue = json_path_1.get(oldData, paths[i], false);\n            if (newValue !== oldValue) {\n                this.emitter.emit(paths[i], this.get(paths[i]));\n            }\n        }\n    }\n    /**\n     * If connected sends the delete message to server, otherwise\n     * we delete in local storage and transition to delete success.\n     */\n    sendDelete() {\n        this.whenReadyInternal(null, () => {\n            if (this.services.connection.isConnected) {\n                const message = {\n                    topic: message_constants_1.TOPIC.RECORD,\n                    action: message_constants_1.RECORD_ACTIONS.DELETE,\n                    name: this.name\n                };\n                this.deletedTimeout = this.services.timeoutRegistry.add({\n                    message,\n                    event: constants_1.EVENT.RECORD_DELETE_TIMEOUT,\n                    duration: this.options.recordDeleteTimeout\n                });\n                this.services.connection.sendMessage(message);\n            }\n            else {\n                this.services.storage.delete(this.name, () => {\n                    this.services.timerRegistry.requestIdleCallback(() => {\n                        this.stateMachine.transition(message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS);\n                    });\n                });\n            }\n        });\n    }\n    /**\n     * Called when a merge conflict is detected by a VERSION_EXISTS error or if an update recieved\n     * is directly after the clients. If no merge strategy is configure it will emit a VERSION_EXISTS\n     * error and the record will remain in an inconsistent state.\n     *\n     * @param   {Number} remoteVersion The remote version number\n     * @param   {Object} remoteData The remote object data\n     * @param   {Object} message parsed and validated deepstream message\n     */\n    recoverRecord(remoteVersion, remoteData, message) {\n        this.recordServices.mergeStrategy.merge(this.name, this.version, this.get(), remoteVersion, remoteData, this.onRecordRecovered, this);\n    }\n    /**\n   * Callback once the record merge has completed. If successful it will set the\n   * record state, else emit and error and the record will remain in an\n   * inconsistent state until the next update.\n   */\n    onRecordRecovered(error, recordName, mergedData, remoteVersion, remoteData) {\n        if (error) {\n            this.services.logger.error({ topic: message_constants_1.TOPIC.RECORD }, constants_1.EVENT.RECORD_VERSION_EXISTS);\n        }\n        this.version = remoteVersion;\n        const oldValue = this.data;\n        if (utils.deepEquals(oldValue, remoteData)) {\n            return;\n        }\n        const newValue = json_path_1.setValue(oldValue, null, mergedData);\n        if (utils.deepEquals(mergedData, remoteData)) {\n            this.applyChange(mergedData);\n            // const callback = this.writeCallbacks.get(remoteVersion)\n            // if (callback !== undefined) {\n            //   callback(null)\n            //   this.writeCallbacks.delete(remoteVersion)\n            // }\n        }\n        else {\n            this.applyChange(newValue);\n            // this.sendUpdate(null, data, message.isWriteAck)\n        }\n        this.stateMachine.transition("MERGED" /* MERGED */);\n    }\n    /**\n   * A quick check that\'s carried out by most methods that interact with the record\n   * to make sure it hasn\'t been destroyed yet - and to handle it gracefully if it has.\n   */\n    checkDestroyed(methodName) {\n        if (this.stateMachine.inEndState) {\n            this.services.logger.error({ topic: message_constants_1.TOPIC.RECORD }, constants_1.EVENT.RECORD_ALREADY_DESTROYED, { methodName });\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Destroys the record and nulls all\n     * its dependencies\n     */\n    destroy() {\n        this.services.timerRegistry.remove(this.readyTimer);\n        this.services.timeoutRegistry.clear(this.responseTimeout);\n        this.services.timeoutRegistry.clear(this.deletedTimeout);\n        this.services.timeoutRegistry.clear(this.discardTimeout);\n        this.services.connection.removeOnReestablished(this.onConnectionReestablished);\n        this.services.connection.removeOnLost(this.onConnectionLost);\n        this.emitter.off();\n        this.isReady = false;\n        this.whenComplete(this.name);\n    }\n    onConnectionReestablished() {\n        this.stateMachine.transition("RESUBSCRIBE" /* RESUBSCRIBE */);\n    }\n    onConnectionLost() {\n        this.saveRecordToOffline();\n    }\n}\nexports.RecordCore = RecordCore;\nconst recordStateTransitions = [\n    { name: message_constants_1.RECORD_ACTIONS.SUBSCRIBE, from: "INITIAL" /* INITIAL */, to: "SUBSCRIBING" /* SUBSCRIBING */, handler: RecordCore.prototype.onSubscribing },\n    { name: "LOAD" /* LOAD */, from: "INITIAL" /* INITIAL */, to: "LOADING_OFFLINE" /* LOADING_OFFLINE */, handler: RecordCore.prototype.onOfflineLoading },\n    { name: "LOADED" /* LOADED */, from: "LOADING_OFFLINE" /* LOADING_OFFLINE */, to: "READY" /* READY */, handler: RecordCore.prototype.onReady },\n    { name: "RESUBSCRIBE" /* RESUBSCRIBE */, from: "LOADING_OFFLINE" /* LOADING_OFFLINE */, to: "RESUBSCRIBING" /* RESUBSCRIBING */, handler: RecordCore.prototype.abortOfflineLoading },\n    { name: message_constants_1.RECORD_ACTIONS.READ_RESPONSE, from: "SUBSCRIBING" /* SUBSCRIBING */, to: "READY" /* READY */, handler: RecordCore.prototype.onReady },\n    { name: "SUBSCRIBED" /* SUBSCRIBED */, from: "RESUBSCRIBING" /* RESUBSCRIBING */, to: "READY" /* READY */ },\n    { name: "RESUBSCRIBE" /* RESUBSCRIBE */, from: "INITIAL" /* INITIAL */, to: "RESUBSCRIBING" /* RESUBSCRIBING */, handler: RecordCore.prototype.onResubscribing },\n    { name: "RESUBSCRIBE" /* RESUBSCRIBE */, from: "READY" /* READY */, to: "RESUBSCRIBING" /* RESUBSCRIBING */, handler: RecordCore.prototype.onResubscribing },\n    { name: "RESUBSCRIBE" /* RESUBSCRIBE */, from: "UNSUBSCRIBING" /* UNSUBSCRIBING */, to: "RESUBSCRIBING" /* RESUBSCRIBING */, handler: RecordCore.prototype.onResubscribing },\n    { name: "RESUBSCRIBED" /* RESUBSCRIBED */, from: "RESUBSCRIBING" /* RESUBSCRIBING */, to: "READY" /* READY */ },\n    { name: "INVALID_VERSION" /* INVALID_VERSION */, from: "RESUBSCRIBING" /* RESUBSCRIBING */, to: "MERGING" /* MERGING */ },\n    { name: "MERGED" /* MERGED */, from: "MERGING" /* MERGING */, to: "READY" /* READY */ },\n    { name: message_constants_1.RECORD_ACTIONS.DELETE, from: "READY" /* READY */, to: "DELETING" /* DELETING */ },\n    { name: message_constants_1.RECORD_ACTIONS.DELETED, from: "READY" /* READY */, to: "DELETED" /* DELETED */, handler: RecordCore.prototype.onDeleted },\n    { name: message_constants_1.RECORD_ACTIONS.DELETE_SUCCESS, from: "DELETING" /* DELETING */, to: "DELETED" /* DELETED */, handler: RecordCore.prototype.onDeleted },\n    { name: message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE, from: "READY" /* READY */, to: "UNSUBSCRIBING" /* UNSUBSCRIBING */ },\n    { name: message_constants_1.RECORD_ACTIONS.SUBSCRIBE, from: "UNSUBSCRIBING" /* UNSUBSCRIBING */, to: "READY" /* READY */ },\n    { name: message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE_ACK, from: "UNSUBSCRIBING" /* UNSUBSCRIBING */, to: "UNSUBSCRIBED" /* UNSUBSCRIBED */, handler: RecordCore.prototype.onUnsubscribed },\n    { name: "INVALID_VERSION" /* INVALID_VERSION */, from: "READY" /* READY */, to: "MERGING" /* MERGING */ },\n];\n\n\n//# sourceURL=webpack://deepstream/./src/record/record-core.ts?')},"./src/record/record-handler.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils = __webpack_require__(/*! ../util/utils */ \"./src/util/utils.ts\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst utils_1 = __webpack_require__(/*! ../../binary-protocol/src/utils */ \"./binary-protocol/src/utils.ts\");\nconst record_core_1 = __webpack_require__(/*! ./record-core */ \"./src/record/record-core.ts\");\nconst record_1 = __webpack_require__(/*! ./record */ \"./src/record/record.ts\");\nconst anonymous_record_1 = __webpack_require__(/*! ./anonymous-record */ \"./src/record/anonymous-record.ts\");\nconst list_1 = __webpack_require__(/*! ./list */ \"./src/record/list.ts\");\nconst listener_1 = __webpack_require__(/*! ../util/listener */ \"./src/util/listener.ts\");\nconst single_notifier_1 = __webpack_require__(/*! ./single-notifier */ \"./src/record/single-notifier.ts\");\nconst write_ack_service_1 = __webpack_require__(/*! ./write-ack-service */ \"./src/record/write-ack-service.ts\");\nconst dirty_service_1 = __webpack_require__(/*! ./dirty-service */ \"./src/record/dirty-service.ts\");\nconst merge_strategy_service_1 = __webpack_require__(/*! ./merge-strategy-service */ \"./src/record/merge-strategy-service.ts\");\nconst bulk_subscription_service_1 = __webpack_require__(/*! ../util/bulk-subscription-service */ \"./src/util/bulk-subscription-service.ts\");\nclass RecordHandler {\n    constructor(services, options, recordServices, listener) {\n        this.services = services;\n        this.options = options;\n        this.listener = listener || new listener_1.Listener(message_constants_1.TOPIC.RECORD, this.services);\n        this.recordCores = new Map();\n        this.recordServices = recordServices || {\n            bulkSubscriptionService: {\n                [message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD_BULK]: this.getBulkSubscriptionService(message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD_BULK, message_constants_1.RECORD_ACTIONS.SUBSCRIBECREATEANDREAD),\n                [message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD_BULK]: this.getBulkSubscriptionService(message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD_BULK, message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDHEAD),\n                [message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD_BULK]: this.getBulkSubscriptionService(message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD_BULK, message_constants_1.RECORD_ACTIONS.SUBSCRIBEANDREAD),\n            },\n            writeAckService: new write_ack_service_1.WriteAcknowledgementService(services),\n            readRegistry: new single_notifier_1.SingleNotifier(services, message_constants_1.RECORD_ACTIONS.READ, options.recordReadTimeout),\n            headRegistry: new single_notifier_1.SingleNotifier(services, message_constants_1.RECORD_ACTIONS.HEAD, options.recordReadTimeout),\n            dirtyService: new dirty_service_1.DirtyService(services.storage, options.dirtyStorageName),\n            mergeStrategy: new merge_strategy_service_1.MergeStrategyService(services, options.mergeStrategy)\n        };\n        this.dirtyService = this.recordServices.dirtyService;\n        this.sendUpdatedData = this.sendUpdatedData.bind(this);\n        this.onRecordUpdated = this.onRecordUpdated.bind(this);\n        this.onMergeCompleted = this.onMergeCompleted.bind(this);\n        this.getRecordCore = this.getRecordCore.bind(this);\n        this.removeRecord = this.removeRecord.bind(this);\n        this.services.connection.registerHandler(message_constants_1.TOPIC.RECORD, this.handle.bind(this));\n        this.services.connection.onReestablished(this.syncDirtyRecords.bind(this));\n        if (this.services.connection.isConnected) {\n            this.syncDirtyRecords();\n        }\n    }\n    setMergeStrategy(recordName, mergeStrategy) {\n        if (typeof mergeStrategy === 'function') {\n            this.recordServices.mergeStrategy.setMergeStrategyByName(recordName, mergeStrategy);\n        }\n        else {\n            throw new Error('Invalid merge strategy: Must be a Function');\n        }\n    }\n    setMergeStrategyRegExp(regexp, mergeStrategy) {\n        if (typeof mergeStrategy === 'function') {\n            this.recordServices.mergeStrategy.setMergeStrategyByPattern(regexp, mergeStrategy);\n        }\n        else {\n            throw new Error('Invalid merge strategy: Must be a Function');\n        }\n    }\n    /**\n   * Returns an existing record or creates a new one.\n   *\n   * @param   {String} name              the unique name of the record\n   */\n    getRecord(name) {\n        return new record_1.Record(this.getRecordCore(name));\n    }\n    /**\n     * Returns an existing List or creates a new one. A list is a specialised\n     * type of record that holds an array of recordNames.\n     *\n     * @param   {String} name       the unique name of the list\n     */\n    getList(name) {\n        return new list_1.List(this.getRecordCore(name));\n    }\n    /**\n     * Returns an anonymous record. A anonymous record is effectively\n     * a wrapper that mimicks the API of a record, but allows for the\n     * underlying record to be swapped without loosing subscriptions etc.\n     *\n     * This is particularly useful when selecting from a number of similarly\n     * structured records. E.g. a list of users that can be choosen from a list\n     *\n     * The only API difference to a normal record is an additional setName( name ) method.\n     */\n    getAnonymousRecord() {\n        return new anonymous_record_1.AnonymousRecord(this.getRecordCore);\n    }\n    /**\n     * Allows to listen for record subscriptions made by this or other clients. This\n     * is useful to create \"active\" data providers, e.g. providers that only provide\n     * data for a particular record if a user is actually interested in it\n     *\n     * @param   {String}   pattern  A combination of alpha numeric characters and wildcards( * )\n     * @param   {Function} callback\n     */\n    listen(pattern, callback) {\n        this.listener.listen(pattern, callback);\n    }\n    /**\n     * Removes a listener that was previously registered with listenForSubscriptions\n     *\n     * @param   {String}   pattern  A combination of alpha numeric characters and wildcards( * )\n     */\n    unlisten(pattern) {\n        this.listener.unlisten(pattern);\n    }\n    snapshot(name, callback) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument: name');\n        }\n        if (callback !== undefined && typeof callback !== 'function') {\n            throw new Error('invalid argument: callback');\n        }\n        const recordCore = this.recordCores.get(name);\n        if (recordCore) {\n            if (callback) {\n                recordCore.whenReady(null, () => {\n                    callback(null, recordCore.get());\n                });\n            }\n            else {\n                return new Promise((resolve, reject) => {\n                    recordCore.whenReady(null, () => {\n                        resolve(recordCore.get());\n                    });\n                });\n            }\n            return;\n        }\n        if (callback) {\n            this.recordServices.readRegistry.request(name, callback);\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                this.recordServices.readRegistry.request(name, (error, data) => error ? reject(error) : resolve(data));\n            });\n        }\n    }\n    has(name, callback) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument: name');\n        }\n        if (callback !== undefined && typeof callback !== 'function') {\n            throw new Error('invalid argument: callback');\n        }\n        let cb;\n        if (!callback) {\n            return new Promise((resolve, reject) => {\n                cb = (error, version) => error ? reject(error) : resolve(version !== -1);\n                this.head(name, cb);\n            });\n        }\n        cb = (error, version) => error ? callback(error, null) : callback(null, version !== -1);\n        this.head(name, cb);\n    }\n    head(name, callback) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument: name');\n        }\n        if (callback !== undefined && typeof callback !== 'function') {\n            throw new Error('invalid argument: callback');\n        }\n        const recordCore = this.recordCores.get(name);\n        if (recordCore) {\n            if (callback) {\n                recordCore.whenReady(null, () => {\n                    callback(null, recordCore.version);\n                });\n            }\n            else {\n                return new Promise((resolve, reject) => {\n                    recordCore.whenReady(null, () => {\n                        resolve(recordCore.version);\n                    });\n                });\n            }\n            return;\n        }\n        if (callback) {\n            this.recordServices.headRegistry.request(name, callback);\n        }\n        else {\n            return new Promise((resolve, reject) => {\n                this.recordServices.headRegistry.request(name, (error, data) => error ? reject(error) : resolve(data));\n            });\n        }\n    }\n    setDataWithAck(recordName, ...rest) {\n        const args = utils.normalizeSetArguments(arguments, 1);\n        if (!args.callback) {\n            return new Promise((resolve, reject) => {\n                args.callback = error => error === null ? resolve() : reject(error);\n                this.sendSetData(recordName, -1, args);\n            });\n        }\n        this.sendSetData(recordName, -1, args);\n    }\n    setData(recordName) {\n        const args = utils.normalizeSetArguments(arguments, 1);\n        this.sendSetData(recordName, -1, args);\n    }\n    sendSetData(recordName, version, args) {\n        const { path, data, callback } = args;\n        if (!recordName || typeof recordName !== 'string' || recordName.length === 0) {\n            throw new Error('invalid argument: recordName must be an non empty string');\n        }\n        if (!path && (data === null || typeof data !== 'object')) {\n            throw new Error('invalid argument: data must be an object when no path is provided');\n        }\n        const recordCores = this.recordCores.get(recordName);\n        if (recordCores) {\n            recordCores.set({ path, data, callback });\n            return;\n        }\n        let action;\n        if (path) {\n            if (data === undefined) {\n                action = message_constants_1.RECORD_ACTIONS.ERASE;\n            }\n            else {\n                action = message_constants_1.RECORD_ACTIONS.CREATEANDPATCH;\n            }\n        }\n        else {\n            action = message_constants_1.RECORD_ACTIONS.CREATEANDUPDATE;\n        }\n        const message = {\n            topic: message_constants_1.TOPIC.RECORD,\n            action,\n            name: recordName,\n            path,\n            version,\n            parsedData: data\n        };\n        if (callback) {\n            this.recordServices.writeAckService.send(message, callback);\n        }\n        else {\n            this.services.connection.sendMessage(message);\n        }\n    }\n    /**\n     * Will be called by the client for incoming messages on the RECORD topic\n     *\n     * @param   {Object} message parsed and validated deepstream message\n     */\n    handle(message) {\n        if (message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_FOR_PATTERN_FOUND ||\n            message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_FOR_PATTERN_REMOVED ||\n            message.action === message_constants_1.RECORD_ACTIONS.LISTEN ||\n            message.action === message_constants_1.RECORD_ACTIONS.UNLISTEN) {\n            this.listener.handle(message);\n            return;\n        }\n        if (utils_1.isWriteAck(message.action) || utils_1.isWriteAck(message.originalAction)) {\n            this.recordServices.writeAckService.recieve(message);\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.READ_RESPONSE || message.originalAction === message_constants_1.RECORD_ACTIONS.READ) {\n            if (message.isError) {\n                this.recordServices.readRegistry.recieve(message, message_constants_1.RECORD_ACTIONS[message.action]);\n            }\n            else {\n                this.recordServices.readRegistry.recieve(message, null, message.parsedData);\n            }\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.HEAD_RESPONSE ||\n            message.originalAction === message_constants_1.RECORD_ACTIONS.HEAD) {\n            if (message.isError) {\n                this.recordServices.headRegistry.recieve(message, message_constants_1.RECORD_ACTIONS[message.action]);\n            }\n            else {\n                this.recordServices.headRegistry.recieve(message, null, message.version);\n            }\n        }\n        const recordCore = this.recordCores.get(message.name);\n        if (recordCore) {\n            recordCore.handle(message);\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.VERSION_EXISTS) {\n            return;\n        }\n        if (message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_PROVIDER ||\n            message.action === message_constants_1.RECORD_ACTIONS.SUBSCRIPTION_HAS_NO_PROVIDER) {\n            // record can receive a HAS_PROVIDER after discarding the record\n            return;\n        }\n        if (message.isError) {\n            this.services.logger.error(message);\n            return;\n        }\n        this.services.logger.error(message, constants_1.EVENT.UNSOLICITED_MESSAGE);\n    }\n    /**\n     * Callback for 'deleted' and 'discard' events from a record. Removes the record from\n     * the registry\n     */\n    removeRecord(recordName) {\n        this.recordCores.delete(recordName);\n    }\n    getRecordCore(recordName) {\n        let recordCore = this.recordCores.get(recordName);\n        if (!recordCore) {\n            recordCore = new record_core_1.RecordCore(recordName, this.services, this.options, this.recordServices, this.removeRecord);\n            this.recordCores.set(recordName, recordCore);\n        }\n        else {\n            recordCore.usages++;\n        }\n        return recordCore;\n    }\n    syncDirtyRecords() {\n        this.dirtyService.whenLoaded(this, this._syncDirtyRecords);\n    }\n    _syncDirtyRecords() {\n        const dirtyRecords = this.dirtyService.getAll();\n        for (const recordName in dirtyRecords) {\n            const recordCore = this.recordCores.get(recordName);\n            if (recordCore && recordCore.usages > 0) {\n                // if it isn't zero.. problem.\n                continue;\n            }\n            this.services.storage.get(recordName, this.sendUpdatedData);\n        }\n    }\n    sendUpdatedData(recordName, version, data) {\n        this.sendSetData(recordName, version, { data, callback: this.onRecordUpdated });\n    }\n    onRecordUpdated(error, recordName) {\n        if (!error) {\n            this.dirtyService.setDirty(recordName, false);\n        }\n    }\n    /**\n    * Callback once the record merge has completed. If successful it will set the\n    * record state, else emit and error and the record will remain in an\n    * inconsistent state until the next update.\n    */\n    // private onMergeConflict (message: RecordWriteMessage): void {\n    //   this.services.storage.get(message.name, (recordName: string, version: number, data: RecordData) => {\n    //     this.recordServices.mergeStrategy.merge(\n    //       message.name,\n    //       version,\n    //       data,\n    //       message.version,\n    //       message.parsedData,\n    //       this.onMergeCompleted\n    //     )\n    //   })\n    // }\n    onMergeCompleted(error, recordName, mergeData, remoteVersion, remoteData) {\n        this.sendSetData(recordName, remoteVersion + 1, { data: mergeData });\n    }\n    getBulkSubscriptionService(bulkSubscribe, subscribe) {\n        return new bulk_subscription_service_1.BulkSubscriptionService(this.services, this.options.subscriptionInterval, message_constants_1.TOPIC.RECORD, bulkSubscribe, subscribe, message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE_BULK, message_constants_1.RECORD_ACTIONS.UNSUBSCRIBE);\n    }\n}\nexports.RecordHandler = RecordHandler;\n\n\n//# sourceURL=webpack://deepstream/./src/record/record-handler.ts?")},"./src/record/record.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst utils = __webpack_require__(/*! ../util/utils */ "./src/util/utils.ts");\nconst constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\nconst Emitter = __webpack_require__(/*! component-emitter2 */ "./node_modules/component-emitter2/index.js");\nclass Record extends Emitter {\n    constructor(record) {\n        super();\n        this.record = record;\n        this.subscriptions = [];\n        this.record.on(constants_1.EVENT.RECORD_READY, this.emit.bind(this, constants_1.EVENT.RECORD_READY, this));\n        this.record.on(constants_1.EVENT.RECORD_DISCARDED, this.emit.bind(this, constants_1.EVENT.RECORD_DISCARDED));\n        this.record.on(constants_1.EVENT.RECORD_DELETED, this.emit.bind(this, constants_1.EVENT.RECORD_DELETED));\n        this.record.on(constants_1.EVENT.RECORD_ERROR, this.emit.bind(this, constants_1.EVENT.RECORD_ERROR));\n    }\n    get name() {\n        return this.record.name;\n    }\n    get isReady() {\n        return this.record.isReady;\n    }\n    get version() {\n        return this.record.version;\n    }\n    get hasProvider() {\n        return this.record.hasProvider;\n    }\n    whenReady(callback) {\n        if (callback) {\n            this.record.whenReady(this, callback);\n        }\n        else {\n            return this.record.whenReady(this);\n        }\n    }\n    get(path) {\n        return this.record.get(path);\n    }\n    set(dataOrPath, dataOrCallback, callback) {\n        return this.record.set(utils.normalizeSetArguments(arguments));\n    }\n    setWithAck(pathOrData, dataOrCallback, callback) {\n        return this.record.setWithAck(utils.normalizeSetArguments(arguments));\n    }\n    /**\n     * Deletes a path from the record. Equivalent to doing `record.set(path, undefined)`\n     *\n     * @param {String} path The path to be deleted\n     */\n    erase(path) {\n        if (!path) {\n            throw new Error(\'unable to erase record data without path, consider using `delete`\');\n        }\n        this.set(path, undefined);\n    }\n    eraseWithAck(path, callback) {\n        if (!path) {\n            throw new Error(\'unable to erase record data without path, consider using `delete`\');\n        }\n        if (callback) {\n            this.setWithAck(path, undefined, callback);\n        }\n        else {\n            return this.setWithAck(path, undefined);\n        }\n    }\n    subscribe(path, callback, triggerNow) {\n        const parameters = utils.normalizeArguments(arguments);\n        this.subscriptions.push(parameters);\n        this.record.subscribe(parameters);\n    }\n    unsubscribe(path, callback) {\n        const parameters = utils.normalizeArguments(arguments);\n        this.subscriptions = this.subscriptions.filter(subscription => {\n            return (subscription.path !== parameters.path ||\n                subscription.callback !== parameters.callback);\n        });\n        this.record.unsubscribe(parameters);\n    }\n    discard() {\n        for (let i = 0; i < this.subscriptions.length; i++) {\n            this.record.unsubscribe(this.subscriptions[i]);\n        }\n        return this.record.discard();\n    }\n    delete(callback) {\n        return this.record.delete(callback);\n    }\n    setMergeStrategy(mergeStrategy) {\n        this.record.setMergeStrategy(mergeStrategy);\n    }\n}\nexports.Record = Record;\n\n\n//# sourceURL=webpack://deepstream/./src/record/record.ts?')},"./src/record/single-notifier.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nconst constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\n/**\n * Provides a scaffold for subscriptionless requests to deepstream, such as the SNAPSHOT\n * and HAS functionality. The SingleNotifier multiplexes all the client requests so\n * that they can can be notified at once, and also includes reconnection funcionality\n * incase the connection drops.\n *\n * @param {Services} services          The deepstream client\n * @param {Options} options     Function to call to allow resubscribing\n *\n * @constructor\n */\nclass SingleNotifier {\n    constructor(services, action, timeoutDuration) {\n        this.services = services;\n        this.action = action;\n        this.requests = new Map();\n        this.internalRequests = new Map();\n        this.limboQueue = [];\n        this.services.connection.onLost(this.onConnectionLost.bind(this));\n        this.services.connection.onExitLimbo(this.onExitLimbo.bind(this));\n        this.services.connection.onReestablished(this.onConnectionReestablished.bind(this));\n    }\n    /**\n     * Add a request. If one has already been made it will skip the server request\n     * and multiplex the response\n     *\n     * @param {String} name An identifier for the request, e.g. a record name\n     * @param {Object} response An object with property `callback` or `resolve` and `reject`\n     *\n     * @public\n     * @returns {void}\n     */\n    request(name, callback) {\n        const req = this.requests.get(name);\n        if (req) {\n            req.push(callback);\n            return;\n        }\n        this.requests.set(name, [callback]);\n        const message = {\n            topic: message_constants_1.TOPIC.RECORD,\n            action: this.action,\n            name\n        };\n        if (this.services.connection.isConnected) {\n            this.services.connection.sendMessage(message);\n            this.services.timeoutRegistry.add({ message });\n        }\n        else if (this.services.connection.isInLimbo) {\n            this.limboQueue.push(message);\n        }\n        else {\n            callback(constants_1.EVENT.CLIENT_OFFLINE);\n        }\n    }\n    /**\n     * Adds a callback to a (possibly) inflight request that will be called\n     * on the response.\n     */\n    register(name, context, callback) {\n        const request = this.internalRequests.get(name);\n        if (!request) {\n            this.internalRequests.set(name, [{ callback, context }]);\n        }\n        else {\n            request.push({ callback, context });\n        }\n    }\n    recieve(message, error, data) {\n        this.services.timeoutRegistry.remove(message);\n        const name = message.name;\n        const responses = this.requests.get(name) || [];\n        const internalResponses = this.internalRequests.get(name) || [];\n        if (!responses && !internalResponses) {\n            return;\n        }\n        for (let i = 0; i < internalResponses.length; i++) {\n            internalResponses[i].callback.call(internalResponses[i].context, message);\n        }\n        this.internalRequests.delete(name);\n        // todo we can clean this up and do cb = (error, data) => error ? reject(error) : resolve()\n        for (let i = 0; i < responses.length; i++) {\n            responses[i](error, data);\n        }\n        this.requests.delete(name);\n        return;\n    }\n    onConnectionLost() {\n        this.requests.forEach(responses => {\n            responses.forEach(response => response(constants_1.EVENT.CLIENT_OFFLINE));\n        });\n        this.requests.clear();\n    }\n    onExitLimbo() {\n        for (let i = 0; i < this.limboQueue.length; i++) {\n            const message = this.limboQueue[i];\n            const requests = this.requests.get(message.name);\n            if (requests) {\n                requests.forEach(cb => cb(constants_1.EVENT.CLIENT_OFFLINE));\n            }\n        }\n        this.requests.clear();\n        this.limboQueue = [];\n    }\n    onConnectionReestablished() {\n        for (let i = 0; i < this.limboQueue.length; i++) {\n            const message = this.limboQueue[i];\n            this.services.connection.sendMessage(message);\n            this.services.timeoutRegistry.add({ message });\n        }\n    }\n}\nexports.SingleNotifier = SingleNotifier;\n\n\n//# sourceURL=webpack://deepstream/./src/record/single-notifier.ts?')},"./src/record/storage-service.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Storage {\n    constructor(options) {\n        if (typeof localStorage === 'undefined' || localStorage === null) {\n            const LocalStorage = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'node-localstorage'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())).LocalStorage;\n            this.storage = new LocalStorage(options.nodeStoragePath, options.nodeStorageSize * 1024 * 1024);\n        }\n        else {\n            this.storage = window.localStorage;\n        }\n    }\n    get(recordName, callback) {\n        const item = this.storage.getItem(recordName);\n        if (item) {\n            const doc = JSON.parse(item);\n            setTimeout(callback.bind(this, recordName, doc.version, doc.data), 0);\n            return;\n        }\n        setTimeout(callback.bind(this, recordName, -1, null), 0);\n    }\n    set(recordName, version, data, callback) {\n        this.storage.setItem(recordName, JSON.stringify({ recordName, version, data }));\n        setTimeout(callback, 0);\n    }\n    delete(recordName, callback) {\n        this.storage.removeItem(recordName);\n        setTimeout(callback, 0);\n    }\n}\nexports.Storage = Storage;\n\n\n//# sourceURL=webpack://deepstream/./src/record/storage-service.ts?")},"./src/record/write-ack-service.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\nconst utils_1 = __webpack_require__(/*! ../../binary-protocol/src/utils */ "./binary-protocol/src/utils.ts");\nconst constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\nclass WriteAcknowledgementService {\n    constructor(services) {\n        this.services = services;\n        this.responses = new Map();\n        this.count = 1;\n        this.services.connection.onLost(this.onConnectionLost.bind(this));\n    }\n    /**\n     * Send message with write ack callback.\n     */\n    send(message, callback) {\n        if (this.services.connection.isConnected === false) {\n            this.services.timerRegistry.requestIdleCallback(callback.bind(this, constants_1.EVENT.CLIENT_OFFLINE));\n            return;\n        }\n        const correlationId = this.count.toString();\n        this.responses.set(correlationId, callback);\n        this.services.connection.sendMessage(Object.assign({}, message, { correlationId, action: utils_1.ACTION_TO_WRITE_ACK[message.action] }));\n        this.count++;\n    }\n    recieve(message) {\n        const id = message.correlationId;\n        const response = this.responses.get(id);\n        if (!response ||\n            (message.action !== message_constants_1.RECORD_ACTIONS.WRITE_ACKNOWLEDGEMENT && !message.isError)) {\n            return;\n        }\n        message.isError\n            ? response(message_constants_1.RECORD_ACTIONS[message.action])\n            : response(null);\n        this.responses.delete(id);\n    }\n    onConnectionLost() {\n        this.responses.forEach(response => response(constants_1.EVENT.CLIENT_OFFLINE));\n        this.responses.clear();\n    }\n}\nexports.WriteAcknowledgementService = WriteAcknowledgementService;\n\n\n//# sourceURL=webpack://deepstream/./src/record/write-ack-service.ts?')},"./src/rpc/rpc-handler.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst rpc_1 = __webpack_require__(/*! ../rpc/rpc */ \"./src/rpc/rpc.ts\");\nconst rpc_response_1 = __webpack_require__(/*! ../rpc/rpc-response */ \"./src/rpc/rpc-response.ts\");\nconst utils_1 = __webpack_require__(/*! ../util/utils */ \"./src/util/utils.ts\");\nclass RPCHandler {\n    constructor(services, options) {\n        this.services = services;\n        this.options = options;\n        this.rpcs = new Map();\n        this.providers = new Map();\n        this.limboQueue = [];\n        this.services.connection.registerHandler(message_constants_1.TOPIC.RPC, this.handle.bind(this));\n        this.services.connection.onReestablished(this.onConnectionReestablished.bind(this));\n        this.services.connection.onExitLimbo(this.onExitLimbo.bind(this));\n        this.services.connection.onLost(this.onConnectionLost.bind(this));\n    }\n    /**\n     * Registers a callback function as a RPC provider. If another connected client calls\n     * client.rpc.make() the request will be routed to this method\n     *\n     * The callback will be invoked with two arguments:\n     *     {Mixed} data The data passed to the client.rpc.make function\n     *     {RpcResponse} rpcResponse An object with methods to response,\n     *                               acknowledge or reject the request\n     *\n     * Only one callback can be registered for a RPC at a time\n     *\n     * Please note: Deepstream tries to deliver data in its original format.\n     * Data passed to client.rpc.make as a String will arrive as a String,\n     * numbers or implicitly JSON serialized objects will arrive in their\n     * respective format as well\n     */\n    provide(name, callback) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        if (this.providers.has(name)) {\n            throw new Error(`RPC ${name} already registered`);\n        }\n        if (typeof callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        this.providers.set(name, callback);\n        if (this.services.connection.isConnected) {\n            this.sendProvide(name);\n        }\n    }\n    /**\n     * Unregisters this client as a provider for a remote procedure call\n     */\n    unprovide(name) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        if (!this.providers.has(name)) {\n            this.services.logger.warn({\n                topic: message_constants_1.TOPIC.RPC,\n                action: message_constants_1.RPC_ACTIONS.NOT_PROVIDED,\n                name\n            });\n            return;\n        }\n        this.providers.delete(name);\n        if (this.services.connection.isConnected) {\n            const message = { topic: message_constants_1.TOPIC.RPC, action: message_constants_1.RPC_ACTIONS.UNPROVIDE, name };\n            this.services.timeoutRegistry.add({ message });\n            this.services.connection.sendMessage(message);\n            return;\n        }\n    }\n    make(name, data, callback) {\n        if (typeof name !== 'string' || name.length === 0) {\n            throw new Error('invalid argument name');\n        }\n        if (callback && typeof callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        const correlationId = utils_1.getUid();\n        if (this.services.connection.isConnected) {\n            if (callback) {\n                this.rpcs.set(correlationId, new rpc_1.RPC(name, correlationId, data, callback, this.options, this.services));\n                return;\n            }\n            return new Promise((resolve, reject) => {\n                this.rpcs.set(correlationId, new rpc_1.RPC(name, correlationId, data, (error, result) => error ? reject(error) : resolve(result), this.options, this.services));\n            });\n        }\n        else if (this.services.connection.isInLimbo) {\n            if (callback) {\n                this.limboQueue.push({ correlationId, name, data, callback });\n            }\n            else {\n                return new Promise((resolve, reject) => {\n                    this.limboQueue.push({ correlationId, name, data, callback: (error, result) => error ? reject(error) : resolve(result) });\n                });\n            }\n        }\n        else {\n            if (callback) {\n                callback(constants_1.EVENT.CLIENT_OFFLINE);\n            }\n            else {\n                return Promise.reject(constants_1.EVENT.CLIENT_OFFLINE);\n            }\n        }\n    }\n    /**\n     * Handles incoming rpc REQUEST messages. Instantiates a new response object\n     * and invokes the provider callback or rejects the request if no rpc provider\n     * is present (which shouldn't really happen, but might be the result of a race condition\n     * if this client sends a unprovide message whilst an incoming request is already in flight)\n     */\n    respondToRpc(message) {\n        const provider = this.providers.get(message.name);\n        if (provider) {\n            provider(message.parsedData, new rpc_response_1.RPCResponse(message, this.options, this.services));\n        }\n        else {\n            this.services.connection.sendMessage({\n                topic: message_constants_1.TOPIC.RPC,\n                action: message_constants_1.RPC_ACTIONS.REJECT,\n                name: message.name,\n                correlationId: message.correlationId\n            });\n        }\n    }\n    /**\n     * Distributes incoming messages from the server\n     * based on their action\n     */\n    handle(message) {\n        // RPC Requests\n        if (message.action === message_constants_1.RPC_ACTIONS.REQUEST) {\n            this.respondToRpc(message);\n            return;\n        }\n        // RPC subscription Acks\n        if (message.isAck) {\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        // handle auth/denied subscription errors\n        if (message.action === message_constants_1.RPC_ACTIONS.MESSAGE_PERMISSION_ERROR || message.action === message_constants_1.RPC_ACTIONS.MESSAGE_DENIED) {\n            if (message.originalAction === message_constants_1.RPC_ACTIONS.PROVIDE || message.originalAction === message_constants_1.RPC_ACTIONS.UNPROVIDE) {\n                this.services.timeoutRegistry.remove(message);\n                this.providers.delete(message.name);\n                this.services.logger.error(message);\n                return;\n            }\n            if (message.originalAction === message_constants_1.RPC_ACTIONS.REQUEST) {\n                const invalidRPC = this.getRPC(message);\n                if (invalidRPC) {\n                    invalidRPC.error(message_constants_1.RPC_ACTIONS[message.action]);\n                    this.rpcs.delete(message.correlationId);\n                    return;\n                }\n            }\n        }\n        // RPC Responses\n        const rpc = this.getRPC(message);\n        if (rpc) {\n            if (message.action === message_constants_1.RPC_ACTIONS.ACCEPT) {\n                rpc.accept();\n                return;\n            }\n            if (message.action === message_constants_1.RPC_ACTIONS.RESPONSE) {\n                rpc.respond(message.parsedData);\n            }\n            else if (message.action === message_constants_1.RPC_ACTIONS.REQUEST_ERROR) {\n                rpc.error(message.parsedData);\n            }\n            else if (message.action === message_constants_1.RPC_ACTIONS.RESPONSE_TIMEOUT ||\n                message.action === message_constants_1.RPC_ACTIONS.NO_RPC_PROVIDER) {\n                rpc.error(message_constants_1.RPC_ACTIONS[message.action]);\n            }\n            this.rpcs.delete(message.correlationId);\n        }\n    }\n    getRPC(message) {\n        const rpc = this.rpcs.get(message.correlationId);\n        if (rpc === undefined) {\n            this.services.logger.error(message, constants_1.EVENT.UNKNOWN_CORRELATION_ID);\n        }\n        return rpc;\n    }\n    sendProvide(name) {\n        const message = {\n            topic: message_constants_1.TOPIC.RPC,\n            action: message_constants_1.RPC_ACTIONS.PROVIDE,\n            name\n        };\n        this.services.timeoutRegistry.add({ message });\n        this.services.connection.sendMessage(message);\n    }\n    onConnectionReestablished() {\n        for (const [name] of this.providers) {\n            this.sendProvide(name);\n        }\n        for (let i = 0; i < this.limboQueue.length; i++) {\n            const { correlationId, name, data, callback } = this.limboQueue[i];\n            this.rpcs.set(correlationId, new rpc_1.RPC(name, correlationId, data, callback, this.options, this.services));\n        }\n        this.limboQueue = [];\n    }\n    onExitLimbo() {\n        for (let i = 0; i < this.limboQueue.length; i++) {\n            this.limboQueue[i].callback(constants_1.EVENT.CLIENT_OFFLINE);\n        }\n        this.limboQueue = [];\n    }\n    onConnectionLost() {\n        this.rpcs.forEach(rpc => {\n            rpc.error(constants_1.EVENT.CLIENT_OFFLINE);\n        });\n        this.rpcs.clear();\n    }\n}\nexports.RPCHandler = RPCHandler;\n\n\n//# sourceURL=webpack://deepstream/./src/rpc/rpc-handler.ts?")},"./src/rpc/rpc-response.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\n/**\n * This class represents a single remote procedure\n * call made from the client to the server. It\'s main function\n * is to encapsulate the logic around timeouts and to convert the\n * incoming response data\n */\nclass RPCResponse {\n    constructor(message, options, services) {\n        this.name = message.name;\n        this.correlationId = message.correlationId;\n        this.services = services;\n        this.isAccepted = false;\n        this.isComplete = false;\n        this.autoAccept = true;\n        this.services.timerRegistry.requestIdleCallback(this.performAutoAck.bind(this));\n    }\n    /**\n     * Acknowledges the receipt of the request. This\n     * will happen implicitly unless the request callback\n     * explicitly sets autoAck to false\n     */\n    accept() {\n        if (this.isAccepted === false) {\n            this.services.connection.sendMessage({\n                topic: message_constants_1.TOPIC.RPC,\n                action: message_constants_1.RPC_ACTIONS.ACCEPT,\n                name: this.name,\n                correlationId: this.correlationId\n            });\n            this.isAccepted = true;\n        }\n    }\n    /**\n     * Reject the request. This might be necessary if the client\n     * is already processing a large number of requests. If deepstream\n     * receives a rejection message it will try to route the request to\n     * another provider - or return a NO_RPC_PROVIDER error if there are no\n     * providers left\n     */\n    reject() {\n        if (this.isComplete === true) {\n            throw new Error(`Rpc ${this.name} already completed`);\n        }\n        this.autoAccept = false;\n        this.isComplete = true;\n        this.isAccepted = true;\n        this.services.connection.sendMessage({\n            topic: message_constants_1.TOPIC.RPC,\n            action: message_constants_1.RPC_ACTIONS.REJECT,\n            name: this.name,\n            correlationId: this.correlationId\n        });\n    }\n    /**\n     * Notifies the server that an error has occured while trying to process the request.\n     * This will complete the rpc.\n     */\n    error(error) {\n        if (this.isComplete === true) {\n            throw new Error(`Rpc ${this.name} already completed`);\n        }\n        this.autoAccept = false;\n        this.isComplete = true;\n        this.isAccepted = true;\n        this.services.connection.sendMessage({\n            topic: message_constants_1.TOPIC.RPC,\n            action: message_constants_1.RPC_ACTIONS.REQUEST_ERROR,\n            name: this.name,\n            correlationId: this.correlationId,\n            parsedData: error\n        });\n    }\n    /**\n     * Completes the request by sending the response data\n     * to the server. If data is an array or object it will\n     * automatically be serialised.\n     * If autoAck is disabled and the response is sent before\n     * the ack message the request will still be completed and the\n     * ack message ignored\n     */\n    send(data) {\n        if (this.isComplete === true) {\n            throw new Error(`Rpc ${this.name} already completed`);\n        }\n        this.accept();\n        this.services.connection.sendMessage({\n            topic: message_constants_1.TOPIC.RPC,\n            action: message_constants_1.RPC_ACTIONS.RESPONSE,\n            name: this.name,\n            correlationId: this.correlationId,\n            parsedData: data\n        });\n        this.isComplete = true;\n    }\n    /**\n     * Callback for the autoAck timeout. Executes ack\n     * if autoAck is not disabled\n     */\n    performAutoAck() {\n        if (this.autoAccept === true) {\n            this.accept();\n        }\n    }\n}\nexports.RPCResponse = RPCResponse;\n\n\n//# sourceURL=webpack://deepstream/./src/rpc/rpc-response.ts?')},"./src/rpc/rpc.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ "./binary-protocol/src/message-constants.ts");\n/**\n * This class represents a single remote procedure\n * call made from the client to the server. It\'s main function\n * is to encapsulate the logic around timeouts and to convert the\n * incoming response data\n */\nclass RPC {\n    constructor(name, correlationId, data, response, options, services) {\n        this.name = name;\n        this.correlationId = correlationId;\n        this.response = response;\n        this.options = options;\n        this.services = services;\n        this.onTimeout = this.onTimeout.bind(this);\n        const message = {\n            topic: message_constants_1.TOPIC.RPC,\n            action: message_constants_1.RPC_ACTIONS.REQUEST,\n            correlationId,\n            name,\n            parsedData: data\n        };\n        this.acceptTimeout = this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RPC,\n                action: message_constants_1.RPC_ACTIONS.ACCEPT,\n                name: this.name,\n                correlationId: this.correlationId\n            },\n            event: message_constants_1.RPC_ACTIONS.ACCEPT_TIMEOUT,\n            duration: this.options.rpcAcceptTimeout,\n            callback: this.onTimeout\n        });\n        this.responseTimeout = this.services.timeoutRegistry.add({\n            message: {\n                topic: message_constants_1.TOPIC.RPC,\n                action: message_constants_1.RPC_ACTIONS.REQUEST,\n                name: this.name,\n                correlationId: this.correlationId\n            },\n            event: message_constants_1.RPC_ACTIONS.RESPONSE_TIMEOUT,\n            duration: this.options.rpcResponseTimeout,\n            callback: this.onTimeout\n        });\n        this.services.connection.sendMessage(message);\n    }\n    /**\n     * Called once an ack message is received from the server\n     */\n    accept() {\n        this.services.timeoutRegistry.clear(this.acceptTimeout);\n    }\n    /**\n     * Called once a response message is received from the server.\n     */\n    respond(data) {\n        this.response(null, data);\n        this.complete();\n    }\n    /**\n     * Called once an error is received from the server.\n     */\n    error(data) {\n        this.response(data);\n        this.complete();\n    }\n    /**\n     * Callback for error messages received from the server. Once\n     * an error is received the request is considered completed. Even\n     * if a response arrives later on it will be ignored / cause an\n     * UNSOLICITED_MESSAGE error\n     */\n    onTimeout(event, message) {\n        this.response(message_constants_1.RPC_ACTIONS[event]);\n        this.complete();\n    }\n    /**\n     * Called after either an error or a response\n     * was received\n    */\n    complete() {\n        this.services.timeoutRegistry.clear(this.acceptTimeout);\n        this.services.timeoutRegistry.clear(this.responseTimeout);\n    }\n}\nexports.RPC = RPC;\n\n\n//# sourceURL=webpack://deepstream/./src/rpc/rpc.ts?')},"./src/util/bulk-subscription-service.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nclass BulkSubscriptionService {\n    constructor(services, subscriptionInterval, topic, subscribeBulkAction, subscribeOriginalAction, unsubscribeBulkAction, unsubscribeOriginalAction, onSubscriptionSent = (() => { })) {\n        this.services = services;\n        this.subscriptionInterval = subscriptionInterval;\n        this.topic = topic;\n        this.subscribeBulkAction = subscribeBulkAction;\n        this.subscribeOriginalAction = subscribeOriginalAction;\n        this.unsubscribeBulkAction = unsubscribeBulkAction;\n        this.unsubscribeOriginalAction = unsubscribeOriginalAction;\n        this.onSubscriptionSent = onSubscriptionSent;\n        this.subscribeNames = new Set();\n        this.unsubscribeNames = new Set();\n        this.timerRef = -1;\n        this.correlationId = 0;\n        this.services.connection.onLost(this.onLost.bind(this));\n    }\n    subscribe(name) {\n        if (this.subscriptionInterval > 0 || !this.subscribeOriginalAction) {\n            this.unsubscribeNames.delete(name);\n            this.subscribeNames.add(name);\n            this.registerFlush();\n            return;\n        }\n        const message = {\n            topic: this.topic,\n            action: this.subscribeOriginalAction,\n            name\n        };\n        this.services.connection.sendMessage(message);\n        this.onSubscriptionSent(message);\n    }\n    subscribeList(users) {\n        users.forEach(this.subscribe.bind(this));\n    }\n    unsubscribe(name) {\n        if (this.subscriptionInterval > 0 || !this.unsubscribeOriginalAction) {\n            this.unsubscribeNames.add(name);\n            this.subscribeNames.delete(name);\n            this.registerFlush();\n            return;\n        }\n        const message = {\n            topic: this.topic,\n            action: this.unsubscribeOriginalAction,\n            name\n        };\n        this.services.connection.sendMessage(message);\n        this.onSubscriptionSent(message);\n    }\n    unsubscribeList(users) {\n        users.forEach(this.unsubscribe.bind(this));\n    }\n    registerFlush() {\n        if (!this.services.timerRegistry.has(this.timerRef)) {\n            this.timerRef = this.services.timerRegistry.add({\n                callback: this.sendMessages,\n                context: this,\n                duration: this.subscriptionInterval\n            });\n        }\n    }\n    sendMessages() {\n        if (!this.services.connection.isConnected) {\n            this.onLost();\n            return;\n        }\n        if (this.subscribeNames.size > 0) {\n            const message = {\n                topic: this.topic,\n                action: this.subscribeBulkAction,\n                names: [...this.subscribeNames],\n                correlationId: (this.correlationId++).toString()\n            };\n            this.services.connection.sendMessage(message);\n            this.onSubscriptionSent(message);\n            this.subscribeNames.clear();\n        }\n        if (this.unsubscribeNames.size > 0) {\n            const message = {\n                topic: this.topic,\n                action: this.unsubscribeBulkAction,\n                names: [...this.unsubscribeNames],\n                correlationId: (this.correlationId++).toString()\n            };\n            this.services.connection.sendMessage(message);\n            this.onSubscriptionSent(message);\n            this.unsubscribeNames.clear();\n        }\n    }\n    onLost() {\n        this.services.timerRegistry.remove(this.timerRef);\n        this.subscribeNames.clear();\n        this.unsubscribeNames.clear();\n    }\n}\nexports.BulkSubscriptionService = BulkSubscriptionService;\n\n\n//# sourceURL=webpack://deepstream/./src/util/bulk-subscription-service.ts?')},"./src/util/listener.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nconst constants_1 = __webpack_require__(/*! ../../src/constants */ \"./src/constants.ts\");\nclass Listener {\n    constructor(topic, services) {\n        this.topic = topic;\n        this.services = services;\n        this.listeners = new Map();\n        this.stopCallbacks = new Map();\n        if (topic === message_constants_1.TOPIC.RECORD) {\n            this.actions = message_constants_1.RECORD_ACTIONS;\n        }\n        else if (topic === message_constants_1.TOPIC.EVENT) {\n            this.actions = message_constants_1.EVENT_ACTIONS;\n        }\n        this.services.connection.onLost(this.onConnectionLost.bind(this));\n        this.services.connection.onReestablished(this.onConnectionReestablished.bind(this));\n    }\n    listen(pattern, callback) {\n        if (typeof pattern !== 'string' || pattern.length === 0) {\n            throw new Error('invalid argument pattern');\n        }\n        if (typeof callback !== 'function') {\n            throw new Error('invalid argument callback');\n        }\n        if (this.listeners.has(pattern)) {\n            this.services.logger.warn({\n                topic: this.topic,\n                action: constants_1.EVENT.LISTENER_EXISTS,\n                name: pattern\n            });\n            return;\n        }\n        this.listeners.set(pattern, callback);\n        this.sendListen(pattern);\n    }\n    unlisten(pattern) {\n        if (typeof pattern !== 'string' || pattern.length === 0) {\n            throw new Error('invalid argument pattern');\n        }\n        if (!this.listeners.has(pattern)) {\n            this.services.logger.warn({\n                topic: this.topic,\n                action: constants_1.EVENT.NOT_LISTENING,\n                name: pattern\n            });\n            return;\n        }\n        this.listeners.delete(pattern);\n        this.sendUnlisten(pattern);\n    }\n    /*\n   * Accepting a listener request informs deepstream that the current provider is willing to\n   * provide the record or event matching the subscriptionName . This will establish the current\n   * provider as the only publisher for the actual subscription with the deepstream cluster.\n   * Either accept or reject needs to be called by the listener\n   */\n    accept(pattern, subscription) {\n        this.services.connection.sendMessage({\n            topic: this.topic,\n            action: this.actions.LISTEN_ACCEPT,\n            name: pattern,\n            subscription\n        });\n    }\n    /*\n    * Rejecting a listener request informs deepstream that the current provider is not willing\n    * to provide the record or event matching the subscriptionName . This will result in deepstream\n    * requesting another provider to do so instead. If no other provider accepts or exists, the\n    * resource will remain unprovided.\n    * Either accept or reject needs to be called by the listener\n    */\n    reject(pattern, subscription) {\n        this.services.connection.sendMessage({\n            topic: this.topic,\n            action: this.actions.LISTEN_REJECT,\n            name: pattern,\n            subscription\n        });\n    }\n    stop(subscription, callback) {\n        this.stopCallbacks.set(subscription, callback);\n    }\n    handle(message) {\n        if (message.isAck) {\n            this.services.timeoutRegistry.remove(message);\n            return;\n        }\n        if (message.action === this.actions.SUBSCRIPTION_FOR_PATTERN_FOUND) {\n            const listener = this.listeners.get(message.name);\n            if (listener) {\n                listener(message.subscription, {\n                    accept: this.accept.bind(this, message.name, message.subscription),\n                    reject: this.reject.bind(this, message.name, message.subscription),\n                    onStop: this.stop.bind(this, message.subscription)\n                });\n            }\n            return;\n        }\n        if (message.action === this.actions.SUBSCRIPTION_FOR_PATTERN_REMOVED) {\n            const stopCallback = this.stopCallbacks.get(message.subscription);\n            if (stopCallback) {\n                stopCallback(message.subscription);\n                this.stopCallbacks.delete(message.subscription);\n            }\n            return;\n        }\n        this.services.logger.error(message, constants_1.EVENT.UNSOLICITED_MESSAGE);\n    }\n    onConnectionLost() {\n        this.stopCallbacks.forEach((callback, subscription) => {\n            callback(subscription);\n        });\n        this.stopCallbacks.clear();\n    }\n    onConnectionReestablished() {\n        this.listeners.forEach((callback, pattern) => {\n            this.sendListen(pattern);\n        });\n    }\n    /*\n    * Sends a C.ACTIONS.LISTEN to deepstream.\n    */\n    sendListen(pattern) {\n        const message = {\n            topic: this.topic,\n            action: this.actions.LISTEN,\n            name: pattern\n        };\n        this.services.timeoutRegistry.add({ message });\n        this.services.connection.sendMessage(message);\n    }\n    sendUnlisten(pattern) {\n        const message = {\n            topic: this.topic,\n            action: this.actions.UNLISTEN,\n            name: pattern\n        };\n        this.services.timeoutRegistry.add({ message });\n        this.services.connection.sendMessage(message);\n    }\n}\nexports.Listener = Listener;\n\n\n//# sourceURL=webpack://deepstream/./src/util/listener.ts?")},"./src/util/logger.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst constants_1 = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\nconst message_constants_1 = __webpack_require__(/*! ../../binary-protocol/src/message-constants */ \"./binary-protocol/src/message-constants.ts\");\nfunction isEvent(action) {\n    // @ts-ignore\n    return constants_1.EVENT[action] !== undefined;\n}\nclass Logger {\n    constructor(emitter) {\n        this.emitter = emitter;\n    }\n    warn(message, event, meta) {\n        let warnMessage = `Warning: ${message_constants_1.TOPIC[message.topic]}`;\n        const action = message.action;\n        if (action) {\n            warnMessage += ` (${message_constants_1.ACTIONS[message.topic][action]})`;\n        }\n        if (event) {\n            warnMessage += `: ${constants_1.EVENT[event]}`;\n        }\n        if (meta) {\n            warnMessage += ` – ${typeof meta === 'string' ? meta : JSON.stringify(meta)}`;\n        }\n        // tslint:disable-next-line:no-console\n        console.warn(warnMessage);\n    }\n    error(message, event, meta) {\n        if (isEvent(event)) {\n            if (event === constants_1.EVENT.IS_CLOSED) {\n                this.emitter.emit('error', meta, constants_1.EVENT[event], message_constants_1.TOPIC[message_constants_1.TOPIC.CONNECTION]);\n            }\n            else if (event === constants_1.EVENT.CONNECTION_ERROR) {\n                this.emitter.emit('error', meta, constants_1.EVENT[event], message_constants_1.TOPIC[message_constants_1.TOPIC.CONNECTION]);\n            }\n        }\n        else {\n            const action = event ? event : message.action;\n            this.emitter.emit('error', meta, message_constants_1.ACTIONS[message.topic][action], message_constants_1.TOPIC[message.topic]);\n        }\n    }\n}\nexports.Logger = Logger;\n\n\n//# sourceURL=webpack://deepstream/./src/util/logger.ts?")},"./src/util/state-machine.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nclass StateMachine {\n    constructor(logger, stateMachine) {\n        this.stateMachine = stateMachine;\n        this.inEndState = false;\n        this.transitions = stateMachine.transitions;\n        this.state = stateMachine.init;\n        this.context = stateMachine.context;\n    }\n    /**\n     * Try to perform a state change\n     */\n    transition(transitionName) {\n        let transition;\n        for (let i = 0; i < this.transitions.length; i++) {\n            transition = this.transitions[i];\n            if (transitionName === transition.name && (this.state === transition.from || transition.from === undefined)) {\n                const oldState = this.state;\n                this.state = transition.to;\n                if (this.stateMachine.onStateChanged) {\n                    this.stateMachine.onStateChanged.call(this.context, this.state, oldState);\n                }\n                if (transition.handler) {\n                    transition.handler.call(this.context);\n                }\n                return;\n            }\n        }\n        const details = JSON.stringify({ transition: transitionName, state: this.state });\n        throw new Error(`Invalid state transition: ${details}`);\n    }\n}\nexports.StateMachine = StateMachine;\n\n\n//# sourceURL=webpack://deepstream/./src/util/state-machine.ts?')},"./src/util/timeout-registry.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nconst constants_1 = __webpack_require__(/*! ../constants */ "./src/constants.ts");\nconst utils_1 = __webpack_require__(/*! ../../binary-protocol/src/utils */ "./binary-protocol/src/utils.ts");\nconst EventEmitter = __webpack_require__(/*! component-emitter2 */ "./node_modules/component-emitter2/index.js");\n/**\n * Subscriptions to events are in a pending state until deepstream acknowledges\n * them. This is a pattern that\'s used by numerour classes. This registry aims\n * to centralise the functionality necessary to keep track of subscriptions and\n * their respective timeouts.\n */\nclass TimeoutRegistry extends EventEmitter {\n    constructor(services, options) {\n        super();\n        this.services = services;\n        this.options = options;\n        this.register = new Map();\n    }\n    /**\n     * Add an entry\n     */\n    add(timeout) {\n        if (timeout.duration === undefined) {\n            timeout.duration = this.options.subscriptionTimeout;\n        }\n        if (timeout.event === undefined) {\n            timeout.event = constants_1.EVENT.ACK_TIMEOUT;\n        }\n        /*\n        if (timeout.duration < 1) {\n          should we throw an error?\n          return -1\n        }\n        */\n        if (!this.services.connection.isConnected) {\n            return null;\n        }\n        this.remove(timeout.message);\n        const internalTimeout = {\n            timerId: -1,\n            uniqueName: this.getUniqueName(timeout.message),\n            // event: timeout.event,\n            timeout\n        };\n        internalTimeout.timerId = this.services.timerRegistry.add({\n            context: this,\n            callback: this.onTimeout,\n            duration: timeout.duration,\n            data: internalTimeout\n        });\n        this.register.set(internalTimeout.uniqueName, internalTimeout);\n        return internalTimeout.uniqueName;\n    }\n    /**\n     * Remove an entry\n     */\n    remove(message) {\n        let requestMsg;\n        const action = utils_1.RESPONSE_TO_REQUEST[message.topic][message.action];\n        if (!action) {\n            requestMsg = message;\n        }\n        else {\n            requestMsg = Object.assign({}, message, { action });\n        }\n        const uniqueName = this.getUniqueName(requestMsg);\n        this.clear(uniqueName);\n    }\n    /**\n     * Processes an incoming ACK-message and removes the corresponding subscription\n     */\n    clear(uniqueName) {\n        const timeout = this.register.get(uniqueName);\n        if (timeout) {\n            this.register.delete(uniqueName);\n            this.services.timerRegistry.remove(timeout.timerId);\n        }\n    }\n    /**\n     * Will be invoked if the timeout has occured before the ack message was received\n     */\n    onTimeout(internalTimeout) {\n        this.register.delete(internalTimeout.uniqueName);\n        const timeout = internalTimeout.timeout;\n        if (timeout.callback) {\n            timeout.callback(timeout.event, timeout.message);\n        }\n        else {\n            this.services.logger.warn(timeout.message, timeout.event);\n        }\n    }\n    /**\n     * Returns a unique name from the timeout\n     */\n    getUniqueName(message) {\n        const action = message.originalAction || message.action;\n        let name = `${message.topic}${action}_`;\n        if (message.correlationId) {\n            name += message.correlationId;\n        }\n        else if (message.name) {\n            name += message.name;\n        }\n        return name;\n    }\n    /**\n     * Remote all timeouts when connection disconnects\n     */\n    onConnectionLost() {\n        for (const [uniqueName, timeout] of this.register) {\n            this.services.timerRegistry.remove(timeout.timerId);\n            this.register.delete(uniqueName);\n        }\n    }\n}\nexports.TimeoutRegistry = TimeoutRegistry;\n\n\n//# sourceURL=webpack://deepstream/./src/util/timeout-registry.ts?')},"./src/util/timer-registry.ts":function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nclass TimerRegistry {\n    constructor(timerResolution) {\n        this.registry = new Map();\n        this.timerIdCounter = 0;\n        setInterval(this.triggerTimeouts.bind(this), timerResolution);\n    }\n    triggerTimeouts() {\n        const now = Date.now();\n        for (const [timerId, timeout] of this.registry) {\n            if (now - timeout.created > timeout.duration) {\n                timeout.callback.call(timeout.context, timeout.data);\n                this.registry.delete(timerId);\n            }\n        }\n    }\n    has(timerId) {\n        return this.registry.has(timerId);\n    }\n    add(timeout) {\n        this.timerIdCounter++;\n        timeout.created = Date.now();\n        this.registry.set(this.timerIdCounter, timeout);\n        return this.timerIdCounter;\n    }\n    remove(timerId) {\n        return this.registry.delete(timerId);\n    }\n    requestIdleCallback(callback) {\n        setTimeout(callback, 0);\n    }\n}\nexports.TimerRegistry = TimerRegistry;\n\n\n//# sourceURL=webpack://deepstream/./src/util/timer-registry.ts?')},"./src/util/utils.ts":function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A regular expression that matches whitespace on either side, but\n * not in the center of a string\n */\nconst TRIM_REGULAR_EXPRESSION = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n/**\n * Removes whitespace from the beginning and end of a string\n */\nexports.trim = function (inputString) {\n    if (inputString.trim) {\n        return inputString.trim();\n    }\n    return inputString.replace(TRIM_REGULAR_EXPRESSION, '');\n};\n/**\n * Compares two objects for deep (recoursive) equality\n *\n * This used to be a significantly more complex custom implementation,\n * but JSON.stringify has gotten so fast that it now outperforms the custom\n * way by a factor of 1.5 to 3.\n *\n * In IE11 / Edge the custom implementation is still slightly faster, but for\n * consistencies sake and the upsides of leaving edge-case handling to the native\n * browser / node implementation we'll go for JSON.stringify from here on.\n *\n * Please find performance test results here\n *\n * http://jsperf.com/deep-equals-code-vs-json\n */\nexports.deepEquals = (objA, objB) => {\n    if (objA === objB) {\n        return true;\n    }\n    else if (typeof objA !== 'object' || typeof objB !== 'object') {\n        return false;\n    }\n    return JSON.stringify(objA) === JSON.stringify(objB);\n};\n/**\n * Similar to deepEquals above, tests have shown that JSON stringify outperforms any attempt of\n * a code based implementation by 50% - 100% whilst also handling edge-cases and keeping\n * implementation complexity low.\n *\n * If ES6/7 ever decides to implement deep copying natively (what happened to Object.clone?\n * that was briefly a thing...), let's switch it for the native implementation. For now though,\n * even Object.assign({}, obj) only provides a shallow copy.\n *\n * Please find performance test results backing these statements here:\n *\n * http://jsperf.com/object-deep-copy-assign\n */\nexports.deepCopy = (obj) => {\n    if (typeof obj === 'object') {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    return obj;\n};\n/**\n * Copy the top level of items, but do not copy its items recourisvely. This\n * is much quicker than deepCopy does not guarantee the object items are new/unique.\n * Mainly used to change the reference to the actual object itself, but not its children.\n */\nexports.shallowCopy = (obj) => {\n    if (Array.isArray(obj)) {\n        return obj.slice(0);\n    }\n    else if (typeof obj === 'object') {\n        const copy = Object.create(null);\n        const props = Object.keys(obj);\n        for (let i = 0; i < props.length; i++) {\n            copy[props[i]] = obj[props[i]];\n        }\n        return copy;\n    }\n    return obj;\n};\n/**\n * Used to see if a protocol is specified within the url\n * @type {RegExp}\n */\nconst hasUrlProtocol = /^wss:|^ws:|^\\/\\//;\n/**\n * Used to see if the protocol contains any unsupported protocols\n * @type {RegExp}\n */\nconst unsupportedProtocol = /^http:|^https:/;\n/**\n * Take the url passed when creating the client and ensure the correct\n * protocol is provided\n * @param  {String} url Url passed in by client\n * @return {String} Url with supported protocol\n */\nexports.parseUrl = (initialURl, defaultPath) => {\n    let url = initialURl;\n    if (unsupportedProtocol.test(url)) {\n        throw new Error('Only ws and wss are supported');\n    }\n    if (!hasUrlProtocol.test(url)) {\n        url = `ws://${url}`;\n    }\n    else if (url.indexOf('//') === 0) {\n        url = `ws:${url}`;\n    }\n    const serverUrl = new URL(url);\n    if (!serverUrl.host) {\n        throw new Error('invalid url, missing host');\n    }\n    serverUrl.protocol = serverUrl.protocol ? serverUrl.protocol : 'ws:';\n    serverUrl.pathname = serverUrl.pathname && serverUrl.pathname !== '/' ? serverUrl.pathname : defaultPath;\n    return serverUrl.href;\n};\n/**\n* Returns a random string. The first block of characters\n* is a timestamp, in order to allow databases to optimize for semi-\n* sequentuel numberings\n*/\nexports.getUid = () => {\n    const timestamp = (new Date()).getTime().toString(36);\n    const randomString = (Math.random() * 10000000000000000).toString(36).replace('.', '');\n    return `${timestamp}-${randomString}`;\n};\n/**\n * Creates a map based on the types of the provided arguments\n */\nexports.normalizeSetArguments = (args, startIndex = 0) => {\n    let result;\n    const isRootData = (data) => data !== undefined && typeof data === 'object';\n    const isNestedData = (data) => typeof data !== 'function';\n    const isPath = (path) => path !== undefined && typeof path === 'string';\n    const isCallback = (callback) => typeof callback === 'function';\n    if (args.length === startIndex + 1) {\n        result = {\n            path: undefined,\n            data: isRootData(args[startIndex]) ? args[startIndex] : undefined,\n            callback: undefined\n        };\n    }\n    if (args.length === startIndex + 2) {\n        result = { path: undefined, data: undefined, callback: undefined };\n        if (!isCallback(args[startIndex]) && isNestedData(args[startIndex])) {\n            result.path = isPath(args[startIndex]) ? args[startIndex] : undefined;\n        }\n        if (isPath(args[startIndex])) {\n            result.data = isNestedData(args[startIndex + 1]) ? args[startIndex + 1] : undefined;\n        }\n        else {\n            result.data = isRootData(args[startIndex]) ? args[startIndex] : undefined;\n        }\n        if (!isPath(args[startIndex])) {\n            result.callback = isCallback(args[startIndex + 1]) ? args[startIndex + 1] : false;\n        }\n    }\n    if (args.length === startIndex + 3) {\n        result = {\n            path: isPath(args[startIndex]) ? args[startIndex] : undefined,\n            data: isNestedData(args[startIndex + 1]) ? args[startIndex + 1] : undefined,\n            callback: isCallback(args[startIndex + 2]) ? args[startIndex + 2] : undefined\n        };\n    }\n    if (result) {\n        if (result.path !== undefined && result.path.length === 0 ||\n            (result.path === undefined && !result.data)) {\n            throw Error('Invalid set path argument');\n        }\n        if (result.data === undefined && result.path === undefined) {\n            throw Error('Invalid set data argument');\n        }\n        if (result.callback !== undefined && result.callback === false ||\n            result.callback === undefined && args.length === startIndex + 3) {\n            throw Error('Invalid set callback argument');\n        }\n        return result;\n    }\n    throw Error('Invalid set arguments');\n};\n/**\n * Creates a map based on the types of the provided arguments\n */\nexports.normalizeArguments = (args) => {\n    // If arguments is already a map of normalized parameters\n    // (e.g. when called by AnonymousRecord), just return it.\n    if (args.length === 1 && typeof args[0] === 'object') {\n        return args[0];\n    }\n    const result = Object.create(null);\n    for (let i = 0; i < args.length; i++) {\n        if (typeof args[i] === 'string') {\n            result.path = args[i];\n        }\n        else if (typeof args[i] === 'function') {\n            result.callback = args[i];\n        }\n        else if (typeof args[i] === 'boolean') {\n            result.triggerNow = args[i];\n        }\n    }\n    return result;\n};\n\n\n//# sourceURL=webpack://deepstream/./src/util/utils.ts?")},0:function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__(/*! ./src/deepstream.ts */"./src/deepstream.ts");\n\n\n//# sourceURL=webpack://deepstream/multi_./src/deepstream.ts?')}},e={},f.m=d,f.c=e,f.d=function(e,n,t){f.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},f.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},f.t=function(n,e){if(1&e&&(n=f(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(f.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var s in n)f.d(t,s,function(e){return n[e]}.bind(null,s));return t},f.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return f.d(n,"a",n),n},f.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},f.p="",f(f.s=0);function f(n){if(e[n])return e[n].exports;var t=e[n]={i:n,l:!1,exports:{}};return d[n].call(t.exports,t,t.exports,f),t.l=!0,t.exports}var d,e});