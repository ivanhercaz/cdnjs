var UITreeNode_1,__decorate=this&&this.__decorate||function(e,t,o,i){var n,r=arguments.length,d=r<3?t:null===i?i=Object.getOwnPropertyDescriptor(t,o):i;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)d=Reflect.decorate(e,t,o,i);else for(var s=e.length-1;s>=0;s--)(n=e[s])&&(d=(r<3?n(d):r>3?n(t,o,d):n(t,o))||d);return r>3&&d&&Object.defineProperty(t,o,d),d},__param=this&&this.__param||function(e,t){return function(o,i){t(o,i,e)}};import{NgModule,Component,Input,AfterContentInit,OnDestroy,Output,EventEmitter,OnInit,ContentChildren,QueryList,TemplateRef,Inject,ElementRef,forwardRef,ChangeDetectionStrategy}from"@angular/core";import{Optional}from"@angular/core";import{CommonModule}from"@angular/common";import{SharedModule}from"primeng/api";import{PrimeTemplate}from"primeng/api";import{TreeDragDropService}from"primeng/api";import{ObjectUtils}from"primeng/utils";import{DomHandler}from"primeng/dom";let UITreeNode=UITreeNode_1=class{constructor(e){this.tree=e}ngOnInit(){this.node.parent=this.parentNode,this.parentNode&&this.tree.syncNodeOption(this.node,this.tree.value,"parent",this.tree.getNodeWithKey(this.parentNode.key,this.tree.value))}getIcon(){let e;return e=this.node.icon?this.node.icon:this.node.expanded&&this.node.children&&this.node.children.length?this.node.expandedIcon:this.node.collapsedIcon,UITreeNode_1.ICON_CLASS+" "+e}isLeaf(){return this.tree.isNodeLeaf(this.node)}toggle(e){this.node.expanded?this.collapse(e):this.expand(e)}expand(e){this.node.expanded=!0,this.tree.onNodeExpand.emit({originalEvent:e,node:this.node})}collapse(e){this.node.expanded=!1,this.tree.onNodeCollapse.emit({originalEvent:e,node:this.node})}onNodeClick(e){this.tree.onNodeClick(e,this.node)}onNodeKeydown(e){13===e.which&&this.tree.onNodeClick(e,this.node)}onNodeTouchEnd(){this.tree.onNodeTouchEnd()}onNodeRightClick(e){this.tree.onNodeRightClick(e,this.node)}isSelected(){return this.tree.isSelected(this.node)}onDropPoint(e,t){e.preventDefault();let o=this.tree.dragNode,i=this.tree.dragNodeIndex,n=this.tree.dragNodeScope,r=this.tree.dragNodeTree!==this.tree||(1===t||i!==this.index-1);this.tree.allowDrop(o,this.node,n)&&r&&(this.tree.validateDrop?this.tree.onNodeDrop.emit({originalEvent:e,dragNode:o,dropNode:this.node,dropIndex:this.index,accept:()=>{this.processPointDrop(o,i,t)}}):(this.processPointDrop(o,i,t),this.tree.onNodeDrop.emit({originalEvent:e,dragNode:o,dropNode:this.node,dropIndex:this.index}))),this.draghoverPrev=!1,this.draghoverNext=!1}processPointDrop(e,t,o){let i=this.node.parent?this.node.parent.children:this.tree.value;this.tree.dragNodeSubNodes.splice(t,1);let n=this.index;o<0?(n=this.tree.dragNodeSubNodes===i?this.tree.dragNodeIndex>this.index?this.index:this.index-1:this.index,i.splice(n,0,e)):(n=i.length,i.push(e)),this.tree.dragDropService.stopDrag({node:e,subNodes:this.node.parent?this.node.parent.children:this.tree.value,index:t})}onDropPointDragOver(e){e.dataTransfer.dropEffect="move",e.preventDefault()}onDropPointDragEnter(e,t){this.tree.allowDrop(this.tree.dragNode,this.node,this.tree.dragNodeScope)&&(t<0?this.draghoverPrev=!0:this.draghoverNext=!0)}onDropPointDragLeave(e){this.draghoverPrev=!1,this.draghoverNext=!1}onDragStart(e){this.tree.draggableNodes&&!1!==this.node.draggable?(e.dataTransfer.setData("text","data"),this.tree.dragDropService.startDrag({tree:this,node:this.node,subNodes:this.node.parent?this.node.parent.children:this.tree.value,index:this.index,scope:this.tree.draggableScope})):e.preventDefault()}onDragStop(e){this.tree.dragDropService.stopDrag({node:this.node,subNodes:this.node.parent?this.node.parent.children:this.tree.value,index:this.index})}onDropNodeDragOver(e){e.dataTransfer.dropEffect="move",this.tree.droppableNodes&&(e.preventDefault(),e.stopPropagation())}onDropNode(e){if(this.tree.droppableNodes&&!1!==this.node.droppable){e.preventDefault(),e.stopPropagation();let t=this.tree.dragNode;this.tree.allowDrop(t,this.node,this.tree.dragNodeScope)&&(this.tree.validateDrop?this.tree.onNodeDrop.emit({originalEvent:e,dragNode:t,dropNode:this.node,index:this.index,accept:()=>{this.processNodeDrop(t)}}):(this.processNodeDrop(t),this.tree.onNodeDrop.emit({originalEvent:e,dragNode:t,dropNode:this.node,index:this.index})))}this.draghoverNode=!1}processNodeDrop(e){let t=this.tree.dragNodeIndex;this.tree.dragNodeSubNodes.splice(t,1),this.node.children?this.node.children.push(e):this.node.children=[e],this.tree.dragDropService.stopDrag({node:e,subNodes:this.node.parent?this.node.parent.children:this.tree.value,index:this.tree.dragNodeIndex})}onDropNodeDragEnter(e){this.tree.droppableNodes&&!1!==this.node.droppable&&this.tree.allowDrop(this.tree.dragNode,this.node,this.tree.dragNodeScope)&&(this.draghoverNode=!0)}onDropNodeDragLeave(e){if(this.tree.droppableNodes){let t=e.currentTarget.getBoundingClientRect();(e.x>t.left+t.width||e.x<t.left||e.y>=Math.floor(t.top+t.height)||e.y<t.top)&&(this.draghoverNode=!1)}}onKeyDown(e){const t=e.target.parentElement.parentElement;if("P-TREENODE"===t.nodeName)switch(e.which){case 40:const o=this.tree.droppableNodes?t.children[1].children[1]:t.children[0].children[1];if(o&&o.children.length>0)this.focusNode(o.children[0]);else{const e=t.nextElementSibling;if(e)this.focusNode(e);else{let e=this.findNextSiblingOfAncestor(t);e&&this.focusNode(e)}}e.preventDefault();break;case 38:if(t.previousElementSibling)this.focusNode(this.findLastVisibleDescendant(t.previousElementSibling));else{let e=this.getParentNodeElement(t);e&&this.focusNode(e)}e.preventDefault();break;case 39:this.node.expanded||this.expand(e),e.preventDefault();break;case 37:if(this.node.expanded)this.collapse(e);else{let e=this.getParentNodeElement(t);e&&this.focusNode(e)}e.preventDefault();break;case 13:this.tree.onNodeClick(e,this.node),e.preventDefault()}}findNextSiblingOfAncestor(e){let t=this.getParentNodeElement(e);return t?t.nextElementSibling?t.nextElementSibling:this.findNextSiblingOfAncestor(t):null}findLastVisibleDescendant(e){const t=e.children[0].children[1];if(t&&t.children.length>0){const e=t.children[t.children.length-1];return this.findLastVisibleDescendant(e)}return e}getParentNodeElement(e){const t=e.parentElement.parentElement.parentElement;return"P-TREENODE"===t.tagName?t:null}focusNode(e){this.tree.droppableNodes?e.children[1].children[0].focus():e.children[0].children[0].focus()}};UITreeNode.ICON_CLASS="ui-treenode-icon ",UITreeNode.ctorParameters=(()=>[{type:void 0,decorators:[{type:Inject,args:[forwardRef(()=>Tree)]}]}]),__decorate([Input()],UITreeNode.prototype,"node",void 0),__decorate([Input()],UITreeNode.prototype,"parentNode",void 0),__decorate([Input()],UITreeNode.prototype,"root",void 0),__decorate([Input()],UITreeNode.prototype,"index",void 0),__decorate([Input()],UITreeNode.prototype,"firstChild",void 0),__decorate([Input()],UITreeNode.prototype,"lastChild",void 0),UITreeNode=UITreeNode_1=__decorate([Component({selector:"p-treeNode",template:'\n        <ng-template [ngIf]="node">\n            <li *ngIf="tree.droppableNodes" class="ui-treenode-droppoint" [ngClass]="{\'ui-treenode-droppoint-active ui-state-highlight\':draghoverPrev}"\n            (drop)="onDropPoint($event,-1)" (dragover)="onDropPointDragOver($event)" (dragenter)="onDropPointDragEnter($event,-1)" (dragleave)="onDropPointDragLeave($event)"></li>\n            <li *ngIf="!tree.horizontal" role="treeitem" [ngClass]="[\'ui-treenode\',node.styleClass||\'\', isLeaf() ? \'ui-treenode-leaf\': \'\']">\n                <div class="ui-treenode-content" (click)="onNodeClick($event)" (contextmenu)="onNodeRightClick($event)" (touchend)="onNodeTouchEnd()"\n                    (drop)="onDropNode($event)" (dragover)="onDropNodeDragOver($event)" (dragenter)="onDropNodeDragEnter($event)" (dragleave)="onDropNodeDragLeave($event)"\n                    [draggable]="tree.draggableNodes" (dragstart)="onDragStart($event)" (dragend)="onDragStop($event)" [attr.tabindex]="0"\n                    [ngClass]="{\'ui-treenode-selectable\':tree.selectionMode && node.selectable !== false,\'ui-treenode-dragover\':draghoverNode, \'ui-treenode-content-selected\':isSelected()}" \n                    (keydown)="onKeyDown($event)" [attr.aria-posinset]="this.index + 1" [attr.aria-expanded]="this.node.expanded" [attr.aria-selected]="isSelected()" [attr.aria-label]="node.label">\n                    <span class="ui-tree-toggler pi pi-fw ui-unselectable-text" [ngClass]="{\'pi-caret-right\':!node.expanded,\'pi-caret-down\':node.expanded}"\n                            (click)="toggle($event)"></span\n                    ><div class="ui-chkbox" *ngIf="tree.selectionMode == \'checkbox\'" [attr.aria-checked]="isSelected()"><div class="ui-chkbox-box ui-widget ui-corner-all ui-state-default" [ngClass]="{\'ui-state-disabled\': node.selectable === false}">\n                        <span class="ui-chkbox-icon ui-clickable pi"\n                            [ngClass]="{\'pi-check\':isSelected(),\'pi-minus\':node.partialSelected}"></span></div></div\n                    ><span [class]="getIcon()" *ngIf="node.icon||node.expandedIcon||node.collapsedIcon"></span\n                    ><span class="ui-treenode-label ui-corner-all"\n                        [ngClass]="{\'ui-state-highlight\':isSelected()}">\n                            <span *ngIf="!tree.getTemplateForNode(node)">{{node.label}}</span>\n                            <span *ngIf="tree.getTemplateForNode(node)">\n                                <ng-container *ngTemplateOutlet="tree.getTemplateForNode(node); context: {$implicit: node}"></ng-container>\n                            </span>\n                    </span>\n                </div>\n                <ul class="ui-treenode-children" style="display: none;" *ngIf="node.children && node.expanded" [style.display]="node.expanded ? \'block\' : \'none\'" role="group">\n                    <p-treeNode *ngFor="let childNode of node.children;let firstChild=first;let lastChild=last; let index=index; trackBy: tree.nodeTrackBy" [node]="childNode" [parentNode]="node"\n                        [firstChild]="firstChild" [lastChild]="lastChild" [index]="index"></p-treeNode>\n                </ul>\n            </li>\n            <li *ngIf="tree.droppableNodes&&lastChild" class="ui-treenode-droppoint" [ngClass]="{\'ui-treenode-droppoint-active ui-state-highlight\':draghoverNext}"\n            (drop)="onDropPoint($event,1)" (dragover)="onDropPointDragOver($event)" (dragenter)="onDropPointDragEnter($event,1)" (dragleave)="onDropPointDragLeave($event)"></li>\n            <table *ngIf="tree.horizontal" [class]="node.styleClass">\n                <tbody>\n                    <tr>\n                        <td class="ui-treenode-connector" *ngIf="!root">\n                            <table class="ui-treenode-connector-table">\n                                <tbody>\n                                    <tr>\n                                        <td [ngClass]="{\'ui-treenode-connector-line\':!firstChild}"></td>\n                                    </tr>\n                                    <tr>\n                                        <td [ngClass]="{\'ui-treenode-connector-line\':!lastChild}"></td>\n                                    </tr>\n                                </tbody>\n                            </table>\n                        </td>\n                        <td class="ui-treenode" [ngClass]="{\'ui-treenode-collapsed\':!node.expanded}">\n                            <div class="ui-treenode-content ui-state-default ui-corner-all" tabindex="0"\n                                [ngClass]="{\'ui-treenode-selectable\':tree.selectionMode,\'ui-state-highlight\':isSelected()}" (click)="onNodeClick($event)" (contextmenu)="onNodeRightClick($event)"\n                                (touchend)="onNodeTouchEnd()" (keydown)="onNodeKeydown($event)">\n                                <span class="ui-tree-toggler pi pi-fw ui-unselectable-text" [ngClass]="{\'pi-plus\':!node.expanded,\'pi-minus\':node.expanded}" *ngIf="!isLeaf()"\n                                        (click)="toggle($event)"></span\n                                ><span [class]="getIcon()" *ngIf="node.icon||node.expandedIcon||node.collapsedIcon"></span\n                                ><span class="ui-treenode-label ui-corner-all">\n                                        <span *ngIf="!tree.getTemplateForNode(node)">{{node.label}}</span>\n                                        <span *ngIf="tree.getTemplateForNode(node)">\n                                        <ng-container *ngTemplateOutlet="tree.getTemplateForNode(node); context: {$implicit: node}"></ng-container>\n                                        </span>\n                                </span>\n                            </div>\n                        </td>\n                        <td class="ui-treenode-children-container" *ngIf="node.children && node.expanded" [style.display]="node.expanded ? \'table-cell\' : \'none\'">\n                            <div class="ui-treenode-children">\n                                <p-treeNode *ngFor="let childNode of node.children;let firstChild=first;let lastChild=last; trackBy: tree.nodeTrackBy" [node]="childNode"\n                                        [firstChild]="firstChild" [lastChild]="lastChild"></p-treeNode>\n                            </div>\n                        </td>\n                    </tr>\n                </tbody>\n            </table>\n        </ng-template>\n    '}),__param(0,Inject(forwardRef(()=>Tree)))],UITreeNode);export{UITreeNode};let Tree=class{constructor(e,t){this.el=e,this.dragDropService=t,this.selectionChange=new EventEmitter,this.onNodeSelect=new EventEmitter,this.onNodeUnselect=new EventEmitter,this.onNodeExpand=new EventEmitter,this.onNodeCollapse=new EventEmitter,this.onNodeContextMenuSelect=new EventEmitter,this.onNodeDrop=new EventEmitter,this.layout="vertical",this.metaKeySelection=!0,this.propagateSelectionUp=!0,this.propagateSelectionDown=!0,this.loadingIcon="pi pi-spinner",this.emptyMessage="No records found",this.filterBy="label",this.filterMode="lenient",this.nodeTrackBy=((e,t)=>t)}ngOnInit(){this.droppableNodes&&(this.dragStartSubscription=this.dragDropService.dragStart$.subscribe(e=>{this.dragNodeTree=e.tree,this.dragNode=e.node,this.dragNodeSubNodes=e.subNodes,this.dragNodeIndex=e.index,this.dragNodeScope=e.scope}),this.dragStopSubscription=this.dragDropService.dragStop$.subscribe(e=>{this.dragNodeTree=null,this.dragNode=null,this.dragNodeSubNodes=null,this.dragNodeIndex=null,this.dragNodeScope=null,this.dragHover=!1}))}get horizontal(){return"horizontal"==this.layout}ngAfterContentInit(){this.templates.length&&(this.templateMap={}),this.templates.forEach(e=>{this.templateMap[e.name]=e.template})}onNodeClick(e,t){let o=e.target;if(!DomHandler.hasClass(o,"ui-tree-toggler")){if(this.selectionMode){if(!1===t.selectable)return;if(this.hasFilteredNodes()&&!(t=this.getNodeWithKey(t.key,this.value)))return;let o=this.findIndexInSelection(t),i=o>=0;if(this.isCheckboxSelectionMode())i?(this.propagateSelectionDown?this.propagateDown(t,!1):this.selection=this.selection.filter((e,t)=>t!=o),this.propagateSelectionUp&&t.parent&&this.propagateUp(t.parent,!1),this.selectionChange.emit(this.selection),this.onNodeUnselect.emit({originalEvent:e,node:t})):(this.propagateSelectionDown?this.propagateDown(t,!0):this.selection=[...this.selection||[],t],this.propagateSelectionUp&&t.parent&&this.propagateUp(t.parent,!0),this.selectionChange.emit(this.selection),this.onNodeSelect.emit({originalEvent:e,node:t}));else{if(!this.nodeTouched&&this.metaKeySelection){let n=e.metaKey||e.ctrlKey;i&&n?(this.isSingleSelectionMode()?this.selectionChange.emit(null):(this.selection=this.selection.filter((e,t)=>t!=o),this.selectionChange.emit(this.selection)),this.onNodeUnselect.emit({originalEvent:e,node:t})):(this.isSingleSelectionMode()?this.selectionChange.emit(t):this.isMultipleSelectionMode()&&(this.selection=n&&this.selection||[],this.selection=[...this.selection,t],this.selectionChange.emit(this.selection)),this.onNodeSelect.emit({originalEvent:e,node:t}))}else this.isSingleSelectionMode()?i?(this.selection=null,this.onNodeUnselect.emit({originalEvent:e,node:t})):(this.selection=t,this.onNodeSelect.emit({originalEvent:e,node:t})):i?(this.selection=this.selection.filter((e,t)=>t!=o),this.onNodeUnselect.emit({originalEvent:e,node:t})):(this.selection=[...this.selection||[],t],this.onNodeSelect.emit({originalEvent:e,node:t})),this.selectionChange.emit(this.selection)}}this.nodeTouched=!1}}onNodeTouchEnd(){this.nodeTouched=!0}onNodeRightClick(e,t){if(this.contextMenu){let o=e.target;if(o.className&&0===o.className.indexOf("ui-tree-toggler"))return;this.findIndexInSelection(t)>=0||(this.isSingleSelectionMode()?this.selectionChange.emit(t):this.selectionChange.emit([t])),this.contextMenu.show(e),this.onNodeContextMenuSelect.emit({originalEvent:e,node:t})}}findIndexInSelection(e){let t=-1;if(this.selectionMode&&this.selection)if(this.isSingleSelectionMode()){t=this.selection.key&&this.selection.key===e.key||this.selection==e?0:-1}else for(let o=0;o<this.selection.length;o++){let i=this.selection[o];if(i.key&&i.key===e.key||i==e){t=o;break}}return t}syncNodeOption(e,t,o,i){const n=this.hasFilteredNodes()?this.getNodeWithKey(e.key,t):null;n&&(n[o]=i||e[o])}hasFilteredNodes(){return this.filter&&this.filteredNodes&&this.filteredNodes.length}getNodeWithKey(e,t){for(let o of t){if(o.key===e)return o;if(o.children){let t=this.getNodeWithKey(e,o.children);if(t)return t}}}propagateUp(e,t){if(e.children&&e.children.length){let o=0,i=!1;for(let t of e.children)this.isSelected(t)?o++:t.partialSelected&&(i=!0);if(t&&o==e.children.length)this.selection=[...this.selection||[],e],e.partialSelected=!1;else{if(!t){let t=this.findIndexInSelection(e);t>=0&&(this.selection=this.selection.filter((e,o)=>o!=t))}i||o>0&&o!=e.children.length?e.partialSelected=!0:e.partialSelected=!1}this.syncNodeOption(e,this.filteredNodes,"partialSelected")}let o=e.parent;o&&this.propagateUp(o,t)}propagateDown(e,t){let o=this.findIndexInSelection(e);if(t&&-1==o?this.selection=[...this.selection||[],e]:!t&&o>-1&&(this.selection=this.selection.filter((e,t)=>t!=o)),e.partialSelected=!1,this.syncNodeOption(e,this.filteredNodes,"partialSelected"),e.children&&e.children.length)for(let o of e.children)this.propagateDown(o,t)}isSelected(e){return-1!=this.findIndexInSelection(e)}isSingleSelectionMode(){return this.selectionMode&&"single"==this.selectionMode}isMultipleSelectionMode(){return this.selectionMode&&"multiple"==this.selectionMode}isCheckboxSelectionMode(){return this.selectionMode&&"checkbox"==this.selectionMode}isNodeLeaf(e){return 0!=e.leaf&&!(e.children&&e.children.length)}getRootNode(){return this.filteredNodes?this.filteredNodes:this.value}getTemplateForNode(e){return this.templateMap?e.type?this.templateMap[e.type]:this.templateMap.default:null}onDragOver(e){!this.droppableNodes||this.value&&0!==this.value.length||(e.dataTransfer.dropEffect="move",e.preventDefault())}onDrop(e){if(this.droppableNodes&&(!this.value||0===this.value.length)){e.preventDefault();let t=this.dragNode;if(this.allowDrop(t,null,this.dragNodeScope)){let e=this.dragNodeIndex;this.dragNodeSubNodes.splice(e,1),this.value=this.value||[],this.value.push(t),this.dragDropService.stopDrag({node:t})}}}onDragEnter(e){this.droppableNodes&&this.allowDrop(this.dragNode,null,this.dragNodeScope)&&(this.dragHover=!0)}onDragLeave(e){if(this.droppableNodes){let t=e.currentTarget.getBoundingClientRect();(e.x>t.left+t.width||e.x<t.left||e.y>t.top+t.height||e.y<t.top)&&(this.dragHover=!1)}}allowDrop(e,t,o){if(e){if(this.isValidDragScope(o)){let o=!0;if(t)if(e===t)o=!1;else{let i=t.parent;for(;null!=i;){if(i===e){o=!1;break}i=i.parent}}return o}return!1}return!1}isValidDragScope(e){let t=this.droppableScope;if(t){if("string"==typeof t){if("string"==typeof e)return t===e;if(e instanceof Array)return-1!=e.indexOf(t)}else if(t instanceof Array){if("string"==typeof e)return-1!=t.indexOf(e);if(e instanceof Array)for(let o of t)for(let t of e)if(o===t)return!0}return!1}return!0}onFilter(e){let t=e.target.value;if(""===t)this.filteredNodes=null;else{this.filteredNodes=[];const e=this.filterBy.split(","),o=ObjectUtils.removeAccents(t).toLowerCase(),i="strict"===this.filterMode;for(let t of this.value){let n=Object.assign({},t),r={searchFields:e,filterText:o,isStrictMode:i};(i&&(this.findFilteredNodes(n,r)||this.isFilterMatched(n,r))||!i&&(this.isFilterMatched(n,r)||this.findFilteredNodes(n,r)))&&this.filteredNodes.push(n)}}}findFilteredNodes(e,t){if(e){let o=!1;if(e.children){let i=[...e.children];e.children=[];for(let n of i){let i=Object.assign({},n);this.isFilterMatched(i,t)&&(o=!0,e.children.push(i))}}if(o)return e.expanded=!0,!0}}isFilterMatched(e,{searchFields:t,filterText:o,isStrictMode:i}){let n=!1;for(let i of t){ObjectUtils.removeAccents(String(ObjectUtils.resolveFieldData(e,i))).toLowerCase().indexOf(o)>-1&&(n=!0)}return(!n||i&&!this.isNodeLeaf(e))&&(n=this.findFilteredNodes(e,{searchFields:t,filterText:o,isStrictMode:i})||n),n}getBlockableElement(){return this.el.nativeElement.children[0]}ngOnDestroy(){this.dragStartSubscription&&this.dragStartSubscription.unsubscribe(),this.dragStopSubscription&&this.dragStopSubscription.unsubscribe()}};Tree.ctorParameters=(()=>[{type:ElementRef},{type:TreeDragDropService,decorators:[{type:Optional}]}]),__decorate([Input()],Tree.prototype,"value",void 0),__decorate([Input()],Tree.prototype,"selectionMode",void 0),__decorate([Input()],Tree.prototype,"selection",void 0),__decorate([Output()],Tree.prototype,"selectionChange",void 0),__decorate([Output()],Tree.prototype,"onNodeSelect",void 0),__decorate([Output()],Tree.prototype,"onNodeUnselect",void 0),__decorate([Output()],Tree.prototype,"onNodeExpand",void 0),__decorate([Output()],Tree.prototype,"onNodeCollapse",void 0),__decorate([Output()],Tree.prototype,"onNodeContextMenuSelect",void 0),__decorate([Output()],Tree.prototype,"onNodeDrop",void 0),__decorate([Input()],Tree.prototype,"style",void 0),__decorate([Input()],Tree.prototype,"styleClass",void 0),__decorate([Input()],Tree.prototype,"contextMenu",void 0),__decorate([Input()],Tree.prototype,"layout",void 0),__decorate([Input()],Tree.prototype,"draggableScope",void 0),__decorate([Input()],Tree.prototype,"droppableScope",void 0),__decorate([Input()],Tree.prototype,"draggableNodes",void 0),__decorate([Input()],Tree.prototype,"droppableNodes",void 0),__decorate([Input()],Tree.prototype,"metaKeySelection",void 0),__decorate([Input()],Tree.prototype,"propagateSelectionUp",void 0),__decorate([Input()],Tree.prototype,"propagateSelectionDown",void 0),__decorate([Input()],Tree.prototype,"loading",void 0),__decorate([Input()],Tree.prototype,"loadingIcon",void 0),__decorate([Input()],Tree.prototype,"emptyMessage",void 0),__decorate([Input()],Tree.prototype,"ariaLabel",void 0),__decorate([Input()],Tree.prototype,"ariaLabelledBy",void 0),__decorate([Input()],Tree.prototype,"validateDrop",void 0),__decorate([Input()],Tree.prototype,"filter",void 0),__decorate([Input()],Tree.prototype,"filterBy",void 0),__decorate([Input()],Tree.prototype,"filterMode",void 0),__decorate([Input()],Tree.prototype,"filterPlaceholder",void 0),__decorate([Input()],Tree.prototype,"nodeTrackBy",void 0),__decorate([ContentChildren(PrimeTemplate)],Tree.prototype,"templates",void 0),Tree=__decorate([Component({selector:"p-tree",template:'\n        <div [ngClass]="{\'ui-tree ui-widget ui-widget-content ui-corner-all\':true,\'ui-tree-selectable\':selectionMode,\'ui-treenode-dragover\':dragHover,\'ui-tree-loading\': loading}" [ngStyle]="style" [class]="styleClass" *ngIf="!horizontal"\n            (drop)="onDrop($event)" (dragover)="onDragOver($event)" (dragenter)="onDragEnter($event)" (dragleave)="onDragLeave($event)">\n            <div class="ui-tree-loading-mask ui-widget-overlay" *ngIf="loading"></div>\n            <div class="ui-tree-loading-content" *ngIf="loading">\n                <i [class]="\'ui-tree-loading-icon pi-spin \' + loadingIcon"></i>\n            </div>\n            <div *ngIf="filter" class="ui-tree-filter-container">\n                <input #filter type="text" autocomplete="off" class="ui-tree-filter ui-inputtext ui-widget ui-state-default ui-corner-all" [attr.placeholder]="filterPlaceholder"\n                    (keydown.enter)="$event.preventDefault()" (input)="onFilter($event)">\n                    <span class="ui-tree-filter-icon pi pi-search"></span>\n            </div>\n            <ul class="ui-tree-container" *ngIf="getRootNode()" role="tree" [attr.aria-label]="ariaLabel" [attr.aria-labelledby]="ariaLabelledBy">\n                <p-treeNode *ngFor="let node of getRootNode(); let firstChild=first;let lastChild=last; let index=index; trackBy: nodeTrackBy" [node]="node"\n                [firstChild]="firstChild" [lastChild]="lastChild" [index]="index"></p-treeNode>\n            </ul>\n            <div class="ui-tree-empty-message" *ngIf="!loading && (value == null || value.length === 0)">{{emptyMessage}}</div>\n        </div>\n        <div [ngClass]="{\'ui-tree ui-tree-horizontal ui-widget ui-widget-content ui-corner-all\':true,\'ui-tree-selectable\':selectionMode}"  [ngStyle]="style" [class]="styleClass" *ngIf="horizontal">\n            <div class="ui-tree-loading ui-widget-overlay" *ngIf="loading"></div>\n            <div class="ui-tree-loading-content" *ngIf="loading">\n                <i [class]="\'ui-tree-loading-icon pi-spin \' + loadingIcon"></i>\n            </div>\n            <table *ngIf="value&&value[0]">\n                <p-treeNode [node]="value[0]" [root]="true"></p-treeNode>\n            </table>\n            <div class="ui-tree-empty-message" *ngIf="!loading && (value == null || value.length === 0)">{{emptyMessage}}</div>\n        </div>\n    ',changeDetection:ChangeDetectionStrategy.Default}),__param(1,Optional())],Tree);export{Tree};let TreeModule=class{};TreeModule=__decorate([NgModule({imports:[CommonModule],exports:[Tree,SharedModule],declarations:[Tree,UITreeNode]})],TreeModule);export{TreeModule};