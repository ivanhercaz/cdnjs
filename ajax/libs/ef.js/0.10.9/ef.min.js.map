{"version":3,"file":"ef.min.js","sources":["../node_modules/eft-parser/src/escape-parser.js","../node_modules/eft-parser/src/eft-parser.js","../node_modules/ef-core/src/lib/utils/type-of.js","../node_modules/ef-core/src/lib/utils/literals-mix.js","../node_modules/ef-core/src/lib/utils/array-helper.js","../node_modules/ef-core/src/lib/render-queue.js","../node_modules/ef-core/src/lib/utils/polyfills.js","../node_modules/ef-core/src/lib/resolver.js","../node_modules/ef-core/src/lib/utils/isnan.js","../node_modules/ef-core/src/lib/binding.js","../node_modules/ef-core/src/lib/utils/fast-instance-of.js","../node_modules/ef-core/src/lib/utils/buble-fix.js","../node_modules/ef-core/src/lib/utils/debug.js","../node_modules/ef-core/src/lib/utils/global-shared.js","../node_modules/ef-core/src/lib/utils/dom-helper.js","../node_modules/ef-core/src/lib/utils/event-helper.js","../node_modules/ef-core/src/lib/element-creator.js","../node_modules/ef-core/src/lib/creator.js","../node_modules/ef-core/src/lib/utils/dom-arr-helper.js","../node_modules/ef-core/src/lib/map-attrs.js","../node_modules/ef-core/src/mount-options.js","../node_modules/ef-core/src/lib/renderer.js","../node_modules/ef-core/src/lib/jsx-create-element.js","../src/ef.js","../node_modules/ef-core/src/ef-core.js","../src/lib/parser.js","../node_modules/ef-core/src/lib/utils/scoped-component.js"],"sourcesContent":["// Set the escape character\nconst char = '&'\nconst doubleChar = char + char\n\n// Initlize RegExp\nconst oct = new RegExp(`\\\\${char}[0-7]{1,3}`, 'g')\nconst ucp = new RegExp(`\\\\${char}u\\\\[.*?\\\\]`, 'g')\nconst uni = new RegExp(`\\\\${char}u.{0,4}`, 'g')\nconst hex = new RegExp(`\\\\${char}x.{0,2}`, 'g')\nconst esc = new RegExp(`\\\\${char}`, 'g')\nconst b = new RegExp(`\\\\${char}b`, 'g')\nconst t = new RegExp(`\\\\${char}t`, 'g')\nconst n = new RegExp(`\\\\${char}n`, 'g')\nconst v = new RegExp(`\\\\${char}v`, 'g')\nconst f = new RegExp(`\\\\${char}f`, 'g')\nconst r = new RegExp(`\\\\${char}r`, 'g')\n\n// Escape octonary sequence\nconst O2C = () => {\n\tthrow new SyntaxError('Octal escape sequences are not allowed in EFML.')\n}\n\n// Escape unicode code point sequence\nconst UC2C = (val) => {\n\tval = val.substr(3, val.length - 4)\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid Unicode escape sequence')\n\ttry {\n\t\treturn String.fromCodePoint(val)\n\t} catch (err) {\n\t\tthrow new SyntaxError('Undefined Unicode code-point')\n\t}\n}\n\n// Escape unicode sequence\nconst U2C = (val) => {\n\tval = val.substring(2)\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid Unicode escape sequence')\n\treturn String.fromCharCode(val)\n}\n\n// Escape hexadecimal sequence\nconst X2C = (val) => {\n\tval = `00${val.substring(2)}`\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid hexadecimal escape sequence')\n\treturn String.fromCharCode(val)\n}\n\nconst efEscape = (string) => {\n\t// Split strings\n\tconst splitArr = string.split(doubleChar)\n\tconst escaped = []\n\n\t// Escape all known escape characters\n\tfor (let i of splitArr) {\n\t\tconst escapedStr = i\n\t\t\t.replace(oct, O2C)\n\t\t\t.replace(ucp, UC2C)\n\t\t\t.replace(uni, U2C)\n\t\t\t.replace(hex, X2C)\n\t\t\t.replace(b, '\\b')\n\t\t\t.replace(t, '\\t')\n\t\t\t.replace(n, '\\n')\n\t\t\t.replace(v, '\\v')\n\t\t\t.replace(f, '\\f')\n\t\t\t.replace(r, '\\r')\n\t\t\t// Remove all useless escape characters\n\t\t\t.replace(esc, '')\n\t\tescaped.push(escapedStr)\n\t}\n\t// Return escaped string\n\treturn escaped.join(char)\n}\n\nconst checkEscape = string => string[string.length - 1] === char\n\nconst splitWith = (string, char) => {\n\tconst splitArr = string.split(char)\n\tconst escapedSplit = []\n\tlet escaped = false\n\tfor (let i of splitArr) {\n\t\tif (escaped) escapedSplit[escapedSplit.length - 1] += `${char}${i}`\n\t\telse escapedSplit.push(i)\n\t\tescaped = checkEscape(i)\n\t}\n\treturn escapedSplit\n}\n\nconst splitBy = (string, char) => {\n\tconst splitArr = string.split(doubleChar)\n\tconst escaped = splitWith(splitArr.shift(), char)\n\tfor (let i of splitArr) {\n\t\tconst escapedSplit = splitWith(i, char)\n\t\tescaped[escaped.length - 1] += `${doubleChar}${escapedSplit.shift()}`\n\t\tescaped.push(...escapedSplit)\n\t}\n\treturn escaped\n}\n\nexport { efEscape, splitBy }\n","import { efEscape, splitBy } from './escape-parser.js'\n\nconst typeSymbols = '>#%@.-+'\nconst reserved = [\n\t'$ctx', '$refs', '$data', '$methods', '$mount', '$umount', '$subscribe', '$unsubscribe', '$update',\n\t'$dispatch', '$emit', '$on', '$off', '$destroy', '__DIRECTMOUNT__'\n]\nconst mustache = /\\{\\{.+?\\}\\}/g\nconst spaceIndent = /^(\\t*)( *).*/\nconst hashref = /#([^}]|}[^}])*$/\n\nconst getErrorMsg = (msg, line = -2) => `Failed to parse eft template: ${msg}. at line ${line + 1}`\n\nconst isEmpty = string => !string.replace(/\\s/, '')\n\nconst checkValidType = obj => ['number', 'boolean', 'string'].indexOf(typeof obj) > -1\n\nconst ESCAPE = (string) => {\n\tif (!string) return [string, false]\n\ttry {\n\t\tconst parsed = JSON.parse(string)\n\t\tif (['number', 'boolean'].indexOf(typeof parsed) === -1) return [efEscape(string), true]\n\t\treturn [parsed, false]\n\t} catch (e) {\n\t\treturn [efEscape(string), true]\n\t}\n}\n\nconst getOffset = (string, parsingInfo) => {\n\tif (parsingInfo.offset !== null) return\n\tparsingInfo.offset = string.match(/\\s*/)[0]\n\tif (parsingInfo.offset) parsingInfo.offsetReg = parsingInfo.offset\n}\n\nconst removeOffset = (string, parsingInfo, i) => {\n\tif (parsingInfo.offsetReg) {\n\t\tlet removed = false\n\t\tstring = string.replace(parsingInfo.offsetReg, () => {\n\t\t\tremoved = true\n\t\t\treturn ''\n\t\t})\n\t\tif (!removed) throw new SyntaxError(getErrorMsg(`Expected indent to be grater than 0 and less than ${parsingInfo.prevDepth + 1}, but got -1`, i))\n\t}\n\treturn string\n}\n\nconst getIndent = (string, parsingInfo) => {\n\tif (parsingInfo.indentReg) return\n\tconst spaces = string.match(spaceIndent)[2]\n\tif (spaces) {\n\t\tparsingInfo.indentReg = new RegExp(spaces, 'g')\n\t}\n}\n\nconst getDepth = (string, parsingInfo, i) => {\n\tlet depth = 0\n\tif (parsingInfo.indentReg) string = string.replace(/^\\s*/, str => str.replace(parsingInfo.indentReg, '\\t'))\n\tconst content = string.replace(/^\\t*/, (str) => {\n\t\tdepth = str.length\n\t\treturn ''\n\t})\n\tif ((/^\\s/).test(content)) throw new SyntaxError(getErrorMsg('Bad indent', i))\n\treturn { depth, content }\n}\n\nconst resolveDepth = (ast, depth) => {\n\tlet currentNode = ast\n\tfor (let i = 0; i < depth; i++) currentNode = currentNode[currentNode.length - 1]\n\treturn currentNode\n}\n\nconst splitDefault = (string) => {\n\tstring = string.slice(2, string.length - 2)\n\tconst [_path, ..._default] = splitBy(string, '=')\n\tconst pathArr = splitBy(_path.trim(), '.').map(efEscape)\n\tconst [defaultVal, escaped] = ESCAPE(_default.join('=').trim())\n\tif (checkValidType(defaultVal) && (escaped || (!escaped && defaultVal !== ''))) return [pathArr, defaultVal]\n\treturn [pathArr]\n}\n\nconst splitLiterals = (string) => {\n\tconst strs = string.split(mustache)\n\tif (strs.length === 1) return ESCAPE(string)[0]\n\tconst tmpl = []\n\tif (strs.length === 2 && !strs[0] && !strs[1]) tmpl.push(0)\n\telse tmpl.push(strs.map(efEscape))\n\tconst mustaches = string.match(mustache)\n\tif (mustaches) tmpl.push(...mustaches.map(splitDefault))\n\treturn tmpl\n}\n\nconst pushStr = (textArr, str) => {\n\tif (str) textArr.push(str)\n}\n\nconst parseText = (string) => {\n\tconst result = splitLiterals(string)\n\tif (checkValidType(result)) return [`${result}`]\n\tconst [strs, ...exprs] = result\n\tconst textArr = []\n\tfor (let i = 0; i < exprs.length; i++) {\n\t\tpushStr(textArr, strs[i])\n\t\ttextArr.push(exprs[i])\n\t}\n\tpushStr(textArr, strs[strs.length - 1])\n\treturn textArr\n}\n\nconst dotToSpace = val => val.replace(/\\./g, ' ')\n\nconst parseTag = (string) => {\n\tconst tagInfo = {}\n\tconst [tag, ...content] = splitBy(string.replace(hashref, (val) => {\n\t\ttagInfo.ref = val.slice(1)\n\t\treturn ''\n\t}), '.')\n\ttagInfo.tag = efEscape(tag)\n\ttagInfo.class = splitLiterals(content.join('.'))\n\tif (typeof tagInfo.class === 'string') tagInfo.class = dotToSpace(tagInfo.class).trim()\n\telse if (tagInfo.class[0]) tagInfo.class[0] = tagInfo.class[0].map(dotToSpace)\n\treturn tagInfo\n}\n\nconst parseNodeAttrs = (string) => {\n\tconst splitted = splitBy(string, '=')\n\treturn {\n\t\tname: efEscape(splitted.shift().trim()),\n\t\tvalue: splitLiterals(splitted.join('=').trim())\n\t}\n}\n\nconst parseNodeProps = (string) => {\n\tconst splitted = splitBy(string, '=')\n\treturn {\n\t\tpropPath: splitBy(splitted.shift().trim(), '.').map(efEscape),\n\t\tvalue: splitLiterals(splitted.join('=').trim())\n\t}\n}\n\nconst parseEvent = (string) => {\n\tconst splitted = splitBy(string, '=')\n\treturn {\n\t\tname: splitted.shift().trim(),\n\t\tvalue: splitted.join('=').trim()\n\t}\n}\n\nconst setOption = (options, option) => {\n\tswitch (option) {\n\t\tcase 'stop': {\n\t\t\toptions.s = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'stopImmediate': {\n\t\t\toptions.i = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'prevent': {\n\t\t\toptions.p = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'shift': {\n\t\t\toptions.h = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'alt': {\n\t\t\toptions.a = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'ctrl': {\n\t\t\toptions.c = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'meta': {\n\t\t\toptions.t = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'capture': {\n\t\t\toptions.u = 1\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\tconsole.warn(`Abandoned unsupported eft event option '${option}'.`)\n\t\t}\n\t}\n}\n\nconst getOption = (options, keys, option) => {\n\tconst keyCode = parseInt(option, 10)\n\tif (isNaN(keyCode)) return setOption(options, efEscape(option))\n\tkeys.push(keyCode)\n}\n\nconst getEventOptions = (name) => {\n\tconst options = {}\n\tconst keys = []\n\tconst [listener, ...ops] = splitBy(name, '.')\n\toptions.l = efEscape(listener)\n\tfor (let i of ops) getOption(options, keys, i)\n\tif (keys.length > 0) options.k = keys\n\treturn options\n}\n\nconst splitEvents = (string) => {\n\tconst [name, ...value] = splitBy(string, ':')\n\tconst content = value.join(':')\n\tconst escapedName = efEscape(name.trim())\n\tif (content) return [escapedName, splitLiterals(content)]\n\treturn [escapedName]\n}\n\nconst parseLine = ({line, ast, parsingInfo, i}) => {\n\tif (isEmpty(line)) return\n\tgetOffset(line, parsingInfo)\n\n\tconst trimmedLine = removeOffset(line, parsingInfo, i)\n\tgetIndent(trimmedLine, parsingInfo)\n\n\tlet { depth, content } = getDepth(trimmedLine, parsingInfo, i)\n\n\tif (content) {\n\t\tif (depth < 0 || depth - parsingInfo.prevDepth > 1 || (depth - parsingInfo.prevDepth === 1 && ['comment', 'tag'].indexOf(parsingInfo.prevType) === -1) || (parsingInfo.prevType !== 'comment' && depth === 0 && parsingInfo.topExists)) throw new SyntaxError(getErrorMsg(`Expected indent to be grater than 0 and less than ${parsingInfo.prevDepth + 1}, but got ${depth}`, i))\n\t\tconst type = content[0]\n\t\tcontent = content.slice(1)\n\t\tif (!content && typeSymbols.indexOf(type) >= 0) throw new SyntaxError(getErrorMsg('Empty content', i))\n\t\t// Jump back to upper level\n\t\tif (depth < parsingInfo.prevDepth || (depth === parsingInfo.prevDepth && parsingInfo.prevType === 'tag')) parsingInfo.currentNode = resolveDepth(ast, depth)\n\t\tparsingInfo.prevDepth = depth\n\n\t\tswitch (type) {\n\t\t\tcase '>': {\n\t\t\t\tconst info = parseTag(content)\n\t\t\t\tconst newNode = [{\n\t\t\t\t\tt: info.tag\n\t\t\t\t}]\n\t\t\t\tif (info.class) {\n\t\t\t\t\tnewNode[0].a = {}\n\t\t\t\t\tnewNode[0].a.class = info.class\n\t\t\t\t}\n\t\t\t\tif (info.ref) newNode[0].r = info.ref\n\t\t\t\tparsingInfo.currentNode.push(newNode)\n\t\t\t\tparsingInfo.currentNode = newNode\n\t\t\t\tparsingInfo.prevType = 'tag'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '#': {\n\t\t\t\tconst { name, value } = parseNodeAttrs(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].a) parsingInfo.currentNode[0].a = {}\n\t\t\t\tparsingInfo.currentNode[0].a[name] = value\n\t\t\t\tparsingInfo.prevType = 'attr'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '%': {\n\t\t\t\tconst { propPath, value } = parseNodeProps(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].p) parsingInfo.currentNode[0].p = []\n\t\t\t\tparsingInfo.currentNode[0].p.push([propPath, value])\n\t\t\t\tparsingInfo.prevType = 'prop'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '@': {\n\t\t\t\tconst { name, value } = parseEvent(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].e) parsingInfo.currentNode[0].e = []\n\t\t\t\tconst options = getEventOptions(name)\n\t\t\t\tconst [method, _value] = splitEvents(value)\n\t\t\t\toptions.m = method\n\t\t\t\tif (_value) options.v = _value\n\t\t\t\tparsingInfo.currentNode[0].e.push(options)\n\t\t\t\tparsingInfo.prevType = 'event'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '.': {\n\t\t\t\tparsingInfo.currentNode.push(...parseText(content))\n\t\t\t\tparsingInfo.prevType = 'text'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '|': {\n\t\t\t\tif (parsingInfo.currentNode.length > 1) content = `\\n${content}`\n\t\t\t\tparsingInfo.currentNode.push(...parseText(content))\n\t\t\t\tparsingInfo.prevType = 'multiline-text'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '-': {\n\t\t\t\tif (reserved.indexOf(content) !== -1) throw new SyntaxError(getErrorMsg(`Reserved name '${content}' should not be used`, i))\n\t\t\t\tparsingInfo.currentNode.push({\n\t\t\t\t\tn: content,\n\t\t\t\t\tt: 0\n\t\t\t\t})\n\t\t\t\tparsingInfo.prevType = 'node'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '+': {\n\t\t\t\tparsingInfo.currentNode.push({\n\t\t\t\t\tn: content,\n\t\t\t\t\tt: 1\n\t\t\t\t})\n\t\t\t\tparsingInfo.prevType = 'list'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tparsingInfo.prevType = 'comment'\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst parseEft = (template) => {\n\tif (!template) throw new TypeError(getErrorMsg('Template required, but nothing given'))\n\tconst tplType = typeof template\n\tif (tplType !== 'string') throw new TypeError(getErrorMsg(`Expected a string, but got a(n) ${tplType}`))\n\tconst lines = template.split(/\\r?\\n/)\n\tconst ast = [{t: 0}]\n\tconst parsingInfo = {\n\t\tindentReg: null,\n\t\tprevDepth: 0,\n\t\toffset: null,\n\t\toffsetReg: null,\n\t\tprevType: 'comment',\n\t\tcurrentNode: ast,\n\t\ttopExists: false,\n\t}\n\tfor (let i = 0; i < lines.length; i++) parseLine({line: lines[i], ast, parsingInfo, i})\n\n\tif (ast.length <= 1) throw new SyntaxError(getErrorMsg('Nothing to be parsed', lines.length - 1))\n\tif (ast.length === 2 && Array.isArray(ast[1]) && Object.hasOwnProperty.call(ast[1][0], 't')) return ast[1]\n\treturn ast\n}\n\nexport default parseEft\n","const typeOf = (obj) => {\n\tif (Array.isArray(obj)) return 'array'\n\treturn typeof obj\n}\n\nexport default typeOf\n","const mixStr = (strs, ...exprs) => {\n\tlet string = ''\n\tfor (let i = 0; i < exprs.length; i++) {\n\t\tif (typeof exprs[i] === 'undefined') string += strs[i]\n\t\telse string += (strs[i] + exprs[i])\n\t}\n\treturn string + strs[strs.length - 1]\n}\n\nconst getVal = ({dataNode, _key}) => {\n\tconst data = dataNode[_key]\n\tif (typeof data === 'undefined') return ''\n\treturn data\n}\n\nconst mixVal = (strs, ...exprs) => {\n\tif (!strs) return getVal(exprs[0])\n\tconst template = [strs]\n\ttemplate.push(...exprs.map(getVal))\n\treturn mixStr(...template)\n}\n\nexport { mixStr, mixVal }\n","const proto = Array.prototype\n\nconst ARR = {\n\tcopy(arr) {\n\t\treturn proto.slice.call(arr, 0)\n\t},\n\tempty(arr) {\n\t\tarr.length = 0\n\t\treturn arr\n\t},\n\tequals(left, right) {\n\t\tif (!Array.isArray(right)) return false\n\t\tif (left === right) return true\n\t\tif (left.length !== right.length) return false\n\t\tfor (let i = 0, l = left.length; i < l; i++) {\n\t\t\tif (left[i] !== right[i]) return false\n\t\t}\n\t\treturn true\n\t},\n\tpop(arr) {\n\t\treturn proto.pop.call(arr)\n\t},\n\tpush(arr, ...items) {\n\t\treturn proto.push.apply(arr, items)\n\t},\n\tremove(arr, item) {\n\t\tconst index = proto.indexOf.call(arr, item)\n\t\tif (index > -1) {\n\t\t\tproto.splice.call(arr, index, 1)\n\t\t\treturn item\n\t\t}\n\t},\n\treverse(arr) {\n\t\treturn proto.reverse.call(arr)\n\t},\n\trightUnique(arr) {\n\t\tconst newArr = []\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tfor (let j = i + 1; j < arr.length; j++) if (arr[i] === arr[j]) j = i += 1\n\t\t\tnewArr.push(arr[i])\n\t\t}\n\t\treturn newArr\n\t},\n\tshift(arr) {\n\t\treturn proto.shift.call(arr)\n\t},\n\tslice(arr, index, length) {\n\t\treturn proto.slice.call(arr, index, length)\n\t},\n\tsort(arr, fn) {\n\t\treturn proto.sort.call(arr, fn)\n\t},\n\tsplice(arr, ...args) {\n\t\treturn proto.splice.apply(arr, args)\n\t},\n\tunshift(arr, ...items) {\n\t\treturn proto.unshift.apply(arr, items)\n\t}\n}\n\nif (window.Set && Array.from) ARR.unique = arr => Array.from(new Set(arr))\nelse ARR.unique = ARR.rightUnique\n\nexport default ARR\n","import ARR from './utils/array-helper.js'\n\nconst modificationQueue = []\nconst domQueue = []\nconst userQueue = []\nlet count = 0\n\nconst queue = handlers => modificationQueue.push(...handlers)\nconst queueDom = handler => domQueue.push(handler)\nconst onNextRender = handler => userQueue.push(handler)\n\n/**\n * @returns {boolean} - Is render paused\n */\nconst isPaused = () => count > 0\n\n/**\n * Add 1 to render count down.\n * When countdown becomes 0, render will be triggered.\n * @returns {number} - Render count down\n */\nconst inform = () => {\n\tcount += 1\n\treturn count\n}\n\nconst execModifications = () => {\n\tif (modificationQueue.length === 0) return\n\tconst renderQueue = ARR.unique(modificationQueue)\n\tARR.empty(modificationQueue)\n\tfor (let i of renderQueue) i()\n}\n\nconst execDomModifications = () => {\n\tif (domQueue.length === 0) return\n\tconst domRenderQueue = ARR.rightUnique(domQueue)\n\tARR.empty(domQueue)\n\tfor (let i of domRenderQueue) i()\n}\n\nconst execUserQueue = () => {\n\tif (userQueue.length === 0) return\n\tconst userFnQueue = ARR.unique(userQueue)\n\tARR.empty(userQueue)\n\tfor (let i of userFnQueue) i()\n}\n\n/**\n * Minus 1 to render count down.\n * When countdown becomes 0, render will be triggered.\n * @param {boolean} immediate - Render immediately, will force countdown become 0\n * @returns {number} - Render count down\n */\nconst exec = (immediate) => {\n\tif (!immediate && (count -= 1) > 0) return count\n\tcount = 0\n\n\tif (modificationQueue.length > 0) execModifications()\n\n\tif (domQueue.length > 0) execDomModifications()\n\n\t// Execute user queue after DOM update\n\tif (userQueue.length > 0) setTimeout(execUserQueue, 0)\n\n\treturn count\n}\n\n/**\n * Run callback in a safe way, without worrying about unhandled errors may break rendering.\n * @param {Function} cb - Callback function to be executed safly\n * @returns {(void|Error)} - Error that happens when executing callback\n */\nconst bundle = (cb) => {\n\tinform()\n\ttry {\n\t\t// eslint-disable-next-line callback-return\n\t\texec(cb(inform, exec))\n\t} catch (e) {\n\t\texec()\n\t\treturn e\n\t}\n}\n\nexport { queue, queueDom, onNextRender, inform, exec, bundle, isPaused }\n","// Enough for ef's usage, so no need for a full polyfill\nconst legacyAssign = (ee, er) => {\n\tfor (let i in er) ee[i] = er[i]\n\treturn ee\n}\n\nconst assign = Object.assign || legacyAssign\n\nexport {assign, legacyAssign}\n","import {inform, exec} from './render-queue.js'\nimport {assign} from './utils/polyfills.js'\n\nconst resolveAllPath = ({_path, handlers, subscribers, innerData}) => {\n\tfor (let i of _path) {\n\t\tif (!handlers[i]) handlers[i] = {}\n\t\tif (!subscribers[i]) subscribers[i] = {}\n\t\tif (!innerData[i]) innerData[i] = {}\n\t\thandlers = handlers[i]\n\t\tsubscribers = subscribers[i]\n\t\tinnerData = innerData[i]\n\t}\n\treturn {\n\t\thandlerNode: handlers,\n\t\tsubscriberNode: subscribers,\n\t\tdataNode: innerData\n\t}\n}\n\n// Workaround for the third bug of buble:\n// https://github.com/bublejs/buble/issues/106\nconst defineNode = (key, obj) => {\n\tconst node = {}\n\tObject.defineProperty(obj, key, {\n\t\tget() {\n\t\t\treturn node\n\t\t},\n\t\tset(data) {\n\t\t\tinform()\n\t\t\tassign(node, data)\n\t\t\texec()\n\t\t},\n\t\tconfigurable: false,\n\t\tenumerable: true\n\t})\n\treturn node\n}\n\nconst resolveReactivePath = (_path, obj) => {\n\tfor (let i of _path) {\n\t\tif (obj[i]) obj = obj[i]\n\t\telse obj = defineNode(i, obj)\n\t}\n\treturn obj\n}\n\nconst resolvePath = (_path, obj) => {\n\tfor (let i of _path) {\n\t\tif (!obj[i]) obj[i] = {}\n\t\tobj = obj[i]\n\t}\n\treturn obj\n}\n\nconst resolve = ({_path, _key, data, handlers, subscribers, innerData}) => {\n\tconst parentNode = resolveReactivePath(_path, data)\n\tconst {handlerNode, subscriberNode, dataNode} = resolveAllPath({_path, handlers, subscribers, innerData})\n\tif (!handlerNode[_key]) handlerNode[_key] = []\n\tif (!subscriberNode[_key]) subscriberNode[_key] = []\n\t/* eslint no-undefined: \"off\" */\n\tif (!Object.prototype.hasOwnProperty.call(dataNode, _key)) dataNode[_key] = undefined\n\treturn {parentNode, handlerNode: handlerNode[_key], subscriberNode: subscriberNode[_key], dataNode}\n}\n\nconst resolveSubscriber = (_path, subscribers) => {\n\tconst pathArr = _path.split('.')\n\tconst key = pathArr.pop()\n\tfor (let i of pathArr) {\n\t\tif (!subscribers[i]) subscribers[i] = {}\n\t\tsubscribers = subscribers[i]\n\t}\n\treturn subscribers[key]\n}\n\nexport {resolveReactivePath, resolvePath, resolve, resolveSubscriber}\n","/* eslint-disable no-self-compare */\nconst isnan = obj => obj !== obj\n\nexport default isnan\n","import {resolve} from './resolver.js'\nimport {inform, exec, queue} from './render-queue.js'\nimport ARR from './utils/array-helper.js'\nimport isnan from './utils/isnan.js'\nimport dbg from './utils/debug.js'\n\nconst initDataNode = ({parentNode, dataNode, handlerNode, subscriberNode, ctx, _key}) => {\n\tlet subscriberExecuting = false\n\tObject.defineProperty(parentNode, _key, {\n\t\tget() {\n\t\t\treturn dataNode[_key]\n\t\t},\n\t\tset(value) {\n\t\t\tif (subscriberExecuting) return\n\t\t\t// Comparing NaN is like eating a cake and suddenly encounter a grain of sand\n\t\t\tif (dataNode[_key] === value || (isnan(dataNode[_key]) && isnan(value))) return\n\t\t\tdataNode[_key] = value\n\t\t\tinform()\n\t\t\tqueue(handlerNode)\n\t\t\texec()\n\t\t\tif (subscriberNode.length > 0) {\n\t\t\t\tsubscriberExecuting = true\n\t\t\t\tinform()\n\t\t\t\ttry {\n\t\t\t\t\tfor (const subscriber of subscriberNode) subscriber({state: ctx.state, value})\n\t\t\t\t} catch (e) {\n\t\t\t\t\tdbg.error('Error caught when executing subscribers:\\n', e)\n\t\t\t\t}\n\t\t\t\texec()\n\t\t\t\tsubscriberExecuting = false\n\t\t\t}\n\t\t},\n\t\tenumerable: true\n\t})\n}\n\nconst initBinding = ({bind, ctx, handlers, subscribers, innerData}) => {\n\tconst _path = ARR.copy(bind[0])\n\tconst _key = _path.pop()\n\tconst {parentNode, handlerNode, subscriberNode, dataNode} = resolve({\n\t\t_path,\n\t\t_key,\n\t\tdata: ctx.data,\n\t\thandlers,\n\t\tsubscribers,\n\t\tinnerData\n\t})\n\n\t// Initlize data binding node if not exist\n\tif (!Object.prototype.hasOwnProperty.call(parentNode, _key)) initDataNode({parentNode, dataNode, handlerNode, subscriberNode, ctx, _key})\n\t// Update default value\n\t// bind[1] is the default value for this node\n\tif (bind.length > 1) parentNode[_key] = bind[1]\n\n\treturn {dataNode, parentNode, handlerNode, subscriberNode, _key}\n}\n\nexport default initBinding\n","const isInstance = (er, ee) => er.constructor === ee\n\nexport default isInstance\n","import ARR from './array-helper.js'\n\n// https://github.com/bublejs/buble/issues/197\nconst enumerableFalse = (classObj, keys) => {\n\tfor (let i of keys) Object.defineProperty(classObj.prototype, i, {enumerable: false})\n\treturn classObj\n}\n\n// https://github.com/bublejs/buble/issues/131\nconst prepareArgs = (self, node) => {\n\tconst args = ARR.copy(self)\n\tARR.unshift(args, node)\n\treturn args\n}\n\nexport {enumerableFalse, prepareArgs}\n","// Wrap console functions for `[EF]` perfix\nconst strTpl = '[EF] %s'\nconst dbg = {\n\tlog: console.log.bind(console, strTpl),\n\tinfo: console.info.bind(console, strTpl),\n\twarn: console.warn.bind(console, strTpl),\n\terror: console.error.bind(console, strTpl)\n}\n\nexport default dbg\n","const shared = {}\n\nexport default shared\n","// import ARR from './array-helper.js'\nimport isInstance from './fast-instance-of.js'\nimport {prepareArgs} from './buble-fix.js'\nimport dbg from './debug.js'\nimport {inform, exec} from '../render-queue.js'\n\nimport shared from './global-shared.js'\n\nconst proto = Node.prototype\n\n// Will require a weakmap polyfill for IE10 and below\nconst mountingPointStore = new WeakMap()\n\nconst DOM = {}\n\nconst EFFragment = class extends Array {\n\tappendTo(node) {\n\t\tDOM.append.apply(null, prepareArgs(this, node))\n\t}\n\t// insertBeforeTo(node) {\n\t// \tconst args = ARR.copy(this)\n\t// \tARR.unshift(args, node)\n\t// \tDOM.before.apply(null, prepareArgs(this, node))\n\t// }\n\t// insertAfterTo(node) {\n\t// \tconst args = ARR.copy(this)\n\t// \tARR.unshift(args, node)\n\t// \tDOM.after.apply(null, prepareArgs(this, node))\n\t// }\n\tremove() {\n\t\tfor (let i of this) DOM.remove(i)\n\t}\n}\n\nDOM.before = (node, ...nodes) => {\n\tconst tempFragment = document.createDocumentFragment()\n\tinform()\n\tfor (let i of nodes) {\n\t\tif (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target: tempFragment})\n\t\t} else if (isInstance(i, EFFragment)) i.appendTo(tempFragment)\n\t\telse proto.appendChild.call(tempFragment, i)\n\t}\n\tproto.insertBefore.call(node.parentNode, tempFragment, node)\n\texec()\n}\n\nDOM.after = (node, ...nodes) => {\n\tconst tempFragment = document.createDocumentFragment()\n\tinform()\n\tfor (let i of nodes) {\n\t\tif (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target: tempFragment})\n\t\t} else if (isInstance(i, EFFragment)) i.appendTo(tempFragment)\n\t\telse proto.appendChild.call(tempFragment, i)\n\t}\n\tif (node.nextSibling) proto.insertBefore.call(node.parentNode, tempFragment, node.nextSibling)\n\telse proto.appendChild.call(node.parentNode, tempFragment)\n\texec()\n}\n\nconst handleMountingPoint = (mountingPoint, tempFragment) => {\n\tconst {node} = mountingPoint\n\tif (!node) return\n\tif (Array.isArray(node) && node.clear) {\n\t\tfor (let j of node) {\n\t\t\tconst {element, placeholder} = j.$ctx.nodeInfo\n\t\t\tDOM.append(tempFragment, element, placeholder)\n\t\t}\n\t} else {\n\t\tconst {element, placeholder} = node.$ctx.nodeInfo\n\t\tDOM.append(tempFragment, element, placeholder)\n\t}\n}\n\nDOM.append = (node, ...nodes) => {\n\t// Handle fragment\n\tif (isInstance(node, EFFragment)) return node.push(...nodes)\n\t// Handle EFComponent\n\tif (node instanceof shared.EFBaseComponent) {\n\t\tif (!(Array.isArray(node.children) && node.children.clear)) {\n\t\t\tif (process.env.NODE_ENV !== 'production') dbg.warn(node, 'has no `children` list mount point! Child nodes are all ignored!')\n\t\t\treturn\n\t\t}\n\n\t\tinform()\n\t\tfor (let i of nodes) {\n\t\t\ti = new shared.toEFComponent(i)\n\t\t\tnode.children.push(i)\n\t\t}\n\t\texec()\n\n\t\treturn\n\t}\n\n\tif ([1,9,11].indexOf(node.nodeType) === -1) return\n\tconst tempFragment = document.createDocumentFragment()\n\tfor (let i of nodes) {\n\t\tif (isInstance(i, EFFragment)) i.appendTo(tempFragment)\n\t\telse if (i instanceof Node) {\n\t\t\tproto.appendChild.call(tempFragment, i)\n\t\t\tconst mountingPoint = mountingPointStore.get(i)\n\t\t\tif (mountingPoint) handleMountingPoint(mountingPoint, tempFragment)\n\t\t} else if (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target: tempFragment})\n\t\t}\n\t}\n\tproto.appendChild.call(node, tempFragment)\n}\n\nDOM.remove = (node) => {\n\tif (isInstance(node, EFFragment)) node.remove()\n\telse if (node instanceof shared.EFBaseComponent) node.$umount()\n\telse proto.removeChild.call(node.parentNode, node)\n}\n\n// addClass(node, className) {\n// \tconst classes = className.split(' ')\n// \tnode.classList.add(...classes)\n// },\n\n// removeClass(node, className) {\n// \tconst classes = className.split(' ')\n// \tnode.classList.remove(...classes)\n// },\n\n// toggleClass(node, className) {\n// \tconst classes = className.split(' ')\n// \tconst classArr = node.className.split(' ')\n// \tfor (let i of classes) {\n// \t\tconst classIndex = classArr.indexOf(i)\n// \t\tif (classIndex > -1) {\n// \t\t\tclassArr.splice(classIndex, 1)\n// \t\t} else {\n// \t\t\tclassArr.push(i)\n// \t\t}\n// \t}\n// \tnode.className = classArr.join(' ').trim()\n// },\n\n// replaceWith(node, newNode) {\n// \tconst parent = node.parentNode\n// \tif (parent) proto.replaceChild.call(parent, newNode, node)\n// },\n\n// swap(node, newNode) {\n// \tconst nodeParent = node.parentNode\n// \tconst newNodeParent = newNode.parentNode\n// \tconst nodeSibling = node.nextSibling\n// \tconst newNodeSibling = newNode.nextSibling\n// \tif (nodeParent && newNodeParent) {\n// \t\tproto.insertBefore.call(nodeParent, newNode, nodeSibling)\n// \t\tproto.insertBefore.call(newNodeParent, node, newNodeSibling)\n// \t}\n// },\n\n// prepend(node, ...nodes) {\n// \tif ([1,9,11].indexOf(node.nodeType) === -1) {\n// \t\treturn\n// \t}\n// \tconst tempFragment = document.createDocumentFragment()\n// \tnodes.reverse()\n// \tfor (let i of nodes) {\n// \t\tproto.appendChild.call(tempFragment, i)\n// \t}\n// \tif (node.firstChild) {\n// \t\tproto.insertBefore.call(node, tempFragment, node.firstChild)\n// \t} else {\n// \t\tproto.appendChild.call(node, tempFragment)\n// \t}\n// },\n\n// appendTo(node, newNode) {\n// \tproto.appendChild.call(newNode, node)\n// },\n\n// prependTo(node, newNode) {\n// \tif (newNode.firstChild) {\n// \t\tproto.insertBefore.call(newNode, node, node.firstChild)\n// \t} else {\n// \t\tproto.appendChild.call(newNode, node)\n// \t}\n// },\n\n// empty(node) {\n// \tnode.innerHTML = ''\n// },\n\nexport {DOM, EFFragment, mountingPointStore}\n","/**\n * @typedef {{bubbles: boolean, cancelable: boolean}} EFEventOptions\n */\n\n/* Get new events that works in all target browsers\n * though a little bit old-fashioned\n */\nconst getEvent = (name, {bubbles, cancelable} = {\n\tbubbles: false,\n\tcancelable: false\n}) => {\n\tconst event = document.createEvent('CustomEvent')\n\tevent.initEvent(name, bubbles, cancelable)\n\treturn event\n}\n\nexport default getEvent\n","import initBinding from './binding.js'\nimport {queue, inform, exec} from './render-queue.js'\nimport {resolvePath} from './resolver.js'\nimport ARR from './utils/array-helper.js'\nimport {EFFragment} from './utils/dom-helper.js'\nimport getEvent from './utils/event-helper.js'\nimport {mixVal} from './utils/literals-mix.js'\nimport dbg from './utils/debug.js'\n\nconst typeValid = obj => ['number', 'boolean', 'string'].indexOf(typeof obj) > -1\n\n// SVG/MathML tags w/ xlink attributes require specific namespace to work properly\nconst svgNS = 'http://www.w3.org/2000/svg'\nconst mathNS = 'http://www.w3.org/1998/Math/MathML'\nconst xlinkNS = 'http://www.w3.org/1999/xlink'\nconst createByTag = ({tagName, tagContent, attrs, svg}) => {\n\tconst tagType = typeof tagContent\n\n\tif (tagType === 'string') {\n\t\t// Then SVG\n\t\tif (svg) return document.createElementNS(svgNS, tagContent)\n\t\t// Then MathML\n\t\tif (tagContent.toLowerCase() === 'math') return document.createElementNS(mathNS, tagContent)\n\t\t// Then custom basic elements\n\t\tif (tagName === tagContent && attrs && attrs.is && typeof attrs.is === 'string') return document.createElement(tagContent, {is: attrs.is})\n\t\t// Then basic HTMLElements\n\t\treturn document.createElement(tagContent)\n\t}\n\n\t// Then custom component or class based custom component\n\tif (tagType === 'function') return new tagContent()\n\n\t// Then overriden basic element\n\treturn document.createElement(tagContent.tag || tagName, {is: tagContent.is})\n}\n\nconst getElement = ({tagName, tagContent, attrs, ref, refs, svg}) => {\n\tconst element = createByTag({tagName, tagContent, attrs, svg})\n\tif (ref) Object.defineProperty(refs, ref, {\n\t\tvalue: element,\n\t\tenumerable: true\n\t})\n\treturn element\n}\n\nconst regTmpl = ({val, ctx, handlers, subscribers, innerData, handler}) => {\n\tif (Array.isArray(val)) {\n\t\tconst [strs, ...exprs] = val\n\t\tconst tmpl = [strs]\n\n\t\tconst _handler = () => handler(mixVal(...tmpl))\n\n\t\ttmpl.push(...exprs.map((item) => {\n\t\t\tconst {dataNode, handlerNode, _key} = initBinding({bind: item, ctx, handlers, subscribers, innerData})\n\t\t\thandlerNode.push(_handler)\n\t\t\treturn {dataNode, _key}\n\t\t}))\n\n\t\treturn _handler\n\t}\n\treturn () => val\n}\n\nconst addValListener = ({ctx, handlers, subscribers, innerData, element, key, expr, custom}) => {\n\tconst addListener = custom && '$on' || 'addEventListener'\n\tconst dispatch = custom && '$dispatch' || 'dispatchEvent'\n\tconst {parentNode, _key} = initBinding({bind: expr, ctx, handlers, subscribers, innerData})\n\tconst _update = () => {\n\t\tinform()\n\t\tif (custom) parentNode[_key] = element.$data.value\n\t\telse parentNode[_key] = element.value\n\t\texec()\n\t}\n\tif (key === 'value') {\n\t\t// Listen to input, keyup and change events in order to work in most browsers.\n\t\telement[addListener]('input', _update, true)\n\t\telement[addListener]('keyup', _update, true)\n\t\telement[addListener]('change', _update, true)\n\t\t// // Remove keyup and change listener if browser supports input event correctly\n\t\t// const removeListener = () => {\n\t\t// \telement.removeEventListener('input', removeListener, true)\n\t\t// \telement.removeEventListener('keyup', _update, true)\n\t\t// \telement.removeEventListener('change', _update, true)\n\t\t// }\n\t\t// element[addListener]('input', removeListener, true)\n\t} else {\n\t\telement[addListener]('change', () => {\n\t\t\t// Trigger change to the element it-self\n\t\t\telement[dispatch](getEvent('ef-change-event'), {bubbles: true, canceoable: false})\n\t\t\tif (element.tagName === 'INPUT' && element.type === 'radio' && element.name !== '') {\n\t\t\t\t// Trigger change to the the same named radios\n\t\t\t\tconst radios = document.querySelectorAll(`input[name=${element.name}][type=radio]`)\n\t\t\t\tif (radios) {\n\t\t\t\t\tconst selected = ARR.copy(radios)\n\t\t\t\t\tARR.remove(selected, element)\n\n\t\t\t\t\t/* Event triggering could cause unwanted render triggers\n\t\t\t\t\t * no better ways came up at the moment\n\t\t\t\t\t */\n\t\t\t\t\tfor (let i of selected) i.dispatchEvent(getEvent('ef-change-event'))\n\t\t\t\t}\n\t\t\t}\n\t\t}, true)\n\t\t// Use custom event to avoid loops and conflicts\n\t\telement[addListener]('ef-change-event', () => {\n\t\t\tinform()\n\t\t\tif (custom) parentNode[_key] = element.$data.checked\n\t\t\telse parentNode[_key] = element.checked\n\t\t\texec()\n\t\t})\n\t}\n}\n\nconst getAttrHandler = (element, key, custom) => {\n\t// Pass directly to custom component\n\tif (custom) return (val) => {\n\t\telement[key] = val\n\t}\n\n\t// Beautify class name\n\tif (key === 'class') return (val) => {\n\t\tval = `${val}`.replace(/\\s+/g, ' ').trim()\n\t\t// Remove attribute when value is empty\n\t\tif (!val) return element.removeAttribute(key)\n\t\telement.setAttribute(key, val)\n\t}\n\n\t// Handle xlink namespace\n\tif (key.indexOf('xlink:') === 0) return (val) => {\n\t\t// Remove attribute when value is empty\n\t\tif (val === '') return element.removeAttributeNS(xlinkNS, key)\n\t\telement.setAttributeNS(xlinkNS, key, val)\n\t}\n\n\treturn (val) => {\n\t\t// Remove attribute when value is empty\n\t\tif (val === '') return element.removeAttribute(key)\n\t\telement.setAttribute(key, val)\n\t}\n}\n\nconst addAttr = ({element, attr, key, ctx, handlers, subscribers, innerData, custom}) => {\n\tif (typeValid(attr)) {\n\t\tif (custom) {\n\t\t\tif (attr === '') element[key] = true\n\t\t\telse element[key] = attr\n\t\t\treturn\n\t\t}\n\t\t// Handle xlink namespace\n\t\tif (key.indexOf('xlink:') === 0) return element.setAttributeNS(xlinkNS, key, attr)\n\t\treturn element.setAttribute(key, attr)\n\t}\n\n\tconst handler = getAttrHandler(element, key, custom)\n\tqueue([regTmpl({val: attr, ctx, handlers, subscribers, innerData, handler})])\n}\n\nconst addProp = ({element, propPath, value, ctx, handlers, subscribers, innerData, custom}) => {\n\tconst keyPath = ARR.copy(propPath)\n\tconst lastKey = keyPath.pop()\n\tif (custom) keyPath.unshift('$data')\n\tconst lastNode = resolvePath(keyPath, element)\n\tif (typeValid(value)) lastNode[lastKey] = value\n\telse {\n\t\tconst handler = (val) => {\n\t\t\tlastNode[lastKey] = val\n\t\t}\n\t\tconst _handler = regTmpl({val: value, ctx, handlers, subscribers, innerData, handler})\n\t\tif (propPath.length === 1 && ((lastKey === 'value' ||\n\t\t\tlastKey === 'checked')) &&\n\t\t\t!value[0]) addValListener({ctx, handlers, subscribers, innerData, element, key: lastKey, expr: value[1], custom})\n\t\tqueue([_handler])\n\t}\n}\n\n\nconst rawHandler = val => val\n\nconst addEvent = ({element, event, ctx, handlers, subscribers, innerData, custom}) => {\n\tconst addListener = custom && '$on' || 'addEventListener'\n\n\t/*\n\t *  l: listener                 : string\n\t *  m: method                   : string\n\t *  s: stopPropagation          : number/undefined\n\t *  i: stopImmediatePropagation : number/undefined\n\t *  p: preventDefault           : number/undefined\n\t *  h: shiftKey                 : number/undefined\n\t *  a: altKey                   : number/undefined\n\t *  c: ctrlKey                  : number/undefined\n\t *  t: metaKey                  : number/undefined\n\t *  u: capture                  : number/undefined\n\t *  k: keyCodes                 : array/undefined\n\t *  v: value                    : string/array/undefined\n\t */\n\tconst {l, m, s, i, p, h, a, c, t, u, k, v} = event\n\tconst _handler = regTmpl({val: v, ctx, handlers, subscribers, innerData, handler: rawHandler})\n\n\telement[addListener](l, (e) => {\n\t\tif (!!h !== !!e.shiftKey ||\n\t\t\t!!a !== !!e.altKey ||\n\t\t\t!!c !== !!e.ctrlKey ||\n\t\t\t!!t !== !!e.metaKey ||\n\t\t\t(k && k.indexOf(e.which) === -1)) return\n\t\tif (s) e.stopPropagation()\n\t\tif (i) e.stopImmediatePropagation()\n\t\tif (p) e.preventDefault()\n\t\tif (ctx.methods[m]) ctx.methods[m]({e, value: _handler(), state: ctx.state})\n\t\telse if (process.env.NODE_ENV !== 'production') dbg.warn(`Method named '${m}' not found! Value been passed is:`, _handler())\n\t}, !!u)\n}\n\nconst createElement = ({info, ctx, innerData, refs, handlers, subscribers, svg, fragment, custom}) => {\n\tif (fragment) return new EFFragment()\n\n\t/*\n\t *  t: tag       : class | string | int, 0 means fragment\n\t *  a: attr      : object\n\t *  p: prop      : object\n\t *  e: event     : array\n\t *  r: reference : string\n\t */\n\tconst {t, a, p, e, r} = info\n\tconst tagName = t\n\tconst tagContent = ctx.scope[t] || t\n\tconst element = getElement({tagName, tagContent, attrs: a, ref: r, refs, svg})\n\tif (a) for (let key in a) addAttr({element, custom, attr: a[key], key, ctx, handlers, subscribers, innerData})\n\tif (p) for (let [propPath, value] of p) addProp({element, custom, value, propPath, ctx, handlers, subscribers, innerData})\n\tif (e) for (let event of e) addEvent({element, custom, event, ctx, handlers, subscribers, innerData})\n\treturn element\n}\n\nexport default createElement\n","import createElement from './element-creator.js'\nimport {queue, inform, exec} from './render-queue.js'\nimport {DOM, mountingPointStore} from './utils/dom-helper.js'\nimport defineArr from './utils/dom-arr-helper.js'\nimport ARR from './utils/array-helper.js'\nimport typeOf from './utils/type-of.js'\nimport initBinding from './binding.js'\nimport mountOptions from '../mount-options.js'\n\nimport shared from './utils/global-shared.js'\n\nconst nullComponent = Object.create(null)\n\nconst checkDestroyed = (state) => {\n\tif (!state.$ctx) throw new Error('[EF] This component has been destroyed!')\n}\n\nconst bindTextNode = ({node, ctx, handlers, subscribers, innerData, element}) => {\n\t// Data binding text node\n\tconst textNode = document.createTextNode('')\n\tconst { dataNode, handlerNode, _key } = initBinding({bind: node, ctx, handlers, subscribers, innerData})\n\tconst handler = () => {\n\t\tconst value = dataNode[_key]\n\t\tif (typeof value === 'undefined') {\n\t\t\ttextNode.textContent = ''\n\t\t\treturn\n\t\t}\n\t\ttextNode.textContent = value\n\t}\n\thandlerNode.push(handler)\n\tqueue([handler])\n\n\t// Append element to the component\n\tDOM.append(element, textNode)\n}\n\nconst updateMountingNode = ({ctx, key, value}) => {\n\tconst {children} = ctx\n\tconst child = children[key]\n\tconst {anchor, node} = child\n\tif (node === value) return\n\n\tvalue = shared.toEFComponent(value)\n\n\tinform()\n\t// Update component\n\tif (node) {\n\t\tif (value === nullComponent) value = null\n\t\telse node.$umount()\n\t}\n\t// Update stored value\n\tchild.node = value\n\tif (value) value.$mount({target: anchor, parent: ctx.state, option: mountOptions.BEFORE, key})\n\texec()\n}\n\nconst updateMountingList = ({ctx, key, value}) => {\n\tconst {children} = ctx\n\tconst {anchor, node} = children[key]\n\tif (ARR.equals(node, value)) return\n\tif (value) value = ARR.copy(value)\n\telse value = []\n\tconst fragment = document.createDocumentFragment()\n\t// Update components\n\tinform()\n\tif (node) {\n\t\tnode.clear()\n\t\tfor (let item of value) {\n\t\t\titem = shared.toEFComponent(item)\n\n\t\t\tif (item.$ctx.nodeInfo.parent) item.$umount()\n\t\t\tDOM.append(fragment, item.$mount({parent: ctx.state, key}))\n\t\t}\n\t} else for (let item of value) DOM.append(fragment, item.$mount({parent: ctx.state, key}))\n\t// Update stored value\n\tnode.length = 0\n\tARR.push(node, ...value)\n\t// Append to current component\n\tDOM.after(anchor, fragment)\n\texec()\n}\n\nconst mountingPointUpdaters = [\n\tupdateMountingNode,\n\tupdateMountingList\n]\n\nconst applyMountingPoint = (type, key, tpl) => {\n\tObject.defineProperty(tpl.prototype, key, {\n\t\tget() {\n\t\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\t\treturn this.$ctx.children[key].node\n\t\t},\n\t\tset(value) {\n\t\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\t\tconst ctx = this.$ctx\n\t\t\tmountingPointUpdaters[type]({ctx, key, value})\n\t\t},\n\t\tenumerable: true\n\t})\n}\n\nconst bindMountingNode = ({ctx, key, anchor}) => {\n\tconst {children, isFragment} = ctx\n\tchildren[key] = {anchor}\n\tif (isFragment) {\n\t\tDOM.append(ctx.safeZone, anchor)\n\t\tmountingPointStore.set(anchor, children[key])\n\t}\n}\n\nconst bindMountingList = ({ctx, key, anchor}) => {\n\tconst {children, isFragment} = ctx\n\tchildren[key] = {\n\t\tnode: defineArr([], {ctx, key, anchor}),\n\t\tanchor\n\t}\n\tif (isFragment) {\n\t\tDOM.append(ctx.safeZone, anchor)\n\t\tmountingPointStore.set(anchor, children[key])\n\t}\n}\n\n// Walk through the AST to perform proper actions\nconst resolveAST = ({node, nodeType, element, ctx, innerData, refs, handlers, subscribers, svg, create}) => {\n\tif (node instanceof Node) {\n\t\tDOM.append(element, node)\n\t\treturn\n\t}\n\tswitch (nodeType) {\n\t\t// Static text node\n\t\tcase 'string': {\n\t\t\tDOM.append(element, document.createTextNode(node))\n\t\t\tbreak\n\t\t}\n\t\t// Child element or a dynamic text node\n\t\tcase 'array': {\n\t\t\t// Recursive call for child element\n\t\t\tif (typeOf(node[0]) === 'object') DOM.append(element, create({node, ctx, innerData, refs, handlers, subscribers, svg}))\n\t\t\t// Dynamic text node\n\t\t\telse bindTextNode({node, ctx, handlers, subscribers, innerData, element})\n\t\t\tbreak\n\t\t}\n\t\t// Mounting points\n\t\tcase 'object': {\n\t\t\tconst anchor = document.createTextNode('')\n\t\t\t// Single node mounting point\n\t\t\tif (node.t === 0) bindMountingNode({ctx, key: node.n, anchor})\n\t\t\t// Multi node mounting point\n\t\t\telse bindMountingList({ctx, key: node.n, anchor})\n\t\t\t// Append anchor\n\t\t\tif (process.env.NODE_ENV !== 'production') DOM.append(element, document.createComment(`EF MOUNTING POINT '${node.n}' START`))\n\t\t\tDOM.append(element, anchor)\n\t\t\tif (process.env.NODE_ENV !== 'production') DOM.append(element, document.createComment(`EF MOUNTING POINT '${node.n}' END`))\n\t\t\tbreak\n\t\t}\n\t\tdefault:\n\t}\n}\n\n// Create elements based on description from AST\nconst create = ({node, ctx, innerData, refs, handlers, subscribers, svg}) => {\n\tconst [info, ...childNodes] = node\n\tconst fragment = info.t === 0\n\tconst custom = Object.isPrototypeOf.call(shared.EFBaseComponent, ctx.scope[info.t] || info.t)\n\t// Enter SVG mode\n\tif (!fragment && !svg && !custom && info.t.toLowerCase() === 'svg') svg = true\n\t// First create an element according to the description\n\tconst element = createElement({info, ctx, innerData, refs, handlers, subscribers, svg, fragment, custom})\n\tif (fragment && process.env.NODE_ENV !== 'production') element.push(document.createComment('EF FRAGMENT START'))\n\n\t// Leave SVG mode if tag is `foreignObject`\n\tif (svg && info.t.toLowerCase() === 'foreignobject') svg = false\n\n\t// Append child nodes\n\tfor (let node of childNodes) {\n\t\tif (node instanceof shared.EFBaseComponent) node.$mount({target: element})\n\t\telse resolveAST({node, nodeType: typeOf(node), element, ctx, innerData, refs, handlers, subscribers, svg, create})\n\t}\n\tif (fragment && process.env.NODE_ENV !== 'production') element.push(document.createComment('EF FRAGMENT END'))\n\n\treturn element\n}\n\nexport {create, nullComponent, checkDestroyed, applyMountingPoint}\n","import {DOM} from './dom-helper.js'\nimport ARR from './array-helper.js'\nimport {inform, exec} from '../render-queue.js'\nimport shared from './global-shared.js'\n\nconst DOMARR = {\n\tempty() {\n\t\tinform()\n\t\tfor (let i of ARR.copy(this)) i.$destroy()\n\t\texec()\n\t\tARR.empty(this)\n\t},\n\tclear() {\n\t\tinform()\n\t\tfor (let i of ARR.copy(this)) i.$umount()\n\t\texec()\n\t\tARR.empty(this)\n\t},\n\tpop() {\n\t\tif (this.length === 0) return\n\t\tconst poped = ARR.pop(this)\n\t\tpoped.$umount()\n\t\treturn poped\n\t},\n\tpush({ctx, key, anchor}, ...items) {\n\t\titems = items.map(shared.toEFComponent)\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of items) ARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\tif (this.length === 0) DOM.after(anchor, ...elements)\n\t\telse DOM.after(this[this.length - 1].$ctx.nodeInfo.placeholder, ...elements)\n\t\texec()\n\t\treturn ARR.push(this, ...items)\n\t},\n\tremove(item) {\n\t\tif (this.indexOf(item) === -1) return\n\t\titem.$umount()\n\t\treturn item\n\t},\n\treverse({ctx, key, anchor}) {\n\t\tif (this.length === 0) return this\n\t\tconst tempArr = ARR.copy(this)\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i = tempArr.length - 1; i >= 0; i--) {\n\t\t\ttempArr[i].$umount()\n\t\t\tARR.push(elements, tempArr[i].$mount({parent: ctx.state, key}))\n\t\t}\n\t\tARR.push(this, ...ARR.reverse(tempArr))\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn this\n\t},\n\tshift() {\n\t\tif (this.length === 0) return\n\t\tconst shifted = ARR.shift(this)\n\t\tshifted.$umount()\n\t\treturn shifted\n\t},\n\tsort({ctx, key, anchor}, fn) {\n\t\tif (this.length === 0) return this\n\t\tconst sorted = ARR.copy(ARR.sort(this, fn))\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of sorted) {\n\t\t\ti.$umount()\n\t\t\tARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\t}\n\t\tARR.push(this, ...sorted)\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn this\n\t},\n\tsplice(...args) {\n\t\tif (this.length === 0) return this\n\t\tconst spliced = ARR.splice(ARR.copy(this), ...args)\n\t\tinform()\n\t\tfor (let i of spliced) i.$umount()\n\t\texec()\n\t\treturn spliced\n\t},\n\tunshift({ctx, key, anchor}, ...items) {\n\t\tif (this.length === 0) return this.push(...items).length\n\t\titems = items.map(shared.toEFComponent)\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of items) ARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn ARR.unshift(this, ...items)\n\t}\n}\n\nconst defineArr = (arr, info) => {\n\tObject.defineProperties(arr, {\n\t\tempty: {value: DOMARR.empty},\n\t\tclear: {value: DOMARR.clear},\n\t\tpop: {value: DOMARR.pop},\n\t\tpush: {value: DOMARR.push.bind(arr, info)},\n\t\tremove: {value: DOMARR.remove},\n\t\treverse: {value: DOMARR.reverse.bind(arr, info)},\n\t\tshift: {value: DOMARR.shift},\n\t\tsort: {value: DOMARR.sort.bind(arr, info)},\n\t\tsplice: {value: DOMARR.splice},\n\t\tunshift: {value: DOMARR.unshift.bind(arr, info)}\n\t})\n\treturn arr\n}\n\nexport default defineArr\n","const getGetter = ({base, key}, {checkTrue, get, set}) => {\n\tif (get) {\n\t\tif (!set) throw new Error('Setter must be defined when getter exists')\n\t\treturn get\n\t}\n\n\tif (checkTrue) return function() {\n\t\treturn checkTrue(base(this)[key], this)\n\t}\n\n\treturn function() {\n\t\treturn base(this)[key]\n\t}\n}\n\nconst getSetter = ({base, key}, {checkTrue, trueVal, falseVal, get, set}) => {\n\tif (set) {\n\t\tif (!get) throw new Error('Getter must be defined when setter exists')\n\t\treturn set\n\t}\n\n\tif (checkTrue) return function(val) {\n\t\tconst baseNode = base(this)\n\t\tconst _trueVal = trueVal\n\t\tconst _falseVal = falseVal\n\n\t\tif (typeof trueVal !== 'function') trueVal = () => _trueVal\n\t\tif (typeof falseVal !== 'function') falseVal = () => _falseVal\n\n\t\tif (val) baseNode[key] = trueVal(this)\n\t\telse baseNode[key] = falseVal(this)\n\t}\n\n\treturn function(val) {\n\t\tbase(this)[key] = val\n\t}\n}\n\nconst defaultRoot = state => state.$data\nconst getBase = (root) => {\n\tif (!root) return defaultRoot\n\tif (typeof root === 'function') return root\n\tif (typeof root === 'string') root = root.split('.')\n\treturn (base) => {\n\t\tfor (let key of root) base = base[key]\n\t\treturn base\n\t}\n}\n\n/**\n * @typedef {import('./renderer.js').EFBaseClass} EFBaseClass\n */\n\n/**\n * Definition of an attribute mapping\n * @typedef {Object} AttrDef\n * @property {string=} key - key to be accessed on base, default to `attr`\n * @property {Function=} base - a function that returns the base of the key, default returns $data\n * @property {bool=} checkTrue - a function returns true or false based on input value\n * @property {*=} trueVal - value when true, only used when checkTrue is set\n * @property {*=} falseVal - value when false, only used when checkTrue is set\n * @property {Function=} get - getter, will ignore all other settings except set\n * @property {Function=} set - setter, will ignore all other settings except get\n */\n\n/**\n * Data to attribute mapping helper\n * @template {EFBaseClass} T\n * @param {T} tpl - Component class to be mapped\n * @param {Object.<string,AttrDef>} attrMap - Attributes to be mapped\n * @returns {T} - Mapped component class\n */\nconst mapAttrs = (tpl, attrMap) => {\n\tfor (let attr in attrMap) {\n\t\tconst options = attrMap[attr]\n\n\t\tconst base = getBase(options.base)\n\t\tconst key = options.key || attr\n\n\t\tconst basicProperty = {base, key}\n\n\t\tconst get = getGetter(basicProperty, options)\n\t\tconst set = getSetter(basicProperty, options)\n\n\t\tObject.defineProperty(tpl.prototype, attr, {\n\t\t\tget,\n\t\t\tset,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false\n\t\t})\n\t}\n\n\treturn tpl\n}\n\nexport default mapAttrs\n","/**\n * @typedef {string} EFMountOption\n * @typedef {{BEFORE: EFMountOption, AFTER: EFMountOption, APPEND: EFMountOption, REPLACE: EFMountOption}} EFMountConfig\n */\n\n/**\n * @type {EFMountConfig}\n */\nconst mountOptions = {\n\tBEFORE: 'before',\n\tAFTER: 'after',\n\tAPPEND: 'append',\n\tREPLACE: 'replace'\n}\n\nexport default mountOptions\n","import {create, nullComponent, checkDestroyed} from './creator.js'\nimport initBinding from './binding.js'\nimport {queueDom, inform, exec} from './render-queue.js'\nimport {resolveSubscriber} from './resolver.js'\nimport mapAttrs from './map-attrs.js'\nimport {DOM, EFFragment, mountingPointStore} from './utils/dom-helper.js'\nimport ARR from './utils/array-helper.js'\nimport {assign, legacyAssign} from './utils/polyfills.js'\nimport isInstance from './utils/fast-instance-of.js'\nimport typeOf from './utils/type-of.js'\nimport {enumerableFalse} from './utils/buble-fix.js'\nimport dbg from './utils/debug.js'\nimport getEvent from './utils/event-helper.js'\nimport mountOptions from '../mount-options.js'\n\nimport shared from './utils/global-shared.js'\n\nconst unsubscribe = (pathStr, fn, subscribers) => {\n\tconst subscriberNode = resolveSubscriber(pathStr, subscribers)\n\tARR.remove(subscriberNode, fn)\n}\n\n/**\n * @typedef {Array} EFAST\n * @typedef {Object.<string,EFBaseComponent>} EFTemplateScope\n */\n\n/**\n * @typedef {Object} EFSubscriberHandlerArg\n * @property {EFBaseComponent} ctx - The component who calls the handler\n * @property {*} value - Value been subscribed\n */\n\n/**\n * @event Event\n */\n\n/**\n * @typedef {Object} EFEventHandlerArg\n * @property {EFBaseComponent} ctx - The component who calls the handler\n * @property {*} value - Value been passed to the event handler\n * @property {Event} event - Event object that has been triggered\n */\n\n/**\n * @typedef {Function} EFSubscriberHandlerMethod\n * @param {EFSubscriberHandlerArg} arg\n * @returns {void}\n */\n\n/**\n * @typedef {Function} EFEventHandlerMethod\n * @param {EFEventHandlerArg} arg\n * @returns {void}\n */\n\n/**\n * The very basic ef component\n * @class EFBaseComponent\n * @param {EFAST} ast - ast for the component\n * @param {EFTemplateScope} scope - scope which contains custom components\n * @private {Object} $ctx - Inner component data, DO NOT TOUCH\n * @property {Object} $data - Data on component\n * @property {Object.<string,EFEventHandlerMethod>} $methods - Methods on component\n * @property {Object.<string,(EFBaseComponent|Node)>} $refs - References on component\n */\nconst EFBaseComponent = class {\n\n\t/**\n\t * Create an EFBaseComponent with ef AST\n\t * @param {EFAST} ast - ast for the component\n\t * @param {EFTemplateScope=} scope - scope which contains custom components\n\t */\n\tconstructor(ast, scope = {}) {\n\t\tconst children = {}\n\t\tconst refs = {}\n\t\tconst data = {}\n\t\tconst innerData = {}\n\t\tconst methods = {}\n\t\tconst handlers = {}\n\t\tconst subscribers = {}\n\t\tconst nodeInfo = {\n\t\t\tplaceholder: null,\n\t\t\treplace: [],\n\t\t\tparent: null,\n\t\t\tkey: null\n\t\t}\n\n\t\t/* Detatched components will be put in the safe zone.\n\t\t * Split safe zone to each component in order to make\n\t\t * the component memory recycleable when lost reference\n\t\t */\n\t\tconst safeZone = document.createDocumentFragment()\n\n\t\tif (process.env.NODE_ENV === 'production') nodeInfo.placeholder = document.createTextNode('')\n\t\telse nodeInfo.placeholder = document.createComment('EF COMPONENT PLACEHOLDER')\n\n\t\tconst mount = () => {\n\t\t\tif (nodeInfo.replace.length > 0) {\n\t\t\t\tfor (let i of nodeInfo.replace) DOM.remove(i)\n\t\t\t\tARR.empty(nodeInfo.replace)\n\t\t\t}\n\t\t\tDOM.before(nodeInfo.placeholder, nodeInfo.element)\n\t\t}\n\n\t\tconst ctx = {\n\t\t\tscope, mount, refs, data, innerData, methods,\n\t\t\thandlers, subscribers, nodeInfo, safeZone,\n\t\t\tchildren, state: this, isFragment: ast[0].t === 0\n\t\t}\n\n\t\tObject.defineProperty(this, '$ctx', {\n\t\t\tvalue: ctx,\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true\n\t\t})\n\n\t\tinform()\n\n\t\tnodeInfo.element = create({node: ast, ctx, innerData, refs, handlers, subscribers, svg: false})\n\t\tDOM.append(safeZone, nodeInfo.placeholder)\n\t\tqueueDom(mount)\n\t\texec()\n\t}\n\n\tget $data() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.data\n\t}\n\n\tset $data(newData) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tinform()\n\t\tassign(this.$ctx.data, newData)\n\t\texec()\n\t}\n\n\tget $methods() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.methods\n\t}\n\n\n\tset $methods(newMethods) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tthis.$ctx.methods = newMethods\n\t}\n\n\tget $refs() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.refs\n\t}\n\n\t/**\n\t * @typedef {import('../mount-options.js').EFMountConfig} EFMountConfig\n\t */\n\n\t/**\n\t * Mount component to a specitic position\n\t * @param {EFMountConfig} config - Mount contigurations\n\t * @returns {number} - Render count down\n\t */\n\t$mount({target, option, parent, key}) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, mount } = this.$ctx\n\t\tif (typeof target === 'string') target = document.querySelector(target)\n\n\t\tinform()\n\t\tif (nodeInfo.parent) {\n\t\t\tthis.$umount()\n\t\t\tif (process.env.NODE_ENV !== 'production') dbg.warn('Component detached from previous mounting point.')\n\t\t}\n\n\t\tif (!parent) parent = target\n\t\tif (!key) key = '__DIRECTMOUNT__'\n\t\tnodeInfo.parent = parent\n\t\tnodeInfo.key = key\n\t\tqueueDom(mount)\n\n\t\tif (!target) {\n\t\t\texec()\n\t\t\treturn nodeInfo.placeholder\n\t\t}\n\n\t\tswitch (option) {\n\t\t\tcase mountOptions.BEFORE: {\n\t\t\t\tDOM.before(target, nodeInfo.placeholder)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase mountOptions.AFTER: {\n\t\t\t\tDOM.after(target, nodeInfo.placeholder)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase mountOptions.REPLACE: {\n\t\t\t\tDOM.before(target, nodeInfo.placeholder)\n\t\t\t\tnodeInfo.replace.push(target)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase mountOptions.APPEND:\n\t\t\tdefault: {\n\t\t\t\t// Parent is EFFragment should only happen when using jsx\n\t\t\t\tif (isInstance(parent, EFFragment)) DOM.append(target, nodeInfo.element)\n\t\t\t\telse DOM.append(target, nodeInfo.placeholder)\n\t\t\t}\n\t\t}\n\t\treturn exec()\n\t}\n\n\t/**\n\t * @returns {number} - Render count down\n\t */\n\t$umount() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, safeZone, mount } = this.$ctx\n\t\tconst { parent, key } = nodeInfo\n\t\tnodeInfo.parent = null\n\t\tnodeInfo.key = null\n\n\t\tinform()\n\t\tif (parent) {\n\t\t\tif (key !== '__DIRECTMOUNT__') {\n\t\t\t\tif (parent[key]) {\n\t\t\t\t\tif (Array.isArray(parent[key])) {\n\t\t\t\t\t\t// Remove self from parent list mounting point\n\t\t\t\t\t\tARR.remove(parent[key], this)\n\t\t\t\t\t} else parent[key] = nullComponent\n\t\t\t\t}\n\t\t\t// Else Remove elements from fragment parent\n\t\t\t} else if (isInstance(parent, EFFragment)) ARR.remove(parent.$ctx.nodeInfo.element, nodeInfo.element)\n\t\t}\n\t\tDOM.append(safeZone, nodeInfo.placeholder)\n\t\tqueueDom(mount)\n\t\treturn exec()\n\t}\n\n\t/**\n\t * Subscribe a value's changing\n\t * @param {string} pathStr - Path string to the subribed value based on `$data`, splitted by `.`\n\t * @param {EFSubscriberHandlerMethod} subscriber - Subscription event handler to be added\n\t * @returns {void}\n\t */\n\t$subscribe(pathStr, subscriber) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst ctx = this.$ctx\n\t\tconst { handlers, subscribers, innerData } = ctx\n\t\tconst _path = pathStr.split('.')\n\t\tconst { dataNode, subscriberNode, _key } = initBinding({bind: [_path], ctx, handlers, subscribers, innerData})\n\t\tinform()\n\t\t// Execute the subscriber function immediately\n\t\ttry {\n\t\t\tsubscriber({state: this, value: dataNode[_key]})\n\t\t\t// Put the subscriber inside the subscriberNode\n\t\t\tsubscriberNode.push(subscriber)\n\t\t} catch (e) {\n\t\t\tdbg.error('Error caught when registering subscriber:\\n', e)\n\t\t}\n\t\texec()\n\t}\n\n\t/**\n\t * Unsubscribe a value's changing\n\t * @param {string} pathStr - Path string to the subribed value based on `$data`, splitted by `.`\n\t * @param {EFSubscriberHandlerMethod} subscriber - Subscription event handler to be removed\n\t * @returns {void}\n\t */\n\t$unsubscribe(pathStr, subscriber) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { subscribers } = this.$ctx\n\t\tunsubscribe(pathStr, subscriber, subscribers)\n\t}\n\n\t/**\n\t * Update the component's state with a new state\n\t * @param {Object} newState - New state to be set on this component\n\t * @returns {void}\n\t */\n\t$update(newState) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tinform()\n\t\tlegacyAssign(this, newState)\n\t\texec()\n\t}\n\n\t/**\n\t * Fire a custom event using an Event object on this component\n\t * @param {Event} event - Event object to be dispatched on this component\n\t * @returns {*} - Same as the return of Node.dispatchEvent\n\t */\n\t$dispatch(event) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.nodeInfo.placeholder.dispatchEvent(event)\n\t}\n\n\t/**\n\t * @typedef {import('./utils/event-helper.js').EFEventOptions} EFEventOptions\n\t */\n\n\t/**\n\t * Fire a custom event using event name on this component\n\t * @param {string} eventName - Name of the custom event\n\t * @param {EFEventOptions} options - Event Options\n\t * @returns {*} - Same as the return of Node.dispatchEvent\n\t */\n\t$emit(eventName, options) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$dispatch(getEvent(eventName, options))\n\t}\n\n\t/**\n\t * Add custom event listener on this component\n\t * @param {...*} args - Same as Node.addEventListener\n\t * @returns {*} - Same as the return of Node.addEventListener\n\t */\n\t$on(...args) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.nodeInfo.placeholder.addEventListener(...args)\n\t}\n\n\t/**\n\t * Remove custom event listener on this component\n\t * @param {...*} args - Same as Node.removeEventListener\n\t * @returns {*} - Same as the return of Node.removeEventListener\n\t */\n\t$off(...args) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.nodeInfo.placeholder.removeEventListener(...args)\n\t}\n\n\t/**\n\t * Destroy this component\n\t * @returns {number} - Render count down\n\t */\n\t$destroy() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, isFragment, children } = this.$ctx\n\t\tinform()\n\t\tthis.$umount()\n\t\tif (isFragment) for (let i in children) mountingPointStore.delete(children[i].anchor)\n\t\t// Detatch all mounted components\n\t\tfor (let i in this) {\n\t\t\tif (typeOf(this[i]) === 'array') this[i].clear()\n\t\t\telse this[i] = null\n\t\t}\n\t\t// Remove context\n\t\tdelete this.$ctx\n\t\t// Push DOM removement operation to query\n\t\tqueueDom(() => {\n\t\t\tDOM.remove(nodeInfo.element)\n\t\t\tDOM.remove(nodeInfo.placeholder)\n\t\t})\n\t\t// Render\n\t\treturn exec()\n\t}\n}\n\n/**\n * @typedef {typeof EFBaseComponent} EFBaseClass\n */\n\nconst fragmentAST = [{t: 0}]\n\n/**\n * ef component node wrapper\n * Better using this than Fragments if wrapping only HTML elements.\n * @class EFNodeWrapper\n * @extends EFBaseComponent\n * @param {...Node} nodes - Nodes to be wrapped\n * @property {Array<Node>} - Nodes that are wrapped\n */\nconst EFNodeWrapper = class extends EFBaseComponent {\n\n\t/**\n\t * Wrap given nodes into an ef component\n\t * @param  {...Node} nodes - Nodes to be wrapped\n\t */\n\tconstructor(...nodes) {\n\t\tsuper(fragmentAST)\n\t\t// Use parens to bypass ESLint's semicolon check\n\t\t// Semi is needed for preventing Buble's bug\n\t\t;(this).$ctx.nodeInfo.element.push(...nodes)\n\t\tthis.$ctx.elements = nodes\n\t}\n\n\tget $el() {\n\t\treturn this.$ctx.elements\n\t}\n}\n\n/**\n * Component fragment wrapper\n * @class Fragment\n * @extends EFBaseComponent\n * @param {...*} children - Things to be wrapped into an ef component\n */\nconst Fragment = class extends EFBaseComponent {\n\tconstructor(...children) {\n\t\tsuper([{t: 0}, ...children])\n\t}\n}\n\nconst textFragmentAst = [{t: 0},[['text']]]\n\n/**\n * ef component text wrapper\n * @class EFTextFragment\n * @extends EFBaseComponent\n * @param {string} text - String to be wrapped\n * @property {string} text - Text on the fragment component\n */\nconst EFTextFragment = class extends EFBaseComponent {\n\n\t/**\n\t * Wrap given text into an ef component\n\t * @param {string} text - String to be wrapped\n\t */\n\tconstructor(text) {\n\t\tinform()\n\t\tsuper(textFragmentAst)\n\t\tthis.text = text\n\t\texec()\n\t}\n}\nmapAttrs(EFTextFragment, {text: {}})\n\nenumerableFalse(EFBaseComponent, ['$mount', '$umount', '$subscribe', '$unsubscribe', '$update', '$dispatch', '$emit', '$on', '$off', '$destroy'])\nenumerableFalse(EFNodeWrapper, ['$el'])\n\n/**\n * Transform almost anyting into ef component\n * @template {value} T\n * @param {T} value - Things to be transformed into ef component\n * @returns {(EFNodeWrapper|EFTextFragment|T)} - Wrapped component or value it self if not supports converting\n */\nconst toEFComponent = (value) => {\n\tif (value === null || typeof value === 'undefined' || value instanceof EFBaseComponent) return value\n\n\tif (value !== nullComponent) {\n\t\tif (value instanceof Node) return new EFNodeWrapper(value)\n\t\telse if (typeof value === 'string') return new EFTextFragment(value)\n\t\telse return new EFTextFragment(JSON.stringify(value))\n\t}\n}\n\nshared.EFBaseComponent = EFBaseComponent\nshared.toEFComponent = toEFComponent\n\nexport {EFBaseComponent, EFNodeWrapper, EFTextFragment, Fragment, toEFComponent}\n","import {EFBaseComponent, Fragment, toEFComponent} from './renderer.js'\nimport {assign} from './utils/polyfills.js'\n\nconst flatten = (prev, item) => {\n\tif (Array.isArray(item)) prev.push(...item.map(toEFComponent))\n\telse prev.push(toEFComponent(item))\n\n\treturn prev\n}\n\n/**\n * @typedef {import('./renderer.js').EFBaseComponent} EFBaseComponent\n * @typedef {import('./renderer.js').EFBaseClass} EFBaseClass\n */\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Create ef component from JSX\n * @template {EFBaseClass} T\n * @param {(string|T)} tag - JSX tag\n * @param {Object.<string,*>} attrs - JSX attributes\n * @param  {...*} children - JSX children\n * @returns {(EFBaseComponent|T extends {new (...args: any): infer R} ? R : never)} ef component created from JSX\n */\nconst createElement = (tag, attrs, ...children) => {\n\t// Create special component for fragment\n\tif (tag === Fragment) return new Fragment(...children)\n\n\t// Create an instance if tag is an ef class\n\tif (Object.isPrototypeOf.call(EFBaseComponent, tag)) {\n\t\tif (children.length <= 0) return new tag(attrs)\n\t\treturn new tag(assign({children: children.reduce(flatten, [])}, attrs || {}))\n\t}\n\n\t// Else return the generated basic component\n\t// Transform all label only attributes to ef-supported style\n\tconst transformedAttrs = assign({}, attrs)\n\tfor (let i in transformedAttrs) {\n\t\tif (transformedAttrs[i] === true) transformedAttrs[i] = ''\n\t}\n\n\treturn new EFBaseComponent([\n\t\t{\n\t\t\tt: tag,\n\t\t\ta: transformedAttrs\n\t\t},\n\t\t...children\n\t])\n}\n\nexport default createElement\n","// Import everything\nimport parse from './lib/parser.js'\nimport typeOf from 'ef-core/src/lib/utils/type-of.js'\nimport { mixStr } from 'ef-core/src/lib/utils/literals-mix.js'\nimport parseEft from 'eft-parser'\nimport { version } from '../package.json'\n// Import core components\nimport {\n\tcreate as createComponent,\n\tcreateElement,\n\tmapAttrs,\n\tEFNodeWrapper,\n\tEFTextFragment,\n\tFragment,\n\tscoped,\n\tonNextRender,\n\tinform,\n\texec,\n\tbundle,\n\tisPaused,\n\tmountOptions\n} from 'ef-core'\n\n// Set parser\nlet parser = parseEft\n\n/**\n * @typedef {import('ef-core/src/ef-core.js').EFMountOption} EFMountOption\n * @typedef {import('ef-core/src/ef-core.js').EFMountConfig} EFMountConfig\n * @typedef {import('ef-core/src/ef-core.js').EFAST} EFAST\n * @typedef {import('ef-core/src/ef-core.js').EFBaseClass} EFBaseClass\n * @typedef {import('ef-core/src/ef-core.js').EFEventHandlerArg} EFEventHandlerArg\n * @typedef {import('ef-core/src/ef-core.js').EFEventHandlerMethod} EFEventHandlerMethod\n * @typedef {import('ef-core/src/ef-core.js').EFSubscriberHandlerArg} EFSubscriberHandlerArg\n * @typedef {import('ef-core/src/ef-core.js').EFSubscriberHandlerMethod} EFSubscriberHandlerMethod\n * @typedef {import('ef-core/src/ef-core.js').EFTemplateScope} EFTemplateScope\n * @typedef {import('ef-core/src/ef-core.js').Fragment} Fragment\n * @typedef {import('ef-core/src/ef-core.js').EFNodeWrapper} EFNodeWrapper\n * @typedef {import('ef-core/src/ef-core.js').EFTextFragment} EFTextFragment\n * @typedef {import('ef-core/src/ef-core.js').EFEventOptions} EFEventOptions\n */\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Return a brand new class for the new component\n * @param {string|EFAST} value - Template or AST for the component\n */\nconst create = (value) => {\n\tconst valType = typeOf(value)\n\tif (valType === 'string') value = parse(value, parser)\n\telse if (valType !== 'array') throw new TypeError('Cannot create new component without proper template or AST!')\n\n\treturn createComponent(value)\n}\n\n/**\n * Change parser\n * @param {Function} newParser - Parser you want to change with\n * @returns {void}\n */\nconst setParser = (newParser) => {\n\tparser = newParser\n}\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Tagged template to quickly create an inline ef component class\n * @param {...*} args - String literal\n */\nconst t = (...args) => create(mixStr(...args))\n\nexport {\n\tt,\n\tcreate,\n\tcreateElement,\n\tmapAttrs,\n\tEFNodeWrapper,\n\tEFTextFragment,\n\tFragment,\n\tscoped,\n\tonNextRender,\n\tinform,\n\texec,\n\tbundle,\n\tisPaused,\n\tsetParser,\n\tparseEft,\n\tmountOptions,\n\tversion\n}\n\nif (process.env.NODE_ENV !== 'production') console.info(`[EF] ef.js v${version} initialized!`)\n","// Import everything\nimport {EFBaseComponent, EFNodeWrapper, EFTextFragment, Fragment, toEFComponent} from './lib/renderer.js'\nimport {applyMountingPoint} from './lib/creator.js'\nimport mountOptions from './mount-options.js'\nimport createElement from './lib/jsx-create-element.js'\nimport mapAttrs from './lib/map-attrs.js'\nimport {onNextRender, inform, exec, bundle, isPaused} from './lib/render-queue.js'\nimport dbg from './lib/utils/debug.js'\nimport typeOf from './lib/utils/type-of.js'\nimport scoped from './lib/utils/scoped-component.js'\nimport {version} from '../package.json'\n\n// Apply mounting point properties for classes\nconst applyMountingPoints = (node, tpl) => {\n\tconst nodeType = typeOf(node)\n\tswitch (nodeType) {\n\t\tcase 'array': {\n\t\t\tconst [info, ...childNodes] = node\n\t\t\tif (typeOf(info) === 'object') for (let i of childNodes) applyMountingPoints(i, tpl)\n\t\t\tbreak\n\t\t}\n\t\tcase 'object': {\n\t\t\tif (node.t > 1) throw new TypeError(`[EF] Not a standard ef.js AST: Unknown mounting point type '${node.t}'`)\n\t\t\tapplyMountingPoint(node.t, node.n, tpl)\n\t\t\tbreak\n\t\t}\n\t\tcase 'string': {\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\tthrow new TypeError(`[EF] Not a standard ef.js AST: Unknown node type '${nodeType}'`)\n\t\t}\n\t}\n}\n\n/**\n * @typedef {import('./mount-options.js').EFMountOption} EFMountOption\n * @typedef {import('./mount-options.js').EFMountConfig} EFMountConfig\n * @typedef {import('./lib/renderer.js').EFAST} EFAST\n * @typedef {import('./lib/renderer.js').EFBaseClass} EFBaseClass\n * @typedef {import('./lib/renderer.js').EFEventHandlerArg} EFEventHandlerArg\n * @typedef {import('./lib/renderer.js').EFEventHandlerMethod} EFEventHandlerMethod\n * @typedef {import('./lib/renderer.js').EFSubscriberHandlerArg} EFSubscriberHandlerArg\n * @typedef {import('./lib/renderer.js').EFSubscriberHandlerMethod} EFSubscriberHandlerMethod\n * @typedef {import('./lib/renderer.js').EFTemplateScope} EFTemplateScope\n * @typedef {import('./lib/renderer.js').Fragment} Fragment\n * @typedef {import('./lib/renderer.js').EFNodeWrapper} EFNodeWrapper\n * @typedef {import('./lib/renderer.js').EFTextFragment} EFTextFragment\n * @typedef {import('./lib/utils/event-helper.js').EFEventOptions} EFEventOptions\n */\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Create a brand new component class for the new component\n * @param {EFAST} ast - AST for the component\n */\nconst create = (ast) => {\n\n\t/**\n\t * The very basic component which users can use\n\t * @class EFComponent\n\t * @param {Object=} initState - Initial state for the component to create with\n\t * @param {EFTemplateScope=} scope - Scope for the component to render template with\n\t */\n\tconst EFComponent = class extends EFBaseComponent {\n\n\t\t/**\n\t\t * Create an EFComponent with initial state\n\t\t * @param {Object=} initState - Initial state for the component to create with\n\t\t * @param {EFTemplateScope=} scope - Scope for the component to render template with\n\t\t */\n\t\tconstructor(initState, scope) {\n\t\t\tinform()\n\t\t\tsuper(ast, scope)\n\t\t\tif (initState) this.$update(initState)\n\t\t\texec()\n\t\t}\n\t}\n\tapplyMountingPoints(ast, EFComponent)\n\n\t// Workaround for a bug of buble\n\t// https://github.com/bublejs/buble/issues/197\n\tObject.defineProperty(EFComponent.prototype, 'constructor', {enumerable: false})\n\treturn EFComponent\n}\n\nexport {\n\tcreate,\n\tmapAttrs,\n\tcreateElement,\n\tEFNodeWrapper,\n\tEFTextFragment,\n\tFragment,\n\ttoEFComponent,\n\tscoped,\n\tonNextRender,\n\tinform,\n\texec,\n\tbundle,\n\tisPaused,\n\tmountOptions,\n\tversion\n}\n\nif (process.env.NODE_ENV !== 'production') dbg.info(`ef-core v${version} initialized!`)\n","import eftParser from 'eft-parser'\n\nconst parse = (template, parser) => {\n\tif (!parser) parser = eftParser\n\treturn parser(template)\n}\n\nexport default parse\n","import {assign} from './polyfills.js'\n\n/**\n * @typedef {import('../renderer.js').EFBaseClass} EFBaseClass\n * @typedef {import('../renderer.js').EFTemplateScope} EFTemplateScope\n */\n\n/**\n * Attach a default scope to the component class\n * @template {component} T\n * @param {EFBaseClass} component - Component class to be scoped\n * @param {EFTemplateScope} initScope - Scope to be bond on the component class\n * @returns {T} - Scoped component class\n */\nconst scoped = (component, initScope) => class extends component {\n\tconstructor(state, scope = {}) {\n\t\tconst _scope = assign({}, initScope)\n\t\tsuper(state, assign(_scope, scope))\n\t}\n}\n\nexport default scoped\n"],"names":["O2C","SyntaxError","UC2C","val","substr","length","parseInt","String","fromCodePoint","err","U2C","substring","fromCharCode","X2C","efEscape","string","const","escaped","split","doubleChar","let","escapedStr","replace","oct","ucp","uni","hex","b","t","n","v","f","r","esc","push","join","char","splitWith","escapedSplit","i","splitBy","splitArr","shift","getErrorMsg","msg","line","checkValidType","obj","indexOf","ESCAPE","parsed","JSON","parse","e","splitDefault","slice","pathArr","_path","trim","map","_default","defaultVal","splitLiterals","strs","mustache","tmpl","mustaches","match","pushStr","textArr","str","parseText","result","exprs","dotToSpace","getOption","options","keys","option","keyCode","isNaN","s","p","h","a","c","u","console","warn","setOption","parseLine","parsingInfo","offset","offsetReg","trimmedLine","removed","prevDepth","removeOffset","indentReg","spaces","spaceIndent","RegExp","getIndent","content","escapedName","splitted","tagInfo","depth","test","getDepth","prevType","topExists","type","currentNode","ast","resolveDepth","info","hashref","ref","tag","class","newNode","name","value","propPath","l","listener","ops","k","getEventOptions","m","method","_value","reserved","parseEft","template","TypeError","tplType","lines","Array","isArray","Object","hasOwnProperty","call","typeOf","mixStr","getVal","data","proto","prototype","ARR","copy","arr","empty","equals","left","right","pop","apply","items","remove","item","index","splice","reverse","rightUnique","newArr","j","sort","fn","args","unshift","window","Set","from","unique","queue","handlers","modificationQueue","queueDom","handler","domQueue","inform","count","execUserQueue","userQueue","userFnQueue","exec","immediate","renderQueue","execModifications","domRenderQueue","execDomModifications","setTimeout","legacyAssign","ee","er","defineNode","key","node","defineProperty","get","set","assign","configurable","enumerable","resolve","parentNode","resolveReactivePath","subscribers","innerData","handlerNode","subscriberNode","dataNode","resolveAllPath","_key","undefined","isnan","initBinding","subscriberExecuting","bind","ctx","subscriber","state","dbg","error","isInstance","constructor","enumerableFalse","classObj","strTpl","log","shared","Node","mountingPointStore","WeakMap","DOM","EFFragment","appendTo","self","append","this","before","tempFragment","document","createDocumentFragment","nodes","EFBaseComponent","$mount","target","appendChild","insertBefore","after","nextSibling","handleMountingPoint","mountingPoint","clear","$ctx","nodeInfo","element","placeholder","children","toEFComponent","nodeType","$umount","removeChild","getEvent","bubbles","cancelable","event","createEvent","initEvent","typeValid","getElement","tagType","tagName","tagContent","attrs","svg","createElementNS","toLowerCase","is","createElement","refs","regTmpl","_handler","addAttr","attr","custom","setAttributeNS","xlinkNS","setAttribute","removeAttribute","removeAttributeNS","addProp","keyPath","lastKey","addListener","dispatch","lastNode","resolvePath","expr","_update","canceoable","radios","querySelectorAll","selected","dispatchEvent","$data","checked","rawHandler","addEvent","shiftKey","altKey","ctrlKey","metaKey","which","stopPropagation","stopImmediatePropagation","preventDefault","methods","bindTextNode","textNode","textContent","createTextNode","bindMountingList","anchor","defineProperties","DOMARR","isFragment","safeZone","resolveAST","create","getGetter","Error","checkTrue","base","getSetter","baseNode","_trueVal","trueVal","_falseVal","falseVal","defaultRoot","getBase","root","mapAttrs","tpl","attrMap","basicProperty","$destroy","poped","elements","parent","tempArr","shifted","sorted","spliced","mountOptions","BEFORE","AFTER","APPEND","REPLACE","nullComponent","mountingPointUpdaters","child","fragment","isPrototypeOf","scope","childNodes","mount","prototypeAccessors","newData","$methods","newMethods","$refs","querySelector","$subscribe","pathStr","$unsubscribe","resolveSubscriber","$update","newState","$dispatch","$emit","eventName","$on","addEventListener","$off","removeEventListener","delete","fragmentAST","EFNodeWrapper","super","prototypeAccessors$1","$el","Fragment","textFragmentAst","EFTextFragment","text","stringify","flatten","prev","EFComponent","valType","parser","eftParser","applyMountingPoints","initState","cb","reduce","transformedAttrs","component","initScope","_scope","newParser"],"mappings":"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"}