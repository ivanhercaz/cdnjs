{"version":3,"file":"ef.min.js","sources":["../node_modules/eft-parser/src/escape-parser.js","../node_modules/eft-parser/src/eft-parser.js","../node_modules/ef-core/src/lib/utils/type-of.js","../node_modules/ef-core/src/lib/utils/literals-mix.js","../node_modules/ef-core/src/lib/utils/array-helper.js","../node_modules/ef-core/src/lib/render-queue.js","../node_modules/ef-core/src/lib/utils/polyfills.js","../node_modules/ef-core/src/lib/resolver.js","../node_modules/ef-core/src/lib/utils/isnan.js","../node_modules/ef-core/src/lib/binding.js","../node_modules/ef-core/src/lib/utils/fast-instance-of.js","../node_modules/ef-core/src/lib/utils/buble-fix.js","../node_modules/ef-core/src/lib/utils/debug.js","../node_modules/ef-core/src/lib/utils/global-shared.js","../node_modules/ef-core/src/lib/utils/dom-helper.js","../node_modules/ef-core/src/lib/utils/event-helper.js","../node_modules/ef-core/src/lib/element-creator.js","../node_modules/ef-core/src/lib/creator.js","../node_modules/ef-core/src/lib/utils/dom-arr-helper.js","../node_modules/ef-core/src/lib/register-props.js","../node_modules/ef-core/src/mount-options.js","../node_modules/ef-core/src/lib/renderer.js","../node_modules/ef-core/src/lib/jsx-create-element.js","../src/ef.js","../node_modules/ef-core/src/ef-core.js","../src/lib/parser.js","../node_modules/ef-core/src/lib/utils/scoped-component.js"],"sourcesContent":["// Set the escape character\nconst char = '&'\nconst doubleChar = char + char\n\n// Initlize RegExp\nconst oct = new RegExp(`\\\\${char}[0-7]{1,3}`, 'g')\nconst ucp = new RegExp(`\\\\${char}u\\\\[.*?\\\\]`, 'g')\nconst uni = new RegExp(`\\\\${char}u.{0,4}`, 'g')\nconst hex = new RegExp(`\\\\${char}x.{0,2}`, 'g')\nconst esc = new RegExp(`\\\\${char}`, 'g')\nconst b = new RegExp(`\\\\${char}b`, 'g')\nconst t = new RegExp(`\\\\${char}t`, 'g')\nconst n = new RegExp(`\\\\${char}n`, 'g')\nconst v = new RegExp(`\\\\${char}v`, 'g')\nconst f = new RegExp(`\\\\${char}f`, 'g')\nconst r = new RegExp(`\\\\${char}r`, 'g')\n\n// Escape octonary sequence\nconst O2C = () => {\n\tthrow new SyntaxError('Octal escape sequences are not allowed in EFML.')\n}\n\n// Escape unicode code point sequence\nconst UC2C = (val) => {\n\tval = val.substr(3, val.length - 4)\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid Unicode escape sequence')\n\ttry {\n\t\treturn String.fromCodePoint(val)\n\t} catch (err) {\n\t\tthrow new SyntaxError('Undefined Unicode code-point')\n\t}\n}\n\n// Escape unicode sequence\nconst U2C = (val) => {\n\tval = val.substring(2)\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid Unicode escape sequence')\n\treturn String.fromCharCode(val)\n}\n\n// Escape hexadecimal sequence\nconst X2C = (val) => {\n\tval = `00${val.substring(2)}`\n\tval = parseInt(val, 16)\n\tif (!val) throw new SyntaxError('Invalid hexadecimal escape sequence')\n\treturn String.fromCharCode(val)\n}\n\nconst efEscape = (string) => {\n\t// Split strings\n\tconst splitArr = string.split(doubleChar)\n\tconst escaped = []\n\n\t// Escape all known escape characters\n\tfor (let i of splitArr) {\n\t\tconst escapedStr = i\n\t\t\t.replace(oct, O2C)\n\t\t\t.replace(ucp, UC2C)\n\t\t\t.replace(uni, U2C)\n\t\t\t.replace(hex, X2C)\n\t\t\t.replace(b, '\\b')\n\t\t\t.replace(t, '\\t')\n\t\t\t.replace(n, '\\n')\n\t\t\t.replace(v, '\\v')\n\t\t\t.replace(f, '\\f')\n\t\t\t.replace(r, '\\r')\n\t\t\t// Remove all useless escape characters\n\t\t\t.replace(esc, '')\n\t\tescaped.push(escapedStr)\n\t}\n\t// Return escaped string\n\treturn escaped.join(char)\n}\n\nconst checkEscape = string => string[string.length - 1] === char\n\nconst splitWith = (string, char) => {\n\tconst splitArr = string.split(char)\n\tconst escapedSplit = []\n\tlet escaped = false\n\tfor (let i of splitArr) {\n\t\tif (escaped) escapedSplit[escapedSplit.length - 1] += `${char}${i}`\n\t\telse escapedSplit.push(i)\n\t\tescaped = checkEscape(i)\n\t}\n\treturn escapedSplit\n}\n\nconst splitBy = (string, char) => {\n\tconst splitArr = string.split(doubleChar)\n\tconst escaped = splitWith(splitArr.shift(), char)\n\tfor (let i of splitArr) {\n\t\tconst escapedSplit = splitWith(i, char)\n\t\tescaped[escaped.length - 1] += `${doubleChar}${escapedSplit.shift()}`\n\t\tescaped.push(...escapedSplit)\n\t}\n\treturn escaped\n}\n\nexport { efEscape, splitBy }\n","import { efEscape, splitBy } from './escape-parser.js'\n\nconst typeSymbols = '>#%@.-+'\nconst reserved = [\n\t'$ctx', '$refs', '$data', '$methods', '$mount', '$umount', '$subscribe', '$unsubscribe', '$update',\n\t'$dispatch', '$emit', '$on', '$off', '$destroy', '__DIRECTMOUNT__'\n]\nconst mustache = /\\{\\{.+?\\}\\}/g\nconst spaceIndent = /^(\\t*)( *).*/\nconst hashref = /#([^}]|}[^}])*$/\n\nconst getErrorMsg = (msg, line = -2) => `Failed to parse eft template: ${msg}. at line ${line + 1}`\n\nconst isEmpty = string => !string.replace(/\\s/, '')\n\nconst checkValidType = obj => ['number', 'boolean', 'string'].indexOf(typeof obj) > -1\n\nconst ESCAPE = (string) => {\n\tif (!string) return [string, false]\n\ttry {\n\t\tconst parsed = JSON.parse(string)\n\t\tif (['number', 'boolean'].indexOf(typeof parsed) === -1) return [efEscape(string), true]\n\t\treturn [parsed, false]\n\t} catch (e) {\n\t\treturn [efEscape(string), true]\n\t}\n}\n\nconst getOffset = (string, parsingInfo) => {\n\tif (parsingInfo.offset !== null) return\n\tparsingInfo.offset = string.match(/\\s*/)[0]\n\tif (parsingInfo.offset) parsingInfo.offsetReg = parsingInfo.offset\n}\n\nconst removeOffset = (string, parsingInfo, i) => {\n\tif (parsingInfo.offsetReg) {\n\t\tlet removed = false\n\t\tstring = string.replace(parsingInfo.offsetReg, () => {\n\t\t\tremoved = true\n\t\t\treturn ''\n\t\t})\n\t\tif (!removed) throw new SyntaxError(getErrorMsg(`Expected indent to be grater than 0 and less than ${parsingInfo.prevDepth + 1}, but got -1`, i))\n\t}\n\treturn string\n}\n\nconst getIndent = (string, parsingInfo) => {\n\tif (parsingInfo.indentReg) return\n\tconst spaces = string.match(spaceIndent)[2]\n\tif (spaces) {\n\t\tparsingInfo.indentReg = new RegExp(spaces, 'g')\n\t}\n}\n\nconst getDepth = (string, parsingInfo, i) => {\n\tlet depth = 0\n\tif (parsingInfo.indentReg) string = string.replace(/^\\s*/, str => str.replace(parsingInfo.indentReg, '\\t'))\n\tconst content = string.replace(/^\\t*/, (str) => {\n\t\tdepth = str.length\n\t\treturn ''\n\t})\n\tif ((/^\\s/).test(content)) throw new SyntaxError(getErrorMsg('Bad indent', i))\n\treturn { depth, content }\n}\n\nconst resolveDepth = (ast, depth) => {\n\tlet currentNode = ast\n\tfor (let i = 0; i < depth; i++) currentNode = currentNode[currentNode.length - 1]\n\treturn currentNode\n}\n\nconst splitDefault = (string) => {\n\tstring = string.slice(2, string.length - 2)\n\tconst [_path, ..._default] = splitBy(string, '=')\n\tconst pathArr = splitBy(_path.trim(), '.').map(efEscape)\n\tconst [defaultVal, escaped] = ESCAPE(_default.join('=').trim())\n\tif (checkValidType(defaultVal) && (escaped || (!escaped && defaultVal !== ''))) return [pathArr, defaultVal]\n\treturn [pathArr]\n}\n\nconst splitLiterals = (string) => {\n\tconst strs = string.split(mustache)\n\tif (strs.length === 1) return ESCAPE(string)[0]\n\tconst tmpl = []\n\tif (strs.length === 2 && !strs[0] && !strs[1]) tmpl.push(0)\n\telse tmpl.push(strs.map(efEscape))\n\tconst mustaches = string.match(mustache)\n\tif (mustaches) tmpl.push(...mustaches.map(splitDefault))\n\treturn tmpl\n}\n\nconst pushStr = (textArr, str) => {\n\tif (str) textArr.push(str)\n}\n\nconst parseText = (string) => {\n\tconst result = splitLiterals(string)\n\tif (checkValidType(result)) return [`${result}`]\n\tconst [strs, ...exprs] = result\n\tconst textArr = []\n\tfor (let i = 0; i < exprs.length; i++) {\n\t\tpushStr(textArr, strs[i])\n\t\ttextArr.push(exprs[i])\n\t}\n\tpushStr(textArr, strs[strs.length - 1])\n\treturn textArr\n}\n\nconst dotToSpace = val => val.replace(/\\./g, ' ')\n\nconst parseTag = (string) => {\n\tconst tagInfo = {}\n\tconst [tag, ...content] = splitBy(string.replace(hashref, (val) => {\n\t\ttagInfo.ref = val.slice(1)\n\t\treturn ''\n\t}), '.')\n\ttagInfo.tag = efEscape(tag)\n\ttagInfo.class = splitLiterals(content.join('.'))\n\tif (typeof tagInfo.class === 'string') tagInfo.class = dotToSpace(tagInfo.class).trim()\n\telse if (tagInfo.class[0]) tagInfo.class[0] = tagInfo.class[0].map(dotToSpace)\n\treturn tagInfo\n}\n\nconst parseNodeProps = (string) => {\n\tconst splited = splitBy(string, '=')\n\treturn {\n\t\tname: efEscape(splited.shift().trim()),\n\t\tvalue: splitLiterals(splited.join('=').trim())\n\t}\n}\n\nconst parseEvent = (string) => {\n\tconst splited = splitBy(string, '=')\n\treturn {\n\t\tname: splited.shift().trim(),\n\t\tvalue: splited.join('=').trim()\n\t}\n}\n\nconst setOption = (options, option) => {\n\tswitch (option) {\n\t\tcase 'stop': {\n\t\t\toptions.s = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'stopImmediate': {\n\t\t\toptions.i = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'prevent': {\n\t\t\toptions.p = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'shift': {\n\t\t\toptions.h = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'alt': {\n\t\t\toptions.a = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'ctrl': {\n\t\t\toptions.c = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'meta': {\n\t\t\toptions.t = 1\n\t\t\tbreak\n\t\t}\n\t\tcase 'capture': {\n\t\t\toptions.u = 1\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\tconsole.warn(`Abandoned unsupported eft event option '${option}'.`)\n\t\t}\n\t}\n}\n\nconst getOption = (options, keys, option) => {\n\tconst keyCode = parseInt(option, 10)\n\tif (isNaN(keyCode)) return setOption(options, efEscape(option))\n\tkeys.push(keyCode)\n}\n\nconst getEventOptions = (name) => {\n\tconst options = {}\n\tconst keys = []\n\tconst [listener, ...ops] = splitBy(name, '.')\n\toptions.l = efEscape(listener)\n\tfor (let i of ops) getOption(options, keys, i)\n\tif (keys.length > 0) options.k = keys\n\treturn options\n}\n\nconst splitEvents = (string) => {\n\tconst [name, ...value] = splitBy(string, ':')\n\tconst content = value.join(':')\n\tconst escapedName = efEscape(name.trim())\n\tif (content) return [escapedName, splitLiterals(content)]\n\treturn [escapedName]\n}\n\nconst parseLine = ({line, ast, parsingInfo, i}) => {\n\tif (isEmpty(line)) return\n\tgetOffset(line, parsingInfo)\n\n\tconst trimmedLine = removeOffset(line, parsingInfo, i)\n\tgetIndent(trimmedLine, parsingInfo)\n\n\tlet { depth, content } = getDepth(trimmedLine, parsingInfo, i)\n\n\tif (content) {\n\t\tif (depth < 0 || depth - parsingInfo.prevDepth > 1 || (depth - parsingInfo.prevDepth === 1 && ['comment', 'tag'].indexOf(parsingInfo.prevType) === -1) || (parsingInfo.prevType !== 'comment' && depth === 0 && parsingInfo.topExists)) throw new SyntaxError(getErrorMsg(`Expected indent to be grater than 0 and less than ${parsingInfo.prevDepth + 1}, but got ${depth}`, i))\n\t\tconst type = content[0]\n\t\tcontent = content.slice(1)\n\t\tif (!content && typeSymbols.indexOf(type) >= 0) throw new SyntaxError(getErrorMsg('Empty content', i))\n\t\t// Jump back to upper level\n\t\tif (depth < parsingInfo.prevDepth || (depth === parsingInfo.prevDepth && parsingInfo.prevType === 'tag')) parsingInfo.currentNode = resolveDepth(ast, depth)\n\t\tparsingInfo.prevDepth = depth\n\n\t\tswitch (type) {\n\t\t\tcase '>': {\n\t\t\t\tconst info = parseTag(content)\n\t\t\t\tconst newNode = [{\n\t\t\t\t\tt: info.tag\n\t\t\t\t}]\n\t\t\t\tif (info.class) {\n\t\t\t\t\tnewNode[0].a = {}\n\t\t\t\t\tnewNode[0].a.class = info.class\n\t\t\t\t}\n\t\t\t\tif (info.ref) newNode[0].r = info.ref\n\t\t\t\tparsingInfo.currentNode.push(newNode)\n\t\t\t\tparsingInfo.currentNode = newNode\n\t\t\t\tparsingInfo.prevType = 'tag'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '#': {\n\t\t\t\tconst { name, value } = parseNodeProps(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].a) parsingInfo.currentNode[0].a = {}\n\t\t\t\tparsingInfo.currentNode[0].a[name] = value\n\t\t\t\tparsingInfo.prevType = 'attr'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '%': {\n\t\t\t\tconst { name, value } = parseNodeProps(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].p) parsingInfo.currentNode[0].p = {}\n\t\t\t\tparsingInfo.currentNode[0].p[name] = value\n\t\t\t\tparsingInfo.prevType = 'prop'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '@': {\n\t\t\t\tconst { name, value } = parseEvent(content)\n\t\t\t\tif (!parsingInfo.currentNode[0].e) parsingInfo.currentNode[0].e = []\n\t\t\t\tconst options = getEventOptions(name)\n\t\t\t\tconst [method, _value] = splitEvents(value)\n\t\t\t\toptions.m = method\n\t\t\t\tif (_value) options.v = _value\n\t\t\t\tparsingInfo.currentNode[0].e.push(options)\n\t\t\t\tparsingInfo.prevType = 'event'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '.': {\n\t\t\t\tparsingInfo.currentNode.push(...parseText(content))\n\t\t\t\tparsingInfo.prevType = 'text'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '|': {\n\t\t\t\tif (parsingInfo.currentNode.length > 1) content = `\\n${content}`\n\t\t\t\tparsingInfo.currentNode.push(...parseText(content))\n\t\t\t\tparsingInfo.prevType = 'multiline-text'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '-': {\n\t\t\t\tif (reserved.indexOf(content) !== -1) throw new SyntaxError(getErrorMsg(`Reserved name '${content}' should not be used`, i))\n\t\t\t\tparsingInfo.currentNode.push({\n\t\t\t\t\tn: content,\n\t\t\t\t\tt: 0\n\t\t\t\t})\n\t\t\t\tparsingInfo.prevType = 'node'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase '+': {\n\t\t\t\tparsingInfo.currentNode.push({\n\t\t\t\t\tn: content,\n\t\t\t\t\tt: 1\n\t\t\t\t})\n\t\t\t\tparsingInfo.prevType = 'list'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tparsingInfo.prevType = 'comment'\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst parseEft = (template) => {\n\tif (!template) throw new TypeError(getErrorMsg('Template required, but nothing given'))\n\tconst tplType = typeof template\n\tif (tplType !== 'string') throw new TypeError(getErrorMsg(`Expected a string, but got a(n) ${tplType}`))\n\tconst lines = template.split(/\\r?\\n/)\n\tconst ast = [{t: 0}]\n\tconst parsingInfo = {\n\t\tindentReg: null,\n\t\tprevDepth: 0,\n\t\toffset: null,\n\t\toffsetReg: null,\n\t\tprevType: 'comment',\n\t\tcurrentNode: ast,\n\t\ttopExists: false,\n\t}\n\tfor (let i = 0; i < lines.length; i++) parseLine({line: lines[i], ast, parsingInfo, i})\n\n\tif (ast.length <= 1) throw new SyntaxError(getErrorMsg('Nothing to be parsed', lines.length - 1))\n\tif (ast.length === 2 && Array.isArray(ast[1]) && Object.hasOwnProperty.call(ast[1][0], 't')) return ast[1]\n\treturn ast\n}\n\nexport default parseEft\n","const typeOf = (obj) => {\n\tif (Array.isArray(obj)) return 'array'\n\treturn typeof obj\n}\n\nexport default typeOf\n","const mixStr = (strs, ...exprs) => {\n\tlet string = ''\n\tfor (let i = 0; i < exprs.length; i++) {\n\t\tif (typeof exprs[i] === 'undefined') string += strs[i]\n\t\telse string += (strs[i] + exprs[i])\n\t}\n\treturn string + strs[strs.length - 1]\n}\n\nconst getVal = ({dataNode, _key}) => {\n\tconst data = dataNode[_key]\n\tif (typeof data === 'undefined') return ''\n\treturn data\n}\n\nconst mixVal = (strs, ...exprs) => {\n\tif (!strs) return getVal(exprs[0])\n\tconst template = [strs]\n\ttemplate.push(...exprs.map(getVal))\n\treturn mixStr(...template)\n}\n\nexport { mixStr, mixVal }\n","const proto = Array.prototype\n\nconst ARR = {\n\tcopy(arr) {\n\t\treturn proto.slice.call(arr, 0)\n\t},\n\tempty(arr) {\n\t\tarr.length = 0\n\t\treturn arr\n\t},\n\tequals(left, right) {\n\t\tif (!Array.isArray(right)) return false\n\t\tif (left === right) return true\n\t\tif (left.length !== right.length) return false\n\t\tfor (let i = 0, l = left.length; i < l; i++) {\n\t\t\tif (left[i] !== right[i]) return false\n\t\t}\n\t\treturn true\n\t},\n\tpop(arr) {\n\t\treturn proto.pop.call(arr)\n\t},\n\tpush(arr, ...items) {\n\t\treturn proto.push.apply(arr, items)\n\t},\n\tremove(arr, item) {\n\t\tconst index = proto.indexOf.call(arr, item)\n\t\tif (index > -1) {\n\t\t\tproto.splice.call(arr, index, 1)\n\t\t\treturn item\n\t\t}\n\t},\n\treverse(arr) {\n\t\treturn proto.reverse.call(arr)\n\t},\n\trightUnique(arr) {\n\t\tconst newArr = []\n\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\tfor (let j = i + 1; j < arr.length; j++) if (arr[i] === arr[j]) j = i += 1\n\t\t\tnewArr.push(arr[i])\n\t\t}\n\t\treturn newArr\n\t},\n\tshift(arr) {\n\t\treturn proto.shift.call(arr)\n\t},\n\tslice(arr, index, length) {\n\t\treturn proto.slice.call(arr, index, length)\n\t},\n\tsort(arr, fn) {\n\t\treturn proto.sort.call(arr, fn)\n\t},\n\tsplice(arr, ...args) {\n\t\treturn proto.splice.apply(arr, args)\n\t},\n\tunshift(arr, ...items) {\n\t\treturn proto.unshift.apply(arr, items)\n\t}\n}\n\nif (window.Set && Array.from) ARR.unique = arr => Array.from(new Set(arr))\nelse ARR.unique = ARR.rightUnique\n\nexport default ARR\n","import ARR from './utils/array-helper.js'\nimport dbg from './utils/debug.js'\n\nconst modificationQueue = []\nconst domQueue = []\nconst userQueue = []\nlet count = 0\n\nconst queue = handlers => modificationQueue.push(...handlers)\nconst queueDom = handler => domQueue.push(handler)\nconst onNextRender = handler => userQueue.push(handler)\n\nconst isPaused = () => count > 0\n\nconst inform = () => {\n\tcount += 1\n\treturn count\n}\n\nconst execModifications = () => {\n\tif (modificationQueue.length === 0) return\n\tconst renderQueue = ARR.unique(modificationQueue)\n\tARR.empty(modificationQueue)\n\tfor (let i of renderQueue) i()\n}\n\nconst execDomModifications = () => {\n\tif (domQueue.length === 0) return\n\tconst domRenderQueue = ARR.rightUnique(domQueue)\n\tARR.empty(domQueue)\n\tfor (let i of domRenderQueue) i()\n}\n\nconst execUserQueue = () => {\n\tif (userQueue.length === 0) return\n\tconst userFnQueue = ARR.unique(userQueue)\n\tARR.empty(userQueue)\n\tfor (let i of userFnQueue) i()\n}\n\nconst exec = (immediate) => {\n\tif (!immediate && (count -= 1) > 0) return count\n\tcount = 0\n\n\tif (modificationQueue.length > 0) execModifications()\n\n\tif (domQueue.length > 0) execDomModifications()\n\n\t// Execute user queue after DOM update\n\tif (userQueue.length > 0) setTimeout(execUserQueue, 0)\n\n\treturn count\n}\n\nconst bundle = (cb) => {\n\tinform()\n\ttry {\n\t\treturn exec(cb(inform, exec))\n\t} catch (e) {\n\t\tdbg.error('Error caught when executing bundle:\\n', e)\n\t\treturn exec()\n\t}\n}\n\nexport { queue, queueDom, onNextRender, inform, exec, bundle, isPaused }\n","// Enough for ef's usage, so no need for a full polyfill\nconst legacyAssign = (ee, er) => {\n\tfor (let i in er) ee[i] = er[i]\n\treturn ee\n}\n\nconst assign = Object.assign || legacyAssign\n\nexport {assign, legacyAssign}\n","import {inform, exec} from './render-queue.js'\nimport {assign} from './utils/polyfills.js'\n\nconst resolveAllPath = ({_path, handlers, subscribers, innerData}) => {\n\tfor (let i of _path) {\n\t\tif (!handlers[i]) handlers[i] = {}\n\t\tif (!subscribers[i]) subscribers[i] = {}\n\t\tif (!innerData[i]) innerData[i] = {}\n\t\thandlers = handlers[i]\n\t\tsubscribers = subscribers[i]\n\t\tinnerData = innerData[i]\n\t}\n\treturn {\n\t\thandlerNode: handlers,\n\t\tsubscriberNode: subscribers,\n\t\tdataNode: innerData\n\t}\n}\n\n// Workaround for the third bug of buble:\n// https://github.com/bublejs/buble/issues/106\nconst defineNode = (key, obj) => {\n\tconst node = {}\n\tObject.defineProperty(obj, key, {\n\t\tget() {\n\t\t\treturn node\n\t\t},\n\t\tset(data) {\n\t\t\tinform()\n\t\t\tassign(node, data)\n\t\t\texec()\n\t\t},\n\t\tconfigurable: false,\n\t\tenumerable: true\n\t})\n\treturn node\n}\n\nconst resolveReactivePath = (_path, obj) => {\n\tfor (let i of _path) {\n\t\tif (obj[i]) obj = obj[i]\n\t\telse obj = defineNode(i, obj)\n\t}\n\treturn obj\n}\n\nconst resolvePath = (_path, obj) => {\n\tfor (let i of _path) {\n\t\tif (!obj[i]) obj[i] = {}\n\t\tobj = obj[i]\n\t}\n\treturn obj\n}\n\nconst resolve = ({_path, _key, data, handlers, subscribers, innerData}) => {\n\tconst parentNode = resolveReactivePath(_path, data)\n\tconst {handlerNode, subscriberNode, dataNode} = resolveAllPath({_path, handlers, subscribers, innerData})\n\tif (!handlerNode[_key]) handlerNode[_key] = []\n\tif (!subscriberNode[_key]) subscriberNode[_key] = []\n\t/* eslint no-undefined: \"off\" */\n\tif (!Object.prototype.hasOwnProperty.call(dataNode, _key)) dataNode[_key] = undefined\n\treturn {parentNode, handlerNode: handlerNode[_key], subscriberNode: subscriberNode[_key], dataNode}\n}\n\nconst resolveSubscriber = (_path, subscribers) => {\n\tconst pathArr = _path.split('.')\n\tconst key = pathArr.pop()\n\tfor (let i of pathArr) {\n\t\tif (!subscribers[i]) subscribers[i] = {}\n\t\tsubscribers = subscribers[i]\n\t}\n\treturn subscribers[key]\n}\n\nexport {resolveReactivePath, resolvePath, resolve, resolveSubscriber}\n","/* eslint-disable no-self-compare */\nconst isnan = obj => obj !== obj\n\nexport default isnan\n","import {resolve} from './resolver.js'\nimport {inform, exec, queue} from './render-queue.js'\nimport ARR from './utils/array-helper.js'\nimport isnan from './utils/isnan.js'\nimport dbg from './utils/debug.js'\n\nconst initDataNode = ({parentNode, dataNode, handlerNode, subscriberNode, ctx, _key}) => {\n\tlet subscriberExecuting = false\n\tObject.defineProperty(parentNode, _key, {\n\t\tget() {\n\t\t\treturn dataNode[_key]\n\t\t},\n\t\tset(value) {\n\t\t\tif (subscriberExecuting) return\n\t\t\t// Comparing NaN is like eating a cake and suddenly encounter a grain of sand\n\t\t\tif (dataNode[_key] === value || (isnan(dataNode[_key]) && isnan(value))) return\n\t\t\tdataNode[_key] = value\n\t\t\tinform()\n\t\t\tqueue(handlerNode)\n\t\t\texec()\n\t\t\tif (subscriberNode.length > 0) {\n\t\t\t\tsubscriberExecuting = true\n\t\t\t\tinform()\n\t\t\t\ttry {\n\t\t\t\t\tfor (const subscriber of subscriberNode) subscriber({state: ctx.state, value})\n\t\t\t\t} catch (e) {\n\t\t\t\t\tdbg.error('Error caught when executing subscribers:\\n', e)\n\t\t\t\t}\n\t\t\t\texec()\n\t\t\t\tsubscriberExecuting = false\n\t\t\t}\n\t\t},\n\t\tenumerable: true\n\t})\n}\n\nconst initBinding = ({bind, ctx, handlers, subscribers, innerData}) => {\n\tconst _path = ARR.copy(bind[0])\n\tconst _key = _path.pop()\n\tconst {parentNode, handlerNode, subscriberNode, dataNode} = resolve({\n\t\t_path,\n\t\t_key,\n\t\tdata: ctx.data,\n\t\thandlers,\n\t\tsubscribers,\n\t\tinnerData\n\t})\n\n\t// Initlize data binding node if not exist\n\tif (!Object.prototype.hasOwnProperty.call(parentNode, _key)) initDataNode({parentNode, dataNode, handlerNode, subscriberNode, ctx, _key})\n\t// Update default value\n\t// bind[1] is the default value for this node\n\tif (bind.length > 1) parentNode[_key] = bind[1]\n\n\treturn {dataNode, parentNode, handlerNode, subscriberNode, _key}\n}\n\nexport default initBinding\n","const isInstance = (er, ee) => er.constructor === ee\n\nexport default isInstance\n","import ARR from './array-helper.js'\n\n// https://github.com/bublejs/buble/issues/197\nconst enumerableFalse = (classObj, keys) => {\n\tfor (let i of keys) Object.defineProperty(classObj.prototype, i, {enumerable: false})\n\treturn classObj\n}\n\n// https://github.com/bublejs/buble/issues/131\nconst prepareArgs = (self, node) => {\n\tconst args = ARR.copy(self)\n\tARR.unshift(args, node)\n\treturn args\n}\n\nexport {enumerableFalse, prepareArgs}\n","// Wrap console functions for `[EF]` perfix\nconst strTpl = '[EF] %s'\nconst dbg = {\n\tlog: console.log.bind(console, strTpl),\n\tinfo: console.info.bind(console, strTpl),\n\twarn: console.warn.bind(console, strTpl),\n\terror: console.error.bind(console, strTpl)\n}\n\nexport default dbg\n","const shared = {}\n\nexport default shared\n","// import ARR from './array-helper.js'\nimport isInstance from './fast-instance-of.js'\nimport {prepareArgs} from './buble-fix.js'\nimport dbg from './debug.js'\nimport {inform, exec} from '../render-queue.js'\n\nimport shared from './global-shared.js'\n\nconst proto = Node.prototype\n\n// Will require a weakmap polyfill for IE10 and below\nconst mountingPointStore = new WeakMap()\n\nconst DOM = {}\n\nconst EFFragment = class extends Array {\n\tappendTo(node) {\n\t\tDOM.append.apply(null, prepareArgs(this, node))\n\t}\n\t// insertBeforeTo(node) {\n\t// \tconst args = ARR.copy(this)\n\t// \tARR.unshift(args, node)\n\t// \tDOM.before.apply(null, prepareArgs(this, node))\n\t// }\n\t// insertAfterTo(node) {\n\t// \tconst args = ARR.copy(this)\n\t// \tARR.unshift(args, node)\n\t// \tDOM.after.apply(null, prepareArgs(this, node))\n\t// }\n\tremove() {\n\t\tfor (let i of this) DOM.remove(i)\n\t}\n}\n\nDOM.before = (node, ...nodes) => {\n\tconst tempFragment = document.createDocumentFragment()\n\tinform()\n\tfor (let i of nodes) {\n\t\tif (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target: tempFragment})\n\t\t} else if (isInstance(i, EFFragment)) i.appendTo(tempFragment)\n\t\telse proto.appendChild.call(tempFragment, i)\n\t}\n\tproto.insertBefore.call(node.parentNode, tempFragment, node)\n\texec()\n}\n\nDOM.after = (node, ...nodes) => {\n\tconst tempFragment = document.createDocumentFragment()\n\tinform()\n\tfor (let i of nodes) {\n\t\tif (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target: tempFragment})\n\t\t} else if (isInstance(i, EFFragment)) i.appendTo(tempFragment)\n\t\telse proto.appendChild.call(tempFragment, i)\n\t}\n\tif (node.nextSibling) proto.insertBefore.call(node.parentNode, tempFragment, node.nextSibling)\n\telse proto.appendChild.call(node.parentNode, tempFragment)\n\texec()\n}\n\nconst handleMountingPoint = (mountingPoint, tempFragment) => {\n\tconst {node} = mountingPoint\n\tif (!node) return\n\tif (Array.isArray(node) && node.clear) {\n\t\tfor (let j of node) {\n\t\t\tconst {element, placeholder} = j.$ctx.nodeInfo\n\t\t\tDOM.append(tempFragment, element, placeholder)\n\t\t}\n\t} else {\n\t\tconst {element, placeholder} = node.$ctx.nodeInfo\n\t\tDOM.append(tempFragment, element, placeholder)\n\t}\n}\n\nDOM.append = (node, ...nodes) => {\n\t// Handle fragment\n\tif (isInstance(node, EFFragment)) return node.push(...nodes)\n\t// Handle EFComponent\n\tif (node instanceof shared.EFBaseComponent) {\n\t\tif (!(Array.isArray(node.children) && node.children.clear)) {\n\t\t\tif (process.env.NODE_ENV !== 'production') dbg.warn(node, 'has no `children` list mount point! Child nodes are all ignored!')\n\t\t\treturn\n\t\t}\n\n\t\tinform()\n\t\tfor (let i of nodes) {\n\t\t\tif (i instanceof Node) i = new shared.EFNodeWrapper(i)\n\t\t\tnode.children.push(i)\n\t\t}\n\t\texec()\n\n\t\treturn\n\t}\n\n\tif ([1,9,11].indexOf(node.nodeType) === -1) return\n\tconst tempFragment = document.createDocumentFragment()\n\tfor (let i of nodes) {\n\t\tif (isInstance(i, EFFragment)) i.appendTo(tempFragment)\n\t\telse if (i instanceof Node) {\n\t\t\tproto.appendChild.call(tempFragment, i)\n\t\t\tconst mountingPoint = mountingPointStore.get(i)\n\t\t\tif (mountingPoint) handleMountingPoint(mountingPoint, tempFragment)\n\t\t} else if (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target: tempFragment})\n\t\t}\n\t}\n\tproto.appendChild.call(node, tempFragment)\n}\n\nDOM.remove = (node) => {\n\tif (isInstance(node, EFFragment)) node.remove()\n\telse if (node instanceof shared.EFBaseComponent) node.$umount()\n\telse proto.removeChild.call(node.parentNode, node)\n}\n\n// addClass(node, className) {\n// \tconst classes = className.split(' ')\n// \tnode.classList.add(...classes)\n// },\n\n// removeClass(node, className) {\n// \tconst classes = className.split(' ')\n// \tnode.classList.remove(...classes)\n// },\n\n// toggleClass(node, className) {\n// \tconst classes = className.split(' ')\n// \tconst classArr = node.className.split(' ')\n// \tfor (let i of classes) {\n// \t\tconst classIndex = classArr.indexOf(i)\n// \t\tif (classIndex > -1) {\n// \t\t\tclassArr.splice(classIndex, 1)\n// \t\t} else {\n// \t\t\tclassArr.push(i)\n// \t\t}\n// \t}\n// \tnode.className = classArr.join(' ').trim()\n// },\n\n// replaceWith(node, newNode) {\n// \tconst parent = node.parentNode\n// \tif (parent) proto.replaceChild.call(parent, newNode, node)\n// },\n\n// swap(node, newNode) {\n// \tconst nodeParent = node.parentNode\n// \tconst newNodeParent = newNode.parentNode\n// \tconst nodeSibling = node.nextSibling\n// \tconst newNodeSibling = newNode.nextSibling\n// \tif (nodeParent && newNodeParent) {\n// \t\tproto.insertBefore.call(nodeParent, newNode, nodeSibling)\n// \t\tproto.insertBefore.call(newNodeParent, node, newNodeSibling)\n// \t}\n// },\n\n// prepend(node, ...nodes) {\n// \tif ([1,9,11].indexOf(node.nodeType) === -1) {\n// \t\treturn\n// \t}\n// \tconst tempFragment = document.createDocumentFragment()\n// \tnodes.reverse()\n// \tfor (let i of nodes) {\n// \t\tproto.appendChild.call(tempFragment, i)\n// \t}\n// \tif (node.firstChild) {\n// \t\tproto.insertBefore.call(node, tempFragment, node.firstChild)\n// \t} else {\n// \t\tproto.appendChild.call(node, tempFragment)\n// \t}\n// },\n\n// appendTo(node, newNode) {\n// \tproto.appendChild.call(newNode, node)\n// },\n\n// prependTo(node, newNode) {\n// \tif (newNode.firstChild) {\n// \t\tproto.insertBefore.call(newNode, node, node.firstChild)\n// \t} else {\n// \t\tproto.appendChild.call(newNode, node)\n// \t}\n// },\n\n// empty(node) {\n// \tnode.innerHTML = ''\n// },\n\nexport {DOM, EFFragment, mountingPointStore}\n","/* Get new events that works in all target browsers\n * though a little bit old-fashioned\n */\nconst getEvent = (name, {bubbles, cancelable} = {\n\tbubbles: false,\n\tcancelable: false\n}) => {\n\tconst event = document.createEvent('CustomEvent')\n\tevent.initEvent(name, bubbles, cancelable)\n\treturn event\n}\n\nexport default getEvent\n","import initBinding from './binding.js'\nimport {queue, inform, exec} from './render-queue.js'\nimport {resolvePath} from './resolver.js'\nimport ARR from './utils/array-helper.js'\nimport {EFFragment} from './utils/dom-helper.js'\nimport getEvent from './utils/event-helper.js'\nimport {mixVal} from './utils/literals-mix.js'\nimport dbg from './utils/debug.js'\n\nconst typeValid = obj => ['number', 'boolean', 'string'].indexOf(typeof obj) > -1\n\n// SVG/MathML tags w/ xlink attributes require specific namespace to work properly\nconst svgNS = 'http://www.w3.org/2000/svg'\nconst mathNS = 'http://www.w3.org/1998/Math/MathML'\nconst xlinkNS = 'http://www.w3.org/1999/xlink'\nconst createByTag = (tag, svg, custom) => {\n\t// First Custom component\n\tif (custom) return new tag()\n\t// Then SVG\n\tif (svg) return document.createElementNS(svgNS, tag)\n\t// Then MathML\n\tif (tag.toLowerCase() === 'math') return document.createElementNS(mathNS, tag)\n\t// Then HTML\n\treturn document.createElement(tag)\n}\n\nconst getElement = ({tag, ref, refs, svg, custom}) => {\n\tconst element = createByTag(tag, svg, custom)\n\tif (ref) Object.defineProperty(refs, ref, {\n\t\tvalue: element,\n\t\tenumerable: true\n\t})\n\treturn element\n}\n\nconst regTmpl = ({val, ctx, handlers, subscribers, innerData, handler}) => {\n\tif (Array.isArray(val)) {\n\t\tconst [strs, ...exprs] = val\n\t\tconst tmpl = [strs]\n\t\tconst _handler = () => handler(mixVal(...tmpl))\n\t\ttmpl.push(...exprs.map((item) => {\n\t\t\tconst {dataNode, handlerNode, _key} = initBinding({bind: item, ctx, handlers, subscribers, innerData})\n\t\t\thandlerNode.push(_handler)\n\t\t\treturn {dataNode, _key}\n\t\t}))\n\t\treturn _handler\n\t}\n\treturn () => val\n}\n\nconst updateOthers = ({parentNode, handlerNode, _handler, _key, value}) => {\n\t// Remove handler for this element temporarily\n\tARR.remove(handlerNode, _handler)\n\tinform()\n\tparentNode[_key] = value\n\texec()\n\t// Add back the handler\n\tARR.push(handlerNode, _handler)\n}\n\nconst addValListener = ({_handler, ctx, handlers, subscribers, innerData, element, key, expr, custom}) => {\n\tconst addListener = custom && '$on' || 'addEventListener'\n\tconst dispatch = custom && '$dispatch' || 'dispatchEvent'\n\tconst {parentNode, handlerNode, _key} = initBinding({bind: expr, ctx, handlers, subscribers, innerData})\n\tconst _update = () => updateOthers({parentNode, handlerNode, _handler, _key, value: element.value})\n\tif (key === 'value') {\n\t\t// Listen to input, keyup and change events in order to work in most browsers.\n\t\telement[addListener]('input', _update, true)\n\t\telement[addListener]('keyup', _update, true)\n\t\telement[addListener]('change', _update, true)\n\t\t// // Remove keyup and change listener if browser supports input event correctly\n\t\t// const removeListener = () => {\n\t\t// \telement.removeEventListener('input', removeListener, true)\n\t\t// \telement.removeEventListener('keyup', _update, true)\n\t\t// \telement.removeEventListener('change', _update, true)\n\t\t// }\n\t\t// element[addListener]('input', removeListener, true)\n\t} else {\n\t\telement[addListener]('change', () => {\n\t\t\t// Trigger change to the element it-self\n\t\t\telement[dispatch](getEvent('ef-change-event'), {bubbles: true, canceoable: false})\n\t\t\tif (element.tagName === 'INPUT' && element.type === 'radio' && element.name !== '') {\n\t\t\t\t// Trigger change to the the same named radios\n\t\t\t\tconst radios = document.querySelectorAll(`input[name=${element.name}][type=radio]`)\n\t\t\t\tif (radios) {\n\t\t\t\t\tconst selected = ARR.copy(radios)\n\t\t\t\t\tARR.remove(selected, element)\n\n\t\t\t\t\t/* Event triggering could cause unwanted render triggers\n\t\t\t\t\t * no better ways came up at the moment\n\t\t\t\t\t */\n\t\t\t\t\tfor (let i of selected) i.dispatchEvent(getEvent('ef-change-event'))\n\t\t\t\t}\n\t\t\t}\n\t\t}, true)\n\t\t// Use custom event to avoid loops and conflicts\n\t\telement[addListener]('ef-change-event', () => updateOthers({parentNode, handlerNode, _handler, _key, value: element.checked}))\n\t}\n}\n\nconst getAttrHandler = (element, key, custom) => {\n\t// Pass directly to custom component\n\tif (custom) return (val) => {\n\t\telement[key] = val\n\t}\n\n\t// Beautify class name\n\tif (key === 'class') return (val) => {\n\t\tval = `${val}`.replace(/\\s+/g, ' ').trim()\n\t\t// Remove attribute when value is empty\n\t\tif (!val) return element.removeAttribute(key)\n\t\telement.setAttribute(key, val)\n\t}\n\n\t// Handle xlink namespace\n\tif (key.indexOf('xlink:') === 0) return (val) => {\n\t\t// Remove attribute when value is empty\n\t\tif (val === '') return element.removeAttributeNS(xlinkNS, key)\n\t\telement.setAttributeNS(xlinkNS, key, val)\n\t}\n\n\treturn (val) => {\n\t\t// Remove attribute when value is empty\n\t\tif (val === '') return element.removeAttribute(key)\n\t\telement.setAttribute(key, val)\n\t}\n}\n\nconst addAttr = ({element, attr, key, ctx, handlers, subscribers, innerData, custom}) => {\n\tif (typeValid(attr)) {\n\t\tif (custom) {\n\t\t\telement[key] = attr\n\t\t\treturn\n\t\t}\n\t\t// Handle xlink namespace\n\t\tif (key.indexOf('xlink:') === 0) return element.setAttributeNS(xlinkNS, key, attr)\n\t\treturn element.setAttribute(key, attr)\n\t}\n\n\tconst handler = getAttrHandler(element, key, custom)\n\tqueue([regTmpl({val: attr, ctx, handlers, subscribers, innerData, handler})])\n}\n\nconst addProp = ({element, prop, key, ctx, handlers, subscribers, innerData, custom}) => {\n\tconst keyPath = key.split('.')\n\tconst lastKey = keyPath.pop()\n\tif (custom) keyPath.unshift('$data')\n\tconst lastNode = resolvePath(keyPath, element)\n\tif (typeValid(prop)) {\n\t\tlastNode[lastKey] = prop\n\t} else {\n\t\tconst handler = (val) => {\n\t\t\tlastNode[lastKey] = val\n\t\t}\n\t\tconst _handler = regTmpl({val: prop, ctx, handlers, subscribers, innerData, handler})\n\t\tif ((key === 'value' ||\n\t\t\tkey === 'checked') &&\n\t\t\t!prop[0]) addValListener({_handler, ctx, handlers, subscribers, innerData, element, key, expr: prop[1], custom})\n\t\tqueue([_handler])\n\t}\n}\n\n\nconst rawHandler = val => val\n\nconst addEvent = ({element, event, ctx, handlers, subscribers, innerData, custom}) => {\n\tconst addListener = custom && '$on' || 'addEventListener'\n\n\t/**\n\t *  l: listener                 : string\n\t *  m: method                   : string\n\t *  s: stopPropagation          : number/undefined\n\t *  i: stopImmediatePropagation : number/undefined\n\t *  p: preventDefault           : number/undefined\n\t *  h: shiftKey                 : number/undefined\n\t *  a: altKey                   : number/undefined\n\t *  c: ctrlKey                  : number/undefined\n\t *  t: metaKey                  : number/undefined\n\t *  u: capture                  : number/undefined\n\t *  k: keyCodes                 : array/undefined\n\t *  v: value                    : string/array/undefined\n\t */\n\tconst {l, m, s, i, p, h, a, c, t, u, k, v} = event\n\tconst _handler = regTmpl({val: v, ctx, handlers, subscribers, innerData, handler: rawHandler})\n\n\telement[addListener](l, (e) => {\n\t\tif (!!h !== !!e.shiftKey ||\n\t\t\t!!a !== !!e.altKey ||\n\t\t\t!!c !== !!e.ctrlKey ||\n\t\t\t!!t !== !!e.metaKey ||\n\t\t\t(k && k.indexOf(e.which) === -1)) return\n\t\tif (s) e.stopPropagation()\n\t\tif (i) e.stopImmediatePropagation()\n\t\tif (p) e.preventDefault()\n\t\tif (ctx.methods[m]) ctx.methods[m]({e, value: _handler(), state: ctx.state})\n\t\telse if (process.env.NODE_ENV !== 'production') dbg.warn(`Method named '${m}' not found! Value been passed is:`, _handler())\n\t}, !!u)\n}\n\nconst createElement = ({info, ctx, innerData, refs, handlers, subscribers, svg, fragment, custom}) => {\n\tif (fragment) return new EFFragment()\n\n\t/**\n\t *  t: tag       : class | string | int, 0 means fragment\n\t *  a: attr      : object\n\t *  p: prop      : object\n\t *  e: event     : array\n\t *  r: reference : string\n\t */\n\tconst {t, a, p, e, r} = info\n\tconst tag = ctx.scope[t] || t\n\tconst element = getElement({tag, ref: r, refs, svg, custom})\n\tfor (let key in a) addAttr({element, custom, attr: a[key], key, ctx, handlers, subscribers, innerData})\n\tfor (let key in p) addProp({element, custom, prop: p[key], key, ctx, handlers, subscribers, innerData})\n\tfor (let key in e) addEvent({element, custom, event: e[key], ctx, handlers, subscribers, innerData})\n\treturn element\n}\n\nexport default createElement\n","import createElement from './element-creator.js'\nimport {queue, inform, exec} from './render-queue.js'\nimport {DOM, mountingPointStore} from './utils/dom-helper.js'\nimport defineArr from './utils/dom-arr-helper.js'\nimport ARR from './utils/array-helper.js'\nimport typeOf from './utils/type-of.js'\nimport initBinding from './binding.js'\nimport mountOptions from '../mount-options.js'\n\nimport shared from './utils/global-shared.js'\n\nconst nullComponent = Object.create(null)\n\nconst checkDestroyed = (state) => {\n\tif (!state.$ctx) throw new Error('[EF] This component has been destroyed!')\n}\n\nconst bindTextNode = ({node, ctx, handlers, subscribers, innerData, element}) => {\n\t// Data binding text node\n\tconst textNode = document.createTextNode('')\n\tconst { dataNode, handlerNode, _key } = initBinding({bind: node, ctx, handlers, subscribers, innerData})\n\tconst handler = () => {\n\t\tconst value = dataNode[_key]\n\t\tif (typeof value === 'undefined') {\n\t\t\ttextNode.textContent = ''\n\t\t\treturn\n\t\t}\n\t\ttextNode.textContent = value\n\t}\n\thandlerNode.push(handler)\n\tqueue([handler])\n\n\t// Append element to the component\n\tDOM.append(element, textNode)\n}\n\nconst updateMountingNode = ({ctx, key, value}) => {\n\tconst {children} = ctx\n\tconst child = children[key]\n\tconst {anchor, node} = child\n\tif (node === value) return\n\n\tif (value instanceof Node) value = new shared.EFNodeWrapper(value)\n\telse if (!(value instanceof shared.EFBaseComponent)) value = new shared.EFTextFragment(`${value}`)\n\n\tinform()\n\t// Update component\n\tif (node) {\n\t\tif (value === nullComponent) value = null\n\t\telse node.$umount()\n\t}\n\t// Update stored value\n\tchild.node = value\n\tif (value) value.$mount({target: anchor, parent: ctx.state, option: mountOptions.BEFORE, key})\n\texec()\n}\n\nconst updateMountingList = ({ctx, key, value}) => {\n\tconst {children} = ctx\n\tconst {anchor, node} = children[key]\n\tif (ARR.equals(node, value)) return\n\tif (value) value = ARR.copy(value)\n\telse value = []\n\tconst fragment = document.createDocumentFragment()\n\t// Update components\n\tinform()\n\tif (node) {\n\t\tnode.clear()\n\t\tfor (let item of value) {\n\t\t\tif (item instanceof Node) item = new shared.EFNodeWrapper(item)\n\t\t\telse if (!(item instanceof shared.EFBaseComponent)) item = new shared.EFTextFragment(`${item}`)\n\t\t\tif (item.$ctx.nodeInfo.parent) item.$umount()\n\t\t\tDOM.append(fragment, item.$mount({parent: ctx.state, key}))\n\t\t}\n\t} else for (let item of value) DOM.append(fragment, item.$mount({parent: ctx.state, key}))\n\t// Update stored value\n\tnode.length = 0\n\tARR.push(node, ...value)\n\t// Append to current component\n\tDOM.after(anchor, fragment)\n\texec()\n}\n\nconst mountingPointUpdaters = [\n\tupdateMountingNode,\n\tupdateMountingList\n]\n\nconst applyMountingPoint = (type, key, tpl) => {\n\tObject.defineProperty(tpl.prototype, key, {\n\t\tget() {\n\t\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\t\treturn this.$ctx.children[key].node\n\t\t},\n\t\tset(value) {\n\t\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\t\tconst ctx = this.$ctx\n\t\t\tmountingPointUpdaters[type]({ctx, key, value})\n\t\t},\n\t\tenumerable: true\n\t})\n}\n\nconst bindMountingNode = ({ctx, key, anchor}) => {\n\tconst {children, isFragment} = ctx\n\tchildren[key] = {anchor}\n\tif (isFragment) {\n\t\tDOM.append(ctx.safeZone, anchor)\n\t\tmountingPointStore.set(anchor, children[key])\n\t}\n}\n\nconst bindMountingList = ({ctx, key, anchor}) => {\n\tconst {children, isFragment} = ctx\n\tchildren[key] = {\n\t\tnode: defineArr([], {ctx, key, anchor}),\n\t\tanchor\n\t}\n\tif (isFragment) {\n\t\tDOM.append(ctx.safeZone, anchor)\n\t\tmountingPointStore.set(anchor, children[key])\n\t}\n}\n\n// Walk through the AST to perform proper actions\nconst resolveAST = ({node, nodeType, element, ctx, innerData, refs, handlers, subscribers, svg, create}) => {\n\tswitch (nodeType) {\n\t\t// Static text node\n\t\tcase 'string': {\n\t\t\tDOM.append(element, document.createTextNode(node))\n\t\t\tbreak\n\t\t}\n\t\t// Child element or a dynamic text node\n\t\tcase 'array': {\n\t\t\t// Recursive call for child element\n\t\t\tif (typeOf(node[0]) === 'object') DOM.append(element, create({node, ctx, innerData, refs, handlers, subscribers, svg}))\n\t\t\t// Dynamic text node\n\t\t\telse bindTextNode({node, ctx, handlers, subscribers, innerData, element})\n\t\t\tbreak\n\t\t}\n\t\t// Mounting points\n\t\tcase 'object': {\n\t\t\tconst anchor = document.createTextNode('')\n\t\t\t// Single node mounting point\n\t\t\tif (node.t === 0) bindMountingNode({ctx, key: node.n, anchor})\n\t\t\t// Multi node mounting point\n\t\t\telse bindMountingList({ctx, key: node.n, anchor})\n\t\t\t// Append anchor\n\t\t\tif (process.env.NODE_ENV !== 'production') DOM.append(element, document.createComment(`EF MOUNTING POINT '${node.n}' START`))\n\t\t\tDOM.append(element, anchor)\n\t\t\tif (process.env.NODE_ENV !== 'production') DOM.append(element, document.createComment(`EF MOUNTING POINT '${node.n}' END`))\n\t\t\tbreak\n\t\t}\n\t\tdefault:\n\t}\n}\n\n// Create elements based on description from AST\nconst create = ({node, ctx, innerData, refs, handlers, subscribers, svg}) => {\n\tconst [info, ...childNodes] = node\n\tconst fragment = info.t === 0\n\tconst custom = Object.isPrototypeOf.call(shared.EFBaseComponent, ctx.scope[info.t] || info.t)\n\t// Enter SVG mode\n\tif (!fragment && !svg && info.t.toLowerCase() === 'svg') svg = true\n\t// First create an element according to the description\n\tconst element = createElement({info, ctx, innerData, refs, handlers, subscribers, svg, fragment, custom})\n\tif (fragment && process.env.NODE_ENV !== 'production') element.push(document.createComment('EF FRAGMENT START'))\n\n\t// Leave SVG mode if tag is `foreignObject`\n\tif (svg && info.t.toLowerCase() === 'foreignobject') svg = false\n\n\t// Append child nodes\n\tfor (let node of childNodes) {\n\t\tif (node instanceof shared.EFBaseComponent) node.$mount({target: element})\n\t\telse resolveAST({node, nodeType: typeOf(node), element, ctx, innerData, refs, handlers, subscribers, svg, create})\n\t}\n\tif (fragment && process.env.NODE_ENV !== 'production') element.push(document.createComment('EF FRAGMENT END'))\n\n\treturn element\n}\n\nexport {create, nullComponent, checkDestroyed, applyMountingPoint}\n","import {DOM} from './dom-helper.js'\nimport ARR from './array-helper.js'\nimport {inform, exec} from '../render-queue.js'\n\nconst DOMARR = {\n\tempty() {\n\t\tinform()\n\t\tfor (let i of ARR.copy(this)) i.$destroy()\n\t\texec()\n\t\tARR.empty(this)\n\t},\n\tclear() {\n\t\tinform()\n\t\tfor (let i of ARR.copy(this)) i.$umount()\n\t\texec()\n\t\tARR.empty(this)\n\t},\n\tpop() {\n\t\tif (this.length === 0) return\n\t\tconst poped = ARR.pop(this)\n\t\tpoped.$umount()\n\t\treturn poped\n\t},\n\tpush({ctx, key, anchor}, ...items) {\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of items) ARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\tif (this.length === 0) DOM.after(anchor, ...elements)\n\t\telse DOM.after(this[this.length - 1].$ctx.nodeInfo.placeholder, ...elements)\n\t\texec()\n\t\treturn ARR.push(this, ...items)\n\t},\n\tremove(item) {\n\t\tif (this.indexOf(item) === -1) return\n\t\titem.$umount()\n\t\treturn item\n\t},\n\treverse({ctx, key, anchor}) {\n\t\tif (this.length === 0) return this\n\t\tconst tempArr = ARR.copy(this)\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i = tempArr.length - 1; i >= 0; i--) {\n\t\t\ttempArr[i].$umount()\n\t\t\tARR.push(elements, tempArr[i].$mount({parent: ctx.state, key}))\n\t\t}\n\t\tARR.push(this, ...ARR.reverse(tempArr))\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn this\n\t},\n\tshift() {\n\t\tif (this.length === 0) return\n\t\tconst shifted = ARR.shift(this)\n\t\tshifted.$umount()\n\t\treturn shifted\n\t},\n\tsort({ctx, key, anchor}, fn) {\n\t\tif (this.length === 0) return this\n\t\tconst sorted = ARR.copy(ARR.sort(this, fn))\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of sorted) {\n\t\t\ti.$umount()\n\t\t\tARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\t}\n\t\tARR.push(this, ...sorted)\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn this\n\t},\n\tsplice(...args) {\n\t\tif (this.length === 0) return this\n\t\tconst spliced = ARR.splice(ARR.copy(this), ...args)\n\t\tinform()\n\t\tfor (let i of spliced) i.$umount()\n\t\texec()\n\t\treturn spliced\n\t},\n\tunshift({ctx, key, anchor}, ...items) {\n\t\tif (this.length === 0) return this.push(...items).length\n\t\tconst elements = []\n\t\tinform()\n\t\tfor (let i of items) ARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\tDOM.after(anchor, ...elements)\n\t\texec()\n\t\treturn ARR.unshift(this, ...items)\n\t}\n}\n\nconst defineArr = (arr, info) => {\n\tObject.defineProperties(arr, {\n\t\tempty: {value: DOMARR.empty},\n\t\tclear: {value: DOMARR.clear},\n\t\tpop: {value: DOMARR.pop},\n\t\tpush: {value: DOMARR.push.bind(arr, info)},\n\t\tremove: {value: DOMARR.remove},\n\t\treverse: {value: DOMARR.reverse.bind(arr, info)},\n\t\tshift: {value: DOMARR.shift},\n\t\tsort: {value: DOMARR.sort.bind(arr, info)},\n\t\tsplice: {value: DOMARR.splice},\n\t\tunshift: {value: DOMARR.unshift.bind(arr, info)}\n\t})\n\treturn arr\n}\n\nexport default defineArr\n","const getGetter = ({base, key}, {checkTrue, get, set}) => {\n\tif (get) {\n\t\tif (!set) throw new Error('Setter must be defined when getter exists')\n\t\treturn get\n\t}\n\n\tif (checkTrue) return function() {\n\t\treturn checkTrue(base(this)[key], this)\n\t}\n\n\treturn function() {\n\t\treturn base(this)[key]\n\t}\n}\n\nconst getSetter = ({base, key}, {checkTrue, trueVal, falseVal, get, set}) => {\n\tif (set) {\n\t\tif (!get) throw new Error('Getter must be defined when setter exists')\n\t\treturn set\n\t}\n\n\tif (checkTrue) return function(val) {\n\t\tconst baseNode = base(this)\n\t\tconst _trueVal = trueVal\n\t\tconst _falseVal = falseVal\n\n\t\tif (typeof trueVal !== 'function') trueVal = () => _trueVal\n\t\tif (typeof falseVal !== 'function') falseVal = () => _falseVal\n\n\t\tif (val) baseNode[key] = trueVal(this)\n\t\telse baseNode[key] = falseVal(this)\n\t}\n\n\treturn function(val) {\n\t\tbase(this)[key] = val\n\t}\n}\n\nconst defaultRoot = state => state.$data\nconst getBase = (root) => {\n\tif (!root) return defaultRoot\n\tif (typeof root === 'function') return root\n\tif (typeof root === 'string') root = root.split('.')\n\treturn (base) => {\n\t\tfor (let key of root) base = base[key]\n\t\treturn base\n\t}\n}\n\nconst registerProps = (tpl, propMap) => {\n\tfor (let prop in propMap) {\n\n\t\t/* Options:\n\t\t * key: key on root, default to prop\n\t\t * base: a function that returns the base of the key, default returns $data\n\t\t * trueVal: value when true, only used when checkTrue is set\n\t\t * falseVal: value when false, only used when checkTrue is set\n\t\t * checkTrue: a function returns true or false based on input value\n\t\t * get: getter, will ignore all other settings except set\n\t\t * set: setter, will ignore all other settings except get\n\t\t */\n\t\tconst options = propMap[prop]\n\n\t\tconst base = getBase(options.base)\n\t\tconst key = options.key || prop\n\n\t\tconst basicProperty = {base, key}\n\n\t\tconst get = getGetter(basicProperty, options)\n\t\tconst set = getSetter(basicProperty, options)\n\n\t\tObject.defineProperty(tpl.prototype, prop, {\n\t\t\tget,\n\t\t\tset,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false\n\t\t})\n\t}\n\n\treturn tpl\n}\n\nexport default registerProps\n","const mountOptions = {\n\tBEFORE: 'before',\n\tAFTER: 'after',\n\tAPPEND: 'append',\n\tREPLACE: 'replace'\n}\n\nexport default mountOptions\n","import {create, nullComponent, checkDestroyed} from './creator.js'\nimport initBinding from './binding.js'\nimport {queueDom, inform, exec} from './render-queue.js'\nimport {resolveSubscriber} from './resolver.js'\nimport registerProps from './register-props.js'\nimport {DOM, EFFragment, mountingPointStore} from './utils/dom-helper.js'\nimport ARR from './utils/array-helper.js'\nimport {assign, legacyAssign} from './utils/polyfills.js'\nimport isInstance from './utils/fast-instance-of.js'\nimport typeOf from './utils/type-of.js'\nimport {enumerableFalse} from './utils/buble-fix.js'\nimport dbg from './utils/debug.js'\nimport getEvent from './utils/event-helper.js'\nimport mountOptions from '../mount-options.js'\n\nimport shared from './utils/global-shared.js'\n\nconst unsubscribe = (pathStr, fn, subscribers) => {\n\tconst subscriberNode = resolveSubscriber(pathStr, subscribers)\n\tARR.remove(subscriberNode, fn)\n}\n\nconst EFBaseComponent = class {\n\tconstructor(ast, scope = {}) {\n\t\tconst children = {}\n\t\tconst refs = {}\n\t\tconst data = {}\n\t\tconst innerData = {}\n\t\tconst methods = {}\n\t\tconst handlers = {}\n\t\tconst subscribers = {}\n\t\tconst nodeInfo = {\n\t\t\tplaceholder: null,\n\t\t\treplace: [],\n\t\t\tparent: null,\n\t\t\tkey: null\n\t\t}\n\n\t\t/* Detatched components will be put in the safe zone.\n\t\t * Split safe zone to each component in order to make\n\t\t * the component memory recycleable when lost reference\n\t\t */\n\t\tconst safeZone = document.createDocumentFragment()\n\n\t\tif (process.env.NODE_ENV === 'production') nodeInfo.placeholder = document.createTextNode('')\n\t\telse nodeInfo.placeholder = document.createComment('EF COMPONENT PLACEHOLDER')\n\n\t\tconst mount = () => {\n\t\t\tif (nodeInfo.replace.length > 0) {\n\t\t\t\tfor (let i of nodeInfo.replace) DOM.remove(i)\n\t\t\t\tARR.empty(nodeInfo.replace)\n\t\t\t}\n\t\t\tDOM.before(nodeInfo.placeholder, nodeInfo.element)\n\t\t}\n\n\t\tconst ctx = {\n\t\t\tscope, mount, refs, data, innerData, methods,\n\t\t\thandlers, subscribers, nodeInfo, safeZone,\n\t\t\tchildren, state: this, isFragment: ast[0].t === 0\n\t\t}\n\n\t\tObject.defineProperty(this, '$ctx', {\n\t\t\tvalue: ctx,\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true\n\t\t})\n\n\t\tinform()\n\n\t\tnodeInfo.element = create({node: ast, ctx, innerData, refs, handlers, subscribers, svg: false})\n\t\tDOM.append(safeZone, nodeInfo.placeholder)\n\t\tqueueDom(mount)\n\t\texec()\n\t}\n\n\tget $data() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.data\n\t}\n\n\tset $data(newData) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tinform()\n\t\tassign(this.$ctx.data, newData)\n\t\texec()\n\t}\n\n\tget $methods() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.methods\n\t}\n\n\tset $methods(newMethods) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tthis.$ctx.methods = newMethods\n\t}\n\n\tget $refs() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.refs\n\t}\n\n\t$mount({target, option, parent, key}) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, mount } = this.$ctx\n\t\tif (typeof target === 'string') target = document.querySelector(target)\n\n\t\tinform()\n\t\tif (nodeInfo.parent) {\n\t\t\tthis.$umount()\n\t\t\tif (process.env.NODE_ENV !== 'production') dbg.warn('Component detached from previous mounting point.')\n\t\t}\n\n\t\tif (!parent) parent = target\n\t\tif (!key) key = '__DIRECTMOUNT__'\n\t\tnodeInfo.parent = parent\n\t\tnodeInfo.key = key\n\t\tqueueDom(mount)\n\n\t\tif (!target) {\n\t\t\texec()\n\t\t\treturn nodeInfo.placeholder\n\t\t}\n\n\t\tswitch (option) {\n\t\t\tcase mountOptions.BEFORE: {\n\t\t\t\tDOM.before(target, nodeInfo.placeholder)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase mountOptions.AFTER: {\n\t\t\t\tDOM.after(target, nodeInfo.placeholder)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase mountOptions.REPLACE: {\n\t\t\t\tDOM.before(target, nodeInfo.placeholder)\n\t\t\t\tnodeInfo.replace.push(target)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcase mountOptions.APPEND:\n\t\t\tdefault: {\n\t\t\t\t// Parent is EFFragment should only happen when using jsx\n\t\t\t\tif (isInstance(parent, EFFragment)) DOM.append(target, nodeInfo.element)\n\t\t\t\telse DOM.append(target, nodeInfo.placeholder)\n\t\t\t}\n\t\t}\n\t\treturn exec()\n\t}\n\n\t$umount() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, safeZone, mount } = this.$ctx\n\t\tconst { parent, key } = nodeInfo\n\t\tnodeInfo.parent = null\n\t\tnodeInfo.key = null\n\n\t\tinform()\n\t\tif (parent) {\n\t\t\tif (key !== '__DIRECTMOUNT__') {\n\t\t\t\tif (parent[key]) {\n\t\t\t\t\tif (Array.isArray(parent[key])) {\n\t\t\t\t\t\t// Remove self from parent list mounting point\n\t\t\t\t\t\tARR.remove(parent[key], this)\n\t\t\t\t\t} else parent[key] = nullComponent\n\t\t\t\t}\n\t\t\t// Else Remove elements from fragment parent\n\t\t\t} else if (isInstance(parent, EFFragment)) ARR.remove(parent.$ctx.nodeInfo.element, nodeInfo.element)\n\t\t}\n\t\tDOM.append(safeZone, nodeInfo.placeholder)\n\t\tqueueDom(mount)\n\t\treturn exec()\n\t}\n\n\t$subscribe(pathStr, subscriber) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst ctx = this.$ctx\n\t\tconst { handlers, subscribers, innerData } = ctx\n\t\tconst _path = pathStr.split('.')\n\t\tconst { dataNode, subscriberNode, _key } = initBinding({bind: [_path], ctx, handlers, subscribers, innerData})\n\t\tinform()\n\t\t// Execute the subscriber function immediately\n\t\ttry {\n\t\t\tsubscriber({state: this, value: dataNode[_key]})\n\t\t\t// Put the subscriber inside the subscriberNode\n\t\t\tsubscriberNode.push(subscriber)\n\t\t} catch (e) {\n\t\t\tdbg.error('Error caught when registering subscriber:\\n', e)\n\t\t}\n\t\texec()\n\t}\n\n\t$unsubscribe(pathStr, fn) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { subscribers } = this.$ctx\n\t\tunsubscribe(pathStr, fn, subscribers)\n\t}\n\n\t$update(newState) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tinform()\n\t\tlegacyAssign(this, newState)\n\t\texec()\n\t}\n\n\t$dispatch(event) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tthis.$ctx.nodeInfo.placeholder.dispatchEvent(event)\n\t}\n\n\t$emit(event, options) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tthis.$dispatch(getEvent(event, options))\n\t}\n\n\t$on(...args) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tthis.$ctx.nodeInfo.placeholder.addEventListener(...args)\n\t}\n\n\t$off(...args) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\t\tthis.$ctx.nodeInfo.placeholder.removeEventListener(...args)\n\t}\n\n\t$destroy() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, isFragment, children } = this.$ctx\n\t\tinform()\n\t\tthis.$umount()\n\t\tif (isFragment) for (let i in children) mountingPointStore.delete(children[i].anchor)\n\t\t// Detatch all mounted components\n\t\tfor (let i in this) {\n\t\t\tif (typeOf(this[i]) === 'array') this[i].clear()\n\t\t\telse this[i] = null\n\t\t}\n\t\t// Remove context\n\t\tdelete this.$ctx\n\t\t// Push DOM removement operation to query\n\t\tqueueDom(() => {\n\t\t\tDOM.remove(nodeInfo.element)\n\t\t\tDOM.remove(nodeInfo.placeholder)\n\t\t})\n\t\t// Render\n\t\treturn exec()\n\t}\n}\n\nconst fragmentAST = [{t: 0}]\nconst EFNodeWrapper = class extends EFBaseComponent {\n\tconstructor(...nodes) {\n\t\tsuper(fragmentAST)\n\t\t// Use parens to bypass ESLint's semicolon check\n\t\t// Semi is needed for preventing Buble's bug\n\t\t;(this).$ctx.nodeInfo.element.push(...nodes)\n\t\tthis.$ctx.elements = nodes\n\t}\n\n\tget $el() {\n\t\treturn this.$ctx.elements\n\t}\n}\n\nconst Fragment = class extends EFBaseComponent {\n\tconstructor(...children) {\n\t\tsuper([{t: 0}, ...children])\n\t}\n}\n\n// Make a helper component for text fragments\nconst textFragmentAst = [{t: 0},[['text']]]\nconst EFTextFragment = class extends EFBaseComponent {\n\tconstructor(text) {\n\t\tinform()\n\t\tsuper(textFragmentAst)\n\t\tthis.text = text\n\t\texec()\n\t}\n}\nregisterProps(EFTextFragment, {text: {}})\n\nenumerableFalse(EFBaseComponent, ['$mount', '$umount', '$subscribe', '$unsubscribe', '$update', '$dispatch', '$emit', '$on', '$off', '$destroy'])\nenumerableFalse(EFNodeWrapper, ['$el'])\n\nshared.EFBaseComponent = EFBaseComponent\nshared.EFNodeWrapper = EFNodeWrapper\nshared.EFTextFragment = EFTextFragment\nshared.Fragment = Fragment\n\nexport {EFBaseComponent, EFNodeWrapper, EFTextFragment, Fragment}\n","import {EFBaseComponent, EFTextFragment, Fragment} from './renderer.js'\nimport {assign} from './utils/polyfills.js'\n\nconst textToFragment = (value) => {\n\tif (typeof value === 'string') return new EFTextFragment(value)\n\treturn value\n}\n\nconst createElement = (tag, attrs, ...children) => {\n\t// Create special component for fragment\n\tif (tag === Fragment) return new Fragment(...children)\n\n\t// Create an instance if tag is an ef class\n\tif (Object.isPrototypeOf.call(EFBaseComponent, tag)) {\n\t\tif (children.length <= 0) return new tag(attrs)\n\t\treturn new tag(assign({children: children.map(textToFragment)}, attrs || {}))\n\t}\n\n\t// Else return the generated basic component\n\t// Transform all label only attributes to ef-supported style\n\tconst transformedAttrs = assign({}, attrs)\n\tfor (let i in transformedAttrs) {\n\t\tif (transformedAttrs[i] === true) transformedAttrs[i] = ''\n\t}\n\n\treturn new EFBaseComponent([\n\t\t{\n\t\t\tt: tag,\n\t\t\ta: transformedAttrs\n\t\t},\n\t\t...children\n\t])\n}\n\nexport default createElement\n","// Import everything\nimport parse from './lib/parser.js'\nimport typeOf from 'ef-core/src/lib/utils/type-of.js'\nimport { mixStr } from 'ef-core/src/lib/utils/literals-mix.js'\nimport parseEft from 'eft-parser'\nimport { version } from '../package.json'\n// Import core components\nimport {\n\tcreate as createComponent,\n\tcreateElement,\n\tregisterProps,\n\tEFNodeWrapper,\n\tEFTextFragment,\n\tFragment,\n\tscoped,\n\tonNextRender,\n\tinform,\n\texec,\n\tbundle,\n\tisPaused,\n\tmountOptions\n} from 'ef-core'\n\n// Set parser\nlet parser = parseEft\n\nconst create = (value) => {\n\tconst valType = typeOf(value)\n\tif (valType === 'string') value = parse(value, parser)\n\telse if (valType !== 'array') throw new TypeError('Cannot create new component without proper template or AST!')\n\n\treturn createComponent(value)\n}\n\n// Change parser\nconst setParser = (newParser) => {\n\tparser = newParser\n}\n\nconst t = (...args) => create(mixStr(...args))\n\nexport {\n\tt,\n\tcreate,\n\tcreateElement,\n\tregisterProps,\n\tEFNodeWrapper,\n\tEFTextFragment,\n\tFragment,\n\tscoped,\n\tonNextRender,\n\tinform,\n\texec,\n\tbundle,\n\tisPaused,\n\tsetParser,\n\tparseEft,\n\tmountOptions,\n\tversion\n}\n\nif (process.env.NODE_ENV !== 'production') console.info(`[EF] ef.js v${version} initialized!`)\n","// Import everything\nimport {EFBaseComponent, EFNodeWrapper, EFTextFragment, Fragment} from './lib/renderer.js'\nimport {applyMountingPoint} from './lib/creator.js'\nimport mountOptions from './mount-options.js'\nimport createElement from './lib/jsx-create-element.js'\nimport registerProps from './lib/register-props.js'\nimport {onNextRender, inform, exec, bundle, isPaused} from './lib/render-queue.js'\nimport dbg from './lib/utils/debug.js'\nimport typeOf from './lib/utils/type-of.js'\nimport scoped from './lib/utils/scoped-component.js'\nimport {version} from '../package.json'\n\n// Apply mounting point properties for classes\nconst applyMountingPoints = (node, tpl) => {\n\tconst nodeType = typeOf(node)\n\tswitch (nodeType) {\n\t\tcase 'array': {\n\t\t\tconst [info, ...childNodes] = node\n\t\t\tif (typeOf(info) === 'object') for (let i of childNodes) applyMountingPoints(i, tpl)\n\t\t\tbreak\n\t\t}\n\t\tcase 'object': {\n\t\t\tif (node.t > 1) throw new TypeError(`[EF] Not a standard ef.js AST: Unknown mounting point type '${node.t}'`)\n\t\t\tapplyMountingPoint(node.t, node.n, tpl)\n\t\t\tbreak\n\t\t}\n\t\tcase 'string': {\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\tthrow new TypeError(`[EF] Not a standard ef.js AST: Unknown node type '${nodeType}'`)\n\t\t}\n\t}\n}\n\n// Return a brand new class for the new component\nconst create = (value) => {\n\tconst ast = value\n\tconst EFComponent = class extends EFBaseComponent {\n\t\tconstructor(newState, scope) {\n\t\t\tinform()\n\t\t\tsuper(ast, scope)\n\t\t\tif (newState) this.$update(newState)\n\t\t\texec()\n\t\t}\n\t}\n\tapplyMountingPoints(ast, EFComponent)\n\n\t// Workaround for a bug of buble\n\t// https://github.com/bublejs/buble/issues/197\n\tObject.defineProperty(EFComponent.prototype, 'constructor', {enumerable: false})\n\treturn EFComponent\n}\n\nexport {create, registerProps, createElement, EFNodeWrapper, EFTextFragment, Fragment, scoped, onNextRender, inform, exec, bundle, isPaused, mountOptions, version}\n\nif (process.env.NODE_ENV !== 'production') dbg.info(`ef-core v${version} initialized!`)\n","import eftParser from 'eft-parser'\n\nconst parse = (template, parser) => {\n\tif (!parser) parser = eftParser\n\treturn parser(template)\n}\n\nexport default parse\n","const scoped = (component, initScope) => class extends component {\n\tconstructor(state, scope = initScope) {\n\t\tsuper(state, scope)\n\t}\n}\n\nexport default scoped\n"],"names":["O2C","SyntaxError","UC2C","val","substr","length","parseInt","String","fromCodePoint","err","U2C","substring","fromCharCode","X2C","efEscape","string","const","escaped","split","doubleChar","let","escapedStr","replace","oct","ucp","uni","hex","b","t","n","v","f","r","esc","push","join","char","splitWith","escapedSplit","i","splitBy","splitArr","shift","getErrorMsg","msg","line","checkValidType","obj","indexOf","ESCAPE","parsed","JSON","parse","e","splitDefault","slice","pathArr","_path","trim","map","_default","defaultVal","splitLiterals","strs","mustache","tmpl","mustaches","match","pushStr","textArr","str","parseText","result","exprs","dotToSpace","parseNodeProps","splited","name","value","getOption","options","keys","option","keyCode","isNaN","s","p","h","a","c","u","console","warn","setOption","parseLine","parsingInfo","offset","offsetReg","trimmedLine","removed","prevDepth","removeOffset","indentReg","spaces","spaceIndent","RegExp","getIndent","content","escapedName","tagInfo","depth","test","getDepth","prevType","topExists","type","currentNode","ast","resolveDepth","info","hashref","ref","tag","class","newNode","l","listener","ops","k","getEventOptions","m","method","_value","reserved","parseEft","template","TypeError","tplType","lines","Array","isArray","Object","hasOwnProperty","call","typeOf","mixStr","getVal","data","proto","prototype","ARR","copy","arr","empty","equals","left","right","pop","apply","items","remove","item","index","splice","reverse","rightUnique","newArr","j","sort","fn","args","unshift","window","Set","from","unique","queue","handlers","modificationQueue","queueDom","handler","domQueue","inform","count","execUserQueue","userQueue","userFnQueue","exec","immediate","renderQueue","execModifications","domRenderQueue","execDomModifications","setTimeout","legacyAssign","ee","er","defineNode","key","node","defineProperty","get","set","assign","configurable","enumerable","resolve","parentNode","resolveReactivePath","subscribers","innerData","handlerNode","subscriberNode","dataNode","resolveAllPath","_key","undefined","isnan","initBinding","subscriberExecuting","bind","ctx","subscriber","state","dbg","error","isInstance","constructor","enumerableFalse","classObj","strTpl","log","shared","Node","mountingPointStore","WeakMap","DOM","EFFragment","appendTo","self","append","this","before","tempFragment","document","createDocumentFragment","nodes","EFBaseComponent","$mount","target","appendChild","insertBefore","after","nextSibling","handleMountingPoint","mountingPoint","clear","$ctx","nodeInfo","element","placeholder","children","EFNodeWrapper","nodeType","$umount","removeChild","getEvent","bubbles","cancelable","event","createEvent","initEvent","typeValid","getElement","svg","custom","createElementNS","toLowerCase","createElement","refs","regTmpl","_handler","updateOthers","addAttr","attr","setAttributeNS","xlinkNS","setAttribute","removeAttribute","removeAttributeNS","addProp","keyPath","lastKey","addListener","dispatch","lastNode","resolvePath","prop","expr","_update","canceoable","tagName","radios","querySelectorAll","selected","dispatchEvent","checked","rawHandler","addEvent","shiftKey","altKey","ctrlKey","metaKey","which","stopPropagation","stopImmediatePropagation","preventDefault","methods","bindTextNode","textNode","textContent","createTextNode","bindMountingList","anchor","defineProperties","DOMARR","isFragment","safeZone","resolveAST","create","getGetter","Error","checkTrue","base","getSetter","baseNode","_trueVal","trueVal","_falseVal","falseVal","defaultRoot","$data","getBase","root","registerProps","tpl","propMap","basicProperty","$destroy","poped","elements","parent","tempArr","shifted","sorted","spliced","mountOptions","BEFORE","AFTER","APPEND","REPLACE","nullComponent","mountingPointUpdaters","child","EFTextFragment","fragment","isPrototypeOf","scope","childNodes","mount","prototypeAccessors","newData","$methods","newMethods","$refs","querySelector","$subscribe","pathStr","$unsubscribe","resolveSubscriber","$update","newState","$dispatch","$emit","$on","addEventListener","$off","removeEventListener","delete","fragmentAST","super","prototypeAccessors$1","$el","Fragment","textFragmentAst","text","textToFragment","EFComponent","valType","parser","eftParser","applyMountingPoints","cb","attrs","transformedAttrs","component","initScope","newParser"],"mappings":"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"}