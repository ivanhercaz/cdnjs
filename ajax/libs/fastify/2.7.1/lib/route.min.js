"use strict";const FindMyWay=require("find-my-way"),proxyAddr=require("proxy-addr"),Context=require("./context"),{buildMiddie:buildMiddie,onRunMiddlewares:onRunMiddlewares}=require("./middleware"),{hookRunner:hookRunner,hookIterator:hookIterator}=require("./hooks"),supportedMethods=["DELETE","GET","HEAD","PATCH","POST","PUT","OPTIONS"],validation=require("./validation"),buildSchema=validation.build,{buildSchemaCompiler:buildSchemaCompiler}=validation,{beforeHandlerWarning:beforeHandlerWarning}=require("./warnings"),{kRoutePrefix:kRoutePrefix,kLogLevel:kLogLevel,kHooks:kHooks,kSchemas:kSchemas,kSchemaCompiler:kSchemaCompiler,kContentTypeParser:kContentTypeParser,kReply:kReply,kReplySerializerDefault:kReplySerializerDefault,kRequest:kRequest,kMiddlewares:kMiddlewares,kGlobalHooks:kGlobalHooks,kDisableRequestLogging:kDisableRequestLogging}=require("./symbols.js");function buildRouting(e){const o=FindMyWay(e.config),r=new Map;let t,n,i,l,s,a,d,u,h,c,p,f,m,g,k,y;r.put=r.set;let b=!1;return{setup(e,o){t=o.avvio,n=o.fourOhFour,d=o.logger,u=o.hasLogger,h=o.setupResponseListeners,c=o.throwIfAlreadyStarted,p=getTrustProxyFn(e),i=e.trustProxy,l=e.requestIdHeader,s=e.querystringParser,a=e.requestIdLogLabel,f=e.modifyCoreObjects,m=e.genReqId,g=e.disableRequestLogging,k=e.ignoreTrailingSlash,y=!Object.prototype.hasOwnProperty.call(e,"return503OnClosing")||e.return503OnClosing},routing:o.lookup.bind(o),route:R,prepareRoute:function(e,o,r,t){if(t||"function"!=typeof r){if(t&&"function"==typeof t){if("[object Object]"!==Object.prototype.toString.call(r))throw new Error(`Options for ${e}:${o} route must be an object`);if(r.handler)throw"function"==typeof r.handler?new Error(`Duplicate handler for ${e}:${o} route is not allowed!`):new Error(`Handler for ${e}:${o} route must be a function`)}}else t=r,r={};return r=Object.assign({},r,{method:e,url:o,handler:t||r&&r.handler}),R.call(this,r)},routeHandler:w,closeRoutes:()=>{b=!0},printRoutes:o.prettyPrint.bind(o)};function R(e){if(c("Cannot add route when fastify instance is already started!"),Array.isArray(e.method)){for(var i=0;i<e.method.length;i++)if(-1===supportedMethods.indexOf(e.method[i]))throw new Error(`${e.method[i]} method is not supported!`)}else if(-1===supportedMethods.indexOf(e.method))throw new Error(`${e.method} method is not supported!`);if(!e.handler)throw new Error(`Missing handler function for ${e.method}:${e.url} route.`);validateBodyLimitOption(e.bodyLimit),null==e.preHandler&&null!=e.beforeHandler&&(beforeHandlerWarning(),e.preHandler=e.beforeHandler);const l=this[kRoutePrefix];return this.after((o,r)=>{var t=e.url||e.path;if("/"===t&&l.length>0)switch(e.prefixTrailingSlash){case"slash":s.call(this,t,o,r);break;case"no-slash":s.call(this,"",o,r);break;case"both":default:s.call(this,"",o,r),!0!==k&&s.call(this,t,o,r)}else"/"===t[0]&&l.endsWith("/")?s.call(this,t.slice(1),o,r):s.call(this,t,o,r)}),this;function s(i,s,a){const d=l+i;e.url=d,e.path=d,e.prefix=l,e.logLevel=e.logLevel||this[kLogLevel],null==e.attachValidation&&(e.attachValidation=!1);for(const o of this[kGlobalHooks].onRoute)try{o.call(this,e)}catch(e){return void a(e)}const u=e.config||{};u.url=d;const h=new Context(e.schema,e.handler.bind(this),this[kReply],this[kRequest],this[kContentTypeParser],u,this._errorHandler,e.bodyLimit,e.logLevel,e.attachValidation,this[kReplySerializerDefault]);if(e.schema)try{if(null==e.schemaCompiler&&null==this[kSchemaCompiler]){const e=this[kSchemas].getJsonSchemas({onlyAbsoluteUri:!0});this.setSchemaCompiler(buildSchemaCompiler(e,r))}buildSchema(h,e.schemaCompiler||this[kSchemaCompiler],this[kSchemas])}catch(e){return void a(e)}const c=["preParsing","preValidation","onRequest","preHandler","preSerialization"];for(const o of c)e[o]&&(Array.isArray(e[o])?e[o]=e[o].map(e=>e.bind(this)):e[o]=e[o].bind(this));try{o.on(e.method,d,{version:e.version},w,h)}catch(e){return void a(e)}t.once("preReady",()=>{const o=this[kHooks].onResponse,r=this[kHooks].onSend,t=this[kHooks].onError;h.onSend=r.length?r:null,h.onError=t.length?t:null,h.onResponse=o.length?o:null;for(const o of c){const r=this[kHooks][o].concat(e[o]||[]);h[o]=r.length?r:null}h._middie=buildMiddie(this[kMiddlewares]),n.setContext(this,h)}),a(s)}}function w(e,o,r,t){if(!0===b&&(2!==e.httpVersionMajor&&(o.once("finish",()=>e.destroy()),o.setHeader("Connection","close")),y)){const e={"Content-Type":"application/json","Content-Length":"80"};return o.writeHead(503,e),void o.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}')}e.id=e.headers[l]||m(e),e.originalUrl=e.url;var n,c=e.headers.host,k=e.connection.remoteAddress;i&&(k=proxyAddr(e,p),n=proxyAddr.all(e,p),void 0!==k&&e.headers["x-forwarded-host"]&&(c=e.headers["x-forwarded-host"]));var R=d.child({[a]:e.id,level:t.logLevel});R[kDisableRequestLogging]=g,f&&(e.hostname=c,e.ip=k,e.ips=n,e.log=o.log=R),!1===g&&R.info({req:e},"incoming request");var w=e.url.indexOf("?"),v=s(w>-1?e.url.slice(w+1):""),S=new t.Request(r,e,v,e.headers,R,k,n,c),C=new t.Reply(o,t,S,R);!0!==u&&null===t.onResponse||h(C),null!==t.onRequest?hookRunner(t.onRequest,hookIterator,S,C,middlewareCallback):middlewareCallback(null,S,C)}}function validateBodyLimitOption(e){if(void 0!==e&&(!Number.isInteger(e)||e<=0))throw new TypeError(`'bodyLimit' option must be an integer > 0. Got '${e}'`)}function middlewareCallback(e,o,r){!0!==r.sent&&(null==e?null!==r.context._middie?r.context._middie.run(o.raw,r.res,r):onRunMiddlewares(null,null,null,r):r.send(e))}function getTrustProxyFn(e){const o=e.trustProxy;if("function"==typeof o)return o;if(!0===o)return function(){return!0};if("number"==typeof o)return function(e,r){return r<o};if("string"==typeof o){const e=o.split(",").map(e=>e.trim());return proxyAddr.compile(e)}return proxyAddr.compile(o||[])}module.exports={buildRouting:buildRouting,validateBodyLimitOption:validateBodyLimitOption};